[{"file": "1601.00455.tex", "nexttext": "\n\\par\\noindent\nwith $s^{(T)}_j$ being a state function of the series of states of the cell $j$ up to \\texttt{T} :\n\n", "itemtype": "equation", "pos": 4499, "prevtext": "\n\n\\catchline{}{}{}{}{} \n\n\\markboth{Alonso-Sanz and Adamatzky}{ACTIN AUTOMATA WITH MEMORY}\n\n\\title{ ACTIN AUTOMATA WITH MEMORY}\n\n\n\n\\author{Ram\\'on Alonso-Sanz}\n\n\n\n\\address{Technical University of Madrid, ETSIA\\,(Estadistica,GSC)\\\\\n\n\n\n ramon.alonso@upm.es}\n\n\n\n\\author{Andy Adamatzky}\n\\address{University of the West of England, Bristol, UK. \\\\\n\n\n andrew.adamatzky@uwe.ac.uk}\n\\maketitle\n \n\\begin{abstract}\nActin is a globular protein which forms long polar filaments in eukaryotic. The actin filaments play roles of cytoskeleton, motility units , information processing and learning.  We model actin filament as a double chain of finite state machines, nodes, which take states `0' and `1'. The states are abstractions of absence and presence of a sub-threshold charge on an actin units corresponding to the nodes. All nodes update their state in parallel in discrete time. A node updates its current state depending on states of two closest neighbours in the node chain and two closest neighbours in the complementary chain. Previous models of actin automata considered momentary state transitions of nodes. We enrich the actin automata model by assuming that states of nodes depends not only on the current states of neighbouring node but also on their past states. Thus, we assess the effect of memory of past states on the dynamics of acting automata. We demonstrate in computational experiments that memory slows down propagation of perturbations, decrease entropy of space-time patterns generated, transforms travelling localisations to stationary oscillators, and stationary oscillations to still patterns.  \n\\end{abstract}\n\n\\keywords{Actin, automata, polymers, dynamics, memory} \n\n\\section{Introduction}\n\nActin is a globular protein presented as intracellular, cytoskeleton, filaments  in eukariotic cells  from unicellular organisms to plants and animals.   Actin filaments, together with  tubule microtubule filaments, are not only key components responsible for coordinated motility of cells but are `nervous system' of the cells. The actin and tubule filaments process information and implement learning~\\cite{hameroff1988coherence, rasmussen1990computational, ludin1993neuronal, conrad1996cross, tuszynski1998dielectric, priel2006dendritic, debanne2004information, priel2010neural, jaeken2007new}.  Disfunction in actin assembly or the actin association with other intracellular components leads to psychiatric and neurological disorders~\\cite{van1990major, fiala2002dendritic, persico2006searching, sekino2007role, van2010synapse, kojima2007synaptic}. Therefore, by uncovering `mechanics' of signal/pertubartion propagation on actin filaments we can, in future, develop novel principles of information processing at sub-cellular level, and may be even contribute towards nano medicine based treatments of neurological disorders.\n\nComputational models tubulin microtubules has been developed in 1990s and used to demonstrate that computation could be implemented in tubulin protofilaments by classical and quantum means~\\cite{rasmussen1990computational, hameroff1992models, janmey, hameroff}. Less attention was paid to actin double helix filaments, despite importance of the actin in learning and information pre-processing as might be hinted by pre-dominant presence of actin networks in synapses~\\cite{fifkova1982cytoplasmic, kim1999role, dillon2005actin, cingolani2008actin}.  Previously  we proposed a model of  actin filaments as two chains of one-dimensional binary-state semi-totalistic automaton arrays~\\cite{aadamatzky}. We analysed the complete rule space of actin automata using integral characteristics of space-time configurations generated by these rules and compute state transition rules that support travelling and mobile localizations. We found that some properties of actin automata rules may be predicted using Shannon entropy, activity and incoherence of excitation between the polymer chains. We also shown that it is possible to infer whether a given rule supports travelling or stationary localizations by looking at ratios of excited neighbours that are essential for generations of the localizations.  \n\n\n\n\n\n\n \n \n \\section{Automata with memory}\n\n\nConventional CA are memoryless\\,: i.e., the new\nstate of a cell depends on the neighborhood configuration solely at the\npreceding time step. The standard framework of CA  can be extended by  implementing memory \n capabilities in cells\\,\\,\\cite{alonso2011discrete,alonso2006elementary,alonso2010One-dimensional}\\,: \n\n", "index": 1, "text": "$$\\sigma^{(T+1)}_{i}=\\phi\\big(\\{{s}^{(T)}_{j}\\}\\in\\mathcal{N}_{i}{\\big )},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\sigma^{(T+1)}_{i}=\\phi\\big{(}\\{{s}^{(T)}_{j}\\}\\in\\mathcal{N}_{i}{\\big{)}},\" display=\"block\"><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mi>\u03d5</mi><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><mrow><mo stretchy=\"false\">{</mo><msubsup><mi>s</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">}</mo></mrow><mo>\u2208</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udca9</mi><mi>i</mi></msub><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\\par\n Thus in CA with memory,  while the mappings $\\phi$ remain unaltered, historic memory of all past iterations is \nretained by featuring each cell as a summary of its past states. So to say, cells $canalize$ memory to the map $\\phi$. \n\\par\nMemory \\eqref{summary} may be implemented as majority memory, i.e., the most frequent (mode) state\\,:\n\n", "itemtype": "equation", "pos": 4689, "prevtext": "\n\\par\\noindent\nwith $s^{(T)}_j$ being a state function of the series of states of the cell $j$ up to \\texttt{T} :\n\n", "index": 3, "text": "\\begin{equation}\\label{summary}\n{s}^{(T)}_{j}={s}\\big(\\sigma^{(1)}_{j},\\ldots,\\sigma^{(T-1)}_{j}, \\sigma^{(T)}_{j}\\big) \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"{s}^{(T)}_{j}={s}\\big{(}\\sigma^{(1)}_{j},\\ldots,\\sigma^{(T-1)}_{j},\\sigma^{(T)%&#10;}_{j}\\big{)}\" display=\"block\"><mrow><msubsup><mi>s</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><msubsup><mi>\u03c3</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msubsup><mi>\u03c3</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>\u03c3</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n with $~s^{(T)}_{i}$=$\\sigma^{(T)}_{i}$ in case of a tie: $card\\{1\\}=card\\{0\\}$\\,.\n\\par\nAt variance with the unlimited memory implementation in \\eqref{modememory}\\,, \nthe length of the trailing memory may be limited to the last $\\tau$ time-steps. \n\n", "itemtype": "equation", "pos": 5170, "prevtext": "\n\\par\n Thus in CA with memory,  while the mappings $\\phi$ remain unaltered, historic memory of all past iterations is \nretained by featuring each cell as a summary of its past states. So to say, cells $canalize$ memory to the map $\\phi$. \n\\par\nMemory \\eqref{summary} may be implemented as majority memory, i.e., the most frequent (mode) state\\,:\n\n", "index": 5, "text": "\\begin{equation}\\label{modememory}\n \\, s^{(T)}_{i}=mode(\\sigma^{(1)}_{i},\\ldots,\\sigma^{(T)}_{i})\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\,s^{(T)}_{i}=mode(\\sigma^{(1)}_{i},\\ldots,\\sigma^{(T)}_{i})\" display=\"block\"><mrow><msubsup><mpadded lspace=\"1.7pt\" width=\"+1.7pt\"><mi>s</mi></mpadded><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\n\\par\nThe shortest operative trailing length is that of $\\tau=3$\\,:\n\n", "itemtype": "equation", "pos": 5531, "prevtext": "\n with $~s^{(T)}_{i}$=$\\sigma^{(T)}_{i}$ in case of a tie: $card\\{1\\}=card\\{0\\}$\\,.\n\\par\nAt variance with the unlimited memory implementation in \\eqref{modememory}\\,, \nthe length of the trailing memory may be limited to the last $\\tau$ time-steps. \n\n", "index": 7, "text": "\\begin{equation}\\label{taumodememory}\ns^{(T)}_{i}=mode(\\sigma^{(T-\\tau+1)}_{i},\\ldots,\\sigma^{(T-2)}_{i},\\sigma^{(T-1)}_{i},\\sigma^{(T)}_{i})\\,.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"s^{(T)}_{i}=mode(\\sigma^{(T-\\tau+1)}_{i},\\ldots,\\sigma^{(T-2)}_{i},\\sigma^{(T-%&#10;1)}_{i},\\sigma^{(T)}_{i})\\,.\" display=\"block\"><mrow><mrow><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>T</mi><mo>-</mo><mi>\u03c4</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\nwith initial assignations\\,: $~s^{(1)}_{i}$=$\\sigma^{(1)}_{i}$,  $~s^{(2)}_{i}$=$\\sigma^{(2)}_{i}$\\,.\n\\par \nKeeping track of the states of the last $\\tau$ time-steps  demands $\\tau$ extra bits per cell to store\ntheir corresponding state values. To avoid this drawback, past state values can be weighted in such a\nway that only the accumulated memory charge needs to be stored.  \nThus, for example, historic memory can be weighted by applying a geometric discounting process\nin which the state $\\sigma ^{(T-\\tau)}_{i}$, obtained $\\tau$ time steps\nbefore the last round, is actualized to  $\\alpha ^{\\tau}\\sigma\n^{(T-\\tau)}_{i}$, $\\alpha$ being the \\textit{memory factor} lying in the [0,1]\ninterval. This well known mechanism fully takes into account the last round $(\\alpha\n^{0}=1)$, and tends to \\textit{forget} the older rounds. Thus, \n\n\n", "itemtype": "equation", "pos": 5759, "prevtext": "\n\n\\par\nThe shortest operative trailing length is that of $\\tau=3$\\,:\n\n", "index": 9, "text": "\\begin{equation}\\label{taumodememory-}\ns^{(T)}_{i}=mode(\\sigma^{(T-2)}_{i},\\sigma^{(T-1)}_{i},\\sigma^{(T)}_{i})\\,.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"s^{(T)}_{i}=mode(\\sigma^{(T-2)}_{i},\\sigma^{(T-1)}_{i},\\sigma^{(T)}_{i})\\,.\" display=\"block\"><mrow><mrow><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\n\\par\n Consequently, only one  number per cell ($\\omega_i$) needs to be stored. This positive property is accompanied by the drawback\nthat it computes with real numbers, which is not in the realm\nof CA, that claims for integer arithmetics. \n\\par \n    Every cell will be featured first by the weighted mean ($m$)  of all its past\nstates, so the memory charge at  time-step $T$ is\\,: \n\\par\n\n\n\n", "itemtype": "equation", "pos": 6727, "prevtext": "\nwith initial assignations\\,: $~s^{(1)}_{i}$=$\\sigma^{(1)}_{i}$,  $~s^{(2)}_{i}$=$\\sigma^{(2)}_{i}$\\,.\n\\par \nKeeping track of the states of the last $\\tau$ time-steps  demands $\\tau$ extra bits per cell to store\ntheir corresponding state values. To avoid this drawback, past state values can be weighted in such a\nway that only the accumulated memory charge needs to be stored.  \nThus, for example, historic memory can be weighted by applying a geometric discounting process\nin which the state $\\sigma ^{(T-\\tau)}_{i}$, obtained $\\tau$ time steps\nbefore the last round, is actualized to  $\\alpha ^{\\tau}\\sigma\n^{(T-\\tau)}_{i}$, $\\alpha$ being the \\textit{memory factor} lying in the [0,1]\ninterval. This well known mechanism fully takes into account the last round $(\\alpha\n^{0}=1)$, and tends to \\textit{forget} the older rounds. Thus, \n\n\n", "index": 11, "text": "\\begin{equation}\\label{eq:omegaeq}\n\\omega^{(T)}_{i}(\\sigma ^{(1)}_{i},\\ldots ,\\sigma ^{(T)}_{i}) = \n\\sigma^{(T)}_{i} + \\displaystyle {\\sum^{T-1}_{\\tau=0}\\alpha ^{\\tau}\\sigma^{(T-\\tau)}_{i}} \n= \\sigma^{(T)}_{i} + \\alpha \\omega^{(T-1)}_{i}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\omega^{(T)}_{i}(\\sigma^{(1)}_{i},\\ldots,\\sigma^{(T)}_{i})=\\sigma^{(T)}_{i}+%&#10;\\displaystyle{\\sum^{T-1}_{\\tau=0}\\alpha^{\\tau}\\sigma^{(T-\\tau)}_{i}}=\\sigma^{(%&#10;T)}_{i}+\\alpha\\omega^{(T-1)}_{i}\" display=\"block\"><mrow><mrow><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>\u03c4</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><msup><mi>\u03b1</mi><mi>\u03c4</mi></msup><mo>\u2062</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mi>\u03c4</mi></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow></mrow></mrow><mo>=</mo><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\\par\nThe trait state \\textit{s} is obtained by\ncomparing $m$ to the landmark  0.5  (if $\\sigma\\in\\{0,1\\}$), assigning the last state in case \nof an equality to this value, so that\\, :\\vspace{-.25cm}\n\n\n", "itemtype": "equation", "pos": 7370, "prevtext": "\n\n\\par\n Consequently, only one  number per cell ($\\omega_i$) needs to be stored. This positive property is accompanied by the drawback\nthat it computes with real numbers, which is not in the realm\nof CA, that claims for integer arithmetics. \n\\par \n    Every cell will be featured first by the weighted mean ($m$)  of all its past\nstates, so the memory charge at  time-step $T$ is\\,: \n\\par\n\n\n\n", "index": 13, "text": "\\begin{equation}\\label{eq:meq}\nm^{(T)}_{i}= {\\displaystyle\\frac{{{\\omega^{(T)}_{i}}} }{\\Omega(T) }}\\hspace{0.15cm}\\,,\\hspace{0.25cm}\n~~\\hbox{with}~~ \\Omega{(T)}= {1+ \\displaystyle \\sum^{T-1}_{t=1}\\alpha ^{T-t}}  \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"m^{(T)}_{i}={\\displaystyle\\frac{{{\\omega^{(T)}_{i}}}}{\\Omega(T)}}\\hskip 4.2679%&#10;13pt\\,,\\hskip 7.113189pt~{}~{}\\hbox{with}~{}~{}\\Omega{(T)}={1+\\displaystyle%&#10;\\sum^{T-1}_{t=1}\\alpha^{T-t}}\" display=\"block\"><mrow><mrow><msubsup><mi>m</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mpadded width=\"+6pt\"><mfrac><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mpadded></mrow><mo rspace=\"16.2pt\">,</mo><mrow><mrow><mpadded width=\"+6.6pt\"><mtext>with</mtext></mpadded><mo>\u2062</mo><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>T</mi><mo>-</mo><mn>1</mn></mrow></munderover><msup><mi>\u03b1</mi><mrow><mi>T</mi><mo>-</mo><mi>t</mi></mrow></msup></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\n\\par \nThe choice of the memory factor $\\alpha$ tunes the memory effect: the limit case\n $\\alpha =1$ corresponds to a memory with equally weighted records \n($full$ memory, equivalent to unlimited trailing \\textit{majority} memory), whereas $\\alpha \\ll 1$ intensifies the contribution\n of the most recent states and diminishes the contribution of the more remote states (short-term  \n memory). The choice $\\alpha = 0$ leads to the ahistoric model. Due to the rounding \\eqref{rounding}\\,,\n $\\alpha$-memory is not effective if $\\alpha \\le 0.5$\\,.\n\n\n\\par\n\n\\section{Actin automata  with memory}\n\n\\begin{figure}[!tbp]\n \\centering\n \\subfigure[]{\\includegraphics[width=0.30\\textwidth]{Actinfiber}}\n \\subfigure[]{\\includegraphics[width=0.69\\textwidth]{scheme}}\n\\caption{Schematic digram of F-actin strands. (a)~Structure of actin detected by X-ray fiber diffraction. Adapted from~\\cite{oda2009nature}. (b)~Actin automata.}\n \\label{scheme}\n \\end{figure}\n \n Each G-actin molecule (except those at the ends of F-actin strands) has four neighbours, as demonstrated \n in Fig.~\\ref{scheme}. An actin automaton consists of two chains $\\sigma$ and $[\\sigma]$ of semi-totalistic\n  binary-state automata. Each automaton takes two states `0' (resting) and `1' (excited). \n\n \n\n\\par\nConventional (Markovian) actin CA rules have been proposed to be implemented in two coupled layers (noted $\\sigma$ and\n$[\\sigma]$) with semitotalistic rules~\\cite{aadamatzky}\\,:\n\n\\begin{subequations} \\label{actinca}\n\n", "itemtype": "equation", "pos": 7798, "prevtext": "\n\\par\nThe trait state \\textit{s} is obtained by\ncomparing $m$ to the landmark  0.5  (if $\\sigma\\in\\{0,1\\}$), assigning the last state in case \nof an equality to this value, so that\\, :\\vspace{-.25cm}\n\n\n", "index": 15, "text": "\\begin{equation}\\label{rounding}\ns^{(T)}_{i} ={\\cal H}(m_{i}^{(T)})=\\left \\{ \n\\begin{array}{lll}\n1                &if& m^{(T)}_{i} > 0.5 \\\\ \n\\sigma^{(T)}_{i} &if& m^{(T)}_{i} = 0.5 \\\\ \n0                &if& m^{(T)}_{i} < 0.5       \n\\end{array}\\equiv\n\\begin{array}{lll}\n 2\\omega^{(T)}_{i} > \\Omega{(T)} \\\\ \n 2\\omega^{(T)}_{i} = \\Omega{(T)} \\\\ \n 2\\omega^{(T)}_{i} < \\Omega{(T)} \\,.\n\\end{array}\\right .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"s^{(T)}_{i}={\\cal H}(m_{i}^{(T)})=\\left\\{\\begin{array}[]{lll}1&amp;if&amp;m^{(T)}_{i}&gt;%&#10;0.5\\\\&#10;\\sigma^{(T)}_{i}&amp;if&amp;m^{(T)}_{i}=0.5\\\\&#10;0&amp;if&amp;m^{(T)}_{i}&lt;0.5\\end{array}\\equiv\\begin{array}[]{lll}2\\omega^{(T)}_{i}&gt;%&#10;\\Omega{(T)}\\\\&#10;2\\omega^{(T)}_{i}=\\Omega{(T)}\\\\&#10;2\\omega^{(T)}_{i}&lt;\\Omega{(T)}\\,.\\end{array}\\right.\" display=\"block\"><mrow><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>m</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>m</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>&gt;</mo><mn>0.5</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>m</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mn>0.5</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>m</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>&lt;</mo><mn>0.5</mn></mrow></mtd></mtr></mtable><mi/></mrow><mo>\u2261</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo>&gt;</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>\u03c9</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo>&lt;</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></mtd><mtd/><mtd/></mtr></mtable></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\\end{subequations}\n\\par \nWith the subrules $(\\phi,\\psi)$ expressed in binary and decimal forms as \n$\\phi=(\\beta_0\\beta_1\\beta_2\\beta_3\\beta_4)\\equiv \\displaystyle {\\sum^{4}_{i=0}2^{4-i} \\beta_i} $\\,, and\n$\\psi=(\\gamma_0\\gamma_1\\gamma_2\\gamma_3\\gamma_4)\\equiv \\displaystyle {\\sum^{4}_{i=0}2^{4-i} \\gamma_i} $\\,.\n\n\\par\nActin CA rules with memory will be implemented from   \\eqref{actinca} as\\,:\n\n\\begin{subequations} \\label{mactinca}\n\n", "itemtype": "equation", "pos": 9690, "prevtext": "\n\n\\par \nThe choice of the memory factor $\\alpha$ tunes the memory effect: the limit case\n $\\alpha =1$ corresponds to a memory with equally weighted records \n($full$ memory, equivalent to unlimited trailing \\textit{majority} memory), whereas $\\alpha \\ll 1$ intensifies the contribution\n of the most recent states and diminishes the contribution of the more remote states (short-term  \n memory). The choice $\\alpha = 0$ leads to the ahistoric model. Due to the rounding \\eqref{rounding}\\,,\n $\\alpha$-memory is not effective if $\\alpha \\le 0.5$\\,.\n\n\n\\par\n\n\\section{Actin automata  with memory}\n\n\\begin{figure}[!tbp]\n \\centering\n \\subfigure[]{\\includegraphics[width=0.30\\textwidth]{Actinfiber}}\n \\subfigure[]{\\includegraphics[width=0.69\\textwidth]{scheme}}\n\\caption{Schematic digram of F-actin strands. (a)~Structure of actin detected by X-ray fiber diffraction. Adapted from~\\cite{oda2009nature}. (b)~Actin automata.}\n \\label{scheme}\n \\end{figure}\n \n Each G-actin molecule (except those at the ends of F-actin strands) has four neighbours, as demonstrated \n in Fig.~\\ref{scheme}. An actin automaton consists of two chains $\\sigma$ and $[\\sigma]$ of semi-totalistic\n  binary-state automata. Each automaton takes two states `0' (resting) and `1' (excited). \n\n \n\n\\par\nConventional (Markovian) actin CA rules have been proposed to be implemented in two coupled layers (noted $\\sigma$ and\n$[\\sigma]$) with semitotalistic rules~\\cite{aadamatzky}\\,:\n\n\\begin{subequations} \\label{actinca}\n\n", "index": 17, "text": "\\begin{align}\n\\sigma^{(T+1)}_{i} =\\left \\{ \n\\begin{array}{lll}\\vspace{0.25cm}\n\\phi(\\sigma^{(T)}_{i-1}+\\sigma^{(T)}_{i+1}+[\\sigma^{(T)}_{i}]+[\\sigma^{(T)}_{i-1}]) &if& \\sigma^{(T)}_{i}=0 \\\\ \n\\psi(\\sigma^{(T)}_{i-1}+\\sigma^{(T)}_{i+1}+[\\sigma^{(T)}_{i}]+[\\sigma^{(T)}_{i-1}]) &if& \\sigma^{(T)}_{i}=1    \n\\end{array}\\right .\n\\\\ \\vspace{0.5cm}\n[\\sigma^{(T+1)}_{i}] =\\left \\{ \n\\begin{array}{lll}\\vspace{0.25cm}\n\\phi([\\sigma^{(T)}_{i-1}]+[\\sigma^{(T)}_{i+1}]+\\sigma^{(T)}_{i}+\\sigma^{(T)}_{i+1}) &if& [\\sigma^{(T)}_{i}]=0 \\\\ \n\\psi([\\sigma^{(T)}_{i-1}]+[\\sigma^{(T)}_{i+1}]+\\sigma^{(T)}_{i}+\\sigma^{(T)}_{i+1}) &if& [\\sigma^{(T)}_{i}]=1    \n\\end{array}\\right .\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sigma^{(T+1)}_{i}=\\left\\{\\begin{array}[]{lll}\\vspace{0.25cm}\\phi%&#10;(\\sigma^{(T)}_{i-1}+\\sigma^{(T)}_{i+1}+[\\sigma^{(T)}_{i}]+[\\sigma^{(T)}_{i-1}]%&#10;)&amp;if&amp;\\sigma^{(T)}_{i}=0\\\\&#10;\\psi(\\sigma^{(T)}_{i-1}+\\sigma^{(T)}_{i+1}+[\\sigma^{(T)}_{i}]+[\\sigma^{(T)}_{i%&#10;-1}])&amp;if&amp;\\sigma^{(T)}_{i}=1\\end{array}\\right.\" display=\"inline\"><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\vspace{0.5cm}[\\sigma^{(T+1)}_{i}]=\\left\\{\\begin{array}[]{lll}%&#10;\\vspace{0.25cm}\\phi([\\sigma^{(T)}_{i-1}]+[\\sigma^{(T)}_{i+1}]+\\sigma^{(T)}_{i}%&#10;+\\sigma^{(T)}_{i+1})&amp;if&amp;[\\sigma^{(T)}_{i}]=0\\\\&#10;\\psi([\\sigma^{(T)}_{i-1}]+[\\sigma^{(T)}_{i+1}]+\\sigma^{(T)}_{i}+\\sigma^{(T)}_{%&#10;i+1})&amp;if&amp;[\\sigma^{(T)}_{i}]=1\\end{array}\\right.\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>\u03c3</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00455.tex", "nexttext": "\n\\end{subequations}\n\nFigure \\ref{fig:damage} shows the effect of memory  up to $T=150$ in two actin rules\nwhen starting at random, i.e.,  the values of sites are initially uncorrelated and chosen\n at random to be 0 ({\\it blank)} or 1 ({\\it black}) with probability 1/2 in layers of size $n=300$\\,.\n The  pictures  show  also the differences in patterns  resulting  from  reversing the initial center site value. The\n{\\it perturbed}  region  is enhanced with {\\it red} pixels,  corresponding  to  the  site  values  that differed\n among the patterns generated with  the two initial  configurations.\nIn the top frame of Fig.\\,\\ref{fig:damage}\\,, the actin rule R(10,10)\\footnote{R(10,10) is usually referred to as the {\\it parity} rule, where both subrules\nturn out to be the sum of their inputs modulo two. The simple in form {\\it parity} rule has proven to be highly chaotic in CA scenarios.} is shown with ahistoric (left),  \n$\\tau=3$ and $\\tau=100$-majority memory models. \nIn the bottom frame, the rule R(14,9) is considered,  with  ahistoric (left),  $\\alpha=0.51$ and $\\alpha=0.9$ memory models. The inertial (or conservative) effect that memory \nexerts  tends to slow down propagation of growing patterns (perturbations, excitations). This is `slowing down' is manifested by apparent `shrinking of patterns' no the space-time configurations.  This is so even with low memory charge, either in the form $\\tau=3$ or as $\\alpha=0.51$, but becomes\nfully appreciable with high memory (either $\\tau=100$, or $\\alpha=0.90$). In correspondence, the perturbation spreading in Fig.\\,\\ref{fig:damage} becomes highly restrained as the\n memory charge increases, so that with high memory charge it remains confined to the proximity of its initial seed. \n\n\n\\begin{figure}[!tbp]\\centering\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-10-10-damage.pdf}\\par\\medskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-14-09-damage.pdf}\n\\caption{Dynamics in two actin rules up to $T=150$\\,. Top\\,: Rule R(10,10). Ahistoric (left) and  majority memory models.\nBottom\\,: Rule R(14,9). Ahistoric (left) and $\\alpha$-memory models.}\\label{fig:damage}\n\\end{figure}\n\n\n\\par\nFigure \\ref{fig:R-14-9} shows the effect of memory  up to $T=1000$ in the actin rule (14,9) when starting at random in layers of size 1500\\,.\nIn the $\\alpha$ memory type (top snapshots), even the very low memory charge  $\\alpha=0.51$ dramatically alters the conventional (ahistoric) spatio-temporal \npatterns, with  stationary localisations becoming dominating, whereas when $\\alpha$ increases to 0.6 a sophisticated spatio-temporal pattern emerges\nwhere travelling glider guns produce gliders, and gliders reflect or annihilate in their collisions. \n\n\nWith majority memory (bottom snapshots), the low memory charge $\\tau=$ induces a {\\it monotonous} transition between from enormous amount of gliders generated\n (so many that space is almost completely filled with them), to situation when few stationary glider guns generate gliders with low frequency, \ngliders collide and in most cases annihilate. When $\\tau$ reaches 8 only stationary (breathing) localisations persist.\n\n\\begin{figure}[!tbp]\\centering\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-14-09-alpha.pdf}\\par\\bigskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-14-09-majority.pdf}\n\\caption{Dynamics in the rule R(14,9). Top\\,: $\\alpha$-memory, Bottom\\,: majority memory.}\\label{fig:R-14-9}\n\\end{figure}\n\n\n\\par \nThe richness of the effect of memory may be envisaged in Fig\\,.\\ref{fig:R-14-9-oness}\\,, where rule R(14,9) starts from one site active seed. Sophisticated \npatterns emerge bith the $\\alpha$ and majority scenarios shown in   Fig\\,.\\ref{fig:R-14-9-oness}\\,.\n\\begin{figure}[!tbp]\\centering\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-14-09-alpha-single-seed.pdf}\\par\\bigskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{R-14-09-majority-single-seed.pdf}\n\\caption{Dynamics in the rule R(14,9) starting from one site active seed. Top\\,: $\\alpha$-memory, Bottom\\,: majority memory.}\\label{fig:R-14-9-oness}\n\\end{figure}\n\n\n\\section{Global characteristics}\n\\par \nFollowing the reference \\cite{aadamatzky}, the following integral measures are calculated on the spatio-temporal pattern $M=(m_{ti})$, where $m_{ti}$ is the state of the \ncell $i$ at time-step $t$\\,:\n\\begin{itemize}\n\\item Shannon entropy\\,: $H=-\\displaystyle\\sum_{w \\in W} \\nu(w)/\\eta \\ln(\\nu(w)/\\eta)$\n\\par Where $\\eta$ is the sum of the $W$ possible kinds of $3\\times3$ configurations found in $M$\\,, and $\\nu(w)$ is the number of times that the configuration $w$ is found in $M$\\,.\n\\item Simpson diversity\\,: $D=1-\\displaystyle \\sum_{w \\in W}\n (\\nu(w)/\\eta)^2$\n\\end{itemize}\n\n\\par\nFigure \\ref{fig:H-D-Number} shows the entropy ($H$) versus diversity ($D$) in the left frames, and  the distribution of the number of rules ($\\#$) of given entropy.\n Ahistoric (black-marked) and $\\tau$-majority memory (red-marked) models are in runs up to $T=1000$ are considered in Fig.\\,\\ref{fig:H-D-Number}\\,: Top\\,: $\\tau=3$, \nMiddle\\,: $\\tau=100$, Bottom\\,: $\\tau=1000$\\,. Memory seems not to dramatically alter the form of the $H$-$D$ plots, at least at a first visual glance in the left panels of \nFig.\\,\\ref{fig:H-D-Number}\\,, where the data from the ahistoric and memory simulations appear rather masked. At variance with this, memory appears to notably modify the distribution \nof the number of rules corresponding to the different levels of entropy in the\nright panels. Thus, comparing the ahistoric (or even the low level $\\tau=3$ memory charge) to the full memory implementation in the bottom-right panel, it becomes apparent that\nthe highest levels of entropy, close to 6.0, become with no rules filling them in the full memory implementation, whereas most of the rules correspond to the middle level \nH-interval [2.5,3.5]\\,, an interval fairly low represented in the ahistoric scenario. Let us take the example of rule R(10,10). In the ahistoric model, R(10,10) achieves\nthe entropy $H=6.233$, very close to the maximum attainable $H^*= \\ln 2^9 =6.238$\\,. With $\\tau=3$ majority memory the entropy of R(10,10) is lowered to $H=6.005$, and with\nfull memory to $H=5.335$\\,. In the scenarios of Fig.\\,\\ref{fig:H-D-Number}\\, the actin rule R(14,9)  achieves in ahistoric model the entropy 3.342, which atypically increases, \nalbeit very little, to 3.835 with $\\tau=3$, then decreases to 3.199 with full memory.\n\n\\begin{figure}[!tbp]\\centering\n\\includegraphics[width=1.0\\textwidth,draft=false]{entrodivernumber-tau1-3.pdf}\\par\\bigskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{entrodivernumber-tau1-100.pdf}\\par\\bigskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{entrodivernumber-tau1-1000.pdf}\\par\\bigskip\n\\includegraphics[width=1.0\\textwidth,draft=false]{entrodivernumber-tau1-1000.pdf}\n\\caption{Entropy ($H$) versus diversity ($D$) (left) and entropy ($H$) versus number of rules ($\\#$) (right) plots. \nAhistoric (black) and $\\tau$- majority (red) memory models. Top\\,: $\\tau=3$; Middle\\,: $\\tau=100$; Bottom\\,: $\\tau=1000$\\,. }\\label{fig:H-D-Number}\n\\end{figure}\n\n\n\\section{Localizations}\n\nWe provide additional section on localisations in acting automata with memory for the following reasons. \nActin filaments are polyelectrolytes surrounded by counter-ions,  the filaments  therefore possess the capacity of transmitting signals or sustaining ionic conductances~\\cite{cantiello1991osmotically, tuszynski2004ionic}.  Actin filaments, being rod-like polymers, are particularly likely to have counter-ions adsorbed to their surface  at high ionic concentrations, such as those in the intra-neuronal environment, ions would be expected to densely adsorb to the surface of actin filaments due to complementary charges~\\cite{priel2010neural}. The actin filaments are also capable for supporting propagation of discrete breathers (non-linear localised modes of excitation) as a  consequence of nonlinearity in pure, translationally invariant systems of any dimensionality (similar to intrinsic localized modes in anharmonic crystals)~\\cite{flach1998discrete,kavitha2013nano, kovaleva2012analytical}. The solitonic signals propagating on actin networks are capable of realising collision-based logical circuits~\\cite{adamatzky2001computing, badamatzky, adamatzky2004collision}. \n\n\nWe consider three types of localisations: \n\\begin{itemize}\n\\item glider: travelling localisation, analogues to voltage solitons in cable equation model of actin~\\cite{tuszynski2004ionic}, and discrete travelling breathers~\\cite{flach1998discrete}. \n\\item still life: still stationary patterns, which repeats itself in every time, analogues to a standing wave, or localised excitation in vibrating granular material~\\cite{umbanhowar1996localized}\n\\item oscillator: oscillating stationary localisation, a pattern which repeats itself in a finite number of evolution steps; a glider also repeated itself but it is not stationary), stationary breather~\\cite{flach1998discrete} or immobile voltage soliton~\\cite{tuszynski2004ionic}.\n\\end{itemize}\nGlider and still life are oscillators as well: a glider is translating oscillator and a still life is stationary oscillator period 1. We compare localisations generated by seeds of five scells in automata without memory and with memory.  Given a rule $\\mathcal R$ we say `glider becomes oscillator' if an automaton governed by rule $\\mathcal R$ evolves seed $s$  into a glider when it does not have memory and the automaton evolves the seed $s$ into a breather when the rule  $\\mathcal R$ is enriched with memory. \n\n\n\\begin{figure}[!tbp]\\centering\n\n\\includegraphics[width=0.7\\textwidth,draft=false]{R_6_20_Spreading2Stilllife.pdf}\n\n\n\\caption{Spreading pattern is localised into a still life. Transformation of localisations by majority memory. In each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with memory (right).\n Times goes down.  Rules are indicated above the space-time configurations. Seeds are indicated in the label of the left (ahistoric) simulation.}\n\\label{stilllife1}\n\\end{figure}\n\nAs we discussed before, introduction of memory typically `shrinks'  patterns. In some rules, e.g. $R(6,20)$ the spreading pattern is shrunk to a still life occupying just one cell (Fig.~\\ref{stilllife1}). \n\n\n\\begin{figure}[!tbp]\\centering\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_4_5_Oscillator_Preserved+}}\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_4_5_OscillatorFrequencyChange+}}\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_4_5_OscillatorShapeChange+}}\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_4_5_OscillatorAnnihilated+}}\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_4_4_OscillatorEmerges+}}\n\n\\subfigure[]{\\includegraphics[width=0.70\\textwidth,draft=false]{R_6_16_breather2stilllife+}}\n\\caption{Transformation of oscillators by $\\tau=3$ majority memory. In each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with memory (right). Times goes down.  Rules are indicated above the space-time configurations. \n(a)~Oscillator is preserved.\n(b )~Oscillator remains yet frequency of its oscillation (breathing) decreases.\n(c )~Pattern of oscillations changes. \n(d)~Oscillator is annihilated by memory.\n(e)~Oscillator emerges assisted by memory.\n(f)~Oscillator is transformed into still life.\nSeeds are indicated in the label of the left (ahistoric) simulation.\n}\n\\label{breathers}\n\\end{figure}\n\nOscillating stationary localisation is preserved (Fig.~\\ref{breathers}a), sometimes with decrease of oscillation frequency  (Fig.~\\ref{breathers}b) or \nchange of the oscillations pattern (Fig.~\\ref{breathers}c) or annihilated  (Fig.~\\ref{breathers}d).  In some rules oscillators can emerge, when state-transition rules are enriched with memory, e.g. in  (Fig.~\\ref{breathers}d) a seed produces an extinguishing pattern in memoryless automaton yet it produces oscillator when majority memory is introduced.  In rule $R(6,16)$ introduction of memory converts oscillator into a still life. \n\n\\begin{figure}[!tbp]\\centering\n\n\\subfigure[]{\\includegraphics[width=0.8\\textwidth,draft=false]{R_7_4_glider2stationary+}}\n\n\\subfigure[]{\\includegraphics[width=0.8\\textwidth,draft=false]{R_5_6_glider2sierpinski+}}\n\n\\subfigure[]{\\includegraphics[width=0.8\\textwidth,draft=false]{R_6_4_glider2nothing+}}\n\n\\subfigure[]{\\includegraphics[width=0.8\\textwidth,draft=false]{R_7_4_gliders2gliderbreather+}}\n\n\\subfigure[]{\\includegraphics[width=0.8\\textwidth,draft=false]{R_7_4_glider2twobreathers+}}\n \n\\caption{Transformation of gliders by  $\\tau=3$ majority memory. In each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with memory (right). Times goes down.  Rules are indicated above the space-time configurations. \n(a)~Glider becomes oscillator.\n(b)~Glider becomes a propagating and expanding pattern (Sierpinski gasket in this  particular example).\n(c )~Glider is annihilated.\n(d)~Glider propagating left is transformed into larger slow moving glider and glider propagating right becomes a oscillator.\n(e)~Glider `splits' into two breathers.}\n\\label{gliders}\n\\end{figure}\n\n\nGliders are transformed as follows (Fig.~\\ref{gliders}). Glider can be transformed to a oscillator  (Fig.~\\ref{gliders}a), or expanding pattern (we can say that the glider was exploded by memory, Fig.~\\ref{gliders}b), or annihilated  (Fig.~\\ref{gliders}c).  In some cases, where a seed generates two gliders -- one travels left and another travels right -- one of the gliders becomes larger and slow moving glider while another glider is transformed into an oscillator (Fig.~\\ref{gliders}d); or, a single gliders is transformed into two oscillators with different patterns of oscillations \n (Fig.~\\ref{gliders}e).\n \n \n \\begin{figure}[!tbp]\\centering\n\\includegraphics[width=0.98\\textwidth,draft=false]{R_14_24_Pattern2Gliders+.pdf}\n\\caption{Initial configurations not of the 5-seed type. A spreading pattern is trimmed to gliders. Transformation of gliders by majority memory. In each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with $\\tau=3$-memory (right). Times goes down.  Rules are indicated above the space-time configurations. Seeds\\,:[00110000000000000000000110~,~01100000000000000000001100] \n}\n\\label{gliders2}\n\\end{figure}\n\n\\begin{figure}[!tbp]\\centering\n\\includegraphics[width=0.98\\textwidth,draft=false]{R_6_18_1chain2chains+}\n\\caption{Entrainment. Dynamics of actin chains is asynchronous in rules without memory: still life persists only one chain. When memory is introduced both chains host still lifes.\nIn each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with $\\tau=3$-memory (right). Times goes down.  Rules are indicated above the space-time configurations. }\n\\label{entrainemnt}\n\\end{figure}\n\nIn rare cases, e.g. rule $R(14,24)$  a spreading pattern is converted to two gliders, propagating to the left and to the right. The gliders annihilate when collide (Fig.~\\ref{gliders2}). We can also observe an entrainment phenomenon \n(Fig.~\\ref{entrainemnt}) where a localisation `inhabiting' only one chain in a rule without memory, spreads to the second chain when memory is introduced. \n \n \\begin{figure}[!tbp]\\centering\n\\includegraphics[width=0.5\\textwidth,draft=false]{localisationtransitions}\n\\caption{Memory-induced transformations of localisation.}\n\\label{schemetransitions}\n\\end{figure}\n\nBy undertaking exhaustive analysis of the rules we found that only the following transformations of localisations are possible when state transition rules are enriched with memory (Fig.~\\ref{schemetransitions}). A glider is transformed to  an oscillator. An oscillator is transformed to a still life. In some cases memory preserved gliders, oscillators and still life. Transformations of still lifes to oscillators or glider, and oscillations to gliders have not been observed so far.  Notably, in elementary cellular automata with memory transitions from glider to oscillation to still life, induced by memory, could be found~\\cite{DBLP:journals/fuin/MartinezAA15, martinez2010make, martinez2012complex}. We did not such transitions in actin automata with memory, this could be due to the fact interaction between two one-dimensional automata forming acting filament leads to `inhibition' of glider dynamics and prevents formation of mobile localisations when memory is introduced to node state-transition rules. \n\n\n \n\n\n\n\n\n\n\n\n\n\\section{Discussion}\n\n\n\\begin{figure}[!tbp]\n \\centering\n\\subfigure[]{\\includegraphics[width=0.5\\textwidth]{Occupancy_0_to_1}}\n\\subfigure[]{\\includegraphics[width=0.5\\textwidth]{Occupancy_1_to_1}}\n  \\caption{Dependence of a probability of excitation of a node in actin automaton (a)~supporting travelling \n  localizations and (b)~supporting stationary localizations  on a number of excited neighbours of the node. The plots are calculated for rules R(7,4), R(5,6), R(6,4), R(12,24), which support travelling localisations shown in Figs.~\\ref{gliders}, \n\\ref{gliders2}, \\ref{fig:R-7-4-interactions}, and rules R(6,20), R(4,5), R(4,4), R(6,16), R(6,18), which support stationary localisations shown in Fig.~\\ref{stilllife1}, \\ref{breathers}, \\ref{entrainemnt}.    Solid discs, connected by solid line, show probability of excitation of a resting node, circles,  connected by dashed line, show probability of excitation of an excited node, i.e. of an excited node to remain excited.}\n \\label{travellingpolynomial}\n \\end{figure}\n \nIn our original studies of actin automata (without memory)~\\cite{adamatzky2014actin} we demonstrated, by exhaustive search of localisations over the whole rule space, that rule supports travelling localizations if a resting node excites if it has two or four excited neighbours  and an excited node remains excited if it has no excited neighbours (there are indeed additional modes of excitability necessary to support propagation of the gliders). We also found that a rule supports stationary localizations if a resting node excites if it has three excited neighbours  and an excited node remains excited if it has less than four excited neighbours. Analysing the rules of actin automat with majority, which we used to illustrate transformation of travelling and stationary localisations, we found that two excited neighbours is a necessary prerequisite for a resting node to be excited and for an excited node to remain excited for a rule to support travelling (Fig.~\\ref{travellingpolynomial}a) and stationary (Fig.~\\ref{travellingpolynomial}b) localisations. Second most common occupancy for these rules is three excited neighbours.  \n\n\n\\begin{figure}[!tbp]\\centering\n\\subfigure[]{\\includegraphics[width=0.47\\textwidth,draft=false]{R-7-4-anihilation+.pdf}} \\subfigure[]{\\includegraphics[width=0.47\\textwidth,draft=false]{R-7-4-spatio-travel+.pdf}}\n\\caption{Initial configurations not of the 5-seed type. Interactions of localizations of rule R(7,4) with (right) and without (left) $\\tau=3$ majority memory. (a)~Two gliders collide and annihilate in the result of the collision. (b)~Glider is stopped by oscillator. In each subfigure we see space-time configurations of both actin chains in automata. Seeds\\,:\n(a) [0011100000000000001,0100000000000001110]\\, (b) [11100000000000001,00000010000000111]}\n\\label{fig:R-7-4-interactions}\n\\end{figure}\n\nBy enriching actin automata with memory we demonstrated that when local transitions rules are enriched with memory they generate slower propagation or expanding patterns, generate less `complex', as measured by entropies, space-time configurations. The memory enrichment also leads to transformation of gliders to oscillatory stationary localisations to still stationary localisations.  These  results well complement our previous findings in  abstract analysis of intracellular acting filaments and complement parallel developments, such as extensions of actin automata to  quantum actin automata~\\cite{siccardi2015actin} and cable equations models of voltage solitons in actin~\\cite{siccardi2015boolean}.  Gliders are propagating signals. Stationary localisation are memory --- in a sense of volatile computer memory.  So by varying depth of actin units memory we can force actin filaments either to produce signals --- which compute when collide --- or to act as a memory device.   Basic computing properties of the quantum actin automata --- Boolean logic gates and binary adder~\\cite{siccardi2015actin}, and three valued logic operations~\\cite{cadamatzky} --- have not yet been matched in the actin automata memory. These will topics of our further studies.\n\n Right now we can just demonstrate interactions which can be interpreted in terms of collision-based computing: presence of a localisation indicate logical {\\sc True} and absence --- logical {\\sc False}.   A `classical' annihilation gate $\\langle x, y \\rangle \\rightarrow \\langle  \\overline{x} y,  x \\overline{y}  \\rangle$ is shown in Fig.~\\ref{fig:R-7-4-interactions}a for inputs $x=${\\sc True} and $y=${\\sc False}.  When  $x=${\\sc True} there is a glider travelling right, when  $y=${\\sc True} there is a glider travelling left. If just one glider present in the gate, it continue it movement undisturbed. The trajectory of undisturbed movement of the glider travelling right represents $x \\overline{y}$ and the trajectory of undisturbed movement of the glider travelling left represents $\\overline{x} y$. Travelling localisations, representing data and result of computation can be stopped via stationary oscillators. An example is shown in Fig.~\\ref{fig:R-7-4-interactions}b. Glider travels left. It collides into a oscillator. The oscillator changes its states in the result of collision. Thus travelling data are re-written into stationary data. \n \n \n \\begin{figure}[!tbp]\\centering\n\\subfigure[]{\\includegraphics[width=0.47\\textwidth,draft=false]{R1424alpha055reflection.pdf}} \n\\subfigure[]{\\includegraphics[width=0.47\\textwidth,draft=false]{R1224annihilation}}\n\\caption{Emergence of localisation induced by memory, rule R(12,24). Distance between glider seeds is\n(a)~48 nodes and (b)~51 nodes.  In each subfigure we see space-time configurations of both actin chains in automata without memory (left) and with $\\alpha=0.55$-memory (right). Initially just single node is in state `1'.\nTimes goes down.  Rules are indicated above the space-time configurations.}\n\\label{fig:R14-24-alpha0-055}\n\\end{figure}\n\n \nAnother example of memory-induced emergence of collision-based gates is illustrated in Fig.~\\ref{fig:R14-24-alpha0-055}. In actin automata rule R(14,24) seeds of a single node in state `1' develop into propagating patterns of regular `excitations' of the actin filaments. When memory is introduced the interior of the propagating patterns is `filtered out' and only wave-fronts, i.e. gliders, remain. The gliders reflect and change their phases when a distance between seeds is 48 nodes (Fig.~\\ref{fig:R14-24-alpha0-055}a) and the gliders annihilate when the distance between seeds is 51 nodes (Fig.~\\ref{fig:R14-24-alpha0-055}b).\n\n\n\n\n \n\n\n\\section*{Acknowledgement}\n\nWe acknowledge the financial support of the Future and Emerging Technologies (FET) programme within the Seventh Framework Programme for Research of the European Commission, under the Collaborative project PhyChip, grant agreement number 316366.\n\n\\bibliographystyle{ws-ijbc}\n\\bibliography{bibmactin}\n\n\n", "itemtype": "equation", "pos": 10788, "prevtext": "\n\\end{subequations}\n\\par \nWith the subrules $(\\phi,\\psi)$ expressed in binary and decimal forms as \n$\\phi=(\\beta_0\\beta_1\\beta_2\\beta_3\\beta_4)\\equiv \\displaystyle {\\sum^{4}_{i=0}2^{4-i} \\beta_i} $\\,, and\n$\\psi=(\\gamma_0\\gamma_1\\gamma_2\\gamma_3\\gamma_4)\\equiv \\displaystyle {\\sum^{4}_{i=0}2^{4-i} \\gamma_i} $\\,.\n\n\\par\nActin CA rules with memory will be implemented from   \\eqref{actinca} as\\,:\n\n\\begin{subequations} \\label{mactinca}\n\n", "index": 19, "text": "\\begin{align}\n\\sigma^{(T+1)}_{i} =\\left \\{ \n\\begin{array}{lll}\\vspace{0.25cm}\n\\phi(s^{(T)}_{i-1}+s^{(T)}_{i+1}+[s^{(T)}_{i}]+[s^{(T)}_{i-1}]) &if& s^{(T)}_{i}=0 \\\\ \n\\psi(s^{(T)}_{i-1}+s^{(T)}_{i+1}+[s^{(T)}_{i}]+[s^{(T)}_{i-1}]) &if& s^{(T)}_{i}=1    \n\\end{array}\\right .\n\\\\ \\vspace{0.5cm}\n[\\sigma^{(T+1)}_{i}] =\\left \\{ \n\\begin{array}{lll}\\vspace{0.25cm}\n\\phi([s^{(T)}_{i-1}]+[s^{(T)}_{i+1}]+s^{(T)}_{i}+s^{(T)}_{i+1}) &if& [s^{(T)}_{i}]=0 \\\\ \n\\psi([s^{(T)}_{i-1}]+[s^{(T)}_{i+1}]+s^{(T)}_{i}+s^{(T)}_{i+1}) &if& [s^{(T)}_{i}]=1    \n\\end{array}\\right .\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sigma^{(T+1)}_{i}=\\left\\{\\begin{array}[]{lll}\\vspace{0.25cm}\\phi%&#10;(s^{(T)}_{i-1}+s^{(T)}_{i+1}+[s^{(T)}_{i}]+[s^{(T)}_{i-1}])&amp;if&amp;s^{(T)}_{i}=0\\\\&#10;\\psi(s^{(T)}_{i-1}+s^{(T)}_{i+1}+[s^{(T)}_{i}]+[s^{(T)}_{i-1}])&amp;if&amp;s^{(T)}_{i}%&#10;=1\\end{array}\\right.\" display=\"inline\"><mrow><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\vspace{0.5cm}[\\sigma^{(T+1)}_{i}]=\\left\\{\\begin{array}[]{lll}%&#10;\\vspace{0.25cm}\\phi([s^{(T)}_{i-1}]+[s^{(T)}_{i+1}]+s^{(T)}_{i}+s^{(T)}_{i+1})%&#10;&amp;if&amp;[s^{(T)}_{i}]=0\\\\&#10;\\psi([s^{(T)}_{i-1}]+[s^{(T)}_{i+1}]+s^{(T)}_{i}+s^{(T)}_{i+1})&amp;if&amp;[s^{(T)}_{i%&#10;}]=1\\end{array}\\right.\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>\u03c3</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>i</mi><mo>\u2062</mo><mi>f</mi></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">[</mo><msubsup><mi>s</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}]