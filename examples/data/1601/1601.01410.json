[{"file": "1601.01410.tex", "nexttext": "\n$\\textbf{x}(t)$ is referred to as the ``state\" of the system, $\\textbf{u}(t)$ is the controller of the system, and $\\textbf{a}(\\cdot, \\cdot, t)$ is, in general, a non-linear time dependent function describing the dynamics of the state as determined by the state and controller at time $t$. We assume that the initial state $\\textbf{x}(t_{0})$ and initial time is known. Often the dynamic system is assumed to be linear time-invariant (LTI) and can be expressed as\n\n", "itemtype": "equation", "pos": 10278, "prevtext": "\n\n\n\\begin{flushleft}\n{\\Large\n\\textbf{Sparse signals for the control of human movements using the infinity norm}\n}\n\n\\\\\n\\vspace{.1cm}\nGeoffrey George Gamble$^{1}$,\nMehrdad Yazdani$^{2}$\n\n\\vspace{.4cm}\n\\bf{1} Geoffrey George Gamble $\\ast$, Department of Computer Science and Engineering, University of California at San Diego, La Jolla, California, United States of America\n\\\\\n\\vspace{.2cm}\n\\bf{2} Mehrdad Yazdani, Qualcomm Institute, University of California at San Diego, La Jolla, California, United States of America\n\\\\\n\\vspace{.4cm}\n$\\ast$ E-mail: ggamble@cs.ucsd.edu\n\\end{flushleft}\n\n\\newpage\n\n\n\\section{Abstract}\n  Optimal control models have been successful tools in describing many aspects of human movements. While these models have a sound theoretical foundation, the interpretation of such models with regard to the neuronal implementation of the human motor system, or how robotic systems might be implemented to mimic human movement, is not clear. One of the most important aspects of optimal control policies is the notion of \\emph{cost}...This body of mathematics seeks to minimize some notion of \\emph{cost}, while meeting certain goals. We offer a mathematical method to transform the current methodologies found in the literature from their traditional form by changing the norm by which cost is assessed. In doing so we show how sparsity can be introduced into current optimal control approaches that use continuous control signals. We assess cost using the $L_{\\infty}$ norm. This influences the optimization process to produce optimal signals which can be represented by a small amount of Dirac delta functions, as opposed to the traditional continuous control signals. In recent years sparsity has played an important role in theoretical neuroscience for information processing (such as vision). Typically, sparsity is imposed by introducing a cardinality constraint or penalty (measured or approximated by the one-norm). In this work, however, to obtain sparse control signals, the $L_{\\infty}$ norm is used as a penalty on the control signal, which is then encoded with Dirac delta functions. We show that, for a basic physical system, a point mass can be moved between two points in a way that resembles human fast reaching movements. Despite the sparse nature of the control signal, the movements that result are continuous and smooth. These control signals are simpler than their non-sparse counterparts, yet yield comparable if not better results when applied towards modeling human fast reaching movements. In addition, such sparse control signals, consisting of Dirac delta functions have a neuronal interpretation as a sequence of spikes, giving this approach a biological interpretation. Actual neuronal implementations are clearly more complex, as they may consist of large numbers of neurons. However, this work shows, in principle, that sparsely encoded control signals are a plausible implementation for the control of fast reaching movements. The presented method could easily be scaled up to arbitrarily large numbers of duplicates, thus representing larger numbers of spikes. We show how leading techniques for modeling human movements can easily be adjusted in order to introduce sparsity, and thus the biological interpretation and the simplified information content of the control signal.\n\n\n\\section{Introduction}\n\\label{sec:Introduction}\n\nOptimal control theory has provided a great deal of insight with regard to developing mathematical models that describe human movements (for example, \\cite{Flash, KawatoMinTorqueChange1989, Hoff93, Harris1998, Liu2007}). These works, amongst many others, have shown that humans move with strategies that can be described/driven by various control signals\\footnote{Control signals are to be described in more depth later, but for now it is a signal that controls elements of a system.} and related cost functions to model movement. However, as \\cite{BayesianBrain} points out, while the development of optimal control models has given mathematical insights into the properties of human movements, and perhaps the costs that forged our motor system via evolution, the connection to the neuronal implementation of the motor system is not clear. In contrast to these models, we show that a novel penalty on a control signal results in signals which can be represented more simply, and that have more plausible biological interpretations, while maintaining the ability to model human movements accurately.\n\n\nTo demonstrate the utility of sparse optimal control signals for human movements, we will compare two versions of a class of problems called ``minimum effort\" control problems, which attempt to minimize the ``size\" or ``effort\" of the control signal when modeling human movements, as explained in \\cite{neustadt1962minimumEffortDefinition}. In the first, and more traditional version, the effort to be minimized is defined as the $L_{2}$ norm of the control signal over some time course within which a movement is completed. The goal is to minimize that signal. One of the first, and most famous of this family of models is the ``minimum jerk\" control policy, proposed originally by Flash and Hogan \\cite{Flash}. The Flash and Hogan control strategy models human reaching movements, and uses jerk (the third derivative of position) as a control signal, and minimizes that signal to the extent allowed by a well defined reaching task. Intuitively, most are more familiar with thinking of acceleration as a control signal (e.g. pressing the accelerator in a car controls the speed). In the Flash and Hogan case, jerk is the derivative of acceleration, so it ``controls\" the acceleration in the same way acceleration ``controls\" velocity. Because jerk is the minimized control signal, we refer to jerk as the ``effort term\". Because they attempt to minimize their control signal, this as a minimum effort problem, and is referred to as ``minimum jerk\".\n\nWork since Flash and Hogan has considered different cost functions as the effort term as defined above, such as minimizing torque over the course of a movement \\cite{lim2005movementMinTorque}, or minimizing torque change (derivative of torque) over the movement  \\cite{KawatoMinTorqueChange1989, MinTorqueChange}. Other works have added more terms to the a cost function but have maintained an effort term. Additions to the effort term include end-point stability (how much adjustment is needed once the target area of a reaching movement is breached) or end-point accuracy (how close to the target when the reaching movement ends) \\cite{Liu2007}. Such extensions, however, have not lead to any insights into the neuronal implementation of control signals in the CNS, nor do they simplify the nature of the control signal.\n\nWe will show that using the $L_{\\infty}$ norm instead of the $L_{2}$ norm for measuring and penalizing the ``effort\" of the control signal results in signals that can be encoded sparsely via Dirac delta functions. There exists a family of models where this technique is applicable, specifically, because they all employ an ``effort\" term. Practically, the sparsification of signals generated by this family of optimal control models might be useful in a robotic system in order to achieve human like-movement. Due to the simplicity (sparsity) of the resulting signal, implementations of human-like robotic control may be easier to comprehend and construct.\n\nModels of reaching movements leading to this work were considered in \\cite{Ben-Itzhak, Yazdani2012, KarnielMinAccelerationWithConstraintsOfCenterOfMass}. These works referred to their signals as ``bang-bang\" or ``intermittent\" (see \\cite{KarnielOpenQuestionsMotorControl,GawthropIntermittentControlCompTheory} for more on intermittent control). However, the control signals were not sparse, rather, they were \\emph{square wave continuous}. Other types of motor control such as standing and keeping balance have been modeled via intermittent control, notably, two such models are compared in \\cite{gawthrop2014intermittent}. Here, we demonstrate a mathematical relationship that can convert non-sparsity to sparsity with regard to the control signal. This relationship is related to the metric used to measure the control signal (i.e. how is the effort measured?), but more importantly a sparse encoding of the signal via Dirac delta functions. We also show that sparse optimal control signals model real human arm movements with high accuracy, thus supporting sparse optimal control signals as a plausible control strategy used by a human's biological system. We emphasize that, using sparse signals in the cases shown here has no downside in terms of model performance, but has the benefits of a simpler encoding of the control signal, a biological interpretation in terms of neural spike timing, and potentially, a simpler control strategy which may be useful in robotics...All of these qualities are absent from non-sparse signals.\n\n\\subsection{Optimal Control Overview}\n\\label{subsec:OptimalControlOverview}\nIn this section we give an overview of optimal control theory and highlight two optimal control problems: the minimum-time and the minimum-effort control problems. Our overview is meant as means to establish common notation and terminology. For a more in depth overview, see \\cite{Kirk, BayesianBrain}. Optimal control theory is an application of optimization theory to the control of a dynamic system. In optimization theory, we seek to find an element in a domain that minimizes (or maximizes) a criterion (also referred to as an objective), while satisfying a constraint set. When the elements in the intersection of the domain and constraint sets are functions, the criterion is typically referred to as an objective functional or a cost functional, whereas when the elements are points in a vector space, the criterion is referred to as an objective function or a cost function. In optimal control, we seek an optimal controller (typically a function of time if the system is continuous or a vector if the system is discrete) that has certain constraints (for example, the controller is limited by a specified amount of power or resources) that minimizes a criterion.\n\nWe describe dynamic systems as a set of first-order differential equations:\n\n", "index": 1, "text": "\\begin{equation}\\label{eq:dynamic}\n\\dot{\\textbf{x}}(t) = \\textbf{a}(\\textbf{x}(t), \\textbf{u}(t), t).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\dot{\\textbf{x}}(t)=\\textbf{a}(\\textbf{x}(t),\\textbf{u}(t),t).\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mtext>\ud835\udc1a</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\n\nGiven the dynamic system of equation \\ref{eq:dynamic} and an initial state $\\textbf{x}(t_{0})$, we seek a control signal $\\textbf{u}(t)$ to transfer the system to a desired state in a finite time. In practice, the control signal $\\textbf{u}(t)$ is not unconstrained, but rather bounded by the available resources (such as fuel, energy, or supply). In optimal control theory, we seek an optimal control signal $\\textbf{u}^{*}(t)$ that, in addition to transferring the system to a desired state, also minimizes a cost functional $\\textbf{J}(\\textbf{u}(t))$. The cost functional is application dependent and the optimal solution $\\textbf{u}^{*}(t)$ depends on what we consider to be ``cost\". For example, in the cost functional we may penalize large control signals or penalize deviations from a desired trajectory. Subsequently we will discuss two important cost functionals.\n\n\n\n\n\n\\subsubsection{Minimum-Time Control}\n\\label{subsec:MinTimeControl}\nIn the minimum-time control problem, the objective is to transfer a system to a final state with a constrained control signal as quickly as possibly. Thus, the cost functional penalizes the total time it takes to transfer the initial state to a final state and can be expressed as\n\n", "itemtype": "equation", "pos": 10859, "prevtext": "\n$\\textbf{x}(t)$ is referred to as the ``state\" of the system, $\\textbf{u}(t)$ is the controller of the system, and $\\textbf{a}(\\cdot, \\cdot, t)$ is, in general, a non-linear time dependent function describing the dynamics of the state as determined by the state and controller at time $t$. We assume that the initial state $\\textbf{x}(t_{0})$ and initial time is known. Often the dynamic system is assumed to be linear time-invariant (LTI) and can be expressed as\n\n", "index": 3, "text": "\\begin{equation}\\label{eq:LTI}\n\\dot{\\textbf{x}}(t) = \\textbf{A}\\textbf{x}(t) +\\textbf{B}\\textbf{u}(t).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\dot{\\textbf{x}}(t)=\\textbf{A}\\textbf{x}(t)+\\textbf{B}\\textbf{u}(t).\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mtext>\ud835\udc00</mtext><mtext>\ud835\udc31</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mtext>\ud835\udc01</mtext><mtext>\ud835\udc2e</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere the initial state $\\textbf{x}(t_{0})$, initial time $t_{0}$, and final state $\\textbf{x}(t_{f})$ are known, while $t_{f}$ is unknown, and the system dynamics are described by equation \\ref{eq:dynamic}. We furthermore constrain the control signals to be bounded\n\n", "itemtype": "equation", "pos": 12205, "prevtext": "\n\nGiven the dynamic system of equation \\ref{eq:dynamic} and an initial state $\\textbf{x}(t_{0})$, we seek a control signal $\\textbf{u}(t)$ to transfer the system to a desired state in a finite time. In practice, the control signal $\\textbf{u}(t)$ is not unconstrained, but rather bounded by the available resources (such as fuel, energy, or supply). In optimal control theory, we seek an optimal control signal $\\textbf{u}^{*}(t)$ that, in addition to transferring the system to a desired state, also minimizes a cost functional $\\textbf{J}(\\textbf{u}(t))$. The cost functional is application dependent and the optimal solution $\\textbf{u}^{*}(t)$ depends on what we consider to be ``cost\". For example, in the cost functional we may penalize large control signals or penalize deviations from a desired trajectory. Subsequently we will discuss two important cost functionals.\n\n\n\n\n\n\\subsubsection{Minimum-Time Control}\n\\label{subsec:MinTimeControl}\nIn the minimum-time control problem, the objective is to transfer a system to a final state with a constrained control signal as quickly as possibly. Thus, the cost functional penalizes the total time it takes to transfer the initial state to a final state and can be expressed as\n\n", "index": 5, "text": "\\begin{equation}\\label{eq:minTime}\n\\textbf{J}(\\textbf{u}(t)) = t_{f} - t_{0}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\textbf{J}(\\textbf{u}(t))=t_{f}-t_{0}\" display=\"block\"><mrow><mrow><mtext>\ud835\udc09</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>t</mi><mi>f</mi></msub><mo>-</mo><msub><mi>t</mi><mn>0</mn></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\n\nWe now show the solution to the minimum-time control problem for an LTI system as described by equation \\ref{eq:LTI}. We consider $\\textbf{A}$ and $\\textbf{B}$ to be constant $n \\times n$ and $n \\times m$ matrices respectively. Thus the minimum-time control problem can be expressed as\n\n\n", "itemtype": "equation", "pos": 12564, "prevtext": "\nwhere the initial state $\\textbf{x}(t_{0})$, initial time $t_{0}$, and final state $\\textbf{x}(t_{f})$ are known, while $t_{f}$ is unknown, and the system dynamics are described by equation \\ref{eq:dynamic}. We furthermore constrain the control signals to be bounded\n\n", "index": 7, "text": "\\begin{equation}\\label{eq:bound}\n|\\textbf{u}(t)| \\leq B.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"|\\textbf{u}(t)|\\leq B.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mi>B</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere we have defined $T \\equiv t_{f} - t_{0}$ and assumed $t_{0} = 0$. This special case has been solved by Pontryagin and colleagues. Their conclusions lead to several important points upon which this work builds, as they guarantee a control signal which switches a finite number of times between two possible values. These points are summarized below (see \\cite{Pontryagin} for more details).\n\\begin{enumerate}[label=\\textbf{P.\\arabic*},ref = P.\\arabic*]\n  \\item For a given LTI system, there is one, and only one optimal signal to drive the system from an initial state to a desired state.\n  \\item \\label{enum:controlSwitchExtremes} Because the goal of a minimum-time problem is to move the system to the desired state in the least amount of time, a control signal representing a dynamic variable (such as acceleration) is always at one of two extremes, $+B$ or $-B$. These extremes are defined in the constraints of equation \\ref{eq:minimumTimeSimple}. Intuitively, if you want to get from point $X$ to point $Y$ as fast as possible, you would change from zero acceleration to maximum positive acceleration to speed up initially, and then to maximum deceleration to slow down to reach point $Y$, and then to zero acceleration to maintain your starting position. The two extreme values are the only values that yield to a minimum time (optimal) result.\n  \\item \\label{enum:controlSwitchesLimited} The control signal will switch between these two extremes at most $n+1$ times, where $n$ is the derivative of position we choose to be the control signal. For example, for velocity, acceleration, and jerk, $n$ is $1$, $2$ and $3$ respectively, and thus has a maximum of $2$, $3$, and $4$ (respectively) switches between the extremes of the control signal.\n\n\\end{enumerate}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis type of control signal is sometimes referred to as a ``bang-bang\" control signal since the signal switches between the lower bound and upper bound of the inequality constraint of equation \\ref{eq:bound} (see \\cite{Kirk} for more). It can also be regarded as a ``sparse\" control signal since the number of changes in the signal's values is small. In other words, the changes in the control signal can be described by a bounded number of switches between the lower and upper bound. These switches can be encoded by a series of Dirac delta functions, which resemble neural bursts or spikes.\n\n\n\n\n\n\n\n\n\\subsubsection{Minimum-Effort Control} \\label{subsec:miniumEffortControl}\nIn the minimum-effort control problem, the objective is to transfer a system from an initial state to a final state with a control signal that is as ``small\" as possible (hence, minimum ``effort\"). Typically, the ``size\" of a control signal is measured with a penalty function. In this work we consider the $L_{p}$ norm penalty function and can express the cost functional as\n\n", "itemtype": "equation", "pos": 12924, "prevtext": "\n\nWe now show the solution to the minimum-time control problem for an LTI system as described by equation \\ref{eq:LTI}. We consider $\\textbf{A}$ and $\\textbf{B}$ to be constant $n \\times n$ and $n \\times m$ matrices respectively. Thus the minimum-time control problem can be expressed as\n\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:minimumTimeSimple}\n\\begin{aligned}\n& \\underset{\\textbf{u}(t), T}{\\text{minimize}}\n& & T   \\\\\n& \\text{subject to} & & \\dot{\\textbf{x}}_{n}(t) = \\textbf{A} \\textbf{x}_{n}(t) + \\textbf{B}\\textbf{u}(t) \\\\\n& & & \\textbf{x}_{n}(0) = \\textbf{x}_{i} \\\\\n& & & \\textbf{x}_{n}(T) = \\textbf{x}_{f} \\\\\n& & & |\\textbf{u}(t)| \\leq B\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{\\textbf{u}(t),T}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>T</mi></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle T\" display=\"inline\"><mi>T</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}_{n}(t)=\\textbf{A}\\textbf{x}_{n}(t)+\\textbf{B}%&#10;\\textbf{u}(t)\" display=\"inline\"><mrow><mrow><msub><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mrow><mtext>\ud835\udc00</mtext><mtext>\ud835\udc31</mtext></mrow><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mtext>\ud835\udc01</mtext><mtext>\ud835\udc2e</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5Xc.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(T)=\\textbf{x}_{f}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5Xd.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\textbf{u}(t)|\\leq B\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mi>B</mi></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": " \nwhich denotes the $L_{p}$ norm (and is typically the $L_{2}$ norm), and the system dynamics are described by equation \\ref{eq:dynamic}. We can also have additional constraints in the minimum-effort control problem, and just as in the minimum-time control problem, there can be many variations by introducing additional constraints or additional costs to the objective. For example, a simple extension would be to consider a control problem where the cost functional trades-off between ``effort\" and the transfer time and can be expressed as a combination of equations \\ref{eq:minTime} and \\ref{eq:minLP}\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere we have defined $T \\equiv t_{f} - t_{0}$ and assumed $t_{0} = 0$. This special case has been solved by Pontryagin and colleagues. Their conclusions lead to several important points upon which this work builds, as they guarantee a control signal which switches a finite number of times between two possible values. These points are summarized below (see \\cite{Pontryagin} for more details).\n\\begin{enumerate}[label=\\textbf{P.\\arabic*},ref = P.\\arabic*]\n  \\item For a given LTI system, there is one, and only one optimal signal to drive the system from an initial state to a desired state.\n  \\item \\label{enum:controlSwitchExtremes} Because the goal of a minimum-time problem is to move the system to the desired state in the least amount of time, a control signal representing a dynamic variable (such as acceleration) is always at one of two extremes, $+B$ or $-B$. These extremes are defined in the constraints of equation \\ref{eq:minimumTimeSimple}. Intuitively, if you want to get from point $X$ to point $Y$ as fast as possible, you would change from zero acceleration to maximum positive acceleration to speed up initially, and then to maximum deceleration to slow down to reach point $Y$, and then to zero acceleration to maintain your starting position. The two extreme values are the only values that yield to a minimum time (optimal) result.\n  \\item \\label{enum:controlSwitchesLimited} The control signal will switch between these two extremes at most $n+1$ times, where $n$ is the derivative of position we choose to be the control signal. For example, for velocity, acceleration, and jerk, $n$ is $1$, $2$ and $3$ respectively, and thus has a maximum of $2$, $3$, and $4$ (respectively) switches between the extremes of the control signal.\n\n\\end{enumerate}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis type of control signal is sometimes referred to as a ``bang-bang\" control signal since the signal switches between the lower bound and upper bound of the inequality constraint of equation \\ref{eq:bound} (see \\cite{Kirk} for more). It can also be regarded as a ``sparse\" control signal since the number of changes in the signal's values is small. In other words, the changes in the control signal can be described by a bounded number of switches between the lower and upper bound. These switches can be encoded by a series of Dirac delta functions, which resemble neural bursts or spikes.\n\n\n\n\n\n\n\n\n\\subsubsection{Minimum-Effort Control} \\label{subsec:miniumEffortControl}\nIn the minimum-effort control problem, the objective is to transfer a system from an initial state to a final state with a control signal that is as ``small\" as possible (hence, minimum ``effort\"). Typically, the ``size\" of a control signal is measured with a penalty function. In this work we consider the $L_{p}$ norm penalty function and can express the cost functional as\n\n", "index": 11, "text": "\\begin{equation}\\label{eq:minLP}\n\\textbf{J}(\\textbf{u}(t)) = \\left(\\int u(t)^{p}dt\\right)^{1/p} \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\textbf{J}(\\textbf{u}(t))=\\left(\\int u(t)^{p}dt\\right)^{1/p}\" display=\"block\"><mrow><mrow><mtext>\ud835\udc09</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msup><mrow><mo>(</mo><mrow><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mi>u</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mi>p</mi></msup><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>t</mi></mrow></mrow></mrow><mo>)</mo></mrow><mrow><mn>1</mn><mo>/</mo><mi>p</mi></mrow></msup></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $\\gamma \\geq 0$ is a trade-off parameter between ``effort\" and the state transfer time and can be varied depending on the application.\n\nAs an example of a minimum-effort problem, Flash and Hogan considered the following minimum-effort control problem which introduced constraints on initial and final state in order to describe human movements:\n\n", "itemtype": "equation", "pos": 16856, "prevtext": " \nwhich denotes the $L_{p}$ norm (and is typically the $L_{2}$ norm), and the system dynamics are described by equation \\ref{eq:dynamic}. We can also have additional constraints in the minimum-effort control problem, and just as in the minimum-time control problem, there can be many variations by introducing additional constraints or additional costs to the objective. For example, a simple extension would be to consider a control problem where the cost functional trades-off between ``effort\" and the transfer time and can be expressed as a combination of equations \\ref{eq:minTime} and \\ref{eq:minLP}\n\n", "index": 13, "text": "\\begin{equation}\\label{eq:tradeoff}\n\\textbf{J}(\\textbf{u}(t)) = \\gamma\\left(\\int u(t)^{p}dt\\right)^{1/p} + t_{f} - t_{0} \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\textbf{J}(\\textbf{u}(t))=\\gamma\\left(\\int u(t)^{p}dt\\right)^{1/p}+t_{f}-t_{0}\" display=\"block\"><mrow><mrow><mtext>\ud835\udc09</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc2e</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mrow><mo>(</mo><mrow><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mi>u</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mi>p</mi></msup><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>t</mi></mrow></mrow></mrow><mo>)</mo></mrow><mrow><mn>1</mn><mo>/</mo><mi>p</mi></mrow></msup></mrow><mo>+</mo><msub><mi>t</mi><mi>f</mi></msub></mrow><mo>-</mo><msub><mi>t</mi><mn>0</mn></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $\\textbf{x}(t) = \\begin{bmatrix} x(t) & \\dot{x}(t) & \\ddot{x}(t) \\end{bmatrix}^\\top$ is the state vector, $\\textbf{x}_{i}$ and $\\textbf{x}_{f}$ are the initial and final boundary conditions, and $T$ is the duration of the movement (with movement starting at time $t = 0$). Flash and Hogan used a jerk control signal ($u(t) = \\dddot{x}(t)$), and furthermore used a third-order integrator model for the linear time-invariant dynamic equation parameters:\n\n", "itemtype": "equation", "pos": 17344, "prevtext": "\nwhere $\\gamma \\geq 0$ is a trade-off parameter between ``effort\" and the state transfer time and can be varied depending on the application.\n\nAs an example of a minimum-effort problem, Flash and Hogan considered the following minimum-effort control problem which introduced constraints on initial and final state in order to describe human movements:\n\n", "index": 15, "text": "\\begin{equation}\\label{eq:FandH}\n\\begin{aligned}\n& \\underset{u(t)}{\\text{minimize}}\n& & \\left(\\int u(t)^{2}dt\\right)^{1/2} \\\\ \n& \\text{subject to} & & \\dot{\\textbf{x}}(t) = A \\textbf{x}(t) + Bu(t) \\\\\n& & & \\textbf{x}(0) = \\textbf{x}_{i} \\\\\n& & & \\textbf{x}(T) = \\textbf{x}_{f}\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u(t)}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\left(\\int u(t)^{2}dt\\right)^{1/2}\" display=\"inline\"><msup><mrow><mo>(</mo><mstyle displaystyle=\"true\"><mrow><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mi>u</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>t</mi></mrow></mrow></mrow></mstyle><mo>)</mo></mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}(t)=A\\textbf{x}(t)+Bu(t)\" display=\"inline\"><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mi>B</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8Xc.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}(T)=\\textbf{x}_{f}\" display=\"inline\"><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nThis simple model yields trajectories that are remarkably similar to those of humans. Naturally, simple extensions of this optimization problem can yield results that are even more realistic and many researches have begun exploring these extensions. For example, \\cite{Harris1998} has noted that when humans make movements to a target, the target that is reached is a not a specific point, but rather a distribution of points. Hence, in their optimization procedure they relaxed the constraints of equation \\ref{eq:FandH}, which specify an exact final state.\n\n\n\n\\subsection{Sparse optimal control policies for straight point-to-point trajectories}\n\\label{sec:SparseControlPointToPoint}\n    In a previous work, we show how square wave control signals, with abrupt switches between two states (first alluded to in \\ref{enum:controlSwitchExtremes}, with an example given in figure \\ref{fig:pulse}), can effectively model smooth human reaching movements \\cite{Yazdani2012}. This work extends that notion by developing a method to represent neural signals via sparse usage of the Dirac delta function. These sparse signals can be thought of as encoding a series of positive (excitatory) or negative (inhibitory) neural spikes, or, more plausibly, groups of neurons spiking for brief periods. In summary, we take the square wave control signals described in \\cite{Yazdani2012}, and encode them as a sparse series of Dirac delta functions, each of which signifies one of the abrupt switching points for the control signal.\n\n    We define a \\emph{sparse optimal control policy} as a control policy that meets optimality constraints with the lowest cost, as defined by the chosen cost function, that can be encoded by a finite number of discontinuous changes in the signal. An example of a signal that can be encoded as a sparse series is a rectangular pulse function, much like the control signals explored in \\cite{Yazdani2012}, and shown in figure \\ref{fig:pulse}. Functions like these can be encoded by impulse functions (see Figure~\\ref{fig:spikedUp}). The control signals in the minimum-time control problem discussed on in section \\ref{subsec:MinTimeControl} is an example of sparse control signals that are optimal in terms of state transfer time. \\emph{Henseforth, we will refer to the control signal (square wave) as ``sparse\", as it is easily transformed into a sparse signal consisting of Dirac delta functions.}  \n\n\n\n\n\n\\begin{figure}\n  \\centering\n  \\subfigure[An example of the types of sparsely driven signals generated by minimizing the control signal as measured by the $L_{\\infty}$ norm.]{\\label{fig:pulse}\\includegraphics[width=0.4\\textwidth]{pulse-eps-converted-to}}\n  \\subfigure[Rate of change of sparse signal shown in Figure \\ref{fig:pulse}. These sparse impulse functions can be thought of as driving (or encoding) the control signal in figure \\ref{fig:pulse}, along with initial conditions, they are all that is needed to encode the control signal in \\ref{fig:pulse}.]{\\label{fig:spikedUp}\\includegraphics[width=0.4\\textwidth]{spikes-eps-converted-to}}\n    \\caption{Example of a control signal and its sparse spike encoding.}\n  \\label{fig:pulseFigure}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we discuss sparse optimal control signals that solve the minimum-effort problem. The control signal is defined as the $n$-th order derivative in terms of position $x(t)$,\n\n\n", "itemtype": "equation", "pos": 18109, "prevtext": "\nwhere $\\textbf{x}(t) = \\begin{bmatrix} x(t) & \\dot{x}(t) & \\ddot{x}(t) \\end{bmatrix}^\\top$ is the state vector, $\\textbf{x}_{i}$ and $\\textbf{x}_{f}$ are the initial and final boundary conditions, and $T$ is the duration of the movement (with movement starting at time $t = 0$). Flash and Hogan used a jerk control signal ($u(t) = \\dddot{x}(t)$), and furthermore used a third-order integrator model for the linear time-invariant dynamic equation parameters:\n\n", "index": 17, "text": "\\begin{equation}\n\\textbf{A} = \\begin{bmatrix}\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n0 & 0 & 0\n\\end{bmatrix}\n\\textnormal{ and } \\textbf{B} = \\begin{bmatrix}\n0 \\\\\n0\\\\\n1\n\\end{bmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\textbf{A}=\\begin{bmatrix}0&amp;1&amp;0\\\\&#10;0&amp;0&amp;1\\\\&#10;0&amp;0&amp;0\\end{bmatrix}\\textnormal{ and }\\textbf{B}=\\begin{bmatrix}0\\\\&#10;0\\\\&#10;1\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mtext>\ud835\udc00</mtext><mo>=</mo><mrow><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u2062</mo><mrow><mtext>\u00a0and\u00a0</mtext><mtext>\ud835\udc01</mtext></mrow></mrow><mo>=</mo><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nThe minimum effort control problem that results in sparse control signals uses the $L_{\\infty}$ norm and is written as\n\n\n", "itemtype": "equation", "pos": 21664, "prevtext": "\nThis simple model yields trajectories that are remarkably similar to those of humans. Naturally, simple extensions of this optimization problem can yield results that are even more realistic and many researches have begun exploring these extensions. For example, \\cite{Harris1998} has noted that when humans make movements to a target, the target that is reached is a not a specific point, but rather a distribution of points. Hence, in their optimization procedure they relaxed the constraints of equation \\ref{eq:FandH}, which specify an exact final state.\n\n\n\n\\subsection{Sparse optimal control policies for straight point-to-point trajectories}\n\\label{sec:SparseControlPointToPoint}\n    In a previous work, we show how square wave control signals, with abrupt switches between two states (first alluded to in \\ref{enum:controlSwitchExtremes}, with an example given in figure \\ref{fig:pulse}), can effectively model smooth human reaching movements \\cite{Yazdani2012}. This work extends that notion by developing a method to represent neural signals via sparse usage of the Dirac delta function. These sparse signals can be thought of as encoding a series of positive (excitatory) or negative (inhibitory) neural spikes, or, more plausibly, groups of neurons spiking for brief periods. In summary, we take the square wave control signals described in \\cite{Yazdani2012}, and encode them as a sparse series of Dirac delta functions, each of which signifies one of the abrupt switching points for the control signal.\n\n    We define a \\emph{sparse optimal control policy} as a control policy that meets optimality constraints with the lowest cost, as defined by the chosen cost function, that can be encoded by a finite number of discontinuous changes in the signal. An example of a signal that can be encoded as a sparse series is a rectangular pulse function, much like the control signals explored in \\cite{Yazdani2012}, and shown in figure \\ref{fig:pulse}. Functions like these can be encoded by impulse functions (see Figure~\\ref{fig:spikedUp}). The control signals in the minimum-time control problem discussed on in section \\ref{subsec:MinTimeControl} is an example of sparse control signals that are optimal in terms of state transfer time. \\emph{Henseforth, we will refer to the control signal (square wave) as ``sparse\", as it is easily transformed into a sparse signal consisting of Dirac delta functions.}  \n\n\n\n\n\n\\begin{figure}\n  \\centering\n  \\subfigure[An example of the types of sparsely driven signals generated by minimizing the control signal as measured by the $L_{\\infty}$ norm.]{\\label{fig:pulse}\\includegraphics[width=0.4\\textwidth]{pulse-eps-converted-to}}\n  \\subfigure[Rate of change of sparse signal shown in Figure \\ref{fig:pulse}. These sparse impulse functions can be thought of as driving (or encoding) the control signal in figure \\ref{fig:pulse}, along with initial conditions, they are all that is needed to encode the control signal in \\ref{fig:pulse}.]{\\label{fig:spikedUp}\\includegraphics[width=0.4\\textwidth]{spikes-eps-converted-to}}\n    \\caption{Example of a control signal and its sparse spike encoding.}\n  \\label{fig:pulseFigure}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we discuss sparse optimal control signals that solve the minimum-effort problem. The control signal is defined as the $n$-th order derivative in terms of position $x(t)$,\n\n\n", "index": 19, "text": "\\begin{equation}\\label{eq:controller}\nu_{n}(t) = \\frac{d^{n}}{dt^{n}}x(t).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"u_{n}(t)=\\frac{d^{n}}{dt^{n}}x(t).\" display=\"block\"><mrow><mrow><mrow><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><msup><mi>d</mi><mi>n</mi></msup><mrow><mi>d</mi><mo>\u2062</mo><msup><mi>t</mi><mi>n</mi></msup></mrow></mfrac><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $\\textbf{x}_{n}(t) = \\begin{bmatrix} x(t) & \\frac{d}{dt}x(t) & \\frac{d^{2}}{dt^{2}}x(t) & \\ldots & \\frac{d^{n-1}}{dt^{n-1}}x(t) \\end{bmatrix}^{T}$ is the state vector, $\\textbf{x}_{i}$ and $\\textbf{x}_{f}$ are the initial and final boundary conditions, $T$ is the duration of the movement (with movement starting at time $t = 0$), and $\\sup_{0 \\leq t \\leq T}| . |$ is the $L_{\\infty}$ norm. Here we consider a system that is an $n$-th order integrator, thus\n\n", "itemtype": "equation", "pos": 21874, "prevtext": "\nThe minimum effort control problem that results in sparse control signals uses the $L_{\\infty}$ norm and is written as\n\n\n", "index": 21, "text": "\\begin{equation}\\label{eq:sparseEffort}\n\\begin{aligned}\n& \\underset{u_{n}(t)}{\\text{minimize}}\n& & \\sup_{0 \\leq t \\leq T}|u(t)| \\\\\n\n& \\text{subject to} & & \\dot{\\textbf{x}}_{n}(t) = \\textbf{A}_{n} \\textbf{x}_{n}(t) + \\textbf{B}_{n}u_{n}(t) \\\\\n& & & \\textbf{x}_{n}(0) = \\textbf{x}_{i} \\\\\n& & & \\textbf{x}_{n}(T) = \\textbf{x}_{f}\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u_{n}(t)}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sup_{0\\leq t\\leq T}|u(t)|\" display=\"inline\"><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mn>0</mn><mo>\u2264</mo><mi>t</mi><mo>\u2264</mo><mi>T</mi></mrow></munder><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11Xa.m5\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}_{n}(t)=\\textbf{A}_{n}\\textbf{x}_{n}(t)+\\textbf{B%&#10;}_{n}u_{n}(t)\" display=\"inline\"><mrow><mrow><msub><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mtext>\ud835\udc00</mtext><mi>n</mi></msub><mo>\u2062</mo><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mtext>\ud835\udc01</mtext><mi>n</mi></msub><mo>\u2062</mo><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11Xc.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(T)=\\textbf{x}_{f}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": " \n The authors of \\cite{Yazdani2012} considered the special case $u_{3}(t) = \\dddot{x}(t)$, ($n = 3$), and showed that this particular sparse control signal explains the trajectories of human movements better than the traditional Flash and Hogan model of equation \\ref{eq:FandH}. Perhaps more importantly, sparse control signals are biologically more realistic than non-sparse signals (See the Discussion section for more on this).  As we will demonstrate, most formulations of minimum effort problems can be easily converted to generate sparse control signals, complete with the afore mentioned benefits. By simply measuring the effort term in the objective function via the $L_{\\infty}$ norm (as opposed to the 2-norm), we can frame the control signal solution to these problems in terms of discontinuous switching states.\n\n\n\n We now show the general analytic solution for equation \\ref{eq:sparseEffort}. To derive the general solution, we assume that the boundary conditions are\n \n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere $\\textbf{x}_{n}(t) = \\begin{bmatrix} x(t) & \\frac{d}{dt}x(t) & \\frac{d^{2}}{dt^{2}}x(t) & \\ldots & \\frac{d^{n-1}}{dt^{n-1}}x(t) \\end{bmatrix}^{T}$ is the state vector, $\\textbf{x}_{i}$ and $\\textbf{x}_{f}$ are the initial and final boundary conditions, $T$ is the duration of the movement (with movement starting at time $t = 0$), and $\\sup_{0 \\leq t \\leq T}| . |$ is the $L_{\\infty}$ norm. Here we consider a system that is an $n$-th order integrator, thus\n\n", "index": 23, "text": "\\begin{equation}\\label{eq:dynamicParameters}\n\\textbf{A}_{n} =  \\begin{bmatrix}\n \\textbf{0}_{(n-1)\\times1} & \\textbf{I}_{(n-1) \\times (n-1)}\\\\\n 0 &  \\textbf{0}_{1 \\times (n-1)}\n \\end{bmatrix}\n \\textnormal{ and } \\textbf{B}_{n} =  \\begin{bmatrix}  \\textbf{0}_{(n-1)\\times1} \\\\  1 \\end{bmatrix}.\n \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\textbf{A}_{n}=\\begin{bmatrix}\\textbf{0}_{(n-1)\\times 1}&amp;\\textbf{I}_{(n-1)%&#10;\\times(n-1)}\\\\&#10;0&amp;\\textbf{0}_{1\\times(n-1)}\\end{bmatrix}\\textnormal{ and }\\textbf{B}_{n}=%&#10;\\begin{bmatrix}\\textbf{0}_{(n-1)\\times 1}\\\\&#10;1\\end{bmatrix}.\" display=\"block\"><mrow><mrow><msub><mtext>\ud835\udc00</mtext><mi>n</mi></msub><mo>=</mo><mrow><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mtext/><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign=\"center\"><msub><mtext>\ud835\udc08</mtext><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><msub><mtext/><mrow><mn>1</mn><mo>\u00d7</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u2062</mo><msub><mrow><mtext>\u00a0and\u00a0</mtext><mtext>\ud835\udc01</mtext></mrow><mi>n</mi></msub></mrow><mo>=</mo><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mtext/><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\n That is, we assume that the movement starts at rest and ends at rest. We solve the general sparse minimum effort control problem by manipulating equation \\ref{eq:sparseEffort} to a form that has been previously solved. Namely, note that every optimization problem can be written equivalently as an optimization problem with a linear objective by introducing an auxiliary variable $K$ and we can equivalently express equation \\ref{eq:sparseEffort} as follows:\n\n", "itemtype": "equation", "pos": 23987, "prevtext": " \n The authors of \\cite{Yazdani2012} considered the special case $u_{3}(t) = \\dddot{x}(t)$, ($n = 3$), and showed that this particular sparse control signal explains the trajectories of human movements better than the traditional Flash and Hogan model of equation \\ref{eq:FandH}. Perhaps more importantly, sparse control signals are biologically more realistic than non-sparse signals (See the Discussion section for more on this).  As we will demonstrate, most formulations of minimum effort problems can be easily converted to generate sparse control signals, complete with the afore mentioned benefits. By simply measuring the effort term in the objective function via the $L_{\\infty}$ norm (as opposed to the 2-norm), we can frame the control signal solution to these problems in terms of discontinuous switching states.\n\n\n\n We now show the general analytic solution for equation \\ref{eq:sparseEffort}. To derive the general solution, we assume that the boundary conditions are\n \n", "index": 25, "text": "\\begin{equation}\\label{eq:simpleBoundary}\n \\textbf{x}_{i} =\n  \\begin{bmatrix}\n  x_{i} \\\\\n  \\textbf{0}_{(n-1)\\times 1}\n  \\end{bmatrix}\n  \\textnormal{ and } \\textbf{x}_{f} =\n  \\begin{bmatrix}\n  x_{f} \\\\\n \\textbf{0}_{(n-1)\\times 1}\n  \\end{bmatrix}.\n  \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\textbf{x}_{i}=\\begin{bmatrix}x_{i}\\\\&#10;\\textbf{0}_{(n-1)\\times 1}\\end{bmatrix}\\textnormal{ and }\\textbf{x}_{f}=\\begin%&#10;{bmatrix}x_{f}\\\\&#10;\\textbf{0}_{(n-1)\\times 1}\\end{bmatrix}.\" display=\"block\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub><mo>=</mo><mrow><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mi>i</mi></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mtext/><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u2062</mo><msub><mrow><mtext>\u00a0and\u00a0</mtext><mtext>\ud835\udc31</mtext></mrow><mi>f</mi></msub></mrow><mo>=</mo><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mi>f</mi></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mtext/><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $u_{n}(t)$, $\\textbf{A}_{n}$, $\\textbf{B}_{n}$, $\\textbf{x}_{i}$, and $\\textbf{x}_{f}$ are defined as before in equations \\ref{eq:controller}, \\ref{eq:dynamicParameters}, and \\ref{eq:simpleBoundary} respectively, and we have used the fact that $|| u_{n}(t)||_{\\infty} \\leq K \\implies  | u_{n}(t) | \\leq K$. The equivalency between equations \\ref{eq:sparseEffort} and \\ref{eq:linearSparse} is due to the fact that every objective can be bounded, and this bound is expressed as an additional constraint in equation \\ref{eq:linearSparse}.\n\nThe optimization problem of equation \\ref{eq:linearSparse} has the same form as equation \\ref{eq:minimumTimeSimple}. We can therefore use the results from the minimum-time control problem and apply them here (namely that the results of Pontryagin and colleagues still hold). The difference is that in equation \\ref{eq:minimumTimeSimple} the unknown is time $T$, whereas in equation \\ref{eq:linearSparse} the unknown is the bound $K$ on the control signal $u_{n}(t)$. Since the dynamic system in equation \\ref{eq:linearSparse} is an $n$-th order integrator, we can use the result from \\cite{Feldbaum} and write the following theorem:\\vspace{.2cm}\\\\\n\n\\newtheorem*{numSwitchings}{Number of Switches for an N-th Order Integrator. Theorem 1}\n\\begin{numSwitchings}\nFor a control problem of the type in equations \\ref{eq:minimumTimeSimple} or \\ref{eq:linearSparse} where the system dynamic equations are an $n$-th order integrator (as in equation \\ref{eq:dynamicParameters}), then the number of switchings in the control signal is exactly $n+1$ and the control signal is symmetric.\\vspace{.2cm}\\\\\n\\end{numSwitchings}\n\nIn other words, as initially discussed in \\ref{enum:controlSwitchesLimited}, as the order of the control signal increases (as $n$ increases), the number of switches in the control signal increases by the same amount. \\cite{Svinin} solved the general $n$-th order minimum-time control problem of equation \\ref{eq:minimumTimeSimple} for an $n$-th order integrator. We adapt their results for the general $n$-th order minimum-effort control problem of equation \\ref{eq:linearSparse} and summarize the solution as follows:\n\n", "itemtype": "equation", "pos": 24710, "prevtext": "\n That is, we assume that the movement starts at rest and ends at rest. We solve the general sparse minimum effort control problem by manipulating equation \\ref{eq:sparseEffort} to a form that has been previously solved. Namely, note that every optimization problem can be written equivalently as an optimization problem with a linear objective by introducing an auxiliary variable $K$ and we can equivalently express equation \\ref{eq:sparseEffort} as follows:\n\n", "index": 27, "text": "\\begin{equation}\\label{eq:linearSparse}\n\\begin{aligned}\n& \\underset{u_{n}(t), K}{\\text{minimize}}\n& & K   \\\\\n& \\text{subject to} & & \\dot{\\textbf{x}}_{n}(t) = \\textbf{A}_{n} \\textbf{x}_{n}(t) + \\textbf{B}_{n}u_{n}(t) \\\\\n& & & \\textbf{x}_{n}(0) = \\textbf{x}_{i} \\\\\n& & & \\textbf{x}_{n}(T) = \\textbf{x}_{f} \\\\\n& & & | u_{n}(t) | \\leq K.\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u_{n}(t),K}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mrow><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>K</mi></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle K\" display=\"inline\"><mi>K</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}_{n}(t)=\\textbf{A}_{n}\\textbf{x}_{n}(t)+\\textbf{B%&#10;}_{n}u_{n}(t)\" display=\"inline\"><mrow><mrow><msub><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mtext>\ud835\udc00</mtext><mi>n</mi></msub><mo>\u2062</mo><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mtext>\ud835\udc01</mtext><mi>n</mi></msub><mo>\u2062</mo><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14Xc.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}_{n}(T)=\\textbf{x}_{f}\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc31</mtext><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14Xd.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle|u_{n}(t)|\\leq K.\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>u</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mi>K</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 27248, "prevtext": "\nwhere $u_{n}(t)$, $\\textbf{A}_{n}$, $\\textbf{B}_{n}$, $\\textbf{x}_{i}$, and $\\textbf{x}_{f}$ are defined as before in equations \\ref{eq:controller}, \\ref{eq:dynamicParameters}, and \\ref{eq:simpleBoundary} respectively, and we have used the fact that $|| u_{n}(t)||_{\\infty} \\leq K \\implies  | u_{n}(t) | \\leq K$. The equivalency between equations \\ref{eq:sparseEffort} and \\ref{eq:linearSparse} is due to the fact that every objective can be bounded, and this bound is expressed as an additional constraint in equation \\ref{eq:linearSparse}.\n\nThe optimization problem of equation \\ref{eq:linearSparse} has the same form as equation \\ref{eq:minimumTimeSimple}. We can therefore use the results from the minimum-time control problem and apply them here (namely that the results of Pontryagin and colleagues still hold). The difference is that in equation \\ref{eq:minimumTimeSimple} the unknown is time $T$, whereas in equation \\ref{eq:linearSparse} the unknown is the bound $K$ on the control signal $u_{n}(t)$. Since the dynamic system in equation \\ref{eq:linearSparse} is an $n$-th order integrator, we can use the result from \\cite{Feldbaum} and write the following theorem:\\vspace{.2cm}\\\\\n\n\\newtheorem*{numSwitchings}{Number of Switches for an N-th Order Integrator. Theorem 1}\n\\begin{numSwitchings}\nFor a control problem of the type in equations \\ref{eq:minimumTimeSimple} or \\ref{eq:linearSparse} where the system dynamic equations are an $n$-th order integrator (as in equation \\ref{eq:dynamicParameters}), then the number of switchings in the control signal is exactly $n+1$ and the control signal is symmetric.\\vspace{.2cm}\\\\\n\\end{numSwitchings}\n\nIn other words, as initially discussed in \\ref{enum:controlSwitchesLimited}, as the order of the control signal increases (as $n$ increases), the number of switches in the control signal increases by the same amount. \\cite{Svinin} solved the general $n$-th order minimum-time control problem of equation \\ref{eq:minimumTimeSimple} for an $n$-th order integrator. We adapt their results for the general $n$-th order minimum-effort control problem of equation \\ref{eq:linearSparse} and summarize the solution as follows:\n\n", "index": 29, "text": "\\begin{equation}\\label{eq:sparseAmplitude}\n\\boxed{K^{*}_{n} = \\frac{2^{2(n-1)}(n-1)!(x_{f} - x_{i})}{T^{n}}}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"\\boxed{K^{*}_{n}=\\frac{2^{2(n-1)}(n-1)!(x_{f}-x_{i})}{T^{n}}}\" display=\"block\"><menclose notation=\"box\"><mrow><msubsup><mi>K</mi><mi>n</mi><mo>*</mo></msubsup><mo>=</mo><mfrac><mrow><msup><mn>2</mn><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msup><mo>\u2062</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo lspace=\"0pt\" rspace=\"3.5pt\">!</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mi>f</mi></msub><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><msup><mi>T</mi><mi>n</mi></msup></mfrac></mrow></menclose></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $K^{*}$ denotes the optimal amplitude or bound on the control signal, and $t_{i}^{*}$ denotes the optimal switching times. Figure \\ref{fig:sparseControlSignals} shows examples of several sparse optimal control signals.\n\n\n\n\n\\begin{figure}\n  \\centering\n  \\subfigure{\\label{subfig:jerk}\\includegraphics[scale = .5]{jerkControl-eps-converted-to}}        \\hspace{15mm}\n  \\subfigure{\\includegraphics[scale = .5]{snapControl-eps-converted-to}}\n  \\subfigure{\\label{subfig:crackle}\\includegraphics[scale = .5]{crackleControl-eps-converted-to}}  \\hspace{15mm}\n  \\subfigure{\\includegraphics[scale = .5]{popControl-eps-converted-to}}\n    \\caption{Examples of sparse optimal control signals $u_{i}(t)$ for $i = 3, \\ldots, 6$. Shown are movements that start from $t = 0$ and end at $t = 1$. }\n  \\label{fig:sparseControlSignals}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Sparse Optimal Control Signals in Fast Human Movements}\nThe sparse optimal control signals introduced in section \\ref{sec:SparseControlPointToPoint} are not only optimal with respect to a minimum-effort objective, but are also more biologically plausible when compared with non-sparse signals. Sparse optimal control signals can be are those that can be efficiently represented with Dirac delta functions, which resemble neuronal bursts or spikes. If we treat each spike as an idealized Dirac delta function, as done in \\cite{Dayan}, and as visualized in Figure~\\ref{fig:spikedUp}, then a spike sequence that represents an $n$-th order optimal control signal can be expressed as\n\n", "itemtype": "equation", "pos": 27372, "prevtext": "\n\n", "index": 31, "text": "\\begin{equation}\\label{eq:sparseSwitch}\n\\boxed{t_{i}^{*} = T\\text{sin}^{2}\\left( \\frac{\\pi i}{2n} \\right), \\quad i = 0, \\ldots, n}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"\\boxed{t_{i}^{*}=T\\text{sin}^{2}\\left(\\frac{\\pi i}{2n}\\right),\\quad i=0,\\ldots%&#10;,n}\" display=\"block\"><menclose notation=\"box\"><mrow><mrow><msubsup><mi>t</mi><mi>i</mi><mo>*</mo></msubsup><mo>=</mo><mrow><mi>T</mi><mo>\u2062</mo><msup><mtext>sin</mtext><mn>2</mn></msup><mo>\u2062</mo><mrow><mo>(</mo><mfrac><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>i</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>0</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>n</mi></mrow></mrow></mrow></menclose></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nwhere $K_{n}^{*}$ and $t_{i}^{*}$ can be found from equations \\ref{eq:sparseAmplitude} and \\ref{eq:sparseSwitch} respectively. The spike train represented by equation \\ref{eq:spikeTrain} is not postulated to be from a single neuron, but rather a population of excitatory and inhibitory neurons forming a network.\n\n\n\nThe work of \\cite{Ben-Itzhak, Yazdani2012} showed that a sparse optimal control signal that corresponds to jerk (expressed as $\\rho_{3}(t)$ in the notation of equation \\ref{eq:spikeTrain}) can model fast human movements with greater accuracy than the smooth control signal that results from using the $L_{2}$ norm. We now also propose that the control signals the nervous system uses are not limited to the jerk control signal. There is nothing preventing the nervous system from using a higher-order control signal (see Figure~\\ref{fig:resultsSnapCrackle} for comparisons higher-order derivative control signals). With each increase in the order of the control signal, the number of spikes increases and the timing of those spikes changes (as shown in Figure \\ref{fig:sparseControlSignals}). Because each wave form is different, these high-order derivative control signals can form a basis set, the elements of which are combined to form a subspace of control signals. The neuroscience motor control literature commonly refers to the elements in such basis sets as ``motor primitives\". These primitives are combined to control a variety of animal movements\\cite{GiszterNeuro}.\n\n\\subsection{Application of Sparsity to Extensions of Minimum Effort Control}\nThe minimum effort control problem proposed in section \\ref{subsec:miniumEffortControl} can be extended in numerous ways, e.g. \\cite{KawatoMinTorqueChange1989,BigDaddyKMTH, Yazdani2012, Ben-Itzhak, EmkenGreedyOptimizationErrorEffort,Flash,Liu2007}. These works and others, account for various aspects of movement and draw different conclusions regarding the nature of the motor system. For example, in \\cite{Liu2007}, several types of reaching movements under various conditions are analyzed and modeled via an extension of the minimum effort problem. The types of movements included both two and three dimensional reaching, with and without target perturbation, with and without obstacle avoidance, and under various instructions to the subject regarding how the target should be impacted. The following is a simplified version of the model in \\cite{Liu2007} that maintains its core concepts: a term for effort and a term for final state error. Equations \\ref{eq:LiuTodorovSimplification} and \\ref{eq:LiuTodorovSparse} give an example of how minimum effort control problems can easily be adapted to our method of generating sparse signals.\n\n\n", "itemtype": "equation", "pos": 29075, "prevtext": "\nwhere $K^{*}$ denotes the optimal amplitude or bound on the control signal, and $t_{i}^{*}$ denotes the optimal switching times. Figure \\ref{fig:sparseControlSignals} shows examples of several sparse optimal control signals.\n\n\n\n\n\\begin{figure}\n  \\centering\n  \\subfigure{\\label{subfig:jerk}\\includegraphics[scale = .5]{jerkControl-eps-converted-to}}        \\hspace{15mm}\n  \\subfigure{\\includegraphics[scale = .5]{snapControl-eps-converted-to}}\n  \\subfigure{\\label{subfig:crackle}\\includegraphics[scale = .5]{crackleControl-eps-converted-to}}  \\hspace{15mm}\n  \\subfigure{\\includegraphics[scale = .5]{popControl-eps-converted-to}}\n    \\caption{Examples of sparse optimal control signals $u_{i}(t)$ for $i = 3, \\ldots, 6$. Shown are movements that start from $t = 0$ and end at $t = 1$. }\n  \\label{fig:sparseControlSignals}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Sparse Optimal Control Signals in Fast Human Movements}\nThe sparse optimal control signals introduced in section \\ref{sec:SparseControlPointToPoint} are not only optimal with respect to a minimum-effort objective, but are also more biologically plausible when compared with non-sparse signals. Sparse optimal control signals can be are those that can be efficiently represented with Dirac delta functions, which resemble neuronal bursts or spikes. If we treat each spike as an idealized Dirac delta function, as done in \\cite{Dayan}, and as visualized in Figure~\\ref{fig:spikedUp}, then a spike sequence that represents an $n$-th order optimal control signal can be expressed as\n\n", "index": 33, "text": "\\begin{equation}\\label{eq:spikeTrain}\n\\rho_{n}(t) = K_{n}^{*}\\sum_{i = 0}^{n} (-1)^{i}\\delta(t - t_{i}^{*})\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"\\rho_{n}(t)=K_{n}^{*}\\sum_{i=0}^{n}(-1)^{i}\\delta(t-t_{i}^{*})\" display=\"block\"><mrow><mrow><msub><mi>\u03c1</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mi>K</mi><mi>n</mi><mo>*</mo></msubsup><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mi>i</mi></msup><mo>\u2062</mo><mi>\u03b4</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>-</mo><msubsup><mi>t</mi><mi>i</mi><mo>*</mo></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nEquation \\ref{eq:LiuTodorovSimplification} is the same as the minimum effort control problem discussed earlier, with the exception that hard equality constraints (the end-point boundary conditions) are now ``soft\" constraints and are penalized as a cost. The $w_{\\text{effort}}$ term dictates a trade off between minimizing effort and meeting the final boundary conditions. To have a sparse implementation of the above, we use the infinity-norm (sup) as before:\n\n\n", "itemtype": "equation", "pos": 31912, "prevtext": "\nwhere $K_{n}^{*}$ and $t_{i}^{*}$ can be found from equations \\ref{eq:sparseAmplitude} and \\ref{eq:sparseSwitch} respectively. The spike train represented by equation \\ref{eq:spikeTrain} is not postulated to be from a single neuron, but rather a population of excitatory and inhibitory neurons forming a network.\n\n\n\nThe work of \\cite{Ben-Itzhak, Yazdani2012} showed that a sparse optimal control signal that corresponds to jerk (expressed as $\\rho_{3}(t)$ in the notation of equation \\ref{eq:spikeTrain}) can model fast human movements with greater accuracy than the smooth control signal that results from using the $L_{2}$ norm. We now also propose that the control signals the nervous system uses are not limited to the jerk control signal. There is nothing preventing the nervous system from using a higher-order control signal (see Figure~\\ref{fig:resultsSnapCrackle} for comparisons higher-order derivative control signals). With each increase in the order of the control signal, the number of spikes increases and the timing of those spikes changes (as shown in Figure \\ref{fig:sparseControlSignals}). Because each wave form is different, these high-order derivative control signals can form a basis set, the elements of which are combined to form a subspace of control signals. The neuroscience motor control literature commonly refers to the elements in such basis sets as ``motor primitives\". These primitives are combined to control a variety of animal movements\\cite{GiszterNeuro}.\n\n\\subsection{Application of Sparsity to Extensions of Minimum Effort Control}\nThe minimum effort control problem proposed in section \\ref{subsec:miniumEffortControl} can be extended in numerous ways, e.g. \\cite{KawatoMinTorqueChange1989,BigDaddyKMTH, Yazdani2012, Ben-Itzhak, EmkenGreedyOptimizationErrorEffort,Flash,Liu2007}. These works and others, account for various aspects of movement and draw different conclusions regarding the nature of the motor system. For example, in \\cite{Liu2007}, several types of reaching movements under various conditions are analyzed and modeled via an extension of the minimum effort problem. The types of movements included both two and three dimensional reaching, with and without target perturbation, with and without obstacle avoidance, and under various instructions to the subject regarding how the target should be impacted. The following is a simplified version of the model in \\cite{Liu2007} that maintains its core concepts: a term for effort and a term for final state error. Equations \\ref{eq:LiuTodorovSimplification} and \\ref{eq:LiuTodorovSparse} give an example of how minimum effort control problems can easily be adapted to our method of generating sparse signals.\n\n\n", "index": 35, "text": "\\begin{equation}\n\\label{eq:LiuTodorovSimplification}\n\\begin{aligned}\n& \\underset{u(t)}{\\text{minimize}}\n& & ||\\textbf{x}(T) - \\textbf{x}_{f}||_{2}^{2} + w_{\\text{effort}}\\int_{0}^{T}u(t)^{2}dt   \\\\\n& \\text{subject to} & & \\dot{\\textbf{x}}(t) = A \\textbf{x}(t) + Bu(t) \\\\\n& & & \\textbf{x}(0) = \\textbf{x}_{i}\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u(t)}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle||\\textbf{x}(T)-\\textbf{x}_{f}||_{2}^{2}+w_{\\text{effort}}\\int_{0%&#10;}^{T}u(t)^{2}dt\" display=\"inline\"><mrow><msubsup><mrow><mo fence=\"true\">||</mo><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow><mo fence=\"true\">||</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mrow><msub><mi>w</mi><mtext>effort</mtext></msub><mo>\u2062</mo><mrow><mstyle displaystyle=\"true\"><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mn>0</mn><mi>T</mi></msubsup></mstyle><mrow><mi>u</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>t</mi></mrow></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}(t)=A\\textbf{x}(t)+Bu(t)\" display=\"inline\"><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mi>B</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nThis optimization problem, similar to the sparse minimum effort problem above in equation \\ref{eq:sparseEffort} can be written as follows:\n\n\n", "itemtype": "equation", "pos": 32713, "prevtext": "\nEquation \\ref{eq:LiuTodorovSimplification} is the same as the minimum effort control problem discussed earlier, with the exception that hard equality constraints (the end-point boundary conditions) are now ``soft\" constraints and are penalized as a cost. The $w_{\\text{effort}}$ term dictates a trade off between minimizing effort and meeting the final boundary conditions. To have a sparse implementation of the above, we use the infinity-norm (sup) as before:\n\n\n", "index": 37, "text": "\\begin{equation}\n\\label{eq:LiuTodorovSparse}\n\\begin{aligned}\n& \\underset{u(t)}{\\text{minimize}}\n& & ||\\textbf{x}(T) - \\textbf{x}_{f}||_{2}^{2} + w_{\\text{effort}}\\sup_{0 \\leq t \\leq T}|u(t)|  \\\\\n& \\text{subject to} & & \\dot{\\textbf{x}}(t) = A \\textbf{x}(t) + Bu(t) \\\\\n& & & \\textbf{x}(0) = \\textbf{x}_{i}\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u(t)}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle||\\textbf{x}(T)-\\textbf{x}_{f}||_{2}^{2}+w_{\\text{effort}}\\sup_{0%&#10;\\leq t\\leq T}|u(t)|\" display=\"inline\"><mrow><msubsup><mrow><mo fence=\"true\">||</mo><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow><mo fence=\"true\">||</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mrow><msub><mi>w</mi><mtext>effort</mtext></msub><mo>\u2062</mo><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mn>0</mn><mo>\u2264</mo><mi>t</mi><mo>\u2264</mo><mi>T</mi></mrow></munder><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}(t)=A\\textbf{x}(t)+Bu(t)\" display=\"inline\"><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mi>B</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>", "type": "latex"}, {"file": "1601.01410.tex", "nexttext": "\nAs before, we are using the property that every optimization function can be written equivalently as an optimization problem with a linear objective by introducing an auxiliary variable. Again, we have used the property that $w_{\\text{effort}}\\sup_{0 \\leq t \\leq T}|u(t)| \\leq K_{2} \\Rightarrow w_{\\text{effort}}|u(t)| \\leq K_{2}$. Therefore, we also have a ``bang-bang\" solution, since the control signal is hard bounded.\n\n\n\n\n\n\n\\section{Materials and Methods}\nThe human arm movement data for this work was originally collected by Karniel and Mussa-Ivaldi and used in their 2002 paper to investigate the nervous system's ability to adapt to perturbations. We used a subset of this data that was relevant for our study of fast movements (the baseline unperturbed movements) and summarize their experimental setup below and refer the reader to \\cite{BigDaddyKandMussa2002} for a more complete description.\n\nFive subjects participated in an experiment involving a manipulandum that restricted their movements to a the horizontal plane in front of the seated subjects (subjects participated separately in these experiments). During each trial, the subject watched a screen that displayed the position of their hand and the manipulandum in relation to three positional markers A, B and C. Each marker was separated by 10 cm and formed an equilateral triangle (see Figure~\\ref{fig:manipSetup}). For each trial, the subject was instructed to move the on-screen representation of the manipulandum from one target to another in about one third of a second with a tolerance of $\\pm$50ms. At the end of each trial feedback was given indicating if the subject had reached the target and also if the execution of their movement was within the allowed time window. The trajectories were recorded for all six possible movement types for all subjects over the course of four days. In all, there are 366 trials for the 5 subjects.\n\n\\begin{figure}\n  \\centering\n  \\subfigure[Experimental setup for collection of fast reaching movement data. Subjects sat down and held a manipulandum with their hands which they could maneuver about a 2D plane positioned in front of them perpendicular to their torsos. Regions 'A', 'B' and 'C' (Figure adapted from \\cite{Yazdani2012} with permission.)]{\\label{fig:manipSetup}\\includegraphics[width=0.3\\textwidth]{manipCorrect-eps-converted-to}}\n  \\hspace{5mm}\n  \\subfigure[A velocity profile for a typical hand movement trial. We attempt to identify the ``ballistic\" (fast) portion of the movement by using an onset and offset detection algorithm to automatically detect the beginning and end of the fast reaching portion of the movement. The ``onset\" is indicated by the leftmost red line and the ``offset\" is indicated by the rightmost red line. The ``corrective region\" refers to the time during which the subject attempts to correct any over or undershoot of the target, this region is not modeled. Data between the red lines is modeled, the rest is discarded.]{\\label{fig:typicalTrial}\\includegraphics[width=0.5\\textwidth]{trialDefinitions-eps-converted-to}}\n    \\caption{Setup for the recording of human reaching movements and a typical velocity profile from those data for one reaching movement trial.}\n  \\label{fig:animals}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor each trial, we only select the so-called ``ballistic\" portion of the movement (see Figure~\\ref{fig:typicalTrial}). That is, we select the portion of the trial where movement had started and the movement had completed its feedforward portion, the portion of the movement that was preplanned and not affected by peripheral feedback. Part of the justification for this understanding of fast reaching movements is that they are happening too quickly for a corrective proprioceptive signal to make a meaningful difference, as discussed in \\cite{gerdes1994noFeedback , keele1968noFeedback}. Thus we do not model the ``corrective\" portion of the movement that likely involves additional feedback information from the subjects' visual system and limbs in order to fix any error when attempting to reach to the targets. For this reason, we frame our approach as a feed forward control problem, because feedback is not involved in the movements. This is the same approach used in several studies including \\cite{Yazdani2012,karniel1997FeedforwardModel,Ben-Itzhak}.\n\nThere are various methods for movement onset and offset detection \\cite{BotzerKarniel, StaudeOnsetDetectionHumanMotor, StaudeOnsetDetectionVoluntaryMotorResonse}, and there is no standard technique for choosing the relevant portion of a movement since the definition of what is relevant may change from study to study or from one movement type to another.\n\nWe approach finding the start and end of movement by finding the point in time when the velocity profile has reached it's peak velocity. Fast movements always have a unique global maximum in the trial (unless the trial is an outlier) so finding the time at which this maximum occurs is unique. Once this point in time is found, we proceed to consider velocity samples before and after the peak velocity and find the sample that falls below a pre-determined threshold. This methods extracts the ballistic region of the movement.\n\nThe optimization procedures were implemented using CVX and Matlab. CVX is package for specifying and solving convex optimization problems \\cite{grant2011cvx}.\n\n\n\n\n\n\n\n\n\n\\section{Comparison of Sparse and Non-Sparse Model Predictions to Human Reaching Movements}\nFigure~\\ref{fig:resultsSnapCrackle} shows the average mean squared error (MSE) between the human subjects' trial velocity profiles and the velocity profiles generated by four computational models. We computed the MSE between the models' velocity profiles and those of the human subjects across time steps of the recorded movement. For all models, portions of the velocity profile which were forced to be accurate due to setting boundary conditions were not included in the MSE calculation. The figure highlights the canonical minimum jerk (as measured by the $L_{2}$ norm) model which results in a continuous, non-sparse control signal. We compare this model with one that minimizes jerk as measured by the $L_{\\infty}$ norm. In all cases the sparse signal generated by this model has a lower error than the minimum jerk $L_{2}$ norm model. This is not to say that the $L_{\\infty}$ norm model is decidedly better in all cases, but it is in most, and at the very least it performs similarly to the $L_{2}$ norm model while retaining the characteristic of an intuitive mapping to a spike train representation.\n\n\\begin{figure}[!htb]\n\\centering\n\\includegraphics[scale=0.35, angle = 270]{snapResults-eps-converted-to}\n\\caption{Comparison of average mean squared error between reaching trials for all five subjects and predictions made on those trials by four models. \\textcolor{red}{Red} bars indicate MSE for the $L_{2}$ norm based \\textcolor{red}{minimum jerk model} (\\emph{continuous}). MSEs shown in \\textcolor{green}{green}, \\textcolor{cyan}{cyan}, and \\textcolor{purple}{purple} are all based on the $L_{\\infty}$ norm, and thus result from \\emph{sparse} control signals. They represent  \\textcolor{green}{minimum jerk} (\\emph{sparse}), \\textcolor{cyan}{minimum snap}, and \\textcolor{purple}{minimum crackle}, respectively.\nThe sparse control signals on average have smaller error than the continuous control signal (resulting from use of the $L_{2}$ norm). In all comparisons but one, the sparse control signals result in lower MSE than the continuous control signal. The one exception is in the case of subject C where we see the the minimum crackle sparse control signal produce a greater error that the $L_{2}$ norm minimum jerk (continuous) control signal, however, the difference between the errors is not statistically significant (as determined by a Wilcoxon rank-sum test).}\n\\label{fig:resultsSnapCrackle}\n\\end{figure}\n\nWe also contrast the results of the $L_{2}$ norm model with three additional models that minimize snap, crackle, and pop (fourth, fifth, and sixth derivatives of position) as measured by the $L_{\\infty}$ norm (resulting in sparse control signals). Errors of all models employing sparse control signals are smaller than those generated by the minimum jerk model employing a non-sparse control signal in all cases but one. In this case, for subject C, the sparse crackle ($L_{\\infty}$) based model has a higher error than the non-sparse jerk ($L_{2}$ norm) based model, however, the difference between the non-sparse minimum jerk error and sparse crackle error is not statistically significant (by a Wilcoxon rank-sum test). This demonstrates that regardless of the chosen derivative of position used as the control signal (jerk, snap, or crackle), sparse signals are effective control strategies.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Discussion}\n\n\n\\subsection{Sparse Signals and Their Biological Plausibility}\nConverting traditional minimum effort models to their sparse counterparts via methods outlined in this work can bring these models closer to a plausible biological interpretation in several ways. At the level of the observation of human movement, studies have indicated that human subjects use sparse (intermittent) control strategies for ballistic movements to control activities that are continuous in nature \\cite{LoramIntermittantControlPhysiological, Ben-Itzhak}.\n\nAt the neural system level, there is evidence that various neural structures exhibit intermittent behavior. For example, the basal ganglia have been shown to be key components in the control of movement. Inputs to the basal ganglia, arriving from a large portion of the cerebral cortex, exhibit intermittent behavior \\cite{redgrave1999basalSwitching}. More generally, the basal ganglia as a whole are thought by most to be a network that switches between well defined states, in an intermittent fashion \\cite{redgrave1999basalSwitching}. Another example that is directly applicable to this work examines a primate tasked with making reaching movements towards two \\emph{possible} targets that the animal is accustomed to. For a given trial, the ``correct\" target is not initially known to the animal. At this point, two sustained signals (sustained neural activity), representing each potential target, are present in its pre-motor cortex. Once the ``correct\" target (for a given trial) is revealed, an abrupt switch occurs where the neural signal representing the ``incorrect target\" is suppressed and the ``correct\" neural signal remains \\cite{cisek2005neuralMultiSignalSwitch}. This is is clearly an abrupt switch between two states, as suggested by the sparse model of reaching tasks outlined in this work.\n\nAt the neuronal level, it has been shown in \\cite{LoewensteinBistabilityPKJCells} that Purkinje cells in the cerebellum (well known to be involved with motor control) exhibit bistability. That is, they have two modes of operation, each of which persist until a switching event occurs. This event consists of \\emph{brief neural pulses}, which switch the Purkinje cell back and forth from a highly active state to an inactive state. The modeled spike trains suggested in this work (e.g. Figure \\ref{fig:spikedUp}) may be interpreted as single neurons or they may be interpreted as ensembles of neurons working in concert. In either case, the the pulses controlling the bistable state of the Purkinje cell can be represented by Dirac delta functions, which is an accepted technique to mathematically represent spike trains \\cite{Dayan}. In this way, these signals more closely mirror the physiology of neurons when compared to their non-sparse counterparts (as shown in Figure \\ref{fig:2NormVsInfinityControlSig}). Conceptually, there is a mapping from sparse switches (Dirac deltas) to neuronal spikes, or groups of neurons spiking. Furthermore, spike timing, and its relevance in the neural coding of control information is directly represented, which is not the case with the continuous control signal method. In addition, the sparsity of these signals simplify the necessary output of a neural circuit used to drive motor function. For example, it would require only four spikes to encode the signal shown in Figure \\ref{subfig:jerk}. This concept lends itself to a hierarchical control structure employing ``higher level\" neural motor control structures that focus on learning and producing simple switching times, which drive and offload more complicated tasks and signal processing to lower level structures (as discussed in \\cite{BigDaddyKMTH}) which exist in the brain stem and spinal cord. To reiterate, we are not stating that the models in this work imply that a single neuron is driving any kind of motor function, or that these signals \\emph{directly} drive muscles. Rather, that, the concepts here are an abstraction which indicates that at some level of a hierarchy of neural motor control hierarchy, this sparse control approach is plausible.\n\n\\begin{figure}\n  \\centering\n  \\includegraphics[width=0.5\\textwidth]{2NormVsInfinityControlSig}\n  \\caption{The \\textcolor{red}{red} plot shows a minimized jerk control signal as measured by the $L_{2}$ norm. Note that it is parabolic and continuous (non-sparse). The \\textcolor{blue}{blue} plot shows a minimized jerk control signal as measured by the $L_{\\infty}$ norm. Note the distinct qualitative difference between the two. The $L_{\\infty}$ based signal is encoded by a finite number of abrupt changes, which can be encoded . Such a signal can be characterized by Dirac delta functions as show in Figures \\ref{fig:pulse} and \\ref{fig:spikedUp}. These spikes resemble neuronal spikes. In contrast, the $L_{2}$ norm based signal and has no obvious mapping to the physiology of neurons. (figure originally used in \\cite{Yazdani2012})}\n  \\label{fig:2NormVsInfinityControlSig}\n\\end{figure}\n\nIt is clear that the timing of spike trains plays an important role in their meaning and information content \\cite{DiLorenzoSpikeTiming2013, GerstnerMarkramFiringRates}. Unlike continuous control signals, the sparse signals discussed here have very specific switching times, each switching time being integral to the character of the resulting modeled movement. Because of this, the sparse approach can model spike timing as it pertains to neural coding of information, while the continuous models have no explicit representation of spike timing or abrupt system level switches.\n\nIt has been proposed that signal dependent noise contributes to the variability of observed movements \\cite{Harris1998}. Both \\cite{JonesWolpertSigDependNoiseForceProduction, WolpertScalingMotorNoiseMuscleStrength} provide empirical support for this proposal. This viewpoint correlates neural signal magnitude with the level of noise in the system, and therefore the accuracy of the movement. In other words, signals that are extremely strong (i.e. all available neurons for a given task are firing), inherently create more noise in their own system, lessening the accuracy of the movement. Using the $L_{\\infty}$ norm to generate sparse control signals has the additional benefit of setting a upper bound on the magnitude of the control signal, thus upper bounding the signal-dependent noise, and increasing accuracy. Thinking of the two ideas (upper bounding a control signal, and signal dependent noise) in this way may reconcile any perceived discrepancy between them. Figure \\ref{fig:2NormVsInfinityControlSig} shows the continuous signal exceeding the absolute magnitude of the sparse signal in two locations, thereby creating more noise in the system at those points. There is nothing explicitly preventing the continuous signal from becoming arbitrarily large at any point along the way, allowing the noise associated with large signals to reach arbitrarily large levels. Using $L_{\\infty}$ norm avoids this problem, as it sets a cap on the absolute magnitude of the control signal, and therefore, the signal dependent noise. In addition, preventing arbitrarily large signal magnitudes is in line with the physiology of (populations of) neurons, which can only fire with a maximum strength and frequency.\n\n\\subsection{Future Work}\nFuture work should consider extensions of the simple minimum effort cost functions used in this work in order to describe a richer set of movements. This can be accomplished by simply penalizing the norm of the effort term in any cost function (such as those outlined in \\cite{Berret}) with an $L_{\\infty}$ norm instead of the $L_{2}$ norm that is typically used. Additionally, the possibility be should explored that some type of \\emph{combination} of signals of the type shown in Figure \\ref{fig:sparseControlSignals} may be advantageous when modeling a richer set of movements. Combining select signals might form a basis set which would provide a larger subspace of signals that, by extension, controls a larger subspace of human movements than have been explored in this work. We envision a set of sparse signals generated by separate populations of neurons which produce sparse control signals that are combined (linearly or otherwise). This ``combination of signals\" concept is inline with the idea that the CNS achieves control through relative activation of motor primitives (as described by Giszter \\cite{GiszterNeuro}). He empirically illustrates how spinal motor primitives can be thought of as a basis set that can be combined in varying degrees to achieve a desired movement. However, in addition to controlling the relative magnitude of activation between primitives, changing the \\emph{timing} of the activation of the primitives is equally, if not more important, as only a proper sequence of motor primitive activation will provide the desired motor output. A basis set of signals as described in this work would be advantageous as it would require a minimum amount of neural structures to control human movement. This combination of ``on-off\" sparse signals might be thought of as controlling motor primitives by varying the activation times between them. Future work should consider combining such sparse signals to describe a richer set of movements. Furthermore, since this work is an abstraction of neural control signals, and it models reaching movements well, the abstraction may be a useful platform to apply to robotic motor control.\n\n\n\n\n\n\n\n\\section{Acknowledgments}\nWe are grateful to Amir Karniel for sharing the reaching movement data used in this work. We thank Robert Hecht-Nielsen for his guidance and Dr. William Lennon for useful discussion. We are especially grateful to Dr. Thomas McKenna and the Office of Naval Research for their support of this work.\n\n\n\\bibliographystyle{apalike}\n\n\n\n\n\\bibliography{sparseOptimalControlDissertation}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 33188, "prevtext": "\nThis optimization problem, similar to the sparse minimum effort problem above in equation \\ref{eq:sparseEffort} can be written as follows:\n\n\n", "index": 39, "text": "\\begin{equation}\n\\begin{aligned}\n& \\underset{u(t), K, K_{1}, K_{2}}{\\text{minimize}}\n& &  K  \\\\\n& \\text{subject to} & & \\dot{\\textbf{x}}(t) = A \\textbf{x}(t) + Bu(t) \\\\\n& & & \\textbf{x}(0) = \\textbf{x}_{i} \\\\\n& & & K = K_{1} + K_{2} \\\\\n& & & ||\\textbf{x}(T) - \\textbf{x}_{f}||_{2}^{2} \\leq K_{1} \\\\\n& & & |u(t)| \\leq \\nicefrac{K_{2}}{w_{\\text{effort}}} \\\\\n& & & K_{1} \\geq 0, K_{2} \\geq 0\n \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\underset{u(t),K,K_{1},K_{2}}{\\text{minimize}}\" display=\"inline\"><munder accentunder=\"true\"><mtext>minimize</mtext><mrow><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>K</mi><mo>,</mo><msub><mi>K</mi><mn>1</mn></msub><mo>,</mo><msub><mi>K</mi><mn>2</mn></msub></mrow></munder></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20X.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle K\" display=\"inline\"><mi>K</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xa.m4\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{\\textbf{x}}(t)=A\\textbf{x}(t)+Bu(t)\" display=\"inline\"><mrow><mrow><mover accent=\"true\"><mtext>\ud835\udc31</mtext><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mi>B</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{x}(0)=\\textbf{x}_{i}\" display=\"inline\"><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mtext>\ud835\udc31</mtext><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xc.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle K=K_{1}+K_{2}\" display=\"inline\"><mrow><mi>K</mi><mo>=</mo><mrow><msub><mi>K</mi><mn>1</mn></msub><mo>+</mo><msub><mi>K</mi><mn>2</mn></msub></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xd.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle||\\textbf{x}(T)-\\textbf{x}_{f}||_{2}^{2}\\leq K_{1}\" display=\"inline\"><mrow><msubsup><mrow><mo fence=\"true\">||</mo><mrow><mrow><mtext>\ud835\udc31</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msub><mtext>\ud835\udc31</mtext><mi>f</mi></msub></mrow><mo fence=\"true\">||</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>\u2264</mo><msub><mi>K</mi><mn>1</mn></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xe.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle|u(t)|\\leq\\nicefrac{{K_{2}}}{{w_{\\text{effort}}}}\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>u</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mrow><msub><mi mathvariant=\"normal\">K</mi><mn>2</mn></msub><mo>/</mo><msub><mi mathvariant=\"normal\">w</mi><mtext>effort</mtext></msub></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20Xf.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle K_{1}\\geq 0,K_{2}\\geq 0\" display=\"inline\"><mrow><mrow><msub><mi>K</mi><mn>1</mn></msub><mo>\u2265</mo><mn>0</mn></mrow><mo>,</mo><mrow><msub><mi>K</mi><mn>2</mn></msub><mo>\u2265</mo><mn>0</mn></mrow></mrow></math>", "type": "latex"}]