[{"file": "1601.05400.tex", "nexttext": "\nwhere $\\hat{\\Pi}_V$ denotes the set of legal partitions of $V$.\n\\end{definition}\n\n\n\\subsection{Complexity}\nIn order to prove that the WSP problem is NP-hard, we perform a\nreduction from the \\emph{Multiway Cut Problem}~\\cite{dahlhaus1992},\nwhich Dahlhaus et al.~has shown is NP-hard for fixed $k \\geq 3$.\n\n\n\n\n\\begin{definition}[Multiway Cut]\n  \\label{def:multiway_cut1}\n  Given a tuple $(V,E,S,w)$ consisting of a graph $(V,E)$, a {\\em terminal set} $S=\\{s_1,\\ldots,s_k\\}$ of vertices,\n  and a non-negative weight $w(u,v)$ for each edge $(u,v)\\in E$, a {\\em multiway cut} is an edge set $E'$\n  the removal of which leaves each terminal in separate components. The solutions to the MWC problem are the multiway cuts\n  of minimal total weight.\n\\end{definition}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{theorem}\n\\label{tho:waog_is_np}\n    The WSP problem is NP-hard for graphs $G = (V, E_d, E_f)$\n    that have a chain of three or more edges in $E_f$.\n\\end{theorem}\n\\begin{proof}\nWe prove NP-hardness through a reduction from multiway cut.\nGiven an MWC-instance, $(V,E,S,w)$, we build a WSP-instance as follows. Let $G = (V,E_d,E_f)$,\n$E_f = \\{(s_i,s_j):1\\leq i<j\\leq k\\}$, and $E_d = \\emptyset$.\nDefine the {\\em cut} of a partition as the set of edges that connect the blocks:\n", "itemtype": "equation", "pos": 16184, "prevtext": "\n\n\n\n\n\n\\title{Fusion of Array Operations at Runtime}\n\n\\author{\\IEEEauthorblockN{Mads R. B. Kristensen,\nSimon A. F. Lund,\nTroels Blum, and\nJames Avery}\n\\IEEEauthorblockA{Niels Bohr Institute, University of Copenhagen, Denmark\\\\\n    \\{madsbk/safl/blum/avery\\}@nbi.ku.dk\n}\n}\n\n\\maketitle\n\n\n\n\n\n\n\n\n\n\\newtheorem{theorem}{Theorem}\n\\newtheorem{prop}{Proposition}\n\\newtheorem{definition}{Definition}\n\\newtheorem{corollary}{Corollary}\n\\newtheorem{lemma}{Lemma}\n\\newtheorem{remark}{Remark}\n\n\n\n\n\n\n\n\n\\ifdefined\\ShortVersion\n    \\ifdefined\\LongVersion\n        \\PackageError{Macros}{Both long and short version macro is defined!}{}\n    \\fi\n    \\PackageInfo{Macros}{Building the Short version}\n\\else\n    \\ifdefined\\LongVersion\n    \\else\n    \\fi\n    \\PackageInfo{Macros}{Building the Long version (default)}\n\\fi\n\n\n\\begin{abstract}\n    We address the problem of fusing array operations based on criteria\nsuch as shape compatibility, data reusability, and communication. We\nformulate the problem as a graph partition problem that is general\nenough to handle loop fusion, combinator fusion, and other types of\nsubroutines.\n\n\\end{abstract}\n\n\\newsavebox{\\LstCFuseExampleA}\n\\begin{lrbox}{\\LstCFuseExampleA}\n\\begin{lstlisting}[language=c, numbers=none, linewidth=0.41\\linewidth]\n#define N 1000\ndouble A[N], B[N], T[N];\nfor(int i=0; i<N; ++i)\n  T[i] = B[i] * A[i];\nfor(int i=0; i<N; ++i)\n  A[i] += T[i];\n\\end{lstlisting}\n\\end{lrbox}\n\n\\newsavebox{\\LstCFuseExampleB}\n\\begin{lrbox}{\\LstCFuseExampleB}\n\\begin{lstlisting}[language=c, numbers=none, linewidth=0.41\\linewidth]\nfor(int i=0; i<N; ++i){\n  T[i] = B[i] * A[i];\n  A[i] += T[i];\n}\n\\end{lstlisting}\n\\end{lrbox}\n\n\\newsavebox{\\LstCFuseExampleC}\n\\begin{lrbox}{\\LstCFuseExampleC}\n\\begin{lstlisting}[language=c, numbers=none, linewidth=0.41\\linewidth]\nfor(int i=0; i<N; ++i){\n  double t = B[i] * A[i];\n  A[i] += t;\n}\n\\end{lstlisting}\n\\end{lrbox}\n\n\\newsavebox{\\LstCNonFuseExample}\n\\begin{lrbox}{\\LstCNonFuseExample}\n\\begin{lstlisting}[language=c, numbers=none, linewidth=0.41\\linewidth]\n#define N 1000\ndouble A[N], B[N], T[N];\nint j = N;\nfor(int i=0; i<N; ++i)\n  T[i] = B[i] * A[i];\nfor(int i=0; i<N; ++i)\n  A[i] += T[--j];\n\\end{lstlisting}\n\\end{lrbox}\n\n\n\n\\section{Introduction}\n\nArray operation fusion is a program transformation that combines, or\nfuses, multiple array operations into a \\emph{kernel} of\noperations. When it is applicable, the technique can drastically\nimprove cache utilization through temporal data locality and enables\nother program transformations such as streaming and array\ncontraction~\\cite{Gao93_array_contraction}. In scalar programming\nlanguages, such as C, array operation fusion typically corresponds to\nloop fusion where multiple computation loops are combined into\na single loop. The effect is a reduction of array traversals\n(Fig. \\ref{lst:fuse_C_code}). Similarly, in functional\nprogramming languages it typically corresponds to fusing\nindividual combinators. In array programming languages, such as\nHPF~\\cite{loveman1993high} and ZPL~\\cite{zpl00}, fusing array operations\nare crucial, since a program written in these languages will consist\nalmost exclusively of array operations. Lewis et al. demonstrates a\nexecution time improvement of up to 400\\% when optimizing for array\ncontraction at the array rather than the loop level~\\cite{Lewis1998}.\n\nHowever, not all fusions of operations are\nallowed. Consider the two loops in\nFig. \\ref{lst:nonfuse_example_in_c}; since the second loop traverses\nthe result from the first loop in reverse, we must compute the\ncomplete result of the first loop before continuing to the second loop,\npreventing fusion.\nClever analysis sometimes allows transforming the program into a form that is amenable to fusion, but\nsuch analysis is outside the scope of the present work.\nThroughout the remainder of this paper, we assume that any such optimizations have already been performed.\n\nDeciding which operations to fuse together is the same as\nfinding a partition of the set of operations in which the blocks obey\nthe same execution dependency order as the individual operations, and in\nwhich no block contains two operations that may not be\nfused. Out of all such partitions, we want to find one that enables us to\nsave the most computation or memory.  It is not an easy problem, in\npart because fusibility is not transitive. That is, even when it is\nlegal to fuse subroutines $x,y$ and $y,z$, it may be illegal for\nall three of $x,y,z$ to be executed together. Thus, one local decision\ncan have global consequences on future possible partitions.\n\nThe problem can be stated in a quite general way: ``\\emph{Given a\n  mixed graph, find a legal partition of vertices that cuts all\n  non-directed edges and minimizes the cost of the\n  partition.}''\\footnote{See Sec. \\ref{sec:subroutine_partition} for\n  the definition of a legal partition and legal cost function.}. We\ncall this problem the \\emph{Weighted Subroutine Partition} problem,\nabbreviated WSP.\n\n\\begin{figure}\n    \\centering\n    \\subfloat[][Two forward iterating loops.]{\\label{lst:fuse_C_code_a}\\usebox{\\LstCFuseExampleA}} \\hspace{40px}\n    \\subfloat[][A forward and a reverse iterating loop.]{\\label{lst:nonfuse_example_in_c}\\usebox{\\LstCNonFuseExample}}\\\\\n    \\subfloat[][Loop fusion: the two loops from Fig. \\ref{lst:fuse_C_code_a} fused into one.]{\\label{lst:fuse_C_code_b}\\usebox{\\LstCFuseExampleB}}\\hspace{40px}\n    \\subfloat[][Array contraction: the temporary array \\texttt{T} from Fig. \\ref{lst:fuse_C_code_b} is contracted into the scalar \\texttt{t}.]{\\label{lst:fuse_C_code_c}\\usebox{\\LstCFuseExampleC}}\n    \\caption{Loop fusion and array contraction in C.}\n    \\label{lst:fuse_C_code}\n\\end{figure}\n\nThe general formulation is applicable to a broad range of optimization\nobjectives. The cost function can penalize any\naspect of the partitions, e.g.~data accesses, memory use,\ncommunication bandwidth, and/or communication latency. The only\nrequirement to the cost function is monotonicity:\n\\begin{itemize}\n\\item Everything else equal, it must be cost neutral or a cost\n  advantage to place two subroutines within the same partition block.\n\\end{itemize}\nSimilarly, the definition of partition legality is flexible.\n\\begin{itemize}\n\\item Any aspect of a pair of subroutines can make them illegal to\n  have in the same partition block, such as preventing mixing of\n  sequential and parallel loops, different array shapes, or access\n  patterns.\n\\item Subroutines may have dependencies that impose a partial order.\n  Then a legal partition must observe this order, i.e.~must not introduce cycles.\n  \n  \n  \n  \n\\end{itemize}\n\nThe remainder of the paper is structured as follows: In Section 3, we formally define\nthe {\\em Weighted Subroutine Partition problem}, which unifies array\noperation-, loop-, and combinator fusion, and prove that it is\nNP-hard. Section 4 shows how WSP is used to solve array operation\nfusion for the {\\em Bohrium} automatic parallelization framework, and gives a\ncorrectness proof. In Section 5, we describe a branch-and-bound\nalgorithm that computes an optimal solution, as well as two approximation\nalgorithms that compute good results rapidly enough to use in\nJIT-compilation. All the algorithms are implemented in Bohrium, and\nwork for any choice of monotonic cost function, which allows us to compare\ndirectly with other fusion schemes from the literature.  Section 6\nshows measurements performed on 15 benchmark programs, comparing both\nthe optimal to the approximation schemes, and to three other fusion\nschemes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Related Work}\n\nThe WSP problem presented in this paper generalizes \nthe \\emph{Weighted Loop Fusion} (WLF) problem first described by\nKennedy in \\cite{Kennedy1994} (by the name \\emph{Fusion for\n  Reuse}). The method aims\nto maximize data locality through loop fusion (corresponding to the\n\\textbf{Max Locality} cost model in Section \\ref{sec:alternative-cost}).\n\\ifdefined{} The WLF\nproblem is described as a graph problem where vertices represent\ncomputation loops, directed edges represent data dependencies between\nloops, and undirected edges represent data sharing between\nloops. Edges that connect fusible loops have a non-negative weight\nthat represents the cost saving associated with fusion of the two\nloops. Edges that connect non-fusible loops are marked as\nfuse-preventing. Now, the objective is to find a partition of the\nvertices into blocks such that no block has vertices connected with\nfuse-preventing edges and that minimize the weight sum of edges that\nconnects vertices in different blocks.  \\else\nThe WLF problem is described as a graph-partitioning problem on a\n\\emph{Loop Dependece Graph} with static weights between fusible loops.\n\\fi\n\nMegiddo et al.~have shown that it is possible to formulate the WLF problem\nas integer linear programming (ILP)~\\cite{Megiddo1997}.\n\\ifdefined{} Based on the WLF graph, the idea is to\ntransform the edges into linear constraints that implement the\ndependency and fusibility between the vertices and transform weights\ninto ILP objective variables. The values of the objective variables are\neither the values of the weights when the associated vertices are in\ndifferent partitions or zero when in the same partition. The objective of\nthe ILP is then to minimize the value of the objective variables .  The\nproblem is NP-hard, but the hope is that with an efficient ILP solver,\nsuch as \\texttt{lp-solve}~\\cite{lpsolve}, and a modest problem size it\nmight be practical as a compile time optimization.  \\fi\n\nDarte et al.~\\cite{Darte2002} proved that the WLF problem is NP-hard\nthrough a reduction from multiway cut \\cite{dahlhaus1992}. Furthermore, since maximizing data\nlocality may not maximize the number of array\ncontractions\\ifdefined{} (Fig. \\ref{lst:alain_example})\\fi,\nthey introduce an ILP formulation with the sole objective of maximizing\nthe number of array contractions (the \\textbf{Max\n  Contract} cost model in Section~\\ref{sec:alternative-cost}).\n\nRobinson et al. \\cite{Robinson2014} describe an ILP scheme that\ncombines the objectives of Megiddo and Darte: both\nmaximizing data locality and array contractions while giving priority to data\nlocality (corresponds to our \\textbf{Robinson} cost model).\n\nHowever, optimization using WLF has a significant limitation: it\nonly allows static edge weights. That is, when building the WLF graph the\nvalues of edge weights are assigned once and for all. This limitation\nis the main reason that we needed to develop the Weighted Subroutine Partition\nformalism, because static edge weights are in fact inappropriate for\naccurate measurement of data locality.\n\n\\begin{figure*}\n    \\centering\n    \\subfloat[][]{\\includegraphics[trim={10px 20px 10px 10px}, clip, width=0.5\\linewidth]{gfx/WLF_fail_1.pdf}}\\\\\n    \\subfloat[][]{\\label{fig:weighted_loop_fusion_graphB}\\includegraphics[trim={15px 15px 10px 15px}, clip, width=0.5\\linewidth]{gfx/WLF_fail_2.pdf}}\n    \\subfloat[][]{\\label{fig:weighted_loop_fusion_graphC}\\includegraphics[trim={10px 15px 15px 15px}, clip, width=0.5\\linewidth]{gfx/WLF_fail_3.pdf}}\n    \\caption{A WLF example where the objective is to maximize data locality. (a) shows the initial graph. (b) shows a partition where loop 1 is in one block and loops 2-6 are in another block. (c) shows a partition where loops 1-2 are in one block and loops 3-6 are in another block.}\n\\label{fig:weighted_loop_fusion_graph}\n\\end{figure*}\n\nConsider the WLF example in Fig.~\\ref{fig:weighted_loop_fusion_graph},\nwhich consist of six loops and three arrays $A,B,C$ of size $1$. The\nobjective is to maximize data locality, represented by weight edges connecting the\nloops that access the same\narrays. Fig.~\\ref{fig:weighted_loop_fusion_graphB} shows the optimal WLF\nsolution to the example, which reduces the total weight from 13 to\n3. However, the actual number of array accesses is only reduced from\n10 to 7. A better strategy is to fuse loop 1-2\n(Fig.~\\ref{fig:weighted_loop_fusion_graphC}), which will reduce the\nactual number of array accesses from 10 to 4.\n\nThe problem with the WLF formulation here is that all the loops that read\nthe same data must be pair-wise connected with a weight, leading to\nover-estimating potential data reuse. In the Weighted Subroutine\nPartition formulation, we work with {\\em partitions} instead of\nindividual merges, and assign a cost to a partition as a whole. The\ncost-savings of a merge is then the difference in cost between the\npartitions before and after merging, allowing accurate descriptions of\ndata-reuse through the costs function.\n\n\n\n\\section{The Weighted Subroutine Partition Problem}\n\\label{sec:subroutine_partition}\n\nThe Weighted Subroutine Partition (WSP) problem is an extension of the\n\\emph{The Weighted Loop Fusion Problem}~\\cite{Kennedy1994} where we\ninclude the weight function in the problem formulation. In this\nsection, we will formally define the WSP problem and show that it is\nNP-hard.\n\n\\begin{definition}[WSP graph] \n\\label{def:wsp_graph}\nA {\\em WSP graph} is a triplet $G = (V, E_d, E_f)$ such that $(V, E_d)$ is a\ndirected acyclic graph describing dependency order, and $(V,E_f)$ is\nan undirected graph of forbidden edges.\n\\end{definition}\n\n\\begin{definition}[WSP order]\n\\label{def:wsp_vertex_order}\nA WSP graph, $G = (V, E_d, E_f)$, induces a partial order ${   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}}$ on\n$V$ as follows: $v {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} v'$ iff there exists a path from $v$ to $v'$\nin $(V,E_d)$. Since $(V,E_d)$ is acyclic, this partial order is\nstrict.\n\\end{definition}\n\n\\begin{definition}[Partitions]\n\\label{def:waof_partition}\nA {\\em partition} of a set $V$ is a set $P = \\{B_1,B_2,\\ldots,B_k\\}$ such that $V$ is the disjoint union of the {\\em blocks} $B_1,\\ldots,B_k$.\nThe set $\\Pi_V$ of all partitions of $V$\nis partially ordered as $P \\le P'$ iff $\\forall B\\in P\\exists B' \\in P'\\colon B\\subseteq B'$,\ni.e.~if each block in $P$ is a subset of a block in $P'$.\n\\end{definition}\nThe set of partitions $\\Pi_V$ is a lattice with bottom and top elements $\\bot = \\{V\\}$ and $\\top = \\{\\{V\\}\\}$.\nThe successors to a partition $P$ in the partition order are those partitions that are identical to $P$ except for merging two of the blocks.\nConversely, splitting a block results in a predecessor. We write $P {\\prec} P'$ if $P'$ is a successor to $P$. This defines a\nbinary {\\em merge operator}:\n\\begin{definition}[Block merge operator]\n  \\label{def:block_merge}\n  Given a partition $P = \\{B_1,B_2,\\ldots\\}$, define $P {/}\n  (B_1,B_2) = \\{B_1\\cup B_2,\\ldots\\}$ to be the successor to $P$ in\n  which $B_1$ and $B_2$ are merged and all other blocks are left the\n  same.\n\\end{definition}\n\n\\begin{definition}[Legal partition]\n\\label{def:wsp_legal_partition}\nGiven a WSP graph, $G=(V, E_d, E_f)$, we say that the partition $P\\in\n\\Pi_V$ is {\\em legal} when the following holds for every block $B\\in P$:\n\\begin{enumerate}\n    \\item $\\nexists v_1,v_2\\in B: (v_1,v_2) \\in E_f$, i.e.~ no block contains both endpoints of a forbidden edge.\n    \\item If $v_1 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} v_2 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} v_3$ and $v_1,v_3\\in B$ then $v_2\\in B$,  i.e.~ the directed edges between blocks must not form cycles.\n\\end{enumerate}\n\\end{definition}\n\n\\begin{definition}[WSP cost]\n\\label{def:wsp_cost}\nGiven a partition, $P$, of vertices in a WSP graph, a {\\em cost function}\n${\\mathsf{{cost}}}(P)$ returns the cost of the partition and respects the following\nconditions:\n\\begin{enumerate}\n    \\item ${\\mathsf{{cost}}}(P) \\geq 0$\n    \\item $P \\leq P' \\implies {\\mathsf{{cost}}}(P) \\geq {\\mathsf{{cost}}}(P')$\n\\end{enumerate}\n\\end{definition}\n\n\\begin{definition}[WSP problem]\n\\label{def:wsp_solution}\nGiven a WSP graph, $G = (V, E_d, E_f)$, and a cost function,\n${\\mathsf{{cost}}}(P)$, the WSP problem is the problem of finding a legal\npartition, $P^*$, of $V$ with minimal cost:\n\n", "index": 1, "text": "\\begin{equation}\n  \\label{eq:wsp_solution}\n    P^*\\in {\\operatornamewithlimits{argmin}}_{P\\in \\hat{\\Pi}_V}{\\mathsf{{cost}}}(P)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"P^{*}\\in{\\operatornamewithlimits{argmin}}_{P\\in\\hat{\\Pi}_{V}}{\\mathsf{{cost}}}%&#10;(P)\" display=\"block\"><mrow><msup><mi>P</mi><mo>*</mo></msup><mo>\u2208</mo><mrow><mrow><munder><mo movablelimits=\"false\">argmin</mo><mrow><mi>P</mi><mo>\u2208</mo><msub><mover accent=\"true\"><mi mathvariant=\"normal\">\u03a0</mi><mo stretchy=\"false\">^</mo></mover><mi>V</mi></msub></mrow></munder><mo>\u2061</mo><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nThe cuts of the legal WSP partitions $\\hat{\\Pi}_V$ are exactly the set of multiway cuts:\n\\begin{itemize}\n\\item The set of directed edges in $E_d$ is empty, which makes\n  Def.~\\ref{def:wsp_vertex_order} and\n  Def.~\\ref{def:wsp_legal_partition}(2) trivially satisfied.\n\\item The fuse-preventing edges $E_f$ connect each terminal\n  in $S$ and no other vertices. Hence, by\n  Def.~\\ref{def:wsp_legal_partition}(1), $\\hat{\\Pi_V}$ are exactly\n  those partitions for which no block contains two terminals.\n\\end{itemize}\nLet now the cost function be the total weight of the cut:\n", "itemtype": "equation", "pos": 17583, "prevtext": "\nwhere $\\hat{\\Pi}_V$ denotes the set of legal partitions of $V$.\n\\end{definition}\n\n\n\\subsection{Complexity}\nIn order to prove that the WSP problem is NP-hard, we perform a\nreduction from the \\emph{Multiway Cut Problem}~\\cite{dahlhaus1992},\nwhich Dahlhaus et al.~has shown is NP-hard for fixed $k \\geq 3$.\n\n\n\n\n\\begin{definition}[Multiway Cut]\n  \\label{def:multiway_cut1}\n  Given a tuple $(V,E,S,w)$ consisting of a graph $(V,E)$, a {\\em terminal set} $S=\\{s_1,\\ldots,s_k\\}$ of vertices,\n  and a non-negative weight $w(u,v)$ for each edge $(u,v)\\in E$, a {\\em multiway cut} is an edge set $E'$\n  the removal of which leaves each terminal in separate components. The solutions to the MWC problem are the multiway cuts\n  of minimal total weight.\n\\end{definition}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{theorem}\n\\label{tho:waog_is_np}\n    The WSP problem is NP-hard for graphs $G = (V, E_d, E_f)$\n    that have a chain of three or more edges in $E_f$.\n\\end{theorem}\n\\begin{proof}\nWe prove NP-hardness through a reduction from multiway cut.\nGiven an MWC-instance, $(V,E,S,w)$, we build a WSP-instance as follows. Let $G = (V,E_d,E_f)$,\n$E_f = \\{(s_i,s_j):1\\leq i<j\\leq k\\}$, and $E_d = \\emptyset$.\nDefine the {\\em cut} of a partition as the set of edges that connect the blocks:\n", "index": 3, "text": "\\[{\\mathsf{{cut}}}(P) = \\left\\{{(u,v)\\in E_f}\\middle| {\\nexists B\\in P: (u,v)\\in B}\\right\\}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"{\\mathsf{{cut}}}(P)=\\left\\{{(u,v)\\in E_{f}}\\middle|{\\nexists B\\in P:(u,v)\\in B%&#10;}\\right\\}\" display=\"block\"><mrow><mrow><mi>\ud835\uddbc\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><msub><mi>E</mi><mi>f</mi></msub></mrow><mo>|</mo><mrow><mrow><mrow><mi mathvariant=\"normal\">\u2204</mi><mo>\u2062</mo><mi>B</mi></mrow><mo>\u2208</mo><mi>P</mi></mrow><mo>:</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>B</mi></mrow></mrow><mo>}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nThis is a valid WSP cost function (by Def.~\\ref{def:wsp_cost}): it\nis non-negative, and if $P \\le P'$ in the partition order, then\n${\\mathsf{{cut}}}(P) \\supseteq {\\mathsf{{cut}}}(P')$, whereby ${\\mathsf{{cost}}}(P) \\ge {\\mathsf{{cost}}}(P')$.\nSince ${\\mathsf{{cost}}}(P)$ is the MWC total weight, Eq.~\\eqref{eq:wsp_solution}\ngives the multiway cuts of minimal total weight, concluding the proof.\n\\end{proof}\n\n\n\n\n\n\n\\section{WSP used to optimize array operation fusion in Bohrium}\nStating the WSP problem formulation in a general way allows a great deal of flexibility, as long as the cost function is monotonic.\nIn this section, we use WSP to solve a concrete optimization problem,\ndemonstrating its real world use. The concrete problem is an\noptimization phase within the Bohrium runtime system~\\cite{kristensen2014bohrium} in which a set of array operations are\npartitioned into computation kernels -- the \\emph{Fusion of Array\n  Operations} (FAO) problem:\n\\begin{definition}\n  \\label{def:fao_problem}\n  Given a set of array operations, $A$, equipped with a strict partial\n  order imposed by the data dependencies between them, $(A,{   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}})$,\n  find a partition, $P$, of $A$ for which:\n  \\begin{enumerate}\n  \\item All operations within a block in $P$ are fusible\n        (Def. \\ref{def:data-parallelism})\n  \\item For all blocks, $B\\in P$, if $a_1 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a_2 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a_3$ and\n        $a_1,a_3\\in B$ then $a_2\\in B$. (I.e.~the partition obeys dependency order).\n  \\item The cost of the partition (Def. \\ref{def:bh_partition_cost}) is\n        minimal.\n  \\end{enumerate}\n\\end{definition}\nIn the following, we will provide a brief description of Bohrium and show\nthat the WSP problem solves the FAO problem (Theorem \\ref{tho:wsp_is_fao}).\n\n\\subsection{Fusion of Array Operations in Bohrium}\n\\newsavebox{\\LstPyCodeExample}\n\\begin{lrbox}{\\LstPyCodeExample}\n    \\lstinputlisting[linewidth=0.50\\linewidth,language=python, numbers=left, otherkeywords={as}]{benchmark/greedy_fail.py}\n\\end{lrbox}\n\n\\newsavebox{\\LstPyByteCodeExample}\n\\begin{lrbox}{\\LstPyByteCodeExample}\n\\begin{lstlisting}[linewidth=0.33\\linewidth, language=python, numbers=left, otherkeywords={ADD, MUL, SYNC, DEL, MAX, COPY, MIN}]\nCOPY A, 0\nCOPY B, 0\nCOPY D, 0\nCOPY E, 0\nADD A, A, D[:-1]\nCOPY A, D[:-1]\nADD B, B, E[:-1]\nCOPY B, E[:-1]\nMUL T, A, B\nMAX D[1:], T, E[1:]\nMIN E[1:], T, D[1:]\nDEL A\nDEL B\nDEL E\nDEL T\nSYNC D\nDEL D\n\\end{lstlisting}\n\\end{lrbox}\n\n\\begin{figure}\n    \\centering\n    \\subfloat[][]{\\label{fig:python_code_a}\\usebox{\\LstPyCodeExample}}\\hspace{25px}\n    \\subfloat[][]{\\label{fig:python_code_b}\\usebox{\\LstPyByteCodeExample}}\n    \\caption{A Python application that utilizes the Bohrium runtime\n      system. In order to demonstrate various challenges and\n      trade-offs, the application is synthetic. (a) shows the Python\n      code and (b) shows the corresponding Bohrium array bytecode.}\n    \\label{fig:python_code}\n\\end{figure}\n\nBohrium is a computation backend for array programming languages and\nlibraries that supports a range of languages, such as Python, C++, and\n.NET, and a range of computer architectures, such as CPU, GPU, and\nclusters of these. The idea is to decouple the domain specific frontend\nimplementation from the hardware specific backend implementation in\norder to provide a high-productivity and high-performance framework.\n\nSimilar to NumPy~\\cite{van2011numpy}, a Bohrium array operation operates on a set of\ninputs and produces a set of outputs~\\cite{kristensen2014bohrium}.\nBoth input and output operands are \\emph{views} of arrays. An array\nview is a structured way to observe the whole or parts of an\nunderlying \\emph{base} array. A base array is always a contiguous\none-dimensional array whereas views can have any shape, stride, and\ndimensionality~\\cite{kristensen2014bohrium}.  \\emph{In the following, when we\n  refer to an array, we mean an array view; when we refer to identical\n  arrays, we mean identical array views that points to the same base\n  array; and when we refer to overlapping arrays, we mean array views\n  that points to some of the same elements in a common base array.}\n\nFig.~\\ref{fig:python_code_a} shows a Python application that\nuses Bohrium as a drop-in replacement for NumPy. The application\nallocates and initiates four arrays (line 4-7), manipulates those\narrays through array operations (line 8-14), and prints the content of\none of the arrays (line 16).\n\nAs Bohrium is language agnostic, it translates the Python array\noperations into bytecode (Fig.~\\ref{fig:python_code_b}) that the\nBohrium backend can execute\\footnote{For a detailed description of\n  this Python-to-bytecode translation we refer to previous work\n  \\cite{PyHPC13_bohrium, PyHPC14_npbackend}.}. In the case of Python,\nthe Python array operations and the Bohrium array bytecode is almost in\none-to-one mapping. The first bytecode operand is the output\narray and the remaining operands are either input arrays or input\nliterals. Since there is no scope in the bytecode, Bohrium uses\n\\texttt{DEL} to destroy arrays and \\texttt{SYNC} to move array data\ninto the address space of the frontend language -- in this case\ntriggered by the Python \\texttt{print} statement\n(Fig.~\\ref{fig:python_code_a}, line 16). There is no explicit bytecode\nfor constructing arrays; on first encounter, Bohrium constructs them\nimplicitly. \n\n\nIn the next phase, Bohrium partitions the list of array operations\ninto blocks that consists of fusible array operations -- the FAO\nproblem. As long as the preceding constraints between the array\noperations are preserved, Bohrium is free to reorder them as it sees\nfit, making code optimizations based on data locality, array contraction, and\nstreaming possible.\n\nIn the final phase, the hardware specific backend implementation\nJIT-compiles each block of array operations and executes them.\n\n\\subsubsection{Fusibility}\nIn order to utilize data-parallelism, Bohrium and most other array\nprogramming languages and libraries require \\emph{data-parallelism}\nof array operations that are to be executed together. The property ensures that\nthe runtime system can calculate each output element independently\nwithout any communication between threads or processors. In Bohrium,\nall array operation must have this property.\n\nWe first introduce some operations that keep track of memory allocation,\ndeallocation, reads, and writes:\n\\begin{definition}\n  Given an array operation $f$, the notation ${\\mathsf{{in}}}[f]$ denotes the\n  set of arrays that $f$ reads; ${\\mathsf{{out}}}[f]$ denotes the set of arrays\n  that $f$ writes; ${\\mathsf{{new}}}[f]$ denotes the set of new arrays that $f$\n  allocates; and ${\\mathsf{{del}}}[f]$ denotes the set of arrays that $f$\n  deletes (or de-allocates).\n\nFurthermore, given a set of array operations, $B$, we define the following:\n\n", "itemtype": "equation", "pos": 18246, "prevtext": "\nThe cuts of the legal WSP partitions $\\hat{\\Pi}_V$ are exactly the set of multiway cuts:\n\\begin{itemize}\n\\item The set of directed edges in $E_d$ is empty, which makes\n  Def.~\\ref{def:wsp_vertex_order} and\n  Def.~\\ref{def:wsp_legal_partition}(2) trivially satisfied.\n\\item The fuse-preventing edges $E_f$ connect each terminal\n  in $S$ and no other vertices. Hence, by\n  Def.~\\ref{def:wsp_legal_partition}(1), $\\hat{\\Pi_V}$ are exactly\n  those partitions for which no block contains two terminals.\n\\end{itemize}\nLet now the cost function be the total weight of the cut:\n", "index": 5, "text": "\n\\[\n {\\mathsf{{cost}}}(P) = \\sum_{(u,v)\\in {\\mathsf{{cut}}}(P)} w(u,v)\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"{\\mathsf{{cost}}}(P)=\\sum_{(u,v)\\in{\\mathsf{{cut}}}(P)}w(u,v)\" display=\"block\"><mrow><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddbc\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder><mrow><mi>w</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nHere, ${\\mathsf{{ext}}}[B]$ gives the set of external data accesses.\n``$\\sqcup$'' is disjoint union: arrays that are both\nread and written are counted twice.\n\\texttt{DEL} and \\texttt{SYNC} are counted as having no input or output.\n\\end{definition}\nThis allows us to formulate the data-parallelism property that determines when array\noperation fusion is allowed:\n\\begin{definition}\n\\label{def:data-parallelism}\nA Bohrium array operation, $f$, is data parallel,\ni.e.,~each output element can be calculated independently, when the following holds:\n\n", "itemtype": "equation", "pos": 25484, "prevtext": "\nThis is a valid WSP cost function (by Def.~\\ref{def:wsp_cost}): it\nis non-negative, and if $P \\le P'$ in the partition order, then\n${\\mathsf{{cut}}}(P) \\supseteq {\\mathsf{{cut}}}(P')$, whereby ${\\mathsf{{cost}}}(P) \\ge {\\mathsf{{cost}}}(P')$.\nSince ${\\mathsf{{cost}}}(P)$ is the MWC total weight, Eq.~\\eqref{eq:wsp_solution}\ngives the multiway cuts of minimal total weight, concluding the proof.\n\\end{proof}\n\n\n\n\n\n\n\\section{WSP used to optimize array operation fusion in Bohrium}\nStating the WSP problem formulation in a general way allows a great deal of flexibility, as long as the cost function is monotonic.\nIn this section, we use WSP to solve a concrete optimization problem,\ndemonstrating its real world use. The concrete problem is an\noptimization phase within the Bohrium runtime system~\\cite{kristensen2014bohrium} in which a set of array operations are\npartitioned into computation kernels -- the \\emph{Fusion of Array\n  Operations} (FAO) problem:\n\\begin{definition}\n  \\label{def:fao_problem}\n  Given a set of array operations, $A$, equipped with a strict partial\n  order imposed by the data dependencies between them, $(A,{   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}})$,\n  find a partition, $P$, of $A$ for which:\n  \\begin{enumerate}\n  \\item All operations within a block in $P$ are fusible\n        (Def. \\ref{def:data-parallelism})\n  \\item For all blocks, $B\\in P$, if $a_1 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a_2 {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a_3$ and\n        $a_1,a_3\\in B$ then $a_2\\in B$. (I.e.~the partition obeys dependency order).\n  \\item The cost of the partition (Def. \\ref{def:bh_partition_cost}) is\n        minimal.\n  \\end{enumerate}\n\\end{definition}\nIn the following, we will provide a brief description of Bohrium and show\nthat the WSP problem solves the FAO problem (Theorem \\ref{tho:wsp_is_fao}).\n\n\\subsection{Fusion of Array Operations in Bohrium}\n\\newsavebox{\\LstPyCodeExample}\n\\begin{lrbox}{\\LstPyCodeExample}\n    \\lstinputlisting[linewidth=0.50\\linewidth,language=python, numbers=left, otherkeywords={as}]{benchmark/greedy_fail.py}\n\\end{lrbox}\n\n\\newsavebox{\\LstPyByteCodeExample}\n\\begin{lrbox}{\\LstPyByteCodeExample}\n\\begin{lstlisting}[linewidth=0.33\\linewidth, language=python, numbers=left, otherkeywords={ADD, MUL, SYNC, DEL, MAX, COPY, MIN}]\nCOPY A, 0\nCOPY B, 0\nCOPY D, 0\nCOPY E, 0\nADD A, A, D[:-1]\nCOPY A, D[:-1]\nADD B, B, E[:-1]\nCOPY B, E[:-1]\nMUL T, A, B\nMAX D[1:], T, E[1:]\nMIN E[1:], T, D[1:]\nDEL A\nDEL B\nDEL E\nDEL T\nSYNC D\nDEL D\n\\end{lstlisting}\n\\end{lrbox}\n\n\\begin{figure}\n    \\centering\n    \\subfloat[][]{\\label{fig:python_code_a}\\usebox{\\LstPyCodeExample}}\\hspace{25px}\n    \\subfloat[][]{\\label{fig:python_code_b}\\usebox{\\LstPyByteCodeExample}}\n    \\caption{A Python application that utilizes the Bohrium runtime\n      system. In order to demonstrate various challenges and\n      trade-offs, the application is synthetic. (a) shows the Python\n      code and (b) shows the corresponding Bohrium array bytecode.}\n    \\label{fig:python_code}\n\\end{figure}\n\nBohrium is a computation backend for array programming languages and\nlibraries that supports a range of languages, such as Python, C++, and\n.NET, and a range of computer architectures, such as CPU, GPU, and\nclusters of these. The idea is to decouple the domain specific frontend\nimplementation from the hardware specific backend implementation in\norder to provide a high-productivity and high-performance framework.\n\nSimilar to NumPy~\\cite{van2011numpy}, a Bohrium array operation operates on a set of\ninputs and produces a set of outputs~\\cite{kristensen2014bohrium}.\nBoth input and output operands are \\emph{views} of arrays. An array\nview is a structured way to observe the whole or parts of an\nunderlying \\emph{base} array. A base array is always a contiguous\none-dimensional array whereas views can have any shape, stride, and\ndimensionality~\\cite{kristensen2014bohrium}.  \\emph{In the following, when we\n  refer to an array, we mean an array view; when we refer to identical\n  arrays, we mean identical array views that points to the same base\n  array; and when we refer to overlapping arrays, we mean array views\n  that points to some of the same elements in a common base array.}\n\nFig.~\\ref{fig:python_code_a} shows a Python application that\nuses Bohrium as a drop-in replacement for NumPy. The application\nallocates and initiates four arrays (line 4-7), manipulates those\narrays through array operations (line 8-14), and prints the content of\none of the arrays (line 16).\n\nAs Bohrium is language agnostic, it translates the Python array\noperations into bytecode (Fig.~\\ref{fig:python_code_b}) that the\nBohrium backend can execute\\footnote{For a detailed description of\n  this Python-to-bytecode translation we refer to previous work\n  \\cite{PyHPC13_bohrium, PyHPC14_npbackend}.}. In the case of Python,\nthe Python array operations and the Bohrium array bytecode is almost in\none-to-one mapping. The first bytecode operand is the output\narray and the remaining operands are either input arrays or input\nliterals. Since there is no scope in the bytecode, Bohrium uses\n\\texttt{DEL} to destroy arrays and \\texttt{SYNC} to move array data\ninto the address space of the frontend language -- in this case\ntriggered by the Python \\texttt{print} statement\n(Fig.~\\ref{fig:python_code_a}, line 16). There is no explicit bytecode\nfor constructing arrays; on first encounter, Bohrium constructs them\nimplicitly. \n\n\nIn the next phase, Bohrium partitions the list of array operations\ninto blocks that consists of fusible array operations -- the FAO\nproblem. As long as the preceding constraints between the array\noperations are preserved, Bohrium is free to reorder them as it sees\nfit, making code optimizations based on data locality, array contraction, and\nstreaming possible.\n\nIn the final phase, the hardware specific backend implementation\nJIT-compiles each block of array operations and executes them.\n\n\\subsubsection{Fusibility}\nIn order to utilize data-parallelism, Bohrium and most other array\nprogramming languages and libraries require \\emph{data-parallelism}\nof array operations that are to be executed together. The property ensures that\nthe runtime system can calculate each output element independently\nwithout any communication between threads or processors. In Bohrium,\nall array operation must have this property.\n\nWe first introduce some operations that keep track of memory allocation,\ndeallocation, reads, and writes:\n\\begin{definition}\n  Given an array operation $f$, the notation ${\\mathsf{{in}}}[f]$ denotes the\n  set of arrays that $f$ reads; ${\\mathsf{{out}}}[f]$ denotes the set of arrays\n  that $f$ writes; ${\\mathsf{{new}}}[f]$ denotes the set of new arrays that $f$\n  allocates; and ${\\mathsf{{del}}}[f]$ denotes the set of arrays that $f$\n  deletes (or de-allocates).\n\nFurthermore, given a set of array operations, $B$, we define the following:\n\n", "index": 7, "text": "\\begin{align*}\n\n    {\\mathsf{{out}}}[B] &\\equiv {\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\ensuremath{\\cup}}}}}}_{f\\in B} {\\mathsf{{out}}}[f] \\\\\n    {\\mathsf{{in}}}[B]  &\\equiv {\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\ensuremath{\\cup}}}}}}_{f\\in B} {\\mathsf{{in}}}[f] \\\\\n    {\\mathsf{{new}}}[B] &\\equiv {\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\ensuremath{\\cup}}}}}}_{f\\in B} {\\mathsf{{new}}}[f] \\\\\n    {\\mathsf{{del}}}[B] &\\equiv {\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\ensuremath{\\cup}}}}}}_{f\\in B} {\\mathsf{{del}}}[f] \\\\\n    {\\mathsf{{ext}}}[B] &\\equiv ({\\mathsf{{in}}}[B]\\setminus {\\mathsf{{new}}}[B]) \\sqcup ({\\mathsf{{out}}}[B] \\setminus {\\mathsf{{del}}}[B])\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\par&#10;{\\mathsf{{out}}}[B]\" display=\"inline\"><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv{\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\cup}}}}}%&#10;_{f\\in B}{\\mathsf{{out}}}[f]\" display=\"inline\"><mrow><mi/><mo>\u2261</mo><mrow><mrow><munder><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mo movablelimits=\"false\">\u2062</mo><mn>1.6</mn></mrow><mo movablelimits=\"false\">\u222a</mo></mrow><mrow><mi>f</mi><mo>\u2208</mo><mi>B</mi></mrow></munder><mo>\u2061</mo><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathsf{{in}}}[B]\" display=\"inline\"><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv{\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\cup}}}}}%&#10;_{f\\in B}{\\mathsf{{in}}}[f]\" display=\"inline\"><mrow><mi/><mo>\u2261</mo><mrow><mrow><munder><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mo movablelimits=\"false\">\u2062</mo><mn>1.6</mn></mrow><mo movablelimits=\"false\">\u222a</mo></mrow><mrow><mi>f</mi><mo>\u2208</mo><mi>B</mi></mrow></munder><mo>\u2061</mo><mi>\ud835\uddc2\ud835\uddc7</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathsf{{new}}}[B]\" display=\"inline\"><mrow><mi>\ud835\uddc7\ud835\uddbe\ud835\uddd0</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv{\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\cup}}}}}%&#10;_{f\\in B}{\\mathsf{{new}}}[f]\" display=\"inline\"><mrow><mi/><mo>\u2261</mo><mrow><mrow><munder><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mo movablelimits=\"false\">\u2062</mo><mn>1.6</mn></mrow><mo movablelimits=\"false\">\u222a</mo></mrow><mrow><mi>f</mi><mo>\u2208</mo><mi>B</mi></mrow></munder><mo>\u2061</mo><mi>\ud835\uddc7\ud835\uddbe\ud835\uddd0</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathsf{{del}}}[B]\" display=\"inline\"><mrow><mi>\ud835\uddbd\ud835\uddbe\ud835\uddc5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv{\\operatornamewithlimits{{\\mathbin{\\scalebox{1.6}{\\cup}}}}}%&#10;_{f\\in B}{\\mathsf{{del}}}[f]\" display=\"inline\"><mrow><mi/><mo>\u2261</mo><mrow><mrow><munder><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mo movablelimits=\"false\">\u2062</mo><mn>1.6</mn></mrow><mo movablelimits=\"false\">\u222a</mo></mrow><mrow><mi>f</mi><mo>\u2208</mo><mi>B</mi></mrow></munder><mo>\u2061</mo><mi>\ud835\uddbd\ud835\uddbe\ud835\uddc5</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathsf{{ext}}}[B]\" display=\"inline\"><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv({\\mathsf{{in}}}[B]\\setminus{\\mathsf{{new}}}[B])\\sqcup({%&#10;\\mathsf{{out}}}[B]\\setminus{\\mathsf{{del}}}[B])\" display=\"inline\"><mrow><mi/><mo>\u2261</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2216</mo><mrow><mi>\ud835\uddc7\ud835\uddbe\ud835\uddd0</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2294</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2216</mo><mrow><mi>\ud835\uddbd\ud835\uddbe\ud835\uddc5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nIn other words, if an input and an output or two output arrays\noverlaps, they must be identical. \n\n\\end{definition}\nFusing array operation must preserve data-parallelism:\n\\begin{definition}\n\\label{definition:fusible}\nIn Bohrium, two array operations, $f$ and $f'$, are said to be fusible\nwhen the following holds:\n\n", "itemtype": "equation", "pos": 26746, "prevtext": "\nHere, ${\\mathsf{{ext}}}[B]$ gives the set of external data accesses.\n``$\\sqcup$'' is disjoint union: arrays that are both\nread and written are counted twice.\n\\texttt{DEL} and \\texttt{SYNC} are counted as having no input or output.\n\\end{definition}\nThis allows us to formulate the data-parallelism property that determines when array\noperation fusion is allowed:\n\\begin{definition}\n\\label{def:data-parallelism}\nA Bohrium array operation, $f$, is data parallel,\ni.e.,~each output element can be calculated independently, when the following holds:\n\n", "index": 9, "text": "\\begin{multline}\n    \\forall{i\\in {\\mathsf{{in}}}[f]}, \\forall{o,o'\\in {\\mathsf{{out}}}[f]} :\\\\\n    (i \\cap o = \\emptyset \\lor i = o) \\land (o \\cap o' = \\emptyset \\lor o = o')\n\\end{multline}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall{i\\in{\\mathsf{{in}}}[f]},\\forall{o,o^{\\prime}\\in{\\mathsf{{%&#10;out}}}[f]}:\\\\&#10;\\displaystyle(i\\cap o=\\emptyset\\lor i=o)\\land(o\\cap o^{\\prime}=\\emptyset\\lor o%&#10;=o^{\\prime})\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><mi>i</mi></mrow><mo>\u2208</mo><mrow><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mrow><mo>\u2200</mo><mi>o</mi></mrow></mrow></mrow><mo>,</mo><mrow><msup><mi>o</mi><mo>\u2032</mo></msup><mo>\u2208</mo><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>:</mo><mi/></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>\u2229</mo><mi>o</mi><mo>=</mo><mi mathvariant=\"normal\">\u2205</mi><mo>\u2228</mo><mi>i</mi><mo>=</mo><mi>o</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mrow><mo stretchy=\"false\">(</mo><mi>o</mi><mo>\u2229</mo><msup><mi>o</mi><mo>\u2032</mo></msup><mo>=</mo><mi mathvariant=\"normal\">\u2205</mi><mo>\u2228</mo><mi>o</mi><mo>=</mo><msup><mi>o</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\n\\end{definition}\nIt follows from Definition \\ref{def:data-parallelism} that fusible\noperations are those that can be executed together without losing independent\ndata-parallelism.\n\nIn addition to the data-parallelism property, the current\nimplementation of Bohrium also requires that the length and\ndimensionality of the fusible array operations are the same.\n\n\n\\subsubsection{Cost Model}\nThe motivation of fusing array operations is to reduce the overall\nexecution time. To accomplish this, Bohrium implements two\ntechniques: \\begin{description}\n\\item[Data Locality] When a kernel accesses an array multiple\n  times, Bohrium will only read and/or write to that array once,\n  avoiding access to main memory. Consider the two for-loops in\n  Fig. \\ref{lst:fuse_C_code_a} that each traverse \\texttt{A} and\n  \\texttt{T}. Fusing the loops avoids one traversal of \\texttt{A} and\n  one traversal of \\texttt{T}\n  (Fig. \\ref{lst:fuse_C_code_b}). Furthermore, the compiler can reduce\n  the access to the main memory by $2N$ elements since it can keep\n  the last read element of \\texttt{A} and \\texttt{T} in register.\n\n\\item[Array Contraction] When an array is created and destroyed within\n  a single partition block, Bohrium will not allocate the array\n  memory, but calculate the result in-place in one single temporary\n  register variable per parallel computing thread. Consider the\n  program transformation from Fig. \\ref{lst:fuse_C_code_a} to\n  \\ref{lst:fuse_C_code_c}, in which, beside loop fusion, the temporary\n  array $T$ is replaced by the scalar variable $t$. In this case, the\n  transformation reduces the accessed elements with $3N$ and memory\n  requirement by $N$ elements.\n  \\end{description} In\n  order to utilize these optimization techniques, we introduce a WSP\n  cost function that penalizes memory accesses from different\n  partition blocks. For simplicity, we will not differentiate between\n  reads and writes, and we will not count access to literals or register\n  variables.\n\\begin{definition}\n\\label{def:bh_partition_cost}\nIn bohrium, the cost of a partition, $P = \\{B_1,B_2,...,B_k\\}$, of\narray operations is given by:\n\n", "itemtype": "equation", "pos": 27251, "prevtext": "\nIn other words, if an input and an output or two output arrays\noverlaps, they must be identical. \n\n\\end{definition}\nFusing array operation must preserve data-parallelism:\n\\begin{definition}\n\\label{definition:fusible}\nIn Bohrium, two array operations, $f$ and $f'$, are said to be fusible\nwhen the following holds:\n\n", "index": 11, "text": "\\begin{align}\n   &\\forall i' \\in {\\mathsf{{in}}}[f'],\\ \\  \\forall o \\in {\\mathsf{{out}}}[f]\\colon &  i' \\cap o = \\emptyset \\lor i' = o \\tag{1}\\\\\n\n   &  \\forall o' \\in {\\mathsf{{out}}}[f'], \\forall o \\in {\\mathsf{{out}}}[f]\\colon &  o' \\cap o = \\emptyset \\lor o' = o \\tag{2}\\\\\n\n   & \\forall o' \\in {\\mathsf{{out}}}[f'], \\forall i \\in {\\mathsf{{in}}}[f]\\colon &  o' \\cap i = \\emptyset \\lor o' = i \\tag{3}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall i^{\\prime}\\in{\\mathsf{{in}}}[f^{\\prime}],\\ \\ \\forall o\\in%&#10;{\\mathsf{{out}}}[f]\\colon\" display=\"inline\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><msup><mi>i</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>f</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mo>\u2200</mo><mi>o</mi></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle i^{\\prime}\\cap o=\\emptyset\\lor i^{\\prime}=o{}\" display=\"inline\"><mrow><mrow><msup><mi>i</mi><mo>\u2032</mo></msup><mo>\u2229</mo><mi>o</mi></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">\u2205</mi><mo>\u2228</mo><msup><mi>i</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mi>o</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall o^{\\prime}\\in{\\mathsf{{out}}}[f^{\\prime}],\\forall o\\in{%&#10;\\mathsf{{out}}}[f]\\colon\" display=\"inline\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><msup><mi>o</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>f</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mo>\u2200</mo><mi>o</mi></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle o^{\\prime}\\cap o=\\emptyset\\lor o^{\\prime}=o{}\" display=\"inline\"><mrow><mrow><msup><mi>o</mi><mo>\u2032</mo></msup><mo>\u2229</mo><mi>o</mi></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">\u2205</mi><mo>\u2228</mo><msup><mi>o</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mi>o</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall o^{\\prime}\\in{\\mathsf{{out}}}[f^{\\prime}],\\forall i\\in{%&#10;\\mathsf{{in}}}[f]\\colon\" display=\"inline\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><msup><mi>o</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>f</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mo>\u2200</mo><mi>i</mi></mrow><mo>\u2208</mo><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle o^{\\prime}\\cap i=\\emptyset\\lor o^{\\prime}=i{}\" display=\"inline\"><mrow><mrow><msup><mi>o</mi><mo>\u2032</mo></msup><mo>\u2229</mo><mi>i</mi></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">\u2205</mi><mo>\u2228</mo><msup><mi>o</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mi>i</mi></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nwhere the length $\\left\\|{x}\\right\\|$ is the total number of bytes accessed\nby the set of arrays in $x$.\n\\end{definition}\nThe Bohrium cost-savings when merging two partition blocks depends\nonly on the blocks:\n\\begin{prop}[Merge-savings]\n    \\label{prop:cost_saving}\n    \n    \n    \n    Let $P$ be a partition and $P' = P {/} (B_1,B_2)$ be its\n    successor derived by merging $B_1$ and $B_2$.\n    Using the cost\n    function of Def.~\\ref{def:bh_partition_cost}, the difference in\n    cost between the two partitions is:\n    \n", "itemtype": "equation", "pos": 29799, "prevtext": "\n\\end{definition}\nIt follows from Definition \\ref{def:data-parallelism} that fusible\noperations are those that can be executed together without losing independent\ndata-parallelism.\n\nIn addition to the data-parallelism property, the current\nimplementation of Bohrium also requires that the length and\ndimensionality of the fusible array operations are the same.\n\n\n\\subsubsection{Cost Model}\nThe motivation of fusing array operations is to reduce the overall\nexecution time. To accomplish this, Bohrium implements two\ntechniques: \\begin{description}\n\\item[Data Locality] When a kernel accesses an array multiple\n  times, Bohrium will only read and/or write to that array once,\n  avoiding access to main memory. Consider the two for-loops in\n  Fig. \\ref{lst:fuse_C_code_a} that each traverse \\texttt{A} and\n  \\texttt{T}. Fusing the loops avoids one traversal of \\texttt{A} and\n  one traversal of \\texttt{T}\n  (Fig. \\ref{lst:fuse_C_code_b}). Furthermore, the compiler can reduce\n  the access to the main memory by $2N$ elements since it can keep\n  the last read element of \\texttt{A} and \\texttt{T} in register.\n\n\\item[Array Contraction] When an array is created and destroyed within\n  a single partition block, Bohrium will not allocate the array\n  memory, but calculate the result in-place in one single temporary\n  register variable per parallel computing thread. Consider the\n  program transformation from Fig. \\ref{lst:fuse_C_code_a} to\n  \\ref{lst:fuse_C_code_c}, in which, beside loop fusion, the temporary\n  array $T$ is replaced by the scalar variable $t$. In this case, the\n  transformation reduces the accessed elements with $3N$ and memory\n  requirement by $N$ elements.\n  \\end{description} In\n  order to utilize these optimization techniques, we introduce a WSP\n  cost function that penalizes memory accesses from different\n  partition blocks. For simplicity, we will not differentiate between\n  reads and writes, and we will not count access to literals or register\n  variables.\n\\begin{definition}\n\\label{def:bh_partition_cost}\nIn bohrium, the cost of a partition, $P = \\{B_1,B_2,...,B_k\\}$, of\narray operations is given by:\n\n", "index": 13, "text": "\\begin{equation}\n\n    {\\mathsf{{cost}}}(P) = \\sum_{B\\in P} \\left\\|{{\\mathsf{{ext}}}[B]}\\right\\|\n\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\par&#10;{\\mathsf{{cost}}}(P)=\\sum_{B\\in P}\\left\\|{{\\mathsf{{ext}}}[B]}\\right\\|\\par&#10;\" display=\"block\"><mrow><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>B</mi><mo>\u2208</mo><mi>P</mi></mrow></munder><mrow><mo>\u2225</mo><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2225</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\n    Since this cost reduction depends only on $B_1$ and $B_2$, we\n    define a function, ${\\mathsf{{saving}}}(B_1,B_2)$, that counts the savings\n    from merging $B_1$ and $B_2$, which is independent of the rest of the\n    partitions.\n\\end{prop}\n\\begin{proof}\n  If $P = \\{B_1,B_2,\\ldots,\\}$ and $P' = \\{B_1\\cup B_2,\\ldots\\}$, then\n  the reduction in cost is\n \n", "itemtype": "equation", "pos": 30434, "prevtext": "\nwhere the length $\\left\\|{x}\\right\\|$ is the total number of bytes accessed\nby the set of arrays in $x$.\n\\end{definition}\nThe Bohrium cost-savings when merging two partition blocks depends\nonly on the blocks:\n\\begin{prop}[Merge-savings]\n    \\label{prop:cost_saving}\n    \n    \n    \n    Let $P$ be a partition and $P' = P {/} (B_1,B_2)$ be its\n    successor derived by merging $B_1$ and $B_2$.\n    Using the cost\n    function of Def.~\\ref{def:bh_partition_cost}, the difference in\n    cost between the two partitions is:\n    \n", "index": 15, "text": "\\begin{align} \\label{eq:cost_saving}\n      {\\mathsf{{cost}}}(P)-{\\mathsf{{cost}}}(P') = &\\phantom{+}\\,\\, \\left\\|{{\\mathsf{{ext}}}[B_1] \\cap {\\mathsf{{ext}}}[B_2]}\\right\\| \\notag\\\\\n                           &+ \\left\\|{{\\mathsf{{new}}}[B_1] \\cap {\\mathsf{{in}}}[B_2]}\\right\\| \\notag\\\\\n                           &+ \\left\\|{{\\mathsf{{out}}}[B_1] \\cap {\\mathsf{{del}}}[B_2]}\\right\\|\n    \\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathsf{{cost}}}(P)-{\\mathsf{{cost}}}(P^{\\prime})=\" display=\"inline\"><mrow><mrow><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\phantom{+}\\,\\,\\left\\|{{\\mathsf{{ext}}}[B_{1}]\\cap{\\mathsf{{ext}}%&#10;}[B_{2}]}\\right\\|\" display=\"inline\"><mrow><mo lspace=\"5.9pt\">\u2225</mo><mrow><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>1</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2229</mo><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>\u2225</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+\\left\\|{{\\mathsf{{new}}}[B_{1}]\\cap{\\mathsf{{in}}}[B_{2}]}\\right\\|\" display=\"inline\"><mrow><mo>+</mo><mrow><mo>\u2225</mo><mrow><mrow><mi>\ud835\uddc7\ud835\uddbe\ud835\uddd0</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>1</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2229</mo><mrow><mi>\ud835\uddc2\ud835\uddc7</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>\u2225</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+\\left\\|{{\\mathsf{{out}}}[B_{1}]\\cap{\\mathsf{{del}}}[B_{2}]}\\right\\|\" display=\"inline\"><mrow><mo>+</mo><mrow><mo>\u2225</mo><mrow><mrow><mi>\ud835\uddc8\ud835\uddce\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>1</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2229</mo><mrow><mi>\ud835\uddbd\ud835\uddbe\ud835\uddc5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>B</mi><mn>2</mn></msub><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>\u2225</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\n  since all other blocks are the same. By using the fact that $B_1$\n  must be executed before $B_2$, whereby\n  ${\\mathsf{{in}}}[B_1]\\cap{\\mathsf{{new}}}[B_2]=\\emptyset$ and\n  ${\\mathsf{{del}}}[B_1]\\cap{\\mathsf{{out}}}[B_2]=\\emptyset$, as well as the ${\\mathsf{{new}}}$'s\n  and ${\\mathsf{{del}}}$'s being disjoint, direct calculation yields\n  Eq.~\\ref{eq:cost_saving}.\n\\end{proof}\nNote that Prop.~\\ref{prop:cost_saving} directly implies that the cost\nfunction of Def.~\\ref{def:bh_partition_cost} is positive and\nmonotonically decreasing, as required by Def.~\\ref{def:wsp_cost}.\nWe next show how the problem can be formulated as a WSP instance.\n\n\\subsubsection{Constructing a WSP-problem from Bohrium bytecode}\n\nGiven a list $A$ of Bohrium array operations, a WSP problem $G =\n(V,E_d,E_f)$ is constructed as follows. \n\\begin{enumerate}\n  \\item The data dependencies between array operations define a partial order: $a {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a'$ iff $a'$ must be executed before $a$.\n  \\item Each array operation $a\\in A$ defines a vertex $v(a)\\in V$. \n                                                                    \n  \\item The dependency graph $E_d$ has an edge $(v(a),v(a'))$ for each pair $a,a'\\in A$ with $a{   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a'$.\n  \\item The fuse-prevention graph $E_f$ has an edge $(v(a),v(a'))$ for each non-fusible pair $a,a'\\in A$.\n\\end{enumerate}\nThe cost function is as in Def.~\\ref{def:bh_partition_cost}, but note\nthat it can be calculated incrementally using Prop.~\\ref{prop:cost_saving}.\n\nThe complexity of this transformation is $O(V^2)$ since we may have\nto check all pairs of array operations for dependecies, fusibility,\nand cost-saving, all of which is $O(1)$.  Fig.~\\ref{fig:dag_singleton}\nshows the trivial partition, $\\bot$, of the Python example, where every\narray operation has its own block. The cost \nis 94.\n\n\n\\subsubsection{WSP solves Fusion of Array Operations}\nFinally, we can show that a solution to the WSP problem also is a\nsolution to the FAO problem.\n\n\\begin{theorem}\n\\label{tho:wsp_is_fao}\n  WSP solves Fusion of Array Operations.\n\\end{theorem}\n\\begin{proof}\n  It is clear from Def.~\\ref{def:wsp_legal_partition} and the construction above that the legal\n  partitions $\\hat{\\Pi}_V$ are exactly all those that fulfill Properties (1) and (2) of\n  Def.~\\ref{def:fao_problem}. Thus, Def.~\\ref{def:wsp_solution} yields a global minimum\n  for all such partitions, fulfilling also Def.~\\ref{def:fao_problem}(3).\n\\end{proof}\n\n\n\n\n\n\n\\begin{figure}\n \\centering\n \\vspace{-0.3cm}\n \\includegraphics[trim={10px 10px 10px 10px}, clip, width=\\linewidth]{gfx/dag_singleton.pdf}\n \\caption{A partition graph of the Python application in\n   Fig. \\ref{fig:python_code}. For illustrative proposes, the graph\n   does not include ignored weight edges \\ifdefined{}\n   (cf. Fig. \\ref{algo:legal})\\fi.}\n\\label{fig:dag_singleton}\n\\end{figure}\n\n\n\n\n\n\n\n\\ifdefined{}\n\\begin{figure*}\n\\footnotesize\n\\setlength{\\columnsep}{5pt}\n\\begin{multicols}{3}\n    \\subfloat[][Help function for Unintrusive]{\\label{algo:gently_help}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{FindCandidate}{$G$}     \\For{$(v,u) \\gets E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G,(u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\For{$(v,u) \\gets E_w[G]$}     \\If{degree is less than $2$ for either $u$ or $v$          when only counting edges in $E_w[G]$}             \\If{$\\theta[u] = \\theta[v]$}                 \\State \\Return $(u,v)$             \\EndIf         \\EndIf     \\EndFor     \\State \\Return $(\\Call{NIL}{},\\Call{NIL}{})$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\subfloat[][Unintrusive]{\\label{algo:gently}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Unintrusive}{$G$}     \\While{$(u,v) \\gets \\Call{FindCandidate}{G} \\neq (\\Call{NIL}{},\\Call{NIL}{})$}         \\State $G\\gets$ \\Call{Merge}{$G,u,v$}     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\newpage \\vskip -10cm\n    \\subfloat[][Greedy]{\\label{algo:greedy}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Greedy}{$G$}     \\While{$E_w[G] \\neq \\emptyset$} \\label{algo:greedy:while}         \\State $(u, v)\\gets \\Call{Find-Heaviest}{E_w[G]}$ \\label{algo:greedy:heaviest}         \\If{$\\Call{Legal}{G, (u,v)}$}             \\State $G\\gets$ \\Call{Merge}{$G,u,v$}\\label{algo:greedy:merge}         \\Else             \\State Remove edge $(u,v)$ from $E_w$ \\label{algo:greedy:remove}         \\EndIf     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\subfloat[][Help function for Optimal]{\\label{algo:optimal_help}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{MergeByMask}{$G, M$}     \\State $f\\gets$ \\textbf{true}\\Comment{Flag that indicates fusibility}     \\For{$i\\gets 0$ \\textbf{to} $|E_w[G]|-1$}         \\If{$M_i = 1$}         \\State $(u,v)\\gets$ the $i$'th edge in $E_w[G]$             \\If{\\textbf{not} \\Call{Fusible}{$G, u,v$}}                 \\State $f\\gets$ \\textbf{false}             \\EndIf             \\State $G\\gets$ \\Call{Merge}{$G, u, v$}         \\EndIf     \\EndFor     \\State \\Return $(G, f)$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\newpage\\vskip -10cm\n    \\subfloat[][Optimal]{\\label{algo:optimal}  \\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Optimal}{$G$}     \\State $G\\gets$ \\Call{Unintrusive}{$G$}     \\For{$(v, u) \\gets |E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G, (u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\State $G_{\\min}\\gets$ \\Call{Greedy}{$G$}\\Comment{Good guess}     \\State $M_{0..|E_w[G]|}\\gets 1$\\Comment{Fill array $M$}     \\State $o\\gets 0$\\Comment{The mask offset}     \\State $Q\\gets \\emptyset$     \\State \\Call{Enqueue}{$Q, (M, o)$}     \\While{$Q \\neq \\emptyset$}         \\State $(M, o)\\gets$ \\Call{Dequeue}{$Q$}         \\State $(G',f)\\gets$ \\Call{MergeByMask}{$G, M$}         \\If{$cost(G') < cost(G_{\\min})$}             \\If{$f$ \\textbf{and} $G'$ is acyclic}                 \\State $G_{\\min}\\gets G'$ \\Comment{New best partitioning}             \\EndIf         \\EndIf         \\For{$i\\gets o$ \\textbf{to} $|M|-1$}             \\State $M'\\gets M$             \\State $M'_i\\gets 0$             \\State \\Call{Enqueue}{$Q, (M', i+1)$}         \\EndFor     \\EndWhile     \\State \\Return $G_{\\min}$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\end{multicols}\n\\caption{The partition algorithms where the function, $cost(G)$, returns the partition cost of the partition graph $G$.}\n\\end{figure*}\n\\fi\n\n\n\\section{Algorithms}\n\nIn this section, we present an exact algorithm for finding an\noptimal solution to WSP (with exponential worst-case execution time),\nand two fast algorithms that find approximate solutions. We\nuse the Python application shown in Fig.~\\ref{fig:python_code} to\ndemonstrate the results of each partition algorithm.\n\n\\subsection{Partition graphs and chains of block merges}\nAll three algorithms work on data structures called {\\em partition\n  graphs}, defined as follows:\n\\begin{definition}[Partition graph]\n  Given a graph $G = (V,E)$ and a partition $P$ of $V$, the\n  corresponding {\\em partition graph} is the graph ${\\hat{{G}}({P})} =\n  (P,{\\hat{{E}}({P})})$ that has an edge $(B,B')$ if there is an\n  edge $(u,v)\\in E$ with $u\\in B$ and $v\\in B'$. That is, the vertices\n  are the blocks, connected by the edges that cross block boundaries.\n\\end{definition}\n\\noindent\nFrom this we build the state needed in WSP computations:\n\n\\begin{definition}[WSP state]\n  Given a WSP-instance $G = (V,E_d,E_f,{\\mathsf{{cost}}})$ and a partition $P$,\n  the {\\em WSP state} is the partition graph ${\\hat{{G}}({P})} =\n  (P,{\\hat{{E_d}}({{P}})},{\\hat{{E_f}}({{P}})})$ together with a complete weighted\n  graph ${\\hat{{E_w}}({P})}$ with weights $w(B_1,B_2) = {\\mathsf{{cost}}}(P) -\n  {\\mathsf{{cost}}}(P {/} (B_1,B_2))$.\n\\end{definition}\nNotice that $w(B_1,B_2) = {\\mathsf{{saving}}}(B_1,B_2)$ for the Bohrium cost\nfunction, as shown in Prop.~\\ref{prop:cost_saving}, and does not\nrequire a full cost calculation.\n\\begin{definition}[Merge operator on partition graphs]\n  We extend the merge operator of Def.~\\ref{def:block_merge} to\n  partition graphs as ${\\hat{{G}}({P})} {/} (B_1,B_2) = {\\hat{{G}}({P     {/} (B_1,B_2)})}$.  This acts exactly as a vertex contraction\n  on the partition graph.\n\\end{definition}\nThe merge operator is commutative in the sense that the order in a\nsequence of successive vertex contractions doesn't affect the result \\cite{wolle2004note}.\nAn auxiliary function, \\Call{Merge}{}, is used in each algorithm to update the state.\n\\begin{definition}\n  Let $S = (\\hat{G},\\hat{E}_w)$ be a WSP state. We define\n \n", "itemtype": "equation", "pos": 31190, "prevtext": "\n    Since this cost reduction depends only on $B_1$ and $B_2$, we\n    define a function, ${\\mathsf{{saving}}}(B_1,B_2)$, that counts the savings\n    from merging $B_1$ and $B_2$, which is independent of the rest of the\n    partitions.\n\\end{prop}\n\\begin{proof}\n  If $P = \\{B_1,B_2,\\ldots,\\}$ and $P' = \\{B_1\\cup B_2,\\ldots\\}$, then\n  the reduction in cost is\n \n", "index": 17, "text": "\\[\n    {\\mathsf{{cost}}}(P) - {\\mathsf{{cost}}}(P') = \\left\\|{{\\mathsf{{ext}}}(B_1)}\\right\\| + \\left\\|{{\\mathsf{{ext}}}(B_2)}\\right\\| - \\left\\|{{\\mathsf{{ext}}}(B_1\\cup B_2)}\\right\\|\n  \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"{\\mathsf{{cost}}}(P)-{\\mathsf{{cost}}}(P^{\\prime})=\\left\\|{{\\mathsf{{ext}}}(B_%&#10;{1})}\\right\\|+\\left\\|{{\\mathsf{{ext}}}(B_{2})}\\right\\|-\\left\\|{{\\mathsf{{ext}}%&#10;}(B_{1}\\cup B_{2})}\\right\\|\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo>\u2225</mo><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>B</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mo>+</mo><mrow><mo>\u2225</mo><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>B</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow></mrow><mo>-</mo><mrow><mo>\u2225</mo><mrow><mi>\ud835\uddbe\ud835\uddd1\ud835\uddcd</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>\u222a</mo><msub><mi>B</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\n  where $\\hat{E_w}'$ is the updated weight graph on the edges\n  incident to the new vertex $z = u\\cup v$.\n\\end{definition}\nThe complexity of \\Call{Merge}{} is dominated by the weight update, which requires\na ${\\mathsf{{saving}}}{}$ computations per edge incident to the merged vertex,\nand is bounded by \\ensuremath{\\mathcal{O}\\left({V^2}\\right)}. We next need a local condition for when\na merge is allowed:\n\\begin{lemma}[Legal merge]\n  \\label{lem:legal_partition_merge}\n  Let $P_{1,2} = P{/} (B_1,B_2)$ be the successor to a legal\n  partition $P\\in\\hat{\\Pi}_V$, derived by merging blocks $B_1$ and\n  $B_2$.  Then $P_{1,2}\\in\\hat{\\Pi}_V$ if and only if\n  \\begin{enumerate}\n  \\item $(B_1,B_2)\\notin {\\hat{{E_f}}({{P}})}$, and\n  \\item there is no path of length $\\ge 2$ from $B_1$ to $B_2$ in the\n        partition graph ${\\hat{{E_d}}({{P}})}$.\n  \\end{enumerate}\n\\end{lemma}\n\\begin{proof}\n  Recall that $\\hat{\\Pi}_V$ is the subset of partitions in $\\Pi_V$\n  that satisfy Def.~\\ref{def:wsp_legal_partition}.  Because $P$ is\n  legal, no block contains an edge in $E_f$. Hence $P_{1,2}$ obeys\n  Def.~\\ref{def:wsp_legal_partition}(1) if and only if no two vertices\n  $u\\in B_1$ and $v\\in B_2$ are connected in $E_f$, or equivalently,\n  $(B_1,B_2)\\notin {\\hat{{E_f}}({{P}})}$. \n\n  Similarly, by assumption, there are no cycles in ${\\hat{{E_d}}({{P}})}$.\n  Thus, $P_{1,2}$ violates Def.~\\ref{def:wsp_legal_partition}(2) if and\n  only if ${\\hat{{E_d}}({{P}})}$ contains a path $B_{1}\\to B' \\to \\cdots \\to\n  B_{2}$, forming the cycle $B_{1,2} \\to B' \\to \\cdots \\to B_{1,2}$ in\n  ${\\hat{{E_d}}({{P_{1,2}}})}$ (where $B_{1,2} = B_1\\cup B_2$).\n\\end{proof}\n\n\\begin{prop}[Reachability through legal merges]\n  Given two legal partitions $P {<} P'$, there exists a successor\n  chain $P {\\prec} P_1 {\\prec} P_2 {\\prec} \\cdots {\\prec} P'$\n  entirely contained in $\\hat{\\Pi}_V$, i.e.  corresponding only to\n  legal block merges.\n\\end{prop}\n\\begin{proof}\n  A successor chain $P {\\prec} P_1 {\\prec} \\cdots {\\prec} P_{n-1}\n  {\\prec} P'$ always exists in the total set of partitions $\\Pi_V$,\n  and all such chains are of the same length $n$.  Any such chain\n  contains no partition that violates\n  Def.~\\ref{def:wsp_legal_partition}(1): each step is a merge,\n  so once a fuse-preventing edge is placed inside a block, it would\n  be included also in a block from $P'$.\n  Hence we only need to worry about Def.~\\ref{def:wsp_legal_partition}(2).\n\n  We now show by induction that a successor chain consisting of only\n  legal partitions exists.  First, if $P{\\prec} P'$, it is trivially\n  so. Assume now that the statement is true for all $n \\le N$, and\n  consider $P{<} P'$ of distance $N+1$.\n\n  \n  \n  \n  \n  \n  Pick any successor chain from $P$ to $P'$.  If any step violates\n  Def.~\\ref{def:wsp_legal_partition}(2), then let $P_{i+1} =\n  P_i{/} (B_1,B_2)$ be the first partition in the chain that does\n  so. Then there is a path $B_1\\to B\\to\\cdots \\to B_2$ in the\n  transitive reduction of ${\\hat{{E_d}}({{P_i}})}$. Because $P'$ satisfies\n  Def.~\\ref{def:wsp_legal_partition}(2), $B_1\\cup B\\cup B_2$ is\n  contained in a block from $P'$, whereby $P_{i+1}' \\equiv P_i{/}\n  (B_1,B) {<} P'$. This merge introduces no cycles, because the\n  path is in the transitive reduction.  Now let $P_{i+1}' {\\prec}\n  P_{i+2}' {\\prec} \\cdots {\\prec} P'$ be a legal successor chain of\n  length $N-i$, known to exist by hypothesis. Then $P{\\prec}\n  P_1{\\prec}\\cdots {\\prec} P_i {\\prec} P_{i+1}' {\\prec} \\cdots\n  {\\prec} P'$ is a length-$N+1$ successor chain consisting of only\n  legal partitions, concluding the proof by induction.\n\\end{proof}\nIn particular, the optimal solutions can be reached in this way from\nthe bottom partition $\\bot = \\{\\{v_1\\},\\{v_2\\},\\ldots,\\{v_n\\}\\}$,\nwhich we will use in the design of the algorithms.\n\n\n\\ifdefined{}\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Legal}{$G, e$}     \\State $(u,v)\\gets e$     \\State $l\\gets$ length of longest path between $u$ and $v$ in $E_d[G]$ \\label{algo:legal:path}     \\If{$l = 1$} \\label{algo:legal:transitive}         \\State \\Return $false$     \\Else         \\State \\Return $true$     \\EndIf \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{A help function thet determines whether the weight edge, $e \\in E_w[G]$}\n\\label{algo:legal}\n\\end{figure}\n\\fi\n\n\n\\ifdefined{}\n\\begin{figure}\n    \\vspace{-0.5cm}\n    \\centering\n    \\subfloat[][Greedy]{\\label{fig:dag_greedy}         \\includegraphics[trim={15px 10px 12px 10px}, clip, scale=0.5, valign=t]{gfx/dag_greedy.pdf}}\n    \\subfloat[][Unintrusive]{\\label{fig:dag_gently}    \\includegraphics[trim={12px 10px 15px 10px}, clip, scale=0.5, valign=t]{gfx/dag_gently.pdf}}\\\\\n    \\vspace{-0.3cm}\n    \\subfloat[][Optimal]{\\label{fig:dag_optimal}       \\includegraphics[trim={10px 10px 10px 10px}, clip, scale=0.5, valign=t]{gfx/dag_optimal.pdf}}\n    \\subfloat[][Linear]{\\label{fig:dag_topological}\\includegraphics[trim={-10px 10px -10px 10px}, clip, scale=0.5, valign=t]{gfx/dag_topological.pdf}}\n    \\caption{Four partition graphs that are the result of running the\n      four partition algorithms with Fig. \\ref{fig:dag_singleton} as\n      input. Lowercase variable names indicate that they are\n      \\emph{array contracted}.}\n\\end{figure}\n\\fi\n\n\\subsection{Unintrusive Partition Algorithm}\n\nIn order to reduce the size of the partition graph to be analyzed, we apply an\nunintrusive strategy where we merge vertices that are guaranteed to be\npart of an optimal solution. Consider the two vertices, $a,e$, in\nFig. \\ref{fig:dag_singleton}. The only beneficial merge possibility\n$a$ has is with $e$, so if $a$ is merged in the optimal solution, it\nis with $e$. Now, since fusing $a,e$ will not impose any restriction\nto future possible vertex merges in the graph, the two vertices are\nsaid to be \\emph{unintrusively fusible}. We formalize this property\nusing the {\\em non-fusible sets}:\n\\begin{definition}[$\\theta$, non-fusible set]\n  The {\\em non-fusible} set,  $\\theta[b]$ for a block $b$\n  is the set of blocks connected with $b$ in $\\hat{E_d}$ through\n  a path containing a non-fusible edge.\n\\end{definition}\n\\begin{theorem}\n\\label{tho:gentle_fusible}\nGiven a partition graph $\\hat{G}$, let $z = u\\cup v$ be the merged\nvertex in $\\hat{G} {/} (u,v)$. The vertices\n$u$ and $v$ are {\\em unintrusively fusible} whenever:\n\\begin{enumerate}\n    \\item $\\theta[u] = \\theta[v] = \\theta[z]$, i.e.~the non-fusibles are unchanged. \n    \\item Either $u$ or $v$ is a pendant vertex in $\\hat{E_d}$, i.e. the\n         degree of either $u$ or $v$ must be $1$.\n\\end{enumerate}\n\\end{theorem}\n\\begin{proof}\n  If Condition 1 is satisfied, any merge that is disallowed at a further\n  stage due to Def.~\\ref{def:wsp_legal_partition}(1) would be disallowed also without the merge.\n  Similarly, merging a pendant vertex with its parent does not affect\n  the possiblity of introducing cycles through future merges (Def.~\\ref{def:wsp_legal_partition}(1)).\n  Finally, since the cost function is monotonic, the merge cannot adversely affect a future cost.\n\\end{proof}\n\nFig.~\\ref{algo:gently} shows the unintrusive partitioning algorithm. It uses\na helper function, \\Call{FindCandidate}{}, to find two vertices that are\nunintrusively fusible. The complexity of \\Call{FindCandidate}{}\nis $\\ensuremath{\\mathcal{O}\\left({E(E+V)}\\right)}$, which dominates the while-loop in \\Call{Unintrusive}{},\nwhereby the overall complexity of the unintrusive merge algorithm is\n$\\ensuremath{\\mathcal{O}\\left({E^2(E+V)}\\right)}$. Note that there is little need to further optimize\n\\Call{Unintrusive}{} since we will only use it as a preconditioner for the\noptimal solution, which will dominate the computation time.\n\n\\ifdefined{}\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{FindCandidate}{$G$}     \\For{$(v,u) \\gets E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G,(u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\For{$(v,u) \\gets E_w[G]$}     \\If{degree is less than $2$ for either $u$ or $v$          when only counting edges in $E_w[G]$}             \\If{$\\theta[u] = \\theta[v]$}                 \\State \\Return $(u,v)$             \\EndIf         \\EndIf     \\EndFor     \\State \\Return $(\\Call{NIL}{},\\Call{NIL}{})$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Unintrusive}{$G$}     \\While{$(u,v) \\gets \\Call{FindCandidate}{G} \\neq (\\Call{NIL}{},\\Call{NIL}{})$}         \\State $G\\gets$ \\Call{Merge}{$G,u,v$}     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The unintrusive merge algorithm that only merge \\emph{unintrusively fusible} vertices.}\n\\label{algo:gently}\n\\end{figure}\n\\fi\n\nFig. \\ref{fig:dag_gently} shows an unintrusive partition of the Python\nexample with a partition cost of 70. However, the significant\nimprovement is the reduction of the number of weight edges in the\ngraph. As we shall see next, in order to find an optimal graph\npartition in practical time, the number of weight edges in the graph\nmust be modest.\n\n\n\\subsection{Greedy Partition Algorithm}\n\nFig. \\ref{algo:greedy} shows a greedy merge algorithm. It uses the\nfunction $\\Call{Find-Heaviest}{}$ to find the edge in $E_w$ with the\ngreatest weight and either remove it or merge over it. Note that\n$\\Call{Find-Heaviest}{}$ must search through $E_w$ in each iteration\nsince $\\Call{Merge}{}$ might change the weights.\n\nThe number of iterations in the while loop (line\n\\ref{algo:greedy:while}) is $\\ensuremath{\\mathcal{O}\\left({E}\\right)}$ since at least one weight edge is\nremoved in each iteration either explicitly (line\n\\ref{algo:greedy:remove}) or implicitly by \\Call{Merge}{} (line\n\\ref{algo:greedy:merge}). The complexity of finding the heaviest (line\n\\ref{algo:greedy:heaviest}) is $\\ensuremath{\\mathcal{O}\\left({E}\\right)}$, calling \\Call{Legal}{} is\n$\\ensuremath{\\mathcal{O}\\left({E+V}\\right)}$, and calling \\Call{Merge}{} is $\\ensuremath{\\mathcal{O}\\left({V^2}\\right)}$ thus the overall\ncomplexity is $\\ensuremath{\\mathcal{O}\\left({V^2E}\\right)}$.\n\nFig. \\ref{fig:dag_greedy} shows a greedy partition of the Python\nexample.  The partition cost is 58, which is a significant improvement\nover no merge. However, it is not the optimal partitioning, as we\nshall see later.\n\n\\ifdefined{}\n\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Greedy}{$G$}     \\While{$E_w[G] \\neq \\emptyset$} \\label{algo:greedy:while}         \\State $(u, v)\\gets \\Call{Find-Heaviest}{E_w[G]}$ \\label{algo:greedy:heaviest}         \\If{$\\Call{Legal}{G, (u,v)}$}             \\State $G\\gets$ \\Call{Merge}{$G,u,v$}\\label{algo:greedy:merge}         \\Else             \\State Remove edge $(u,v)$ from $E_w$ \\label{algo:greedy:remove}         \\EndIf     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The greedy merge algorithm that greedily merges the vertices connected with the heaviest weight edge in $G$.}\n\\label{algo:greedy}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_greedy.pdf}\n \\caption{A partition graph of the greedy merge of the graph in Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_greedy}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_gently.pdf}\n \\caption{A partition graph of the unintrusive merge of the graph in Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_gently}\n\\end{figure}\n\n\\fi\n\n\n\\subsection{Optimal Partition Algorithm}\nBecause the WSP problem is NP-hard, we cannot in general hope to solve\nit exactly in polynomial time. However, we may be able to solve the\nproblems within reasonable time in common cases given a carefully\nchosen search strategy through the $2^E$ possible partitions. For this\npurpose, we have implemented a branch-and-bound algorithm,\nexploiting the monotonicity of the partition cost (Def.~\\ref{def:wsp_cost}(2)).\nIt is shown in Fig.~\\ref{algo:optimal}, and proceeds as follows:\n\nBefore starting, the largest unintrusive partition is found. This is\nthe largest partition that we can ensure is included in an optimal\npartition.  The blocks of the unintrusive partition will be the\nvertices in our initial partition graph.  Second, a good suboptimal\nsolution is computed. We use the greedy algorithm for this purpose,\nbut any scheme will do.  We now start a search rooted in the\n$\\top$-partition where everything is one block. This has the lowest\ncost, but will in general be illegal.  Each recursion step cuts a\nweight edge that has not been considered before, if it yields a cost\nthat is strictly lower than the currently best partition $G_{\\min}$\n(if the cost is higher than for $G_{\\min}$, no further splitting will\nyield a better partition, and its search subtree can be ignored). If\nwe reach a legal partition, this will be the new best candidate, and\nno further splitting will yield a better one. When the work queue is\nempty, $G_{\\min}$ holds an optimal solution to WSP.\n\nFig.~\\ref{algo:optimal} shows the implementation, Fig.~\\ref{fig:search_tree} shows an example of a branch-and-bound search tree, and Fig.~\\ref{fig:dag_optimal} shows an optimal partition of the Python example with a partition cost of 38.\n\n\\begin{figure}\n \\centering\n \\vspace{-10px}\n \\includegraphics[width=\\linewidth]{gfx/search_tree.pdf}\n \\caption{A branch-and-bound search tree of the unintrusively merged\n   partition graph (Fig. \\ref{fig:dag_gently}). Each vertex lists a\n   sequences of vertex merges that build a specific graph\n   partition. The grayed out area indicates the part of the search\n   tree that a depth-first-search can skip because of the cost\n   bound. }\n \\label{fig:search_tree}\n\\end{figure}\n\n\\ifdefined{}\n\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{MergeByMask}{$G, M$}     \\State $f\\gets$ \\textbf{true}\\Comment{Flag that indicates fusibility}     \\For{$i\\gets 0$ \\textbf{to} $|E_w[G]|-1$}         \\If{$M_i = 1$}         \\State $(u,v)\\gets$ the $i$'th edge in $E_w[G]$             \\If{\\textbf{not} \\Call{Fusible}{$G, u,v$}}                 \\State $f\\gets$ \\textbf{false}             \\EndIf             \\State $G\\gets$ \\Call{Merge}{$G, u, v$}         \\EndIf     \\EndFor     \\State \\Return $(G, f)$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Optimal}{$G$}     \\State $G\\gets$ \\Call{Unintrusive}{$G$}     \\For{$(v, u) \\gets |E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G, (u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\State $G_{\\min}\\gets$ \\Call{Greedy}{$G$}\\Comment{Good guess}     \\State $M_{0..|E_w[G]|}\\gets 1$\\Comment{Fill array $M$}     \\State $o\\gets 0$\\Comment{The mask offset}     \\State $Q\\gets \\emptyset$     \\State \\Call{Enqueue}{$Q, (M, o)$}     \\While{$Q \\neq \\emptyset$}         \\State $(M, o)\\gets$ \\Call{Dequeue}{$Q$}         \\State $(G',f)\\gets$ \\Call{MergeByMask}{$G, M$}         \\If{$cost(G') < cost(G_{\\min})$}             \\If{$f$ \\textbf{and} $G'$ is acyclic}                 \\State $G_{\\min}\\gets G'$ \\Comment{New best partitioning}             \\EndIf         \\EndIf         \\For{$i\\gets o$ \\textbf{to} $|M|-1$}             \\State $M'\\gets M$             \\State $M'_i\\gets 0$             \\State \\Call{Enqueue}{$Q, (M', i+1)$}         \\EndFor     \\EndWhile     \\State \\Return $G_{\\min}$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The optimal merge algorithm that optimally merges the\n  vertices in $G$. The function, $cost(G)$, returns the partition cost\n  of the partition graph $G$.}\n\\label{algo:optimal}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_optimal.pdf}\n \\caption{A partition graph of the optimal merge of the graph in\n   Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_optimal}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_topological.pdf}\n \\caption{A partition graph of a Linear partition of the Python\n   example (Fig. \\ref{fig:python_code}).}\n\\label{fig:dag_topological}\n\\end{figure}\n\n\\fi\n\n\n\\subsection{Linear Merge}\nFor completeness, we also implement a partition algorithm that does\nnot use a graph representation. In this na\\\"{\\i}ve approach, we simply\ngo through the array operation list and add each array operation to\nthe \\emph{current} partition block unless the array operations makes\nthe current block illegal, in which case we add the array operation to\na new partition block, which then becomes the current one. The\nasymptotic complexity of this algorithm is $\\ensuremath{\\mathcal{O}\\left({n^2}\\right)}$ where $n$ is the\nnumber of array operations.\n\nFig.~\\ref{fig:dag_topological} show that result of partitioning the\nPython example with a cost of 58.\n\n\n\\subsection{Merge Cache}\nIn order to amortize the execution time of applying the merge algorithms,\nBohrium implements a merge cache of previously found partitions of\narray operation lists. It is often the case that scientific\napplications use large calculation loops such that an iteration in the\nloop corresponds to a list of array operations. Since the loop\ncontains many iterations, the cache can amortize the overall execution time\ntime.\n\n\n\n\n\n\n\\section{Evaluation}\nIn this section, we will evaluate the different partition algorithm both theoretically and practically. We execute a range of scientific Python benchmarks, which are part of an open source benchmark tool and suite named Benchpress\\footnote{Available at \\url{http://benchpress.bh107.org}.  For reproducibility, the exact version can be obtained from the source code repository at \\url{https://github.com/bh107/benchpress.git} revision \\texttt{b6e9b83}.}.\n\n\n\\ifdefined{} A list of the benchmarks and the input sizes\nwe use throughout this evaluation can be found in the supplemental\nmaterial submitted with this paper as well as the system\nspecification.  \\else Table \\ref{tab:bench_specs} shows the specific\nbenchmarks that we uses and Table \\ref{tab:system_specs} specifies the\nhost machine.  \\fi When reporting execution times, we use the results\nof the mean of 10 identical executions as well as error bars that\nshows two standard deviations from the mean.\n\nWe would like to point out that even though we are using benchmarks\nimplemented in pure Python/NumPy, the performance is comparable to\ntraditional high-performance languages such as C and Fortran. This is\nbecause Bohrium overloads NumPy array\noperations~\\cite{PyHPC14_npbackend} in order to JIT compile and execute\nthem in parallel seamlessly~\\cite{cape:in_submission}.\n\n\n\\ifdefined{}\n\\begin{table}\n    \\begin{footnotesize}\n      \\begin{center}\n          \\begin{tabular}{ l l r}\n              Benchmark    & Input size (in 64bit floats) & Iterations \\\\\n            \\hline\n            Black Scholes           & $1.5\\Times10^6$ & $20$ \\\\\n            Game of Life          & $10^8$ & $20$ \\\\\n            Heat Equation         & $1.44\\Times10^8$ & $20$\\\\\n            Leibnitz PI           & $10^8$ & $20$\\\\\n            Gauss Elimination     & $2800$ & $2799$\\\\\n            LU Factorization      & $2800$ & $2799$\\\\\n            Monte Carlo PI        & $10^8$ & $20$\\\\\n            27 Point Stencil      & $4.2875\\Times10^7$ & $20$\\\\\n            Shallow Water         & $1.024\\Times10^7$ & $20$\\\\\n            Rosenbrock            & $2\\Times10^8$ & $20$\\\\\n            Successive over-relaxation & $1.44\\Times10^8$ & $20$\\\\\n            NBody                 & $6000$ & $20$\\\\\n            NBody Nice            & $40$ plantes, $2\\Times10^6$asteroids & $20$\\\\\n            Lattice Boltzmann D3Q19 & $3.375\\Times10^6$ & $20$\\\\\n            Water-Ice Simulation  & $6.4\\Times10^5$ & $20$\\\\\n          \\end{tabular}\n      \\end{center}\n    \\end{footnotesize}\n  \\caption{Benchmark applications}\n  \\label{tab:bench_specs}\n\\end{table}\n\n\\begin{table}\n  \\begin{footnotesize}\n      \\begin{center}\n          \\begin{tabular}{ l l}\n            Processor:        & Intel Core i7-3770 \\\\\n            Clock:            & 3.4 GHz            \\\\\n            \\#Cores:          & 4                  \\\\\n            Peak performance: & 108.8 GFLOPS       \\\\\n            L3 Cache:         & 16MB               \\\\\n            Memory:           & 128GB DDR3         \\\\\n            Operating system: & Ubuntu Linux 14.04.2 LTS \\\\\n            Software:         & GCC v4.8.4, Python v2.7.6, NumPy 1.8.2\\\\\n          \\end{tabular}\n      \\end{center}\n  \\end{footnotesize}\n  \\caption{System specifications}\n  \\label{tab:system_specs}\n\\end{table}\n\\fi\n\n\n\\subsubsection*{Theoretical Partition Cost}\n\nFig. \\ref{bench:unique_fuseprice} shows that theoretical partition\ncost (Def. \\ref{def:bh_partition_cost}) of the four different\npartition algorithms previously presented. Please note that the last\nfive benchmarks do not show an optimal solution. This is because the\nassociated search trees are too large for our branch-and-bound\nalgorithm to solve. For example, the search tree of the Lattice\nBoltzmann is $2^{664}$, which is simply too large even if the bound\ncan cut $99.999\\%$ of the search tree away.\n\nAs expected, we observe that the three algorithms that do fusion,\nLinear, Greedy, and Optimal, have a significant smaller cost than the\nnon-fusing algorithm Singleton. The difference between Linear and\nGreedy is significant in some of the benchmarks but the difference\nbetween greedy and optimal does almost not exist.\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px}, clip, width=\\linewidth]{benchmark/plots/unique_fuseprice.pdf}\n \\caption{Theoretical cost of the different partition algorithms. NB: the last five benchmarks, Lattice Boltzmann, NBody, NBody Nice, SOR, Water-Ice Simulation, do not show an optimal solution.}\n \\label{bench:unique_fuseprice}\n\\end{figure}\n\n\n\n\\subsubsection*{Practical Execution Time}\nIn order to evaluate the full picture, we do three execution time\nmeasurements: one with a warm fuse cache, one with a cold fuse cache,\nand one with no fuse cache. Fig. \\ref{bench:unique_warmcache} shows\nthe execution time when using a warm fuse cache thus we can compare the\ntheoretical partition cost with the practical execution time without the\noverhead of running the partition algorithm. Looking at\nFig. \\ref{bench:unique_fuseprice} and\nFig. \\ref{bench:unique_warmcache}, it is evident that our cost model,\nwhich is a measurement of unique array accesses\n(Def. \\ref{def:bh_partition_cost}), compares well to the practical\nexecution time result in this specific benchmark setup. However, there are\nsome outliers -- the Monte Carlo Pi benchmark has a theoretical\npartition cost of $1$ when using the Greedy and Optimal algorithm but\nhas a significantly greater practical execution time. This is because the\nexecution becomes computation bound rather than memory bound thus a\nfurther reduction in memory accesses does not improve performance.\nSimilarly, in the 27 Point Stencil benchmark the theoretical partition\ncost is identical for Linear, Greedy, and Optimal, but in practice\nOptimal is marginally better. This is an artifact of our cost model,\nwhich define the cost of reads and writes identically.\n\n\\ifdefined{}\nThe execution time measurements with the cold fuse cache and with the fuse cache completely disabled are in the supplemental material submitted with this paper.\n\\fi\nWith the cold fuse cache, the partition algorithm runs once in the first iteration of the computation. The results show that $20$ iterations, which most of the benchmarks uses, is enough to amortize the partition overhead\\ifdefined{}\n~(Fig.~\\ref{bench:unique_coldcache})\\fi. Whereas, if we run with no fuse cache, i.e.~we execute the partition algorithm in each iteration\\ifdefined{}~(Fig.~\\ref{bench:unique_nocache})\\fi, the Linear partition algorithm outperforms both the Greedy and Optimal algorithm because of its smaller time complexity.\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_filecache.pdf}\n \\caption{Execution time of the different partition algorithms using a \\textbf{warm cache}.}\n \\label{bench:unique_warmcache}\n\\end{figure}\n\n\n\n\\ifdefined{}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_memcache.pdf}\n \\caption{Execution time of the different partition algorithms using a \\textbf{cold cache}.}\n \\label{bench:unique_coldcache}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_nocache.pdf}\n \\caption{Execution time of the different partition algorithms using \\textbf{no cache}.}\n \\label{bench:unique_nocache}\n\\end{figure}\n\n\\fi\n\n\\subsection{Alternative Cost Model}\n\\label{sec:alternative-cost}\nWith the theoretical and practical framework we are presenting in this\npaper, it is straightforward to explore the impact of alternative cost\nmodels. In this section, we will do exactly that -- replace our cost\nmodel with alternative cost models and evaluate the effect on the\nexecution time of the generated code.\n\nLet us define and evaluate three alternative cost models, \\emph{Max\n  Contract}, \\emph{Max Locality}, and \\emph{Robinson}, which are used\nin related literature~\\cite{Darte2002, Megiddo1997, Robinson2014}:\n\\begin{definition}\n\\label{def:tmpelem_partition_cost}\nThe cost model \\textbf{Max Contract} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "itemtype": "equation", "pos": 40327, "prevtext": "\n  since all other blocks are the same. By using the fact that $B_1$\n  must be executed before $B_2$, whereby\n  ${\\mathsf{{in}}}[B_1]\\cap{\\mathsf{{new}}}[B_2]=\\emptyset$ and\n  ${\\mathsf{{del}}}[B_1]\\cap{\\mathsf{{out}}}[B_2]=\\emptyset$, as well as the ${\\mathsf{{new}}}$'s\n  and ${\\mathsf{{del}}}$'s being disjoint, direct calculation yields\n  Eq.~\\ref{eq:cost_saving}.\n\\end{proof}\nNote that Prop.~\\ref{prop:cost_saving} directly implies that the cost\nfunction of Def.~\\ref{def:bh_partition_cost} is positive and\nmonotonically decreasing, as required by Def.~\\ref{def:wsp_cost}.\nWe next show how the problem can be formulated as a WSP instance.\n\n\\subsubsection{Constructing a WSP-problem from Bohrium bytecode}\n\nGiven a list $A$ of Bohrium array operations, a WSP problem $G =\n(V,E_d,E_f)$ is constructed as follows. \n\\begin{enumerate}\n  \\item The data dependencies between array operations define a partial order: $a {   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a'$ iff $a'$ must be executed before $a$.\n  \\item Each array operation $a\\in A$ defines a vertex $v(a)\\in V$. \n                                                                    \n  \\item The dependency graph $E_d$ has an edge $(v(a),v(a'))$ for each pair $a,a'\\in A$ with $a{   \\mathrel{\\vbox{\\offinterlineskip\\ialign{     \\hfil##\\hfil\\cr     $\\scriptscriptstyle d$\\cr     \\noalign{\\kern0ex}     ${<}$\\cr }}}} a'$.\n  \\item The fuse-prevention graph $E_f$ has an edge $(v(a),v(a'))$ for each non-fusible pair $a,a'\\in A$.\n\\end{enumerate}\nThe cost function is as in Def.~\\ref{def:bh_partition_cost}, but note\nthat it can be calculated incrementally using Prop.~\\ref{prop:cost_saving}.\n\nThe complexity of this transformation is $O(V^2)$ since we may have\nto check all pairs of array operations for dependecies, fusibility,\nand cost-saving, all of which is $O(1)$.  Fig.~\\ref{fig:dag_singleton}\nshows the trivial partition, $\\bot$, of the Python example, where every\narray operation has its own block. The cost \nis 94.\n\n\n\\subsubsection{WSP solves Fusion of Array Operations}\nFinally, we can show that a solution to the WSP problem also is a\nsolution to the FAO problem.\n\n\\begin{theorem}\n\\label{tho:wsp_is_fao}\n  WSP solves Fusion of Array Operations.\n\\end{theorem}\n\\begin{proof}\n  It is clear from Def.~\\ref{def:wsp_legal_partition} and the construction above that the legal\n  partitions $\\hat{\\Pi}_V$ are exactly all those that fulfill Properties (1) and (2) of\n  Def.~\\ref{def:fao_problem}. Thus, Def.~\\ref{def:wsp_solution} yields a global minimum\n  for all such partitions, fulfilling also Def.~\\ref{def:fao_problem}(3).\n\\end{proof}\n\n\n\n\n\n\n\\begin{figure}\n \\centering\n \\vspace{-0.3cm}\n \\includegraphics[trim={10px 10px 10px 10px}, clip, width=\\linewidth]{gfx/dag_singleton.pdf}\n \\caption{A partition graph of the Python application in\n   Fig. \\ref{fig:python_code}. For illustrative proposes, the graph\n   does not include ignored weight edges \\ifdefined{}\n   (cf. Fig. \\ref{algo:legal})\\fi.}\n\\label{fig:dag_singleton}\n\\end{figure}\n\n\n\n\n\n\n\n\\ifdefined{}\n\\begin{figure*}\n\\footnotesize\n\\setlength{\\columnsep}{5pt}\n\\begin{multicols}{3}\n    \\subfloat[][Help function for Unintrusive]{\\label{algo:gently_help}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{FindCandidate}{$G$}     \\For{$(v,u) \\gets E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G,(u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\For{$(v,u) \\gets E_w[G]$}     \\If{degree is less than $2$ for either $u$ or $v$          when only counting edges in $E_w[G]$}             \\If{$\\theta[u] = \\theta[v]$}                 \\State \\Return $(u,v)$             \\EndIf         \\EndIf     \\EndFor     \\State \\Return $(\\Call{NIL}{},\\Call{NIL}{})$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\subfloat[][Unintrusive]{\\label{algo:gently}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Unintrusive}{$G$}     \\While{$(u,v) \\gets \\Call{FindCandidate}{G} \\neq (\\Call{NIL}{},\\Call{NIL}{})$}         \\State $G\\gets$ \\Call{Merge}{$G,u,v$}     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\newpage \\vskip -10cm\n    \\subfloat[][Greedy]{\\label{algo:greedy}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Greedy}{$G$}     \\While{$E_w[G] \\neq \\emptyset$} \\label{algo:greedy:while}         \\State $(u, v)\\gets \\Call{Find-Heaviest}{E_w[G]}$ \\label{algo:greedy:heaviest}         \\If{$\\Call{Legal}{G, (u,v)}$}             \\State $G\\gets$ \\Call{Merge}{$G,u,v$}\\label{algo:greedy:merge}         \\Else             \\State Remove edge $(u,v)$ from $E_w$ \\label{algo:greedy:remove}         \\EndIf     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\subfloat[][Help function for Optimal]{\\label{algo:optimal_help}\\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{MergeByMask}{$G, M$}     \\State $f\\gets$ \\textbf{true}\\Comment{Flag that indicates fusibility}     \\For{$i\\gets 0$ \\textbf{to} $|E_w[G]|-1$}         \\If{$M_i = 1$}         \\State $(u,v)\\gets$ the $i$'th edge in $E_w[G]$             \\If{\\textbf{not} \\Call{Fusible}{$G, u,v$}}                 \\State $f\\gets$ \\textbf{false}             \\EndIf             \\State $G\\gets$ \\Call{Merge}{$G, u, v$}         \\EndIf     \\EndFor     \\State \\Return $(G, f)$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\newpage\\vskip -10cm\n    \\subfloat[][Optimal]{\\label{algo:optimal}  \\begin{tcolorbox}[width=1\\linewidth] \\begin{algorithmic}[1] \\Function{Optimal}{$G$}     \\State $G\\gets$ \\Call{Unintrusive}{$G$}     \\For{$(v, u) \\gets |E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G, (u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\State $G_{\\min}\\gets$ \\Call{Greedy}{$G$}\\Comment{Good guess}     \\State $M_{0..|E_w[G]|}\\gets 1$\\Comment{Fill array $M$}     \\State $o\\gets 0$\\Comment{The mask offset}     \\State $Q\\gets \\emptyset$     \\State \\Call{Enqueue}{$Q, (M, o)$}     \\While{$Q \\neq \\emptyset$}         \\State $(M, o)\\gets$ \\Call{Dequeue}{$Q$}         \\State $(G',f)\\gets$ \\Call{MergeByMask}{$G, M$}         \\If{$cost(G') < cost(G_{\\min})$}             \\If{$f$ \\textbf{and} $G'$ is acyclic}                 \\State $G_{\\min}\\gets G'$ \\Comment{New best partitioning}             \\EndIf         \\EndIf         \\For{$i\\gets o$ \\textbf{to} $|M|-1$}             \\State $M'\\gets M$             \\State $M'_i\\gets 0$             \\State \\Call{Enqueue}{$Q, (M', i+1)$}         \\EndFor     \\EndWhile     \\State \\Return $G_{\\min}$ \\EndFunction \\end{algorithmic} \\end{tcolorbox}}\\par\n    \\end{multicols}\n\\caption{The partition algorithms where the function, $cost(G)$, returns the partition cost of the partition graph $G$.}\n\\end{figure*}\n\\fi\n\n\n\\section{Algorithms}\n\nIn this section, we present an exact algorithm for finding an\noptimal solution to WSP (with exponential worst-case execution time),\nand two fast algorithms that find approximate solutions. We\nuse the Python application shown in Fig.~\\ref{fig:python_code} to\ndemonstrate the results of each partition algorithm.\n\n\\subsection{Partition graphs and chains of block merges}\nAll three algorithms work on data structures called {\\em partition\n  graphs}, defined as follows:\n\\begin{definition}[Partition graph]\n  Given a graph $G = (V,E)$ and a partition $P$ of $V$, the\n  corresponding {\\em partition graph} is the graph ${\\hat{{G}}({P})} =\n  (P,{\\hat{{E}}({P})})$ that has an edge $(B,B')$ if there is an\n  edge $(u,v)\\in E$ with $u\\in B$ and $v\\in B'$. That is, the vertices\n  are the blocks, connected by the edges that cross block boundaries.\n\\end{definition}\n\\noindent\nFrom this we build the state needed in WSP computations:\n\n\\begin{definition}[WSP state]\n  Given a WSP-instance $G = (V,E_d,E_f,{\\mathsf{{cost}}})$ and a partition $P$,\n  the {\\em WSP state} is the partition graph ${\\hat{{G}}({P})} =\n  (P,{\\hat{{E_d}}({{P}})},{\\hat{{E_f}}({{P}})})$ together with a complete weighted\n  graph ${\\hat{{E_w}}({P})}$ with weights $w(B_1,B_2) = {\\mathsf{{cost}}}(P) -\n  {\\mathsf{{cost}}}(P {/} (B_1,B_2))$.\n\\end{definition}\nNotice that $w(B_1,B_2) = {\\mathsf{{saving}}}(B_1,B_2)$ for the Bohrium cost\nfunction, as shown in Prop.~\\ref{prop:cost_saving}, and does not\nrequire a full cost calculation.\n\\begin{definition}[Merge operator on partition graphs]\n  We extend the merge operator of Def.~\\ref{def:block_merge} to\n  partition graphs as ${\\hat{{G}}({P})} {/} (B_1,B_2) = {\\hat{{G}}({P     {/} (B_1,B_2)})}$.  This acts exactly as a vertex contraction\n  on the partition graph.\n\\end{definition}\nThe merge operator is commutative in the sense that the order in a\nsequence of successive vertex contractions doesn't affect the result \\cite{wolle2004note}.\nAn auxiliary function, \\Call{Merge}{}, is used in each algorithm to update the state.\n\\begin{definition}\n  Let $S = (\\hat{G},\\hat{E}_w)$ be a WSP state. We define\n \n", "index": 19, "text": "\\[\n     \\Call{Merge}{(S,u,v)} = (\\hat{G} {/} (u,v), \\hat{E_w}')\n  \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\textsc{Merge}((S,u,v))=(\\hat{G}{/}(u,v),\\hat{E_{w}}^{\\prime})\" display=\"block\"><mrow><mrow><mtext class=\"ltx_font_smallcaps\" mathvariant=\"normal\">Merge</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">(</mo><mi>S</mi><mo>,</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mover accent=\"true\"><mi>G</mi><mo stretchy=\"false\">^</mo></mover><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><msup><mover accent=\"true\"><msub><mi>E</mi><mi>w</mi></msub><mo stretchy=\"false\">^</mo></mover><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nwhere $|new[A]|$ is the total number of allocated arrays. Thus, in this cost model, all arrays that are not contracted add $1$ to the cost.\n\\end{definition}\n\\begin{definition}\n\\label{def:reuse_partition_cost}\nThe cost model \\textbf{Max Locality} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "itemtype": "equation", "pos": 65747, "prevtext": "\n  where $\\hat{E_w}'$ is the updated weight graph on the edges\n  incident to the new vertex $z = u\\cup v$.\n\\end{definition}\nThe complexity of \\Call{Merge}{} is dominated by the weight update, which requires\na ${\\mathsf{{saving}}}{}$ computations per edge incident to the merged vertex,\nand is bounded by \\ensuremath{\\mathcal{O}\\left({V^2}\\right)}. We next need a local condition for when\na merge is allowed:\n\\begin{lemma}[Legal merge]\n  \\label{lem:legal_partition_merge}\n  Let $P_{1,2} = P{/} (B_1,B_2)$ be the successor to a legal\n  partition $P\\in\\hat{\\Pi}_V$, derived by merging blocks $B_1$ and\n  $B_2$.  Then $P_{1,2}\\in\\hat{\\Pi}_V$ if and only if\n  \\begin{enumerate}\n  \\item $(B_1,B_2)\\notin {\\hat{{E_f}}({{P}})}$, and\n  \\item there is no path of length $\\ge 2$ from $B_1$ to $B_2$ in the\n        partition graph ${\\hat{{E_d}}({{P}})}$.\n  \\end{enumerate}\n\\end{lemma}\n\\begin{proof}\n  Recall that $\\hat{\\Pi}_V$ is the subset of partitions in $\\Pi_V$\n  that satisfy Def.~\\ref{def:wsp_legal_partition}.  Because $P$ is\n  legal, no block contains an edge in $E_f$. Hence $P_{1,2}$ obeys\n  Def.~\\ref{def:wsp_legal_partition}(1) if and only if no two vertices\n  $u\\in B_1$ and $v\\in B_2$ are connected in $E_f$, or equivalently,\n  $(B_1,B_2)\\notin {\\hat{{E_f}}({{P}})}$. \n\n  Similarly, by assumption, there are no cycles in ${\\hat{{E_d}}({{P}})}$.\n  Thus, $P_{1,2}$ violates Def.~\\ref{def:wsp_legal_partition}(2) if and\n  only if ${\\hat{{E_d}}({{P}})}$ contains a path $B_{1}\\to B' \\to \\cdots \\to\n  B_{2}$, forming the cycle $B_{1,2} \\to B' \\to \\cdots \\to B_{1,2}$ in\n  ${\\hat{{E_d}}({{P_{1,2}}})}$ (where $B_{1,2} = B_1\\cup B_2$).\n\\end{proof}\n\n\\begin{prop}[Reachability through legal merges]\n  Given two legal partitions $P {<} P'$, there exists a successor\n  chain $P {\\prec} P_1 {\\prec} P_2 {\\prec} \\cdots {\\prec} P'$\n  entirely contained in $\\hat{\\Pi}_V$, i.e.  corresponding only to\n  legal block merges.\n\\end{prop}\n\\begin{proof}\n  A successor chain $P {\\prec} P_1 {\\prec} \\cdots {\\prec} P_{n-1}\n  {\\prec} P'$ always exists in the total set of partitions $\\Pi_V$,\n  and all such chains are of the same length $n$.  Any such chain\n  contains no partition that violates\n  Def.~\\ref{def:wsp_legal_partition}(1): each step is a merge,\n  so once a fuse-preventing edge is placed inside a block, it would\n  be included also in a block from $P'$.\n  Hence we only need to worry about Def.~\\ref{def:wsp_legal_partition}(2).\n\n  We now show by induction that a successor chain consisting of only\n  legal partitions exists.  First, if $P{\\prec} P'$, it is trivially\n  so. Assume now that the statement is true for all $n \\le N$, and\n  consider $P{<} P'$ of distance $N+1$.\n\n  \n  \n  \n  \n  \n  Pick any successor chain from $P$ to $P'$.  If any step violates\n  Def.~\\ref{def:wsp_legal_partition}(2), then let $P_{i+1} =\n  P_i{/} (B_1,B_2)$ be the first partition in the chain that does\n  so. Then there is a path $B_1\\to B\\to\\cdots \\to B_2$ in the\n  transitive reduction of ${\\hat{{E_d}}({{P_i}})}$. Because $P'$ satisfies\n  Def.~\\ref{def:wsp_legal_partition}(2), $B_1\\cup B\\cup B_2$ is\n  contained in a block from $P'$, whereby $P_{i+1}' \\equiv P_i{/}\n  (B_1,B) {<} P'$. This merge introduces no cycles, because the\n  path is in the transitive reduction.  Now let $P_{i+1}' {\\prec}\n  P_{i+2}' {\\prec} \\cdots {\\prec} P'$ be a legal successor chain of\n  length $N-i$, known to exist by hypothesis. Then $P{\\prec}\n  P_1{\\prec}\\cdots {\\prec} P_i {\\prec} P_{i+1}' {\\prec} \\cdots\n  {\\prec} P'$ is a length-$N+1$ successor chain consisting of only\n  legal partitions, concluding the proof by induction.\n\\end{proof}\nIn particular, the optimal solutions can be reached in this way from\nthe bottom partition $\\bot = \\{\\{v_1\\},\\{v_2\\},\\ldots,\\{v_n\\}\\}$,\nwhich we will use in the design of the algorithms.\n\n\n\\ifdefined{}\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Legal}{$G, e$}     \\State $(u,v)\\gets e$     \\State $l\\gets$ length of longest path between $u$ and $v$ in $E_d[G]$ \\label{algo:legal:path}     \\If{$l = 1$} \\label{algo:legal:transitive}         \\State \\Return $false$     \\Else         \\State \\Return $true$     \\EndIf \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{A help function thet determines whether the weight edge, $e \\in E_w[G]$}\n\\label{algo:legal}\n\\end{figure}\n\\fi\n\n\n\\ifdefined{}\n\\begin{figure}\n    \\vspace{-0.5cm}\n    \\centering\n    \\subfloat[][Greedy]{\\label{fig:dag_greedy}         \\includegraphics[trim={15px 10px 12px 10px}, clip, scale=0.5, valign=t]{gfx/dag_greedy.pdf}}\n    \\subfloat[][Unintrusive]{\\label{fig:dag_gently}    \\includegraphics[trim={12px 10px 15px 10px}, clip, scale=0.5, valign=t]{gfx/dag_gently.pdf}}\\\\\n    \\vspace{-0.3cm}\n    \\subfloat[][Optimal]{\\label{fig:dag_optimal}       \\includegraphics[trim={10px 10px 10px 10px}, clip, scale=0.5, valign=t]{gfx/dag_optimal.pdf}}\n    \\subfloat[][Linear]{\\label{fig:dag_topological}\\includegraphics[trim={-10px 10px -10px 10px}, clip, scale=0.5, valign=t]{gfx/dag_topological.pdf}}\n    \\caption{Four partition graphs that are the result of running the\n      four partition algorithms with Fig. \\ref{fig:dag_singleton} as\n      input. Lowercase variable names indicate that they are\n      \\emph{array contracted}.}\n\\end{figure}\n\\fi\n\n\\subsection{Unintrusive Partition Algorithm}\n\nIn order to reduce the size of the partition graph to be analyzed, we apply an\nunintrusive strategy where we merge vertices that are guaranteed to be\npart of an optimal solution. Consider the two vertices, $a,e$, in\nFig. \\ref{fig:dag_singleton}. The only beneficial merge possibility\n$a$ has is with $e$, so if $a$ is merged in the optimal solution, it\nis with $e$. Now, since fusing $a,e$ will not impose any restriction\nto future possible vertex merges in the graph, the two vertices are\nsaid to be \\emph{unintrusively fusible}. We formalize this property\nusing the {\\em non-fusible sets}:\n\\begin{definition}[$\\theta$, non-fusible set]\n  The {\\em non-fusible} set,  $\\theta[b]$ for a block $b$\n  is the set of blocks connected with $b$ in $\\hat{E_d}$ through\n  a path containing a non-fusible edge.\n\\end{definition}\n\\begin{theorem}\n\\label{tho:gentle_fusible}\nGiven a partition graph $\\hat{G}$, let $z = u\\cup v$ be the merged\nvertex in $\\hat{G} {/} (u,v)$. The vertices\n$u$ and $v$ are {\\em unintrusively fusible} whenever:\n\\begin{enumerate}\n    \\item $\\theta[u] = \\theta[v] = \\theta[z]$, i.e.~the non-fusibles are unchanged. \n    \\item Either $u$ or $v$ is a pendant vertex in $\\hat{E_d}$, i.e. the\n         degree of either $u$ or $v$ must be $1$.\n\\end{enumerate}\n\\end{theorem}\n\\begin{proof}\n  If Condition 1 is satisfied, any merge that is disallowed at a further\n  stage due to Def.~\\ref{def:wsp_legal_partition}(1) would be disallowed also without the merge.\n  Similarly, merging a pendant vertex with its parent does not affect\n  the possiblity of introducing cycles through future merges (Def.~\\ref{def:wsp_legal_partition}(1)).\n  Finally, since the cost function is monotonic, the merge cannot adversely affect a future cost.\n\\end{proof}\n\nFig.~\\ref{algo:gently} shows the unintrusive partitioning algorithm. It uses\na helper function, \\Call{FindCandidate}{}, to find two vertices that are\nunintrusively fusible. The complexity of \\Call{FindCandidate}{}\nis $\\ensuremath{\\mathcal{O}\\left({E(E+V)}\\right)}$, which dominates the while-loop in \\Call{Unintrusive}{},\nwhereby the overall complexity of the unintrusive merge algorithm is\n$\\ensuremath{\\mathcal{O}\\left({E^2(E+V)}\\right)}$. Note that there is little need to further optimize\n\\Call{Unintrusive}{} since we will only use it as a preconditioner for the\noptimal solution, which will dominate the computation time.\n\n\\ifdefined{}\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{FindCandidate}{$G$}     \\For{$(v,u) \\gets E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G,(u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\For{$(v,u) \\gets E_w[G]$}     \\If{degree is less than $2$ for either $u$ or $v$          when only counting edges in $E_w[G]$}             \\If{$\\theta[u] = \\theta[v]$}                 \\State \\Return $(u,v)$             \\EndIf         \\EndIf     \\EndFor     \\State \\Return $(\\Call{NIL}{},\\Call{NIL}{})$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Unintrusive}{$G$}     \\While{$(u,v) \\gets \\Call{FindCandidate}{G} \\neq (\\Call{NIL}{},\\Call{NIL}{})$}         \\State $G\\gets$ \\Call{Merge}{$G,u,v$}     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The unintrusive merge algorithm that only merge \\emph{unintrusively fusible} vertices.}\n\\label{algo:gently}\n\\end{figure}\n\\fi\n\nFig. \\ref{fig:dag_gently} shows an unintrusive partition of the Python\nexample with a partition cost of 70. However, the significant\nimprovement is the reduction of the number of weight edges in the\ngraph. As we shall see next, in order to find an optimal graph\npartition in practical time, the number of weight edges in the graph\nmust be modest.\n\n\n\\subsection{Greedy Partition Algorithm}\n\nFig. \\ref{algo:greedy} shows a greedy merge algorithm. It uses the\nfunction $\\Call{Find-Heaviest}{}$ to find the edge in $E_w$ with the\ngreatest weight and either remove it or merge over it. Note that\n$\\Call{Find-Heaviest}{}$ must search through $E_w$ in each iteration\nsince $\\Call{Merge}{}$ might change the weights.\n\nThe number of iterations in the while loop (line\n\\ref{algo:greedy:while}) is $\\ensuremath{\\mathcal{O}\\left({E}\\right)}$ since at least one weight edge is\nremoved in each iteration either explicitly (line\n\\ref{algo:greedy:remove}) or implicitly by \\Call{Merge}{} (line\n\\ref{algo:greedy:merge}). The complexity of finding the heaviest (line\n\\ref{algo:greedy:heaviest}) is $\\ensuremath{\\mathcal{O}\\left({E}\\right)}$, calling \\Call{Legal}{} is\n$\\ensuremath{\\mathcal{O}\\left({E+V}\\right)}$, and calling \\Call{Merge}{} is $\\ensuremath{\\mathcal{O}\\left({V^2}\\right)}$ thus the overall\ncomplexity is $\\ensuremath{\\mathcal{O}\\left({V^2E}\\right)}$.\n\nFig. \\ref{fig:dag_greedy} shows a greedy partition of the Python\nexample.  The partition cost is 58, which is a significant improvement\nover no merge. However, it is not the optimal partitioning, as we\nshall see later.\n\n\\ifdefined{}\n\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Greedy}{$G$}     \\While{$E_w[G] \\neq \\emptyset$} \\label{algo:greedy:while}         \\State $(u, v)\\gets \\Call{Find-Heaviest}{E_w[G]}$ \\label{algo:greedy:heaviest}         \\If{$\\Call{Legal}{G, (u,v)}$}             \\State $G\\gets$ \\Call{Merge}{$G,u,v$}\\label{algo:greedy:merge}         \\Else             \\State Remove edge $(u,v)$ from $E_w$ \\label{algo:greedy:remove}         \\EndIf     \\EndWhile     \\State \\Return $G$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The greedy merge algorithm that greedily merges the vertices connected with the heaviest weight edge in $G$.}\n\\label{algo:greedy}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_greedy.pdf}\n \\caption{A partition graph of the greedy merge of the graph in Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_greedy}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_gently.pdf}\n \\caption{A partition graph of the unintrusive merge of the graph in Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_gently}\n\\end{figure}\n\n\\fi\n\n\n\\subsection{Optimal Partition Algorithm}\nBecause the WSP problem is NP-hard, we cannot in general hope to solve\nit exactly in polynomial time. However, we may be able to solve the\nproblems within reasonable time in common cases given a carefully\nchosen search strategy through the $2^E$ possible partitions. For this\npurpose, we have implemented a branch-and-bound algorithm,\nexploiting the monotonicity of the partition cost (Def.~\\ref{def:wsp_cost}(2)).\nIt is shown in Fig.~\\ref{algo:optimal}, and proceeds as follows:\n\nBefore starting, the largest unintrusive partition is found. This is\nthe largest partition that we can ensure is included in an optimal\npartition.  The blocks of the unintrusive partition will be the\nvertices in our initial partition graph.  Second, a good suboptimal\nsolution is computed. We use the greedy algorithm for this purpose,\nbut any scheme will do.  We now start a search rooted in the\n$\\top$-partition where everything is one block. This has the lowest\ncost, but will in general be illegal.  Each recursion step cuts a\nweight edge that has not been considered before, if it yields a cost\nthat is strictly lower than the currently best partition $G_{\\min}$\n(if the cost is higher than for $G_{\\min}$, no further splitting will\nyield a better partition, and its search subtree can be ignored). If\nwe reach a legal partition, this will be the new best candidate, and\nno further splitting will yield a better one. When the work queue is\nempty, $G_{\\min}$ holds an optimal solution to WSP.\n\nFig.~\\ref{algo:optimal} shows the implementation, Fig.~\\ref{fig:search_tree} shows an example of a branch-and-bound search tree, and Fig.~\\ref{fig:dag_optimal} shows an optimal partition of the Python example with a partition cost of 38.\n\n\\begin{figure}\n \\centering\n \\vspace{-10px}\n \\includegraphics[width=\\linewidth]{gfx/search_tree.pdf}\n \\caption{A branch-and-bound search tree of the unintrusively merged\n   partition graph (Fig. \\ref{fig:dag_gently}). Each vertex lists a\n   sequences of vertex merges that build a specific graph\n   partition. The grayed out area indicates the part of the search\n   tree that a depth-first-search can skip because of the cost\n   bound. }\n \\label{fig:search_tree}\n\\end{figure}\n\n\\ifdefined{}\n\n\\begin{figure}\n\\footnotesize\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{MergeByMask}{$G, M$}     \\State $f\\gets$ \\textbf{true}\\Comment{Flag that indicates fusibility}     \\For{$i\\gets 0$ \\textbf{to} $|E_w[G]|-1$}         \\If{$M_i = 1$}         \\State $(u,v)\\gets$ the $i$'th edge in $E_w[G]$             \\If{\\textbf{not} \\Call{Fusible}{$G, u,v$}}                 \\State $f\\gets$ \\textbf{false}             \\EndIf             \\State $G\\gets$ \\Call{Merge}{$G, u, v$}         \\EndIf     \\EndFor     \\State \\Return $(G, f)$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\begin{tcolorbox}\n     \\begin{algorithmic}[1] \\Function{Optimal}{$G$}     \\State $G\\gets$ \\Call{Unintrusive}{$G$}     \\For{$(v, u) \\gets |E_w[G]$}         \\If{\\textbf{not} $\\Call{Legal}{G, (u,v)}$}             \\State Remove edge $(u,v)$ from $E_w$         \\EndIf     \\EndFor     \\State $G_{\\min}\\gets$ \\Call{Greedy}{$G$}\\Comment{Good guess}     \\State $M_{0..|E_w[G]|}\\gets 1$\\Comment{Fill array $M$}     \\State $o\\gets 0$\\Comment{The mask offset}     \\State $Q\\gets \\emptyset$     \\State \\Call{Enqueue}{$Q, (M, o)$}     \\While{$Q \\neq \\emptyset$}         \\State $(M, o)\\gets$ \\Call{Dequeue}{$Q$}         \\State $(G',f)\\gets$ \\Call{MergeByMask}{$G, M$}         \\If{$cost(G') < cost(G_{\\min})$}             \\If{$f$ \\textbf{and} $G'$ is acyclic}                 \\State $G_{\\min}\\gets G'$ \\Comment{New best partitioning}             \\EndIf         \\EndIf         \\For{$i\\gets o$ \\textbf{to} $|M|-1$}             \\State $M'\\gets M$             \\State $M'_i\\gets 0$             \\State \\Call{Enqueue}{$Q, (M', i+1)$}         \\EndFor     \\EndWhile     \\State \\Return $G_{\\min}$ \\EndFunction \\end{algorithmic} \n\\end{tcolorbox}\n\\caption{The optimal merge algorithm that optimally merges the\n  vertices in $G$. The function, $cost(G)$, returns the partition cost\n  of the partition graph $G$.}\n\\label{algo:optimal}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_optimal.pdf}\n \\caption{A partition graph of the optimal merge of the graph in\n   Fig. \\ref{fig:dag_singleton}.}\n\\label{fig:dag_optimal}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[scale=0.5]{gfx/dag_topological.pdf}\n \\caption{A partition graph of a Linear partition of the Python\n   example (Fig. \\ref{fig:python_code}).}\n\\label{fig:dag_topological}\n\\end{figure}\n\n\\fi\n\n\n\\subsection{Linear Merge}\nFor completeness, we also implement a partition algorithm that does\nnot use a graph representation. In this na\\\"{\\i}ve approach, we simply\ngo through the array operation list and add each array operation to\nthe \\emph{current} partition block unless the array operations makes\nthe current block illegal, in which case we add the array operation to\na new partition block, which then becomes the current one. The\nasymptotic complexity of this algorithm is $\\ensuremath{\\mathcal{O}\\left({n^2}\\right)}$ where $n$ is the\nnumber of array operations.\n\nFig.~\\ref{fig:dag_topological} show that result of partitioning the\nPython example with a cost of 58.\n\n\n\\subsection{Merge Cache}\nIn order to amortize the execution time of applying the merge algorithms,\nBohrium implements a merge cache of previously found partitions of\narray operation lists. It is often the case that scientific\napplications use large calculation loops such that an iteration in the\nloop corresponds to a list of array operations. Since the loop\ncontains many iterations, the cache can amortize the overall execution time\ntime.\n\n\n\n\n\n\n\\section{Evaluation}\nIn this section, we will evaluate the different partition algorithm both theoretically and practically. We execute a range of scientific Python benchmarks, which are part of an open source benchmark tool and suite named Benchpress\\footnote{Available at \\url{http://benchpress.bh107.org}.  For reproducibility, the exact version can be obtained from the source code repository at \\url{https://github.com/bh107/benchpress.git} revision \\texttt{b6e9b83}.}.\n\n\n\\ifdefined{} A list of the benchmarks and the input sizes\nwe use throughout this evaluation can be found in the supplemental\nmaterial submitted with this paper as well as the system\nspecification.  \\else Table \\ref{tab:bench_specs} shows the specific\nbenchmarks that we uses and Table \\ref{tab:system_specs} specifies the\nhost machine.  \\fi When reporting execution times, we use the results\nof the mean of 10 identical executions as well as error bars that\nshows two standard deviations from the mean.\n\nWe would like to point out that even though we are using benchmarks\nimplemented in pure Python/NumPy, the performance is comparable to\ntraditional high-performance languages such as C and Fortran. This is\nbecause Bohrium overloads NumPy array\noperations~\\cite{PyHPC14_npbackend} in order to JIT compile and execute\nthem in parallel seamlessly~\\cite{cape:in_submission}.\n\n\n\\ifdefined{}\n\\begin{table}\n    \\begin{footnotesize}\n      \\begin{center}\n          \\begin{tabular}{ l l r}\n              Benchmark    & Input size (in 64bit floats) & Iterations \\\\\n            \\hline\n            Black Scholes           & $1.5\\Times10^6$ & $20$ \\\\\n            Game of Life          & $10^8$ & $20$ \\\\\n            Heat Equation         & $1.44\\Times10^8$ & $20$\\\\\n            Leibnitz PI           & $10^8$ & $20$\\\\\n            Gauss Elimination     & $2800$ & $2799$\\\\\n            LU Factorization      & $2800$ & $2799$\\\\\n            Monte Carlo PI        & $10^8$ & $20$\\\\\n            27 Point Stencil      & $4.2875\\Times10^7$ & $20$\\\\\n            Shallow Water         & $1.024\\Times10^7$ & $20$\\\\\n            Rosenbrock            & $2\\Times10^8$ & $20$\\\\\n            Successive over-relaxation & $1.44\\Times10^8$ & $20$\\\\\n            NBody                 & $6000$ & $20$\\\\\n            NBody Nice            & $40$ plantes, $2\\Times10^6$asteroids & $20$\\\\\n            Lattice Boltzmann D3Q19 & $3.375\\Times10^6$ & $20$\\\\\n            Water-Ice Simulation  & $6.4\\Times10^5$ & $20$\\\\\n          \\end{tabular}\n      \\end{center}\n    \\end{footnotesize}\n  \\caption{Benchmark applications}\n  \\label{tab:bench_specs}\n\\end{table}\n\n\\begin{table}\n  \\begin{footnotesize}\n      \\begin{center}\n          \\begin{tabular}{ l l}\n            Processor:        & Intel Core i7-3770 \\\\\n            Clock:            & 3.4 GHz            \\\\\n            \\#Cores:          & 4                  \\\\\n            Peak performance: & 108.8 GFLOPS       \\\\\n            L3 Cache:         & 16MB               \\\\\n            Memory:           & 128GB DDR3         \\\\\n            Operating system: & Ubuntu Linux 14.04.2 LTS \\\\\n            Software:         & GCC v4.8.4, Python v2.7.6, NumPy 1.8.2\\\\\n          \\end{tabular}\n      \\end{center}\n  \\end{footnotesize}\n  \\caption{System specifications}\n  \\label{tab:system_specs}\n\\end{table}\n\\fi\n\n\n\\subsubsection*{Theoretical Partition Cost}\n\nFig. \\ref{bench:unique_fuseprice} shows that theoretical partition\ncost (Def. \\ref{def:bh_partition_cost}) of the four different\npartition algorithms previously presented. Please note that the last\nfive benchmarks do not show an optimal solution. This is because the\nassociated search trees are too large for our branch-and-bound\nalgorithm to solve. For example, the search tree of the Lattice\nBoltzmann is $2^{664}$, which is simply too large even if the bound\ncan cut $99.999\\%$ of the search tree away.\n\nAs expected, we observe that the three algorithms that do fusion,\nLinear, Greedy, and Optimal, have a significant smaller cost than the\nnon-fusing algorithm Singleton. The difference between Linear and\nGreedy is significant in some of the benchmarks but the difference\nbetween greedy and optimal does almost not exist.\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px}, clip, width=\\linewidth]{benchmark/plots/unique_fuseprice.pdf}\n \\caption{Theoretical cost of the different partition algorithms. NB: the last five benchmarks, Lattice Boltzmann, NBody, NBody Nice, SOR, Water-Ice Simulation, do not show an optimal solution.}\n \\label{bench:unique_fuseprice}\n\\end{figure}\n\n\n\n\\subsubsection*{Practical Execution Time}\nIn order to evaluate the full picture, we do three execution time\nmeasurements: one with a warm fuse cache, one with a cold fuse cache,\nand one with no fuse cache. Fig. \\ref{bench:unique_warmcache} shows\nthe execution time when using a warm fuse cache thus we can compare the\ntheoretical partition cost with the practical execution time without the\noverhead of running the partition algorithm. Looking at\nFig. \\ref{bench:unique_fuseprice} and\nFig. \\ref{bench:unique_warmcache}, it is evident that our cost model,\nwhich is a measurement of unique array accesses\n(Def. \\ref{def:bh_partition_cost}), compares well to the practical\nexecution time result in this specific benchmark setup. However, there are\nsome outliers -- the Monte Carlo Pi benchmark has a theoretical\npartition cost of $1$ when using the Greedy and Optimal algorithm but\nhas a significantly greater practical execution time. This is because the\nexecution becomes computation bound rather than memory bound thus a\nfurther reduction in memory accesses does not improve performance.\nSimilarly, in the 27 Point Stencil benchmark the theoretical partition\ncost is identical for Linear, Greedy, and Optimal, but in practice\nOptimal is marginally better. This is an artifact of our cost model,\nwhich define the cost of reads and writes identically.\n\n\\ifdefined{}\nThe execution time measurements with the cold fuse cache and with the fuse cache completely disabled are in the supplemental material submitted with this paper.\n\\fi\nWith the cold fuse cache, the partition algorithm runs once in the first iteration of the computation. The results show that $20$ iterations, which most of the benchmarks uses, is enough to amortize the partition overhead\\ifdefined{}\n~(Fig.~\\ref{bench:unique_coldcache})\\fi. Whereas, if we run with no fuse cache, i.e.~we execute the partition algorithm in each iteration\\ifdefined{}~(Fig.~\\ref{bench:unique_nocache})\\fi, the Linear partition algorithm outperforms both the Greedy and Optimal algorithm because of its smaller time complexity.\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_filecache.pdf}\n \\caption{Execution time of the different partition algorithms using a \\textbf{warm cache}.}\n \\label{bench:unique_warmcache}\n\\end{figure}\n\n\n\n\\ifdefined{}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_memcache.pdf}\n \\caption{Execution time of the different partition algorithms using a \\textbf{cold cache}.}\n \\label{bench:unique_coldcache}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/unique_nocache.pdf}\n \\caption{Execution time of the different partition algorithms using \\textbf{no cache}.}\n \\label{bench:unique_nocache}\n\\end{figure}\n\n\\fi\n\n\\subsection{Alternative Cost Model}\n\\label{sec:alternative-cost}\nWith the theoretical and practical framework we are presenting in this\npaper, it is straightforward to explore the impact of alternative cost\nmodels. In this section, we will do exactly that -- replace our cost\nmodel with alternative cost models and evaluate the effect on the\nexecution time of the generated code.\n\nLet us define and evaluate three alternative cost models, \\emph{Max\n  Contract}, \\emph{Max Locality}, and \\emph{Robinson}, which are used\nin related literature~\\cite{Darte2002, Megiddo1997, Robinson2014}:\n\\begin{definition}\n\\label{def:tmpelem_partition_cost}\nThe cost model \\textbf{Max Contract} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "index": 21, "text": "\\begin{equation}\n    MaxContract(A, P) = |new[A]| - \\sum_{B\\in P} {\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}} new[B] \\cap del[B] {\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"MaxContract(A,P)=|new[A]|-\\sum_{B\\in P}{\\mathbin{\\scalebox{1.2}{|}}}new[B]\\cap&#10;del%&#10;[B]{\\mathbin{\\scalebox{1.2}{|}}}\" display=\"block\"><mrow><mrow><mi>M</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mi>C</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>n</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>w</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>A</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>-</mo><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow><mo>\u2061</mo><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>B</mi><mo>\u2208</mo><mi>P</mi></mrow></munder><mi>n</mi></mrow><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>w</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>\u2229</mo><mrow><mrow><mi>d</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>B</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nIn other words, this cost model penalizes each pair of array accesses\nnot fused with a cost of $1$.  NB: the cost is a pair-wise sum of all\nidentical array accesses. Thus, fusing four identical array accesses\nachieves a cost saving of $6$ rather than $4$.\n\\end{definition}\n\\begin{definition}\n\\label{def:robin_partition_cost}\nThe cost model \\textbf{Robinson} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "itemtype": "equation", "pos": 66255, "prevtext": "\nwhere $|new[A]|$ is the total number of allocated arrays. Thus, in this cost model, all arrays that are not contracted add $1$ to the cost.\n\\end{definition}\n\\begin{definition}\n\\label{def:reuse_partition_cost}\nThe cost model \\textbf{Max Locality} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "index": 23, "text": "\\begin{equation}\n    MaxLocality(A, P) = \\sum_{B\\in P}\\sum_{f\\in B}\\sum_{f'\\in (A\\setminus B)} {\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}} ext[f] \\cap io[f'] {\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"MaxLocality(A,P)=\\sum_{B\\in P}\\sum_{f\\in B}\\sum_{f^{\\prime}\\in(A\\setminus B)}{%&#10;\\mathbin{\\scalebox{1.2}{|}}}ext[f]\\cap io[f^{\\prime}]{\\mathbin{\\scalebox{1.2}{%&#10;|}}}\" display=\"block\"><mrow><mrow><mi>M</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mi>L</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>B</mi><mo>\u2208</mo><mi>P</mi></mrow></munder><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>f</mi><mo>\u2208</mo><mi>B</mi></mrow></munder><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow><mo>\u2061</mo><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msup><mi>f</mi><mo>\u2032</mo></msup><mo>\u2208</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>A</mi><mo>\u2216</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></munder><mi>e</mi></mrow><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>f</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>\u2229</mo><mrow><mrow><mi>i</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>f</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05400.tex", "nexttext": "\nwhere $N$ is the total number of accessed arrays.  In other words,\nthis cost model combines Max Locality, Max Contract, and penalizes the\nnumber of partition blocks (in that priority). Furthermore, the size\nof $N$ guaranties that Max Locality always attach more importance than\nMax Contract which in turn always attach more importance than the\nnumber of partition blocks.\n\\end{definition}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/all_naive_filecache.pdf}\n \\caption{Execution time of the different cost models using the \\textbf{Linear} partition algorithm and a \\textbf{warm cache}.}\n \\label{bench:all_naive_filecach}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/all_greedy_filecache.pdf}\n \\caption{Execution time of the different cost models using the \\textbf{Greedy} partition algorithm and a \\textbf{warm cache}.}\n \\label{bench:all_greedy_filecach}\n\\end{figure}\n\n\\begin{figure}\n \\centering\n \\includegraphics[trim={12px 10px 10px 0px},clip,width=\\linewidth]{benchmark/plots/all_optimal_filecache.pdf}\n \\caption{Execution time of the different cost models using the \\textbf{Optimal} partition algorithm and a \\textbf{warm cache}.}\n \\label{bench:all_optimal_filecach}\n\\end{figure}\n\nFig. \\ref{bench:all_naive_filecach}, \\ref{bench:all_greedy_filecach},\nand \\ref{bench:all_optimal_filecach} compares the execution time of the cost\nmodels using the Linear, Greedy, and Optimal partition algorithms\nrespectively. The execution time of the Linear algorithm is more or less\nidentical for all cost models.\n\nThe execution time of the Greedy algorithm shows some outliers -- in the Heat\nEquation and the SOR benchmark, the performance of Max Locality and\nRobinson is significantly worse than the other two.\n\nFinally, the execution time of the Optimal algorithm shows a case, Game of\nLife, where the Bohrium cost model performs better than the\nothers. Additionally, in the Heat Equation benchmark the performance\nof Max Locality is significantly worse than the other three.\n\nOverall, the practical performance of the four cost models is similar\nfor the benchmarks presented. However, there are some important\ndifferences between them:\n\nSince the objective of Max Contract is to maximize the number of array\ncontractions exclusively, there exist programs where Max Contract is\nthe only cost model that achieve this objective. With enough potential\ndata locality in a program, the other three cost models will utilize\nthis data locality at the expense of potential array\ncontractions. This was a strong motivation for Darte and\nHuard~\\cite{Darte2002} when they introduced an optimal solution to Max\nContract.\n\\ifdefined{}\nFig. \\ref{lst:alain_example} shows a program fragment from \\cite{Darte2002} where Max Locality fails to maximize the number of array contractions. However, in this specific program fragment, both Bohrium and Robinson obtain the same solution as Max Contract because their objective includes the maximization of the number of array contractions.\n\\fi\n\n\\newsavebox{\\LstAlainExampleA}\n\\begin{lrbox}{\\LstAlainExampleA}\n\\begin{lstlisting}[language=fortran, numbers=none, linewidth=105px, basicstyle=\\scriptsize]\nA(1:N)=E(0:N-1)\nB = A*2 + 3\nC = B + 99\nD(1:N)=A(N:1:-1) + A(1:N)\nE = B + C*D\nF = E*4 + 2\nG = E*8 - 3\nH(1:N)=F(1:N)+G(1:N)*E(2:N+1)\n\\end{lstlisting}\n\\end{lrbox}\n\n\\newsavebox{\\LstAlainExampleB}\n\\begin{lrbox}{\\LstAlainExampleB}\n\\begin{lstlisting}[language=fortran, numbers=none, linewidth=100px, basicstyle=\\scriptsize]\nDO I=1,N\n  A(I) = E(I-1)\nENDDO\nDO I=1,N\n  b = A(I)*2 + 3\n  c = b + 99\n  d = A(N-I+1) + A(I)\n  E(I) = b + c*d\n  F(I) = E(I)*4 + 2\n  G(I) = E(I)*8 - 3\nENDDO\nDO I=1,N\n  H(I) = F(I) + G(I)*E(I+1)\nENDDO\n\\end{lstlisting}\n\\end{lrbox}\n\n\\newsavebox{\\LstAlainExampleC}\n\\begin{lrbox}{\\LstAlainExampleC}\n\\begin{lstlisting}[language=fortran, numbers=none, linewidth=100px, basicstyle=\\scriptsize]\nDO I=1,N\n  A(I) = E(I-1)\nENDDO\nDO I=1,N\n  b = A(I)*2 + 3\n  c = b + 99\n  d = A(N-I+1) + A(I)\n  E(I) = b + c*d\nENDDO\nDO I=1,N\n  f = E(I)*4 + 2\n  g = E(I)*8 - 3\n  H(I) = f + g*E(I+1)\nENDDO\n\\end{lstlisting}\n\\end{lrbox}\n\n\\ifdefined{}\n\\begin{figure}\n    \\centering\n    \\subfloat[][]{\\usebox{\\LstAlainExampleA}}\\\\\n    \\subfloat[][]{\\usebox{\\LstAlainExampleB}}\\hspace{20px}\n    \\subfloat[][]{\\usebox{\\LstAlainExampleC}}\\hspace{20px}\n\\caption{A Fortran program fragment from \\cite{Darte2002}, which is based on \\cite{Megiddo1997,Gao93_array_contraction}. (a) is an array operation version, (b) is the loop version that Max Locality will generate, and (c) is the loop version that Bohrium, Max Contract, and Robinson will generate.}\n    \\label{lst:alain_example}\n\\end{figure}\n\\fi\n\n\\section{Future Work}\n\nThe cost models we present in this paper are abstract -- they do not\ntake the memory architecture of the execution hardware into account.\nSince the WSP formulation makes it easy to change the cost model, our\nfuture work is to develop cost models that, in detail, model\narchitectures such as NUMA CPU, GPU, Intel Xeon Phi, and distributed\nshared-memory machines.\n\nFurthermore, the only requirement to the cost model in the WSP\nformulation is that fusing two operations must be cost neutral or an\nadvantage. Thus, it is perfectly legal to have cost models that reward\nfusion of specific operation types e.g. rewarding fusion of multiply\nand addition instructions to utilize the FMA instruction set available\non recent Intel and AMD microprocessors.\n\n\n\\section{Conclusion}\n\nIn this paper, we introduce the \\emph{Weighted Subroutine Partition\nProblem} (WSP), which unifies program transformations for fusion of\nloops, array operations, and combinators.  Contrary to previous\nformulations of this problem, WSP incorporates the cost function into\nthe formulation, which makes WSP able to handle a wide range of\noptimization objects.  Furthermore, we show that the cost function\nmust be part of the formulation to enable optimization objects that\nminimize data locality correctly.\n\nWe prove that WSP is NP-hard and implement a branch-and-bound algorithm\nthat finds an optimal solution.  Out of 15 application benchmarks,\nthis branch-and-bound algorithm finds a solution for ten benchmarks\nwithin reasonable execution time.\n\nWe implement a greedy algorithm that finds a \\emph{good} solution to\nthe WSP problem, works with any cost function, and is fast enough for\nJust-In-Time compilation (20 iterations is typically enough to\namortize overhead).\n\nTo evaluate various WSP algorithms, we have incorporated the\nalgorithms into Bohrium.  The optimization objective is then to\nminimize data accesses through array contractions and data reuses\nwithin Just-In-Time compiled computation kernels.\n\nAs expected, our evaluation shows that minimizing data accesses have a\nsignificant performance impact.  The 15 application benchmarks\nwe evaluate in this paper experience a speedup ranging between 2 and\n30, compared to no optimization.\n\nHowever, our evaluation also shows that the various approaches to\napproximate or solve the WSP have only a marginal impact on the\noverall execution time of the benchmarks.  Out of 15, only one\nbenchmark performs significantly better using the optimal algorithm --\napproximately a speedup of 1.3 compared to the greedy algorithm.\nSimilarly, the impact of various optimization objects is also minimal.\nThis tells us that approximation algorithms will give us most\nof the savings, so more is won by making them faster than closer to optimal.\n\n\n\\bibliography{../literature}\n\n\\bibliographystyle{plain}\n\n", "itemtype": "equation", "pos": 66904, "prevtext": "\nIn other words, this cost model penalizes each pair of array accesses\nnot fused with a cost of $1$.  NB: the cost is a pair-wise sum of all\nidentical array accesses. Thus, fusing four identical array accesses\nachieves a cost saving of $6$ rather than $4$.\n\\end{definition}\n\\begin{definition}\n\\label{def:robin_partition_cost}\nThe cost model \\textbf{Robinson} defines the cost of a partition, $P$, of array operations, $A$, as follows:\n\n", "index": 25, "text": "\\begin{align}\n    Robinson(A, P) &= {\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}} P{\\mathbin{\\scalebox{1.2}{\\ensuremath{|}}}} \\notag\\\\\n                   &+ N \\cdot MaxContract(A,P)\\notag\\\\\n                   &+ N^2 \\cdot MaxLocality(A,P)\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle Robinson(A,P)\" display=\"inline\"><mrow><mi>R</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>b</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle={\\mathbin{\\scalebox{1.2}{|}}}P{\\mathbin{\\scalebox{1.2}{|}}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow><mo>\u2061</mo><mi>P</mi></mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\scalebox</mtext></merror><mn>1.2</mn><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+N\\cdot MaxContract(A,P)\" display=\"inline\"><mrow><mo>+</mo><mrow><mrow><mi>N</mi><mo>\u22c5</mo><mi>M</mi></mrow><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mi>C</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+N^{2}\\cdot MaxLocality(A,P)\" display=\"inline\"><mrow><mo>+</mo><mrow><mrow><msup><mi>N</mi><mn>2</mn></msup><mo>\u22c5</mo><mi>M</mi></mrow><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mi>L</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}]