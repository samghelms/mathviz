[{"file": "1601.05187.tex", "nexttext": "\nIntuitively, in case ${\\tt dom}(a)\\not\\rightarrowtail u$, \ninformation from ${\\tt dom}(a)$ is not permitted to flow to $u$, so the occurrence of the\naction $a$ causes no change  in the maximal information ${{\\tt {ta}}_{u}(\\alpha)}$ that\nmay be possessed by $u$ after $\\alpha$. \nHowever, if  ${\\tt dom}(a)\\rightarrowtail u$, then the occurrence \nof $a$ after $\\alpha$ causes the maximal information that agent $u$ is permitted to have to increase, \nby adding to its prior information   ${{\\tt {ta}}_{u}({\\alpha})}$ the maximal \ninformation ${{\\tt {ta}}_{{{\\tt dom}(a)}}(\\alpha)}$ that the agent performing $a$ is permitted to have after $\\alpha$, \nas well as the fact that the action $a$ has occurred. \nUsing the functions ${\\tt {ta}}_u$, we may \nnow declare a system to be secure, in the sense of complying with the information flow policy $\\rightarrowtail$, \nas follows: \n\n\\begin{definition} \nA system $M$ is TA-secure with respect to policy $\\rightarrowtail$, if\nfor all agents $u$ and $\\alpha, \\beta\\in {A}^*$, if \n${{\\tt {ta}}_{u}(\\alpha)} ={{\\tt {ta}}_{u}(\\beta)}$ then ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$. \n\\end{definition} \n\nIntuitively, this says that for all agents $u$, the observation ${\\tt obs}_u(s_0 \\cdot \\alpha) $\ncontains no more information than the maximal permitted information ${{\\tt {ta}}_{u}(\\alpha)}$. \n\n\nIn general, when considering the deductive capabilities of agents in computer security, it \nis appropriate to assume that an adversary will reason based not just on their\ncurrent observation, but also using their past observations. This \nsuggests that we should consider a \n\\emph{perfect recall} attacker. In the case of TA-security, \na definition stated using a perfect recall attacker is equivalent to \none stated using just the final observation of traces \\cite{Meyden15}. \nWe formulate this result in a more general \nway, so that it also applies to the other definitions we state in this paper. \n\nFirst, to capture a perfect recall attacker, we define the\n\\emph{view} of an agent $u$ inductively, by \n${\\tt view}_u(\\epsilon) = {\\tt obs}_u(s_0)$ and\n\n", "itemtype": "equation", "pos": 18117, "prevtext": "\n\\label{firstpage}\n\n\\iffac\n\\makecorrespond\n\\fi \n\n\\iffac \\else \n\\newenvironment{proof}{\\noindent {\\bf Proof:}}{{\\hfill{$\\Box$}}} \n\\newenvironment{proof*}{\\noindent {\\bf Proof:}}{} \n\\fi \n\n\\maketitle\n\n\n\n\\begin{abstract} \nThe paper studies dynamic information flow security policies \nin an automaton-based model. Two semantic\ninterpretations of such policies are developed, both of which \ngeneralize the notion of TA-security [van der Meyden ESORICS 2007] for static intransitive noninterference \npolicies. One of the interpretations focuses on information flows permitted by \npolicy edges, the other focuses on prohibitions implied by absence of policy edges. \nIn general, the two interpretations differ, \nbut necessary and sufficient conditions are identified \nfor the two interpretations to be equivalent. \nSound and complete proof techniques are developed for both interpretations. \nTwo applications of the theory are presented. The first is a general result \nshowing that access control  mechanisms are able to enforce a\ndynamic information flow policy. The second is a simple \ncapability system motivated by the Flume operating system. \n\\end{abstract} \n\n\\section{Introduction} \n\n\\label{sec:introduction}\n\nCovert channels, i.e., avenues for information flow unintended by the designers of a system, \npresent a significant risk for systems that are required to enforce confidentiality, since they \nconstitute vulnerabilities that an attacker may exploit in order to exfiltrate secrets. \nThis has motivated a body of research that aims to provide means\nby which systems can be assured to be free of covert channels. At the highest levels \nof assurance, one aims for formal verification based on rigorous models of the \nsystem. This requires formal definitions of what it means for a system to \ncomply with a policy that specifies the intended information \nflows, and prohibits the unintended information flows.\n\n\nHow to give a formal semantics to such policies that is suitable for formal verification \nhas been a topic of study since the 1970's \\cite{Cohen77}. \n\\emph{Noninterference policies} \\cite{Goguen1982} are a form of policy syntax\nin the form of a graph over a set of security levels, or domains, \nwith an edge representing that information is permitted to flow\nfrom the source of the edge to the destination. Conversely, absence \nof an edge can be understood as prohibiting (direct) information flow. \nIn the original formulation of such policies, corresponding to classical multi-level security policies \nbased on a lattice of security levels, the graph was transitive, but\nthere has more recently been a body of work on \\emph{intransitive noninterference} policies, \nwhich do not require transitivity. Here,  a domain is best understood as a component\nwithin a security architecture, with edges describing permitted direct flows of \ninformation, and paths corresponding to permitted indirect flows of information. In particular, this\nunderstanding underlies MILS security \\cite{BDRF08,Vanfleet2005}, an approach to high assurance systems\ndevelopment in which security architectures comprised of trusted and untrusted components\nare enforced using a variety of mechanisms including separation kernels. At its most abstract level, \nthe architecture can be understood as an intransitive noninterference policy. \nSeveral large-scale efforts \n\\cite{BytschkowQIR14,HeitmeyerALM06,Martin2000,Murray2012,Schellhorn2002} \nhave formally verified that intransitive noninterference policies hold in a number of \nseparation kernels.\n\nThe proper semantics of intransitive noninterference policies \nhas proved to be a subtle matter. Rushby \\cite{rushby92} \nimproved an initial proposal by Haigh and Young \\cite{HY87}, \ngiving semantics to policies by means of an \\emph{intransitive purge} function.\nVan der Meyden~\\cite{Meyden15} has recently argued that there is \na subtle weakness in \nthis intransitive purge based semantics. He provides an example that demonstrates that \nthis semantics may classify as secure a system that contains\nflows of information, based on the ordering of events, that seem\nto contradict an intuitive understanding of the policy.  He proposes an \nalternative, stronger, definition of security, \\emph{TA-security}, that correctly classifies this\nexample as insecure. Moreover, TA-security is shown to provide a better\nfit for Rushby's proof theory. Rushby shows that this proof theory is sound for \nhis definition, but fails to provide a completeness result. Van der Meyden explains this, \nby showing that it is both sound and complete for the stronger notion of TA-security. \nThis completeness result is obtained both for Rushby's unwinding proof method\nand for a variant of Rushby's results demonstrating that access control systems\nprovide a sound method for enforcement of intransitive noninterference policies. \n\n \nThis line of work has concerned static policies, in which the \npermitted flows of information do not change over time. \nSuch policies are too restrictive for many practical purposes: \nthe permitted flows of information in a system could change\nas a result of policy changes, system reconfiguration, \nin response to detection\nof vulnerabilities or attacks in progress, as a result of\npersonnel changes, promotions, revocations of privileges, \ndelegations, transfers of capabilities, \nand for many other reasons. \n\n\nA full understanding of the  formal underpinnings of security architecture should accommodate\nsuch dynamic policy changes, and it is therefore of interest to \nhave a satisfactory theory of dynamic intransitive noninterference \npolicies. To date, only a few works have studied this question: Leslie\n\\cite{Leslie2006} and Eggert et. al.~\\cite{Eggert2013}. Both are based on \ngeneralizations of  Rushby's ``intransitive purge\" operator and, in the case of static \npolicies, are equivalent to Rushby's semantics. \nConsequently, these works are subject to the weakness of this semantics \nidentified by van der Meyden. \nIn particular, they misclassify van der Meyden's example.\nLeslie provides an unwinding proof theory for her definition that is  equivalent to\nRushby's unwinding in the static case, hence is incomplete. Eggert et. al. do  \nprovide a complete proof theory and a complexity characterization for their definition. \n\n\n\nOur main contribution in this paper is to develop alternate semantics for dynamic \nintransitive noninterference policies that generalize the more adequate notion of \nTA-security in the static case. Indeed, we show (in Section~\\ref{sec:knowledgebased}) that there are several candidates for\nsuch a semantics since, in the dynamic setting, it turns out that the  information \nflows permitted by policy edges are not always the complement of the information flows\nprohibited by the absence of policy edges. This leads to two distinct\nsemantics, one of which prioritizes the permissions and the other of\nwhich prioritizes the prohibitions. A further complexity to policy in the dynamic setting \nis the question of what knowledge the agents in the system are permitted\nto have of the state of the policy itself. However, this consideration is\nalso helpful: we show that \\emph{locality}, a natural condition on agent knowledge of the policy, \nprovides \nnecessary and sufficient conditions\nfor the permissive and the prohibitive interpretations of\nthe policy to be equivalent. \nReference to agent knowledge also enables us to  \ncharacterize precisely the maximal information permitted to be known to each agent\nin the system at moment of time, in terms of a concrete representation of the \ninformation that may have been transmitted to the agent. \nWe show \nby some examples \nthat our definitions improve on those of Leslie \n\\cite{Leslie2006} and Eggert et. al.~\\cite{Eggert2013},\nnot just in the treatment of static policies (van der Meyden's example justifying \nTA-security), but also in the classification of some simple dynamic policies. \n\n\nWe then (in Section~\\ref{sec:prooftechniques}) develop proof methods that \nmay be used to show that a system is secure, \nwith a focus on local policies, so that the technique applies\nto both of our definitions of security. We first  generalize the \nclassical \\emph{unwinding} proof method \\cite{goguen84} to our new definitions. \nThis is used  (in Section~\\ref{sec:accesscontrolinterpretation}) to generalize,  \nto a dynamic setting, Rushby's \\cite{rushby92} results \non enforcement of a static intransitive noninterference policy by means of \naccess control settings. \nIn both cases, we demonstrate not \njust soundness but also completeness of the proof method.\n\n\nAs an \napplication of the theory, we establish \n(in Section~\\ref{sec:flume})\nsecurity for \na capability system, motivated by  the Flume operating system \\cite{Krohn2009}. \nWe show that the capability system enforces a naturally \n associated dynamic intransitive noninterference policy. \nThis result gives an illustration of how the general theory \ncan be applied to a concrete system. \n\n\n\\section{Basic Definitions} \n\n\\label{sec:definitions}\n\nIn this section we give the basic definitions concerning the \nsystems model about which we will make security judgements, \nand introduce the syntax of  dynamic intransitive noninterference policies. \nThe following section develops several semantics for these  policies in this systems model. \n\n\\subsection{Systems} \n\nWe model systems as deterministic automata in which the actions of multiple agents \ncause state transitions. Agents obtain information about\nthe state of system, and each other's actions, by making observations of the state of the system. \n\nA \\emph{signature}  is a tuple ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$, \nwhere ${D}$ is a finite set of \\emph{domains}, (which we may also refer to  as \\emph{agents}), \n ${A}$ is a finite set of \\emph{actions}, and ${\\tt dom}\\colon {A} \\rightarrow {D}$, \n assigns each action to a domain (agent). Intuitively,  ${\\tt dom}(a)$ is the domain within \nwhich the action $a$ is performed (the agent performing that action). \nWe write ${A}^*$ for the set of finite sequences of elements of the set $A$ and\ndenote the empty sequence by $\\epsilon$. \n\n\n\n\nAn {\\em automaton} \nfor a signature ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$\nis a tuple ${\\langle {S, s_0, \\rightarrow} \\rangle}$, where $S$ is a set of states (not necessarily finite), $s_0\\in S$ is\nthe \\emph{initial state}, and ${\\rightarrow} \\subseteq S\\times A\\times S$  is a labelled transition relation. \nThis relation is required to be {\\em input-enabled}, \nin the  sense that for all states $s\\in S$ and actions $a\\in A$, \nthere exists  $t\\in S$ such that $(s,a,t) \\in {\\rightarrow}$. We also assume\nthat the relation is deterministic in the sense that if $(s,a,t)\\in {\\rightarrow}$ and $(s,a,t') \\in {\\rightarrow}$\nthen $t = t'$. Under these assumptions, we may write $s\\cdot a$ for the unique $t$ such that \n$(s,a,t) \\in {\\rightarrow}$. \n\nWe make several uses of the general notion of automaton. One is the \nmachine model that we analyze for security. \nFormally, a \\emph{system} for a signature ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$\nis an automaton ${\\langle {S, s_0, \\rightarrow} \\rangle}$ for the signature, together with \nan observation function ${\\tt obs}\\colon {D} \\times S \\rightarrow O$.  \nIntuitively, ${\\tt obs}(u,s)$ is the observation \nmade in domain $u$ (by agent $u$) when the system is in state $s$. \nSince the domain $u$ will typically be fixed in a context of application, \nbut the state $s$ will vary, we write ${\\tt obs}_u(s)$ for ${\\tt obs}(u,s)$. \nWe write systems in the form \n$M = {\\langle {S, s_0, \\rightarrow, {D}, {\\tt dom}, {A}, {\\tt obs}} \\rangle}$\nwhen we wish to make all the relevant components explicit. \n\n\nThe assumption that the transition relation is input-enabled has often been made in the \nliterature.  It prevents enablement of actions being a source of information flow, and \nintuitively represents that it is always possible for an agent to attempt to perform an action \n(even if it would have no actual effect). \nA situation $s$ where an agent is not able to successfully perform an action can be represented \nin an input-enabled model by means of a transition $(s,a,s)$ that leaves the state unchanged. If\nit is desired to model that the agent is able to observe that the action is not enabled, \nthis can be encoded in the observation that the agent makes in either the source or destination state of the \ntransition. (This  leaves the modelling of the way that enablement of actions becomes known to agents\nin the hands of the system modeller, as opposed to many process algebraic semantics, e.g., \nthose using bisimulation, that would mandate that enablement of actions is always observable.) \n\nThe restriction to deterministic systems is made in part because the theory of \nintransitive noninterference is better understood in deterministic systems \\cite{rushby92,Meyden15}\nthan in nondeterministic systems \\cite{Engelhardt2012}. However, in many cases, \nnondeterminism can be represented in deterministic systems by using\nadditional agents to model the source of nondeterminism. (This does \nrequire that such additional agents be included in the policy as well as in the systems model, but\nthat can be argued to add clarity to the meaning of the policy.)  \n\n\nA \\emph{run} of a system is a sequence $s_0 a_1 s_1 \\ldots a_n s_n$, where $n \\geq 0$ and \nthe $s_i \\in S$ are states (with $s_0$ the initial state of the system) and the $a_i\\in {A}$ are actions, such that for $i=1 \\ldots n$ we \nhave $s_i = s_{i-1} \\cdot a$. We call the sequence $\\alpha =a_1 \\ldots a_n\\in {A}^*$ the \\emph{trace} of the run.  \nConversely, since the system is input-enabled and deterministic, every sequence $\\alpha \\in {A}^*$ \nis the trace of a unique run. We may therefore refer to runs by their corresponding traces. \nFor a sequence $\\alpha = a_1 \\ldots a_n \\in {A}^*$ and a state $s\\in S$, \nwe write $s \\cdot \\alpha$ for the state reached after executing the sequence of actions $\\alpha$ starting at $s$, \ni.e., the state $t_n$, obtained inductively by taking  $t_0 = s$ and \n$t_i = t_{i-1} \\cdot a_i$, for $i =1\\ldots n$. \n\n\nTwo systems $M = {\\langle {S, s_o, \\rightarrow, {\\tt obs}} \\rangle}$ and  $M = {\\langle {S', s_0', \\rightarrow', {\\tt obs}'} \\rangle}$ for the same signature $\\langle{D}, {\\tt dom},{A}\\rangle$ \nare \\emph{bisimilar} if for all $u \\in {D}$ and $\\alpha\\in {A}^*$, we have ${\\tt obs}_u(s_0\\cdot \\alpha) = {\\tt obs}'_u(s_0'\\cdot \\alpha)$. \n(We remark that we do not need the usual relational definition of bisimilarity because our systems are deterministic.) \nIt is easily checked that all the definitions of security that  follow are preserved under bisimilarity.\n\n\nThe \\emph{unfolding} of a system $M$ for signature $\\langle {D}, {\\tt dom}, {A}\\rangle$ is defined to be the system \n${\\mathit{unfold}}(M)$ for the same signature, \nwith states $A^*$, initial state $\\epsilon$, \ntransition relation such that $\\alpha \\cdot a = \\alpha a$ for all $\\alpha \\in A^*$ and $a\\in A$, \nand observation functions ${\\tt obs}_u(\\alpha) = {\\tt obs}^M_u(s_0\\cdot \\alpha)$.  \nThe system ${\\mathit{unfold}}(M)$  is easily seen to be bisimilar to~$M$, \nso ${\\mathit{unfold}}(M)$ can be thought of as an \nequivalent implementation of the system $M$. \n\n\n\\subsection{Static Policies} \\label{sec:static-policies}\n\nA {\\em static policy} describes the permitted and prohibited flows of information between domains. \nFormally, a static policy for the signature ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$ \n is a reflexive binary relation  $\\rightarrowtail$ (possibly intransitive) on the set of domains ${D}$.\nIntuitively, $u \\rightarrowtail v$ means that information is permitted to flow from domain $u$ to domain \n$v$, and conversely, $u \\not\\rightarrowtail v$ means that information flows from domain $u$ to domain $v$ are\nprohibited.  \n\nPolicies are assumed to be reflexive because, intuitively, nothing can be done to prevent \ninformation flowing from a domain to itself, so this is allowed by default. \nSince $\\rightarrowtail$ can be taken to be the edge set of a directed graph with vertex set D, we may use terminology from graph theory \nwhen we describe properties of a policy. For example, we may call $ u \\rightarrowtail v$  an ``edge'' of the policy $\\rightarrowtail$, \nand talk about ``paths\" in the relation~$\\rightarrowtail$. \n\nWe remark that the system model introduced above appears to lack a notion of \ninternal (silent) transitions, but these can be  \nhandled by adding a systems domain $Sys$, such that each internal transition \ncorresponds to some action of domain $Sys$. This representation also requires\nadding an edge $Sys \\rightarrowtail u$ to the policy for all other domains $u$.  \n\nA significant body of work already exists in relation to static policies, e.g., \\cite{Goguen1982,rushby92,Meyden15,Roscoe1999}. \nSince our focus in this paper is to find semantics for dynamic policies that generalizes the semantics of van der Meyden \\cite{Meyden15} \nfor static intransitive noninterference policies, we reiterate here just that semantics in order to motivate what follows, and refer the reader to \nthe literature for more detailed discussion. The semantics involves for each agent $u$ a function \n${\\tt {ta}}_u$ from the set of traces, such that for a trace $\\alpha$, the value \n${\\tt {ta}}_u(\\alpha)$ intuitively represents a concrete encoding of the maximal \namount of information that the agent is permitted to have about $\\alpha$. \nThe function ${\\tt {ta}}_u$ transforms a trace $\\alpha$ into a binary tree, which contains less information about the order of the actions than the trace does. \nThis \nfunction is defined inductively by\n\\footnote{\nNote that the functions ${\\tt {ta}}_u$ depend on the policy $\\rightarrowtail$, but \nto avoid clutter,  this is suppressed in the notation, here and for similar\ndefinitions later in the paper.   We may add the policy to the notation in contexts containing several policies, \ne.g., by writing ${\\tt {ta}}^{\\rightarrowtail}_u(\\alpha)$ when the policy used is $\\rightarrowtail$.}\n\n${{\\tt {ta}}_{u}(\\epsilon)}  = \\epsilon$ and for every $\\alpha \\in {A}^*$ and $a \\in {A}$ by\n\n", "index": 1, "text": "\\begin{align*}\n {{\\tt {ta}}_{u}({\\alpha a})} & =\n \\begin{cases}\n  ({{\\tt {ta}}_{u}({\\alpha})}, {{\\tt {ta}}_{{{\\tt dom}(a)}}(\\alpha)}, a) & \\text{if } {{\\tt dom}(a) \\rightarrowtail u}\\\\\n  {{\\tt {ta}}_{u}({\\alpha})} & \\text{otherwise} \n  \\enspace. \n \\end{cases}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt{ta}}_{u}({\\alpha a})}\" display=\"inline\"><mrow><msub><mi>\ud835\ude9d\ud835\ude8a</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}({{\\tt{ta}}_{u}({\\alpha})},{{\\tt{ta}}_{{{\\tt dom}(a%&#10;)}}(\\alpha)},a)&amp;\\text{if }{{\\tt dom}(a)\\rightarrowtail u}\\\\&#10;{{\\tt{ta}}_{u}({\\alpha})}&amp;\\text{otherwise}\\@math@espace.\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\ude9d\ud835\ude8a</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mi>\ud835\ude9d\ud835\ude8a</mi><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21a3</mo><mi>u</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><msub><mi>\ud835\ude9d\ud835\ude8a</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>otherwise</mtext><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\@math@espace</span></mtext></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nwhere every $\\alpha \\in {A}^*$ and $a \\in {A}$. \nHere, $\\sigma \\circ x$ denotes the absorptive concatenation of an element $x$ of a set  $X$ to a string whose final element is in $X$, defined\nby $\\epsilon x = x$, and $\\sigma y\\circ x = \\sigma y x$ if $x\\neq y$ and $\\sigma y\\circ x = \\sigma y$ if $y = x$. \nThe reason we apply this type of concatenation is to capture the asynchronous behaviour of the system, \nwhere agents do not necessarily have access to a global clock. \nIntuitively, agent $u$ is aware of its own actions, so these are always available in its perfect recall \nview. This is captured by the first clause of the definition of ${\\tt view}_u$. However, when another agent performs an action, this may or may not\ncause a change in $u$'s observation. If it does, then $u$ detects the change, and the new observation is added to its view. \nHowever, if there is no change of observation, then there is no change to the view, since the agent is assumed to operate asynchronously, \nso that it does not know for what length of time it makes each observation.\n\n\nConsider an indexed collection of functions $f= \\{f_u\\}_{u \\in {D}}$, \neach with domain ${A}^*$, and defined \nby $f_u(\\epsilon) = \\epsilon$ and \n\n", "itemtype": "equation", "pos": 20498, "prevtext": "\nIntuitively, in case ${\\tt dom}(a)\\not\\rightarrowtail u$, \ninformation from ${\\tt dom}(a)$ is not permitted to flow to $u$, so the occurrence of the\naction $a$ causes no change  in the maximal information ${{\\tt {ta}}_{u}(\\alpha)}$ that\nmay be possessed by $u$ after $\\alpha$. \nHowever, if  ${\\tt dom}(a)\\rightarrowtail u$, then the occurrence \nof $a$ after $\\alpha$ causes the maximal information that agent $u$ is permitted to have to increase, \nby adding to its prior information   ${{\\tt {ta}}_{u}({\\alpha})}$ the maximal \ninformation ${{\\tt {ta}}_{{{\\tt dom}(a)}}(\\alpha)}$ that the agent performing $a$ is permitted to have after $\\alpha$, \nas well as the fact that the action $a$ has occurred. \nUsing the functions ${\\tt {ta}}_u$, we may \nnow declare a system to be secure, in the sense of complying with the information flow policy $\\rightarrowtail$, \nas follows: \n\n\\begin{definition} \nA system $M$ is TA-secure with respect to policy $\\rightarrowtail$, if\nfor all agents $u$ and $\\alpha, \\beta\\in {A}^*$, if \n${{\\tt {ta}}_{u}(\\alpha)} ={{\\tt {ta}}_{u}(\\beta)}$ then ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$. \n\\end{definition} \n\nIntuitively, this says that for all agents $u$, the observation ${\\tt obs}_u(s_0 \\cdot \\alpha) $\ncontains no more information than the maximal permitted information ${{\\tt {ta}}_{u}(\\alpha)}$. \n\n\nIn general, when considering the deductive capabilities of agents in computer security, it \nis appropriate to assume that an adversary will reason based not just on their\ncurrent observation, but also using their past observations. This \nsuggests that we should consider a \n\\emph{perfect recall} attacker. In the case of TA-security, \na definition stated using a perfect recall attacker is equivalent to \none stated using just the final observation of traces \\cite{Meyden15}. \nWe formulate this result in a more general \nway, so that it also applies to the other definitions we state in this paper. \n\nFirst, to capture a perfect recall attacker, we define the\n\\emph{view} of an agent $u$ inductively, by \n${\\tt view}_u(\\epsilon) = {\\tt obs}_u(s_0)$ and\n\n", "index": 3, "text": "\\begin{align*}\n {\\tt view}_u(\\alpha a)& = \n \\begin{cases}\n   {\\tt view}_u(\\alpha) \\; a \\; {\\tt obs}_u(s_0 \\cdot \\alpha a) & \\text{if } {\\tt dom}(a) = u \\\\\n   {\\tt view}_u(\\alpha) \\circ {\\tt obs}_u(s_0 \\cdot \\alpha a) & \\text{otherwise}\n \\end{cases}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\tt view}_{u}(\\alpha a)\" display=\"inline\"><mrow><msub><mi>\ud835\ude9f\ud835\ude92\ud835\ude8e\ud835\udea0</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}{\\tt view}_{u}(\\alpha)\\;a\\;{\\tt obs}_{u}(s_{0}\\cdot%&#10;\\alpha a)&amp;\\text{if }{\\tt dom}(a)=u\\\\&#10;{\\tt view}_{u}(\\alpha)\\circ{\\tt obs}_{u}(s_{0}\\cdot\\alpha a)&amp;\\text{otherwise}%&#10;\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><msub><mi>\ud835\ude9f\ud835\ude92\ud835\ude8e\ud835\udea0</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo rspace=\"5.3pt\" stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mpadded width=\"+2.8pt\"><mi>a</mi></mpadded><mo>\u2062</mo><msub><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mi>\u03b1</mi></mrow><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>u</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><msub><mi>\ud835\ude9f\ud835\ude92\ud835\ude8e\ud835\udea0</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2218</mo><msub><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c</mi><mi>u</mi></msub></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mi>\u03b1</mi></mrow><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nfor some boolean condition $C$ and function $g$,  \nwhere $\\alpha \\in {A}^*$, $a\\in {A}$ and $u \\in {D}$. \nNote that the collection ${\\tt {ta}}$ is in this pattern, with $g(\\alpha,a, u) = (f_{{\\tt dom}(a)}(\\alpha),a)$ and $C(\\alpha, a, u) = {\\tt dom}(a) \\rightarrowtail u$. \nWe say that $f$ is \\emph{self-aware} if ${\\tt dom}(a) = u$ implies $C(\\alpha,a,  u)$, \nand $g(\\alpha, a, u) = g(\\beta, b,u)$ implies $a=b$. Intuitively, in the self-aware case, \n$f_u(\\alpha)$ encodes at least a record of all the actions of domain $u$ that occur in $\\alpha$. \n\nSay that a system is \\emph{$f$-secure}  \nif for all $\\alpha, \\beta \\in {A}^*$ with $f_u(\\alpha) = f_u(\\beta)$, we have ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$. \nAn alternative  definition with the ${\\tt view}$ function instead of ${\\tt obs}$ is: \na system is \\emph{$f$-view-secure} \nif for all $\\alpha, \\beta \\in {A}^*$ with $f_u(\\alpha) = f_u(\\beta)$, we have ${\\tt view}_u(\\alpha) = {\\tt view}_u(\\beta)$. \nThese definitions are equivalent, subject to self-awareness of $f$: \n\n\\begin{lemma}\n\\label{lem:obs-view} \nSuppose that $f$ is self-aware. Then a system $M$ is $f$-secure \niff it is $f$-view-secure. \n\\end{lemma}\n\n\\begin{proof}\n Assume first that $M$ is not $f$-view-secure. \n Then there are $u \\in {D}$ and $\\alpha, \\beta \\in {A}^*$ of minimal combined length with $f_u(\\alpha) = f_u(\\beta)$ and ${\\tt view}_u(\\alpha) \\neq {\\tt view}_u(\\beta)$. \n At least one of $\\alpha$ and $\\beta$ is not the empty trace, suppose that it is $\\alpha$ and let $\\alpha = \\alpha' a$ for some $\\alpha' \\in {A}^*$ and $a \\in {A}$. \n Then there are two cases:\n \\begin{itemize}\n  \\item \\emph{Case 1:} $f_u(\\alpha' a) = f_u(\\alpha')$. \n  Then $f_u(\\alpha') = f_u(\\beta)$, so \n  from the minimality of $\\alpha$ and $\\beta$ it follows that ${\\tt view}_u(\\alpha') = {\\tt view}_u(\\beta)$ and hence ${\\tt view}_u(\\alpha') \\neq {\\tt view}_u(\\alpha' a)$. \n  Since \n   $C(\\alpha, a,u)$ is false, we have by self-awareness that \n  ${\\tt dom}(a) \\neq u$, so ${\\tt view}_u(\\alpha' a) = {\\tt view}_u(\\alpha') {\\tt obs}_u(s_0 \\cdot \\alpha'a)$. \n  Therefore, we have ${\\tt obs}_u(s_0 \\cdot \\alpha' a) \\neq {\\tt obs}_u(s_0 \\cdot \\beta)$. \n  \\item \\emph{Case 2:} $f_u(\\alpha' a) \\neq f_u(\\alpha')$. \n  We can assume that $\\beta = \\beta'b$ for some $\\beta' \\in {A}^*$ and $b \\in {A}$ with $f_u(\\beta' b) \\neq f_u(\\beta')$ since otherwise, we proceed with the first case with the roles of $\\alpha$ and $\\beta$ swapped. \n  From the inductive definition of $f_u$ \n  and self-awareness, it\n  follows that $a = b$ and $f_u(\\alpha') = f_u(\\beta')$. \n  By the minimality of $\\alpha$ and $\\beta$, we have \n${\\tt view}_u(\\alpha') = {\\tt view}_u(\\beta')$. There are two cases of the definitions of ${\\tt view}_u(\\alpha' a)$ and ${\\tt view}_u(\\beta' a)$, \ndepending on whether ${\\tt dom}(a) = u$, but in either case, it follows that \n${\\tt obs}_u(s_0 \\cdot \\alpha'a) \\neq {\\tt obs}_u(s_0 \\cdot \\beta' b)$, since the \nonly difference in these sequences can be in the final observation. \n\\end{itemize}\nThe other direction of the proof follows directly from the definition of the ${\\tt view}$ function. \n\\end{proof}\n\n\nSince the definition of $f={\\tt {ta}}$ is easily seen to be self-aware (using reflexivity of the policy), it follows from Lemma~\\ref{lem:obs-view} \nthat TA-security and ${\\tt {ta}}$-view-security are equivalent. \n\n\n\n\n\n\\subsection{Dynamic Policies} \n\n\nOur main concern in this paper is with \\emph{dynamic intransitive information flow policies}, \nwhich generalize static policies by allowing the edges of the policy to depend \non the actions that have been performed in the system. Formally,\na \\emph{dynamic policy} is a relation ${\\rightarrowtail} \\subseteq {{D} \\times A^* \\times {D}}$, \nsuch that ${(u, \\alpha, u)} \\in {\\rightarrowtail}$ for all $\\alpha \\in {A}^*$ and all $u \\in {D}$. \nWe write $\\alpha \\models u \\rightarrowtail v$ when $(u, \\alpha ,v)\\in {\\rightarrowtail}$. \nIntuitively,   $\\alpha \\models {u \\rightarrowtail v}$ says that, after the sequence of actions\n$\\alpha$ have been performed, information may flow from domain $u$ to domain $v$. \nThus, $\\rightarrowtail_\\alpha = \\{(u,v) \\mid (u,\\alpha, v) \\in {\\rightarrowtail} \\}$ is the (static) policy that applies after the actions $\\alpha$  have been performed. \n\nDynamic policies can be represented using \nautomata.  We say that a tuple ${\\langle {P,\\rightarrowtail'} \\rangle}$\nconsisting of an automaton $P = {\\langle {S,s_0, \\rightarrow} \\rangle}$ and\na relation  ${\\rightarrowtail'} \\subseteq {D} \\times S\\times {D}$ \n\\emph{represents} a dynamic policy  $\\rightarrowtail$, if for all \n$\\alpha \\in {A}^*$, domains $u,v, \\in {D}$, and state $s \\in  {S}$ with $s = s_0 \\cdot \\alpha$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ iff \n$(u, s, v) \\in {\\rightarrowtail'}$.  \n(In this case we also write $s \\models {u \\rightarrowtail' v}$.) \nEvery dynamic policy has such a representation (with an infinite number of states), since we\nmay take $S= {A}^*$ and ${\\rightarrow} = \\{(\\alpha, a, \\alpha a)~|~\\alpha\\in {A}^*, a\\in {A}\\}$. \nWe may call the policy \\emph{finite state} if it has a representation with $S$ finite. \n\nLet $\\langle {D}, {\\tt dom}, {A}\\rangle$ be a signature.  \nA \\emph{policy enhanced system} for this signature is an automaton ${\\mathcal{A}}={\\langle {S, s_0, \\rightarrow} \\rangle}$  that is equipped with \na relation ${\\rightarrowtail} \\subseteq {{D} \\times S\\times {D}}$  and an observation function ${\\tt obs}$ with domain ${D} \\times S$.\nGiven a system $M$ and a dynamic policy $ \\rightarrowtail'$ for the signature, \nwe say that the policy enhanced system ${\\langle {{\\mathcal{A}}, \\rightarrowtail, {\\tt obs}} \\rangle}$ \\emph{encodes} $M$ and $\\rightarrowtail'$ if \n${\\langle {{\\mathcal{A}},{\\tt obs}} \\rangle}$ is bisimilar to $M$ and ${\\langle {{\\mathcal{A}},\\rightarrowtail} \\rangle}$ represents $\\rightarrowtail'$.\n\nFor every pair consisting of a system $M$ and a dynamic policy $\\rightarrowtail$ for the same signature, we can construct a policy enhanced system\nthat encodes $M$ and $\\rightarrowtail$. \nGiven an automaton representation ${\\langle {{\\mathcal{A}}_P,\\rightarrowtail'} \\rangle}$ of  $\\rightarrowtail$ \nwhere ${\\mathcal{A}}_P = {\\langle {S^P, s^P_0, \\rightarrow^P} \\rangle}$,  \nand  a system $M \\hspace{-2pt}= \\hspace{-2pt} {\\langle {{\\mathcal{A}}_M,{\\tt obs}^M} \\rangle}$  where ${\\mathcal{A}}_M = {\\langle {S^M, s^M_0, \\rightarrow^M} \\rangle}$ for the same signature, \nwe define the product automaton \n$A_M \\times {\\mathcal{A}}_P\n={\\langle {S, s_0, \\rightarrow} \\rangle}$, \nwhere $S = S^M \\times   S^P$, $s_0 = (s^M_0, s_0^P)$\nand $((s, p), a, (s',p')) \\in  {\\rightarrow}$  iff $(s,a,s') \\in {\\rightarrow^M}$ and $(p,a,p') \\in {\\rightarrow^P}$. \nThe automaton \n${\\mathcal{A}}_M \\times {\\mathcal{A}}_P$ \nmay be equipped with an observation function ${\\tt obs}$ with domain \n$S$  and a policy  relation ${\\rightarrowtail''} \\subseteq {D} \\times S\\times {D}$ \nby defining ${\\tt obs}(u, (s,p)) = {\\tt obs}^M(u,s)$ and ${\\rightarrowtail''} = \\{(u,(s,p),v)~|~u \\rightarrowtail_p v\\}$. \nIt is then straightforward to show that the policy enhanced system ${\\langle { {\\mathcal{A}}_M \\times {\\mathcal{A}}_P, {\\tt obs}, \\rightarrowtail''} \\rangle}$\nencodes $M$ and $\\rightarrowtail$. \n\nIt will often be convenient, in presenting examples, \nto use a diagram  of a policy enhanced system in order to present the policy and the system \ntogether as a single automaton.  Figure~\\ref{fig:conflict} gives an example of this presentation. \nWe note the following conventions to be applied in interpreting these diagrams. \nThe systems represented are input-enabled, but we elide self loops \ncorresponding to edges of the form $(s,a,s)$ in order to reduce clutter. \nStates are partitioned into three components. The top component gives the \nname of the state. The middle component depicts the static policy applicable at that \nstate. The bottom component gives partial information about the observations that the \nagents make at the state: typically, only one agent's information is relevant to the discussion, \nand we elide the observations of the other agents in the system. \n\n\nThere is a natural order on policies. \nConsider the binary relation $\\leq$ on policies with respect to a given signature $\\langle{D}, {\\tt dom}, {A}\\rangle$, \ndefined by ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ iff for all $\\alpha \\in A^*$ and $u,v\\in {D}$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ implies $\\alpha \\models {u \\rightarrowtail' v}$. \nIt is easily seen that this relation partially orders the policies with respect to the signature. \nIntuitively, if ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ then $\\rightarrowtail$ places more\nrestrictions on the flow of information in a system than does $\\rightarrowtail'$. \nThis  intuition can be supported for both a permissive and a prohibitive reading\nof policies. On a permissive reading, ${\\rightarrowtail} \\leq {\\rightarrowtail'}$\n intuitively says that every situation in which a flow of information is explicitly \n permitted by $\\rightarrowtail$ is one where the flow of information is explicitly \n permitted by $\\rightarrowtail'$. Thus, $\\rightarrowtail$ is more restrictive than $\\rightarrowtail'$ in the sense of \n having fewer explicitly permitted flows of information. \nOn a prohibitive reading,  ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ says (contrapositively) that \n every situation where $\\rightarrowtail'$ explicitly prohibits a flow of information is\n one where $\\rightarrowtail$ also explicitly prohibits that flow of information. \n Thus, $\\rightarrowtail$ is more restrictive than $\\rightarrowtail'$ in the sense of \n having more explicitly prohibited flows of information. \nWe may therefore gloss ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ \nas stating that $\\rightarrowtail$ is \\emph{more restrictive} than $\\rightarrowtail'$. \n\n\n\n\n\\subsection{Logic of Knowledge} \n\nIt will be convenient to formulate some of our definitions using formulas \nfrom a logic of knowledge. Given a signature ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$, \nwe work with formulas $\\phi$ expressed using the following \ngrammar: \n\n", "itemtype": "equation", "pos": 21975, "prevtext": "\nwhere every $\\alpha \\in {A}^*$ and $a \\in {A}$. \nHere, $\\sigma \\circ x$ denotes the absorptive concatenation of an element $x$ of a set  $X$ to a string whose final element is in $X$, defined\nby $\\epsilon x = x$, and $\\sigma y\\circ x = \\sigma y x$ if $x\\neq y$ and $\\sigma y\\circ x = \\sigma y$ if $y = x$. \nThe reason we apply this type of concatenation is to capture the asynchronous behaviour of the system, \nwhere agents do not necessarily have access to a global clock. \nIntuitively, agent $u$ is aware of its own actions, so these are always available in its perfect recall \nview. This is captured by the first clause of the definition of ${\\tt view}_u$. However, when another agent performs an action, this may or may not\ncause a change in $u$'s observation. If it does, then $u$ detects the change, and the new observation is added to its view. \nHowever, if there is no change of observation, then there is no change to the view, since the agent is assumed to operate asynchronously, \nso that it does not know for what length of time it makes each observation.\n\n\nConsider an indexed collection of functions $f= \\{f_u\\}_{u \\in {D}}$, \neach with domain ${A}^*$, and defined \nby $f_u(\\epsilon) = \\epsilon$ and \n\n", "index": 5, "text": "\\begin{align*}\n f_u(\\alpha a) &= \n \\begin{cases}\n\t(f_u(\\alpha), g(\\alpha,a,u))& \\text{if } \n\t C(\\alpha, a, u) \\\\ \n\tf_u(\\alpha) & \\text{otherwise}\n \\end{cases}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle f_{u}(\\alpha a)\" display=\"inline\"><mrow><msub><mi>f</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}(f_{u}(\\alpha),g(\\alpha,a,u))&amp;\\text{if }C(\\alpha,a,%&#10;u)\\\\&#10;f_{u}(\\alpha)&amp;\\text{otherwise}\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><msub><mi>f</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": " \nwhere $u,v \\in {D}$ are domains and $G \\subseteq {D}$ is a set of domains. \nIntuitively, the atomic propositions of the logic are assertions of the form\n$u\\rightarrowtail v$ concerning the static policy holding at a particular point of time. \nWe write ${\\mathit{Prop}}$ for the set of atomic propositions. \nThe logic contains the usual boolean operators for conjunction and negation, \nand we freely use other boolean operators that can be defined using these, \ne.g., we write $\\phi {\\Rightarrow}\\psi$ for $\\neg (\\phi \\land \\neg \\psi)$.  \nThe formula $K_u \\phi$ intuitively says that domain $u$ \\emph{knows} that $\\phi$ \nholds,  and $D_G \\phi$ says that it is \\emph{distributed knowledge} to the \ngroup $G$ that $\\phi$ holds, i.e., the group $G$ would be able to deduce  \n$\\phi$ if they were to pool all the information held by the members of the group. \n\nThe semantics of the logic is a standard Kripke semantics for \nepistemic logic \\cite{fhmvbook}: formulas are interpreted\n in Kripke structures\n${\\cal K} = {\\langle {W, \\{\\sim_u\\}_{u \\in {D}}, \\models} \\rangle}$ where \n$W$ is a set, \n for each $u\\in {D}$, we have an equivalence relation $\\sim_u$ on $W$, \n and ${\\models} \\subseteq {W\\times {\\mathit{Prop}}}$ is a binary relation.  \n \n Intuitively,  $W$ is a set of worlds, representing possible situations in a system of\ninterest. The equivalence relation $\\sim_u$\nintuitively corresponds to indistinguishability of worlds to an agent: \n$w \\sim_u w'$ will hold when agent $u$ has the same information available to \nit when it is in situation $w$ as it has in situation $w'$. \nFor a world $w$ and an atomic proposition $p$, the relation $w\\models p$\nrepresents that the proposition $p$ is true at the world $w$. \nWe may also write this as ${\\cal K}, w\\models p$ to make the structure ${\\cal K}$ explicit. \nIn turn, this relation can be extended to a satisfaction relation ${\\cal K}, w\\models \\phi$\nfor arbitrary formulas, by means of the following recursion: \n\\begin{tabbing}\n${\\cal K}, w\\models {\\phi_1 \\land \\phi_2}$~~\\= \\kill \n${\\cal K}, w\\models {\\phi_1 \\land \\phi_2}$\\> if ${\\cal K}, w\\models \\phi_1$ and ${\\cal K},w\\models \\phi_2$ \\\\ \n${\\cal K}, w\\models {\\neg \\phi}$ \\> if not ${\\cal K}, w\\models \\phi_1$ \\\\ \n${\\cal K}, w\\models K_u \\phi$ \\> if  ${\\cal K}, w'\\models \\phi$ for all $w'\\in W$ with $w \\sim_u w'$ \\\\ \n${\\cal K}, w\\models D_G \\phi$ \\> if  ${\\cal K}, w'\\models \\phi$ for all $w'\\in W$ with $w \\sim_u w'$ \\\\ \\> for all $u \\in G$  \n\\end{tabbing} \nIn our applications, we will work  with the set of worlds $W =A^*$, i.e., worlds will be traces \nfor the signature of interest. The basic relation $w \\models p$ \nwill be the relation $\\alpha \\models {u \\rightarrowtail v}$ from some \ndynamic policy for this signature. We discuss the \nequivalence relations we use later. \n\n\n\\section{Semantics for dynamic policies} \n\n\\label{sec:knowledgebased}\n\nIn the setting of dynamic policies, several subtle issues arise that a suitable \ndefinition of security needs to take into account.  \n\nOne is that policies can be interpreted with a focus on positive or negative edges. \nOne can read $\\alpha \\models {u \\rightarrowtail v}$ as stating a permission: \nin state $\\alpha$, actions of $u$ may pass information from $u$ to $v$ \n(even if $u$ or $v$ does not know that  $\\alpha \\models {u \\rightarrowtail v}$). \nNothing about the policy or system may override this permission, and an agent\ncannot be sanctioned for having caused the information flow. \nAlternately,  and more restrictively, one could focus on the converse: \nand treat $\\alpha  \\models {u \\not\\rightarrowtail v}$ as stating a prohibition: in state $\\alpha$, \ninformation may not flow from $u$ to $v$.  The interaction between \nvarious such prohibitions may have the effect that even where there is \nan edge $\\alpha \\models {u \\rightarrowtail v}$, it is in fact prohibited \nfor information to flow from $u$ to $v$ because of derived prohibitions. \nThe following example suggests that these two readings of the policy may be in conflict. \n\n\\begin{example} \\label{ex:conflict-example} \nConsider the system in Figure~\\ref{fig:conflict}. \nIntuitively, domain $P$ is a policy authority that controls the \npolicy between domains $A$ and $B$ by means of its action $p$, and \n$a$ is an action of domain $A$. \n\n\n\\begin{figure}\n\\begin{center} \n\\scalebox{0.8}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n  };\n\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n   \\path[policy] (A) edge (B);\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 1$ \\\\\n };\n    \\path[policy] (A) edge (B);\n   \n \\path (s0) edge node {$p$} (s1) \n (s1) edge node {$a$} (s2)\n ;\n\\end{tikzpicture}}\n\\end{center} \n\\caption{Conflicting permissive and prohibitive interpretations}\n\\label{fig:conflict}\n\\end{figure} \nThis system displays a conflict in the transition from state $s_1$ to state $s_2$,  \nbetween the permissive reading of the edge $A \\rightarrowtail B$ \nand the prohibitive reading of the edge $P \\not\\rightarrowtail B$.  \nOn the one hand, according to a permissive reading of the policy, the fact that the action $a$ causes a change in the \nobservation in domain $B$ is not an insecurity, because the policy explicitly permits \na flow of information from domain $A$ to $B$ in state $s_1$, and what $B$ learns in state $s_2$ is that \n$A$ has  performed action $a$. On the other hand, in no state of the policy is there an edge from domain $P$ to domain $B$. \nEven the union of all possible policy states does not contain a path from $P$ to $B$. \nThus, \nwe expect from a prohibitive reading of the policy that there should be no flow of information \nfrom domain $P$ to domain $B$. On this reading, the transition from $s_1$ to $s_2$ displays \nan insecurity in the system, since on making observation 1 domain $B$ can deduce not just that \naction $a$ has occurred, but also that it has been preceded by action $p$ in domain $P$. \nThus, the system contains a prohibited flow of information from $P$ to $B$, and should be judged to be insecure. \n\\end{example} \n\n\nThere are several attitudes one can take in the face of such apparent conflicts within a policy. \nOne is to allow explicit permissions to take precedence over prohibitions. Another is to \nrequire that prohibitions take precedence over permissions.  Finally, we can restrict policies\nto instances that do not contain such conflicts. We will consider all these possibilities. \n\nFor static policies, it is safe to assume that the policy is known to all agents in the system:  \nindeed, it can be assumed to be common knowledge. A second subtlety for dynamic policies is that the current \npolicy state depends on past actions, and not all agents will be permitted to know the \nentire past. This implies that there may be situations where some agents do not \nhave complete information about the current policy state. This causes difficulty \nfor any agent that is required to enforce compliance with the policy. \nFor example, in the policy of Example~\\ref{ex:conflict-example}, agent $A$ is never permitted\nto know whether $P$ has performed action $p$, so cannot be relied upon to \nenforce a policy restriction on the transfer of information about its actions to agent $B$, as applies in the initial policy state, but not\nin state $s_1$. We will approach this issue below by interpreting the policy in a way \ntakes into account what  agents know about the policy state. \n\n\n\\subsection{Permissive Interpretation} \n\nWe first formulate a definition that captures a permissive reading of a  \ndynamic policy, while generalizing TA-security. \nThe methodology underlying the notion of TA-security is to \nconstruct a concrete representation of the maximal information that\neach agent is permitted to have after each sequence of actions, and then to \nstate that a system is secure if it has no more than that permitted information. \nFor dynamic policies, with a permissive interpretation of edges $\\alpha \\models {u \\rightarrowtail v}$, \nthis leads to the following inductive definition of an operator  ${{\\tt {ta}}^\\Diamond}$. It is defined for every domain $u$, \ntrace $\\alpha \\in {A}^*$ and action $a \\in {A}$ by ${{{\\tt {ta}}^\\Diamond}_{u}(\\epsilon)} = \\epsilon$ and \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nfor some boolean condition $C$ and function $g$,  \nwhere $\\alpha \\in {A}^*$, $a\\in {A}$ and $u \\in {D}$. \nNote that the collection ${\\tt {ta}}$ is in this pattern, with $g(\\alpha,a, u) = (f_{{\\tt dom}(a)}(\\alpha),a)$ and $C(\\alpha, a, u) = {\\tt dom}(a) \\rightarrowtail u$. \nWe say that $f$ is \\emph{self-aware} if ${\\tt dom}(a) = u$ implies $C(\\alpha,a,  u)$, \nand $g(\\alpha, a, u) = g(\\beta, b,u)$ implies $a=b$. Intuitively, in the self-aware case, \n$f_u(\\alpha)$ encodes at least a record of all the actions of domain $u$ that occur in $\\alpha$. \n\nSay that a system is \\emph{$f$-secure}  \nif for all $\\alpha, \\beta \\in {A}^*$ with $f_u(\\alpha) = f_u(\\beta)$, we have ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$. \nAn alternative  definition with the ${\\tt view}$ function instead of ${\\tt obs}$ is: \na system is \\emph{$f$-view-secure} \nif for all $\\alpha, \\beta \\in {A}^*$ with $f_u(\\alpha) = f_u(\\beta)$, we have ${\\tt view}_u(\\alpha) = {\\tt view}_u(\\beta)$. \nThese definitions are equivalent, subject to self-awareness of $f$: \n\n\\begin{lemma}\n\\label{lem:obs-view} \nSuppose that $f$ is self-aware. Then a system $M$ is $f$-secure \niff it is $f$-view-secure. \n\\end{lemma}\n\n\\begin{proof}\n Assume first that $M$ is not $f$-view-secure. \n Then there are $u \\in {D}$ and $\\alpha, \\beta \\in {A}^*$ of minimal combined length with $f_u(\\alpha) = f_u(\\beta)$ and ${\\tt view}_u(\\alpha) \\neq {\\tt view}_u(\\beta)$. \n At least one of $\\alpha$ and $\\beta$ is not the empty trace, suppose that it is $\\alpha$ and let $\\alpha = \\alpha' a$ for some $\\alpha' \\in {A}^*$ and $a \\in {A}$. \n Then there are two cases:\n \\begin{itemize}\n  \\item \\emph{Case 1:} $f_u(\\alpha' a) = f_u(\\alpha')$. \n  Then $f_u(\\alpha') = f_u(\\beta)$, so \n  from the minimality of $\\alpha$ and $\\beta$ it follows that ${\\tt view}_u(\\alpha') = {\\tt view}_u(\\beta)$ and hence ${\\tt view}_u(\\alpha') \\neq {\\tt view}_u(\\alpha' a)$. \n  Since \n   $C(\\alpha, a,u)$ is false, we have by self-awareness that \n  ${\\tt dom}(a) \\neq u$, so ${\\tt view}_u(\\alpha' a) = {\\tt view}_u(\\alpha') {\\tt obs}_u(s_0 \\cdot \\alpha'a)$. \n  Therefore, we have ${\\tt obs}_u(s_0 \\cdot \\alpha' a) \\neq {\\tt obs}_u(s_0 \\cdot \\beta)$. \n  \\item \\emph{Case 2:} $f_u(\\alpha' a) \\neq f_u(\\alpha')$. \n  We can assume that $\\beta = \\beta'b$ for some $\\beta' \\in {A}^*$ and $b \\in {A}$ with $f_u(\\beta' b) \\neq f_u(\\beta')$ since otherwise, we proceed with the first case with the roles of $\\alpha$ and $\\beta$ swapped. \n  From the inductive definition of $f_u$ \n  and self-awareness, it\n  follows that $a = b$ and $f_u(\\alpha') = f_u(\\beta')$. \n  By the minimality of $\\alpha$ and $\\beta$, we have \n${\\tt view}_u(\\alpha') = {\\tt view}_u(\\beta')$. There are two cases of the definitions of ${\\tt view}_u(\\alpha' a)$ and ${\\tt view}_u(\\beta' a)$, \ndepending on whether ${\\tt dom}(a) = u$, but in either case, it follows that \n${\\tt obs}_u(s_0 \\cdot \\alpha'a) \\neq {\\tt obs}_u(s_0 \\cdot \\beta' b)$, since the \nonly difference in these sequences can be in the final observation. \n\\end{itemize}\nThe other direction of the proof follows directly from the definition of the ${\\tt view}$ function. \n\\end{proof}\n\n\nSince the definition of $f={\\tt {ta}}$ is easily seen to be self-aware (using reflexivity of the policy), it follows from Lemma~\\ref{lem:obs-view} \nthat TA-security and ${\\tt {ta}}$-view-security are equivalent. \n\n\n\n\n\n\\subsection{Dynamic Policies} \n\n\nOur main concern in this paper is with \\emph{dynamic intransitive information flow policies}, \nwhich generalize static policies by allowing the edges of the policy to depend \non the actions that have been performed in the system. Formally,\na \\emph{dynamic policy} is a relation ${\\rightarrowtail} \\subseteq {{D} \\times A^* \\times {D}}$, \nsuch that ${(u, \\alpha, u)} \\in {\\rightarrowtail}$ for all $\\alpha \\in {A}^*$ and all $u \\in {D}$. \nWe write $\\alpha \\models u \\rightarrowtail v$ when $(u, \\alpha ,v)\\in {\\rightarrowtail}$. \nIntuitively,   $\\alpha \\models {u \\rightarrowtail v}$ says that, after the sequence of actions\n$\\alpha$ have been performed, information may flow from domain $u$ to domain $v$. \nThus, $\\rightarrowtail_\\alpha = \\{(u,v) \\mid (u,\\alpha, v) \\in {\\rightarrowtail} \\}$ is the (static) policy that applies after the actions $\\alpha$  have been performed. \n\nDynamic policies can be represented using \nautomata.  We say that a tuple ${\\langle {P,\\rightarrowtail'} \\rangle}$\nconsisting of an automaton $P = {\\langle {S,s_0, \\rightarrow} \\rangle}$ and\na relation  ${\\rightarrowtail'} \\subseteq {D} \\times S\\times {D}$ \n\\emph{represents} a dynamic policy  $\\rightarrowtail$, if for all \n$\\alpha \\in {A}^*$, domains $u,v, \\in {D}$, and state $s \\in  {S}$ with $s = s_0 \\cdot \\alpha$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ iff \n$(u, s, v) \\in {\\rightarrowtail'}$.  \n(In this case we also write $s \\models {u \\rightarrowtail' v}$.) \nEvery dynamic policy has such a representation (with an infinite number of states), since we\nmay take $S= {A}^*$ and ${\\rightarrow} = \\{(\\alpha, a, \\alpha a)~|~\\alpha\\in {A}^*, a\\in {A}\\}$. \nWe may call the policy \\emph{finite state} if it has a representation with $S$ finite. \n\nLet $\\langle {D}, {\\tt dom}, {A}\\rangle$ be a signature.  \nA \\emph{policy enhanced system} for this signature is an automaton ${\\mathcal{A}}={\\langle {S, s_0, \\rightarrow} \\rangle}$  that is equipped with \na relation ${\\rightarrowtail} \\subseteq {{D} \\times S\\times {D}}$  and an observation function ${\\tt obs}$ with domain ${D} \\times S$.\nGiven a system $M$ and a dynamic policy $ \\rightarrowtail'$ for the signature, \nwe say that the policy enhanced system ${\\langle {{\\mathcal{A}}, \\rightarrowtail, {\\tt obs}} \\rangle}$ \\emph{encodes} $M$ and $\\rightarrowtail'$ if \n${\\langle {{\\mathcal{A}},{\\tt obs}} \\rangle}$ is bisimilar to $M$ and ${\\langle {{\\mathcal{A}},\\rightarrowtail} \\rangle}$ represents $\\rightarrowtail'$.\n\nFor every pair consisting of a system $M$ and a dynamic policy $\\rightarrowtail$ for the same signature, we can construct a policy enhanced system\nthat encodes $M$ and $\\rightarrowtail$. \nGiven an automaton representation ${\\langle {{\\mathcal{A}}_P,\\rightarrowtail'} \\rangle}$ of  $\\rightarrowtail$ \nwhere ${\\mathcal{A}}_P = {\\langle {S^P, s^P_0, \\rightarrow^P} \\rangle}$,  \nand  a system $M \\hspace{-2pt}= \\hspace{-2pt} {\\langle {{\\mathcal{A}}_M,{\\tt obs}^M} \\rangle}$  where ${\\mathcal{A}}_M = {\\langle {S^M, s^M_0, \\rightarrow^M} \\rangle}$ for the same signature, \nwe define the product automaton \n$A_M \\times {\\mathcal{A}}_P\n={\\langle {S, s_0, \\rightarrow} \\rangle}$, \nwhere $S = S^M \\times   S^P$, $s_0 = (s^M_0, s_0^P)$\nand $((s, p), a, (s',p')) \\in  {\\rightarrow}$  iff $(s,a,s') \\in {\\rightarrow^M}$ and $(p,a,p') \\in {\\rightarrow^P}$. \nThe automaton \n${\\mathcal{A}}_M \\times {\\mathcal{A}}_P$ \nmay be equipped with an observation function ${\\tt obs}$ with domain \n$S$  and a policy  relation ${\\rightarrowtail''} \\subseteq {D} \\times S\\times {D}$ \nby defining ${\\tt obs}(u, (s,p)) = {\\tt obs}^M(u,s)$ and ${\\rightarrowtail''} = \\{(u,(s,p),v)~|~u \\rightarrowtail_p v\\}$. \nIt is then straightforward to show that the policy enhanced system ${\\langle { {\\mathcal{A}}_M \\times {\\mathcal{A}}_P, {\\tt obs}, \\rightarrowtail''} \\rangle}$\nencodes $M$ and $\\rightarrowtail$. \n\nIt will often be convenient, in presenting examples, \nto use a diagram  of a policy enhanced system in order to present the policy and the system \ntogether as a single automaton.  Figure~\\ref{fig:conflict} gives an example of this presentation. \nWe note the following conventions to be applied in interpreting these diagrams. \nThe systems represented are input-enabled, but we elide self loops \ncorresponding to edges of the form $(s,a,s)$ in order to reduce clutter. \nStates are partitioned into three components. The top component gives the \nname of the state. The middle component depicts the static policy applicable at that \nstate. The bottom component gives partial information about the observations that the \nagents make at the state: typically, only one agent's information is relevant to the discussion, \nand we elide the observations of the other agents in the system. \n\n\nThere is a natural order on policies. \nConsider the binary relation $\\leq$ on policies with respect to a given signature $\\langle{D}, {\\tt dom}, {A}\\rangle$, \ndefined by ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ iff for all $\\alpha \\in A^*$ and $u,v\\in {D}$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ implies $\\alpha \\models {u \\rightarrowtail' v}$. \nIt is easily seen that this relation partially orders the policies with respect to the signature. \nIntuitively, if ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ then $\\rightarrowtail$ places more\nrestrictions on the flow of information in a system than does $\\rightarrowtail'$. \nThis  intuition can be supported for both a permissive and a prohibitive reading\nof policies. On a permissive reading, ${\\rightarrowtail} \\leq {\\rightarrowtail'}$\n intuitively says that every situation in which a flow of information is explicitly \n permitted by $\\rightarrowtail$ is one where the flow of information is explicitly \n permitted by $\\rightarrowtail'$. Thus, $\\rightarrowtail$ is more restrictive than $\\rightarrowtail'$ in the sense of \n having fewer explicitly permitted flows of information. \nOn a prohibitive reading,  ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ says (contrapositively) that \n every situation where $\\rightarrowtail'$ explicitly prohibits a flow of information is\n one where $\\rightarrowtail$ also explicitly prohibits that flow of information. \n Thus, $\\rightarrowtail$ is more restrictive than $\\rightarrowtail'$ in the sense of \n having more explicitly prohibited flows of information. \nWe may therefore gloss ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ \nas stating that $\\rightarrowtail$ is \\emph{more restrictive} than $\\rightarrowtail'$. \n\n\n\n\n\\subsection{Logic of Knowledge} \n\nIt will be convenient to formulate some of our definitions using formulas \nfrom a logic of knowledge. Given a signature ${\\langle {{D}, {\\tt dom}, {A}} \\rangle}$, \nwe work with formulas $\\phi$ expressed using the following \ngrammar: \n\n", "index": 7, "text": "$$ \\phi ::= u \\rightarrowtail v~|~\\phi\\land \\phi~|~ \\neg \\phi~|~ K_u\\phi~|~ D_G\\phi $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\phi::=u\\rightarrowtail v~{}|~{}\\phi\\land\\phi~{}|~{}\\neg\\phi~{}|~{}K_{u}\\phi~{%&#10;}|~{}D_{G}\\phi\" display=\"block\"><mrow><mi>\u03d5</mi><mo>:</mo><mo>:=</mo><mi>u</mi><mo>\u21a3</mo><mpadded width=\"+3.3pt\"><mi>v</mi></mpadded><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><mi>\u03d5</mi><mo>\u2227</mo><mpadded width=\"+3.3pt\"><mi>\u03d5</mi></mpadded><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><mi mathvariant=\"normal\">\u00ac</mi><mpadded width=\"+3.3pt\"><mi>\u03d5</mi></mpadded><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><msub><mi>K</mi><mi>u</mi></msub><mpadded width=\"+3.3pt\"><mi>\u03d5</mi></mpadded><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><msub><mi>D</mi><mi>G</mi></msub><mi>\u03d5</mi></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nWe also obtain a derived equivalence relation $\\sim^\\Diamond_u$ on ${A}^*$ for each $u \\in {D}$, \ndefined by $\\alpha \\sim^\\Diamond_u \\beta$ iff ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}= {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$. \n\nIntuitively, \n$\\alpha\\models {\\tt dom}(a) \\rightarrowtail u$ \nstates that it is  permitted,  \nafter trace $\\alpha$, \nfor\n${\\tt dom}(a)$ to send information to $u$, and ${\\tt dom}(a)$ exercises this by sending to $u$ all the \ninformation that it has (viz. ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}$), as well as the fact that it is performing the\naction $a$. The agent $u$ receives this information and appends it to the information that it already has\n(viz., ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}$.) In case $ \\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, on the other \nhand, there is no transfer of information from ${\\tt dom}(a)$ to $u$, since the policy \ndoes not permit this. \n\n\nIf we take ${{\\tt {ta}}^\\Diamond}$ as a formalization of the maximal information permitted to an agent, we get the \nfollowing definition of security, in the same pattern as TA-security. \n\n\\begin{definition} \nA system $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to a policy $\\rightarrowtail$ if for all domains $u$ and sequences of actions $\\alpha,\\beta$, \nif ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}= {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$ then ${\\tt obs}_{u}(s_0\\cdot \\alpha) = {\\tt obs}_{u}(s_0\\cdot \\beta)$. \n\\end{definition}  \n\n\nWe remark that the definition of ${{\\tt {ta}}^\\Diamond}$ is  self-aware \n(since by reflexivity ${\\tt dom}(a) = u$ implies $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ for all $\\alpha$)\nso it follows from Lemma~\\ref{lem:obs-view} \nthat ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Diamond}$-view-security are equivalent. \n\nThe following example shows that ${{\\tt {ta}}^\\Diamond}$-security takes a \npermissive interpretation of Example~\\ref{ex:conflict-example}. \n\n\n\\begin{example} \\label{ex:conflict-ta}\nTreating the diagram of Figure~\\ref{fig:conflict} \nas a definition of the policy, we obtain that for any \nsequence $\\alpha$ of the form $a^*$ or $a^*p$, \nwe have ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha})}  = \\epsilon$.  \nOn the other hand ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = (\\epsilon, \\epsilon,a)$, \nso every sequence $\\beta$ such that ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = {{{\\tt {ta}}^\\Diamond}_{B}({\\beta})}$\nhas the property that it contains a $p$ followed later by an $a$. Thus, \nif we interpret ${{{\\tt {ta}}^\\Diamond}_{B}({pa})} $ as a concrete representation of what \n$B$ is allowed to know after the sequence $pa$, we conclude that $B$ \nis permitted to know that there has been an occurrence of action $p$. \nIndeed, for any sequence $\\beta$ with ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = {{{\\tt {ta}}^\\Diamond}_{B}({\\beta})}$ we\nhave $s_0\\cdot \\beta = s_2= s_0\\cdot pa$, so \nthere is not a witness to insecurity of the system at\nthe sequence $pa$. The reader may confirm that this \nsystem is in fact ${{\\tt {ta}}^\\Diamond}$-secure. \n\nWe remark here that we have ${{{\\tt {ta}}^\\Diamond}_{A}({p})} = \\epsilon = {{{\\tt {ta}}^\\Diamond}_{A}({\\epsilon})}$ and \n${{{\\tt {ta}}^\\Diamond}_{B}({p})} = \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}({\\epsilon})}$, but \n${{{\\tt {ta}}^\\Diamond}_{B}({pa})} = (\\epsilon, \\epsilon, a) \\neq  \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}({a})}$. \nThat is, in general, the value ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha a})}$ depends on more than the values  ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha})}$ and ${{{\\tt {ta}}^\\Diamond}_{A}({\\alpha})}$ and the action $a$; \nadditional information (namely, does $\\alpha\\models {{\\tt dom}(a) \\rightarrowtail u}$ hold) about the sequence $\\alpha$ is required to determine \n${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha a})}$. \nWe discuss the significance of this below. \n\\end{example} \n\n\n\\subsection{Prohibitive Interpretation} \n\nExample~\\ref{ex:conflict-ta} shows that if we would like instead to prioritize prohibitions over permissions when interpreting a\npolicy, we need a different representation of the maximal information permitted to an agent than \nthat provided by the function ${{\\tt {ta}}^\\Diamond}$. It is not completely obvious what should be the \ndeduced prohibitions that prevent the use of an edge $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ \nas a justification for the transmission of information from ${\\tt dom}(a)$ to $u$ in the transition from state \n$\\alpha$ to state $\\alpha a$. \n\nHowever, we may apply some general constraints to suggest a definition. \nFirst of all, note that for static policies, the function ${\\tt {ta}}$ \nhas the property that the information available to domain $u$ immediately after \nan action $a$ performed by domain ${\\tt dom}(a)$, should depend only on the action $a$ and the \ninformation possessed by domains $u$ and ${\\tt dom}(a)$. The function ${{\\tt {ta}}^\\Diamond}$ does not have this property: \nsee the remark at the end of Example~\\ref{ex:conflict-ta}. \n\nA general way to ensure that the state of information of domain $u$ \nafter action $a$ depends only on the prior states of information of domains $u$ and ${\\tt dom}(a)$, \nis to condition the definition of the maximal information permitted to be known to $u$ on the \ndistributed knowledge of the group $\\{u, {\\tt dom}(a)\\}$. This suggests the following inductive definition\nof a function ${{\\tt {ta}}^\\Box}$, similar to ${\\tt {ta}}$, defined by ${{{\\tt {ta}}^\\Box}_{u}(\\epsilon)}  = \\epsilon$ and\nif $\\alpha \\models D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u)$, then \n\n", "itemtype": "equation", "pos": 41128, "prevtext": " \nwhere $u,v \\in {D}$ are domains and $G \\subseteq {D}$ is a set of domains. \nIntuitively, the atomic propositions of the logic are assertions of the form\n$u\\rightarrowtail v$ concerning the static policy holding at a particular point of time. \nWe write ${\\mathit{Prop}}$ for the set of atomic propositions. \nThe logic contains the usual boolean operators for conjunction and negation, \nand we freely use other boolean operators that can be defined using these, \ne.g., we write $\\phi {\\Rightarrow}\\psi$ for $\\neg (\\phi \\land \\neg \\psi)$.  \nThe formula $K_u \\phi$ intuitively says that domain $u$ \\emph{knows} that $\\phi$ \nholds,  and $D_G \\phi$ says that it is \\emph{distributed knowledge} to the \ngroup $G$ that $\\phi$ holds, i.e., the group $G$ would be able to deduce  \n$\\phi$ if they were to pool all the information held by the members of the group. \n\nThe semantics of the logic is a standard Kripke semantics for \nepistemic logic \\cite{fhmvbook}: formulas are interpreted\n in Kripke structures\n${\\cal K} = {\\langle {W, \\{\\sim_u\\}_{u \\in {D}}, \\models} \\rangle}$ where \n$W$ is a set, \n for each $u\\in {D}$, we have an equivalence relation $\\sim_u$ on $W$, \n and ${\\models} \\subseteq {W\\times {\\mathit{Prop}}}$ is a binary relation.  \n \n Intuitively,  $W$ is a set of worlds, representing possible situations in a system of\ninterest. The equivalence relation $\\sim_u$\nintuitively corresponds to indistinguishability of worlds to an agent: \n$w \\sim_u w'$ will hold when agent $u$ has the same information available to \nit when it is in situation $w$ as it has in situation $w'$. \nFor a world $w$ and an atomic proposition $p$, the relation $w\\models p$\nrepresents that the proposition $p$ is true at the world $w$. \nWe may also write this as ${\\cal K}, w\\models p$ to make the structure ${\\cal K}$ explicit. \nIn turn, this relation can be extended to a satisfaction relation ${\\cal K}, w\\models \\phi$\nfor arbitrary formulas, by means of the following recursion: \n\\begin{tabbing}\n${\\cal K}, w\\models {\\phi_1 \\land \\phi_2}$~~\\= \\kill \n${\\cal K}, w\\models {\\phi_1 \\land \\phi_2}$\\> if ${\\cal K}, w\\models \\phi_1$ and ${\\cal K},w\\models \\phi_2$ \\\\ \n${\\cal K}, w\\models {\\neg \\phi}$ \\> if not ${\\cal K}, w\\models \\phi_1$ \\\\ \n${\\cal K}, w\\models K_u \\phi$ \\> if  ${\\cal K}, w'\\models \\phi$ for all $w'\\in W$ with $w \\sim_u w'$ \\\\ \n${\\cal K}, w\\models D_G \\phi$ \\> if  ${\\cal K}, w'\\models \\phi$ for all $w'\\in W$ with $w \\sim_u w'$ \\\\ \\> for all $u \\in G$  \n\\end{tabbing} \nIn our applications, we will work  with the set of worlds $W =A^*$, i.e., worlds will be traces \nfor the signature of interest. The basic relation $w \\models p$ \nwill be the relation $\\alpha \\models {u \\rightarrowtail v}$ from some \ndynamic policy for this signature. We discuss the \nequivalence relations we use later. \n\n\n\\section{Semantics for dynamic policies} \n\n\\label{sec:knowledgebased}\n\nIn the setting of dynamic policies, several subtle issues arise that a suitable \ndefinition of security needs to take into account.  \n\nOne is that policies can be interpreted with a focus on positive or negative edges. \nOne can read $\\alpha \\models {u \\rightarrowtail v}$ as stating a permission: \nin state $\\alpha$, actions of $u$ may pass information from $u$ to $v$ \n(even if $u$ or $v$ does not know that  $\\alpha \\models {u \\rightarrowtail v}$). \nNothing about the policy or system may override this permission, and an agent\ncannot be sanctioned for having caused the information flow. \nAlternately,  and more restrictively, one could focus on the converse: \nand treat $\\alpha  \\models {u \\not\\rightarrowtail v}$ as stating a prohibition: in state $\\alpha$, \ninformation may not flow from $u$ to $v$.  The interaction between \nvarious such prohibitions may have the effect that even where there is \nan edge $\\alpha \\models {u \\rightarrowtail v}$, it is in fact prohibited \nfor information to flow from $u$ to $v$ because of derived prohibitions. \nThe following example suggests that these two readings of the policy may be in conflict. \n\n\\begin{example} \\label{ex:conflict-example} \nConsider the system in Figure~\\ref{fig:conflict}. \nIntuitively, domain $P$ is a policy authority that controls the \npolicy between domains $A$ and $B$ by means of its action $p$, and \n$a$ is an action of domain $A$. \n\n\n\\begin{figure}\n\\begin{center} \n\\scalebox{0.8}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n  };\n\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n   \\path[policy] (A) edge (B);\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {        \\node[agent] (P) [left] {$P$};       \\node[agent] (A) [right of=P] {$A$};       \\node[agent] (B) [below of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 1$ \\\\\n };\n    \\path[policy] (A) edge (B);\n   \n \\path (s0) edge node {$p$} (s1) \n (s1) edge node {$a$} (s2)\n ;\n\\end{tikzpicture}}\n\\end{center} \n\\caption{Conflicting permissive and prohibitive interpretations}\n\\label{fig:conflict}\n\\end{figure} \nThis system displays a conflict in the transition from state $s_1$ to state $s_2$,  \nbetween the permissive reading of the edge $A \\rightarrowtail B$ \nand the prohibitive reading of the edge $P \\not\\rightarrowtail B$.  \nOn the one hand, according to a permissive reading of the policy, the fact that the action $a$ causes a change in the \nobservation in domain $B$ is not an insecurity, because the policy explicitly permits \na flow of information from domain $A$ to $B$ in state $s_1$, and what $B$ learns in state $s_2$ is that \n$A$ has  performed action $a$. On the other hand, in no state of the policy is there an edge from domain $P$ to domain $B$. \nEven the union of all possible policy states does not contain a path from $P$ to $B$. \nThus, \nwe expect from a prohibitive reading of the policy that there should be no flow of information \nfrom domain $P$ to domain $B$. On this reading, the transition from $s_1$ to $s_2$ displays \nan insecurity in the system, since on making observation 1 domain $B$ can deduce not just that \naction $a$ has occurred, but also that it has been preceded by action $p$ in domain $P$. \nThus, the system contains a prohibited flow of information from $P$ to $B$, and should be judged to be insecure. \n\\end{example} \n\n\nThere are several attitudes one can take in the face of such apparent conflicts within a policy. \nOne is to allow explicit permissions to take precedence over prohibitions. Another is to \nrequire that prohibitions take precedence over permissions.  Finally, we can restrict policies\nto instances that do not contain such conflicts. We will consider all these possibilities. \n\nFor static policies, it is safe to assume that the policy is known to all agents in the system:  \nindeed, it can be assumed to be common knowledge. A second subtlety for dynamic policies is that the current \npolicy state depends on past actions, and not all agents will be permitted to know the \nentire past. This implies that there may be situations where some agents do not \nhave complete information about the current policy state. This causes difficulty \nfor any agent that is required to enforce compliance with the policy. \nFor example, in the policy of Example~\\ref{ex:conflict-example}, agent $A$ is never permitted\nto know whether $P$ has performed action $p$, so cannot be relied upon to \nenforce a policy restriction on the transfer of information about its actions to agent $B$, as applies in the initial policy state, but not\nin state $s_1$. We will approach this issue below by interpreting the policy in a way \ntakes into account what  agents know about the policy state. \n\n\n\\subsection{Permissive Interpretation} \n\nWe first formulate a definition that captures a permissive reading of a  \ndynamic policy, while generalizing TA-security. \nThe methodology underlying the notion of TA-security is to \nconstruct a concrete representation of the maximal information that\neach agent is permitted to have after each sequence of actions, and then to \nstate that a system is secure if it has no more than that permitted information. \nFor dynamic policies, with a permissive interpretation of edges $\\alpha \\models {u \\rightarrowtail v}$, \nthis leads to the following inductive definition of an operator  ${{\\tt {ta}}^\\Diamond}$. It is defined for every domain $u$, \ntrace $\\alpha \\in {A}^*$ and action $a \\in {A}$ by ${{{\\tt {ta}}^\\Diamond}_{u}(\\epsilon)} = \\epsilon$ and \n\n", "index": 9, "text": "\\begin{align*}\n {{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} & =\n \\begin{cases}\n  ({{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}, {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}, a) & \\text{if } \\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}\\\\\n  {{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})} & \\text{otherwise} \n  \\enspace. \n \\end{cases}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{{\\tt{ta}}^{\\Diamond}}_{u}({\\alpha a})}\" display=\"inline\"><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}({{{\\tt{ta}}^{\\Diamond}}_{u}({\\alpha})},{{{\\tt{ta}}%&#10;^{\\Diamond}}_{{{\\tt dom}(a)}}(\\alpha)},a)&amp;\\text{if }\\alpha\\models{{\\tt dom}(a)%&#10;\\rightarrowtail u}\\\\&#10;{{{\\tt{ta}}^{\\Diamond}}_{u}({\\alpha})}&amp;\\text{otherwise}\\@math@espace.\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>\u03b1</mi></mrow><mo>\u22a7</mo><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21a3</mo><mi>u</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>otherwise</mtext><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\@math@espace</span></mtext></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nand else\n$ {{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}({\\alpha})}$. \n\n\n\nThe formula \n$D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u) {\\Rightarrow} {{\\tt dom}(a) \\rightarrowtail u}$ is a \nvalidity of epistemic logic, so this definition strengthens the condition under which information is transmitted in the definition of ${{\\tt {ta}}^\\Diamond}$. \nIntuitively, this definition permits transmission of ${\\tt dom}(a)$'s information to $u$ only when \nit is distributed knowledge to $u$ and ${\\tt dom}(a)$ that ${\\tt dom}(a) \\rightarrowtail u$, \ni.e., there is not the possibility, so far as these domains jointly know, that there is an \nedge ${\\tt dom}(a) \\not\\rightarrowtail u$ that prohibits the transmission of information\nfrom ${\\tt dom}(a) $ to $u$. Thus, the  definition takes the point of view that transmission\nis permitted whenever the agents would jointly be able to confirm that there is not \nan explicit prohibition to the transmission. \n\nAs it stands, the definition of ${{\\tt {ta}}^\\Box}$ is incomplete, because in order to \ninterpret the condition $\\alpha \\models D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u) $, \nwe need an appropriate Kripke structure in order to evaluate the \ndistributed knowledge operator. We may take ${A}^*$ to be the set of \nworlds of this structure, and derive satisfaction of atomic propositions from the policy, but it remains to specify\nequivalence relations $\\sim_v$ for $v\\in {D}$. \nIntuitively, \nan equivalence $\\alpha \\sim_v \\beta$ holds when agent $v$ is not able to \ndistinguish between the traces $\\alpha$ and $\\beta$: whenever the system is\nin state $\\alpha$, agent $v$ considers it possible that the system is in state $\\beta$. \nWhat these equivalence relations should be is \nnot immediately apparent. We take the approach \nof identifying some constraints on these equivalence relations. \n\nFirst, consider the general constraint, that the way agent $u$'s state of \ninformation is updated when action $a$ is performed, should depend only on the \nprior state of information of $u$ and ${\\tt dom}(a)$. This can be captured at the \nlevel of the relations \n$\\sim_v$\nby means of the following constraint: \n\\begin{itemize} \n\\item[(WSC)] For all traces $\\alpha, \\beta$, and actions $a$, if $\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ then \n$\\alpha a\\sim_u\\beta a$.\n\\end{itemize}\n(We call this constraint WSC since it is essentially the same as Rushby's condition of \\emph{Weak Step Consistency} \\cite{rushby92}.) \nAlthough it  does not mention the policy explicitly, this constraint is not inconsistent \nwith the state of the policy being a factor in how $u$'s knowledge is updated. However, it \nrequires that the way that the policy is taken into account depends only on information\njointly available to domains $u$ and ${\\tt dom}(a)$. \n\nNext, to factor in the prohibitions to information transfer \nimplied by the \npolicy, note that one case where the policy clearly prohibits transfer of \ninformation from a domain ${\\tt dom}(a)$ to $u$ when action $a$ is performed\nafter sequence $\\alpha$ is where $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$. \nThus, domain $u$'s state of information in state $\\alpha a$ should be the same \nas its information in state $\\alpha$ in this case. This suggests the \nfollowing constraint: \n\\begin{itemize} \n\\item[(DLR)] For all traces $\\alpha$, and actions $a$, if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then \n$\\alpha a\\sim_u\\alpha$.\n\\end{itemize} \nThe nomenclature DLR arises from the fact that this is essentially a dynamic generalization of Rushby's condition of \\emph{Locally Respects} \\cite{rushby92}. \nA slightly stronger alternative of DLR is the following: \n\\begin{itemize} \n\\item[(DLR$'$)] For all traces $\\alpha$, and actions $a$, if there exists a trace $\\beta$ such that \n$\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ and \n$\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then \n$\\alpha a\\sim_u\\alpha$.\n\\end{itemize} \nIn fact, in the context of WSC, this is equivalent to DLR. \n\n\n\\begin{proposition}\\label{prop:LRprime} \nIf WSC then DLR iff DLR$'$.  \n\\end{proposition}  \n\n\\begin{proof} \nWe assume WSC and DLR and show DLR$'$. (The other direction is straightforward.) \nSuppose that \n$\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ and \n$\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$.  We need to show \n$\\alpha a\\sim_u\\alpha$. By WSC, we have $\\alpha a \\sim_u \\beta a$. \nSince $\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$, we have by DLR that \n$\\beta a \\sim_u \\beta$. Two applications of transitivity now yield that \n$\\alpha a \\sim_u \\alpha$, as required. \n\\end{proof} \n\n\n\nSuppose that we now accept WSC and DLR as reasonable constraints on the\nequivalence relations $\\sim_u$ corresponding to the maximal knowledge that an agent $u$ is permitted \nto have. Indexed collections of equivalence relations may be partially ordered by pointwise containment. \n(That is, we take \\mbox{$\\{\\sim_u\\}_{u\\in D}  \\leq \\{\\sim'_u\\}_{u\\in D}$} if ${\\sim_u} \\subseteq {\\sim'_u}$ for all $u\\in D$.)  \nGiven the dynamic policy $\\rightarrowtail$, let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ be the \nsmallest collection of equivalence relations that is consistent with WSC and DLR. \nIntuitively, these smallest relations are the ones that\nallow for the {\\em maximal} amount of information flow in the system that is consistent with the \nconstraints. (The smaller the equivalence class, the larger the agent's amount of knowledge.)\nWe call these relations the \\emph{unwinding relations}. \nThe following fact will be useful below.\n\n\n\\begin{lemma} \\label{lem:unwmon}\nSuppose  ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ and $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ be the \nunwinding relations for the policies $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nThen ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \n\\end{lemma} \n\\begin{proof} \nSince ${\\tt dom}(a) \\not\\rightarrowtail' u$ implies ${\\tt dom}(a) \\not\\rightarrowtail u$, there are fewer cases of \nbasic facts $\\alpha a{\\sim^{\\mathit{unw}}}_u \\alpha$ than basic facts  $\\alpha a{\\approx^{\\mathit{unw}}}_u \\alpha$\nderivable using DLR. By monotonicity of WSC and the rules for an equivalence relation, \nit follows that ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \n\\end{proof}\n\n\n\n\nWe now take the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ as the equivalence relations \nin the Kripke structure needed to interpret the distributed knowledge operator in the \ndefinition of the functions ${{\\tt {ta}}^\\Box}_u$. We call the derived security notion\nassociated to these functions \\emph{${{\\tt {ta}}^\\Box}$-security}.  \n(Note that since, by reflexivity, if ${\\tt dom}(a) = u$ then $D_{\\{u, {\\tt dom}(a)\\}}({\\tt dom}(a) \\rightarrowtail u)$ \nis valid in this Kripke structure, these functions are self-aware, so \nagain, by Lemma~\\ref{lem:obs-view},  ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Box}$-view-security\nare equivalent.) \nFor $u\\in D$ we also write $\\sim^\\Box_u$ for the relation on traces defined by $\\alpha \\sim^\\Box_u \\beta$ \niff ${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$.  \n \nHowever, we note that we could also take the \nunwinding \nrelations directly as the \nbasis for another definition of security: \n\n\\begin{definition} \nA system is \\emph{unwinding-secure} with respect to a policy $\\rightarrowtail$ \nif, \nfor all traces $\\alpha,\\beta$ and domain~$u$, \nwe have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ implies ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$.  \n\\end{definition}  \n\nIn fact, it turns out that this does not give a new definition of security. \nThe following result shows that the \nunwinding relations \ncorrespond precisely to the information \nflow modelled by the function ${{\\tt {ta}}^\\Box}$. \n\n\n\\begin{theorem} \n\\label{thm:mustunwind} \nWe have \n${{\\sim^{\\mathit{unw}}}_u} = {\\sim^\\Box_u}$ for all $u\\in D$. \n\\end{theorem} \n\n\\begin{proof}\nWe establish the containments ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim^\\Box_u}$ and ${\\sim^\\Box_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$. \n\nFor  ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim^\\Box_u}$, we argue by induction on the number of steps of a derivation \nof the statement $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ using rules WSC, DLR and the rules for an equivalence relation. \nThe cases for reflexivity, transitivity an symmetry are direct from the fact that $\\sim^\\Box_u$ has these properties. \nFor the DLR case, suppose that $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, so that we have \n$\\alpha a {\\sim^{\\mathit{unw}}}_u \\alpha$. By validity of the formula $D_G(\\phi) {\\Rightarrow} \\phi$, we  have also \n$\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, so by the definition of ${{\\tt {ta}}^\\Box}$ \nwe have $\\alpha a \\sim^\\Box_u \\alpha$, as required. \nFor the WSC case, suppose that \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha{\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta$, so that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta a$ by WSC. \nBy the inductive hypothesis, we have \n$\\alpha \\sim^\\Box_u \\beta$ and $\\alpha\\sim^\\Box_{{\\tt dom}(a)}\\beta$, \ni.e., ${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\beta)}$. \nMoreover, it also follows that \n $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$ iff \n $\\beta \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, so that the \n same case of the definition of ${{\\tt {ta}}^\\Box}$ is selected in both \n ${{{\\tt {ta}}^\\Box}_{u}({ \\alpha a})}$ and   ${{{\\tt {ta}}^\\Box}_{u}({ \\beta a})}$. \n It follows that ${{{\\tt {ta}}^\\Box}_{u}({ \\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}({ \\beta a})}$, \n i.e., $\\alpha a\\sim^\\Box_{{\\tt dom}(a)}\\beta a$, as required. \n\nFor  ${\\sim^\\Box_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$, we argue \nby induction on the combined length of $\\alpha$ and $\\beta$\nthat $\\alpha \\sim^\\Box_{{\\tt dom}(a)}\\beta $ implies $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta $.\nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial by reflexivity. \nBy symmetry, it suffices to consider the case of $\\alpha = \\alpha a$ and $\\beta$, where the result\nhas already been established for sequences of shorter combined length.\nWe suppose that  $\\alpha \\sim^\\Box_{{\\tt dom}(a)}\\beta $, i.e., \n${{{\\tt {ta}}^\\Box}_{u}({\\alpha a })} = {{{\\tt {ta}}^\\Box}_{u}({\\beta})}$, and show that $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta $.\nWe consider two cases, corresponding to the cases of the \ndefinition of ${{\\tt {ta}}^\\Box}$. \n\nIn the first case, we have $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, \nso that ${{{\\tt {ta}}^\\Box}_{u}({\\alpha})} = {{{\\tt {ta}}^\\Box}_{u}({\\alpha a})}$, and hence ${{{\\tt {ta}}^\\Box}_{u}({\\alpha})} = {{{\\tt {ta}}^\\Box}_{u}({\\beta})}$. \nBy induction, we have $\\alpha  {\\sim^{\\mathit{unw}}}_u \\beta$. \nSince $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, \nthere exists a trace $\\gamma$ such that \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\gamma$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\gamma$ and \n$\\gamma \\models {\\tt dom}(a) \\not\\rightarrowtail u$. The relation ${\\sim^{\\mathit{unw}}}_u$ satisfies WSC and DLR by definition, \nso by Proposition~\\ref{prop:LRprime} it also satisfies DLR$'$. \nThus,  we obtain that $\\alpha a {\\sim^{\\mathit{unw}}}_{u} \\alpha $. It now follows by transitivity that $\\alpha a {\\sim^{\\mathit{unw}}}_u\\beta$, as required. \n\nIn the second case, we have $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\rightarrowtail u)$,\nso that ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = ({{{\\tt {ta}}^\\Box}_{u}(\\alpha)}, {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)}, a)$. \nAssuming that   ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$, it follows that $\\beta \\neq \\epsilon$, \nso we may write $\\beta = \\beta' b$. If \n$\\beta' \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, then we may switch the roles\nof $\\alpha a$ and $\\beta' b$ and argue as above, so it suffices to consider the case where \n$\\beta' \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\rightarrowtail u)$. In this case, \nwe have ${{{\\tt {ta}}^\\Box}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Box}_{u}({\\beta'})}, {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, \nso it follows from ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$ that \n$a = b$ and \n${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}({\\beta'})}$ \nand $ {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}({\\beta'})}$. \nThat is, we have $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta'$  and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \nBy WSC, it follows that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta' a = \\beta$, as required. \n\\end{proof} \n\n\n\nIt is immediate from Theorem~\\ref{thm:mustunwind}  that unwinding security and ${{\\tt {ta}}^\\Box}$-security \nare equivalent. Thus, these definitions lend support to each other and help to \nexplain each other: the functions ${{\\tt {ta}}^\\Box}$ give an intuitive, concrete description of \nthe information flows that are permitted when security is interpreted using the unwinding relations. \n\nMoreover, Theorem~\\ref{thm:mustunwind}  shows that ${{\\tt {ta}}^\\Box}$-security provides a feasible \ngeneral framework for security definitions. To instantiate this framework, we \nmust provide a collection of equivalence relations \n$\\{\\sim_u\\}_{u\\in D}$ \nto be used \nto interpret the distributed knowledge operator in the definition.   It is reasonable \nto ask that however we do so, it should be the case that \nthe resulting relations $\\{\\sim^\\Box_u\\}_{u\\in D}$ are exactly the relations \n$\\{\\sim_u\\}_{u\\in D}$, \nso that the definition of ${{\\tt {ta}}^\\Box}$ is self-consistent.\n\\footnote{It is worth noting that the circularity here is similar to the circularity in the \nsemantics of {\\em knowledge-based programs} \\cite{fhmvbook}.} \nTheorem~\\ref{thm:mustunwind} shows that this condition \nis in fact satisfiable. \n\nThere remains some circularity in this justification of the definitions of unwinding security and \n${{\\tt {ta}}^\\Box}$-security. In particular, these definitions\nare both based on the assumption that the constraints WSC and DLR are the only constraints\nthat should be applied to the flow of information in order to satisfy the policy, and that the \nresulting relations give an acceptable notion of permitted agent knowledge. However, if a case\ncan be made that further constraints should be placed on the semantics, then a comparison\nsimilar to that made above can be considered. \n\nThe next lemma shows that ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security. \n\n\\begin{lemma} \n\\label{mayta-cont-unwind} \nWe have ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}  = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ implies $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ for all $\\alpha, \\beta \\in {A}^*$ and all $u \\in {D}$. \nMoreover, ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security. \n\\end{lemma} \n\n\\begin{proof} \nBy induction on the combined length of $\\alpha$ and $\\beta$. \nThe base case is trivial by reflexivity. Consider the case of\n$\\alpha a $ and $\\beta$, and suppose ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$.\n\nIn case  $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$, \nso by induction we obtain $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. Also, by DLR, we have $\\alpha a {\\sim^{\\mathit{unw}}}_u \\alpha$. \nIt follows that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta$, as required. \n\nAlternately, if $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$, \nthen we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})},  {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha})} , a)$. \nIt follows that $\\beta \\neq\\epsilon$, so let $\\beta = \\beta' b$ for $b \\in A$. \nIn the case that $\\beta' \\models {{\\tt dom}(b) \\not\\rightarrowtail u}$, we may swap the roles of $\\alpha a$ and $\\beta' b$ and\nargue as in the previous paragraph. In case $\\beta' \\models {{\\tt dom}(b) \\rightarrowtail u}$, we have \n${{{\\tt {ta}}^\\Diamond}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})},  {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})} , b)$,  \nand it follows that $a=b$ and ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$. \nBy induction, we obtain that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta'$.\nIt now follows by WSC that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta' a = \\beta$, as required.   \n\\end{proof} \n\n\nThe following example shows that ${{\\tt {ta}}^\\Box}$-security differs from ${{\\tt {ta}}^\\Diamond}$-security. \n\\begin{example}\n As already seen in Example~\\ref{ex:conflict-ta}, the system in Figure~\\ref{fig:conflict} is ${{\\tt {ta}}^\\Diamond}$-secure. \n But, we have that $p {\\sim^{\\mathit{unw}}}_B \\epsilon$ and $p {\\sim^{\\mathit{unw}}}_A \\epsilon$ by WSC. \n By applying DLR, we obtain $pa {\\sim^{\\mathit{unw}}}_B a$. \n Using Theorem~\\ref{thm:mustunwind}, we have ${{{\\tt {ta}}^\\Box}_{B}({pa})} = {{{\\tt {ta}}^\\Box}_{B}(a)}$, and since \n ${\\tt obs}_B(s_0 \\cdot pa) \\neq {\\tt obs}_B(s_0 \\cdot a)$, the system is not ${{\\tt {ta}}^\\Box}$-secure. \n\\end{example}\n\n\n\\subsection{A sufficient condition for equivalence}\n\n\nThe outcome of the discussion so far is that we have identified two definitions of \nsecurity of dynamic policies, one of which (${{\\tt {ta}}^\\Diamond}$-security) takes a permissive\ninterpretation of policies, and the other $({{\\tt {ta}}^\\Box}$-security, or equivalently, unwinding security)\ntakes a prohibitive interpretation. As noted above, these two interpretations\nmay be in conflict for some policies. It is therefore of interest to \nunderstand when a policy is free of this conflict. The \nfollowing notion is useful in this regard. \n\n\\begin{definition} \n\\label{def:locality}\nA policy $\\rightarrowtail$ is {\\em local} \nwith respect to a collection of equivalence relations \n$\\{\\approx_u\\}_{u\\in D}$ on $A^*$ if, \nfor all domains $u,v\\in D$ and traces $\\alpha, \\beta\\in A^*$, if  \n$\\alpha \\approx_u \\beta $ and $\\alpha \\approx_v \\beta $ \nthen $\\alpha \\models {u \\rightarrowtail v}$ iff $\\beta \\models {u \\rightarrowtail v}$. \n\\end{definition} \n\nAn equivalent statement is that \n\n", "itemtype": "equation", "pos": 46970, "prevtext": "\nWe also obtain a derived equivalence relation $\\sim^\\Diamond_u$ on ${A}^*$ for each $u \\in {D}$, \ndefined by $\\alpha \\sim^\\Diamond_u \\beta$ iff ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}= {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$. \n\nIntuitively, \n$\\alpha\\models {\\tt dom}(a) \\rightarrowtail u$ \nstates that it is  permitted,  \nafter trace $\\alpha$, \nfor\n${\\tt dom}(a)$ to send information to $u$, and ${\\tt dom}(a)$ exercises this by sending to $u$ all the \ninformation that it has (viz. ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}$), as well as the fact that it is performing the\naction $a$. The agent $u$ receives this information and appends it to the information that it already has\n(viz., ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}$.) In case $ \\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, on the other \nhand, there is no transfer of information from ${\\tt dom}(a)$ to $u$, since the policy \ndoes not permit this. \n\n\nIf we take ${{\\tt {ta}}^\\Diamond}$ as a formalization of the maximal information permitted to an agent, we get the \nfollowing definition of security, in the same pattern as TA-security. \n\n\\begin{definition} \nA system $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to a policy $\\rightarrowtail$ if for all domains $u$ and sequences of actions $\\alpha,\\beta$, \nif ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})}= {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$ then ${\\tt obs}_{u}(s_0\\cdot \\alpha) = {\\tt obs}_{u}(s_0\\cdot \\beta)$. \n\\end{definition}  \n\n\nWe remark that the definition of ${{\\tt {ta}}^\\Diamond}$ is  self-aware \n(since by reflexivity ${\\tt dom}(a) = u$ implies $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ for all $\\alpha$)\nso it follows from Lemma~\\ref{lem:obs-view} \nthat ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Diamond}$-view-security are equivalent. \n\nThe following example shows that ${{\\tt {ta}}^\\Diamond}$-security takes a \npermissive interpretation of Example~\\ref{ex:conflict-example}. \n\n\n\\begin{example} \\label{ex:conflict-ta}\nTreating the diagram of Figure~\\ref{fig:conflict} \nas a definition of the policy, we obtain that for any \nsequence $\\alpha$ of the form $a^*$ or $a^*p$, \nwe have ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha})}  = \\epsilon$.  \nOn the other hand ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = (\\epsilon, \\epsilon,a)$, \nso every sequence $\\beta$ such that ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = {{{\\tt {ta}}^\\Diamond}_{B}({\\beta})}$\nhas the property that it contains a $p$ followed later by an $a$. Thus, \nif we interpret ${{{\\tt {ta}}^\\Diamond}_{B}({pa})} $ as a concrete representation of what \n$B$ is allowed to know after the sequence $pa$, we conclude that $B$ \nis permitted to know that there has been an occurrence of action $p$. \nIndeed, for any sequence $\\beta$ with ${{{\\tt {ta}}^\\Diamond}_{B}({pa})}  = {{{\\tt {ta}}^\\Diamond}_{B}({\\beta})}$ we\nhave $s_0\\cdot \\beta = s_2= s_0\\cdot pa$, so \nthere is not a witness to insecurity of the system at\nthe sequence $pa$. The reader may confirm that this \nsystem is in fact ${{\\tt {ta}}^\\Diamond}$-secure. \n\nWe remark here that we have ${{{\\tt {ta}}^\\Diamond}_{A}({p})} = \\epsilon = {{{\\tt {ta}}^\\Diamond}_{A}({\\epsilon})}$ and \n${{{\\tt {ta}}^\\Diamond}_{B}({p})} = \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}({\\epsilon})}$, but \n${{{\\tt {ta}}^\\Diamond}_{B}({pa})} = (\\epsilon, \\epsilon, a) \\neq  \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}({a})}$. \nThat is, in general, the value ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha a})}$ depends on more than the values  ${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha})}$ and ${{{\\tt {ta}}^\\Diamond}_{A}({\\alpha})}$ and the action $a$; \nadditional information (namely, does $\\alpha\\models {{\\tt dom}(a) \\rightarrowtail u}$ hold) about the sequence $\\alpha$ is required to determine \n${{{\\tt {ta}}^\\Diamond}_{B}({\\alpha a})}$. \nWe discuss the significance of this below. \n\\end{example} \n\n\n\\subsection{Prohibitive Interpretation} \n\nExample~\\ref{ex:conflict-ta} shows that if we would like instead to prioritize prohibitions over permissions when interpreting a\npolicy, we need a different representation of the maximal information permitted to an agent than \nthat provided by the function ${{\\tt {ta}}^\\Diamond}$. It is not completely obvious what should be the \ndeduced prohibitions that prevent the use of an edge $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ \nas a justification for the transmission of information from ${\\tt dom}(a)$ to $u$ in the transition from state \n$\\alpha$ to state $\\alpha a$. \n\nHowever, we may apply some general constraints to suggest a definition. \nFirst of all, note that for static policies, the function ${\\tt {ta}}$ \nhas the property that the information available to domain $u$ immediately after \nan action $a$ performed by domain ${\\tt dom}(a)$, should depend only on the action $a$ and the \ninformation possessed by domains $u$ and ${\\tt dom}(a)$. The function ${{\\tt {ta}}^\\Diamond}$ does not have this property: \nsee the remark at the end of Example~\\ref{ex:conflict-ta}. \n\nA general way to ensure that the state of information of domain $u$ \nafter action $a$ depends only on the prior states of information of domains $u$ and ${\\tt dom}(a)$, \nis to condition the definition of the maximal information permitted to be known to $u$ on the \ndistributed knowledge of the group $\\{u, {\\tt dom}(a)\\}$. This suggests the following inductive definition\nof a function ${{\\tt {ta}}^\\Box}$, similar to ${\\tt {ta}}$, defined by ${{{\\tt {ta}}^\\Box}_{u}(\\epsilon)}  = \\epsilon$ and\nif $\\alpha \\models D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u)$, then \n\n", "index": 11, "text": "\\begin{equation*}\n {{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = ({{{\\tt {ta}}^\\Box}_{u}({\\alpha})}, {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)}, a)\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"{{{\\tt{ta}}^{\\Box}}_{u}({\\alpha a})}=({{{\\tt{ta}}^{\\Box}}_{u}({\\alpha})},{{{%&#10;\\tt{ta}}^{\\Box}}_{{{\\tt dom}(a)}}(\\alpha)},a)\" display=\"block\"><mrow><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25a1</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25a1</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25a1</mi><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nfor all traces $\\alpha$ and domains $u,v$, \nwhen the equivalence relation used to  interpret knowledge is $\\approx$-equivalence. \nThat is, a pair of agents always have distributed knowledge of whether \none may interfere with the other. \n\n\\begin{example} \nThe policy of Example~\\ref{ex:conflict-example} is  not a local policy\nwith respect to the relations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$. For, \nwe have $\\epsilon \\sim^\\Diamond_A p$ and $\\epsilon \\sim^\\Diamond_B p$, \nbut $\\epsilon \\models A \\not\\rightarrowtail B$ and $p \\models A \\rightarrowtail B$. \nWe present some examples of classes of local policies in Section~\\ref{sec:specialcases}. \n\\end{example} \n\nWe could instantiate the definition of locality with respect to either the equivalence relations\n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$ or $\\{\\sim^\\Box_u\\}_{u\\in D}$ (equivalently, the unwinding relations\n$\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$). \nIn fact, these definitions prove to be equivalent. \nWe first remark that, in general, the relations ${\\sim^{\\mathit{unw}}}_u$ differ from the relations  $\\sim^\\Diamond_u$. In particular, \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta $ does not imply $\\alpha \\sim^\\Diamond_u \\beta$. \n\\begin{example}\n In this example we proceed with the system of Figure~\\ref{fig:conflict}. \n By DLR, we have from $\\epsilon \\models {P \\not\\rightarrowtail B}$ that $p {\\sim^{\\mathit{unw}}}_B \\epsilon$ and from $\\epsilon \\models {P \\not\\rightarrowtail A}$ that $p {\\sim^{\\mathit{unw}}}_A \\epsilon$. \n By WSC, we have $p a {\\sim^{\\mathit{unw}}}_B a$. \n However, the ${{\\tt {ta}}^\\Diamond}$ values of $B$ differ: ${{{\\tt {ta}}^\\Diamond}_{{B}}({p a})} = (\\epsilon, \\epsilon, a) \\neq \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}(a)}$. \n\\end{example}\n\n \nHowever, the relations ${\\sim^{\\mathit{unw}}}_u$ and $\\sim^\\Diamond_u$ \\emph{are} identical \n for policies that are local with respect to the equivalence relations \n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$.  \n\n\\begin{lemma} \n\\label{lemma:eqi-mayta-unwind}\nLet $\\rightarrowtail$ be a local policy with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$.\nThen  $\\{\\sim^\\Diamond_u\\}_{u\\in D} =  \\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$. \n\\end{lemma} \n\\begin{proof} \nSuppose \nthat the policy $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$.  Then \nthese relations satisfy WSC. For, suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta})}$. \nNote that, by locality, we have that   $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail v}$ iff $\\beta \\models {{\\tt dom}(a) \\rightarrowtail v}$. \nIt follows that the same case is chosen in the definitions of \n${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})}$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\beta a})}$, and we obtain that  ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta a})}$.\n\nIt is immediate from the definition of ${{\\tt {ta}}^\\Diamond}$ that the relations \n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$ satisfy DLR. By \nthe previous paragraph, these relations also \nsatisfy WSC. Since $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ are the minimal relations satisfying WSC and DLR, \nwe obtain that $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D} \\leq \\{\\sim^\\Diamond_u\\}_{u\\in D}$. \nThe converse also holds by Lemma~\\ref{mayta-cont-unwind}.  \n\\end{proof} \n\nFrom this, we obtain the claimed independence of locality on the choice of equivalence relation. \n\n\\begin{lemma} \n\\label{lem:locality-equiv} \nA given policy $\\rightarrowtail$ is local with respect to the associated\nrelations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$ iff it is \nlocal with respect to the relations $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n\\end{lemma} \n\n\\begin{proof}\n First suppose that $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$. \n Then by Lemma~\\ref{lemma:eqi-mayta-unwind} and Theorem~\\ref{thm:mustunwind}, we have \n $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D} = \\{\\sim^\\Diamond_u\\}_{u\\in D} =\\{\\sim^\\Box_u\\}_{u\\in D}$. \n Hence, $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n \n Suppose now that $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n Let $u, v \\in {D}$ and $\\alpha, \\beta \\in {A}^*$ with ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$. \n By Lemma~\\ref{mayta-cont-unwind}, we have $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v \\beta$. \n By Theorem~\\ref{thm:mustunwind}, we have $\\alpha \\sim^\\Box_u \\beta$ and $\\alpha \\sim^\\Box_v \\beta$ and hence, $\\alpha \\models {u \\rightarrowtail v}$ iff $\\beta \\models {u \\rightarrowtail v}$. \n\\end{proof}\n\n\nConsequently, in the sequel we say simply that the policy is local,  \nif it is local with respect to either of these relations. \n\n\nThe following result shows that \nfor local policies, the conflict between a permissive and a prohibitive  reading of policies does not arise. \n\n\\begin{theorem} \n\\label{thm:local-must-may} \nIf $\\rightarrowtail$ is a local policy then ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security with \nrespect to $\\rightarrowtail$ are equivalent. \n\\end{theorem} \n\n\\begin{proof} \nThis is immediate from the fact that if the policy is local, then for all traces $\\alpha$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ iff  $\\alpha \\models D_{\\{u,v\\}}(u \\rightarrowtail v)$. \nThis claim follows straightforwardly from the properties of distributed knowledge.  \n\\end{proof} \n\n\nIndeed, locality  \\emph{exactly} captures the condition under which the permissive and the prohibitive interpretations of a policy are equivalent. \nWe need one technical condition on this statement. \nSay that a domain $u$ is \\emph{inactive} when ${\\tt dom}^{-1}(u) =\\emptyset$, i.e., the domain has no actions that it can perform, \nso it plays only the role of an observer in the system. \nNote that policy edges of the form $\\alpha \\models u\\rightarrowtail v$\nwhere \n$u$ is inactive \nhave no bearing on the definitions of ${{\\tt {ta}}^\\Diamond}$-security or unwinding-security (and hence also not on the equivalent \n${{\\tt {ta}}^\\Box}$-security) since all references to the policy in these definitions occur\nonly in the form $\\alpha \\models u\\rightarrowtail v$ with $u = {\\tt dom}(a)$ for some action $a$. \nIntuitively, the interference relation $u\\rightarrowtail v$ is  concerned with the ability of domain  $u$ to perform actions that \ntransfer information to domain $v$, and for a domain with no actions, such transfer of information is always impossible. \nWe say that policy $\\rightarrowtail$ \\emph{has no edges from \ninactive domains}, when for all domains $u$ that are inactive, \nwe have \n$\\alpha \\models u \\not\\rightarrowtail v$ for all traces $\\alpha$ and domains $v$. \nBy the above observation, every policy is semantically equivalent to one that has no edges from \ninactive\ndomains, \nso we may assume this condition without loss of generality. Subject to this assumption, we have the following: \n\n\\begin{theorem} \\label{thm:must-may-local} \nLet $\\mathcal{S} = {\\langle {{D}, {\\tt dom}, {A}} \\rangle}$ be a signature, and let $\\rightarrowtail$ be a \npolicy for this signature that has no edges from \ninactive\ndomains.  Suppose that for all systems $M$ for the signature $\\mathcal{S}$, \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$ iff \n$M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Then $\\rightarrowtail$ is local. \n\\end{theorem} \n\n\\begin{proof} \nWe prove the converse, that is, we show that if $\\rightarrowtail$ is not local, \nthen ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security with respect to \n$\\rightarrowtail$ differ on some system $M$. Suppose that $\\rightarrowtail$ is not local. \nBy Lemma~\\ref{lem:locality-equiv}, we may use the relations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$, \nso we have that there exist traces $\\alpha, \\beta\\in A^*$ and domains $u,v$ \nsuch that $\\alpha \\sim^\\Diamond_u \\beta$ and $\\alpha \\sim^\\Diamond_v \\beta$, \nand $\\alpha \\models u \\rightarrowtail v$ and $\\beta \\models u \\not\\rightarrowtail v$. \n\nBy Lemma~\\ref{mayta-cont-unwind}, we also have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v\\beta$. \nSince $\\rightarrowtail$ has no edges from \ninactive\ndomains, and $\\alpha \\models u \\rightarrowtail v$, \ndomain $u$ has actions.  Let $a$ be any action with ${\\tt dom}(a) = u$.   Then, by condition WSC, it follows that $\\alpha a {\\sim^{\\mathit{unw}}}_v \\beta a $. \nMoreover, since $\\alpha \\sim^\\Diamond_v \\beta$ and $\\beta \\sim^\\Diamond_v \\beta a$ (because $\\beta \\models u \\not\\rightarrowtail v$), \nwe have that $\\alpha \\sim^\\Diamond_v \\beta a$. By $\\alpha \\models u \\rightarrowtail v$ we have that \n$\\alpha a \\not \\sim^\\Diamond_v \\alpha$, so it follows that $\\alpha a \\not \\sim^\\Diamond_v \\beta a$. \n\nDefine $M$ to be the system with states $S = A^*$, \ninitial state $s_0 = \\epsilon$, transitions defined by $\\gamma \\cdot b =  \\gamma b$ for all \n$\\gamma \\in A^*$ and $b\\in A$, and observations defined by \n${\\tt obs}_w(\\gamma) = 0$ if $w\\neq v$ or $\\gamma \\not \\sim^\\Diamond_v \\alpha a$, \nand ${\\tt obs}_w(\\gamma) = 1$ otherwise, for all $\\gamma \\in A^*$. \nObviously, ${\\tt obs}_v(\\alpha a) = 1$. On the other hand, since $\\alpha a \\not \\sim^\\Diamond_v \\beta a$, \nwe have that ${\\tt obs}_v(\\beta a) = 0$. \n\nSince  $\\alpha a {\\sim^{\\mathit{unw}}}_v \\beta a $, it is immediate that $M$ is not \n${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \nTo complete the proof, we note that \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$, \nso that the two notions disagree on system $M$. \nTo see this, note that any insecurity must involve domain $v$, since \n${\\tt obs}_w(\\gamma) = 0$ for all $\\gamma$ and $w\\neq v$. \nHowever, on domain $v$, if $\\gamma \\sim^\\Diamond_v \\gamma'$ then \n$\\gamma \\not \\sim^\\Diamond_v \\alpha a$ iff $\\gamma' \\not \\sim^\\Diamond_v \\alpha a$, \nso we have  ${\\tt obs}_v(\\gamma) = {\\tt obs}_v(\\gamma')$, as required for ${{\\tt {ta}}^\\Diamond}$-security.  \n\\end{proof} \n\n\n\nGiven this result, one reasonable approach to the  possibility of conflicting interpretations\nof policies is to require that the policy be local, so that we are left with a single \nnotion of security that supports both the permissive and prohibitive interpretation of\npolicies. A potential disadvantage of this is that such a restriction results in a loss of \nexpressiveness: certain policies can no longer be expressed. The following result shows\nthat, in fact, provided that one is interested in ${{\\tt {ta}}^\\Box}$-security, there\nis no loss of expressiveness: for every policy, there is a local policy that is\nequivalent with respect to ${{\\tt {ta}}^\\Box}$-security. \n\n\n\\begin{lemma}\n\\label{lem:restrict-to-local}\n For every policy $\\rightarrowtail$ over signature $\\langle {D}, {\\tt dom}, {A}\\rangle$, there is a \n local policy ${\\rightarrowtail'} \\leq {\\rightarrowtail}$ such that \n for all systems $M$ with signature $\\langle {D}, {\\tt dom}, {A}\\rangle$, \n system $M$ is  ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail$ iff $M$ is  ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail'$. \n\\end{lemma}\n\n\n\n\\begin{proof}\nWe write $[\\alpha]_{{\\sim}}$ for the equivalence class of $\\alpha$ with respect to an equivalence relation ${\\sim}$. \nIn the following, the unwinding $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$ refers to the policy $\\rightarrowtail$.  \nDefine the policy $\\rightarrowtail'$ by\n\n", "itemtype": "equation", "pos": 65821, "prevtext": "\nand else\n$ {{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}({\\alpha})}$. \n\n\n\nThe formula \n$D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u) {\\Rightarrow} {{\\tt dom}(a) \\rightarrowtail u}$ is a \nvalidity of epistemic logic, so this definition strengthens the condition under which information is transmitted in the definition of ${{\\tt {ta}}^\\Diamond}$. \nIntuitively, this definition permits transmission of ${\\tt dom}(a)$'s information to $u$ only when \nit is distributed knowledge to $u$ and ${\\tt dom}(a)$ that ${\\tt dom}(a) \\rightarrowtail u$, \ni.e., there is not the possibility, so far as these domains jointly know, that there is an \nedge ${\\tt dom}(a) \\not\\rightarrowtail u$ that prohibits the transmission of information\nfrom ${\\tt dom}(a) $ to $u$. Thus, the  definition takes the point of view that transmission\nis permitted whenever the agents would jointly be able to confirm that there is not \nan explicit prohibition to the transmission. \n\nAs it stands, the definition of ${{\\tt {ta}}^\\Box}$ is incomplete, because in order to \ninterpret the condition $\\alpha \\models D_{\\{{\\tt dom}(a),u\\}}({\\tt dom}(a) \\rightarrowtail u) $, \nwe need an appropriate Kripke structure in order to evaluate the \ndistributed knowledge operator. We may take ${A}^*$ to be the set of \nworlds of this structure, and derive satisfaction of atomic propositions from the policy, but it remains to specify\nequivalence relations $\\sim_v$ for $v\\in {D}$. \nIntuitively, \nan equivalence $\\alpha \\sim_v \\beta$ holds when agent $v$ is not able to \ndistinguish between the traces $\\alpha$ and $\\beta$: whenever the system is\nin state $\\alpha$, agent $v$ considers it possible that the system is in state $\\beta$. \nWhat these equivalence relations should be is \nnot immediately apparent. We take the approach \nof identifying some constraints on these equivalence relations. \n\nFirst, consider the general constraint, that the way agent $u$'s state of \ninformation is updated when action $a$ is performed, should depend only on the \nprior state of information of $u$ and ${\\tt dom}(a)$. This can be captured at the \nlevel of the relations \n$\\sim_v$\nby means of the following constraint: \n\\begin{itemize} \n\\item[(WSC)] For all traces $\\alpha, \\beta$, and actions $a$, if $\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ then \n$\\alpha a\\sim_u\\beta a$.\n\\end{itemize}\n(We call this constraint WSC since it is essentially the same as Rushby's condition of \\emph{Weak Step Consistency} \\cite{rushby92}.) \nAlthough it  does not mention the policy explicitly, this constraint is not inconsistent \nwith the state of the policy being a factor in how $u$'s knowledge is updated. However, it \nrequires that the way that the policy is taken into account depends only on information\njointly available to domains $u$ and ${\\tt dom}(a)$. \n\nNext, to factor in the prohibitions to information transfer \nimplied by the \npolicy, note that one case where the policy clearly prohibits transfer of \ninformation from a domain ${\\tt dom}(a)$ to $u$ when action $a$ is performed\nafter sequence $\\alpha$ is where $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$. \nThus, domain $u$'s state of information in state $\\alpha a$ should be the same \nas its information in state $\\alpha$ in this case. This suggests the \nfollowing constraint: \n\\begin{itemize} \n\\item[(DLR)] For all traces $\\alpha$, and actions $a$, if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then \n$\\alpha a\\sim_u\\alpha$.\n\\end{itemize} \nThe nomenclature DLR arises from the fact that this is essentially a dynamic generalization of Rushby's condition of \\emph{Locally Respects} \\cite{rushby92}. \nA slightly stronger alternative of DLR is the following: \n\\begin{itemize} \n\\item[(DLR$'$)] For all traces $\\alpha$, and actions $a$, if there exists a trace $\\beta$ such that \n$\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ and \n$\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then \n$\\alpha a\\sim_u\\alpha$.\n\\end{itemize} \nIn fact, in the context of WSC, this is equivalent to DLR. \n\n\n\\begin{proposition}\\label{prop:LRprime} \nIf WSC then DLR iff DLR$'$.  \n\\end{proposition}  \n\n\\begin{proof} \nWe assume WSC and DLR and show DLR$'$. (The other direction is straightforward.) \nSuppose that \n$\\alpha \\sim_u\\beta$ and $\\alpha \\sim_{{\\tt dom}(a)}\\beta$ and \n$\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$.  We need to show \n$\\alpha a\\sim_u\\alpha$. By WSC, we have $\\alpha a \\sim_u \\beta a$. \nSince $\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$, we have by DLR that \n$\\beta a \\sim_u \\beta$. Two applications of transitivity now yield that \n$\\alpha a \\sim_u \\alpha$, as required. \n\\end{proof} \n\n\n\nSuppose that we now accept WSC and DLR as reasonable constraints on the\nequivalence relations $\\sim_u$ corresponding to the maximal knowledge that an agent $u$ is permitted \nto have. Indexed collections of equivalence relations may be partially ordered by pointwise containment. \n(That is, we take \\mbox{$\\{\\sim_u\\}_{u\\in D}  \\leq \\{\\sim'_u\\}_{u\\in D}$} if ${\\sim_u} \\subseteq {\\sim'_u}$ for all $u\\in D$.)  \nGiven the dynamic policy $\\rightarrowtail$, let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ be the \nsmallest collection of equivalence relations that is consistent with WSC and DLR. \nIntuitively, these smallest relations are the ones that\nallow for the {\\em maximal} amount of information flow in the system that is consistent with the \nconstraints. (The smaller the equivalence class, the larger the agent's amount of knowledge.)\nWe call these relations the \\emph{unwinding relations}. \nThe following fact will be useful below.\n\n\n\\begin{lemma} \\label{lem:unwmon}\nSuppose  ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ and $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ be the \nunwinding relations for the policies $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nThen ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \n\\end{lemma} \n\\begin{proof} \nSince ${\\tt dom}(a) \\not\\rightarrowtail' u$ implies ${\\tt dom}(a) \\not\\rightarrowtail u$, there are fewer cases of \nbasic facts $\\alpha a{\\sim^{\\mathit{unw}}}_u \\alpha$ than basic facts  $\\alpha a{\\approx^{\\mathit{unw}}}_u \\alpha$\nderivable using DLR. By monotonicity of WSC and the rules for an equivalence relation, \nit follows that ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \n\\end{proof}\n\n\n\n\nWe now take the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ as the equivalence relations \nin the Kripke structure needed to interpret the distributed knowledge operator in the \ndefinition of the functions ${{\\tt {ta}}^\\Box}_u$. We call the derived security notion\nassociated to these functions \\emph{${{\\tt {ta}}^\\Box}$-security}.  \n(Note that since, by reflexivity, if ${\\tt dom}(a) = u$ then $D_{\\{u, {\\tt dom}(a)\\}}({\\tt dom}(a) \\rightarrowtail u)$ \nis valid in this Kripke structure, these functions are self-aware, so \nagain, by Lemma~\\ref{lem:obs-view},  ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Box}$-view-security\nare equivalent.) \nFor $u\\in D$ we also write $\\sim^\\Box_u$ for the relation on traces defined by $\\alpha \\sim^\\Box_u \\beta$ \niff ${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$.  \n \nHowever, we note that we could also take the \nunwinding \nrelations directly as the \nbasis for another definition of security: \n\n\\begin{definition} \nA system is \\emph{unwinding-secure} with respect to a policy $\\rightarrowtail$ \nif, \nfor all traces $\\alpha,\\beta$ and domain~$u$, \nwe have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ implies ${\\tt obs}_u(s_0 \\cdot \\alpha) = {\\tt obs}_u(s_0 \\cdot \\beta)$.  \n\\end{definition}  \n\nIn fact, it turns out that this does not give a new definition of security. \nThe following result shows that the \nunwinding relations \ncorrespond precisely to the information \nflow modelled by the function ${{\\tt {ta}}^\\Box}$. \n\n\n\\begin{theorem} \n\\label{thm:mustunwind} \nWe have \n${{\\sim^{\\mathit{unw}}}_u} = {\\sim^\\Box_u}$ for all $u\\in D$. \n\\end{theorem} \n\n\\begin{proof}\nWe establish the containments ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim^\\Box_u}$ and ${\\sim^\\Box_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$. \n\nFor  ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim^\\Box_u}$, we argue by induction on the number of steps of a derivation \nof the statement $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ using rules WSC, DLR and the rules for an equivalence relation. \nThe cases for reflexivity, transitivity an symmetry are direct from the fact that $\\sim^\\Box_u$ has these properties. \nFor the DLR case, suppose that $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, so that we have \n$\\alpha a {\\sim^{\\mathit{unw}}}_u \\alpha$. By validity of the formula $D_G(\\phi) {\\Rightarrow} \\phi$, we  have also \n$\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, so by the definition of ${{\\tt {ta}}^\\Box}$ \nwe have $\\alpha a \\sim^\\Box_u \\alpha$, as required. \nFor the WSC case, suppose that \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha{\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta$, so that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta a$ by WSC. \nBy the inductive hypothesis, we have \n$\\alpha \\sim^\\Box_u \\beta$ and $\\alpha\\sim^\\Box_{{\\tt dom}(a)}\\beta$, \ni.e., ${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\beta)}$. \nMoreover, it also follows that \n $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$ iff \n $\\beta \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, so that the \n same case of the definition of ${{\\tt {ta}}^\\Box}$ is selected in both \n ${{{\\tt {ta}}^\\Box}_{u}({ \\alpha a})}$ and   ${{{\\tt {ta}}^\\Box}_{u}({ \\beta a})}$. \n It follows that ${{{\\tt {ta}}^\\Box}_{u}({ \\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}({ \\beta a})}$, \n i.e., $\\alpha a\\sim^\\Box_{{\\tt dom}(a)}\\beta a$, as required. \n\nFor  ${\\sim^\\Box_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$, we argue \nby induction on the combined length of $\\alpha$ and $\\beta$\nthat $\\alpha \\sim^\\Box_{{\\tt dom}(a)}\\beta $ implies $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta $.\nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial by reflexivity. \nBy symmetry, it suffices to consider the case of $\\alpha = \\alpha a$ and $\\beta$, where the result\nhas already been established for sequences of shorter combined length.\nWe suppose that  $\\alpha \\sim^\\Box_{{\\tt dom}(a)}\\beta $, i.e., \n${{{\\tt {ta}}^\\Box}_{u}({\\alpha a })} = {{{\\tt {ta}}^\\Box}_{u}({\\beta})}$, and show that $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta $.\nWe consider two cases, corresponding to the cases of the \ndefinition of ${{\\tt {ta}}^\\Box}$. \n\nIn the first case, we have $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, \nso that ${{{\\tt {ta}}^\\Box}_{u}({\\alpha})} = {{{\\tt {ta}}^\\Box}_{u}({\\alpha a})}$, and hence ${{{\\tt {ta}}^\\Box}_{u}({\\alpha})} = {{{\\tt {ta}}^\\Box}_{u}({\\beta})}$. \nBy induction, we have $\\alpha  {\\sim^{\\mathit{unw}}}_u \\beta$. \nSince $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, \nthere exists a trace $\\gamma$ such that \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\gamma$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\gamma$ and \n$\\gamma \\models {\\tt dom}(a) \\not\\rightarrowtail u$. The relation ${\\sim^{\\mathit{unw}}}_u$ satisfies WSC and DLR by definition, \nso by Proposition~\\ref{prop:LRprime} it also satisfies DLR$'$. \nThus,  we obtain that $\\alpha a {\\sim^{\\mathit{unw}}}_{u} \\alpha $. It now follows by transitivity that $\\alpha a {\\sim^{\\mathit{unw}}}_u\\beta$, as required. \n\nIn the second case, we have $\\alpha \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\rightarrowtail u)$,\nso that ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = ({{{\\tt {ta}}^\\Box}_{u}(\\alpha)}, {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)}, a)$. \nAssuming that   ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$, it follows that $\\beta \\neq \\epsilon$, \nso we may write $\\beta = \\beta' b$. If \n$\\beta' \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\not\\rightarrowtail u)$, then we may switch the roles\nof $\\alpha a$ and $\\beta' b$ and argue as above, so it suffices to consider the case where \n$\\beta' \\models D_{\\{{\\tt dom}(a), u\\}} ({\\tt dom}(a) \\rightarrowtail u)$. In this case, \nwe have ${{{\\tt {ta}}^\\Box}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Box}_{u}({\\beta'})}, {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, \nso it follows from ${{{\\tt {ta}}^\\Box}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Box}_{u}(\\beta)}$ that \n$a = b$ and \n${{{\\tt {ta}}^\\Box}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{u}({\\beta'})}$ \nand $ {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Box}_{{{\\tt dom}(a)}}({\\beta'})}$. \nThat is, we have $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta'$  and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \nBy WSC, it follows that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta' a = \\beta$, as required. \n\\end{proof} \n\n\n\nIt is immediate from Theorem~\\ref{thm:mustunwind}  that unwinding security and ${{\\tt {ta}}^\\Box}$-security \nare equivalent. Thus, these definitions lend support to each other and help to \nexplain each other: the functions ${{\\tt {ta}}^\\Box}$ give an intuitive, concrete description of \nthe information flows that are permitted when security is interpreted using the unwinding relations. \n\nMoreover, Theorem~\\ref{thm:mustunwind}  shows that ${{\\tt {ta}}^\\Box}$-security provides a feasible \ngeneral framework for security definitions. To instantiate this framework, we \nmust provide a collection of equivalence relations \n$\\{\\sim_u\\}_{u\\in D}$ \nto be used \nto interpret the distributed knowledge operator in the definition.   It is reasonable \nto ask that however we do so, it should be the case that \nthe resulting relations $\\{\\sim^\\Box_u\\}_{u\\in D}$ are exactly the relations \n$\\{\\sim_u\\}_{u\\in D}$, \nso that the definition of ${{\\tt {ta}}^\\Box}$ is self-consistent.\n\\footnote{It is worth noting that the circularity here is similar to the circularity in the \nsemantics of {\\em knowledge-based programs} \\cite{fhmvbook}.} \nTheorem~\\ref{thm:mustunwind} shows that this condition \nis in fact satisfiable. \n\nThere remains some circularity in this justification of the definitions of unwinding security and \n${{\\tt {ta}}^\\Box}$-security. In particular, these definitions\nare both based on the assumption that the constraints WSC and DLR are the only constraints\nthat should be applied to the flow of information in order to satisfy the policy, and that the \nresulting relations give an acceptable notion of permitted agent knowledge. However, if a case\ncan be made that further constraints should be placed on the semantics, then a comparison\nsimilar to that made above can be considered. \n\nThe next lemma shows that ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security. \n\n\\begin{lemma} \n\\label{mayta-cont-unwind} \nWe have ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}  = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ implies $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ for all $\\alpha, \\beta \\in {A}^*$ and all $u \\in {D}$. \nMoreover, ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security. \n\\end{lemma} \n\n\\begin{proof} \nBy induction on the combined length of $\\alpha$ and $\\beta$. \nThe base case is trivial by reflexivity. Consider the case of\n$\\alpha a $ and $\\beta$, and suppose ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$.\n\nIn case  $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$, we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$, \nso by induction we obtain $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. Also, by DLR, we have $\\alpha a {\\sim^{\\mathit{unw}}}_u \\alpha$. \nIt follows that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta$, as required. \n\nAlternately, if $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$, \nthen we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\alpha})},  {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha})} , a)$. \nIt follows that $\\beta \\neq\\epsilon$, so let $\\beta = \\beta' b$ for $b \\in A$. \nIn the case that $\\beta' \\models {{\\tt dom}(b) \\not\\rightarrowtail u}$, we may swap the roles of $\\alpha a$ and $\\beta' b$ and\nargue as in the previous paragraph. In case $\\beta' \\models {{\\tt dom}(b) \\rightarrowtail u}$, we have \n${{{\\tt {ta}}^\\Diamond}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})},  {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})} , b)$,  \nand it follows that $a=b$ and ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$. \nBy induction, we obtain that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)}\\beta'$.\nIt now follows by WSC that $\\alpha a {\\sim^{\\mathit{unw}}}_u \\beta' a = \\beta$, as required.   \n\\end{proof} \n\n\nThe following example shows that ${{\\tt {ta}}^\\Box}$-security differs from ${{\\tt {ta}}^\\Diamond}$-security. \n\\begin{example}\n As already seen in Example~\\ref{ex:conflict-ta}, the system in Figure~\\ref{fig:conflict} is ${{\\tt {ta}}^\\Diamond}$-secure. \n But, we have that $p {\\sim^{\\mathit{unw}}}_B \\epsilon$ and $p {\\sim^{\\mathit{unw}}}_A \\epsilon$ by WSC. \n By applying DLR, we obtain $pa {\\sim^{\\mathit{unw}}}_B a$. \n Using Theorem~\\ref{thm:mustunwind}, we have ${{{\\tt {ta}}^\\Box}_{B}({pa})} = {{{\\tt {ta}}^\\Box}_{B}(a)}$, and since \n ${\\tt obs}_B(s_0 \\cdot pa) \\neq {\\tt obs}_B(s_0 \\cdot a)$, the system is not ${{\\tt {ta}}^\\Box}$-secure. \n\\end{example}\n\n\n\\subsection{A sufficient condition for equivalence}\n\n\nThe outcome of the discussion so far is that we have identified two definitions of \nsecurity of dynamic policies, one of which (${{\\tt {ta}}^\\Diamond}$-security) takes a permissive\ninterpretation of policies, and the other $({{\\tt {ta}}^\\Box}$-security, or equivalently, unwinding security)\ntakes a prohibitive interpretation. As noted above, these two interpretations\nmay be in conflict for some policies. It is therefore of interest to \nunderstand when a policy is free of this conflict. The \nfollowing notion is useful in this regard. \n\n\\begin{definition} \n\\label{def:locality}\nA policy $\\rightarrowtail$ is {\\em local} \nwith respect to a collection of equivalence relations \n$\\{\\approx_u\\}_{u\\in D}$ on $A^*$ if, \nfor all domains $u,v\\in D$ and traces $\\alpha, \\beta\\in A^*$, if  \n$\\alpha \\approx_u \\beta $ and $\\alpha \\approx_v \\beta $ \nthen $\\alpha \\models {u \\rightarrowtail v}$ iff $\\beta \\models {u \\rightarrowtail v}$. \n\\end{definition} \n\nAn equivalent statement is that \n\n", "index": 13, "text": "$$\\alpha \\models D_{\\{u,v\\}}(u \\rightarrowtail v) \\lor D_{\\{u,v\\}}(u \\not\\rightarrowtail v)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\alpha\\models D_{\\{u,v\\}}(u\\rightarrowtail v)\\lor D_{\\{u,v\\}}(u\\not%&#10;\\rightarrowtail v)\" display=\"block\"><mrow><mi>\u03b1</mi><mo>\u22a7</mo><msub><mi>D</mi><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">}</mo></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>\u21a3</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2228</mo><msub><mi>D</mi><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">}</mo></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>\u21a3\u0338</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nIt is clear that ${\\rightarrowtail'} \\leq {\\rightarrowtail}$. \n\nLet $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in D}$ be the smallest unwinding satisfying WSC and DLR {with respect to\\xspace} the policy $\\rightarrowtail'$. \nWe claim that ${{\\sim^{\\mathit{unw}}}_u}  = {{\\approx^{\\mathit{unw}}}_u}$ for all $u\\in D$. \nBy Lemma~\\ref{lem:unwmon}, we have ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$.\n\n\nWe will show that for every $u \\in {D}$ and every $\\alpha, \\beta \\in {A}^*$, we have $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ implies $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. \nThe proof is by an induction on the length of the derivation of $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$. \nConsider a derivation of   $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ and suppose that the claim holds for all \nshorter derivations.  We need to show that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. The cases\nwhere the final step of the derivation are an application of reflexivity, symmetry or transitivity\nare straightforward from the fact that ${\\sim^{\\mathit{unw}}}_u$ is an equivalence relation. \nThere are two remaining cases: \n\n\\begin{itemize} \n\\item \\emph{Case 1:} $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ is derived using the condition DLR.\nHere we have that there exists $a\\in A$ such that  $\\alpha = \\beta a$ and $\\beta \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nThus, there exists a trace $\\gamma$ such that $\\gamma {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\gamma {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta$ such that $\\beta \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nBy Proposition~\\ref{prop:LRprime}, we have that ${\\sim^{\\mathit{unw}}}_u$ satisfies DLR$'$. It follows that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$.  \n\n\\item \n\\emph{Case 2:} $\\alpha{\\approx^{\\mathit{unw}}}_u \\beta$ is derived using condition WSC.\nHence we have $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$ with $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\approx^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \nBy applying the induction hypothesis, we have $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$ and by the WSC condition applied to ${\\sim^{\\mathit{unw}}}_u$, we have $\\alpha' a {\\sim^{\\mathit{unw}}}_u \\beta' a$. \n\\end{itemize} \nThis shows that the system $M$ is ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail$ if and only if it is ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail'$. \n\nIt remains to show that the policy $\\rightarrowtail'$ is ${{\\tt {ta}}^\\Diamond}$-local. \nFirst, we will show for every $u \\in {D}$ and every $\\alpha, \\beta \\in {A}^*$, that \n${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ ({with respect to\\xspace} $\\rightarrowtail'$) implies $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$. \nWe prove this by an induction on the combined length of $\\alpha$ and $\\beta$. \nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial by reflexivity of ${\\approx^{\\mathit{unw}}}_u$. \n\nAssume the claim for all traces of combined length shorter than $|\\alpha|+|\\beta|$. \nLet $\\alpha = \\alpha' a$ and suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. \nWe need to show that $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\beta$. \n\\begin{itemize}\n\\item  \n\\emph{Case 1:} $\\alpha' \\models {\\tt dom}(a) \\not\\rightarrowtail' u$. \nIn this case, we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha' a})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})}$, so ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$. \nBy induction hypothesis, we have $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta$.  By DLR, we have $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\alpha'$, \nso by transitivity we obtain $\\alpha' a  {\\approx^{\\mathit{unw}}}_u \\beta$. \n\\item \n\\emph{Case 2:} $\\alpha' \\models {{\\tt dom}(a) \\rightarrowtail' u}$. \nThen ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha' a})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})}, a)$, \nso $\\beta \\neq \\epsilon$ and we have \n $\\beta = \\beta' b$ for some $b\\in A$. \nWe may assume that $\\beta' \\models {{\\tt dom}(b) \\rightarrowtail' u}$, \nsince otherwise we may argue as in Case 1 for $\\beta' b$ and apply symmetry. \nIt follows that ${{{\\tt {ta}}^\\Diamond}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, \nand we conclude that \n$a= b$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$.\nBy induction hypothesis we have $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\approx^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$ and by WSC,  we obtain that $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\beta' a$. \n\\end{itemize} \nThe ${{\\tt {ta}}^\\Diamond}$-locality follows: if ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$ ({with respect to\\xspace} $\\rightarrowtail'$), then we have\n$\\alpha \\in [\\beta]_{{\\approx^{\\mathit{unw}}}_u} \\cap [\\beta]_{{\\approx^{\\mathit{unw}}}_v}$ and hence $\\alpha \\models {u \\rightarrowtail' v}$ iff $\\beta \\models {u \\rightarrowtail' v}$. \n\\end{proof}\n\n\nWe say that two policies $\\rightarrowtail$ and $\\rightarrowtail'$ for a common signature $\\langle D, {\\tt dom},A\\rangle$\nare \\emph{identical up to \ninactive\ndomains}, if for all domains $u,v\\in D$ such that the  set of actions ${\\tt dom}^{-1}(u)$ of domain $u$ is nonempty, \nwe have, for all $\\alpha\\in A^*$, that $\\alpha \\models {u \\rightarrowtail v}$ iff $\\alpha\\models {u \\rightarrowtail' v}$. \nIntuitively, this says that the two policies are identical, except that they may differ on edges $\\alpha\\models {u \\rightarrowtail' v}$\nfrom \ninactive domains $u$. \nSince  \nsuch a domain $u$ cannot take any action to cause information flow\nto $v$, this difference cannot, in practice, be detected. The following result makes this intuition precise.  \nSay that two policies  $\\rightarrowtail$ and $\\rightarrowtail'$ are two policies for a common signature are \\emph{equivalent} with respect to a\nnotion of security if for all systems $M$ for the signature, $M$ is secure with respect to $\\rightarrowtail$ iff $M$ is secure with respect to $\\rightarrowtail'$. \n\n\\begin{theorem} \nSuppose that $\\rightarrowtail$ and $\\rightarrowtail'$ are two policies for a common signature $\\langle D, {\\tt dom},A\\rangle$. \nThen $\\rightarrowtail$ and $\\rightarrowtail'$ are equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security iff\n$\\rightarrowtail$ and $\\rightarrowtail'$ are identical up to \ninactive \ndomains. \n\\end{theorem} \n\n\\begin{proof} \nIn this proof, ${\\tt {ta}}^{\\Diamond,\\rightarrowtail}$ and ${\\tt {ta}}^{\\Diamond,\\rightarrowtail'}$ denote the ${\\tt {ta}}^{\\Diamond}$ function that refers to $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nSuppose first that $\\rightarrowtail$ and $\\rightarrowtail'$ are identical up to \ninactive \ndomains. \nThen a straightforward induction on the length of $\\alpha\\in A^*$ shows that for all $u\\in D$, we have \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_u (\\alpha) = {\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_u (\\alpha)$. \n(Note that in the inductive case for ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})}$, we have that $a \\in {\\tt dom}^{-1}( {\\tt dom}(a)) \\neq \\emptyset$, \nso ${\\tt dom}(a) \\rightarrowtail u$ iff ${\\tt dom}(a) \\rightarrowtail' u$.) \nIt follows that $\\rightarrowtail$ and $\\rightarrowtail'$ are equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security. \n\nConversely, suppose that $\\rightarrowtail$ and $\\rightarrowtail'$ are not identical up to \ninactive \ndomains. \nWe show that they are not equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security.  \nWe have that there exists $\\alpha \\in A^*$ and domains $u,v$ with ${\\tt dom}^{-1}(u)$ nonempty, \nsuch that (without loss of generality) $\\alpha \\models {u \\rightarrowtail v}$  but not $\\alpha\\models {u \\rightarrowtail' v}$. \nLet $a$ be an action with ${\\tt dom}(a) = u$. Then \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_v (\\alpha a ) \\neq  {\\tt {ta}}^{\\Diamond,\\rightarrowtail}_v (\\alpha)$\nbut \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_v (\\alpha a ) =  {\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_v (\\alpha)$. \nDefine the system $M$ with states $S= A^*$, transitions $\\beta\\cdot b = \\beta b$ for all $\\beta\\in A^*$ and $b\\in A$, \nand observations given by \n${\\tt obs}_w(\\beta) = 0$ if either $w \\neq v$ or ${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_w (\\beta )\\neq  {\\tt {ta}}^{\\Diamond,\\rightarrowtail}_w (\\alpha)$, \notherwise ${\\tt obs}_w(\\beta) = 1$. \nThen, by construction, $M$ is $ {{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \nBut we have ${\\tt obs}_v(\\alpha a) = 0$ and ${\\tt obs}_v(\\alpha) = 1$,  so \n$M$ is  not $ {{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \nThus, these policies disagree on $M$. \n\\end{proof}\n\nIn particular, it follows that if $\\rightarrowtail'$ is a nonlocal policy that has no edges from \ninactive \ndomains \n(so that the reason for nonlocality is not trivial, in the sense that it must involve edges from a\ndomain with a nonempty set of actions), then there is no local policy that is equivalent \nwith respect to ${{\\tt {ta}}^\\Diamond}$-security.  Thus, ${{\\tt {ta}}^\\Diamond}$-security is inherently a \nmore expressive notion than ${{\\tt {ta}}^\\Box}$-security. \n\n\n\n\n\n\\subsection{Special Cases}\n\\label{sec:specialcases}\n\n To judge the adequacy of a definition of security with respect to \ndynamic policies, it is useful to \nverify that the definition gives the expected answer in \n a number of simple scenarios where\nwe have clear intuitions about the desired behaviour of the definition. \nThe following provide some examples. \n\n\\subsubsection{Static Policies:} \n\nWe say that a \ndynamic \npolicy \n$\\rightarrowtail \\subseteq {D}\\times A^*\\times {D}$ \nis \\emph{static}, if for all $\\alpha\\in A^*$ and $u,v\\in {D}$, we have \n$\\alpha \\models {u \\rightarrowtail v}$ iff $\\epsilon \\models {u \\rightarrowtail v}$. \nThat is, the policy never changes from its initial state. \nA static policy $\\rightarrowtail$ may equivalently be presented as the \nrelation \n$\\pi_{1,3}(\\rightarrowtail) \\subseteq {D} \\times {D}$, the projection \nof the dynamic policy to the first and third components, \nwhich is \nin \nprecisely the format for classical intransitive noninterference \npolicies \\cite{Goguen1982}. \n\nStatic policies are a special case of dynamic policies, that have been subject to \na significant amount of study \\cite{HY87,Roscoe1999,rushby92,Meyden15}, so it is reasonable to expect that \nany definition for dynamic policies should reduce to an accepted definition \nwhen applied to the static case. The following result shows that this is the case. \n\n\\begin{theorem} \nIf $\\rightarrowtail$ is a static policy, then the following \nare equivalent: \n\\begin{itemize} \n\\item $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$,  \n\\item $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$,  \n\\item $M$ is TA-secure with respect to $\\pi_{1,3}(\\rightarrowtail)$. \n\\end{itemize}  \n\\end{theorem} \n\n\\begin{proof} \nThis is immediate from the definitions, together with the fact that for static policies $\\rightarrowtail$, we have \n$\\alpha \\models u \\rightarrowtail v$ iff $\\alpha \\models D_{\\{u,v\\}} (u\\rightarrowtail v) $ iff \n$(u,v) \\in \\pi_{1,3}(\\rightarrowtail)$. \n\\end{proof} \n\nThis result shows that ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security agree and \ncollapse to the standard notion of ${\\tt {ta}}$-security when restricted\nto static policies. This provides support for these definitions. \n\n\\subsubsection{Globally known policies:} \n\n\nAnother setting \nthat can serve as a useful test case for the adequacy of \ndefinitions \nof security for dynamic policies \nis a group of agents subject to an information flow policy that is set by a \npolicy authority $P$, and in which all agents are permitted to know the \npolicy \nstate\nat all times. \n\nFormally, these are dynamic policies in which the set of domains contains $P$, \nand we have the following: \n\\begin{itemize} \n\\item[(GK1)] \nFor all traces $\\alpha$ and domains $u$,  we have that \n$\\alpha \\models {P \\rightarrowtail u}$. That is, domain $P$, which controls\nthe policy state, is always permitted to transmit information to $u$. \nThis ensures that $u$ is always able to know the policy state. \n \n\\item[(GK2)] For all traces $\\alpha,\\beta$ and domains $u,v$,  we have that \n$\\alpha |P = \\beta |P$ implies that \n$\\alpha \\models {u \\rightarrowtail v}$ iff  $\\beta \\models {u \\rightarrowtail v}$.  That is, the policy setting depends only on the \npast actions of domain $P$. \n\\end{itemize} \nWe say that a dynamic policy $\\rightarrowtail$ satisfying these conditions \nis {\\em globally known}. \n\n\\begin{theorem} \n\\label{thm:globally-known-implies-local}\nIf the policy $\\rightarrowtail$ is globally known, then it is local. \n\\end{theorem} \n\n\\begin{proof} \nSuppose that the policy $\\rightarrowtail$ is globally known. \nWe need to show that for all $u,v\\in D$ and $\\alpha, \\beta \\in A^*$, \nwe have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ and $\\alpha  {\\sim^{\\mathit{unw}}}_v\\beta$ implies \n$\\alpha \\models {u \\rightarrowtail v}$ iff  $\\beta \\models {u \\rightarrowtail v}$.  \nWe claim that, in fact, $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$ implies $\\alpha |P = \\beta |P$, \nfrom which the desired result follows using GK2. \n\nThe proof of the claim is by induction on the length of the derivation of $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$. \nThe base case of a step in which $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$ is reflexivity by reflexivity is trivial, \nand the cases of steps using symmetry or transitivity are also straightforward. \n\nConsider a step using DLR. Then $\\alpha = \\beta a$ and we have $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$. \nBy GK1, we have ${\\tt dom}(a) \\neq P$. Thus $\\alpha |P = \\alpha a |P = \\beta | P$, as required. \n\nFinally, consider a step using WSC. Then $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$ for some\naction $a$, and we have $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \n{From }  $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$, we obtain by induction that $\\alpha |P = \\beta|P$. \nIt follows that $\\alpha|P = \\alpha' a |P = \\beta' a|P = \\beta |P$, as required. \n\\end{proof} \n\n\n\n\nSince by Theorem~\\ref{thm:local-must-may}, for local policies the definitions of \n${{\\tt {ta}}^\\Diamond}$-security and  ${{\\tt {ta}}^\\Box}$-security are\nequivalent, these definitions are equivalent for all globally known policies, \nso these definitions lend mutual support to each other in this case. \n\n\n\\subsubsection{Locally known policies:} \n\nA slightly more general case in which the notions of \n${{\\tt {ta}}^\\Diamond}$-security and  ${{\\tt {ta}}^\\Box}$-security coincide\nare  policies in which agents\nare always aware of their incoming and/or outgoing policy edges. \nFormally, define say that the policy $\\rightarrowtail$ is \n\\emph{locally known to the sender} (with respect to equivalence relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}} $) \nif we have, for all $u, v\\in {D}$, that  \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ implies \n$\\alpha \\models {u \\rightarrowtail v}$  iff $\\beta \\models {u \\rightarrowtail v}$. \nSimilarly, say that \nthe policy $\\rightarrowtail$ is \n\\emph{locally known to the receiver} if we have, for all $u, v\\in {D}$, that  \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ implies \n$\\alpha \\models {v \\rightarrowtail u}$  iff $\\beta \\models {v \\rightarrowtail u}$. \nIt is easily seen that if the policy is locally known to the sender and/or the receiver\n(with respect to either $\\sim^{\\Box}$ or $\\sim^{\\Diamond}$), \nthen it is local. Thus, this again is  a case where the \nnotions of ${{\\tt {ta}}^\\Diamond}$-security  and ${{\\tt {ta}}^\\Box}$-security are equivalent. \n \n\n\n\n\n\n\\subsection{Related Work using Automaton Semantics} \\label{sec:related:aut} \n\n\n\nTo make the case for our definitions above, we now compare \nthem \nto related \nprior work that is also stated in an automaton based semantics. \n(We defer discussion of related programming language-based work to Section~\\ref{sec:relatedwork}.)  \nTo the best of our knowledge, the only other \nsemantics for dynamic intransitive noninterference \npolicies in \nautomaton-based systems are those of Leslie~\\cite{Leslie2006} and Eggert et. al.~\\cite{Eggert2013}. \nBoth works deal with policy enhanced systems. \nRecall that in this model, \nwe write $s \\models {u \\rightarrowtail v}$ iff information flow from $u$ to $v$ is allowed in the state~$s$. \n\n\nLeslie's definition of intransitive noninterference is a direct adaption of Rushby's ipurge function~\\cite{rushby92} to the dynamic setting. \nSimilar to Rushby's ipurge function, \nLeslie's purge function is based on a ``source\" function. \nFormally, \nthe dynamic version of this function is defined \nfor every $u \\in {D}$ and  $s \\in {S}$\nby ${{\\tt dsrc}({\\epsilon}, {u}, {s})} = \\{u \\}$\nand for $\\alpha \\in {A}^*$ and~$a \\in {A}$ by \n$ {{\\tt dsrc}({a \\alpha}, {u}, {s})} = {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})} \\cup \\{ {\\tt dom}(a) \\} $\n if there is some $v \\in {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})}$ with $s \\models {{\\tt dom}(a) \\rightarrowtail v}$, \nand else\n$\n  {{\\tt dsrc}({a \\alpha}, {u}, {s})} = {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})}\n$. \n\n\n\n\n\n\n\n\n\n\n\n\n\nIntuitively, the set ${{\\tt dsrc}({a\\alpha}, {u}, {s})}$ is the set of all agents, to which the information that the action $a$ has been performed, is transmitted by the sequence of actions $\\alpha$. \n\nLeslie's purge function for intransitive noninterference is inductively defined \nfor every $u \\in {D}$, $s \\in {S}$, $a \\in {A}$, and~$\\alpha \\in {A}^*$ by\n${{\\tt Lpurge}(\\epsilon, u, s)}  = \\epsilon$ and \n\n", "itemtype": "equation", "pos": 77422, "prevtext": "\nfor all traces $\\alpha$ and domains $u,v$, \nwhen the equivalence relation used to  interpret knowledge is $\\approx$-equivalence. \nThat is, a pair of agents always have distributed knowledge of whether \none may interfere with the other. \n\n\\begin{example} \nThe policy of Example~\\ref{ex:conflict-example} is  not a local policy\nwith respect to the relations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$. For, \nwe have $\\epsilon \\sim^\\Diamond_A p$ and $\\epsilon \\sim^\\Diamond_B p$, \nbut $\\epsilon \\models A \\not\\rightarrowtail B$ and $p \\models A \\rightarrowtail B$. \nWe present some examples of classes of local policies in Section~\\ref{sec:specialcases}. \n\\end{example} \n\nWe could instantiate the definition of locality with respect to either the equivalence relations\n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$ or $\\{\\sim^\\Box_u\\}_{u\\in D}$ (equivalently, the unwinding relations\n$\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$). \nIn fact, these definitions prove to be equivalent. \nWe first remark that, in general, the relations ${\\sim^{\\mathit{unw}}}_u$ differ from the relations  $\\sim^\\Diamond_u$. In particular, \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta $ does not imply $\\alpha \\sim^\\Diamond_u \\beta$. \n\\begin{example}\n In this example we proceed with the system of Figure~\\ref{fig:conflict}. \n By DLR, we have from $\\epsilon \\models {P \\not\\rightarrowtail B}$ that $p {\\sim^{\\mathit{unw}}}_B \\epsilon$ and from $\\epsilon \\models {P \\not\\rightarrowtail A}$ that $p {\\sim^{\\mathit{unw}}}_A \\epsilon$. \n By WSC, we have $p a {\\sim^{\\mathit{unw}}}_B a$. \n However, the ${{\\tt {ta}}^\\Diamond}$ values of $B$ differ: ${{{\\tt {ta}}^\\Diamond}_{{B}}({p a})} = (\\epsilon, \\epsilon, a) \\neq \\epsilon = {{{\\tt {ta}}^\\Diamond}_{B}(a)}$. \n\\end{example}\n\n \nHowever, the relations ${\\sim^{\\mathit{unw}}}_u$ and $\\sim^\\Diamond_u$ \\emph{are} identical \n for policies that are local with respect to the equivalence relations \n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$.  \n\n\\begin{lemma} \n\\label{lemma:eqi-mayta-unwind}\nLet $\\rightarrowtail$ be a local policy with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$.\nThen  $\\{\\sim^\\Diamond_u\\}_{u\\in D} =  \\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$. \n\\end{lemma} \n\\begin{proof} \nSuppose \nthat the policy $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$.  Then \nthese relations satisfy WSC. For, suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta})}$. \nNote that, by locality, we have that   $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail v}$ iff $\\beta \\models {{\\tt dom}(a) \\rightarrowtail v}$. \nIt follows that the same case is chosen in the definitions of \n${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})}$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\beta a})}$, and we obtain that  ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta a})}$.\n\nIt is immediate from the definition of ${{\\tt {ta}}^\\Diamond}$ that the relations \n$\\{\\sim^\\Diamond_u\\}_{u\\in D}$ satisfy DLR. By \nthe previous paragraph, these relations also \nsatisfy WSC. Since $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D}$ are the minimal relations satisfying WSC and DLR, \nwe obtain that $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D} \\leq \\{\\sim^\\Diamond_u\\}_{u\\in D}$. \nThe converse also holds by Lemma~\\ref{mayta-cont-unwind}.  \n\\end{proof} \n\nFrom this, we obtain the claimed independence of locality on the choice of equivalence relation. \n\n\\begin{lemma} \n\\label{lem:locality-equiv} \nA given policy $\\rightarrowtail$ is local with respect to the associated\nrelations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$ iff it is \nlocal with respect to the relations $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n\\end{lemma} \n\n\\begin{proof}\n First suppose that $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Diamond_u\\}_{u\\in D}$. \n Then by Lemma~\\ref{lemma:eqi-mayta-unwind} and Theorem~\\ref{thm:mustunwind}, we have \n $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u\\in D} = \\{\\sim^\\Diamond_u\\}_{u\\in D} =\\{\\sim^\\Box_u\\}_{u\\in D}$. \n Hence, $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n \n Suppose now that $\\rightarrowtail$ is local with respect to $\\{\\sim^\\Box_u\\}_{u\\in D}$. \n Let $u, v \\in {D}$ and $\\alpha, \\beta \\in {A}^*$ with ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$. \n By Lemma~\\ref{mayta-cont-unwind}, we have $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v \\beta$. \n By Theorem~\\ref{thm:mustunwind}, we have $\\alpha \\sim^\\Box_u \\beta$ and $\\alpha \\sim^\\Box_v \\beta$ and hence, $\\alpha \\models {u \\rightarrowtail v}$ iff $\\beta \\models {u \\rightarrowtail v}$. \n\\end{proof}\n\n\nConsequently, in the sequel we say simply that the policy is local,  \nif it is local with respect to either of these relations. \n\n\nThe following result shows that \nfor local policies, the conflict between a permissive and a prohibitive  reading of policies does not arise. \n\n\\begin{theorem} \n\\label{thm:local-must-may} \nIf $\\rightarrowtail$ is a local policy then ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security with \nrespect to $\\rightarrowtail$ are equivalent. \n\\end{theorem} \n\n\\begin{proof} \nThis is immediate from the fact that if the policy is local, then for all traces $\\alpha$, \nwe have $\\alpha \\models {u \\rightarrowtail v}$ iff  $\\alpha \\models D_{\\{u,v\\}}(u \\rightarrowtail v)$. \nThis claim follows straightforwardly from the properties of distributed knowledge.  \n\\end{proof} \n\n\nIndeed, locality  \\emph{exactly} captures the condition under which the permissive and the prohibitive interpretations of a policy are equivalent. \nWe need one technical condition on this statement. \nSay that a domain $u$ is \\emph{inactive} when ${\\tt dom}^{-1}(u) =\\emptyset$, i.e., the domain has no actions that it can perform, \nso it plays only the role of an observer in the system. \nNote that policy edges of the form $\\alpha \\models u\\rightarrowtail v$\nwhere \n$u$ is inactive \nhave no bearing on the definitions of ${{\\tt {ta}}^\\Diamond}$-security or unwinding-security (and hence also not on the equivalent \n${{\\tt {ta}}^\\Box}$-security) since all references to the policy in these definitions occur\nonly in the form $\\alpha \\models u\\rightarrowtail v$ with $u = {\\tt dom}(a)$ for some action $a$. \nIntuitively, the interference relation $u\\rightarrowtail v$ is  concerned with the ability of domain  $u$ to perform actions that \ntransfer information to domain $v$, and for a domain with no actions, such transfer of information is always impossible. \nWe say that policy $\\rightarrowtail$ \\emph{has no edges from \ninactive domains}, when for all domains $u$ that are inactive, \nwe have \n$\\alpha \\models u \\not\\rightarrowtail v$ for all traces $\\alpha$ and domains $v$. \nBy the above observation, every policy is semantically equivalent to one that has no edges from \ninactive\ndomains, \nso we may assume this condition without loss of generality. Subject to this assumption, we have the following: \n\n\\begin{theorem} \\label{thm:must-may-local} \nLet $\\mathcal{S} = {\\langle {{D}, {\\tt dom}, {A}} \\rangle}$ be a signature, and let $\\rightarrowtail$ be a \npolicy for this signature that has no edges from \ninactive\ndomains.  Suppose that for all systems $M$ for the signature $\\mathcal{S}$, \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$ iff \n$M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Then $\\rightarrowtail$ is local. \n\\end{theorem} \n\n\\begin{proof} \nWe prove the converse, that is, we show that if $\\rightarrowtail$ is not local, \nthen ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security with respect to \n$\\rightarrowtail$ differ on some system $M$. Suppose that $\\rightarrowtail$ is not local. \nBy Lemma~\\ref{lem:locality-equiv}, we may use the relations $\\{\\sim^\\Diamond_u\\}_{u\\in D}$, \nso we have that there exist traces $\\alpha, \\beta\\in A^*$ and domains $u,v$ \nsuch that $\\alpha \\sim^\\Diamond_u \\beta$ and $\\alpha \\sim^\\Diamond_v \\beta$, \nand $\\alpha \\models u \\rightarrowtail v$ and $\\beta \\models u \\not\\rightarrowtail v$. \n\nBy Lemma~\\ref{mayta-cont-unwind}, we also have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v\\beta$. \nSince $\\rightarrowtail$ has no edges from \ninactive\ndomains, and $\\alpha \\models u \\rightarrowtail v$, \ndomain $u$ has actions.  Let $a$ be any action with ${\\tt dom}(a) = u$.   Then, by condition WSC, it follows that $\\alpha a {\\sim^{\\mathit{unw}}}_v \\beta a $. \nMoreover, since $\\alpha \\sim^\\Diamond_v \\beta$ and $\\beta \\sim^\\Diamond_v \\beta a$ (because $\\beta \\models u \\not\\rightarrowtail v$), \nwe have that $\\alpha \\sim^\\Diamond_v \\beta a$. By $\\alpha \\models u \\rightarrowtail v$ we have that \n$\\alpha a \\not \\sim^\\Diamond_v \\alpha$, so it follows that $\\alpha a \\not \\sim^\\Diamond_v \\beta a$. \n\nDefine $M$ to be the system with states $S = A^*$, \ninitial state $s_0 = \\epsilon$, transitions defined by $\\gamma \\cdot b =  \\gamma b$ for all \n$\\gamma \\in A^*$ and $b\\in A$, and observations defined by \n${\\tt obs}_w(\\gamma) = 0$ if $w\\neq v$ or $\\gamma \\not \\sim^\\Diamond_v \\alpha a$, \nand ${\\tt obs}_w(\\gamma) = 1$ otherwise, for all $\\gamma \\in A^*$. \nObviously, ${\\tt obs}_v(\\alpha a) = 1$. On the other hand, since $\\alpha a \\not \\sim^\\Diamond_v \\beta a$, \nwe have that ${\\tt obs}_v(\\beta a) = 0$. \n\nSince  $\\alpha a {\\sim^{\\mathit{unw}}}_v \\beta a $, it is immediate that $M$ is not \n${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \nTo complete the proof, we note that \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$, \nso that the two notions disagree on system $M$. \nTo see this, note that any insecurity must involve domain $v$, since \n${\\tt obs}_w(\\gamma) = 0$ for all $\\gamma$ and $w\\neq v$. \nHowever, on domain $v$, if $\\gamma \\sim^\\Diamond_v \\gamma'$ then \n$\\gamma \\not \\sim^\\Diamond_v \\alpha a$ iff $\\gamma' \\not \\sim^\\Diamond_v \\alpha a$, \nso we have  ${\\tt obs}_v(\\gamma) = {\\tt obs}_v(\\gamma')$, as required for ${{\\tt {ta}}^\\Diamond}$-security.  \n\\end{proof} \n\n\n\nGiven this result, one reasonable approach to the  possibility of conflicting interpretations\nof policies is to require that the policy be local, so that we are left with a single \nnotion of security that supports both the permissive and prohibitive interpretation of\npolicies. A potential disadvantage of this is that such a restriction results in a loss of \nexpressiveness: certain policies can no longer be expressed. The following result shows\nthat, in fact, provided that one is interested in ${{\\tt {ta}}^\\Box}$-security, there\nis no loss of expressiveness: for every policy, there is a local policy that is\nequivalent with respect to ${{\\tt {ta}}^\\Box}$-security. \n\n\n\\begin{lemma}\n\\label{lem:restrict-to-local}\n For every policy $\\rightarrowtail$ over signature $\\langle {D}, {\\tt dom}, {A}\\rangle$, there is a \n local policy ${\\rightarrowtail'} \\leq {\\rightarrowtail}$ such that \n for all systems $M$ with signature $\\langle {D}, {\\tt dom}, {A}\\rangle$, \n system $M$ is  ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail$ iff $M$ is  ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail'$. \n\\end{lemma}\n\n\n\n\\begin{proof}\nWe write $[\\alpha]_{{\\sim}}$ for the equivalence class of $\\alpha$ with respect to an equivalence relation ${\\sim}$. \nIn the following, the unwinding $\\{ {\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$ refers to the policy $\\rightarrowtail$.  \nDefine the policy $\\rightarrowtail'$ by\n\n", "index": 15, "text": "\\begin{align*}\n \\alpha \\models {u \\rightarrowtail' v} \\text{ iff } \\beta \\models {u \\rightarrowtail v} \\text{ for all } \\beta \\in [\\alpha]_{{\\sim^{\\mathit{unw}}}_u} \\cap [\\alpha]_{{\\sim^{\\mathit{unw}}}_v} \n \\enspace. \n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\alpha\\models{u\\rightarrowtail^{\\prime}v}\\text{ iff }\\beta\\models%&#10;{u\\rightarrowtail v}\\text{ for all }\\beta\\in[\\alpha]_{{\\sim^{\\mathit{unw}}}_{u%&#10;}}\\cap[\\alpha]_{{\\sim^{\\mathit{unw}}}_{v}}\\@math@espace.\" display=\"inline\"><mrow><mrow><mi>\u03b1</mi><mo>\u22a7</mo><mi>u</mi><msup><mo>\u21a3</mo><mo>\u2032</mo></msup><mrow><mi>v</mi><mo>\u2062</mo><mtext>\u00a0iff\u00a0</mtext><mo>\u2062</mo><mi>\u03b2</mi></mrow><mo>\u22a7</mo><mi>u</mi><mo>\u21a3</mo><mrow><mi>v</mi><mo>\u2062</mo><mtext>\u00a0for all\u00a0</mtext><mo>\u2062</mo><mi>\u03b2</mi></mrow><mo>\u2208</mo><mrow><msub><mrow><mo stretchy=\"false\">[</mo><mi>\u03b1</mi><mo stretchy=\"false\">]</mo></mrow><mmultiscripts><mo>\u223c</mo><none/><mi>\ud835\udc62\ud835\udc5b\ud835\udc64</mi><mi>u</mi><none/></mmultiscripts></msub><mo>\u2229</mo><mrow><msub><mrow><mo stretchy=\"false\">[</mo><mi>\u03b1</mi><mo stretchy=\"false\">]</mo></mrow><mmultiscripts><mo>\u223c</mo><none/><mi>\ud835\udc62\ud835\udc5b\ud835\udc64</mi><mi>v</mi><none/></mmultiscripts></msub><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n if there is some $v \\in {{\\tt dsrc}({a \\alpha}, u, s)}$ with $s \\models {{\\tt dom}(a) \\rightarrowtail v}$, \nand else\n$\n {{\\tt Lpurge}({a \\alpha}, u, s)} = {{\\tt Lpurge}(\\alpha, u, {s \\cdot a})}\n$. \n\n\n\n\n\n\n\n\n\n\n\nThis function removes exactly those actions from a trace that are from agents where interference to $u$ is forbidden by the policy. \n\n\n\n\nThe corresponding security definition is:\n\\begin{definition}\n A system $M$ is ${\\tt Lpurge}$-secure with respect to a policy $\\rightarrowtail$ if for all domains $u$ and sequences of actions $\\alpha$ holds:  ${\\tt obs}_u(s_0 \\cdot {{\\tt Lpurge}(\\alpha, u, {s_0})}) = {\\tt obs}_u(s_0 \\cdot \\alpha)$. \n\\end{definition}\n\n\nOur notion of ${{\\tt {ta}}^\\Diamond}$-security is incomparable to ${\\tt Lpurge}$-security, in the sense that neither of them implies the other. \nOne the one hand, on systems with a static policy, ${\\tt Lpurge}$-security is equivalent to Rushby's IP-security and hence,  \nas shown in~\\cite{Meyden15}, strictly weaker than {TA-security\\xspace}, which is the equivalent to ${{\\tt {ta}}^\\Diamond}$-security on such systems. \nOn the other hand, the following example presents a ${{\\tt {ta}}^\\Diamond}$-secure, but not ${\\tt Lpurge}$-secure system. \n\n\n\n\n\n\n\n\n\n\n\n\\vspace*{-10pt} \n\\begin{example}\nWe consider again the system in Figure~\\ref{fig:conflict}. \nAs shown in Example~\\ref{ex:conflict-ta}, this system is ${{\\tt {ta}}^\\Diamond}$-secure. \n\n\n\n\n\n\nHowever the system is not ${\\tt Lpurge}$-secure, since we have\n\n$ {\\tt obs}_B(s_0 \\cdot {{\\tt Lpurge}({pa}, {B}, {s_0})}) \n   = {\\tt obs}_B(s_0 \\cdot {{\\tt Lpurge}({a}, {B}, {s_1})}) \n   = {\\tt obs}_B(s_0 \\cdot a)\n   = 0 \n   \\neq 1 \n   = {\\tt obs}_B(s_0 \\cdot pa)\n\n\n$. \n\\end{example}\n\n\\vspace*{-10pt} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimilar to ${{\\tt {ta}}^\\Diamond}$-security, ${\\tt Lpurge}$-security is not monotonic with respect to the restrictiveness order on policies. \n\n\n \\begin{figure}\n \\centering\n \\scalebox{0.78}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n  };\n   \\path[policy] (D) edge (L);\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\t\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n \\path[policy,dotted] (D) edge (L);\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n   \n\n  \\node[systemstate] (s3) [right=of s2] {\n $s_3$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 1$ \\\\\n };\n   \\path[policy] (D) edge (L);\n\n \\path (s0) edge node {$h$} (s1) \n (s0) edge [bend right=40] node[below] {$d$} (s3)\n (s1)  edge node {$d$} (s2)\n ;\n\\end{tikzpicture}\n}\n\\caption{Non-monotony of {\\tt Lpurge}-security}\n\\label{fig:unintuitive-property-leslie-security}\n\\end{figure} \n\n\n\\begin{example}\n\\label{example:counterintuitive-leslie}\nThe system in Figure~\\ref{fig:unintuitive-property-leslie-security} has two different configurations of the dynamic policy indicated by the dotted policy edge in state $s_1$: in one configuration there is an edge from $D$ to $L$ and in the other, this edge is \nabsent. \nFirst, consider the configuration where this edge exists. \nWith respect to {\\tt Lpurge}-security, this system is insecure, since we have \n\n${{\\tt Lpurge}({hd}, {L}, {s_0})} = {{\\tt Lpurge}({d}, {L}, {s_1})} = d$, \n\nbut ${\\tt obs}_L(s_0 \\cdot hd) = 0 \\neq 1 = {\\tt obs}_L(s_0 \\cdot d)$. \n\nHowever, if we remove the edge from $D$ to $L$ in state $s_1$, this system becomes {\\tt Lpurge}-secure: \nall traces starting with $h$ will be purged to $\\epsilon$ and all traces starting with $d$ have a purge value different from $\\epsilon$. \n\n\n\n\\end{example}\n\n\n\nOur notion of ${{\\tt {ta}}^\\Box}$ is strictly stronger than ${\\tt Lpurge}$-security. \nThat these two are indeed different follows from the same argument as above for systems with static policies. \n\n\n\n\\begin{lemma} \\label{must-imp-Lpurge} \n Every ${{\\tt {ta}}^\\Box}$-secure system is ${\\tt Lpurge}$-secure.\n\\end{lemma}\n\n\n\\begin{proof*} \n We show this lemma by contraposition. \n Suppose that the system is not ${\\tt Lpurge}$-secure. \n Then there are $u \\in {D}$ and $\\alpha \\in {A}^*$ with \n \n", "itemtype": "equation", "pos": 95492, "prevtext": "\nIt is clear that ${\\rightarrowtail'} \\leq {\\rightarrowtail}$. \n\nLet $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in D}$ be the smallest unwinding satisfying WSC and DLR {with respect to\\xspace} the policy $\\rightarrowtail'$. \nWe claim that ${{\\sim^{\\mathit{unw}}}_u}  = {{\\approx^{\\mathit{unw}}}_u}$ for all $u\\in D$. \nBy Lemma~\\ref{lem:unwmon}, we have ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$.\n\n\nWe will show that for every $u \\in {D}$ and every $\\alpha, \\beta \\in {A}^*$, we have $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ implies $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. \nThe proof is by an induction on the length of the derivation of $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$. \nConsider a derivation of   $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ and suppose that the claim holds for all \nshorter derivations.  We need to show that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$. The cases\nwhere the final step of the derivation are an application of reflexivity, symmetry or transitivity\nare straightforward from the fact that ${\\sim^{\\mathit{unw}}}_u$ is an equivalence relation. \nThere are two remaining cases: \n\n\\begin{itemize} \n\\item \\emph{Case 1:} $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ is derived using the condition DLR.\nHere we have that there exists $a\\in A$ such that  $\\alpha = \\beta a$ and $\\beta \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nThus, there exists a trace $\\gamma$ such that $\\gamma {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\gamma {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta$ such that $\\beta \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nBy Proposition~\\ref{prop:LRprime}, we have that ${\\sim^{\\mathit{unw}}}_u$ satisfies DLR$'$. It follows that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$.  \n\n\\item \n\\emph{Case 2:} $\\alpha{\\approx^{\\mathit{unw}}}_u \\beta$ is derived using condition WSC.\nHence we have $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$ with $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\approx^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \nBy applying the induction hypothesis, we have $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$ and by the WSC condition applied to ${\\sim^{\\mathit{unw}}}_u$, we have $\\alpha' a {\\sim^{\\mathit{unw}}}_u \\beta' a$. \n\\end{itemize} \nThis shows that the system $M$ is ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail$ if and only if it is ${{\\tt {ta}}^\\Box}$-secure {with respect to\\xspace} $\\rightarrowtail'$. \n\nIt remains to show that the policy $\\rightarrowtail'$ is ${{\\tt {ta}}^\\Diamond}$-local. \nFirst, we will show for every $u \\in {D}$ and every $\\alpha, \\beta \\in {A}^*$, that \n${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ ({with respect to\\xspace} $\\rightarrowtail'$) implies $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$. \nWe prove this by an induction on the combined length of $\\alpha$ and $\\beta$. \nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial by reflexivity of ${\\approx^{\\mathit{unw}}}_u$. \n\nAssume the claim for all traces of combined length shorter than $|\\alpha|+|\\beta|$. \nLet $\\alpha = \\alpha' a$ and suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. \nWe need to show that $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\beta$. \n\\begin{itemize}\n\\item  \n\\emph{Case 1:} $\\alpha' \\models {\\tt dom}(a) \\not\\rightarrowtail' u$. \nIn this case, we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha' a})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})}$, so ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta})}$. \nBy induction hypothesis, we have $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta$.  By DLR, we have $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\alpha'$, \nso by transitivity we obtain $\\alpha' a  {\\approx^{\\mathit{unw}}}_u \\beta$. \n\\item \n\\emph{Case 2:} $\\alpha' \\models {{\\tt dom}(a) \\rightarrowtail' u}$. \nThen ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha' a})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})}, a)$, \nso $\\beta \\neq \\epsilon$ and we have \n $\\beta = \\beta' b$ for some $b\\in A$. \nWe may assume that $\\beta' \\models {{\\tt dom}(b) \\rightarrowtail' u}$, \nsince otherwise we may argue as in Case 1 for $\\beta' b$ and apply symmetry. \nIt follows that ${{{\\tt {ta}}^\\Diamond}_{u}({\\beta' b})} = ({{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, \nand we conclude that \n$a= b$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$.\nBy induction hypothesis we have $\\alpha' {\\approx^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\approx^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$ and by WSC,  we obtain that $\\alpha' a {\\approx^{\\mathit{unw}}}_u \\beta' a$. \n\\end{itemize} \nThe ${{\\tt {ta}}^\\Diamond}$-locality follows: if ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$ ({with respect to\\xspace} $\\rightarrowtail'$), then we have\n$\\alpha \\in [\\beta]_{{\\approx^{\\mathit{unw}}}_u} \\cap [\\beta]_{{\\approx^{\\mathit{unw}}}_v}$ and hence $\\alpha \\models {u \\rightarrowtail' v}$ iff $\\beta \\models {u \\rightarrowtail' v}$. \n\\end{proof}\n\n\nWe say that two policies $\\rightarrowtail$ and $\\rightarrowtail'$ for a common signature $\\langle D, {\\tt dom},A\\rangle$\nare \\emph{identical up to \ninactive\ndomains}, if for all domains $u,v\\in D$ such that the  set of actions ${\\tt dom}^{-1}(u)$ of domain $u$ is nonempty, \nwe have, for all $\\alpha\\in A^*$, that $\\alpha \\models {u \\rightarrowtail v}$ iff $\\alpha\\models {u \\rightarrowtail' v}$. \nIntuitively, this says that the two policies are identical, except that they may differ on edges $\\alpha\\models {u \\rightarrowtail' v}$\nfrom \ninactive domains $u$. \nSince  \nsuch a domain $u$ cannot take any action to cause information flow\nto $v$, this difference cannot, in practice, be detected. The following result makes this intuition precise.  \nSay that two policies  $\\rightarrowtail$ and $\\rightarrowtail'$ are two policies for a common signature are \\emph{equivalent} with respect to a\nnotion of security if for all systems $M$ for the signature, $M$ is secure with respect to $\\rightarrowtail$ iff $M$ is secure with respect to $\\rightarrowtail'$. \n\n\\begin{theorem} \nSuppose that $\\rightarrowtail$ and $\\rightarrowtail'$ are two policies for a common signature $\\langle D, {\\tt dom},A\\rangle$. \nThen $\\rightarrowtail$ and $\\rightarrowtail'$ are equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security iff\n$\\rightarrowtail$ and $\\rightarrowtail'$ are identical up to \ninactive \ndomains. \n\\end{theorem} \n\n\\begin{proof} \nIn this proof, ${\\tt {ta}}^{\\Diamond,\\rightarrowtail}$ and ${\\tt {ta}}^{\\Diamond,\\rightarrowtail'}$ denote the ${\\tt {ta}}^{\\Diamond}$ function that refers to $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nSuppose first that $\\rightarrowtail$ and $\\rightarrowtail'$ are identical up to \ninactive \ndomains. \nThen a straightforward induction on the length of $\\alpha\\in A^*$ shows that for all $u\\in D$, we have \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_u (\\alpha) = {\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_u (\\alpha)$. \n(Note that in the inductive case for ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})}$, we have that $a \\in {\\tt dom}^{-1}( {\\tt dom}(a)) \\neq \\emptyset$, \nso ${\\tt dom}(a) \\rightarrowtail u$ iff ${\\tt dom}(a) \\rightarrowtail' u$.) \nIt follows that $\\rightarrowtail$ and $\\rightarrowtail'$ are equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security. \n\nConversely, suppose that $\\rightarrowtail$ and $\\rightarrowtail'$ are not identical up to \ninactive \ndomains. \nWe show that they are not equivalent with respect to ${{\\tt {ta}}^\\Diamond}$-security.  \nWe have that there exists $\\alpha \\in A^*$ and domains $u,v$ with ${\\tt dom}^{-1}(u)$ nonempty, \nsuch that (without loss of generality) $\\alpha \\models {u \\rightarrowtail v}$  but not $\\alpha\\models {u \\rightarrowtail' v}$. \nLet $a$ be an action with ${\\tt dom}(a) = u$. Then \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_v (\\alpha a ) \\neq  {\\tt {ta}}^{\\Diamond,\\rightarrowtail}_v (\\alpha)$\nbut \n${\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_v (\\alpha a ) =  {\\tt {ta}}^{\\Diamond,\\rightarrowtail'}_v (\\alpha)$. \nDefine the system $M$ with states $S= A^*$, transitions $\\beta\\cdot b = \\beta b$ for all $\\beta\\in A^*$ and $b\\in A$, \nand observations given by \n${\\tt obs}_w(\\beta) = 0$ if either $w \\neq v$ or ${\\tt {ta}}^{\\Diamond,\\rightarrowtail}_w (\\beta )\\neq  {\\tt {ta}}^{\\Diamond,\\rightarrowtail}_w (\\alpha)$, \notherwise ${\\tt obs}_w(\\beta) = 1$. \nThen, by construction, $M$ is $ {{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \nBut we have ${\\tt obs}_v(\\alpha a) = 0$ and ${\\tt obs}_v(\\alpha) = 1$,  so \n$M$ is  not $ {{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \nThus, these policies disagree on $M$. \n\\end{proof}\n\nIn particular, it follows that if $\\rightarrowtail'$ is a nonlocal policy that has no edges from \ninactive \ndomains \n(so that the reason for nonlocality is not trivial, in the sense that it must involve edges from a\ndomain with a nonempty set of actions), then there is no local policy that is equivalent \nwith respect to ${{\\tt {ta}}^\\Diamond}$-security.  Thus, ${{\\tt {ta}}^\\Diamond}$-security is inherently a \nmore expressive notion than ${{\\tt {ta}}^\\Box}$-security. \n\n\n\n\n\n\\subsection{Special Cases}\n\\label{sec:specialcases}\n\n To judge the adequacy of a definition of security with respect to \ndynamic policies, it is useful to \nverify that the definition gives the expected answer in \n a number of simple scenarios where\nwe have clear intuitions about the desired behaviour of the definition. \nThe following provide some examples. \n\n\\subsubsection{Static Policies:} \n\nWe say that a \ndynamic \npolicy \n$\\rightarrowtail \\subseteq {D}\\times A^*\\times {D}$ \nis \\emph{static}, if for all $\\alpha\\in A^*$ and $u,v\\in {D}$, we have \n$\\alpha \\models {u \\rightarrowtail v}$ iff $\\epsilon \\models {u \\rightarrowtail v}$. \nThat is, the policy never changes from its initial state. \nA static policy $\\rightarrowtail$ may equivalently be presented as the \nrelation \n$\\pi_{1,3}(\\rightarrowtail) \\subseteq {D} \\times {D}$, the projection \nof the dynamic policy to the first and third components, \nwhich is \nin \nprecisely the format for classical intransitive noninterference \npolicies \\cite{Goguen1982}. \n\nStatic policies are a special case of dynamic policies, that have been subject to \na significant amount of study \\cite{HY87,Roscoe1999,rushby92,Meyden15}, so it is reasonable to expect that \nany definition for dynamic policies should reduce to an accepted definition \nwhen applied to the static case. The following result shows that this is the case. \n\n\\begin{theorem} \nIf $\\rightarrowtail$ is a static policy, then the following \nare equivalent: \n\\begin{itemize} \n\\item $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$,  \n\\item $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$,  \n\\item $M$ is TA-secure with respect to $\\pi_{1,3}(\\rightarrowtail)$. \n\\end{itemize}  \n\\end{theorem} \n\n\\begin{proof} \nThis is immediate from the definitions, together with the fact that for static policies $\\rightarrowtail$, we have \n$\\alpha \\models u \\rightarrowtail v$ iff $\\alpha \\models D_{\\{u,v\\}} (u\\rightarrowtail v) $ iff \n$(u,v) \\in \\pi_{1,3}(\\rightarrowtail)$. \n\\end{proof} \n\nThis result shows that ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security agree and \ncollapse to the standard notion of ${\\tt {ta}}$-security when restricted\nto static policies. This provides support for these definitions. \n\n\\subsubsection{Globally known policies:} \n\n\nAnother setting \nthat can serve as a useful test case for the adequacy of \ndefinitions \nof security for dynamic policies \nis a group of agents subject to an information flow policy that is set by a \npolicy authority $P$, and in which all agents are permitted to know the \npolicy \nstate\nat all times. \n\nFormally, these are dynamic policies in which the set of domains contains $P$, \nand we have the following: \n\\begin{itemize} \n\\item[(GK1)] \nFor all traces $\\alpha$ and domains $u$,  we have that \n$\\alpha \\models {P \\rightarrowtail u}$. That is, domain $P$, which controls\nthe policy state, is always permitted to transmit information to $u$. \nThis ensures that $u$ is always able to know the policy state. \n \n\\item[(GK2)] For all traces $\\alpha,\\beta$ and domains $u,v$,  we have that \n$\\alpha |P = \\beta |P$ implies that \n$\\alpha \\models {u \\rightarrowtail v}$ iff  $\\beta \\models {u \\rightarrowtail v}$.  That is, the policy setting depends only on the \npast actions of domain $P$. \n\\end{itemize} \nWe say that a dynamic policy $\\rightarrowtail$ satisfying these conditions \nis {\\em globally known}. \n\n\\begin{theorem} \n\\label{thm:globally-known-implies-local}\nIf the policy $\\rightarrowtail$ is globally known, then it is local. \n\\end{theorem} \n\n\\begin{proof} \nSuppose that the policy $\\rightarrowtail$ is globally known. \nWe need to show that for all $u,v\\in D$ and $\\alpha, \\beta \\in A^*$, \nwe have $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ and $\\alpha  {\\sim^{\\mathit{unw}}}_v\\beta$ implies \n$\\alpha \\models {u \\rightarrowtail v}$ iff  $\\beta \\models {u \\rightarrowtail v}$.  \nWe claim that, in fact, $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$ implies $\\alpha |P = \\beta |P$, \nfrom which the desired result follows using GK2. \n\nThe proof of the claim is by induction on the length of the derivation of $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$. \nThe base case of a step in which $\\alpha  {\\sim^{\\mathit{unw}}}_u\\beta$ is reflexivity by reflexivity is trivial, \nand the cases of steps using symmetry or transitivity are also straightforward. \n\nConsider a step using DLR. Then $\\alpha = \\beta a$ and we have $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$. \nBy GK1, we have ${\\tt dom}(a) \\neq P$. Thus $\\alpha |P = \\alpha a |P = \\beta | P$, as required. \n\nFinally, consider a step using WSC. Then $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$ for some\naction $a$, and we have $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$ and $\\alpha' {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta'$. \n{From }  $\\alpha' {\\sim^{\\mathit{unw}}}_u \\beta'$, we obtain by induction that $\\alpha |P = \\beta|P$. \nIt follows that $\\alpha|P = \\alpha' a |P = \\beta' a|P = \\beta |P$, as required. \n\\end{proof} \n\n\n\n\nSince by Theorem~\\ref{thm:local-must-may}, for local policies the definitions of \n${{\\tt {ta}}^\\Diamond}$-security and  ${{\\tt {ta}}^\\Box}$-security are\nequivalent, these definitions are equivalent for all globally known policies, \nso these definitions lend mutual support to each other in this case. \n\n\n\\subsubsection{Locally known policies:} \n\nA slightly more general case in which the notions of \n${{\\tt {ta}}^\\Diamond}$-security and  ${{\\tt {ta}}^\\Box}$-security coincide\nare  policies in which agents\nare always aware of their incoming and/or outgoing policy edges. \nFormally, define say that the policy $\\rightarrowtail$ is \n\\emph{locally known to the sender} (with respect to equivalence relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}} $) \nif we have, for all $u, v\\in {D}$, that  \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ implies \n$\\alpha \\models {u \\rightarrowtail v}$  iff $\\beta \\models {u \\rightarrowtail v}$. \nSimilarly, say that \nthe policy $\\rightarrowtail$ is \n\\emph{locally known to the receiver} if we have, for all $u, v\\in {D}$, that  \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ implies \n$\\alpha \\models {v \\rightarrowtail u}$  iff $\\beta \\models {v \\rightarrowtail u}$. \nIt is easily seen that if the policy is locally known to the sender and/or the receiver\n(with respect to either $\\sim^{\\Box}$ or $\\sim^{\\Diamond}$), \nthen it is local. Thus, this again is  a case where the \nnotions of ${{\\tt {ta}}^\\Diamond}$-security  and ${{\\tt {ta}}^\\Box}$-security are equivalent. \n \n\n\n\n\n\n\\subsection{Related Work using Automaton Semantics} \\label{sec:related:aut} \n\n\n\nTo make the case for our definitions above, we now compare \nthem \nto related \nprior work that is also stated in an automaton based semantics. \n(We defer discussion of related programming language-based work to Section~\\ref{sec:relatedwork}.)  \nTo the best of our knowledge, the only other \nsemantics for dynamic intransitive noninterference \npolicies in \nautomaton-based systems are those of Leslie~\\cite{Leslie2006} and Eggert et. al.~\\cite{Eggert2013}. \nBoth works deal with policy enhanced systems. \nRecall that in this model, \nwe write $s \\models {u \\rightarrowtail v}$ iff information flow from $u$ to $v$ is allowed in the state~$s$. \n\n\nLeslie's definition of intransitive noninterference is a direct adaption of Rushby's ipurge function~\\cite{rushby92} to the dynamic setting. \nSimilar to Rushby's ipurge function, \nLeslie's purge function is based on a ``source\" function. \nFormally, \nthe dynamic version of this function is defined \nfor every $u \\in {D}$ and  $s \\in {S}$\nby ${{\\tt dsrc}({\\epsilon}, {u}, {s})} = \\{u \\}$\nand for $\\alpha \\in {A}^*$ and~$a \\in {A}$ by \n$ {{\\tt dsrc}({a \\alpha}, {u}, {s})} = {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})} \\cup \\{ {\\tt dom}(a) \\} $\n if there is some $v \\in {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})}$ with $s \\models {{\\tt dom}(a) \\rightarrowtail v}$, \nand else\n$\n  {{\\tt dsrc}({a \\alpha}, {u}, {s})} = {{\\tt dsrc}({\\alpha}, {u}, {s \\cdot a})}\n$. \n\n\n\n\n\n\n\n\n\n\n\n\n\nIntuitively, the set ${{\\tt dsrc}({a\\alpha}, {u}, {s})}$ is the set of all agents, to which the information that the action $a$ has been performed, is transmitted by the sequence of actions $\\alpha$. \n\nLeslie's purge function for intransitive noninterference is inductively defined \nfor every $u \\in {D}$, $s \\in {S}$, $a \\in {A}$, and~$\\alpha \\in {A}^*$ by\n${{\\tt Lpurge}(\\epsilon, u, s)}  = \\epsilon$ and \n\n", "index": 17, "text": "\\begin{align*}\n {{\\tt Lpurge}({a \\alpha}, u, s)} =  a \\; {{\\tt Lpurge}(\\alpha, u, {s \\cdot a})} \n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt Lpurge}({a\\alpha},u,s)}=a\\;{{\\tt Lpurge}(\\alpha,u,{s\\cdot a%&#10;})}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>\u03b1</mi></mrow><mo>,</mo><mi>u</mi><mo>,</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><mi>a</mi></mpadded><mo>\u2062</mo><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>u</mi><mo>,</mo><mrow><mi>s</mi><mo>\u22c5</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n\tWe will show the following claim: \n\tFor every $\\beta, \\beta' \\in {A}^*$ with $\\alpha = \\beta \\beta'$ and for every $\\gamma \\in {A}^*$ with ${{\\tt Lpurge}(\\alpha, u, {s_0})} = \\gamma \\; {{\\tt Lpurge}({\\beta'}, u, {s_0 \\cdot \\beta})}$ and for every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\beta})}$, we have $\\beta {\\sim^{\\mathit{unw}}}_v \\gamma$. \n\t\n\tWe prove this claim by an induction on $\\beta$. \n\tFor the base case with $\\beta = \\epsilon$, we have that $\\alpha = \\beta'$ and hence $\\gamma = \\epsilon$ from which the claim is immediate. \n\tFor the inductive step, let $\\beta = \\tilde \\beta b$ for some action $b$. \n\tThe induction hypothesis is: For some $\\gamma$ with ${{\\tt Lpurge}({\\alpha}, u, {s_0})} = \\gamma \\; {{\\tt Lpurge}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$ and every $v \\in {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$, we have $\\tilde\\beta {\\sim^{\\mathit{unw}}}_v \\gamma$. \n\n\tWe consider the following two cases: \n\t\\begin{itemize}\n\t \\item \n\t\\emph{Case 1: } ${\\tt dom}(a) \\notin {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$. \n\t\tIn this case, we have\n\t\n", "itemtype": "equation", "pos": 100314, "prevtext": "\n if there is some $v \\in {{\\tt dsrc}({a \\alpha}, u, s)}$ with $s \\models {{\\tt dom}(a) \\rightarrowtail v}$, \nand else\n$\n {{\\tt Lpurge}({a \\alpha}, u, s)} = {{\\tt Lpurge}(\\alpha, u, {s \\cdot a})}\n$. \n\n\n\n\n\n\n\n\n\n\n\nThis function removes exactly those actions from a trace that are from agents where interference to $u$ is forbidden by the policy. \n\n\n\n\nThe corresponding security definition is:\n\\begin{definition}\n A system $M$ is ${\\tt Lpurge}$-secure with respect to a policy $\\rightarrowtail$ if for all domains $u$ and sequences of actions $\\alpha$ holds:  ${\\tt obs}_u(s_0 \\cdot {{\\tt Lpurge}(\\alpha, u, {s_0})}) = {\\tt obs}_u(s_0 \\cdot \\alpha)$. \n\\end{definition}\n\n\nOur notion of ${{\\tt {ta}}^\\Diamond}$-security is incomparable to ${\\tt Lpurge}$-security, in the sense that neither of them implies the other. \nOne the one hand, on systems with a static policy, ${\\tt Lpurge}$-security is equivalent to Rushby's IP-security and hence,  \nas shown in~\\cite{Meyden15}, strictly weaker than {TA-security\\xspace}, which is the equivalent to ${{\\tt {ta}}^\\Diamond}$-security on such systems. \nOn the other hand, the following example presents a ${{\\tt {ta}}^\\Diamond}$-secure, but not ${\\tt Lpurge}$-secure system. \n\n\n\n\n\n\n\n\n\n\n\n\\vspace*{-10pt} \n\\begin{example}\nWe consider again the system in Figure~\\ref{fig:conflict}. \nAs shown in Example~\\ref{ex:conflict-ta}, this system is ${{\\tt {ta}}^\\Diamond}$-secure. \n\n\n\n\n\n\nHowever the system is not ${\\tt Lpurge}$-secure, since we have\n\n$ {\\tt obs}_B(s_0 \\cdot {{\\tt Lpurge}({pa}, {B}, {s_0})}) \n   = {\\tt obs}_B(s_0 \\cdot {{\\tt Lpurge}({a}, {B}, {s_1})}) \n   = {\\tt obs}_B(s_0 \\cdot a)\n   = 0 \n   \\neq 1 \n   = {\\tt obs}_B(s_0 \\cdot pa)\n\n\n$. \n\\end{example}\n\n\\vspace*{-10pt} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimilar to ${{\\tt {ta}}^\\Diamond}$-security, ${\\tt Lpurge}$-security is not monotonic with respect to the restrictiveness order on policies. \n\n\n \\begin{figure}\n \\centering\n \\scalebox{0.78}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n  };\n   \\path[policy] (D) edge (L);\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\t\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n \\path[policy,dotted] (D) edge (L);\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n   \n\n  \\node[systemstate] (s3) [right=of s2] {\n $s_3$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 1$ \\\\\n };\n   \\path[policy] (D) edge (L);\n\n \\path (s0) edge node {$h$} (s1) \n (s0) edge [bend right=40] node[below] {$d$} (s3)\n (s1)  edge node {$d$} (s2)\n ;\n\\end{tikzpicture}\n}\n\\caption{Non-monotony of {\\tt Lpurge}-security}\n\\label{fig:unintuitive-property-leslie-security}\n\\end{figure} \n\n\n\\begin{example}\n\\label{example:counterintuitive-leslie}\nThe system in Figure~\\ref{fig:unintuitive-property-leslie-security} has two different configurations of the dynamic policy indicated by the dotted policy edge in state $s_1$: in one configuration there is an edge from $D$ to $L$ and in the other, this edge is \nabsent. \nFirst, consider the configuration where this edge exists. \nWith respect to {\\tt Lpurge}-security, this system is insecure, since we have \n\n${{\\tt Lpurge}({hd}, {L}, {s_0})} = {{\\tt Lpurge}({d}, {L}, {s_1})} = d$, \n\nbut ${\\tt obs}_L(s_0 \\cdot hd) = 0 \\neq 1 = {\\tt obs}_L(s_0 \\cdot d)$. \n\nHowever, if we remove the edge from $D$ to $L$ in state $s_1$, this system becomes {\\tt Lpurge}-secure: \nall traces starting with $h$ will be purged to $\\epsilon$ and all traces starting with $d$ have a purge value different from $\\epsilon$. \n\n\n\n\\end{example}\n\n\n\nOur notion of ${{\\tt {ta}}^\\Box}$ is strictly stronger than ${\\tt Lpurge}$-security. \nThat these two are indeed different follows from the same argument as above for systems with static policies. \n\n\n\n\\begin{lemma} \\label{must-imp-Lpurge} \n Every ${{\\tt {ta}}^\\Box}$-secure system is ${\\tt Lpurge}$-secure.\n\\end{lemma}\n\n\n\\begin{proof*} \n We show this lemma by contraposition. \n Suppose that the system is not ${\\tt Lpurge}$-secure. \n Then there are $u \\in {D}$ and $\\alpha \\in {A}^*$ with \n \n", "index": 19, "text": "\\begin{align*}\n  {\\tt obs}_u(s_0 \\cdot \\alpha) \\neq {\\tt obs}_u(s_0 \\cdot {{\\tt Lpurge}(\\alpha, u, {s_0})})\n  \\enspace. \n \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\tt obs}_{u}(s_{0}\\cdot\\alpha)\\neq{\\tt obs}_{u}(s_{0}\\cdot{{\\tt&#10;Lpurge%&#10;}(\\alpha,u,{s_{0}})})\\@math@espace.\" display=\"inline\"><mrow><mrow><mrow><msub><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mi>\u03b1</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2260</mo><mrow><msub><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c</mi><mi>u</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>u</mi><mo>,</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n\tand \n\t\n", "itemtype": "equation", "pos": 101541, "prevtext": "\n\tWe will show the following claim: \n\tFor every $\\beta, \\beta' \\in {A}^*$ with $\\alpha = \\beta \\beta'$ and for every $\\gamma \\in {A}^*$ with ${{\\tt Lpurge}(\\alpha, u, {s_0})} = \\gamma \\; {{\\tt Lpurge}({\\beta'}, u, {s_0 \\cdot \\beta})}$ and for every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\beta})}$, we have $\\beta {\\sim^{\\mathit{unw}}}_v \\gamma$. \n\t\n\tWe prove this claim by an induction on $\\beta$. \n\tFor the base case with $\\beta = \\epsilon$, we have that $\\alpha = \\beta'$ and hence $\\gamma = \\epsilon$ from which the claim is immediate. \n\tFor the inductive step, let $\\beta = \\tilde \\beta b$ for some action $b$. \n\tThe induction hypothesis is: For some $\\gamma$ with ${{\\tt Lpurge}({\\alpha}, u, {s_0})} = \\gamma \\; {{\\tt Lpurge}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$ and every $v \\in {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$, we have $\\tilde\\beta {\\sim^{\\mathit{unw}}}_v \\gamma$. \n\n\tWe consider the following two cases: \n\t\\begin{itemize}\n\t \\item \n\t\\emph{Case 1: } ${\\tt dom}(a) \\notin {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$. \n\t\tIn this case, we have\n\t\n", "index": 21, "text": "\\begin{align*}\n\t{{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})} = {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})} \n\t\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt dsrc}({b\\beta^{\\prime}},u,{s_{0}\\cdot\\tilde{\\beta}})}={{\\tt&#10;dsrc%&#10;}({\\beta^{\\prime}},u,{s_{0}\\cdot\\tilde{\\beta}b})}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude8d\ud835\ude9c\ud835\ude9b\ud835\ude8c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>\u2062</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup></mrow><mo>,</mo><mi>u</mi><mo>,</mo><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\ud835\ude8d\ud835\ude9c\ud835\ude9b\ud835\ude8c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup><mo>,</mo><mi>u</mi><mo>,</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo>\u2062</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n\tHence, the new value of $\\gamma$ is the same as the previous value.\n\tAnd since ${s_0 \\cdot  \\tilde \\beta} \\models {{\\tt dom}(b) \\rightarrowtail v}$, by DLR, for every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$, we have $ \\tilde \\beta b {\\sim^{\\mathit{unw}}}_v  \\tilde \\beta$, and combined with $ \\tilde \\beta {\\sim^{\\mathit{unw}}}_v  \\gamma$ \n\tthe claim follows. \n\t\\item\n\t\\emph{Case 2: } ${\\tt dom}(a) \\in {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$. \n\tIn this case, we have ${{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})} = \\{{\\tt dom}(b) \\} \\cup {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$. \n\tSince \n\t\n", "itemtype": "equation", "pos": 101689, "prevtext": "\n\tand \n\t\n", "index": 23, "text": "\\begin{align*}\n\t{{\\tt Lpurge}({b \\beta'}, {u}, {s_0 \\cdot \\tilde \\beta})} = {{\\tt Lpurge}({\\beta'}, {u}, {s_0 \\cdot \\tilde \\beta b})}\n\t\\enspace. \n\t\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt Lpurge}({b\\beta^{\\prime}},{u},{s_{0}\\cdot\\tilde{\\beta}})}={%&#10;{\\tt Lpurge}({\\beta^{\\prime}},{u},{s_{0}\\cdot\\tilde{\\beta}b})}\\@math@espace.\" display=\"inline\"><mrow><mrow><mrow><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>\u2062</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup></mrow><mo>,</mo><mi>u</mi><mo>,</mo><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup><mo>,</mo><mi>u</mi><mo>,</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo>\u2062</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n\tthe new value of $\\gamma$ is $\\gamma' =\\gamma b$.\n\tFor every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$, we have $\\tilde \\beta {\\sim^{\\mathit{unw}}}_v \\gamma$ by induction hypothesis\n\t and additionally $ \\tilde \\beta {\\sim^{\\mathit{unw}}}_{{\\tt dom}(b)}  \\gamma$. \n\tFrom the condition WSC it follows for every such $v$: $ \\tilde \\beta b {\\sim^{\\mathit{unw}}}_v  \\gamma b = \\gamma'$. \n\tFrom this claim it follows $ \\alpha {\\sim^{\\mathit{unw}}}_u  \\; {{\\tt Lpurge}({\\alpha}, {u}, {s_0})}$ with $\\beta = \\alpha$ and hence the system is \\emph{not} ${{\\tt {ta}}^\\Box}$-secure. {\\hfill{$\\Box$}}\n\t\t\\end{itemize}\n\\end{proof*}\n\nIn \\cite{Eggert2013}, some problems with ${\\tt Lpurge}$-security are identified and a new purge-based security definition is proposed in response.  \nThis notion uses\nthe same dynamic sources function as Leslie's does, but the purge function does not change in the state parameter if an action has been removed. \nMore precisely, their dynamic intransitive purge function is defined for every $u \\in {D}$ and $s \\in {S}$ by\n${{\\tt ipurge}({\\epsilon}, {u}, {s})}  = \\epsilon$\nand for every $a \\in {A}$ and $\\alpha \\in {A}^*$ if ${\\tt dom}(a) \\in {{\\tt dsrc}({a \\alpha}, {u}, {s})}$, \nthen\n$\n {{\\tt ipurge}({a \\alpha}, {u}, {s})} = a \\; {{\\tt ipurge}({\\alpha}, {u}, {s\\cdot a})}\n$ \nand else\n$\n   {{\\tt ipurge}({a \\alpha}, {u}, {s})} = {{\\tt ipurge}({\\alpha}, {u}, {s})} \n$. \n\n\n\n\n\n\n\n\n\n\n\n\n\nThe notion of \n\\emph{i-security} is defined as usual as the property that for all agent $u$, all states $s$, and all action sequences $\\alpha$ and $\\beta$ with ${{\\tt ipurge}(\\alpha, u, s)} = {{\\tt ipurge}(\\beta, u, s)}$, we have ${\\tt obs}_u(s \\cdot \\alpha) = {\\tt obs}_u(s \\cdot \\beta)$. \n\n\nThis notion of security is incomparable with our security definitions of ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security.\nOn the one hand, we have, due to the static case, that i-security does not imply ${{\\tt {ta}}^\\Diamond}$-security. \t\nThe following example gives a system, with a local policy, that is ${{\\tt {ta}}^\\Box}$-secure and ${{\\tt {ta}}^\\Diamond}$-secure, but not i-secure.  \n\n\n \\begin{figure}\n \\centering\n \\scalebox{0.8}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n  };\n   \\path[policy] (D) edge (L);\n   \\path[policy] (H) edge (D);\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\t\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n  \\path[policy] (H) edge (D);\n  \n\n\n\n\n\n\n\n\n\n\n\n   \n    \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 1$ \\\\\n };\n   \\path[policy] (D) edge (L);\n   \\path[policy] (H) edge (D);\n\n   \n \\path (s0) edge node {$h$} (s1) \n       (s0) edge [bend right=40] node[below] {$d$} (s2)\n\n ;\n\\end{tikzpicture}\n}\n\\caption{A ${{\\tt {ta}}^\\Box}$-secure, but \\emph{not} i-secure system}\n\\label{fig:dtasecure-not-disecure}\n\\end{figure} \n\n\\vspace*{-10pt} \n\\begin{example}\n\\label{ex:dtasecure-not-disecure}\nThe system in Figure~\\ref{fig:dtasecure-not-disecure} is clearly \\emph{not} i-secure. \nWe consider the traces $h d $ and $d$ since the ${\\tt ipurge}$ values of these two traces are the same for $L$ if one starts purging in $s_0$:\n$\n {{\\tt ipurge}({h d}, {L}, {s_0})} = {{\\tt ipurge}({d}, L, {s_0})} = d\n\n$. \nBut the observations after these two traces are different for $L$. \n\nHowever, for any trace that starts with an $h$ action, the ${{\\tt {ta}}^\\Diamond}$ value is $\\epsilon$, and for any trace that starts with a $d$ action, the ${{\\tt {ta}}^\\Diamond}$ value differs from $\\epsilon$. \nHence, for any two traces that lead to different observations for $L$ have different ${{\\tt {ta}}^\\Diamond}$ values. \nNote, that the dynamic policy of this system is local, and hence, this system is also ${{\\tt {ta}}^\\Box}$-secure. \n\nWe would argue that this system is intuitively secure, so this gives grounds to prefer our two definitions over i-security. \nFirst, note that in every state $D$ is permitted to learn about $H$ actions, so, in particular, it should be permitted\nfor $D$ to know in state $s_0$ that $H$ has not yet acted. In state $s_2$, $L$ can deduce that $D$ acted before $H$ did, \nbut $D$ was permitted to transfer its information to $L$ when it acted, so this is not an insecurity. Finally, $L$ cannot distinguish state $s_1$ from $s_0$, \nso  this state is secure on the grounds that the initial state of a system always is (noninterference definitions, intuitively, aim\nto prohibit agents from learning information about what has happened in a system). \n\\end{example}\n\n\\vspace*{-10pt} \n\\begin{figure}\n\\centering\n \\begin{tikzpicture}\n \\node (mustta) {${{\\tt {ta}}^\\Box}$-security};\n \\node (mayta) [right=of mustta] {${{\\tt {ta}}^\\Diamond}$-security};\n \\node (isecurity) [below=of mustta] {i-security};\n \\node (lpurge) [right=of isecurity] {${\\tt Lpurge}$-security};\n \n \n \n \n \n \\draw (mustta) edge[->] (mayta);\n \\draw (mustta)\t edge[->] (lpurge);\n \\draw (isecurity) edge[->] (lpurge);\n \\end{tikzpicture}\n \\caption{Relations between dynamic intransitive noninterference definitions}\n \\label{fig:relation-security-definitions}\n\\end{figure}\n\nAlthough i-security implies ${\\tt Lpurge}$-security, Example~\\ref{ex:dtasecure-not-disecure} shows that these security definitions still differ on systems with local policies. \nThe implications of the security definitions analyzed in this work are depicted in Figure~\\ref{fig:relation-security-definitions}.\nAll these implications are strict in general, and the definitions of ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Diamond}$-security only collapse on systems with local policies. \n\nWe can summarize our reasons for preferring the definitions of the present paper to these prior works as \nfollows. First, both  ${\\tt Lpurge}$-security and i-security \nare \nequivalent to Rushby's IP-security\nin the case of static policies. This means that these definitions are \nare subject to the problems identified by van der Meyden \\cite{Meyden15}. \nOne of these problems is an example presented in \\cite{Meyden15}, which shows that Rushby's IP-security fails to detect a covert\nchannel based on ordering of actions.  A second weakness is that IP-security has a weaker relationship\nto the unwinding proof method for intransitive non-interference proposed by Rushby \\cite{rushby92} than does ${\\tt {ta}}$-security. \nAs shown in  \\cite{Meyden15}, this proof method is sound but not complete for IP-security, \nbut both sound and complete for {TA-security\\xspace}. Since the proof method is itself is based on well-founded intuitions,\n this lends further support to {TA-security\\xspace}. (We establish a related completeness result for\n ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Diamond}$-security with respect to local dynamic policies in the following section, that shows\n that a similar justification exists for these extensions of {TA-security\\xspace} to the dynamic case.) \nSecondly, when we consider ${\\tt Lpurge}$-security and i-security  with respect to \ndynamic policies, there are   examples for each where they give intuitively incorrect results. \nWe refer  to  \\cite{Eggert2013} for examples showing ${\\tt Lpurge}$-security yields\nundesirable conclusions. Example~\\ref{ex:dtasecure-not-disecure} shows that i-security \ncan also yield undesirable results.\n\n\n\\subsection{Policy Refinement} \n\nRecall that ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ says that policy $\\rightarrowtail$ is more restrictive than\npolicy $\\rightarrowtail'$. We therefore expect that if a system is secure with respect to $\\rightarrowtail$, \nit is also secure with respect to $\\rightarrowtail'$. The following result shows that ${{\\tt {ta}}^\\Box}$-security behaves as expected\nwith respect to this order. \n\n\\begin{proposition} \n\\label{prop:mustta-monotonic} \nIf ${\\rightarrowtail} \\leq {\\rightarrowtail'}$  and system $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$, \nthen $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail'$. \n\\end{proposition} \n\n\\begin{proof} \nThis follows from the equivalence of ${{\\tt {ta}}^\\Box}$-security and unwinding-security. \nLet ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ and $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ be the \nunwinding relations for the policies $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nBy Lemma~\\ref{lem:unwmon}, we have ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \nSuppose that \n$M$ is unwinding secure with respect to $\\rightarrowtail$. Then $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ \nimplies $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$, which yields ${\\tt obs}_u(s_0\\cdot \\alpha) = {\\tt obs}_u(s_0\\cdot \\beta)$, \nas required for $M$ to be secure with respect to $\\rightarrowtail'$. \n\\end{proof} \n\n\n\n\nThe following example illustrates a further subtlety concerning \n${{\\tt {ta}}^\\Diamond}$-security: unlike ${{\\tt {ta}}^\\Box}$-security, it is not monotonic with respect to \nthe restrictiveness order on policies. \n\n\\begin{example} \nFigure~\\ref{fig:refinement} shows a system and a policy $\\rightarrowtail$\n for two agents $A,B$. Only the observations of agent $B$ are depicted;\n for agent $A$ we assume that ${\\tt obs}_A(s) = 0$ for all states $s$, \n so that there can be no insecurity with respect to agent $A$. \n For agent $B$, the only possible cases of ${{\\tt {ta}}^\\Diamond}$-insecurity are \n when ${\\tt obs}_B(s_0\\cdot \\alpha) = 1 $ and ${\\tt obs}_B(s_0\\cdot \\beta)=0$. \n This implies that we have  $\\alpha = aba \\alpha'$ and that $aba$ is not a prefix of \n $\\beta$. However, in this case, ${{{\\tt {ta}}^\\Diamond}_{B}(\\beta)}$ cannot contain a subterm $a$, \n since there are no strict prefixes $\\gamma$ of $\\beta$ with $\\gamma \\models {A \\rightarrowtail B}$. \n On the other hand, ${{{\\tt {ta}}^\\Diamond}_{B}({aba \\alpha'})}$ always contains a subterm $a$, since \n${{{\\tt {ta}}^\\Diamond}_{B}({aba})} = ((\\epsilon,\\epsilon,b), (\\epsilon,\\epsilon,a), a)$. Thus, we cannot have \n ${{{\\tt {ta}}^\\Diamond}_{B}({aba \\alpha})} = {{{\\tt {ta}}^\\Diamond}_{B}(\\beta)}$. It follows that the system is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \nWe note that the policy $\\rightarrowtail$ is not local, because \n${{{\\tt {ta}}^\\Diamond}_{A}({ab})} = {{{\\tt {ta}}^\\Diamond}_{A}({ba})} = (\\epsilon, \\epsilon,a)$ and  ${{{\\tt {ta}}^\\Diamond}_{B}({ab})} = {{{\\tt {ta}}^\\Diamond}_{B}({ba})} = (\\epsilon, \\epsilon,b)$, \nbut $ab \\models {A \\rightarrowtail B}$ while $ba \\models {A \\not\\rightarrowtail B}$.  \n\n\n\\begin{figure}\n\\begin{center}\n\\scalebox{0.75}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n  };\n\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n    \\path[policy] (A) edge (B);\n   \n    \n  \\node[systemstate] (s4) [right=of s2] {\n $s_4$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n \n \n \\node[systemstate] (s3) [below=of s4] {\n $s_3$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 1$ \\\\\n };\n \n   \n \n   \n\n \n   \n\n \\node[systemstate] (s5) [below=of s0] {\n $s_5$ \n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n\n   \n \\node[systemstate] (s6) [right=of s5] {\n $s_6$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n  \n\n \\path (s0) edge node {$a$} (s1) \n (s1) edge node {$b$} (s2)\n (s2) edge node {$a$} (s3) \n (s2) edge node {$b$} (s4)\n (s0) edge node {$b$} (s5) \n (s5) edge node {$a$} (s6);\n\\end{tikzpicture}\n}\n\\end{center}\n\\caption{The permissive interpretation is not monotonic: policy $\\rightarrowtail$}\n\\label{fig:refinement}\n\\end{figure} \n\n\nOn the other hand, consider the policy $\\rightarrowtail'$, which is defined identically to $\\rightarrowtail$, except that on \nstate $s_6$ we take $s_6 \\models {A \\rightarrowtail' B}$. Plainly, ${\\rightarrowtail} \\leq {\\rightarrowtail'}$. \nHowever, the system is not ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \nNote that with respect to policy $\\rightarrowtail'$, \nwe have ${{{\\tt {ta}}^\\Diamond}_{B}({aba})} = ((\\epsilon,\\epsilon,b), (\\epsilon,\\epsilon,a), a) = {{{\\tt {ta}}^\\Diamond}_{B}({baa})}$, \nwhereas ${\\tt obs}_B(s_0\\cdot aba) = 1 $ and ${\\tt obs}_B(s_0\\cdot baa)=0$. \n\\end{example} \n\nHowever, for local policies, ${{\\tt {ta}}^\\Diamond}$-security behaves as expected. \nThis follows from Proposition~\\ref{prop:mustta-monotonic}, the equivalence of ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security \nfor local policies. The following result shows that, in fact it holds slightly more generally, \nand we can also use monotonicity to derive ${{\\tt {ta}}^\\Diamond}$-security for non-local policies. \n\n\\begin{proposition} \n\\label{prop:may-monotonic} \nSuppose that ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and that $\\rightarrowtail$ is \nlocal. \nIf a system $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$, then $M$ is \n${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$.\n\\end{proposition} \n\n\\begin{proof}\n Let $M$ be a ${{\\tt {ta}}^\\Diamond}$-secure system with respect to $\\rightarrowtail$. \n Since $\\rightarrowtail$ is local, we obtain from Theorem~\\ref{thm:local-must-may} that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \n By Proposition~\\ref{prop:mustta-monotonic}, the system is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail'$. \n Since ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security (by Lemma~\\ref{mayta-cont-unwind} and Theorem~\\ref{thm:mustunwind}), we have that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \n\\end{proof}\n\n\n\\section{Proof Techniques} \n\n\\label{sec:prooftechniques}\n\nIn the theory of static  (intransitive) noninterference  policies, \n{\\em unwinding relations} provide a proof technique that \ncan be used to show that a system is secure.  An unwinding\nrelation is a relation on the states of the system that \nsatisfies certain conditions. We show in this section that a similar technique applies \nto dynamic policies. In fact, the conditions that we need are very similar to those \ndefined on the policy above, with the main difference being that they are stated\nwith respect to states of the system rather than traces. \n\n\n\\subsection{Proof technique for ${{\\tt {ta}}^\\Box}$-security}\n\nLet \n$M$ be a system and let $\\approx_u$ be an equivalence \nrelation on the states of $M$ for each $u\\in {D}$. \n\n\\begin{itemize} \n\\item[(DLR$_M$)]   If $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$ then $s_0\\cdot \\alpha a \\approx_u s_0 \\cdot \\alpha$. \n\\item[(WSC$_M$)]   If $s \\approx_u t$ and $s \\approx_{{\\tt dom}(a)} t$ then $s\\cdot a \\approx_u t\\cdot a$. \n\\item[(OC$_M$)]   If $s \\approx_u t$ then ${\\tt obs}_u(s) = {\\tt obs}_u(t)$. \n\\end{itemize} \nWe call a collection $\\{\\approx_u \\}_{u\\in {D}}$ of equivalence relations satisfying DLR$_M$, WSC$_M$ and \nOC$_M$ a $\\Box$-unwinding on $M$ with respect to $\\rightarrowtail$.\n\nWe remark that for policy-enhanced systems, we have the following version of DLR$_M$: \n\\begin{itemize} \n\\item[(DLR-PE$_M$)]   If $s \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then $s\\cdot  a \\approx_u s$. \n\\end{itemize} \nwhich formulates the conditions to uniformly quantify over states of the system rather than both \nover states and traces. \nIt is straightforward to show that if a policy-enhanced system $M$ satisfies \nDLR-PE$_M$ then it satisfies DLR$_M$.\n\nThe following result states that to prove ${{\\tt {ta}}^\\Box}$-security, it suffices to  \nshow that there exists a $\\Box$-unwinding on the system.  \n\n\\begin{theorem} \n\\label{thm:unwind-mustsecure}\nSuppose that there exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M$ satisfying DLR$_M$, WSC$_M$ and OC$_M$ with respect to a \npolicy $\\rightarrowtail$. Then $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$.  \n\\end{theorem} \n\n\\begin{proof} \nTo show that $M$ is ${{\\tt {ta}}^\\Box}$-secure, we argue that the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$, which by definition satisfy WSC and DLR, also satisfy OC. \nFor this, we claim that for all $\\alpha, \\beta\\in A^*$, if \n$\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ then $s_0\\cdot \\alpha \\approx_u s_0\\cdot\\beta$.\nIt is  then immediate from OC$_M$ that OC holds for ${\\sim^{\\mathit{unw}}}_u$. \n\nThe proof of the claim is by induction on the derivation of $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$. \nThe cases of $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ obtained by reflexivity, symmetry or\ntransitivity are straightforward, using the fact that $\\approx_u$ has these\nproperties. For DLR, if $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ is obtained by an application of \nDLR then $\\alpha = \\beta a$ for some $a\\in A$ with $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nBy DLR$_M$, we have ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$, as required. \nFor WSC, suppose that $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ is obtained by an application of WSC, \nso that we have $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$. where \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta$. \nBy induction, we have $s_0 \\cdot \\alpha' \\approx_u s_0 \\cdot \\beta'$ and $s_0 \\cdot \\alpha' \\approx_{{\\tt dom}(a)} s_0 \\cdot \\beta'$. \nWe now obtain $s_0 \\cdot \\alpha' a\\approx_u s_0 \\cdot \\beta' a $ by WSC$_M$, i.e., \n$s_0 \\cdot \\alpha\\approx_u s_0 \\cdot \\beta$, as required. \n\\end{proof} \n\nAn unwinding on the system can often be naturally defined.  \nWe give an example below in the case of access control systems. \n\n\nWe may also show that unwindings provide a complete proof method, \nmodulo the fact that we may need to work in a bisimilar system, rather\nthan the system as presented. (See \\cite{Meyden15} for an example that demonstrates\nthat, already for static policies, we do not obtain completeness if we \nrequire that the unwinding be defined over the states of the system $M$ itself. \nA more complex type of unwinding on the system $M$ itself is shown to be complete for {TA-security\\xspace} of static policies \nin \\cite{EggertMSW13}. It would be interesting to develop a generalization of this to the \ndynamic case, but we leave this for future work.)\n\n\\begin{theorem} \nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Then there \nexists a system $M'$ that is bisimilar to $M$ (specifically, we may take $M'= {\\mathit{unfold}}(M)$), \nsuch that there exist equivalence relations $\\{\\approx'_u\\}_{u \\in {D}}$ on the states\nof  $M'$ satisfying DLR$_{M'}$, WSC$_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. \n\\end{theorem} \n\n\\begin{proof} \nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \nThen the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$ are defined on the states of \n$M'= {\\mathit{unfold}}(M)$, and  by definition, satisfy WSC and $DLR$. \nThese are equivalent to WSC$_{M'}$ and DLR$_{M'}$. \nMoreover, by Theorem~\\ref{thm:mustunwind}, we have that ${{\\sim^{\\mathit{unw}}}_u} = {\\sim^\\Box_u}$ for all $u\\in D$, \nso OC$_{M'}$ follows from the fact that $M$ is ${{\\tt {ta}}^\\Box}$-secure. \n\\end{proof} \n\n\n\\subsection{Proof technique for ${{\\tt {ta}}^\\Diamond}$-security} \n\nA similar proof theory can be developed for the notion ${{\\tt {ta}}^\\Diamond}$-security. \nWe replace the condition WSC$_M$ by the following:  \n\n\\begin{itemize} \n\\item[(WSC$^\\Diamond_M$)]   If $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ and $\\beta  \\models {{\\tt dom}(a) \\rightarrowtail u}$  and ${s_0\\cdot \\alpha}  \\approx_u {s_0 \\cdot \\beta}$ \nand ${s_0\\cdot \\alpha} \\approx_{{\\tt dom}(a)} {s_0 \\cdot \\beta}$ \nthen ${s_0\\cdot \\alpha a} \\approx_u {s_0 \\cdot \\beta a}$. \n\\end{itemize} \nOn policy enhanced systems $M$, it is  easily seen that the following variant is sufficient for WSC$^\\Diamond_M$ to hold:\n\\begin{itemize} \n\\item[(WSC-PE$^\\Diamond_M$)]   If $s\\models {{\\tt dom}(a) \\rightarrowtail u}$ and $t  \\models {{\\tt dom}(a) \\rightarrowtail u}$  and $s \\approx_u t $ \nand $s  \\approx_{{\\tt dom}(a)} t $ \nthen ${s\\cdot  a} \\approx_u {t \\cdot a}$. \n\\end{itemize} \n\n\\begin{theorem} \n\\label{thm:unwind-maysecure}\nSuppose that there exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M$ satisfying DLR$_M$, WSC$^\\Diamond_M$ and OC$_M$ with respect to a \npolicy $\\rightarrowtail$. Then $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$.  \n\\end{theorem} \n\n\\begin{proof*} \nWe claim that for all $\\alpha,\\beta \\in A^*$ we have ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ implies\nthat $s_0 \\cdot \\alpha  \\approx_u s_0\\cdot \\beta $. It follows from this using  OC$_M$ that \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure. \n\nTo prove the claim we proceed by induction on $|\\alpha| + |\\beta|$. \nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial. \nFor the inductive case, suppose (without loss of generality) that $\\alpha = \\alpha' a$, and we have \n${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}= {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. There are two possibilities: \n\\begin{itemize} \n\\item $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. In this case we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$, so by the inductive hypothesis, \nwe have ${s_0\\cdot \\alpha'} \\approx_u {s_0\\cdot \\beta}$. By DLR$_M$, we also have that ${s_0\\cdot \\alpha' a} \\approx_u {s_0\\cdot \\alpha'}$. \nSince $\\approx_u$ is an equivalence relation, we have ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$. \n\n\\item $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$. \nIn this case, ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = ( {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}, {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}, a)$. It follows that $\\beta \\neq \\epsilon$,\nso we may write $\\beta = \\beta' b$ for some $\\beta'\\in A^*$ and $b\\in A$. If $\\beta' \\models {{\\tt dom}(b) \\not\\rightarrowtail u}$, \nwe may reverse the roles of $\\alpha$ and $\\beta$ and obtain that  ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$ using the argument of the previous case.  \nIf $\\beta'\\models {{\\tt dom}(b) \\rightarrowtail u}$, then ${{{\\tt {ta}}^\\Diamond}_{u}(\\beta)} = ( {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}, {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, and we\nconclude that $a=b$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$. \nBy the inductive hypothesis, we have ${s_0\\cdot\\alpha'} \\approx_u {s_0\\cdot\\beta'}$ and ${s_0\\cdot\\alpha'} \\approx_{{\\tt dom}(a)} {s_0\\cdot\\beta'}$. \nUsing WSC$^\\Diamond_M$ it follows that ${s_0\\cdot\\alpha' a} \\approx_u {s_0\\cdot\\beta' a}$, i.e., ${s_0\\cdot\\alpha} \\approx_u {s_0\\cdot\\beta}$. \n{\\hfill{$\\Box$}} \n\\end{itemize} \n\\end{proof*} \nWe also have completeness of the technique, provided \nwe allow its application on a bisimilar system: \n\n\\begin{theorem} \n\\label{thm:unwind-mustsecure}\nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$.  \nThen there exists a system $M'$ that is bisimilar to $M$ and \nthere exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M'$ satisfying DLR$_{M'}$, WSC$^\\Diamond_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. \n\\end{theorem} \n\n\\begin{proof} Let $M = {\\langle {S, s_0, \\rightarrow, {D}, {\\tt dom}, {A}, {\\tt obs}} \\rangle}$. \nWe take $M' = {\\langle {S', s'_0, \\rightarrow', {D}, {\\tt dom}, {A}, {\\tt obs}'} \\rangle}$  to be the system \nover the same signature $({D}, {\\tt dom}, {A})$\nwith states $S' = A^*$, initial state $s_0' = \\epsilon$, \ntransitions $\\rightarrow'$ defined by $\\alpha \\cdot a = \\alpha a$ for all $\\alpha \\in A^*$, and observations defined\n${\\tt obs}'_u(\\alpha) = {\\tt obs}_u(s_0\\cdot\\alpha)$ for all $\\alpha \\in S'$. It is easily checked that this system\nis bisimilar to $M$. \n\nWe show that the relations $\\{\\sim^\\Diamond_u\\}_{u \\in {D}}$ satisfy  DLR$_{M'}$, WSC$^\\Diamond_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. Note that for all $\\alpha\\in A^*$, we have $s_0'\\cdot \\alpha  = \\alpha$. \nFor condition DLR$_{M'}$, note that if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}$, \nso $\\alpha a \\sim^\\Diamond_u\\alpha$. \nFor condition WSC$^\\Diamond_{M'}$, note that  if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$\nand  $\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$ and $\\alpha  \\sim^\\Diamond_u\\beta$ and \n$\\alpha  \\sim^\\Diamond_{{\\tt dom}(a)}\\beta$ then \n", "itemtype": "equation", "pos": 102501, "prevtext": "\n\tHence, the new value of $\\gamma$ is the same as the previous value.\n\tAnd since ${s_0 \\cdot  \\tilde \\beta} \\models {{\\tt dom}(b) \\rightarrowtail v}$, by DLR, for every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$, we have $ \\tilde \\beta b {\\sim^{\\mathit{unw}}}_v  \\tilde \\beta$, and combined with $ \\tilde \\beta {\\sim^{\\mathit{unw}}}_v  \\gamma$ \n\tthe claim follows. \n\t\\item\n\t\\emph{Case 2: } ${\\tt dom}(a) \\in {{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})}$. \n\tIn this case, we have ${{\\tt dsrc}({b \\beta'}, u, {s_0 \\cdot \\tilde \\beta})} = \\{{\\tt dom}(b) \\} \\cup {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$. \n\tSince \n\t\n", "index": 25, "text": "\\begin{align*}\n\t{{\\tt Lpurge}({\\alpha}, {u }, {s_0})} & = \\gamma \\; {{\\tt Lpurge}({b \\beta'}, {u }, {s_0 \\cdot \\tilde \\beta})} \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t& = \\gamma b \\; {{\\tt Lpurge}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})} \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\enspace, \n\t\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt Lpurge}({\\alpha},{u},{s_{0}})}\" display=\"inline\"><mrow><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>u</mi><mo>,</mo><msub><mi>s</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\gamma\\;{{\\tt Lpurge}({b\\beta^{\\prime}},{u},{s_{0}\\cdot\\tilde{%&#10;\\beta}})}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><mi>\u03b3</mi></mpadded><mo>\u2062</mo><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>\u2062</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup></mrow><mo>,</mo><mi>u</mi><mo>,</mo><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\gamma b\\;{{\\tt Lpurge}({\\beta^{\\prime}},u,{s_{0}\\cdot\\tilde{%&#10;\\beta}b})}\\@math@espace,\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><mi>b</mi></mpadded><mo>\u2062</mo><mi>\ud835\ude7b\ud835\ude99\ud835\ude9e\ud835\ude9b\ud835\ude90\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\u03b2</mi><mo>\u2032</mo></msup><mo>,</mo><mi>u</mi><mo>,</mo><mrow><mrow><msub><mi>s</mi><mn>0</mn></msub><mo>\u22c5</mo><mover accent=\"true\"><mi>\u03b2</mi><mo stretchy=\"false\">~</mo></mover></mrow><mo>\u2062</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": " \nhence $\\alpha a \\sim^\\Diamond_u \\beta a$. \nCondition OC$_{M'}$  is immediate from the fact that $M$ (and hence $M'$) is ${{\\tt {ta}}^\\Diamond}$-secure. \n\\end{proof} \n\n\n\\section{Access Control \nin Dynamic Systems}\n\\label{sec:accesscontrolinterpretation}\n\nAccess control monitors are a fundamental security mechanism\nthat can be used to enforce a variety of policies. Rushby \\cite{rushby92} \nshowed that access control can provide a sound enforcement \nmechanism for static intransitive noninterference policies, and that a simple static check of the access control table suffices\nto verify the policy will be enforced. It was later shown by van der Meyden \n\\cite{Meyden15} that, in fact, access control is also a \\emph{complete} enforcement mechanism\nfor such policies, in the sense that every system that satisfies the policy is \nbisimilar to one using access control, with a setting that satisfies the static check.  \nIn this section, we develop a generalization of these results to \ndynamic noninterference policies. \n\nA system with structured state, is a system equipped with \n\\begin{itemize}\n  \\item a set of all possible objects ${O}$, \n  \\item a set of all possible values ${V}$, \n  \\item a function ${\\tt contents} \\colon {O} \\times {S} \\rightarrow {V}$, \n   \\item a function ${\\tt observe} \\colon {D} \\times {S} \\rightarrow {\\mathcal{P}({{O}})}$, \n   \\item a function ${\\tt alter} \\colon {D} \\times {S} \\rightarrow {\\mathcal{P}({{O}})}$. \n\\end{itemize}\nIntuitively, ${{\\tt contents}({o}, {s})}$ is the value of object $o$ in state $s$, \n${{\\tt observe}({u}, {s})}$ is the set of objects that domain $u$ is permitted to observe (or read) in state $s$, \nand ${{\\tt alter}({u}, {s})}$ is the set of objects that domain $u$ is permitted to alter (or write) in state $s$. \nThe pair of functions ${\\tt observe}, {\\tt alter}$ can be thought of as an encoding\nof an access control table that varies with the state of the system. \n\n  \nWe make an  assumption on the set $O$ of objects, namely, that this contains  \na special object ${{\\tt oset}({u})}$ for each domain $u \\in {D}$.\nWe write the  set of all these special objects as ${\\tt Osets}({D}) = \\{ {{\\tt oset}({u})} \\mid u \\in {D} \\}$ and assume ${\\tt Osets}(D) \\subseteq {O}$. \nWe assume that \n${{\\tt contents}({{{\\tt oset}({u})}}, {s})} = {{\\tt observe}({u}, {s})}$, \nso that the content of ${{\\tt oset}({u})}$ is the set of all objects \nthat are observable to $u$. \nFurthermore, we assume that ${{\\tt oset}({u})} \\in {{\\tt observe}(u, s)}$ for all domains $u\\in D$ and states $s\\in{S}$, i.e., \nthe object ${{\\tt oset}({u})}$ is always observable by $u$. \nThis is intuitively reasonable, given the meaning of this object, since domain $u$ can  always determine the value of \n${{\\tt oset}({u})}$ by checking directly which objects it is able to observe. \n\n\nThe motivation for these special objects \n${{\\tt oset}({u})}$ is that they are a  kind of ``meta-object''\nthat can be used to specify if an agent is allowed to change the observable objects of another agent. \nMore precisely, we may let ${{\\tt oset}({u})} \\in {{\\tt alter}({v}, {s})}$ if and only if in state $s$, domain $v$ is allowed to influence which objects are observable by $u$. \n\nWe now state a number of conditions (resembling Rushby's ``reference monitor conditions\" \\cite{rushby92}) that are \nintended to capture the intuitive semantics of the access control functions ${\\tt observe}$, ${\\tt alter}$, \nas they might be enforced by a reference monitor that restricts agents' ability to read and write objects\nas these access control settings change. \nThe conditions are cast in terms of the relations ${\\approx_{u}}$, for $u\\in {D}$, defined by  \n\n$  s {\\approx_{u}} t \\text{ iff } \n   \\text{for all } o \\in {{\\tt observe}(u, s)}, \n   \\text{ we have } {{\\tt contents}(o, s)} = {{\\tt contents}(o, t)} $. \n\nIntuitively, $s{\\approx_{u}} t$ when the objects observable by domain $u$ have the same values in the states\n$s$ and $t$. Note that because ${{\\tt oset}({u})} \\in {{\\tt observe}(u, s)}$, it is always that case that \n${{\\tt observe}(u, s)} = {{\\tt observe}(u, t)}$ when $s {\\approx_{u}} t$. It follows that the relations ${\\approx_{u}}$ are in fact equivalence \nrelations. Our new ``dynamic reference monitor\" conditions\nare the following: \n\\begin{enumerate}[{{\\tt DRM}-}1]\n  \\item  If $s {\\approx_{u}} t$, then ${\\tt obs}_u(s) = {\\tt obs}_u(t)$. \n  \\label{cond:wa:outputconsistency}\n\n  \\item\n     If $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)} \\cap {{\\tt alter}({{\\tt dom}(a)}, t)}$ and \n     $s {\\approx_{{{\\tt dom}(a)}}} t$\n      and  ${{\\tt contents}(o, s)} = {{\\tt contents}(o, t)}$ then  ${{\\tt contents}(o, {s\\cdot a})} = {{\\tt contents}(o, {t \\cdot a})}$. \n  \\label{cond:wa:contentconsistency}\n\n  \\item\n  If  ${{\\tt contents}(o, {s \\cdot a})} \\neq {{\\tt contents}(o, s)}$, then \n  $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)}$. \n  \\label{cond:wa:allowedinterference}\n\n\n  \\item ${{{\\tt observe}(u, {s \\cdot a})}\\! \\setminus\\! {{\\tt observe}(u, s)}}\\! \\subseteq \\! {{\\tt observe}({{\\tt dom}(a)}, s)}$.\n    \\label{cond:wa:grantobserve}\n  \n\n  \\item \n  If $\\alpha \\models v \\rightarrowtail u$ and $\\beta \\models v \\rightarrowtail u$ and  \n  $s_0\\cdot \\alpha {\\approx_{{u}}} s_0\\cdot \\beta$ and $s_0\\cdot \\alpha {\\approx_{{v}}} s_0\\cdot \\beta$, then ${{\\tt observe}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt alter}(v, {s_0\\cdot\\alpha})} = {{\\tt observe}(u, {s_0\\cdot\\beta})}  \\cap {{\\tt alter}(v, {s_0\\cdot \\beta})}$. \n  \\label{cond:wa:weakpolicyconsistency}\n\n\n \\item\n  If ${{\\tt alter}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt observe}(v, {s_0\\cdot \\alpha})} \\neq \\emptyset$, then $\\alpha \\models {u \\rightarrowtail v}$. \n  \\label{cond:wa:commonvar}\n\n\\end{enumerate}\nIntuitively, condition {{\\tt DRM}-}\\ref{cond:wa:outputconsistency} says that a domain's observation depends only on the\ncontents of the objects observable to the domain. \nCondition {{\\tt DRM}-}\\ref{cond:wa:contentconsistency} says that when a domain is permitted to alter an object, the new value of the \nobject depends only on its previous value and the values of the objects observable by the acting domain. \n(The version of this constraint given here follows \\cite{Meyden15} rather than \\cite{rushby92}.)  \nCondition {{\\tt DRM}-}\\ref{cond:wa:allowedinterference} can be understood as stating that an \naction can change the value of an object only when the domain of the action is permitted by \nthe access control setting to alter the object.  \nCondition {{\\tt DRM}-}\\ref{cond:wa:grantobserve} states that any object that is made newly observable to a\ndomain $u$ by an action $a$ must be observable to the domain ${\\tt dom}(a)$. \n\nCondition {{\\tt DRM}-}\\ref{cond:wa:policyconsistency} is a kind of locality constraint, \nwhich states that \nwhen $v$ is permitted to interfere with $u$, in situation $s$, \nthe set ${{\\tt observe}(u, s)} \\cap {{\\tt alter}(v, s)} $ \nof objects that $u$ can observe and $v$ can alter \ndepends only on information local to \ndomains $u$ and $v$, as captured by the relations ${\\approx_{{u}}}$ and ${\\approx_{{v}}}$. \nWe note that this constraint actually only states a weak property of ${{\\tt alter}(v, s)}$, as \nwe already have that ${{\\tt observe}(u, s)}$ depends only on the local state of $u$ as captured by ${\\approx_{{u}}}$.\nThe following stronger version of this condition is also of interest: \n \\begin{itemize} \n\\item[{{\\tt DRM}-}5$'$] If $s {\\approx_{{u}}} t$ and $s {\\approx_{{v}}} t$, then ${{\\tt observe}(u, s)} \\cap {{\\tt alter}(v, s)} = {{\\tt observe}(u, t)} \\cap {{\\tt alter}(v, t)}$. \n \\label{cond:wa:policyconsistency}\n\\end{itemize} \nHere we have dropped the requirement that $v$ be permitted to interfere with $u$ in order for the\ndependency to hold. This stronger condition more closely resembles locality.\n\n \n\nWe remark that have not introduced special objects $\\mathtt{aset}(u)$ for each domain $u$, with the property \nthat ${{\\tt contents}({\\mathtt{aset}(u)}, s)} = {{\\tt alter}(u, s)}$, as might be suggested by analogy with the \nobjects ${{\\tt oset}({u})}$. The results to follow do not require the introduction of these objects. \nHowever, in systems with such objects, and also satisfying the  property\n$\\mathtt{aset}(u) \\in {{\\tt observe}(u, s)}$ condition {\\xspace{{{\\tt DRM}-}5$'$}\\xspace}\\   would be necessarily satisfied. \n\n\n\n\n\nFinally, condition {{\\tt DRM}-}\\ref{cond:wa:commonvar} relates the access control setting to the \npolicy. Note that if there exists an object that domain $u$ is able to write and domain $v$ is able\nto read, then this object provides an obvious channel for information to flow from $u$ to $v$. \nThe condition states that in this situation, the resulting channel for information flow is permitted \nby the information flow policy $\\rightarrowtail$. \n\n\\begin{theorem}\n\\label{thm:ac-secure}\nSuppose $M$ is a system with structured state that satisfies properties {{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail$. \nThen $M$ is  ${{\\tt {ta}}^\\Diamond}$-secure with respect to~$\\rightarrowtail$. \nIf $M$ also satisfies the stronger condition~{\\xspace{{{\\tt DRM}-}5$'$}\\xspace}, then \n$M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to~$\\rightarrowtail$. \n\\end{theorem}\n\n\\begin{proof} \nAssume that $M$ is a system with structured state that satisfies properties {{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail$. \nWe first show that $M$ satisfies DLR$_M$ and WSC$^\\Diamond_M$ and OC$_M$ with respect to the relations $\\{{\\approx_{u}}\\}_{u\\in {D}} $.  \n\nFor property DLR$_M$,  suppose that $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$. Then by \n{{\\tt DRM}-}\\ref{cond:wa:commonvar}, we have \n${{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})} \\cap {{\\tt observe}(u, {s_0\\cdot \\alpha})} = \\emptyset$. \nThus, for all $o\\in {{\\tt observe}(u, {s_0\\cdot \\alpha})}$, we have $ o \\not \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})}$, and by \n{{\\tt DRM}-}\\ref{cond:wa:allowedinterference} we obtain that ${{\\tt contents}(o, {s_0\\cdot \\alpha })} = {{\\tt contents}(o, {s_0\\cdot \\alpha a})}$. \nThis shows that  $s_0\\cdot \\alpha a{\\approx_{{u}}} s_0 \\cdot \\alpha $, as required. \n\nFor WSC$^\\Diamond_M$, suppose that \n$\\alpha \\models {\\tt dom}(a) \\rightarrowtail u$ and $\\beta \\models {\\tt dom}(a) \\rightarrowtail u$ and \n$s_0\\cdot \\alpha  {\\approx_{{u}}} s_0\\cdot \\beta $ and $s_0\\cdot \\alpha {\\approx_{{{\\tt dom}(a)}}} s_0\\cdot \\beta$. \nWe need to show that ${s_0 \\cdot \\alpha a} {\\approx_{{u}}} {s_0 \\cdot \\beta a}$, \n i.e.,  that for all  $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha a})}$, we have  ${{\\tt contents}(o, {s_0\\cdot \\alpha a})} = {{\\tt contents}(o, {s_0 \\cdot \\beta a})}$. \n Let $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha a})}$. By {{\\tt DRM}-}\\ref{cond:wa:grantobserve}\nwe have that $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha })} \\cup {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})}$. \n From $s_0\\cdot\\alpha  {\\approx_{{u}}} s_0\\cdot\\beta$ and $s_0\\cdot\\alpha {\\approx_{{{\\tt dom}(a)}}} s_0\\cdot\\beta$ we obtain \n that ${{\\tt observe}(u, {s_0\\cdot\\alpha})}  = {{\\tt observe}(u, {s_0\\cdot\\beta})}$ and ${{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})} = {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$, \n and for all $o \\in {{\\tt observe}(u, {s_0\\cdot\\alpha})} \\cup {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ we have ${{\\tt contents}(o, {s_0\\cdot\\alpha})} = {{\\tt contents}(o, {s_0\\cdot\\beta})}$.  \n By two applications of {{\\tt DRM}-}\\ref{cond:wa:policyconsistency} (one for the pair of domains $u$, ${\\tt dom}(a)$, and \n the other for the pair ${\\tt dom}(a)$ ,${\\tt dom}(a)$), we obtain that $o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ iff $o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. \n It therefore suffices to consider two cases: \n\\begin{itemize} \n\\item Suppose $ o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. Then by {{\\tt DRM}-}\\ref{cond:wa:contentconsistency}\nwe get ${{\\tt contents}(o, {s_0\\cdot\\alpha a })}  = {{\\tt contents}(o, {s_0\\cdot\\beta a})}$.  \n \\item Suppose $ o \\not \\in  {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ and $o \\not \\in  {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. Then by {{\\tt DRM}-}\\ref{cond:wa:allowedinterference}\n we have ${{\\tt contents}(o, {s_0\\cdot\\alpha a })}  = {{\\tt contents}(o, {s_0\\cdot\\alpha})} = {{\\tt contents}(o, {s_0\\cdot\\beta})} = {{\\tt contents}(o, {s_0\\cdot\\beta a})}$. \n \\end{itemize}  \n\nThe property OC$_{M}$ is trivial, since this is just {{\\tt DRM}-}\\ref{cond:wa:outputconsistency}. \nWe now have that $M$ satisfies DLR$_M$  and WSC$^\\Diamond_M$ and OC$_M$.  By Theorem~\\ref{thm:unwind-maysecure}, \nit follows that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \n\n\nSuppose that $M$ also satisfies the stronger condition~{\\xspace{{{\\tt DRM}-}5$'$}\\xspace}. \nWe show that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Consider the policy $\\rightarrowtail^M$  defined by $\\alpha \\models {u \\rightarrowtail^M v}$ if \n${{\\tt alter}(u, {s_0\\cdot \\alpha })} \\cap {{\\tt observe}({v}, {s_0\\cdot \\alpha})} \\neq \\emptyset$. It is easily checked that $M$ satisfies \n{{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail^M$, so by the above, we conclude that $M$ is  ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail^M$.\nWe claim that the policy $\\rightarrowtail^M$ is local. This being the case, we obtain using Theorem~\\ref{thm:local-must-may}  that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail^M$.\nBy {{\\tt DRM}-}\\ref{cond:wa:commonvar}, we have that ${\\rightarrowtail^M} \\leq {\\rightarrowtail}$, so by Proposition~\\ref{prop:mustta-monotonic} we get that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \n\nTo show that $\\rightarrowtail^M$ is local, define the equivalence relations $\\{\\sim_u\\}_{u\\in {D}}$ on $A^*$ by $\\alpha \\sim_u\\beta$ iff $s_0\\cdot \\alpha {\\approx_{u}} s_0\\cdot \\beta$. \nIt follows from the fact that $M$ satisfies DLR$_M$ with respect to $\\{{\\approx_{u}}\\}_{u\\in {D}}$ that $M$ satisfies DLR with respect to $\\{\\sim_u\\}_{u\\in {D}}$. \nAn argument similar to that above for WSC$^\\Diamond_M$, but using {\\xspace{{{\\tt DRM}-}5$'$}\\xspace} in place of {{\\tt DRM}-}\\ref{cond:wa:policyconsistency}, shows that \n$M$ also satisfies WSC with respect to   $\\{\\sim_u\\}_{u\\in {D}}$. Thus, for the smallest equivalence relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ \nsatisfying WSC and DLR with respect to $\\rightarrowtail^M$, we have ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim_u}$ \nfor all $u\\in {D}$. Suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$ (with respect to policy $\\rightarrowtail^M$). \nWe need to show that $\\alpha \\models {u \\rightarrowtail^M v}$ iff $\\beta \\models {u \\rightarrowtail^M v}$. \nBy Lemma~\\ref{mayta-cont-unwind}, we have that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v\\beta$. \nBy what was shown above, we obtain that $\\alpha \\sim_u \\beta$ and $\\alpha \\sim_v\\beta$, \nso $s_0\\cdot \\alpha \\approx_u s_0\\cdot \\beta$ and $s_0\\cdot\\alpha \\approx_v s_0\\cdot \\beta$. \nBy {\\xspace{{{\\tt DRM}-}5$'$}\\xspace} we now obtain that \n${{\\tt observe}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt alter}(v, {s_0\\cdot \\alpha})} =  {{\\tt observe}(u, {s_0\\cdot \\beta})} \\cap {{\\tt alter}(v, {s_0\\cdot \\beta})}$. \nIt follows that $\\alpha \\models {u \\rightarrowtail^M v}$ iff $\\beta \\models {u \\rightarrowtail^M v}$, as required. \n\\end{proof} \n\nTheorem~\\ref{thm:ac-secure} shows that access control mechanisms \nprovide an implementation method that guarantees \nthat a system constructed using this method is secure. \nIt states a soundness result: any system that satisfies the \nreference monitor conditions with respect to a policy is secure for that \npolicy. \n\n\n\n\n\nIt is also possible to prove a converse to this result, stating that \nany system that is secure with respect to a policy \ncould have been constructed using access control \nmechanisms so as to satisfy the policy. To obtain such a \nresult, we need to allow consideration of \na bisimilar system. \nIn particular, we focus on the \n\\emph{unfolding} of a system $M$. \n\nSay that a system \\emph{admits an access control interpretation consistent with a policy \n$\\rightarrowtail$}, if it can be extended into a system with structured state by adding\ndefinitions of $O, V,  {\\tt contents}, {\\tt observe}$ and ${\\tt alter}$ in such a way as to \nsatisfy conditions {{\\tt DRM}-}1 to {{\\tt DRM}-}6. \n\n\n\\begin{theorem} \n\\label{thm:ac-complete} \nLet system $M$ be  ${{\\tt {ta}}^\\Diamond}$-secure   {with respect to\\xspace} $\\rightarrowtail$. \nThen ${\\mathit{unfold}}(M)$ admits an access control interpretation consistent with $\\rightarrowtail$. \n\nIf $M$ is ${{\\tt {ta}}^\\Box}$-secure  {with respect to\\xspace} $\\rightarrowtail$, \nthen \nthere exists a local policy ${\\rightarrowtail'} \\leq {\\rightarrowtail}$ such that \n${\\mathit{unfold}}(M)$ admits an access control interpretation consistent with $\\rightarrowtail'$,\nthat additionally satisfies {{\\tt DRM}-}$5'$. \n\\end{theorem}\n\n\\begin{proof}\nSuppose first that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$.  \nExtend ${\\mathit{unfold}}(M)$ to a system with structured state by the following definitions: \n \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\tthe new value of $\\gamma$ is $\\gamma' =\\gamma b$.\n\tFor every $v \\in {{\\tt dsrc}({\\beta'}, u, {s_0 \\cdot \\tilde \\beta b})}$, we have $\\tilde \\beta {\\sim^{\\mathit{unw}}}_v \\gamma$ by induction hypothesis\n\t and additionally $ \\tilde \\beta {\\sim^{\\mathit{unw}}}_{{\\tt dom}(b)}  \\gamma$. \n\tFrom the condition WSC it follows for every such $v$: $ \\tilde \\beta b {\\sim^{\\mathit{unw}}}_v  \\gamma b = \\gamma'$. \n\tFrom this claim it follows $ \\alpha {\\sim^{\\mathit{unw}}}_u  \\; {{\\tt Lpurge}({\\alpha}, {u}, {s_0})}$ with $\\beta = \\alpha$ and hence the system is \\emph{not} ${{\\tt {ta}}^\\Box}$-secure. {\\hfill{$\\Box$}}\n\t\t\\end{itemize}\n\\end{proof*}\n\nIn \\cite{Eggert2013}, some problems with ${\\tt Lpurge}$-security are identified and a new purge-based security definition is proposed in response.  \nThis notion uses\nthe same dynamic sources function as Leslie's does, but the purge function does not change in the state parameter if an action has been removed. \nMore precisely, their dynamic intransitive purge function is defined for every $u \\in {D}$ and $s \\in {S}$ by\n${{\\tt ipurge}({\\epsilon}, {u}, {s})}  = \\epsilon$\nand for every $a \\in {A}$ and $\\alpha \\in {A}^*$ if ${\\tt dom}(a) \\in {{\\tt dsrc}({a \\alpha}, {u}, {s})}$, \nthen\n$\n {{\\tt ipurge}({a \\alpha}, {u}, {s})} = a \\; {{\\tt ipurge}({\\alpha}, {u}, {s\\cdot a})}\n$ \nand else\n$\n   {{\\tt ipurge}({a \\alpha}, {u}, {s})} = {{\\tt ipurge}({\\alpha}, {u}, {s})} \n$. \n\n\n\n\n\n\n\n\n\n\n\n\n\nThe notion of \n\\emph{i-security} is defined as usual as the property that for all agent $u$, all states $s$, and all action sequences $\\alpha$ and $\\beta$ with ${{\\tt ipurge}(\\alpha, u, s)} = {{\\tt ipurge}(\\beta, u, s)}$, we have ${\\tt obs}_u(s \\cdot \\alpha) = {\\tt obs}_u(s \\cdot \\beta)$. \n\n\nThis notion of security is incomparable with our security definitions of ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security.\nOn the one hand, we have, due to the static case, that i-security does not imply ${{\\tt {ta}}^\\Diamond}$-security. \t\nThe following example gives a system, with a local policy, that is ${{\\tt {ta}}^\\Box}$-secure and ${{\\tt {ta}}^\\Diamond}$-secure, but not i-secure.  \n\n\n \\begin{figure}\n \\centering\n \\scalebox{0.8}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 0$ \\\\\n  };\n   \\path[policy] (D) edge (L);\n   \\path[policy] (H) edge (D);\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\t\n   ${\\tt obs}_L \\colon 0$ \\\\\n };\n  \\path[policy] (H) edge (D);\n  \n\n\n\n\n\n\n\n\n\n\n\n   \n    \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {               \\node[agent] (H) [left] {$H$};       \\node[agent] (D) [right of=H] {$D$};       \\node[agent] (L) [below of=D] {$L$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_L \\colon 1$ \\\\\n };\n   \\path[policy] (D) edge (L);\n   \\path[policy] (H) edge (D);\n\n   \n \\path (s0) edge node {$h$} (s1) \n       (s0) edge [bend right=40] node[below] {$d$} (s2)\n\n ;\n\\end{tikzpicture}\n}\n\\caption{A ${{\\tt {ta}}^\\Box}$-secure, but \\emph{not} i-secure system}\n\\label{fig:dtasecure-not-disecure}\n\\end{figure} \n\n\\vspace*{-10pt} \n\\begin{example}\n\\label{ex:dtasecure-not-disecure}\nThe system in Figure~\\ref{fig:dtasecure-not-disecure} is clearly \\emph{not} i-secure. \nWe consider the traces $h d $ and $d$ since the ${\\tt ipurge}$ values of these two traces are the same for $L$ if one starts purging in $s_0$:\n$\n {{\\tt ipurge}({h d}, {L}, {s_0})} = {{\\tt ipurge}({d}, L, {s_0})} = d\n\n$. \nBut the observations after these two traces are different for $L$. \n\nHowever, for any trace that starts with an $h$ action, the ${{\\tt {ta}}^\\Diamond}$ value is $\\epsilon$, and for any trace that starts with a $d$ action, the ${{\\tt {ta}}^\\Diamond}$ value differs from $\\epsilon$. \nHence, for any two traces that lead to different observations for $L$ have different ${{\\tt {ta}}^\\Diamond}$ values. \nNote, that the dynamic policy of this system is local, and hence, this system is also ${{\\tt {ta}}^\\Box}$-secure. \n\nWe would argue that this system is intuitively secure, so this gives grounds to prefer our two definitions over i-security. \nFirst, note that in every state $D$ is permitted to learn about $H$ actions, so, in particular, it should be permitted\nfor $D$ to know in state $s_0$ that $H$ has not yet acted. In state $s_2$, $L$ can deduce that $D$ acted before $H$ did, \nbut $D$ was permitted to transfer its information to $L$ when it acted, so this is not an insecurity. Finally, $L$ cannot distinguish state $s_1$ from $s_0$, \nso  this state is secure on the grounds that the initial state of a system always is (noninterference definitions, intuitively, aim\nto prohibit agents from learning information about what has happened in a system). \n\\end{example}\n\n\\vspace*{-10pt} \n\\begin{figure}\n\\centering\n \\begin{tikzpicture}\n \\node (mustta) {${{\\tt {ta}}^\\Box}$-security};\n \\node (mayta) [right=of mustta] {${{\\tt {ta}}^\\Diamond}$-security};\n \\node (isecurity) [below=of mustta] {i-security};\n \\node (lpurge) [right=of isecurity] {${\\tt Lpurge}$-security};\n \n \n \n \n \n \\draw (mustta) edge[->] (mayta);\n \\draw (mustta)\t edge[->] (lpurge);\n \\draw (isecurity) edge[->] (lpurge);\n \\end{tikzpicture}\n \\caption{Relations between dynamic intransitive noninterference definitions}\n \\label{fig:relation-security-definitions}\n\\end{figure}\n\nAlthough i-security implies ${\\tt Lpurge}$-security, Example~\\ref{ex:dtasecure-not-disecure} shows that these security definitions still differ on systems with local policies. \nThe implications of the security definitions analyzed in this work are depicted in Figure~\\ref{fig:relation-security-definitions}.\nAll these implications are strict in general, and the definitions of ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Diamond}$-security only collapse on systems with local policies. \n\nWe can summarize our reasons for preferring the definitions of the present paper to these prior works as \nfollows. First, both  ${\\tt Lpurge}$-security and i-security \nare \nequivalent to Rushby's IP-security\nin the case of static policies. This means that these definitions are \nare subject to the problems identified by van der Meyden \\cite{Meyden15}. \nOne of these problems is an example presented in \\cite{Meyden15}, which shows that Rushby's IP-security fails to detect a covert\nchannel based on ordering of actions.  A second weakness is that IP-security has a weaker relationship\nto the unwinding proof method for intransitive non-interference proposed by Rushby \\cite{rushby92} than does ${\\tt {ta}}$-security. \nAs shown in  \\cite{Meyden15}, this proof method is sound but not complete for IP-security, \nbut both sound and complete for {TA-security\\xspace}. Since the proof method is itself is based on well-founded intuitions,\n this lends further support to {TA-security\\xspace}. (We establish a related completeness result for\n ${{\\tt {ta}}^\\Box}$-security and ${{\\tt {ta}}^\\Diamond}$-security with respect to local dynamic policies in the following section, that shows\n that a similar justification exists for these extensions of {TA-security\\xspace} to the dynamic case.) \nSecondly, when we consider ${\\tt Lpurge}$-security and i-security  with respect to \ndynamic policies, there are   examples for each where they give intuitively incorrect results. \nWe refer  to  \\cite{Eggert2013} for examples showing ${\\tt Lpurge}$-security yields\nundesirable conclusions. Example~\\ref{ex:dtasecure-not-disecure} shows that i-security \ncan also yield undesirable results.\n\n\n\\subsection{Policy Refinement} \n\nRecall that ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ says that policy $\\rightarrowtail$ is more restrictive than\npolicy $\\rightarrowtail'$. We therefore expect that if a system is secure with respect to $\\rightarrowtail$, \nit is also secure with respect to $\\rightarrowtail'$. The following result shows that ${{\\tt {ta}}^\\Box}$-security behaves as expected\nwith respect to this order. \n\n\\begin{proposition} \n\\label{prop:mustta-monotonic} \nIf ${\\rightarrowtail} \\leq {\\rightarrowtail'}$  and system $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$, \nthen $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail'$. \n\\end{proposition} \n\n\\begin{proof} \nThis follows from the equivalence of ${{\\tt {ta}}^\\Box}$-security and unwinding-security. \nLet ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and let $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ and $\\{{\\approx^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ be the \nunwinding relations for the policies $\\rightarrowtail$ and $\\rightarrowtail'$, respectively. \nBy Lemma~\\ref{lem:unwmon}, we have ${{\\approx^{\\mathit{unw}}}_u} \\subseteq {{\\sim^{\\mathit{unw}}}_u}$ for all $u\\in {D}$. \nSuppose that \n$M$ is unwinding secure with respect to $\\rightarrowtail$. Then $\\alpha {\\approx^{\\mathit{unw}}}_u \\beta$ \nimplies $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$, which yields ${\\tt obs}_u(s_0\\cdot \\alpha) = {\\tt obs}_u(s_0\\cdot \\beta)$, \nas required for $M$ to be secure with respect to $\\rightarrowtail'$. \n\\end{proof} \n\n\n\n\nThe following example illustrates a further subtlety concerning \n${{\\tt {ta}}^\\Diamond}$-security: unlike ${{\\tt {ta}}^\\Box}$-security, it is not monotonic with respect to \nthe restrictiveness order on policies. \n\n\\begin{example} \nFigure~\\ref{fig:refinement} shows a system and a policy $\\rightarrowtail$\n for two agents $A,B$. Only the observations of agent $B$ are depicted;\n for agent $A$ we assume that ${\\tt obs}_A(s) = 0$ for all states $s$, \n so that there can be no insecurity with respect to agent $A$. \n For agent $B$, the only possible cases of ${{\\tt {ta}}^\\Diamond}$-insecurity are \n when ${\\tt obs}_B(s_0\\cdot \\alpha) = 1 $ and ${\\tt obs}_B(s_0\\cdot \\beta)=0$. \n This implies that we have  $\\alpha = aba \\alpha'$ and that $aba$ is not a prefix of \n $\\beta$. However, in this case, ${{{\\tt {ta}}^\\Diamond}_{B}(\\beta)}$ cannot contain a subterm $a$, \n since there are no strict prefixes $\\gamma$ of $\\beta$ with $\\gamma \\models {A \\rightarrowtail B}$. \n On the other hand, ${{{\\tt {ta}}^\\Diamond}_{B}({aba \\alpha'})}$ always contains a subterm $a$, since \n${{{\\tt {ta}}^\\Diamond}_{B}({aba})} = ((\\epsilon,\\epsilon,b), (\\epsilon,\\epsilon,a), a)$. Thus, we cannot have \n ${{{\\tt {ta}}^\\Diamond}_{B}({aba \\alpha})} = {{{\\tt {ta}}^\\Diamond}_{B}(\\beta)}$. It follows that the system is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \nWe note that the policy $\\rightarrowtail$ is not local, because \n${{{\\tt {ta}}^\\Diamond}_{A}({ab})} = {{{\\tt {ta}}^\\Diamond}_{A}({ba})} = (\\epsilon, \\epsilon,a)$ and  ${{{\\tt {ta}}^\\Diamond}_{B}({ab})} = {{{\\tt {ta}}^\\Diamond}_{B}({ba})} = (\\epsilon, \\epsilon,b)$, \nbut $ab \\models {A \\rightarrowtail B}$ while $ba \\models {A \\not\\rightarrowtail B}$.  \n\n\n\\begin{figure}\n\\begin{center}\n\\scalebox{0.75}{\n \\begin{tikzpicture}[tikzglobal,node distance=1cm]\n \n\n \\node[initial,systemstate] (s0) {\n   $s_0$ \n   \\\\\n   \\hline\n   {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n   \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n  };\n\n   \n \\node[systemstate] (s1) [right=of s0] {\n $s_1$ \n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n\n   \n \\node[systemstate] (s2) [right=of s1] {\n $s_2$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n    \\path[policy] (A) edge (B);\n   \n    \n  \\node[systemstate] (s4) [right=of s2] {\n $s_4$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n \n \n \\node[systemstate] (s3) [below=of s4] {\n $s_3$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 1$ \\\\\n };\n \n   \n \n   \n\n \n   \n\n \\node[systemstate] (s5) [below=of s0] {\n $s_5$ \n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n\n   \n \\node[systemstate] (s6) [right=of s5] {\n $s_6$\n \\\\\n \\hline\n  {        \\node[agent] (A) [left] {$A$};       \\node[agent] (B) [right of=A] {$B$};       }\n  \\\\\n   \\hline\n   ${\\tt obs}_B \\colon 0$ \\\\\n };\n  \n\n \\path (s0) edge node {$a$} (s1) \n (s1) edge node {$b$} (s2)\n (s2) edge node {$a$} (s3) \n (s2) edge node {$b$} (s4)\n (s0) edge node {$b$} (s5) \n (s5) edge node {$a$} (s6);\n\\end{tikzpicture}\n}\n\\end{center}\n\\caption{The permissive interpretation is not monotonic: policy $\\rightarrowtail$}\n\\label{fig:refinement}\n\\end{figure} \n\n\nOn the other hand, consider the policy $\\rightarrowtail'$, which is defined identically to $\\rightarrowtail$, except that on \nstate $s_6$ we take $s_6 \\models {A \\rightarrowtail' B}$. Plainly, ${\\rightarrowtail} \\leq {\\rightarrowtail'}$. \nHowever, the system is not ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \nNote that with respect to policy $\\rightarrowtail'$, \nwe have ${{{\\tt {ta}}^\\Diamond}_{B}({aba})} = ((\\epsilon,\\epsilon,b), (\\epsilon,\\epsilon,a), a) = {{{\\tt {ta}}^\\Diamond}_{B}({baa})}$, \nwhereas ${\\tt obs}_B(s_0\\cdot aba) = 1 $ and ${\\tt obs}_B(s_0\\cdot baa)=0$. \n\\end{example} \n\nHowever, for local policies, ${{\\tt {ta}}^\\Diamond}$-security behaves as expected. \nThis follows from Proposition~\\ref{prop:mustta-monotonic}, the equivalence of ${{\\tt {ta}}^\\Diamond}$-security and ${{\\tt {ta}}^\\Box}$-security \nfor local policies. The following result shows that, in fact it holds slightly more generally, \nand we can also use monotonicity to derive ${{\\tt {ta}}^\\Diamond}$-security for non-local policies. \n\n\\begin{proposition} \n\\label{prop:may-monotonic} \nSuppose that ${\\rightarrowtail} \\leq {\\rightarrowtail'}$ and that $\\rightarrowtail$ is \nlocal. \nIf a system $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$, then $M$ is \n${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$.\n\\end{proposition} \n\n\\begin{proof}\n Let $M$ be a ${{\\tt {ta}}^\\Diamond}$-secure system with respect to $\\rightarrowtail$. \n Since $\\rightarrowtail$ is local, we obtain from Theorem~\\ref{thm:local-must-may} that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \n By Proposition~\\ref{prop:mustta-monotonic}, the system is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail'$. \n Since ${{\\tt {ta}}^\\Box}$-security implies ${{\\tt {ta}}^\\Diamond}$-security (by Lemma~\\ref{mayta-cont-unwind} and Theorem~\\ref{thm:mustunwind}), we have that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \n\\end{proof}\n\n\n\\section{Proof Techniques} \n\n\\label{sec:prooftechniques}\n\nIn the theory of static  (intransitive) noninterference  policies, \n{\\em unwinding relations} provide a proof technique that \ncan be used to show that a system is secure.  An unwinding\nrelation is a relation on the states of the system that \nsatisfies certain conditions. We show in this section that a similar technique applies \nto dynamic policies. In fact, the conditions that we need are very similar to those \ndefined on the policy above, with the main difference being that they are stated\nwith respect to states of the system rather than traces. \n\n\n\\subsection{Proof technique for ${{\\tt {ta}}^\\Box}$-security}\n\nLet \n$M$ be a system and let $\\approx_u$ be an equivalence \nrelation on the states of $M$ for each $u\\in {D}$. \n\n\\begin{itemize} \n\\item[(DLR$_M$)]   If $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$ then $s_0\\cdot \\alpha a \\approx_u s_0 \\cdot \\alpha$. \n\\item[(WSC$_M$)]   If $s \\approx_u t$ and $s \\approx_{{\\tt dom}(a)} t$ then $s\\cdot a \\approx_u t\\cdot a$. \n\\item[(OC$_M$)]   If $s \\approx_u t$ then ${\\tt obs}_u(s) = {\\tt obs}_u(t)$. \n\\end{itemize} \nWe call a collection $\\{\\approx_u \\}_{u\\in {D}}$ of equivalence relations satisfying DLR$_M$, WSC$_M$ and \nOC$_M$ a $\\Box$-unwinding on $M$ with respect to $\\rightarrowtail$.\n\nWe remark that for policy-enhanced systems, we have the following version of DLR$_M$: \n\\begin{itemize} \n\\item[(DLR-PE$_M$)]   If $s \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then $s\\cdot  a \\approx_u s$. \n\\end{itemize} \nwhich formulates the conditions to uniformly quantify over states of the system rather than both \nover states and traces. \nIt is straightforward to show that if a policy-enhanced system $M$ satisfies \nDLR-PE$_M$ then it satisfies DLR$_M$.\n\nThe following result states that to prove ${{\\tt {ta}}^\\Box}$-security, it suffices to  \nshow that there exists a $\\Box$-unwinding on the system.  \n\n\\begin{theorem} \n\\label{thm:unwind-mustsecure}\nSuppose that there exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M$ satisfying DLR$_M$, WSC$_M$ and OC$_M$ with respect to a \npolicy $\\rightarrowtail$. Then $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$.  \n\\end{theorem} \n\n\\begin{proof} \nTo show that $M$ is ${{\\tt {ta}}^\\Box}$-secure, we argue that the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$, which by definition satisfy WSC and DLR, also satisfy OC. \nFor this, we claim that for all $\\alpha, \\beta\\in A^*$, if \n$\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ then $s_0\\cdot \\alpha \\approx_u s_0\\cdot\\beta$.\nIt is  then immediate from OC$_M$ that OC holds for ${\\sim^{\\mathit{unw}}}_u$. \n\nThe proof of the claim is by induction on the derivation of $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$. \nThe cases of $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ obtained by reflexivity, symmetry or\ntransitivity are straightforward, using the fact that $\\approx_u$ has these\nproperties. For DLR, if $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ is obtained by an application of \nDLR then $\\alpha = \\beta a$ for some $a\\in A$ with $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. \nBy DLR$_M$, we have ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$, as required. \nFor WSC, suppose that $\\alpha {\\sim^{\\mathit{unw}}}_u\\beta$ is obtained by an application of WSC, \nso that we have $\\alpha = \\alpha' a$ and $\\beta = \\beta' a$. where \n$\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_{{\\tt dom}(a)} \\beta$. \nBy induction, we have $s_0 \\cdot \\alpha' \\approx_u s_0 \\cdot \\beta'$ and $s_0 \\cdot \\alpha' \\approx_{{\\tt dom}(a)} s_0 \\cdot \\beta'$. \nWe now obtain $s_0 \\cdot \\alpha' a\\approx_u s_0 \\cdot \\beta' a $ by WSC$_M$, i.e., \n$s_0 \\cdot \\alpha\\approx_u s_0 \\cdot \\beta$, as required. \n\\end{proof} \n\nAn unwinding on the system can often be naturally defined.  \nWe give an example below in the case of access control systems. \n\n\nWe may also show that unwindings provide a complete proof method, \nmodulo the fact that we may need to work in a bisimilar system, rather\nthan the system as presented. (See \\cite{Meyden15} for an example that demonstrates\nthat, already for static policies, we do not obtain completeness if we \nrequire that the unwinding be defined over the states of the system $M$ itself. \nA more complex type of unwinding on the system $M$ itself is shown to be complete for {TA-security\\xspace} of static policies \nin \\cite{EggertMSW13}. It would be interesting to develop a generalization of this to the \ndynamic case, but we leave this for future work.)\n\n\\begin{theorem} \nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Then there \nexists a system $M'$ that is bisimilar to $M$ (specifically, we may take $M'= {\\mathit{unfold}}(M)$), \nsuch that there exist equivalence relations $\\{\\approx'_u\\}_{u \\in {D}}$ on the states\nof  $M'$ satisfying DLR$_{M'}$, WSC$_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. \n\\end{theorem} \n\n\\begin{proof} \nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \nThen the relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u \\in {D}}$ are defined on the states of \n$M'= {\\mathit{unfold}}(M)$, and  by definition, satisfy WSC and $DLR$. \nThese are equivalent to WSC$_{M'}$ and DLR$_{M'}$. \nMoreover, by Theorem~\\ref{thm:mustunwind}, we have that ${{\\sim^{\\mathit{unw}}}_u} = {\\sim^\\Box_u}$ for all $u\\in D$, \nso OC$_{M'}$ follows from the fact that $M$ is ${{\\tt {ta}}^\\Box}$-secure. \n\\end{proof} \n\n\n\\subsection{Proof technique for ${{\\tt {ta}}^\\Diamond}$-security} \n\nA similar proof theory can be developed for the notion ${{\\tt {ta}}^\\Diamond}$-security. \nWe replace the condition WSC$_M$ by the following:  \n\n\\begin{itemize} \n\\item[(WSC$^\\Diamond_M$)]   If $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$ and $\\beta  \\models {{\\tt dom}(a) \\rightarrowtail u}$  and ${s_0\\cdot \\alpha}  \\approx_u {s_0 \\cdot \\beta}$ \nand ${s_0\\cdot \\alpha} \\approx_{{\\tt dom}(a)} {s_0 \\cdot \\beta}$ \nthen ${s_0\\cdot \\alpha a} \\approx_u {s_0 \\cdot \\beta a}$. \n\\end{itemize} \nOn policy enhanced systems $M$, it is  easily seen that the following variant is sufficient for WSC$^\\Diamond_M$ to hold:\n\\begin{itemize} \n\\item[(WSC-PE$^\\Diamond_M$)]   If $s\\models {{\\tt dom}(a) \\rightarrowtail u}$ and $t  \\models {{\\tt dom}(a) \\rightarrowtail u}$  and $s \\approx_u t $ \nand $s  \\approx_{{\\tt dom}(a)} t $ \nthen ${s\\cdot  a} \\approx_u {t \\cdot a}$. \n\\end{itemize} \n\n\\begin{theorem} \n\\label{thm:unwind-maysecure}\nSuppose that there exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M$ satisfying DLR$_M$, WSC$^\\Diamond_M$ and OC$_M$ with respect to a \npolicy $\\rightarrowtail$. Then $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$.  \n\\end{theorem} \n\n\\begin{proof*} \nWe claim that for all $\\alpha,\\beta \\in A^*$ we have ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ implies\nthat $s_0 \\cdot \\alpha  \\approx_u s_0\\cdot \\beta $. It follows from this using  OC$_M$ that \n$M$ is ${{\\tt {ta}}^\\Diamond}$-secure. \n\nTo prove the claim we proceed by induction on $|\\alpha| + |\\beta|$. \nThe base case of $\\alpha = \\beta = \\epsilon$ is trivial. \nFor the inductive case, suppose (without loss of generality) that $\\alpha = \\alpha' a$, and we have \n${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}= {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. There are two possibilities: \n\\begin{itemize} \n\\item $\\alpha \\models {{\\tt dom}(a) \\not\\rightarrowtail u}$. In this case we have ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$, so by the inductive hypothesis, \nwe have ${s_0\\cdot \\alpha'} \\approx_u {s_0\\cdot \\beta}$. By DLR$_M$, we also have that ${s_0\\cdot \\alpha' a} \\approx_u {s_0\\cdot \\alpha'}$. \nSince $\\approx_u$ is an equivalence relation, we have ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$. \n\n\\item $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail u}$. \nIn this case, ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = ( {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}, {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}, a)$. It follows that $\\beta \\neq \\epsilon$,\nso we may write $\\beta = \\beta' b$ for some $\\beta'\\in A^*$ and $b\\in A$. If $\\beta' \\models {{\\tt dom}(b) \\not\\rightarrowtail u}$, \nwe may reverse the roles of $\\alpha$ and $\\beta$ and obtain that  ${s_0\\cdot \\alpha} \\approx_u {s_0\\cdot \\beta}$ using the argument of the previous case.  \nIf $\\beta'\\models {{\\tt dom}(b) \\rightarrowtail u}$, then ${{{\\tt {ta}}^\\Diamond}_{u}(\\beta)} = ( {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}, {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(b)}}({\\beta'})}, b)$, and we\nconclude that $a=b$ and ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{u}({\\beta'})}$ and ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\alpha'})} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}({\\beta'})}$. \nBy the inductive hypothesis, we have ${s_0\\cdot\\alpha'} \\approx_u {s_0\\cdot\\beta'}$ and ${s_0\\cdot\\alpha'} \\approx_{{\\tt dom}(a)} {s_0\\cdot\\beta'}$. \nUsing WSC$^\\Diamond_M$ it follows that ${s_0\\cdot\\alpha' a} \\approx_u {s_0\\cdot\\beta' a}$, i.e., ${s_0\\cdot\\alpha} \\approx_u {s_0\\cdot\\beta}$. \n{\\hfill{$\\Box$}} \n\\end{itemize} \n\\end{proof*} \nWe also have completeness of the technique, provided \nwe allow its application on a bisimilar system: \n\n\\begin{theorem} \n\\label{thm:unwind-mustsecure}\nSuppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$.  \nThen there exists a system $M'$ that is bisimilar to $M$ and \nthere exist equivalence relations $\\{\\approx_u\\}_{u \\in {D}}$ on the states\nof a system $M'$ satisfying DLR$_{M'}$, WSC$^\\Diamond_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. \n\\end{theorem} \n\n\\begin{proof} Let $M = {\\langle {S, s_0, \\rightarrow, {D}, {\\tt dom}, {A}, {\\tt obs}} \\rangle}$. \nWe take $M' = {\\langle {S', s'_0, \\rightarrow', {D}, {\\tt dom}, {A}, {\\tt obs}'} \\rangle}$  to be the system \nover the same signature $({D}, {\\tt dom}, {A})$\nwith states $S' = A^*$, initial state $s_0' = \\epsilon$, \ntransitions $\\rightarrow'$ defined by $\\alpha \\cdot a = \\alpha a$ for all $\\alpha \\in A^*$, and observations defined\n${\\tt obs}'_u(\\alpha) = {\\tt obs}_u(s_0\\cdot\\alpha)$ for all $\\alpha \\in S'$. It is easily checked that this system\nis bisimilar to $M$. \n\nWe show that the relations $\\{\\sim^\\Diamond_u\\}_{u \\in {D}}$ satisfy  DLR$_{M'}$, WSC$^\\Diamond_{M'}$ and OC$_{M'}$ with respect to \npolicy $\\rightarrowtail$. Note that for all $\\alpha\\in A^*$, we have $s_0'\\cdot \\alpha  = \\alpha$. \nFor condition DLR$_{M'}$, note that if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$ then ${{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}$, \nso $\\alpha a \\sim^\\Diamond_u\\alpha$. \nFor condition WSC$^\\Diamond_{M'}$, note that  if $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$\nand  $\\beta \\models {\\tt dom}(a) \\not\\rightarrowtail u$ and $\\alpha  \\sim^\\Diamond_u\\beta$ and \n$\\alpha  \\sim^\\Diamond_{{\\tt dom}(a)}\\beta$ then \n", "index": 27, "text": "\n\\[ \n\\begin{array}{rcl} \n{{{\\tt {ta}}^\\Diamond}_{u}({\\alpha a})} & = & ({{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)}, a) \\\\ \n& = & ({{{\\tt {ta}}^\\Diamond}_{u}(\\beta)} , {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\beta)}, a) \\\\ \n& = & {{{\\tt {ta}}^\\Diamond}_{u}({\\beta a})}\n\\end{array} \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{rcl}{{{\\tt{ta}}^{\\Diamond}}_{u}({\\alpha a})}&amp;=&amp;({{{\\tt{ta}}^{%&#10;\\Diamond}}_{u}(\\alpha)},{{{\\tt{ta}}^{\\Diamond}}_{{{\\tt dom}(a)}}(\\alpha)},a)\\\\&#10;&amp;=&amp;({{{\\tt{ta}}^{\\Diamond}}_{u}(\\beta)},{{{\\tt{ta}}^{\\Diamond}}_{{{\\tt dom}(a)%&#10;}}(\\beta)},a)\\\\&#10;&amp;=&amp;{{{\\tt{ta}}^{\\Diamond}}_{u}({\\beta a})}\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>=</mo></mtd><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"center\"><mo>=</mo></mtd><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mrow><mi>\ud835\ude8d\ud835\ude98\ud835\ude96</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"center\"><mo>=</mo></mtd><mtd columnalign=\"left\"><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>u</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b2</mi><mo>\u2062</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\nWe will show that the dynamic reference monitor conditions {{\\tt DRM}-}1 to {{\\tt DRM}-}6 hold. \n \\begin{enumerate}\n  \\item[{{\\tt DRM}-}\\ref{cond:wa:outputconsistency}:]\n    Let ${ \\alpha} {\\approx_{{u}}} { \\beta}$. \n    Then we have $u \\in {{\\tt observe}(u, { \\alpha})} = {{\\tt observe}(u, { \\beta})}$ and ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{\\tt contents}(u, { \\alpha})} = {{\\tt contents}(u, { \\beta})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. \n    It now follows by ${{\\tt {ta}}^\\Diamond}$-security of $M$ that ${\\tt obs}_u( \\alpha) = {\\tt obs}^M_u( s_0\\cdot \\alpha) = {\\tt obs}^M_u(s_0\\cdot \\beta) = {\\tt obs}_u( \\beta)$. \n  \\item [{{\\tt DRM}-}\\ref{cond:wa:contentconsistency}:]\n    Let $o \\in {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, { \\beta})}$ and ${ \\alpha} {\\approx_{{{\\tt dom}(a)}}} { \\beta}$ and ${{\\tt contents}(o, { \\alpha})} = {{\\tt contents}(o, { \\beta})}$.     \n    From ${ \\alpha} {\\approx_{{{\\tt dom}(a)}}} { \\beta}$ and the fact that, by definition,  ${\\tt dom}(a) \\in {{\\tt observe}({{\\tt dom}(a)}, \\alpha)}$ we obtain ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\beta)}$. \n    From $o \\in {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, { \\beta})}$ it follows that $o\\in D$ and $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail o}$ and $\\beta \\models {{\\tt dom}(a) \\rightarrowtail o}$. \n    From ${{\\tt contents}(o, { \\alpha})} = {{\\tt contents}(o, { \\beta})}$ it follows that ${{{\\tt {ta}}^\\Diamond}_{o}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{o}(\\beta)}$.  By the definition of the ${{\\tt {ta}}^\\Diamond}$-operator, we obtain ${{{\\tt {ta}}^\\Diamond}_{o}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{o}({\\beta a})}$. \n  \\item[{{\\tt DRM}-}\\ref{cond:wa:allowedinterference}:] We prove the contrapositive. \n    Suppose $o \\notin {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})}$. \n    We can assume that $o \\in {D}$, since the values of objects in ${\\tt Osets}$ do not change. \n    Thus, we have $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail o}$. \n    Then we have ${{{\\tt {ta}}^\\Diamond}_{o}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{o}({\\alpha})}$ and hence ${{\\tt contents}(o, { \\alpha a})} = {{\\tt contents}(o, { \\alpha})}$.\n\n  \\item[{{\\tt DRM}-}\\ref{cond:wa:grantobserve}:]  \n    Since the function ${\\tt observe}$ is constant, we have ${{\\tt observe}(u, {\\alpha \\cdot a})} \\setminus {{\\tt observe}(u, \\alpha)} = \\emptyset$. \n  \\item[{{\\tt DRM}-}\\ref{cond:wa:policyconsistency}:] \n   By definition, we have that \n    \n", "itemtype": "equation", "pos": 146267, "prevtext": " \nhence $\\alpha a \\sim^\\Diamond_u \\beta a$. \nCondition OC$_{M'}$  is immediate from the fact that $M$ (and hence $M'$) is ${{\\tt {ta}}^\\Diamond}$-secure. \n\\end{proof} \n\n\n\\section{Access Control \nin Dynamic Systems}\n\\label{sec:accesscontrolinterpretation}\n\nAccess control monitors are a fundamental security mechanism\nthat can be used to enforce a variety of policies. Rushby \\cite{rushby92} \nshowed that access control can provide a sound enforcement \nmechanism for static intransitive noninterference policies, and that a simple static check of the access control table suffices\nto verify the policy will be enforced. It was later shown by van der Meyden \n\\cite{Meyden15} that, in fact, access control is also a \\emph{complete} enforcement mechanism\nfor such policies, in the sense that every system that satisfies the policy is \nbisimilar to one using access control, with a setting that satisfies the static check.  \nIn this section, we develop a generalization of these results to \ndynamic noninterference policies. \n\nA system with structured state, is a system equipped with \n\\begin{itemize}\n  \\item a set of all possible objects ${O}$, \n  \\item a set of all possible values ${V}$, \n  \\item a function ${\\tt contents} \\colon {O} \\times {S} \\rightarrow {V}$, \n   \\item a function ${\\tt observe} \\colon {D} \\times {S} \\rightarrow {\\mathcal{P}({{O}})}$, \n   \\item a function ${\\tt alter} \\colon {D} \\times {S} \\rightarrow {\\mathcal{P}({{O}})}$. \n\\end{itemize}\nIntuitively, ${{\\tt contents}({o}, {s})}$ is the value of object $o$ in state $s$, \n${{\\tt observe}({u}, {s})}$ is the set of objects that domain $u$ is permitted to observe (or read) in state $s$, \nand ${{\\tt alter}({u}, {s})}$ is the set of objects that domain $u$ is permitted to alter (or write) in state $s$. \nThe pair of functions ${\\tt observe}, {\\tt alter}$ can be thought of as an encoding\nof an access control table that varies with the state of the system. \n\n  \nWe make an  assumption on the set $O$ of objects, namely, that this contains  \na special object ${{\\tt oset}({u})}$ for each domain $u \\in {D}$.\nWe write the  set of all these special objects as ${\\tt Osets}({D}) = \\{ {{\\tt oset}({u})} \\mid u \\in {D} \\}$ and assume ${\\tt Osets}(D) \\subseteq {O}$. \nWe assume that \n${{\\tt contents}({{{\\tt oset}({u})}}, {s})} = {{\\tt observe}({u}, {s})}$, \nso that the content of ${{\\tt oset}({u})}$ is the set of all objects \nthat are observable to $u$. \nFurthermore, we assume that ${{\\tt oset}({u})} \\in {{\\tt observe}(u, s)}$ for all domains $u\\in D$ and states $s\\in{S}$, i.e., \nthe object ${{\\tt oset}({u})}$ is always observable by $u$. \nThis is intuitively reasonable, given the meaning of this object, since domain $u$ can  always determine the value of \n${{\\tt oset}({u})}$ by checking directly which objects it is able to observe. \n\n\nThe motivation for these special objects \n${{\\tt oset}({u})}$ is that they are a  kind of ``meta-object''\nthat can be used to specify if an agent is allowed to change the observable objects of another agent. \nMore precisely, we may let ${{\\tt oset}({u})} \\in {{\\tt alter}({v}, {s})}$ if and only if in state $s$, domain $v$ is allowed to influence which objects are observable by $u$. \n\nWe now state a number of conditions (resembling Rushby's ``reference monitor conditions\" \\cite{rushby92}) that are \nintended to capture the intuitive semantics of the access control functions ${\\tt observe}$, ${\\tt alter}$, \nas they might be enforced by a reference monitor that restricts agents' ability to read and write objects\nas these access control settings change. \nThe conditions are cast in terms of the relations ${\\approx_{u}}$, for $u\\in {D}$, defined by  \n\n$  s {\\approx_{u}} t \\text{ iff } \n   \\text{for all } o \\in {{\\tt observe}(u, s)}, \n   \\text{ we have } {{\\tt contents}(o, s)} = {{\\tt contents}(o, t)} $. \n\nIntuitively, $s{\\approx_{u}} t$ when the objects observable by domain $u$ have the same values in the states\n$s$ and $t$. Note that because ${{\\tt oset}({u})} \\in {{\\tt observe}(u, s)}$, it is always that case that \n${{\\tt observe}(u, s)} = {{\\tt observe}(u, t)}$ when $s {\\approx_{u}} t$. It follows that the relations ${\\approx_{u}}$ are in fact equivalence \nrelations. Our new ``dynamic reference monitor\" conditions\nare the following: \n\\begin{enumerate}[{{\\tt DRM}-}1]\n  \\item  If $s {\\approx_{u}} t$, then ${\\tt obs}_u(s) = {\\tt obs}_u(t)$. \n  \\label{cond:wa:outputconsistency}\n\n  \\item\n     If $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)} \\cap {{\\tt alter}({{\\tt dom}(a)}, t)}$ and \n     $s {\\approx_{{{\\tt dom}(a)}}} t$\n      and  ${{\\tt contents}(o, s)} = {{\\tt contents}(o, t)}$ then  ${{\\tt contents}(o, {s\\cdot a})} = {{\\tt contents}(o, {t \\cdot a})}$. \n  \\label{cond:wa:contentconsistency}\n\n  \\item\n  If  ${{\\tt contents}(o, {s \\cdot a})} \\neq {{\\tt contents}(o, s)}$, then \n  $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)}$. \n  \\label{cond:wa:allowedinterference}\n\n\n  \\item ${{{\\tt observe}(u, {s \\cdot a})}\\! \\setminus\\! {{\\tt observe}(u, s)}}\\! \\subseteq \\! {{\\tt observe}({{\\tt dom}(a)}, s)}$.\n    \\label{cond:wa:grantobserve}\n  \n\n  \\item \n  If $\\alpha \\models v \\rightarrowtail u$ and $\\beta \\models v \\rightarrowtail u$ and  \n  $s_0\\cdot \\alpha {\\approx_{{u}}} s_0\\cdot \\beta$ and $s_0\\cdot \\alpha {\\approx_{{v}}} s_0\\cdot \\beta$, then ${{\\tt observe}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt alter}(v, {s_0\\cdot\\alpha})} = {{\\tt observe}(u, {s_0\\cdot\\beta})}  \\cap {{\\tt alter}(v, {s_0\\cdot \\beta})}$. \n  \\label{cond:wa:weakpolicyconsistency}\n\n\n \\item\n  If ${{\\tt alter}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt observe}(v, {s_0\\cdot \\alpha})} \\neq \\emptyset$, then $\\alpha \\models {u \\rightarrowtail v}$. \n  \\label{cond:wa:commonvar}\n\n\\end{enumerate}\nIntuitively, condition {{\\tt DRM}-}\\ref{cond:wa:outputconsistency} says that a domain's observation depends only on the\ncontents of the objects observable to the domain. \nCondition {{\\tt DRM}-}\\ref{cond:wa:contentconsistency} says that when a domain is permitted to alter an object, the new value of the \nobject depends only on its previous value and the values of the objects observable by the acting domain. \n(The version of this constraint given here follows \\cite{Meyden15} rather than \\cite{rushby92}.)  \nCondition {{\\tt DRM}-}\\ref{cond:wa:allowedinterference} can be understood as stating that an \naction can change the value of an object only when the domain of the action is permitted by \nthe access control setting to alter the object.  \nCondition {{\\tt DRM}-}\\ref{cond:wa:grantobserve} states that any object that is made newly observable to a\ndomain $u$ by an action $a$ must be observable to the domain ${\\tt dom}(a)$. \n\nCondition {{\\tt DRM}-}\\ref{cond:wa:policyconsistency} is a kind of locality constraint, \nwhich states that \nwhen $v$ is permitted to interfere with $u$, in situation $s$, \nthe set ${{\\tt observe}(u, s)} \\cap {{\\tt alter}(v, s)} $ \nof objects that $u$ can observe and $v$ can alter \ndepends only on information local to \ndomains $u$ and $v$, as captured by the relations ${\\approx_{{u}}}$ and ${\\approx_{{v}}}$. \nWe note that this constraint actually only states a weak property of ${{\\tt alter}(v, s)}$, as \nwe already have that ${{\\tt observe}(u, s)}$ depends only on the local state of $u$ as captured by ${\\approx_{{u}}}$.\nThe following stronger version of this condition is also of interest: \n \\begin{itemize} \n\\item[{{\\tt DRM}-}5$'$] If $s {\\approx_{{u}}} t$ and $s {\\approx_{{v}}} t$, then ${{\\tt observe}(u, s)} \\cap {{\\tt alter}(v, s)} = {{\\tt observe}(u, t)} \\cap {{\\tt alter}(v, t)}$. \n \\label{cond:wa:policyconsistency}\n\\end{itemize} \nHere we have dropped the requirement that $v$ be permitted to interfere with $u$ in order for the\ndependency to hold. This stronger condition more closely resembles locality.\n\n \n\nWe remark that have not introduced special objects $\\mathtt{aset}(u)$ for each domain $u$, with the property \nthat ${{\\tt contents}({\\mathtt{aset}(u)}, s)} = {{\\tt alter}(u, s)}$, as might be suggested by analogy with the \nobjects ${{\\tt oset}({u})}$. The results to follow do not require the introduction of these objects. \nHowever, in systems with such objects, and also satisfying the  property\n$\\mathtt{aset}(u) \\in {{\\tt observe}(u, s)}$ condition {\\xspace{{{\\tt DRM}-}5$'$}\\xspace}\\   would be necessarily satisfied. \n\n\n\n\n\nFinally, condition {{\\tt DRM}-}\\ref{cond:wa:commonvar} relates the access control setting to the \npolicy. Note that if there exists an object that domain $u$ is able to write and domain $v$ is able\nto read, then this object provides an obvious channel for information to flow from $u$ to $v$. \nThe condition states that in this situation, the resulting channel for information flow is permitted \nby the information flow policy $\\rightarrowtail$. \n\n\\begin{theorem}\n\\label{thm:ac-secure}\nSuppose $M$ is a system with structured state that satisfies properties {{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail$. \nThen $M$ is  ${{\\tt {ta}}^\\Diamond}$-secure with respect to~$\\rightarrowtail$. \nIf $M$ also satisfies the stronger condition~{\\xspace{{{\\tt DRM}-}5$'$}\\xspace}, then \n$M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to~$\\rightarrowtail$. \n\\end{theorem}\n\n\\begin{proof} \nAssume that $M$ is a system with structured state that satisfies properties {{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail$. \nWe first show that $M$ satisfies DLR$_M$ and WSC$^\\Diamond_M$ and OC$_M$ with respect to the relations $\\{{\\approx_{u}}\\}_{u\\in {D}} $.  \n\nFor property DLR$_M$,  suppose that $\\alpha \\models {\\tt dom}(a) \\not\\rightarrowtail u$. Then by \n{{\\tt DRM}-}\\ref{cond:wa:commonvar}, we have \n${{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})} \\cap {{\\tt observe}(u, {s_0\\cdot \\alpha})} = \\emptyset$. \nThus, for all $o\\in {{\\tt observe}(u, {s_0\\cdot \\alpha})}$, we have $ o \\not \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})}$, and by \n{{\\tt DRM}-}\\ref{cond:wa:allowedinterference} we obtain that ${{\\tt contents}(o, {s_0\\cdot \\alpha })} = {{\\tt contents}(o, {s_0\\cdot \\alpha a})}$. \nThis shows that  $s_0\\cdot \\alpha a{\\approx_{{u}}} s_0 \\cdot \\alpha $, as required. \n\nFor WSC$^\\Diamond_M$, suppose that \n$\\alpha \\models {\\tt dom}(a) \\rightarrowtail u$ and $\\beta \\models {\\tt dom}(a) \\rightarrowtail u$ and \n$s_0\\cdot \\alpha  {\\approx_{{u}}} s_0\\cdot \\beta $ and $s_0\\cdot \\alpha {\\approx_{{{\\tt dom}(a)}}} s_0\\cdot \\beta$. \nWe need to show that ${s_0 \\cdot \\alpha a} {\\approx_{{u}}} {s_0 \\cdot \\beta a}$, \n i.e.,  that for all  $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha a})}$, we have  ${{\\tt contents}(o, {s_0\\cdot \\alpha a})} = {{\\tt contents}(o, {s_0 \\cdot \\beta a})}$. \n Let $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha a})}$. By {{\\tt DRM}-}\\ref{cond:wa:grantobserve}\nwe have that $o \\in {{\\tt observe}(u, {s_0\\cdot \\alpha })} \\cup {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot \\alpha})}$. \n From $s_0\\cdot\\alpha  {\\approx_{{u}}} s_0\\cdot\\beta$ and $s_0\\cdot\\alpha {\\approx_{{{\\tt dom}(a)}}} s_0\\cdot\\beta$ we obtain \n that ${{\\tt observe}(u, {s_0\\cdot\\alpha})}  = {{\\tt observe}(u, {s_0\\cdot\\beta})}$ and ${{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})} = {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$, \n and for all $o \\in {{\\tt observe}(u, {s_0\\cdot\\alpha})} \\cup {{\\tt observe}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ we have ${{\\tt contents}(o, {s_0\\cdot\\alpha})} = {{\\tt contents}(o, {s_0\\cdot\\beta})}$.  \n By two applications of {{\\tt DRM}-}\\ref{cond:wa:policyconsistency} (one for the pair of domains $u$, ${\\tt dom}(a)$, and \n the other for the pair ${\\tt dom}(a)$ ,${\\tt dom}(a)$), we obtain that $o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ iff $o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. \n It therefore suffices to consider two cases: \n\\begin{itemize} \n\\item Suppose $ o \\in {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. Then by {{\\tt DRM}-}\\ref{cond:wa:contentconsistency}\nwe get ${{\\tt contents}(o, {s_0\\cdot\\alpha a })}  = {{\\tt contents}(o, {s_0\\cdot\\beta a})}$.  \n \\item Suppose $ o \\not \\in  {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\alpha})}$ and $o \\not \\in  {{\\tt alter}({{\\tt dom}(a)}, {s_0\\cdot\\beta})}$. Then by {{\\tt DRM}-}\\ref{cond:wa:allowedinterference}\n we have ${{\\tt contents}(o, {s_0\\cdot\\alpha a })}  = {{\\tt contents}(o, {s_0\\cdot\\alpha})} = {{\\tt contents}(o, {s_0\\cdot\\beta})} = {{\\tt contents}(o, {s_0\\cdot\\beta a})}$. \n \\end{itemize}  \n\nThe property OC$_{M}$ is trivial, since this is just {{\\tt DRM}-}\\ref{cond:wa:outputconsistency}. \nWe now have that $M$ satisfies DLR$_M$  and WSC$^\\Diamond_M$ and OC$_M$.  By Theorem~\\ref{thm:unwind-maysecure}, \nit follows that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$. \n\n\nSuppose that $M$ also satisfies the stronger condition~{\\xspace{{{\\tt DRM}-}5$'$}\\xspace}. \nWe show that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. Consider the policy $\\rightarrowtail^M$  defined by $\\alpha \\models {u \\rightarrowtail^M v}$ if \n${{\\tt alter}(u, {s_0\\cdot \\alpha })} \\cap {{\\tt observe}({v}, {s_0\\cdot \\alpha})} \\neq \\emptyset$. It is easily checked that $M$ satisfies \n{{\\tt DRM}-}{1} to {{\\tt DRM}-}{6}  with respect to policy $\\rightarrowtail^M$, so by the above, we conclude that $M$ is  ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail^M$.\nWe claim that the policy $\\rightarrowtail^M$ is local. This being the case, we obtain using Theorem~\\ref{thm:local-must-may}  that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail^M$.\nBy {{\\tt DRM}-}\\ref{cond:wa:commonvar}, we have that ${\\rightarrowtail^M} \\leq {\\rightarrowtail}$, so by Proposition~\\ref{prop:mustta-monotonic} we get that $M$ is  ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \n\nTo show that $\\rightarrowtail^M$ is local, define the equivalence relations $\\{\\sim_u\\}_{u\\in {D}}$ on $A^*$ by $\\alpha \\sim_u\\beta$ iff $s_0\\cdot \\alpha {\\approx_{u}} s_0\\cdot \\beta$. \nIt follows from the fact that $M$ satisfies DLR$_M$ with respect to $\\{{\\approx_{u}}\\}_{u\\in {D}}$ that $M$ satisfies DLR with respect to $\\{\\sim_u\\}_{u\\in {D}}$. \nAn argument similar to that above for WSC$^\\Diamond_M$, but using {\\xspace{{{\\tt DRM}-}5$'$}\\xspace} in place of {{\\tt DRM}-}\\ref{cond:wa:policyconsistency}, shows that \n$M$ also satisfies WSC with respect to   $\\{\\sim_u\\}_{u\\in {D}}$. Thus, for the smallest equivalence relations $\\{{\\sim^{\\mathit{unw}}}_u\\}_{u\\in {D}}$ \nsatisfying WSC and DLR with respect to $\\rightarrowtail^M$, we have ${{\\sim^{\\mathit{unw}}}_u} \\subseteq {\\sim_u}$ \nfor all $u\\in {D}$. Suppose that ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$ (with respect to policy $\\rightarrowtail^M$). \nWe need to show that $\\alpha \\models {u \\rightarrowtail^M v}$ iff $\\beta \\models {u \\rightarrowtail^M v}$. \nBy Lemma~\\ref{mayta-cont-unwind}, we have that $\\alpha {\\sim^{\\mathit{unw}}}_u \\beta$ and $\\alpha {\\sim^{\\mathit{unw}}}_v\\beta$. \nBy what was shown above, we obtain that $\\alpha \\sim_u \\beta$ and $\\alpha \\sim_v\\beta$, \nso $s_0\\cdot \\alpha \\approx_u s_0\\cdot \\beta$ and $s_0\\cdot\\alpha \\approx_v s_0\\cdot \\beta$. \nBy {\\xspace{{{\\tt DRM}-}5$'$}\\xspace} we now obtain that \n${{\\tt observe}(u, {s_0\\cdot \\alpha})} \\cap {{\\tt alter}(v, {s_0\\cdot \\alpha})} =  {{\\tt observe}(u, {s_0\\cdot \\beta})} \\cap {{\\tt alter}(v, {s_0\\cdot \\beta})}$. \nIt follows that $\\alpha \\models {u \\rightarrowtail^M v}$ iff $\\beta \\models {u \\rightarrowtail^M v}$, as required. \n\\end{proof} \n\nTheorem~\\ref{thm:ac-secure} shows that access control mechanisms \nprovide an implementation method that guarantees \nthat a system constructed using this method is secure. \nIt states a soundness result: any system that satisfies the \nreference monitor conditions with respect to a policy is secure for that \npolicy. \n\n\n\n\n\nIt is also possible to prove a converse to this result, stating that \nany system that is secure with respect to a policy \ncould have been constructed using access control \nmechanisms so as to satisfy the policy. To obtain such a \nresult, we need to allow consideration of \na bisimilar system. \nIn particular, we focus on the \n\\emph{unfolding} of a system $M$. \n\nSay that a system \\emph{admits an access control interpretation consistent with a policy \n$\\rightarrowtail$}, if it can be extended into a system with structured state by adding\ndefinitions of $O, V,  {\\tt contents}, {\\tt observe}$ and ${\\tt alter}$ in such a way as to \nsatisfy conditions {{\\tt DRM}-}1 to {{\\tt DRM}-}6. \n\n\n\\begin{theorem} \n\\label{thm:ac-complete} \nLet system $M$ be  ${{\\tt {ta}}^\\Diamond}$-secure   {with respect to\\xspace} $\\rightarrowtail$. \nThen ${\\mathit{unfold}}(M)$ admits an access control interpretation consistent with $\\rightarrowtail$. \n\nIf $M$ is ${{\\tt {ta}}^\\Box}$-secure  {with respect to\\xspace} $\\rightarrowtail$, \nthen \nthere exists a local policy ${\\rightarrowtail'} \\leq {\\rightarrowtail}$ such that \n${\\mathit{unfold}}(M)$ admits an access control interpretation consistent with $\\rightarrowtail'$,\nthat additionally satisfies {{\\tt DRM}-}$5'$. \n\\end{theorem}\n\n\\begin{proof}\nSuppose first that $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail$.  \nExtend ${\\mathit{unfold}}(M)$ to a system with structured state by the following definitions: \n \n", "index": 29, "text": "\\begin{align*}\n  & {O}  = {D} \\cup {\\tt Osets}(D) \\\\\n  & {{\\tt observe}(u, {\\alpha})} = \\{ u, {{\\tt oset}({u})} \\} \\\\\n  & {{\\tt alter}(u, {\\alpha})} = \\{ v \\in {D} \\mid \\alpha \\models u \\rightarrowtail v \\} \\\\\n  & {{\\tt contents}(x, {\\alpha})} = \n  \\begin{cases}\n   {{{\\tt {ta}}^\\Diamond}_{x}(\\alpha)} & \\text{if } x \\in {D} \\\\\n   \\{u, {{\\tt oset}({u})}\\} \n   & \\text{if } x = {{\\tt oset}({u})} \n  \\end{cases}   \n \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{O}={D}\\cup{\\tt Osets}(D)\" display=\"inline\"><mrow><mi>O</mi><mo>=</mo><mrow><mi>D</mi><mo>\u222a</mo><mrow><mi>\ud835\ude7e\ud835\ude9c\ud835\ude8e\ud835\ude9d\ud835\ude9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>D</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt observe}(u,{\\alpha})}=\\{u,{{\\tt oset}({u})}\\}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c\ud835\ude8e\ud835\ude9b\ud835\ude9f\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo>,</mo><mrow><mi>\ud835\ude98\ud835\ude9c\ud835\ude8e\ud835\ude9d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt alter}(u,{\\alpha})}=\\{v\\in{D}\\mid\\alpha\\models u%&#10;\\rightarrowtail v\\}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude8a\ud835\ude95\ud835\ude9d\ud835\ude8e\ud835\ude9b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>v</mi><mo>\u2208</mo><mi>D</mi></mrow><mo>\u2223</mo><mrow><mi>\u03b1</mi><mo>\u22a7</mo><mi>u</mi><mo>\u21a3</mo><mi>v</mi></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt contents}(x,{\\alpha})}=\\begin{cases}{{{\\tt{ta}}^{\\Diamond}}%&#10;_{x}(\\alpha)}&amp;\\text{if }x\\in{D}\\\\&#10;\\{u,{{\\tt oset}({u})}\\}&amp;\\text{if }x={{\\tt oset}({u})}\\end{cases}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude8c\ud835\ude98\ud835\ude97\ud835\ude9d\ud835\ude8e\ud835\ude97\ud835\ude9d\ud835\ude9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mmultiscripts><mi>\ud835\ude9d\ud835\ude8a</mi><none/><mi mathvariant=\"normal\">\u25c7</mi><mi>x</mi><none/></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>x</mi></mrow><mo>\u2208</mo><mi>D</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo>,</mo><mrow><mi>\ud835\ude98\ud835\ude9c\ud835\ude8e\ud835\ude9d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>\ud835\ude98\ud835\ude9c\ud835\ude8e\ud835\ude9d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05187.tex", "nexttext": "\n    It is immediate that if \n    $\\alpha \\models {v \\rightarrowtail u}$ and $\\alpha \\models {v \\rightarrowtail u}$ then \n    ${{\\tt observe}(u, { \\alpha})} \\cap {{\\tt alter}(v, { \\alpha})} = \\{u\\} =  {{\\tt observe}(u, { \\beta})} \\cap {{\\tt alter}(v, { \\beta})}$. \n    (We remark that we do not need the antecedents ${ \\alpha} {\\approx_{{u}}} { \\beta}$ and ${ \\alpha} {\\approx_{{v}}} { \\beta}$ of  {{\\tt DRM}-}\\ref{cond:wa:policyconsistency}, so we \n    have actually proved something stronger.) \\\\\n  \\item[{{\\tt DRM}-}\\ref{cond:wa:commonvar}:] We prove the contrapositive. \n    Suppose $\\alpha \\models {u \\not\\rightarrowtail v}$. \n    Then clearly \n    ${{\\tt alter}(u, { \\alpha})} \\cap {{\\tt observe}(v, \\alpha)} = \\{ w \\in {D} \\mid \\alpha \\models {u \\rightarrowtail w} \\} \\cap \\{ v, {{\\tt oset}({v})} \\} = \\emptyset$. \n \\end{enumerate}\n \nNext, suppose that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail$. \nBy Lemma~\\ref{lem:restrict-to-local} there exists a local policy ${\\rightarrowtail'} \\leq {\\rightarrowtail}$ such that $M$ is ${{\\tt {ta}}^\\Box}$-secure with respect to $\\rightarrowtail'$. \nBy Theorem~\\ref{thm:local-must-may}, $M$ is ${{\\tt {ta}}^\\Diamond}$-secure with respect to $\\rightarrowtail'$. \nHence, we may apply the above construction with respect to $\\rightarrowtail'$ instead of $\\rightarrowtail$, \nto obtain an access control interpretation consistent with $\\rightarrowtail'$. \nWe show that the stronger condition {\\xspace{{{\\tt DRM}-}5$'$}\\xspace}\\ also holds in this case. \n Let ${ \\alpha} {\\approx_{{u}}} { \\beta}$ and ${ \\alpha} {\\approx_{{v}}} { \\beta}$. \n    Then we have ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)}  = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$ and ${{{\\tt {ta}}^\\Diamond}_{v}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{v}(\\beta)}$, i.e., \n    $\\alpha \\sim^\\Diamond_u\\beta$ and      $\\alpha \\sim^\\Diamond_v\\beta$. We may work with the \n    relations $\\sim^\\Diamond$ in the definition of locality, so \n    from locality of $\\rightarrowtail'$, it  follows that $\\alpha \\models v \\rightarrowtail' u$ iff $\\beta \\models v \\rightarrowtail' u$. \n    If $\\alpha \\models v \\rightarrowtail' u$ and $\\beta \\models v \\rightarrowtail' u$ then \n      ${{\\tt observe}(u, { \\alpha})} \\cap {{\\tt alter}(v, { \\alpha})} = \\{u\\}  = {{\\tt observe}(u, { \\beta})} \\cap {{\\tt alter}(v, { \\beta})}$. \n      Alternately, if $\\alpha \\models v \\not\\rightarrowtail' u$ and $\\beta \\models v \\not\\rightarrowtail' u$ then \n      ${{\\tt observe}(u, { \\alpha})} \\cap {{\\tt alter}(v, { \\alpha})} = \\emptyset = {{\\tt observe}(u, { \\beta})} \\cap {{\\tt alter}(v, { \\beta})}$. \n      That is, in either case, we have the desired result. \n\\end{proof}\n\n\n\n\nTheorem~\\ref{thm:ac-complete} can be understood as \nsaying that every system that is secure with respect to a local policy could have been constructed \nusing access control mechanisms satisfying the reference monitor \nconditions, in such a way that its security follows using Theorem~\\ref{thm:ac-secure}. \nThe phrase ``could have been constructed\" here is formally interpreted as \nallowing bisimilar systems as equivalent alternate implementations. \nThus, this result states that the reference monitor conditions provide\nboth a sound and complete methodology for the construction of \nsystems that are secure with respect to local policies. \nThis result, and the intuitive nature of the dynamic reference monitor conditions, \nprovides further  justification for our definitions. \n\n\\section{Example: a capability system} \n\\label{sec:flume}\n\nIn the operating systems literature, {\\em capabilities} are\na commonly used representation for access control. They\nprovide a conceptual model that allows for dynamic security \npolicies, by allowing an agent possessing a capability to \ntransmit it to another agent, thereby granting the \nreceiver the powers associated with the capability. \nA number of works on {\\em Decentralized Information Flow Control} \nsystems \\cite{Krohn2009,Myers1997,Vandebogart2007,ZeldovichBKM06} have proposed capability-based systems as a mechanism\nfor implementing dynamic information flow policies. \nMany of the proposals in the literature  contain covert channels.\nIn this section, we  develop a simplified model that is in the spirit of  these proposals, \nbut tailored to be secure with respect to an associated policy. (Our model was\nmotivated by a consideration of Flume \\cite{Krohn2009}, but we have taken\nsignificant liberties in order to obtain a system that satisfies the desired result.\nWe discuss the motivation for our changes to Flume in Section~\\ref{sec:flume-comments}.) \n\n\n\\subsection{States and Observations} \n\nWe assume a set ${P}$ of processes, each corresponding to a domain, \nso ${D} = {P}$. There is a fixed set ${\\cal N}$ of \\emph{basic tag names}, \nfrom which the set ${\\mathcal{T}} = {\\cal N} \\cup \\{{n_{p}} ~|~n \\in {\\cal N},~ p \\in {P}\\}$ of \\emph{tags}\nis generated. Here, each tag $t\\in {\\cal N}$ is a tag that exists at system startup, and \n${n_{p}}$ is a tag that is labelled with the process $p$ that may create it.   A security level\nis represented as a subset of ${\\mathcal{T}}$. \nA \\emph{capability} is a value of the form either $t^+$ or $t^-$, where $t$ is a tag. \nIntuitively, $t^+$ represents the capability to add tag $t$ to a security level, and \n$t^-$ represents the capability to remove tag $t$ from a security level. \nWe write ${\\mathit{Capabilities}}$ for the set of all capabilities. \n\n\nEach process $p$ has an associated set ${\\mathit{Objects}}_p = {\\mathit{Data}}_p \\cup {\\mathit{PolicyState}}_p$  of \nobjects.  \nThe set ${\\mathit{PolicyState}}_p$ represents process $p$'s component of the policy, and \nconsists of the following special objects, each with an associated type (of possible values for the object) \n\\begin{itemize} \n\\item $S_p$ of type ${\\cal P}({\\mathcal{T}})$: the value of this object is a set of tags, and\nintuitively represents the types of information that process $p$ may receive. \nThe set $S_p$ is called the \\emph{secrecy} set of process $p$, and \nrepresents its security level. \n\\item $O_p$ of type ${\\cal P}({\\mathit{Capabilities}})$  the value of this object is a set of capabilities. \nThe set $O_p$ is called the \\emph{capability set} of process $p$, and represents the \nset of powers that the process has to add and remove tags from its security level.  \n\n\\end{itemize} \nThe set ${\\mathit{Data}}_p$ is the set of data objects that are local to process $p$. \nWe assume that the set ${\\mathit{Data}}_p$ contains at least the following: \n\\begin{itemize} \n\\item $m_p$, an outgoing message buffer, used by $p$ to construct a message\nprior to its transmission\n\\item $in_p$, of type a sequence of messages. This is the input buffer through which \n$p$ receives messages from other processes. \n\\end{itemize} \n\nA {\\em state} is a function $s$  assigning a value of the appropriate type to each \nobject in $\\bigcup_{p\\in {P}} {\\mathit{Objects}}_p$.  We write $S$ for the set of states. \nA {\\em candidate initial state} is a state $s$ such that \nfor all processes $p$, we have $O_p \\subseteq \\{ n^x ~|~n \\in {\\cal N}, x\\in \\{+,-\\}\\}$\nand $S_p \\subseteq {\\cal N}$. That is, in an initial state, only basic tags exist; tags local \nto a process need to be created as the system runs. \nWe allow the initial state of a system to be any candidate initial state: different \nchoices of initial state correspond to different initial \nconfigurations of the security policy. \n\nThe observation functions of a capability system may  be defined as any\nfunctions that satisfy the following constraint, for each process $p$ and all states $s$ and $t$: \n\\begin{itemize}\n\\item[{\\tt Obs}.]  If $s{\\upharpoonright} {\\mathit{Objects}}_p = t{\\upharpoonright} {\\mathit{Objects}}_p$ then ${\\tt obs}_p(s) = {\\tt obs}_p(t)$. \n\\end{itemize} \nThat is, observations depend, for each process, only on its own objects.\n\nGiven the intuition that the set $S_p$ represents the types of \ninformation that process $p$ may receive. Note that if $S_p$ contains\na tag $t$ then $p$ may have received information of type $t$. \nIf $t$ is not in $S_q$ for some other process $q$, then there is a risk that if $p$ \ntransfers information to $q$ then $q$ will obtain information of type $t$, \nwhich is prohibited. This suggests that with each state $s$, we may naturally \nassociate a static policy $\\rightarrowtail$, such that $p \\rightarrowtail q$ iff $S_p(s) \\subseteq S_q(s)$. \nIn what follows, it is convenient to write $s\\models S_p \\subseteq S_q$ when \n$s(S_p) \\subseteq s(S_q)$. \n\n\n\\subsection{Actions and Transitions}\n\nThe following actions are possible in the system. \nWe write actions in the format $p.a$, where $p\\in {P}$ is a\nprocess, and define the domain of action $p.a$ to be \n${\\tt dom}(p.a) = p$. \n\n\n\n\n\n\n\n\n\n\n\\begin{description}\n\\item[Data actions $p.a$] ~\\\\ We assume that $p$ has some set of data manipulating actions \nthat act on its data objects. This set of actions can be instantiated in any way, subject to the \nconstraint that these actions read only the local state of the process and write only the data objects of the process. \nMore precisely, for any data action $p.a$, \nwe assume the following, for all states $s$ and $t$:  \n\\begin{itemize} \n\\item[{\\tt Data1}.]  For all objects $x\\not\\in {\\mathit{Data}}_p$, $(s\\cdot p.a)(x) = s(x)$. \n\\item[{\\tt Data2}.]  If $s(x) = t(x)$ for all $x\\in {\\mathit{Objects}}_p$, then $(s\\cdot p.a)(x) = (t\\cdot p.a)(x)$ for all $x\\in {\\mathit{Data}}_p$. \n\\end{itemize}  \nConstraint {\\tt Data1} says that data actions of process $p$ change only $p$'s data objects, \nand no others. Constraint {\\tt Data2} says that the way that such an action changes $p$'s \ndata objects depends only on the value of $p$'s data and policy state objects. That is, a data action $p.a$ \nis deterministic and may read only objects in ${\\mathit{Objects}}_p$ and write only objects in ${\\mathit{Data}}_p$. \\\\\n\n\n\n\\item[${p.{\\sf add\\_cap}(c,n)}$] where $n\\in {\\cal N}$ and  $c\\subseteq \\{+, -\\}$ with code\n  \\begin{tabbing} \n\\quad   $O_p := O_p \\cup \\{{n_{p}}^x~|~x\\in c\\}$ \n  \\end{tabbing} \n Intuitively, this action creates a new tag ${n_{p}}$, if it does not already exist, and grants $p$  \n the rights $c$ over this tag, by adding the capabilities \n $ {n_{p}}^x$ for $x\\in c$ to $p$'s capability set $O_p$. \n(If the tag already exists, the operation may be used to add capabilities   \nto the existing ones.) Note that the fact that the tag created is indexed by the process $p$ \nmeans that two distinct processes cannot create a tag with the same name.\\\\\n  \n \\item[${{p}.{\\sf drop\\_cap}({c})}$]  where $c\\in {\\mathit{Capabilities}}$, with code  \n    \\begin{tabbing} \n\\quad $O_p := O_p \\setminus \\{c\\} $ \n  \\end{tabbing} \nThis action removes the capability $c$ from $p's$ capability set, if\npresent. \\\\\n\n  \n  \n  \n \\item[${p.{\\sf add\\_tag}(t)}$] where $t\\in {\\mathcal{T}}$, with code  \n  \\begin{tabbing} \n \\quad  If $t^+ \\in O_p $ \\=then $ S_p := S_p \\cup \\{t\\}$ \n   \\end{tabbing} \n  This action adds a tag to the secrecy set of the process, \n  provided it has the capability to do so. A consequence of this is\n  that some outgoing edges from $p$ may be removed from the policy, \n  and some ingoing edges may be added. \\\\\n  \n \\item[${p.{\\sf remove\\_tag}(t)}$]  where $t \\in {\\mathcal{T}}$, with code \n    \\begin{tabbing} \n  \\quad If $t^- \\in O_p$ \\=then $ S_p := S_p \\setminus \\{t\\} $  \n  \\end{tabbing} \n This action removes a tag from the secrecy set of the process, provided it has the \n capability to do so, and \n consequently might add outgoing policy edges from $p$ or insert incoming edges.  \n Intuitively, by removing the tag, $p$ enables declassification of information of type $p$; \n whereas it may have received information of  type $t$, the policy is no longer \n constrained to restrict $p$ from communicating with processes that are \n not permitted to receive information of type $t$. \\\\\n \n\n \\item[${p.{\\sf send\\_message\\_to}(q)}$]   where $q$ is a process,  with code  \n  \\begin{tabbing} \n  \\quad If $S_p \\subseteq  S_q$ \\=then $ in_q := in_q \\cdot m_p$  \n  \\end{tabbing} \nThis action transmits the message in the message object $m_p$ to $q$ by adding it\nto the end of $q's$ input buffer $in_p$, \nprovided the policy permits transmission of information from $p$ to $q$ \n(i.e., $S_p \\subseteq  S_q$). The action has no effect on the policy, even \nif the message contains information about $p$'s tags and/or capabilities. \nIntuitively, we assume that the operating system is responsible for maintaining\nthe policy state, and mere knowledge of a capability name or value does not\nsuffice to be able to exercise the capability. In order to transmit the ability to exercise\ncapabilities, the following action needs to be used. \\\\\n\n \\item[${p.{\\sf send\\_cap}(c,q)}$]  where $c \\in {\\mathit{Capabilities}}$ and $q$ is a process,  with code\n  \\begin{tabbing} \n  \\quad If $S_p \\subseteq  S_q$ and $c \\in O_p$ \\=then $O_q := O_q \\cup \\{c\\} $ .  \n  \\end{tabbing}\n  This action transmits the capability $c$ to $q$, \n  provided both that $p$ is permitted to transmit information to $q$ (i.e., $S_p \\subseteq  S_q$)\n  and $p$ actually possesses the capability (i.e., $c\\in O_p$). \n The effect of this action may be to remove outgoing edges from $q$\n or add incoming edges to $q$. \n\n \\end{description}\n \n\n\n\\subsection{Security of the capability model} \n\nWe now establish the security of any capability system constructed as \tdescribed above. \nNote that there are multiple such systems, since the description \nabove leaves open the choice of  processes, basic tag names, data objects, data actions, initial state\nand observation functions. It also remains to specify a dynamic security policy. \nGiven a capability system $M$ with actions $A$ and processes ${P}$, and initial state $s_0$, we say that the \n\\emph{associated policy} is the policy $\\rightarrowtail^M$ defined by \n$\\alpha \\models {p \\rightarrowtail^M q}$ when $s_0\\cdot \\alpha \\models S_p \\subseteq S_q$. \n The following states that a capability system is secure with respect to the \nthe associated security policy. \n\n\\begin{theorem} \n\\label{thm:capsystem-associated} \nLet $M$ be a capability system. Then the associated policy  $\\rightarrowtail^M$ is local, and  \nthe system $M$ is both ${{\\tt {ta}}^\\Diamond}$-secure and ${{\\tt {ta}}^\\Box}$-secure\nwith respect to $\\rightarrowtail^M$. \n\\end{theorem} \n\n\\begin{proof*} \nWe show that $M$ admits an access control interpretation consistent with $\\rightarrowtail^M$ \nand apply Theorem~\\ref{thm:ac-secure}. \n\nFor the set of objects of the access control interpretation, we take\n${O} = \\cup_{p \\in {P}} {\\mathit{Objects}}_p \\cup \\{ {{\\tt oset}({p})}\\} $. \n(Since both the access control model and the capability model use a notion of \n\\emph{object}, and these are not quite the same when relating the two models,\nthe reader needs to bear in mind that ${O}$ refers to the objects in the acccess control \nmodel and ${\\mathit{Objects}}$ refers to objects in the capability model.) \nWe define the access control functions for states $s$ and processes $p$ by \n${{\\tt observe}(p, s)}  = {\\mathit{Objects}}_p \\cup \\{ {{\\tt oset}({p})}\\}$ \nand ${{\\tt alter}(p, s)}= {\\mathit{Objects}}_p \\cup \\{ in_q, O_q~|~s\\models S_p \\subseteq S_q\\}$. \nFor each state $s$ and object $o \\in \\cup_{p \\in {P}} {\\mathit{Objects}}_p$, \nwe define ${{\\tt contents}(o, s)}  = s(o)$, and (as is necessary) for $o = {{\\tt oset}({p})}$, \nwe define ${{\\tt contents}(o, s)}  = {{\\tt observe}(s, p)}$. \nWe need to show that conditions {{\\tt DRM}-}1 to {{\\tt DRM}-}4, {{\\tt DRM}-}5' and {{\\tt DRM}-}6 are satisfied \nby these definitions. \n\nNote that, by definition of ${\\approx_{{p}}}$, and the definitions above, we have \n$s {\\approx_{{p}}} t $ iff  for all $o\\in {\\mathit{Objects}}_p$ we have $s(o) = t(o)$\n(the contents of ${{\\tt oset}({p})}$ are static). \n\nAdditionally, $o \\in {{\\tt alter}(p, s)} \\cap {{\\tt observe}(q, s)}$ iff \n$p = q$ and $o \\in {\\mathit{Objects}}_p$ or \n$p \\neq q$ and $s\\models S_p \\subseteq S_q$ and $o \\in \\{in_q, O_q\\}$.  \n    \n\\begin{enumerate}\n\\item[{{\\tt DRM}-}\\ref{cond:wa:outputconsistency}:]\n  This is immediate from the above characterization of ${\\approx_{{p}}}$ and the constraint \n  {\\tt Obs}. \n\n\\item [{{\\tt DRM}-}\\ref{cond:wa:contentconsistency}:]\nSuppose $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)} \\cap {{\\tt alter}({{\\tt dom}(a)}, t)}$ and  $s {\\approx_{{{\\tt dom}(a)}}} t$\nand  ${{\\tt contents}(o, s)} = {{\\tt contents}(o, t)}$. We need to show that ${{\\tt contents}(o, {s\\cdot a})} = {{\\tt contents}(o, {t \\cdot a})}$. \nBy definition, we have $o \\in {{\\tt alter}({{\\tt dom}(a)}, s)} \\cap {{\\tt alter}({{\\tt dom}(a)}, t)}$ \njust when either $o \\in {\\mathit{Objects}}_{{\\tt dom}(a)}$ or $o \\in \\{in_q, O_q\\} $ for some process $q$ such that \n$s\\models S_{{\\tt dom}(a)} \\subseteq S_q$. \n{From } $s {\\approx_{{{\\tt dom}(a)}}} t$ we have that $s{\\upharpoonright} {\\tt dom}(a) = t {\\upharpoonright} {\\tt dom}(a)$, \nand from ${{\\tt contents}(o, s)} = {{\\tt contents}(o, t)}$ we have \n$s(o) = t(o)$. \n\nWe argue that  ${{\\tt contents}(o, {s\\cdot a})} = {{\\tt contents}(o, {t \\cdot a})}$, \ni.e., $(s\\cdot a)(o) = (t\\cdot a)(o)$, for each possibility for the action $a$. \n\\begin{itemize} \n\\item If $a$ is a data action $p. b$ (so that $p = {\\tt dom}(a)$), then\nif $o \\notin Data_{{\\tt dom}(a)}$, we have by {\\tt Data1} that $(s\\cdot a)(o) = s(o) = t(o) = (t\\cdot a)(o)$.\nIn the case $o \\notin Data_{{\\tt dom}(a)}$, we have $o \\in {\\mathit{Objects}}_{{\\tt dom}(a)}$, and\n$(s\\cdot a)(o)  = (t\\cdot a)(o)$ follows by {\\tt Data2}. \n\n\\item The code for each of the actions ${p.{\\sf add\\_cap}(c,n)}$, ${{p}.{\\sf drop\\_cap}({c})}$, \n${p.{\\sf add\\_tag}(t)}$, ${p.{\\sf remove\\_tag}(t)}$, reads only objects in ${\\mathit{Objects}}_p$ and \nwrites only objects in ${\\mathit{Objects}}_p$. If $a$ is one of these actions, then\n$p = dom(a)$ and  the claim holds. \n\n\\item \nThe only object that can be changed by the code for the action\n$a = {p.{\\sf send\\_message\\_to}(q)}$ is $in_q$, so this is the only case of $o$ that \nwe need to consider. If ${\\tt dom}(a) = p = q$, then the condition $S_p \\models S_q$ is a \ntautology, so the code performs the assignment $in_p := in_p \\cdot m_p$ \nin both states $s$ and $t$. If ${\\tt dom}(a) = p \\neq q$, then from \n$o = in_q \\in {{\\tt alter}({{\\tt dom}(a)}, s)} \\cap {{\\tt alter}({{\\tt dom}(a)}, t)}$ we have both \n$s\\models S_p \\subseteq S_q$ and $t\\models S_p \\subseteq S_q$. \nThus, again, the code takes the same branch in both cases, \nand since $m_p \\in {\\mathit{Objects}}_p$ we have $s(m_p) = t(m_p)$ \nand we have $(s\\cdot a)(in_q) =s(in_q) \\cdot  s(m_p) = t(in_q) \\cdot  t(m_p) = (t\\cdot a)(in_q)$, \nas required. \n\nThe argument for the action ${p.{\\sf send\\_cap}(c,q)}$ is similar. \n\\end{itemize} \n\n\\item[{{\\tt DRM}-}\\ref{cond:wa:allowedinterference}:] \nSuppose that $o \\notin {{\\tt alter}({{\\tt dom}(a)}, s)}$. Since ${\\mathit{Objects}}_{{\\tt dom}(a)} \\subseteq {{\\tt alter}({{\\tt dom}(a)}, s)}$, \nwe have $o \\notin {\\mathit{Objects}}_{{\\tt dom}(a)}$.  It follows that data actions $a$ and actions $a$ of the forms\n${p.{\\sf add\\_cap}(c,n)}$, ${{p}.{\\sf drop\\_cap}({c})}$, \n${p.{\\sf add\\_tag}(t)}$, ${p.{\\sf remove\\_tag}(t)}$ do not change the value of $o$, since\nthese actions change only the values of objects in ${\\mathit{Objects}}_{{\\tt dom}(a)}$.  \nIn the case of $a = {p.{\\sf send\\_message\\_to}(q)}$ and ${p.{\\sf send\\_cap}(c,q)}$, \nwe have from $o \\notin {{\\tt alter}({{\\tt dom}(a)}, s)}$ that  $o$ is not one of the\ntwo possible objects $in_q$ and $O_q$ whose values these actions can change, \nso again, these actions do not change the value of $o$. \n\n\\item[{{\\tt DRM}-}\\ref{cond:wa:grantobserve}:]  \nThis is immediate from the fact that the value of ${{\\tt observe}(s, p)}$ is a constant. \n \n\\item[{\\xspace{{{\\tt DRM}-}5$'$}\\xspace}:] \nSuppose $s {\\approx_{{p}}} t$ and $s {\\approx_{{q}}} t$. \nWe need to show that ${{\\tt alter}(p, s)} \\cap {{\\tt observe}(q, s)} = {{\\tt alter}(p, t)} \\cap {{\\tt observe}(q, t)}$.  \nNow ${{\\tt observe}(q, s)}$ is a constant, and if $p = q$ then ${{\\tt alter}(p, s)} = {\\mathit{Objects}}_p$ is also a constant, \nso we need only consider the case $p \\neq q$. \nIn this case, ${{\\tt alter}(p, s)} \\cap {{\\tt observe}(q, s)}$ is $ \\{ in_q, O_q\\}$ if $s\\models S_p \\subseteq S_q$\nand is $\\emptyset$ otherwise. From $s {\\approx_{{p}}} t$ and $s {\\approx_{{q}}} t$ we get that \n$s(S_p) = t(S_p)$ and $s(S_q) = t(S_q)$, so $s\\models S_p \\subseteq S_q$ iff $t\\models S_p \\subseteq S_q$. \nThus, ${{\\tt alter}(p, s)} \\cap {{\\tt observe}(q, s)} = {{\\tt alter}(p, t)} \\cap {{\\tt observe}(q, t)}$.  \n\n\\item[{{\\tt DRM}-}\\ref{cond:wa:commonvar}:] \nNote that for $p \\neq q$, the sets ${\\mathit{Objects}}_p$ and ${\\mathit{Objects}}_q$ are disjoint. \nIt follows that if ${{\\tt alter}(p, {s_0\\cdot \\alpha})} \\cap {{\\tt observe}(q, {s_0\\cdot \\alpha})} \\neq \\emptyset$, then  \nwe have either $p= q$ or $s_0\\cdot \\alpha \\models S_p \\subseteq S_q$. In either case, \nwe have $s_0\\cdot \\alpha \\models S_p \\subseteq S_q$, i.e., $\\alpha \\models {p \\rightarrowtail^M q}$. \n{\\hfill{$\\Box$}}\n\\end{enumerate}      \n\\end{proof*} \n\n\n\nIt follows from Theorem~\\ref{thm:capsystem-associated}\nthat a capability system is secure with respect to any policy that is no more\nrestrictive than the associated policy. \n\n\\begin{corollary} \n\\label{corol:capability-monotonicity} \nLet $M$ be a capability system. Then for any dynamic security policy $\\rightarrowtail$ with \n${\\rightarrowtail^M} \\leq {\\rightarrowtail}$, the system $M$ is both ${{\\tt {ta}}^\\Diamond}$-secure and ${{\\tt {ta}}^\\Box}$-secure\nwith respect to $\\rightarrowtail$. \n\\end{corollary}\n\n\\begin{proof} \nImmediate from Theorem~\\ref{thm:capsystem-associated} using Proposition~\\ref{prop:mustta-monotonic} and Proposition~\\ref{prop:may-monotonic}. \n\\end{proof} \n\n\n\\subsection{Comments on Flume} \n\\label{sec:flume-comments}\n \n\nThe capability system described above is somewhat motivated by Flume \\cite{Krohn2009}, \nbut differs in a number of respects.\n We comment here on the differences.  \n\nFirst, Flume associates both a {\\em secrecy set} $S_p\\subseteq {\\mathcal{T}}$ and an \n{\\em integrity set} $I_p \\subseteq {\\mathcal{T}}$  to each agent $p$. These operate dually, \nso we have avoided inclusion of the integrity set just for simplicity. Our formulation \ncould be extended to include it. \n\n\nNext, Flume permits transmission of information from $p$ to $q$ when \n$S_p \\setminus D_p \\subseteq S_q \\cup D_q$, where $D_u$ is the set of tags \nfor which $u$ possesses  both the capability to add and remove the tag. \nThe intuition for this definition is that if $p$ wishes to transmit information to $q$, \nbut is constrained from doing so because $S_p$ contains a tag $t$ \nthat are not in $S_q$, then this obstacle would be overcome\nif $p$ is able to remove the tag from $S_p$ or if $q$ is able to add the tag to $S_q$. \nAssuming no other obstacles, the transmission could then proceed. Moreover, if, \ncorrespondingly, $p$ is also able to add the tag or\n$q$ is able to remove it, then after the transmission, the policy could be restored\nto its original state. Thus, the condition $S_p \\setminus D_p \\subseteq S_q \\cup D_q$\ncaptures the situations where this sequence of moves would allow transmission from \n$p$ to $q$ while leaving the policy state unchanged after the transmission is complete. \nThe thinking then is that since such a sequence of moves cannot be prevented, the policy may as well \nallow the transmission directly. \n\nWe are not convinced that this is a good idea. One reason for $p$ to have a tag in $D_p$ \nbut not in $S_p$ might be that $p$ wishes to protect itself against {\\em inadvertent} \ntransmission of information to $q$. Mechanisms such as {\\em sudo} \nand the discretionary access controls on a user's own objects in \nUnix are explicitly designed to disable the effects of actions that the \nuser nevertheless has the capacity to enable, and it seems useful\nto have a similar discretionary layer of control for information flow policies. \nSo we have not followed Flume in adopting this modification of the basic policy.  \n\nThe Flume model includes a set $\\hat{O}$ of {\\em global capabilities}, that \nare implicitly owned by all domains. That is, Flume works with the sets of owned\ncapabilities  $\\overline{O}_p = O_p \\cup \\hat{O}$. When creating a tag, an agent \nis able to place the associated capabilities into $\\hat{O}$. The motivation \nfor this appears to be the following (\\cite{Krohn2009} section II.D): \n\n\\begin{quote} \nThe most important policy in Flume is {\\em export protection}, wherein\nuntrustworthy processes can compute with secret data without the ability\nto reveal it. An export protection tag is a tag $t$ \nsuch that $t^+ \\in \\hat{O}$ and $t^-\\in \\hat{O}$. For a process $p$ to \nachieve such a result, it creates a new tag $t$ and grants $t^+$ to the \nglobal set $\\hat{O}$, while closely guarding $t^-$.  To protect a file $f$, $p$ creates the \nfile with secrecy label $\\{t\\}$. If a process $q$ wishes to read $f$, it must first \nadd $t$ to $S_q$, which it can do since $t^+ \\in \\hat{O} \\subseteq \\overline{O}_q$. \nNow, $q$ can only send messages to other processes with $t$ in their labels. \nIt requires $p$'s authorization to remove $t$ from its label or send data to the \nnetwork. \n\\end{quote}  \n\nWe have not followed Flume in including the set of global capabilities $O$. \nOne reason is that we find the above argument unconvincing. Once \n$t^+$ is in $\\hat{O}$, not just $q$, but any other agent $r$ may add $t$ to its secrecy set, \nand any protection afforded by tag $t$ is then eliminated. \nThe main reason that Krohn and Tromer have in mind that $r$ might not be able\nto add $t$ to its secrecy set is that $t$ is randomly generated, and \n$r$ does not know the appropriate value to use, making it a low probability \nevent that $r$ should add $t$ unless it somehow receives $t^+$ in a chain \nof transmission from $p$. But in that case, we may as well rely upon the \ndirect transmission of $t^+$ to the set $O_r$ as the enabler for \n$r$'s adding $t$ to its secrecy set. There does not appear to be \nany necessary role for $\\hat{O}$ in the above argument. \n\nAnother reason for not following Flume in the inclusion of the global set $\\hat{O}$ \nis that it  causes a covert channel. \nAn agent $p$ may choose to add a capability $t$ to $O$, \nand any other agent $q$ can test whether the \ncapability $t$ is in $O$ or not. This causes a flow of\ninformation from $p$ to $q$.  Krohn and Tromer are aware of this covert channel \nand seek to mitigate it by randomizing tag names. \nHowever this means that they require a much more complicated \nprobabilistic version of noninterference semantics. \nIt is not clear to us whether their semantics is well-formulated, \nsince some subtle points appear to have been overlooked. \nNote that their systems have both probabilistic transitions\n(random generation of tag names) and nondeterministic \ntransitions (agent's choice of their actions). \nThis means that there is not a straightforward probability \ndistribution on runs. How to handle the mix of probability and nondeterminism \nis an issue that has been studied in the literature, \nand involves a number of subtleties \\cite{JSM97,Cheung}. It does not\nappear that Krohn and Tromer are aware of these issues, indeed, they do not even \ndefine the probability space that they use. It would seem \nthat, at the very least, some non-trivial further details are needed to make \ntheir result fully precise, which we will not pursue here.\n\nFinally, Flume allows for dynamic creation of processes by means of a forking operation. \nIt uses this to represent newly created objects as processes. \nOur policy model assumes a fixed set of domains, so this aspect of \nFlume cannot be directly represented. It would be interesting \nto develop an extension of our framework  with the expressiveness\nto encompass creation of objects and agents.\n\n\n\n\\section{Related Work} \n\\label{sec:relatedwork}\n\nRelated work using an automaton-based semantics similar to the one we\nhave used in the paper has already been discussed in detail in Section~\\ref{sec:related:aut}. \nWe focus here on work in the context of programming language security\nthat has considered dynamic information flow policies.  \nA recent survey of dynamic \npolicies in the context of programming languages is \\cite{BrobergDS15}.  \nThey attempt to develop a classification based on various ``facets\" that \nare factored into the wide spectrum of definitions of security in this area.\nIn general, there exist nontrivial gaps between the semantic frameworks used in \nthis literature and our semantic model. Even \\emph{within} the programming language literature, \nformal relationships between the various semantics studied are rarely presented.  \nWe therefore give only some informal comparisons \nwith our work.\n\nOne of the facets discussed in \\cite{BrobergDS15} is the distinction between \n``whitelisting flows\" and ``blacklisting flows\", which is similar to our\ndistinction between a permissive and a prohibitive reading of policies.  \nInterestingly, the whitelisting/permissive reading is claimed to be the \nnorm in the programming language security literature.\n\nHowever, there are also significant points of difference.\nGenerally these works concern a programming language framework in which \nthe secrets to be concealed are already encoded into the initial state, rather than \nour ``interactive\" model in which secrets are  generated\non the fly as the result of nondeterministic choices of action made by the agents. \nFrequently, the programming languages studied are deterministic, \nso a direct relationship to our setting is not immediately clear. \nThere exists an approach by Clarke and Hunt~\\cite{ClarkH08} to \nhandling interactivity in a programming language setting  \nby including stream variables in the initial state to represent the\nsequence of future inputs that will be selected by an agent over the \ncourse of the run. However, this, in effect, assumes that the scheduler \nalso is deterministic. Adding a variable for the schedule and \nallowing other agents to learn the complete schedule would \nbe more permissive than a definition such as {TA-security\\xspace}, \nsince this restricts the information that agents may learn about the schedule. \nIt therefore seems that establishing an exact correspondence would \nrequire some detailed work. \n\nAnother significant point of difference is that in \nthe programming language literature, the policy and the system model (program) \nare often tightly intertwined, whereas we have a separate policy and system model, \njust as a specification and implementation  are usually considered distinct. \nOther works that do allow for such a  separation include \nMorgan \\cite{Morgan09} develops a refinement calculus that allows for mixtures\nof information flow specifications and code, enabling  an implementation to \nbe derived from a specification via steps that mix the two, and  \nDelft et. al.~\\cite{DelftHS15}, who develop a type theory for dynamic information \nflow that operates on a program separately from the dynamic policy. \n\nOne of the ways that  intransitivity is handled in the programming \nlanguage setting also involves a dynamic aspect to policies: \nspecial constructs are introduced that allow temporary violations of a static policy, \neither through use of special basic actions or the establishment of a \nprogram region within which an alternate policy is enforced. \nFor example, Mantel and Sands~\\cite{Mantel:Sands:APLAS04} \nwork with a classical transitive security policy, but add downgrading commands \nthat may violate this policy (subject to some alternate constraints.) \nThey give a security definition that uses a specially defined bisimulation \nrelation. \n\n\nBroberg and Sands \\cite{Broberg2006,Broberg2009} \ndefine \\emph{flow locks}, which enable variables \nto be typed with conditional annotations that constrain the \nsecurity levels to which contents of these variables may flow. \nThe values referred to in the conditions may be altered during the execution \nof the program, thereby making the policy dynamic. \n The authors give a complex bisimulation-based semantics \n to these policies  \\cite{Broberg2006}, but in later work \n \\cite{Broberg2009} prefer an alternate knowledge-based semantics, with a \n perfect recall interpretation of knowledge. It appears that their definitions are closer to those for \na classical purge-based definition than to our intransitive policies. \nTo capture a downgrader policy $H \\rightarrowtail D \\rightarrowtail L$, \nsuch as to allow information from $H$ to reach $L$ via $D$, it seems necessary to \ntemporarily change the policy to effectively add an edge $H\\rightarrowtail L$ to the policy, \nallowing a direct flow from $H$ to~$L$. \nThis is not in the spirit of intransitive noninterference, which intends to capture \nthat all flows from $H$ to $L$ must pass through~$D$. \n\nChong and Myers \\cite{ChongM04} propose to handle declassification violations of \ntransitive policy using a notion  of \\emph{noninterference until declassification}  \nwhich applies a classical noninterference definition on runs \njust up to the point where a sequence of events has occurred\non the basis of which the policy permits a declassification of secret information \nto the domain under consideration.\nBeyond this point,  the definition does not constrain the behaviour of the system. \nHicks et al \\cite{HTHZ05} refine this idea to impose constraints on longer runs, \ndeclaring these secure if they consist of a sequence of \npolicy-update free fragments, each of which satisfies the standard noninterference condition. \nThis extension is also applied in Swamy et al \\cite{SwamyHTZ06}, who develop a language with \ndynamic role-based information flow policies. This approach  \nis also similar to the approach used by Almeida-Matos and Boudol \\cite{MatosB09}, who  \nwork in a language-based setting where a transitive policy can temporarily be extended\nby addition of new edges (yielding another transitive policy).  \nTheir security condition states, using a bisimulation,  \nthat each transition in an execution is secure with respect to the transitive \npolicy in place at the time the transition is taken. \nWe note that these approaches generally do not handle covert channels resulting from the policy\nchanges themselves, as illustrated in our Example~\\ref{ex:conflict-example}. \n\n\n\nAll of the above approaches, like ours in this paper, work with perfect recall definitions  of attacker knowledge. \nAskarov and Chong \\cite{Askarov2012} point to an interesting issue with respect to dynamic security policies, \nwhich is that events may transmit ``old news\": information that would have been allowed to be transmitted \nto an attacker according to an earlier state of the security policy, but was actually not transmitted.   \nThe current state of the policy may prohibit the flow of this information. In this case, \nsecurity definitions that are based on a perfect recall model of attacker knowledge, \nfail to identify such transmissions of ``old news\" as violations of security. \n  \nIn response to this observation, Askarov and Chong propose to work with attackers that are weaker than the perfect\nrecall attacker. They define a notion of knowledge for such attackers, and state definitions \nof security that require that any new knowledge gained by an attacker at security level (domain) $u$  should \nonly concern security levels $v$ such that $v\\rightarrowtail u$ according to the security policy \nat the time of the event. They identify some potential weaker attackers, but do not identify a definitive set of attackers; \nsince the attacker is a parameter of their proposed security definition one could view the set of attackers\nagainst which a system should be secure as a matter of policy. \n\nOne of the attackers considered by Askarov  and Chong is the perfect recall attacker, and here it is \nreasonable to attempt to compare their framework to ours. Unfortunately, making such a comparison formally is \nnot completely straightforward because their semantic setting is somewhat different from ours: \nwhereas in our framework there are multiple causal agents (the domains), who are free to \nchoose any action at any time, in theirs there is a single causal agent (a deterministic program) that reads\nand writes information from different security domains. However, there is one respect where \na clear difference of intent is apparent in their intuitions and definitions. \n\nConsider a situation with domains $D = \\{ A,B,C, P\\}$. \nLet $\\Delta$ be the policy $\\{u \\rightarrowtail u ~|~ u \\in D \\} \\cup \\{ P \\rightarrowtail u~|~ u \\in D\\}$. \nIntuitively, $P$ here is the policy authority, and $\\Delta$ states that all domains are permitted to know the state of the policy. \nIn the initial state of the system,  take the policy to be $\\Delta \\cup \\{A\\rightarrowtail B\\}$. \nAny actions performed by $A$ are, intuitively, permitted by this policy to be recorded in the state of $B$, \nbut should remain unknown to $C$. Suppose that after some actions by $A$, the policy agent changes the policy to \n$\\Delta \\cup \\{B\\rightarrowtail C\\}$. Now, $B$ is permitted to communicate with $C$. According to our intuitions and formal definitions, \n$B$ may now send  to $C$ the information it has about the actions that $A$ performed before the policy change. \nSuch flows from $A$ to $C$ via $B$ are typical of the flows that intransitive policies are intended to permit \\cite{HY87}. \n\nHowever, according to Askarov and Chong's definitions (both for the perfect recall attacker and weaker attackers), if \nan action now copies this information from $B$'s state and it is observed by $C$, this is a violation of \nsecurity, because in a transition where it makes the observation, $C$ learns new information about $A$, whereas the current state of the \npolicy prohibits it from doing so. Thus, although Askarov and Chong permit intransitive \npolicies, we would argue that their definitions do not handle dynamic intransitivity in a way that \nfits our intuitions: their semantics can best be characterized as a dynamic version of \nthe classical purge-based definition of security, rather than a dynamic version of a semantics\nfor intransitive noninterference. \nThe details of Askarov and Chong's semantics are refined\nin \\cite{DelftHS15}, but similar remarks apply to to this work.\n \n\n\\section{Conclusion} \n\nWe have developed two generalizations for intransitive dynamic policies \nof the notion of TA-security that has recently been argued to provide a \nbetter semantics for static policies. One is based on a permissive reading\nof policy edges, the other on a prohibitive reading of policy edges. Under\nthe natural condition of locality, the two readings are equivalent. \nWe have also provided proof theory for these notions in the form of unwinding \nconditions and a sound and complete policy enforcement method using  \naccess control. Finally, we have demonstrated the applicability of the theory\nby applying it to establish security for a natural capability model. \n\n\nSeveral interesting directions remain open for further investigation. One\nconcerns the circularity in the justification of ${{\\tt {ta}}^\\Box}$-security. \nWhile ${{\\tt {ta}}^\\Box}$-security is, as we have shown, self-consistent, \nthere may be further natural constraints that also lead to self-consistent\nnotions of security. For example, one candidate is to require for information transfer that the sender know that there is an edge from it \nto the receiver, in place of the assumption we made in ${{\\tt {ta}}^\\Box}$-security that\nthe sender and receiver must jointly know that there is such an edge. \nWhether such a constraint should apply is arguably a matter of policy. \nThis suggests that there may be a case for a policy language that\nmore explicitly provides a way to express conditions on  agent knowledge. \nIt would also be of interest to develop algorithms for verifying whether a system satisfies a policy. \nBoth models and dynamic policies as we have defined them are highly expressive, \nso this would require some restrictions: finite state models and policies that \nare representable using finite state automata would be one interesting starting\npoint: it remains to be shown that this case is decidable. \n\nWe have shown that  while ${{\\tt {ta}}^\\Diamond}$-security is more expressive than ${{\\tt {ta}}^\\Box}$-security, \nthe difference between these notions applies only in the case of non-local policies. \nBoth are associated with natural  intuitions, but we leave open the question of whether the\nextra expressiveness of ${{\\tt {ta}}^\\Diamond}$-security is necessary in practice, i.e., whether there are any \ninteresting systems requiring non-local policies where ${{\\tt {ta}}^\\Diamond}$-security, rather than ${{\\tt {ta}}^\\Box}$-security, is the appropriate notion \nof security. The main realistic example we have presented, the capability system of Section~\\ref{sec:flume} involves a local policy, \nso it does not resolve this question. The notion of ${{\\tt {ta}}^\\Diamond}$-security allows information flows relating to policy \nsettings that are not explicitly represented as edges in the policy itself. Conceivably, a richer policy format may allow these implicit flows \nto be more explicitly represented. \n\nIt  would also be  interesting  to formally relate our work \nto work in the programming language setting, and to \ncombine the insights from \nAskarov and Chong's work on imperfect recall attackers with the approach we have developed in the \npresent paper. \n\n\n\\bibliographystyle{abbrv}\n\\bibliography{bibliography} \n\n\n\n", "itemtype": "equation", "pos": 149220, "prevtext": "\nWe will show that the dynamic reference monitor conditions {{\\tt DRM}-}1 to {{\\tt DRM}-}6 hold. \n \\begin{enumerate}\n  \\item[{{\\tt DRM}-}\\ref{cond:wa:outputconsistency}:]\n    Let ${ \\alpha} {\\approx_{{u}}} { \\beta}$. \n    Then we have $u \\in {{\\tt observe}(u, { \\alpha})} = {{\\tt observe}(u, { \\beta})}$ and ${{{\\tt {ta}}^\\Diamond}_{u}(\\alpha)} = {{\\tt contents}(u, { \\alpha})} = {{\\tt contents}(u, { \\beta})} = {{{\\tt {ta}}^\\Diamond}_{u}(\\beta)}$. \n    It now follows by ${{\\tt {ta}}^\\Diamond}$-security of $M$ that ${\\tt obs}_u( \\alpha) = {\\tt obs}^M_u( s_0\\cdot \\alpha) = {\\tt obs}^M_u(s_0\\cdot \\beta) = {\\tt obs}_u( \\beta)$. \n  \\item [{{\\tt DRM}-}\\ref{cond:wa:contentconsistency}:]\n    Let $o \\in {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, { \\beta})}$ and ${ \\alpha} {\\approx_{{{\\tt dom}(a)}}} { \\beta}$ and ${{\\tt contents}(o, { \\alpha})} = {{\\tt contents}(o, { \\beta})}$.     \n    From ${ \\alpha} {\\approx_{{{\\tt dom}(a)}}} { \\beta}$ and the fact that, by definition,  ${\\tt dom}(a) \\in {{\\tt observe}({{\\tt dom}(a)}, \\alpha)}$ we obtain ${{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{{{\\tt dom}(a)}}(\\beta)}$. \n    From $o \\in {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})} \\cap {{\\tt alter}({{\\tt dom}(a)}, { \\beta})}$ it follows that $o\\in D$ and $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail o}$ and $\\beta \\models {{\\tt dom}(a) \\rightarrowtail o}$. \n    From ${{\\tt contents}(o, { \\alpha})} = {{\\tt contents}(o, { \\beta})}$ it follows that ${{{\\tt {ta}}^\\Diamond}_{o}(\\alpha)} = {{{\\tt {ta}}^\\Diamond}_{o}(\\beta)}$.  By the definition of the ${{\\tt {ta}}^\\Diamond}$-operator, we obtain ${{{\\tt {ta}}^\\Diamond}_{o}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{o}({\\beta a})}$. \n  \\item[{{\\tt DRM}-}\\ref{cond:wa:allowedinterference}:] We prove the contrapositive. \n    Suppose $o \\notin {{\\tt alter}({{\\tt dom}(a)}, { \\alpha})}$. \n    We can assume that $o \\in {D}$, since the values of objects in ${\\tt Osets}$ do not change. \n    Thus, we have $\\alpha \\models {{\\tt dom}(a) \\rightarrowtail o}$. \n    Then we have ${{{\\tt {ta}}^\\Diamond}_{o}({\\alpha a})} = {{{\\tt {ta}}^\\Diamond}_{o}({\\alpha})}$ and hence ${{\\tt contents}(o, { \\alpha a})} = {{\\tt contents}(o, { \\alpha})}$.\n\n  \\item[{{\\tt DRM}-}\\ref{cond:wa:grantobserve}:]  \n    Since the function ${\\tt observe}$ is constant, we have ${{\\tt observe}(u, {\\alpha \\cdot a})} \\setminus {{\\tt observe}(u, \\alpha)} = \\emptyset$. \n  \\item[{{\\tt DRM}-}\\ref{cond:wa:policyconsistency}:] \n   By definition, we have that \n    \n", "index": 31, "text": "\\begin{align*}\n     {{\\tt observe}(u, { \\alpha})} \\cap {{\\tt alter}(v, { \\alpha})} & = \n     \\begin{cases}\n      \\{u \\} & \\text{if } \\alpha \\models {v \\rightarrowtail u} \\\\\n      \\emptyset & \\text{otherwise}\n     \\end{cases} \\\\\n      {{\\tt observe}(u, { \\beta})} \\cap {{\\tt alter}(v, { \\beta})} & = \n     \\begin{cases}\n      \\{u \\} & \\text{if } \\beta \\models {v \\rightarrowtail u} \\\\\n      \\emptyset & \\text{otherwise}\n     \\end{cases}\n    \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt observe}(u,{\\alpha})}\\cap{{\\tt alter}(v,{\\alpha})}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c\ud835\ude8e\ud835\ude9b\ud835\ude9f\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2229</mo><mrow><mi>\ud835\ude8a\ud835\ude95\ud835\ude9d\ud835\ude8e\ud835\ude9b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}\\{u\\}&amp;\\text{if }\\alpha\\models{v\\rightarrowtail u}\\\\&#10;\\emptyset&amp;\\text{otherwise}\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo stretchy=\"false\">}</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>\u03b1</mi></mrow><mo>\u22a7</mo><mi>v</mi><mo>\u21a3</mo><mi>u</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mi mathvariant=\"normal\">\u2205</mi></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{{\\tt observe}(u,{\\beta})}\\cap{{\\tt alter}(v,{\\beta})}\" display=\"inline\"><mrow><mrow><mi>\ud835\ude98\ud835\ude8b\ud835\ude9c\ud835\ude8e\ud835\ude9b\ud835\ude9f\ud835\ude8e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2229</mo><mrow><mi>\ud835\ude8a\ud835\ude95\ud835\ude9d\ud835\ude8e\ud835\ude9b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo>,</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\begin{cases}\\{u\\}&amp;\\text{if }\\beta\\models{v\\rightarrowtail u}\\\\&#10;\\emptyset&amp;\\text{otherwise}\\end{cases}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">{</mo><mi>u</mi><mo stretchy=\"false\">}</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>\u03b2</mi></mrow><mo>\u22a7</mo><mi>v</mi><mo>\u21a3</mo><mi>u</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mi mathvariant=\"normal\">\u2205</mi></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}]