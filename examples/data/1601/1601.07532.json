[{"file": "1601.07532.tex", "nexttext": "\n\n\n\n\\subsection{Invariance to brightness and contrast}\n\nThe estimated motion should be insensitive to additive changes of brightness of the input. Since the subsequent processing will be local, instead of subtracting the average brightness over the whole image, we subtract the local low-frequency component:\n\n", "itemtype": "equation", "pos": 17814, "prevtext": "\n\n\\title{\\vspace{-6pt}Learning to Extract Motion from Videos in Convolutional Neural Networks\\vspace{-5pt}}\n\n\\author{\n  Damien Teney ~~~~~~~~~~~~~Martial Hebert\n  \\vspace{4pt}\\\\\n  \n  \n  The Robotics Institute\\\\Carnegie Mellon University\\\\Pittsburgh, PA, USA\n  \\vspace{-4pt}\n}\n\n\\maketitle\n\n\\thispagestyle{empty} \n\\pagestyle{empty} \n\n\\begin{abstract}\nThis paper shows how to extract dense optical flow from videos with a convolutional neural network (CNN). The proposed model constitutes a potential building block for deeper architectures to allow using motion without resorting to an external algorithm, {\\emph{e.g.}~} for recognition in videos. We derive our network architecture from signal processing principles to provide desired invariances to image contrast, phase and texture. We constrain weights within the network to enforce strict rotation invariance and substantially reduce the number of parameters to learn. We demonstrate end-to-end training on only 8 sequences of the Middlebury dataset, orders of magnitude less than competing CNN-based motion estimation methods, and obtain comparable performance to classical methods on the Middlebury benchmark. Importantly, our method outputs a distributed representation of motion that allows representing multiple, transparent motions, and dynamic textures. Our contributions on network design and rotation invariance offer insights nonspecific to motion estimation.\n\\end{abstract}\n\n\n\n\n\n\n\n\\section{Introduction}\n\nThe success of convolutional neural networks (CNNs) on image-based tasks, from object recognition to semantic segmentation or geometry prediction, has inspired similar developments with videos. Example applications include activity recognition \\cite{simonyan2014,wu2015,ye2015}, scene classification \\cite{tran2014}, or semantic segmentation of scenes with dynamic textures \\cite{teney2014}. The appeal of CNNs is to be trainable end-to-end, {\\emph{i.e.}~} taking raw pixel values as input, and learning their mapping to the output of choice, identifying appropriate intermediate representations in the layers of the network. The natural application of this paradigm to videos involves a 3D volume of pixels as input, made of stacked consecutive frames. The direct application of existing architectures on such inputs has shown mixed results. An alternative is to first extract optical flow or dense trajectories with an external algorithm \\cite{simonyan2014,ye2015,wu2015} and feed the CNN with this information in addition to the pixel values. The success of this approach can be explained by the intrinsically different nature of spatial and temporal components, now separated during a preprocessing. The extraction of motion regardless of image contents is not trivial, and has been addressed by the long-standing line of successful optical flow algorithms. Conversely, the end-to-end training of CNNs on videos for high-level tasks has shown limited capability for identifying intermediate representations of motion. In this paper, we show that specifically training a CNN to extract optical flow can be achieved once some key principles are taken into account.\n\n\n\n\n\n\n\n\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\includegraphics[width=0.93\\linewidth,width=.99\\linewidth]{Teaser.pdf}\n  \\end{center}\n  \\vspace{-6pt}\n  \\caption{The proposed CNN takes raw pixels as input and produces features representing evidence for motion at various speeds and orientations. These can be projected as a traditional optical flow map. First-layer kernels (pictured) typically identify translating patterns in the image.}\n  \n  \\vspace{-9pt}\n\\end{figure}\n\nWe leverage signal processing principles and how motion manifests itself in the frequency domain of a spatiotemporal signal ({Section~}\\ref{sect:principles}) to derive convolutions, pooling and non-linear operations able to map input pixels to a representation of motion ({Section~}\\ref{ref:network}). The resulting network is designed as a building block for deeper architectures addressing higher-level tasks. The current practice of extracting optical flow as an independent preprocessing might be suboptimal, as the assumptions of an optical flow algorithm may not hold for a particular end application. The proposed approach would potentially allow to fine-tune the motion representation with the whole model in a deep learning setting.\n\nThe proposed network outputs a distributed representation of motion. The penultimate layer comprises, for each pixel, a population of neurons selective to various orientations and speeds. These can represent a multimodal distribution of activity at a single spatial location, and represent non-rigid, overlapping, and transparent motions that traditional optical flow usually cannot. The distributed representation can be used as a high-dimensional feature by subsequent applications, or decoded into a traditional map of the dominant flow. The latter allows training and evaluation with existing optical flow datasets.\n\nThe motivation for the proposed approach is not direct competition with existing optical flow algorithms. The aim is to enable using CNNs with videos in a more principled way, using pixel input for both spatial and temporal components. Instead of considering the flow of a complete scene as the end-goal, we rather wish to identify local motion cues without committing to an early scene interpretation. This contrasts with modern optical flow approaches, which often perform implicit or explicit tracking and/or segmentation. In particular, we avoid motion smoothness and rigidness priors, and spatial scene-level reasoning. This makes the features produced by the network suitable to characterize situations that break such assumptions, {\\emph{e.g.}~} with transparent phenomena and dynamic textures \\cite{derpanis2012,teney2014}. As a downside, our evaluation on the Sintel benchmark shows inferior performance to state-of-the-art techniques. This confirms that a \\emph{scene-level} interpretation of motion requires such priors and higher-level reasoning. In particular, we do not perform explicit feature tracking and long-range matching, which are the highlights of the best-performing methods on this dataset ({\\emph{e.g.}~}\\cite{deepflow,brox2011}).\n\n\nThe contributions of this paper are fourfold. (1)~We derive, from signal processing principles, a CNN able to learn mapping pixels to optical flow. (2)~We train this CNN end-to-end on videos with ground truth flow, then demonstrate performance on the Middlebury benchmarks comparable to classical methods. (3)~We show how to enforce strict rotation invariance within a CNN through weight-sharing, and demonstrate significant benefit for training on a small dataset with no need for data augmentation. (4)~We show that the distributed representation of motion produced within our network is more versatile than traditional flow maps, able to represent phenomena such as dynamic textures and multiple, overlapping motions. Our pretrained network is available as a building block for deeper architectures addressing higher-level tasks. Its training is significantly less complex than competing methods \\cite{flownet} while providing similar or superior accuracy on the Middlebury benchmark.\n\n\n\n\n\n\n\n\\section{Related work}\n\n{\\noindent{\\normalfont\\normalsize\\bfseries{{Learning spatiotemporal features}}}\\hspace{6pt}} Several recent works have used CNNs for classification and recognition in videos. Karpathy {\\emph{et al.}}~\\cite{karpathy2014} consider the large-scale classification of videos, but obtain only a modest improvement over single-frame input. Simonyan and Zisserman \\cite{simonyan2014} propose a CNN for activity recognition in which appearance and motion are processed in two separate streams. The temporal stream is fed with optical flow computed by a separate algorithm. The advantage of using separate processing of spatial and temporal information was further examined in \\cite{wu2015,ye2015}. We propose to integrate the identification of motion into such networks, eliminating the need for a separate algorithm, and potentially allowing to fine-tune the representation of motion. Tran {\\emph{et al.}}~\\cite{tran2014} proposed an architecture to extract general-purpose features from videos, which can be used for classification and recognition. Their deep network captures high-level concepts that integrate both motion and appearance. In comparison, our work focuses on the extraction of motion alone, {\\emph{i.e.}~} independently of appearance, as motivated by the two-stream approach \\cite{simonyan2014}. Learning spatiotemporal features outside of CNN architectures was considered earlier. Le {\\emph{et al.}} \\cite{le2011} used independent subspace analysis to identify filter-based features. Konda {\\emph{et al.}}~\\cite{konda2013} learned motion filters together with depth from videos. Their model is based on the classical energy-based motion model, similarly to ours. Taylor {\\emph{et al.}}~\\cite{taylor2010} used restricted Boltzmann machines to learn unsupervised motion features. Their representation can be used to derive the latent optical flow, but was shown to capture richer information, useful {\\emph{e.g.}~} for activity recognition. The high-dimensional features produced by our network bear similar benefits. Earlier work by Olshausen {\\emph{et al.}}~\\cite{olshausen2003} learned sparse decompositions of video signals, identifying features resembling the filters learned in our approach. In comparison to all works mentioned above, we focus on the extraction of motion independently of spatial appearance, whereas decompositions such as in \\cite{olshausen2003} result in representations that confound appearance and temporal information.\n\n\n\n\n\n\n\n\n\n\n\n\n{\\noindent{\\normalfont\\normalsize\\bfseries{{Extraction of optical flow}}}\\hspace{6pt}} The estimation of optical flow has been studied for several decades. The basis for many of today's methods dates back to the seminal work of Horn and Schunk \\cite{hornSchunk}. The flow is computed as the minimizer of data and smoothness terms. The former relies on the conservation of a measureable image feature (typically corresponding to the assumption of brightness constancy) and the latter models priors such as motion smoothness. Many works proposed improvements to these two terms (see \\cite{fortun2015} for a recent survey). Heeger {\\emph{et al.}}~\\cite{heeger1987} proposed a completely different approach, applying spatiotemporal filters to the input frames to sample their frequency contents. This method naturally applies to sequences of more than two frames, and relies on a bank of hand-designed filters (typically, Gaussian derivatives or spatiotemporal Gabor filters \\cite{adelson1985}). Subsequent improvements \\cite{rust2006,solari2015,ulman2010} focused on the design of those filters. They must balance the sampling of narrow regions of the frequency spectrum, {\\emph{i.e.}~}, to accurately estimate motion speed and orientation, while retaining the ability to precisely locate the stimuli in image. A practical consequence of this tradeoff is the typically blurry flow maps produced the method. This historically played in favor of the more popular approach of Horn and Schunk. Another downside of the filter-based approach was the computational expense of convolutions. Our work revisits Heeger's approach, motivated by two key points. On the one hand, applying spatiotemporal filters naturally falls in the paradigm of convolutional neural networks, which are currently of particular for analyzing videos. On the other hand, modern advances can overcome the two initial burdens of the filter-based approach by (1) learning the filters using backpropagation, and (2) leveraging GPU implementations of convolutions.\n\nConcurrently with our own developments, Fisher {\\emph{et al.}}~proposed another CNN-based method (Flownet \\cite{flownet}). They obtain very good results on optical flow benchmarks. In comparison to our work, they train a much deeper network that requires tens of thousands of training images. Our architecture is derived from signal processing principles, which contains fewer weights by several orders of magnitude. This allows training on much smaller datasets. The final results in \\cite{flownet} also include a variational refinement, essentially using the CNN to initialize a traditional flow estimation. Our procedure is entirely formulated as a CNN. This potentially allows fine-tuning when integrated into a deeper architecture.\n\nA number of recent works \\cite{derpanis2012,derpanis2010,teney2014,teney2015} studied the use of spatiotemporal filters to characterize motion in {\\emph{e.g.}~} transparent and semi-transparent phenomena, and dynamic textures such as a swirling cloud of smoke, reflections on water, or swaying vegetation. These works highlighted the potential of filter-based features, and the need for motion representations --~such as those produced by our approach~-- that go beyond displacement (flow) maps\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\noindent{\\normalfont\\normalsize\\bfseries{{Invariances in CNNs}}}\\hspace{6pt}} One of our technical contributions is to enforce rotation invariance by tiying groups of weights together. In contrast to weight \\emph{sharing} which involves weights at different layers, this applies to weights of a same layer. Encouraging or enforcing invariances in neural networks has been approached in several ways. The convolutional paradigm ensure translation invariance by reusing weights between spatial locations. Other schemes of weight sharing were proposed in a simple model in \\cite{fasel2006}, and later in \\cite{le2010} with a method to learn which weights to share. No published work discussed the implementation of strict rotation invariance in CNN to our knowledge. In \\cite{dieleman2015,laptev2015}, schemes akin to ensemble methods were proposed for invariance to geometric transformations. In \\cite{rowley1998} and more recently in \\cite{jaderberg2015}, a network first predicts a parametric transformation, used to rotate or warp the image to a canonical state before further processing. Our approach, in addition to the actual invariance, has the benefit of reducing the number of weights to learn and facilitates the training. Soft invariances, {\\emph{e.g.}~} to contrast can be encouraged by specific operations, such as local response normalization (LRN, {\\emph{e.g.}~} in \\cite{krizhevsky2012}). We also use a number of such operations.\nNote that this paper abuses of the term ``invariance'' for cases more accurately involving \\emph{equi}variance or \\emph{co}variance \\cite{jayaraman2015}.\n\n\n\n\n\n\n\\section{Filter-based motion estimation}\n\\label{sect:principles}\n\nOur rationale for estimating motion with a convolutional architecture is based on the motion energy model \\cite{adelson1985}. Classical implementations \\cite{heeger1987,niyogi1995,ulman2010} are based on convolutions with hardcoded spatiotemporal filters ({\\emph{e.g.}~} 3D Gabors or Gaussian derivatives). The convolution of a signal with a kernel in the spatiotemporal domain corresponds to a multiplication of their spectra in the frequency domain. Convolutions with a bank of bandpass filters produce measurements of energy in these bands, which are then suitable for frequency analysis of the signal. A pattern moving in a video with a constant speed and orientation manifests itself as a plane in the frequency domain \\cite{adelson1985,fleet1990}, and the signal energy entirely lies within this plane. It passes through the origin, and its tilt corresponds to the motion orientation and speed in the image domain. Classical implementations have used various schemes to identify the best-fitting plane to the energy measurements. In our model, we learn the spatiotemporal filters together with additional layers to decode their responses into the optical flow. Importantly, transparent patterns in an image moving with different directions or speeds correspond to distinct planes in the frequency domain. The same principle can thus identify multiple, overlapping motions.\n\n\n\n\n\n\n\n\n\n\n\\section{Proposed network architecture}\n\\label{ref:network}\n\nOur network is fully convolutional, {\\emph{i.e.}~}, it does not contain any fully connected layers. Each location in the output flow map is linked to a spatially-limited receptive field in the input, and each pixel of a training sequence can thus be seen as a unique training point. We describe below each layers of our network in their feedforward order. We use $x_{ijk}^{{\\ell}}$ to refer to the scalar value at coordinates $(i,j,k)$ in the 3D tensor obtained by evaluating the ${\\ell}$th layer. Indices $i$ and $j$ refer to spatial dimensions, $k$ to feature channels. We use a colon ($:$) to refer to all elements along a dimension. We denote with ${\\ast{}_{_{\\hspace{-.15em}2D}}}$ and ${\\ast}$ convolutions in two and three dimensions, respectively. In contrast to CNNs used for image recognition, the desired output here is dense, {\\emph{i.e.}~} a 2D flow vector for every pixel. To achieve this, all convolutions use a 1{\\,\\textit{px}\\;} stride and the pooling ({Eq.\\,}\\ref{eq:pooling}) a 2{\\,\\textit{px}\\;} stride, all with appropriate padding. The output is thus at half the resolution of the input. Our experiments use bilinear upsampling (except otherwise noted) to obtain flow fields at the original resolution.\n\n\n\n\n\\subsection{Network input}\nThe input to the network is the $H{\\nobreak\\hspace{-.22em}}\\times{\\nobreak\\hspace{-.22em}} W {\\nobreak\\hspace{-.22em}}\\times{\\nobreak\\hspace{-.22em}} F$ volume of pixels made by stacking $F$ successive grayscale frames of a video (typically, $F{\\nobreak\\hspace{-.4em}}=\\mm3$). The desired network output is the flow between frames $\\lceil F/2 \\rceil$ and $\\lceil F/2 \\rceil{\\nobreak\\hspace{-.22em}}+\\n1$.\n\\abovedisplayskip=2pt\n\\belowdisplayskip=2pt\n\n", "index": 1, "text": "\\begin{gather} \\label{eq:input}\n  x_{::k}^{1} ~=~ k \\textrm{th frame of the video} ~~~~\\forall\\; k{\\nobreak\\hspace{-.2em}}=\\m1...F.\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{1}~{}=~{}k\\textrm{th frame of the video}~{}~{}~{}~{}%&#10;\\forall\\;k{\\nobreak\\hskip-2.0pt}=\\m 1...F.\" display=\"block\"><mrow><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mn>1</mn></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mi>k</mi><mo>\u2062</mo><mtext>th frame of the video</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2005</mo><mrow><mrow><mo rspace=\"5.3pt\">\u2200</mo><mpadded width=\"-2pt\"><mi>k</mi></mpadded></mrow><mo>=</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\m</mtext></merror><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>F</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nwhere $\\mathcal{H}^{0}$ denotes a fixed, 2D Gaussian kernel of standard deviation $w/3$. Note that this operation could also be written as a convolution with a center-surround filter. We then ensure invariance to local constrast changes with a normalization using the standard deviation in local neighbourhoods:\n\n", "itemtype": "equation", "pos": 18267, "prevtext": "\n\n\n\n\\subsection{Invariance to brightness and contrast}\n\nThe estimated motion should be insensitive to additive changes of brightness of the input. Since the subsequent processing will be local, instead of subtracting the average brightness over the whole image, we subtract the local low-frequency component:\n\n", "index": 3, "text": "\\begin{gather} \\label{eq:centerSurround}\n  x_{::k}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{::k}^{{\\ell}} ~-~ (x_{::k}^{{\\ell}} ~{\\ast{}_{_{\\hspace{-.15em}2D}}}~ \\mathcal{H}^{0})  ~~~~\\forall\\, k,\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{::k}^{{\\ell}%&#10;}~{}-~{}(x_{::k}^{{\\ell}}~{}{\\ast{}_{{}_{\\hskip-1.5pt2D}}}~{}\\mathcal{H}^{0})~%&#10;{}~{}~{}~{}\\forall\\,k,\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"5.8pt\">-</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo>\u2217</mo><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><none/><mn>0</mn><mprescripts/><msub><mi/><mrow><mpadded lspace=\"-1.5pt\" width=\"-1.5pt\"><mn>2</mn></mpadded><mo>\u2062</mo><mi>D</mi></mrow></msub><none/></mmultiscripts></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2005</mo><mrow><mo rspace=\"4.2pt\">\u2200</mo><mi>k</mi></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nwhere $\\Omega(i,j)$ refers to the square region of length~$w$ centered on $(i,j)$. \n\nThe two above operations proved essential to learn subsequent filters with little training data. They can be seen as a local equivalent to a typical image-wide whitening \\cite{lecun1998b}. This formulation is better suited to the subsequent local processing of a fully convolutional network.\n\n\n\\subsection{Motion detection}\nThis key operation convolves the volume of pixels with learned 3D kernels. They can be interpreted as spatiotemporal filters that respond to various patterns moving at different speeds.\n\n", "itemtype": "equation", "pos": 18794, "prevtext": "\nwhere $\\mathcal{H}^{0}$ denotes a fixed, 2D Gaussian kernel of standard deviation $w/3$. Note that this operation could also be written as a convolution with a center-surround filter. We then ensure invariance to local constrast changes with a normalization using the standard deviation in local neighbourhoods:\n\n", "index": 5, "text": "\\begin{gather} \\label{eq:stdNormalization}\n  x_{ijk}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{ijk}^{{\\ell}} ~~/~~ {\\operatorname{std}}_{\\vspace{8pt}{\\nobreak\\hspace{-.2em}} i',j' \\in \\Omega(i,j)}\\big( x_{i'j'k}^{{\\ell}}\\big ) ~~~~\\forall\\, i,j,k,\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{ijk}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{ijk}^{{\\ell}%&#10;}~{}~{}/~{}~{}{\\operatorname{std}}_{\\vspace{8pt}{\\nobreak\\hskip-2.0pt}i^{%&#10;\\prime},j^{\\prime}\\in\\Omega(i,j)}\\big{(}x_{i^{\\prime}j^{\\prime}k}^{{\\ell}}\\big%&#10;{)}~{}~{}~{}~{}\\forall\\,i,j,k,\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+6.6pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"9.1pt\">/</mo><mrow><msub><mo>std</mo><mrow><mrow><msup><mpadded lspace=\"-2pt\" width=\"-2pt\"><mi>i</mi></mpadded><mo>\u2032</mo></msup><mo>,</mo><msup><mi>j</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msub><mo>\u2061</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><msubsup><mi>x</mi><mrow><msup><mi>i</mi><mo>\u2032</mo></msup><mo>\u2062</mo><msup><mi>j</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2005</mo><mrow><mo rspace=\"4.2pt\">\u2200</mo><mi>i</mi></mrow><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nwhere $\\mathcal{H}_k^{1}$ are $MO$ learned convolution kernels of size $w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} F$, and ${b}_k^{1}$ the associated biases. The constants $M$ and $O$ respecitvely fix the number of independent kernels and the number of orientations explicitly represented within the network ({Section~}\\ref{sect:orientationInvariance}).\n\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\includegraphics[width=0.92\\linewidth]{Architecture.pdf}\n  \\end{center}\n  \\vspace{-4pt}\n  \\caption{The proposed neural network takes raw pixels of $F$ video frames as input, and outputs a dense optical flow at half its resolution. The network comprises 2 convolutional layers, 1 pooling layer, and 2 pixelwise weights ($1{\\nobreak\\hspace{-.22em}}\\times{\\nobreak\\hspace{-.22em}} 1$ convolutions). Dimensions of receptive fields and feature maps are shown, with numbers chosen in our implementation in gray. Normalizations and non-linearities are not shown.}\n  \\label{fig:architecture}\n  \\vspace{-9pt}\n\\end{figure}\n\n\n\\subsection{Invariance to local image phase}\nThe learned kernels used as motion detectors above typically respond to lines and edges in the image. The estimated motion should however be independent of such image structure. Classical models \\cite{heeger1987,solari2015} account for this using pairs of quadrature filters, though this is not trivial to enforce with our learned filters. Instead, we approximate a phase-invariant reponse as follows. (1) The response of the convolution is rectified by pointwise squaring. Responses out of phase by 180\\degree ({\\emph{e.g.}~} dark-bright and bright-dark transitions) then give a same response. (2) We apply a spatial max-pooling. The wavenumber of the pattern captured by our kernels of size $w$ is at least $2/w$ cycles/px. The worst-case phase shift of 90\\degree then corresponds to a spatial shift of $w/4$ px. We maxpool responses over windows of size $w/4$ with a fixed stride of $2$, and thus approximate a phase-invariant response at the price of a lowered resolution.\n\n", "itemtype": "equation", "pos": 19654, "prevtext": "\nwhere $\\Omega(i,j)$ refers to the square region of length~$w$ centered on $(i,j)$. \n\nThe two above operations proved essential to learn subsequent filters with little training data. They can be seen as a local equivalent to a typical image-wide whitening \\cite{lecun1998b}. This formulation is better suited to the subsequent local processing of a fully convolutional network.\n\n\n\\subsection{Motion detection}\nThis key operation convolves the volume of pixels with learned 3D kernels. They can be interpreted as spatiotemporal filters that respond to various patterns moving at different speeds.\n\n", "index": 7, "text": "\\begin{gather} \\label{eq:motionFilters}\n  x_{::k}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{:::}^{{\\ell}} ~{\\ast}~ \\mathcal{H}_k^{1} + {b}_k^{1} ~~~\\forall~k{\\nobreak\\hspace{-.2em}}=\\m1...MO~~,\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{:::}^{{\\ell}%&#10;}~{}{\\ast}~{}\\mathcal{H}_{k}^{1}+{b}_{k}^{1}~{}~{}~{}\\forall~{}k{\\nobreak%&#10;\\hskip-2.0pt}=\\m 1...MO~{}~{},\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mo>:</mo></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"5.8pt\">\u2217</mo><msubsup><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><mi>k</mi><mn>1</mn></msubsup></mrow><mo>+</mo><mrow><mpadded width=\"+9.9pt\"><msubsup><mi>b</mi><mi>k</mi><mn>1</mn></msubsup></mpadded><mo>\u2062</mo><mrow><mo rspace=\"5.8pt\">\u2200</mo><mpadded width=\"-2pt\"><mi>k</mi></mpadded></mrow></mrow></mrow><mo>=</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\m</mtext></merror><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>M</mi><mo>\u2062</mo><mpadded width=\"+6.6pt\"><mi>O</mi></mpadded></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nwhere $\\Omega'(2i,2j)$ refers to the square region of length~$\\lceil w/4 \\rceil$ centered on $(2i,2j)$.\n\n\n\\subsection{Invariance to local image structure}\nThe estimated motion should be independent from the amount and type of texture in the image. To account for intensity differences of patterns at different orientations at any particular location ({\\emph{e.g.}~} a grid pattern of horizontal lines crossing fainter vertical ones), we normalize the responses by their sum over all orientations \\cite{heeger1987}:\n\n", "itemtype": "equation", "pos": 21966, "prevtext": "\nwhere $\\mathcal{H}_k^{1}$ are $MO$ learned convolution kernels of size $w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} F$, and ${b}_k^{1}$ the associated biases. The constants $M$ and $O$ respecitvely fix the number of independent kernels and the number of orientations explicitly represented within the network ({Section~}\\ref{sect:orientationInvariance}).\n\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\includegraphics[width=0.92\\linewidth]{Architecture.pdf}\n  \\end{center}\n  \\vspace{-4pt}\n  \\caption{The proposed neural network takes raw pixels of $F$ video frames as input, and outputs a dense optical flow at half its resolution. The network comprises 2 convolutional layers, 1 pooling layer, and 2 pixelwise weights ($1{\\nobreak\\hspace{-.22em}}\\times{\\nobreak\\hspace{-.22em}} 1$ convolutions). Dimensions of receptive fields and feature maps are shown, with numbers chosen in our implementation in gray. Normalizations and non-linearities are not shown.}\n  \\label{fig:architecture}\n  \\vspace{-9pt}\n\\end{figure}\n\n\n\\subsection{Invariance to local image phase}\nThe learned kernels used as motion detectors above typically respond to lines and edges in the image. The estimated motion should however be independent of such image structure. Classical models \\cite{heeger1987,solari2015} account for this using pairs of quadrature filters, though this is not trivial to enforce with our learned filters. Instead, we approximate a phase-invariant reponse as follows. (1) The response of the convolution is rectified by pointwise squaring. Responses out of phase by 180\\degree ({\\emph{e.g.}~} dark-bright and bright-dark transitions) then give a same response. (2) We apply a spatial max-pooling. The wavenumber of the pattern captured by our kernels of size $w$ is at least $2/w$ cycles/px. The worst-case phase shift of 90\\degree then corresponds to a spatial shift of $w/4$ px. We maxpool responses over windows of size $w/4$ with a fixed stride of $2$, and thus approximate a phase-invariant response at the price of a lowered resolution.\n\n", "index": 9, "text": "\\begin{gather} \\label{eq:pooling}\n  x_{ijk}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ \\max_{\\vspace{8pt}{\\nobreak\\hspace{-.2em}} i',j' \\in \\Omega'(2i,2j)}\\big( {x_{i'j'k}^{{\\ell}}}^2 \\big) ~~~~\\forall\\, i,j,k,\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{ijk}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}\\max_{\\vspace{8%&#10;pt}{\\nobreak\\hskip-2.0pt}i^{\\prime},j^{\\prime}\\in\\Omega^{\\prime}(2i,2j)}\\big{(%&#10;}{x_{i^{\\prime}j^{\\prime}k}^{{\\ell}}}^{2}\\big{)}~{}~{}~{}~{}\\forall\\,i,j,k,\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><munder><mi>max</mi><mrow><mrow><msup><mpadded lspace=\"-2pt\" width=\"-2pt\"><mi>i</mi></mpadded><mo>\u2032</mo></msup><mo>,</mo><msup><mi>j</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><msup><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo>,</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>j</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder><mo>\u2061</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><mmultiscripts><mi>x</mi><mrow><msup><mi>i</mi><mo>\u2032</mo></msup><mo>\u2062</mo><msup><mi>j</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi><none/><mn>2</mn></mmultiscripts><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2005</mo><mrow><mo rspace=\"4.2pt\">\u2200</mo><mi>i</mi></mrow><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nwhere $\\epsilon$ is a small constant to avoid divisions by a small value in low-texture areas of the image. The sum is performed over feature channels $k'$ that correspond to the $O$ variants of $k$ at all orientations (see {Section~}\\ref{sect:orientationInvariance})\n\n\nTo account for the aperture problem, we allow local interacton by introducing an additional convolutional layer with $MO$ learned kernels $\\mathcal{H}^{2}$ of size $w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} w \\times MO$.\n\n", "itemtype": "equation", "pos": 22705, "prevtext": "\nwhere $\\Omega'(2i,2j)$ refers to the square region of length~$\\lceil w/4 \\rceil$ centered on $(2i,2j)$.\n\n\n\\subsection{Invariance to local image structure}\nThe estimated motion should be independent from the amount and type of texture in the image. To account for intensity differences of patterns at different orientations at any particular location ({\\emph{e.g.}~} a grid pattern of horizontal lines crossing fainter vertical ones), we normalize the responses by their sum over all orientations \\cite{heeger1987}:\n\n", "index": 11, "text": "\\begin{gather} \\label{eq:normalization}\n  x_{ijk}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{ijk}^{{\\ell}} \\Big/ \\big(\\textstyle \\sum_{k'} {x_{ijk'}^{{\\ell}}} + \\epsilon \\big)~~~\\forall\\, i,j,k,\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{ijk}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{ijk}^{{\\ell}%&#10;}\\Big{/}\\big{(}\\textstyle\\sum_{k^{\\prime}}{x_{ijk^{\\prime}}^{{\\ell}}}+\\epsilon%&#10;\\big{)}~{}~{}~{}\\forall\\,i,j,k,\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mrow><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup><mo mathsize=\"160%\" stretchy=\"false\">/</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><mrow><mrow><mstyle displaystyle=\"false\"><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><msup><mi>k</mi><mo>\u2032</mo></msup></msub></mstyle><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><msup><mi>k</mi><mo>\u2032</mo></msup></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mrow><mo>+</mo><mi>\u03f5</mi></mrow><mo maxsize=\"120%\" minsize=\"120%\" rspace=\"12.4pt\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mo rspace=\"4.2pt\">\u2200</mo><mi>i</mi></mrow></mrow><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\nThe classical hardcoded models typically use here 2D convolutions with Gaussian kernels. Our experiments showed that supervised training lead to similar kernels, although slightly non-isotropic, and modeling some cross-channel and center-surround interactions.\n\n\n\n\\subsection{Decoding into flow vectors}\nThe features maps at this point represent evidence for different types of motion at every pixel. This evidence is now decoded with a hidden layer, a softmax nonlinearity and a linear output layer:\n\n", "itemtype": "equation", "pos": 23422, "prevtext": "\nwhere $\\epsilon$ is a small constant to avoid divisions by a small value in low-texture areas of the image. The sum is performed over feature channels $k'$ that correspond to the $O$ variants of $k$ at all orientations (see {Section~}\\ref{sect:orientationInvariance})\n\n\nTo account for the aperture problem, we allow local interacton by introducing an additional convolutional layer with $MO$ learned kernels $\\mathcal{H}^{2}$ of size $w {\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} w \\times MO$.\n\n", "index": 13, "text": "\\begin{gather} \\label{eq:smoothing}\n  x_{::k}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{:::}^{{\\ell}} ~{\\ast}~ \\mathcal{H}_k^{2} + {b}_k^{2} ~~~\\forall~k{\\nobreak\\hspace{-.2em}}=\\m1...MO~~,\\\\\n  x_{ijk}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ \\max(x_{ijk}^{{\\ell}}, 0)~~.\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{:::}^{{\\ell}%&#10;}~{}{\\ast}~{}\\mathcal{H}_{k}^{2}+{b}_{k}^{2}~{}~{}~{}\\forall~{}k{\\nobreak%&#10;\\hskip-2.0pt}=\\m 1...MO~{}~{},\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mo>:</mo></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"5.8pt\">\u2217</mo><msubsup><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><mi>k</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mpadded width=\"+9.9pt\"><msubsup><mi>b</mi><mi>k</mi><mn>2</mn></msubsup></mpadded><mo>\u2062</mo><mrow><mo rspace=\"5.8pt\">\u2200</mo><mpadded width=\"-2pt\"><mi>k</mi></mpadded></mrow></mrow></mrow><mo>=</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\m</mtext></merror><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>M</mi><mo>\u2062</mo><mpadded width=\"+6.6pt\"><mi>O</mi></mpadded></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{ijk}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}\\max(x_{ijk}^{{%&#10;\\ell}},0)~{}~{}.\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup><mo>,</mo><mn>0</mn><mo rspace=\"9.1pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\n\nwhere $T$ is a constant that fixes the number of hidden units. The decoding is performed pixelwise, {\\emph{i.e.}~} $\\mathcal{H}_k^{3}$ and $\\mathcal{H}_k^{3}$ are $1{\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} 1$.\nIntuitively, the activations of the hidden layer ({Eq.\\,}\\ref{eq:decoding}) represent scores for motions at $S$ and $O$ discrete speeds and orientations, of which the softmax picks out the highest. Assuming a unimodal distribution of \nscores ({\\emph{i.e.}~} a single motion at any pixel), the output layer interpolates these scores and maps them to a 2D flow vector for every pixel (see {Section~}\\ref{sect:training}).\n\n\n\\subsection{Invariance to in-plane rotations}\n\\label{sect:orientationInvariance}\nIn our context, rotation invariance implies that a rotated input must produce a correspondingly rotated output. Note the contrast with image recognition where rotated inputs should give a \\emph{same} output. All of our learned weights ({Eq.\\,}\\ref{eq:motionFilters}--\\ref{eq:decoding}) are split into groups corresponding to discrete orientations. The key is to enforce these groups of weights to be equivalent, {\\emph{i.e.}~} so that they make the same use of features from the preceding layer at the same \\emph{relative} orientations. In addition, convolutional kernels need to be 2D rotations of each other. These strict requirements allow us to maintain only a single version of the weights at a canonical orientation, and generate the others when evaluating the network (see {Fig.~}\\ref{fig:weights}). During training with backpropagation, the gradients are aligned with this canonical orientation and averaged to update the single version of the weights.\n\nFormally, let us consider a convolutional layer\\footnote{The general formulation applies to convolutional layers as well as to our pixelwise weights ({Eq.\\,}\\ref{eq:decoding}, \\ref{eq:output}), in which case the 2D rotation of the kernel has no effect.} ${\\ell\\hspace{-.1em}+\\hspace{-.1em}1}$. The feature maps $x^{{\\ell}}$ (respectively $x^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}$) are split into $O$ ($P$) groups of $M$ ($N$) channels. For example, in {Eq.\\,}\\ref{eq:smoothing}, $O{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} P$ and $M{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} N$. The groups of channels correspond to regular orientations ${\\theta^{{\\ell}}}_{i}$ (${\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}$) in $[0,2\\pi[$. Considering the convolution weights $\\mathcal{H}$ and their slice $h_{imjn}$ the 2D kernel acting on the input (respectively output) channel of orientation ${\\theta^{{\\ell}}}_{i}$ (${\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}$), we constrain the weights as follows:\n\n", "itemtype": "equation", "pos": 24214, "prevtext": "\nThe classical hardcoded models typically use here 2D convolutions with Gaussian kernels. Our experiments showed that supervised training lead to similar kernels, although slightly non-isotropic, and modeling some cross-channel and center-surround interactions.\n\n\n\n\\subsection{Decoding into flow vectors}\nThe features maps at this point represent evidence for different types of motion at every pixel. This evidence is now decoded with a hidden layer, a softmax nonlinearity and a linear output layer:\n\n", "index": 15, "text": "\\begin{gather}\n  \\label{eq:decoding} x_{::k}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{:::}^{{\\ell}} ~{\\ast}~ \\mathcal{H}_k^{3} + {b}_k^{3} ~~~\\forall~k{\\nobreak\\hspace{-.2em}}=\\m1...TO\\\\\n  \\label{eq:softmax} x_{ijk}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ e^{x_{ijk}^{{\\ell}}} \\big/ \\textstyle \\sum_{k'} e^{x_{ijk'}^{{\\ell}}} ~~~~\\forall~i,j,k{\\nobreak\\hspace{-.2em}}=\\m1...TO\\\\\n  \\label{eq:output} x_{::k}^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}} ~=~ x_{:::}^{{\\ell}} ~{\\ast}~ \\mathcal{H}_k^{4} + {b}_k^{4} ~~~\\forall~k{\\nobreak\\hspace{-.2em}}={\\nobreak\\hspace{-.2em}}\\{1,2\\},\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{:::}^{{\\ell}%&#10;}~{}{\\ast}~{}\\mathcal{H}_{k}^{3}+{b}_{k}^{3}~{}~{}~{}\\forall~{}k{\\nobreak%&#10;\\hskip-2.0pt}=\\m 1...TO\" display=\"block\"><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mo>:</mo></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"5.8pt\">\u2217</mo><msubsup><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><mi>k</mi><mn>3</mn></msubsup></mrow><mo>+</mo><mrow><mpadded width=\"+9.9pt\"><msubsup><mi>b</mi><mi>k</mi><mn>3</mn></msubsup></mpadded><mo>\u2062</mo><mrow><mo rspace=\"5.8pt\">\u2200</mo><mpadded width=\"-2pt\"><mi>k</mi></mpadded></mrow></mrow></mrow><mo>=</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\m</mtext></merror><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>T</mi><mo>\u2062</mo><mi>O</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{ijk}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}e^{x_{ijk}^{{%&#10;\\ell}}}\\big{/}\\textstyle\\sum_{k^{\\prime}}e^{x_{ijk^{\\prime}}^{{\\ell}}}~{}~{}~{%&#10;}~{}\\forall~{}i,j,k{\\nobreak\\hskip-2.0pt}=\\m 1...TO\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><msup><mi>e</mi><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>k</mi></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></msup><mo mathsize=\"120%\" stretchy=\"false\">/</mo><mrow><mstyle displaystyle=\"false\"><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><msup><mi>k</mi><mo>\u2032</mo></msup></msub></mstyle><msup><mi>e</mi><msubsup><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><msup><mi>k</mi><mo>\u2032</mo></msup></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></msup></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2005</mo><mrow><mo rspace=\"5.8pt\">\u2200</mo><mi>i</mi></mrow><mo>,</mo><mi>j</mi></mrow></mrow><mo>,</mo><mrow><mpadded width=\"-2pt\"><mi>k</mi></mpadded><mo>=</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\m</mtext></merror><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>T</mi><mo>\u2062</mo><mi>O</mi></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{::k}^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}~{}=~{}x_{:::}^{{\\ell}%&#10;}~{}{\\ast}~{}\\mathcal{H}_{k}^{4}+{b}_{k}^{4}~{}~{}~{}\\forall~{}k{\\nobreak%&#10;\\hskip-2.0pt}={\\nobreak\\hskip-2.0pt}\\{1,2\\},\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mi>k</mi></mrow></mrow><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow></msubsup></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><mrow><mpadded width=\"+3.3pt\"><msubsup><mi>x</mi><mrow><mo>:</mo><mo>\u2063</mo><mrow><mi/><mo>:</mo><mo>:</mo></mrow></mrow><mi mathvariant=\"normal\">\u2113</mi></msubsup></mpadded><mo rspace=\"5.8pt\">\u2217</mo><msubsup><mi class=\"ltx_font_mathcaligraphic\">\u210b</mi><mi>k</mi><mn>4</mn></msubsup></mrow><mo>+</mo><mrow><mpadded width=\"+9.9pt\"><msubsup><mi>b</mi><mi>k</mi><mn>4</mn></msubsup></mpadded><mo>\u2062</mo><mrow><mo rspace=\"5.8pt\">\u2200</mo><mpadded width=\"-2pt\"><mi>k</mi></mpadded></mrow></mrow></mrow><mo rspace=\"0.5pt\">=</mo><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07532.tex", "nexttext": "\n{Eq.\\,}\\ref{eq:rotationTies1} ensures that convolution kernels are rotated versions of each other (implemented with bilinear interpolation) and {Eq.\\,}\\ref{eq:rotationTies2} ensures that the same weights are applied to input channels representing a same \\emph{relative} orientation with respect to a given output channel of the layer. In other words, the weights are shifted between each group so as to act similarly on channels representing the same relative orientations (see {Fig.~}\\ref{fig:weights}). In {Eq.\\,}\\ref{eq:smoothing} and \\ref{eq:decoding}, $N{\\nobreak\\hspace{-.2em}}={\\nobreak\\hspace{-.2em}} N'$. In {Eq.\\,}\\ref{eq:motionFilters}, $N{\\nobreak\\hspace{-.2em}}=\\m1$. In {Eq.\\,}\\ref{eq:output}, $N{\\nobreak\\hspace{-.2em}}=\\m2$ with ${\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}=\\{0,\\pi/2\\}$.\n\n\n\n\n\nIt follows that the number of convolution kernels to explicitly maintain is reduced from $OPMN$ to $\\lceil O/2 \\rceil MN$. In {Eq.\\,}\\ref{eq:smoothing} for example, in our implementation with $O{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} P{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} 12$ orientations, this amounts to a decrease by a factor 24. It allows training on small amounts of data with lower risk of overfitting. This also negates the need to artificially augment the dataset with rotations and flips.\n\n\n\n\n\\section{Multiscale processing}\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\includegraphics[width=0.95\\linewidth,width=.95\\linewidth]{Multiscale2.pdf}\n  \\end{center}\n  \\vspace{-5pt}\n  \\caption{We bring two modifications to the basic network ({Fig.~}\\ref{fig:architecture}) for multiscale processing. First, we apply the network on several downsampled versions of the input, concatenating the feature maps before the decoding stage. Second, we add a recurrent connection to warp the input frames according to the estimated flow, iterating its evaluation for a fixed number of steps. This is inspired by the classical ``coarse-to-fine'' strategy for optical flow, and designed to estimate motions larger than the receptive field of the network output units.}\n  \\label{fig:multiscale}\n  \\vspace{-9pt}\n\\end{figure}\n\nEquations \\ref{eq:input}--\\ref{eq:output} form a complete network that maps pixels to a dense flow field. However, the detection of large motion speeds is limited by the small effective receptive field of the output units, due to the limited number of convolutional layers. We remedy this in two ways ({Fig.~}\\ref{fig:multiscale}) without increasing the number of weights to train. First, we apply the network ({Eq.\\,}\\ref{eq:input}--\\ref{eq:smoothing}) on multiple downsized versions of the input frames. The feature maps are brought back to a common resolution by bilinear upsampling and concatenated before the decoding stage ({Eq.\\,}\\ref{eq:decoding}--\\ref{eq:output}).\n\n\nSecond, we add a recurrent connection to the network that warps the input frames according to the current estimate of the flow. The evaluation runs through the recurrent connection for a fixed number of steps. This is inspired by the classical coarse-to-fine warping strategy \\cite{memin1998}. It allows the model to approximate the flow iteratively. Note that the recurrent connection to the warping layer is not a strictly linear operation contrary to typical recurrent neural networks. Training is performed by backpropagation through the unfolded recurrent iterations, but not through the recurrent connection itself. Since the result of each iteration is summed to give the final output, we can append and sum the same loss ({Section~}\\ref{sect:training}) at the end of each unfolded iteration.\n\n\n\n\n\n\n\n\n\n\\section{Implementation and training}\n\\label{sect:training}\n\n\nWe train the weights ($\\mathcal{H}^{1}, ..., \\mathcal{H}^{4}$) and biases (${b}^{1}, ..., {b}^{4}$) end-to-end with backpropagation. Even though the network ultimately performs a regression to flow vectors, we found more effective to train it first for \\emph{classification}. First, we pick a number $TO$ of flow vectors uniformly in the distribution of training flows. We train the network for nearest-neighbour classification over these possible outputs, with a logarithmic loss over {Eq.\\,}\\ref{eq:softmax}. Second, we add the linear output layer ({Eq.\\,}\\ref{eq:output}) and initialize the rows of $\\mathcal{H}_k^{4}$ with the vectors used for classification. Second, the network is fine-tuned with a Euclidean (``end-point error'') loss over the decoded vectors. That fine-tuning has a marginal effect in practice. The softmax values are practically unimodal and sum to one by construction, hence they can directly interpolate the vectors used for classification with a linear operation. We believe the 2-step training is helpful because the Euclidean loss alone does not reflect well the quality ({\\emph{e.g.}~} smoothness) of the flow. The classification loss guides the optimization towards a better optimum.\n\n\nConsidering the above, the softmax values ({Eq.\\,}\\ref{eq:softmax}) constitute a distributed representation of motion, where each dimension corresponds to a different orientation and speed. Feature maps at this layer can encode multimodal distributions over this representation and represent patterns that optical flow cannot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\scriptsize\n  \n  \\begin{tabular}{ccc}\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {{\\includegraphics[height=17.5mm]{filters.png}}}    \\end{tabbing}   \\end{minipage} &\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {{\\includegraphics[height=17.5mm]{pooling2.png}}}    \\end{tabbing}   \\end{minipage} &\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {{\\includegraphics[height=17.5mm]{c.png}}}    \\end{tabbing}   \\end{minipage}\n  \\end{tabular}\n  \\end{center}\n  \\vspace{-7pt}\n  \\caption{Convolutional kernels $\\mathcal{H}^{1}$, $\\mathcal{H}^{2}$, and pixelwise weights $\\mathcal{H}^{3}$ learned on the Middlebury dataset (selection). The obvious structure is enforced by constraints that ensure rotation invariance of the overall network.}\n  \\label{fig:weights}\n  \\vspace{-12pt}\n\\end{figure}\n\n\n\\section{Experimental evaluation}\n\\label{sect:experiments}\n\nWe present three sets of experiments. (1)~We evaluate the non-standard design choices of the proposed architecture through ablative analysis. (2)~We compare our performance versus existing methods on the Middlebury and Sintel benchmarks. (3)~We demonstrate applicability to dynamic textures and multiple transparent motions that goes beyond traditional optical flow. Code and trained models are available on the author's website \\cite{myWebsite0}.\n\n\n\\subsection{Ablative analysis}\n\\label{sec:ablative}\n\nOur ablative analysis uses the public Middlebury dataset, with the sequences split into halves for training (Grove2, RubberWhale, Urban3) and testing (Grove3, Dimetrodon, Hydrangea). For each run, we modify the network in one particular way, retrain it from scratch, and report its performance on the test set (Table~\\ref{tab:ablative}). We observe that all preprocessing and normalization steps (2--3) have a positive impact, and some are even necessary for the training to converge at all (at least with the small dataset used in these experiments). Operations inspired by the classical implementations of the motion energy model, {\\emph{i.e.}~}, (8)~rectification by squaring of filter responses and (6)~normalization across orientations, proved beneficial as well. This shows the benefit for our principled approach to network design. We perform a comparison to the classical, hardcoded filter-approach approach \\cite{heeger1987} by setting the first filters to Gaussian derivatives (4). Although learned filters are visually somewhat similar ({Fig.~}\\ref{fig:weights}), learned kernels clearly perform better. This confirms the general benefit of a data-driven approach to motion estimation. \n\n\n\n\n\n\n\n\n\\begin{table}\n  \\scriptsize\n  \n  \\begin{center}\n  \n  \n  \\begin{tabular*} {\\linewidth} {@{}>{}l@{\\extracolsep{\\fill}}*{2}{c}@{}}\n  \n  ~ & EPE ({\\nobreak\\hspace{-.2em}}{\\,\\textit{px}\\;}{\\nobreak\\hspace{-.2em}}) & {\\textcolor{myGray}{{AAE ({$^{\\circ}$})}}} \\\\\n  \\toprule\\vspace{-10pt}\\\\\n  \n  Full model, $F{\\nobreak\\hspace{-.4em}}=\\mm3$, $O{\\nobreak\\hspace{-.4em}}=\\mm12$, 10 scales, 1 rec.iter. & 0.66 & {\\textcolor{myGray}{{6.9}}} \\\\\n  \\hline\n  \\tiny{(1)}\\footnotesize~Number of input frames $F{\\nobreak\\hspace{-.4em}}=\\mm2/5$ & 0.67~0.90 & {\\textcolor{myGray}{{6.8~8.7}}} \\\\\n  \\hline\n  \\tiny{(2)}\\footnotesize~No center-surround filter & {N.C.} & {\\textcolor{myGray}{{{N.C.}}}} \\\\\n  \\tiny{(3)}\\footnotesize~No local normalization & 0.67 & {\\textcolor{myGray}{{6.9}}} \\\\\n  \\hline\n  \\tiny{(4)}\\footnotesize~Hard-coded $\\mathcal{H}_k^{1}$: Gauss. deriv. & 0.78 & {\\textcolor{myGray}{{8.4}}} \\\\\n  \\hline\n  \\tiny{(5)}\\footnotesize~No L1-normalization over orientations & {N.C.} & {\\textcolor{myGray}{{{N.C.}}}} \\\\\n  \\tiny{(6)}\\footnotesize~No pooling for phase invariance & 0.93 & {\\textcolor{myGray}{{11.2}}} \\\\\n  \\tiny{(7)}\\footnotesize~ReLU after conv1 (default: squaring) & {N.C.} & {\\textcolor{myGray}{{{N.C.}}}} \\\\\n  \\hline\n  \\tiny{(8)}\\footnotesize~No constraints for rotation invariance & {N.C.} & {\\textcolor{myGray}{{{N.C.}}}} \\\\\n  \\tiny{(9)}\\footnotesize~Number of orientations $O{\\nobreak\\hspace{-.4em}}=\\mm6/8/16$ & 1.65~0.72~0.65 & {\\textcolor{myGray}{{26.6~8.1~6.6}}} \\\\\n  \\hline\n  \\tiny{(10)}\\footnotesize~Loss: classification/regression  & 0.66/0.83 & {\\textcolor{myGray}{{7.0~8.7}}} \\\\\n  \\multicolumn{3}{l}{~~~~\\,(default: 2-step, classification (logarithmic) then regression (Euclidean))}\\\\\n  \\hline\n  \\tiny{(11)}\\footnotesize~Number of scales: 4/8/16 & 0.69~0.66~0.67 & {\\textcolor{myGray}{{6.9~6.8~6.9}}} \\\\\n  \\hline\n  \\tiny{(12)}\\footnotesize~Recurrent iterations: 2/3/4/5 & 0.57~0.55~0.56~0.57 & {\\textcolor{myGray}{{6.5~6.4~6.7~6.8}}} \\\\\n  \\toprule\\vspace{-11pt}\\\\\n  \n  \\end{tabular*}\n  \n  \\end{center}\n  \\vspace{-6pt}\n  \\caption{We evaluate every non-standard design choice by retraining a modified network. {N.C.}~denotes networks for which the training did not converge within a reasonable number of iterations. See discussion in {Section~}\\ref{sec:ablative}.}\n  \\label{tab:ablative}\n  \\vspace{-7pt}\n\\end{table}\n\n\\begin{table}\n  \\scriptsize\n  \n  \\begin{center}\n  \n  \n  \\begin{tabular*} {\\linewidth} {@{}>{}l@{\\extracolsep{\\fill}}*{8}{c}@{}}\n  ~      & \\multicolumn{2}{c}{Middlebury}\t& \\multicolumn{2}{c}{Sintel private} & Time \\\\\n  Method & public\t\t& private\t\t& clean & final\t& (sec) \\\\\n  \\toprule\\vspace{-11pt}\\\\\n  \n  FlowNetS \\cite{flownet}             \t& 1.09\t{\\textcolor{myGray}{{13.28}}} & --\t\t& 4.44 & 7.76 & 0.08 \\\\\n  FlowNetS + refinement \\cite{flownet}\t\t& 0.33\t{\\textcolor{myGray}{{3.87}}}& 0.47\t{\\textcolor{myGray}{{4.58}}}& 4.07 & 7.22 & 1.05 \\\\\n  DeepFlow \\cite{deepflow}\t\t\t\t& 0.21\t{\\textcolor{myGray}{{3.24}}}& 0.42\t{\\textcolor{myGray}{{4.22}}}& 4.56 & 7.21 & 17 \\\\\n  LDOF \\cite{ldofflow}       \t\t\t& 0.45\t{\\textcolor{myGray}{{4.97}}}& 0.56\t{\\textcolor{myGray}{{4.55}}}& 6.42 & 9.12 & 2.5 \\\\\n  Classic++ \\cite{sun2010}   \t\t\t& 0.28\t{\\textcolor{myGray}{{~~~--~~~}}}\t\t& 0.41\t{\\textcolor{myGray}{{3.92}}}\t& 8.72 & 9.96 & -- \\\\\n  FFV1MT \\cite{solari2015}\t\t\t\t& 0.95\t{\\textcolor{myGray}{{9.96}}}\t& 1.24\t{\\textcolor{myGray}{{11.66}}}& -- & -- & -- \\\\\n  \\toprule\\vspace{-11pt}\\\\\n  Proposed                            \t& (0.45)\t{\\textcolor{myGray}{{(5.47)}}}\t& 0.70\t{\\textcolor{myGray}{{6.41}}}& 9.36 & 10.04 & 6 \\\\\n  Proposed + refinement as \\cite{flownet}     \t& (0.35)\t{\\textcolor{myGray}{{(4.10)}}}\t& 0.58\t{\\textcolor{myGray}{{5.22}}}& 9.47 & 10.14 & 7 \\\\ \n  \\hline\n  \n  \\toprule\\vspace{-11pt}\\\\\n  \\end{tabular*}\n  \n  \\end{center}\n  \\vspace{-6pt}\n  \\caption{Comparison with existing algorithms on the Middlebury and Sintel benchmarks. We report average end-point errors (EPE, in pixels) average angular errors (AAE, in gray, in degrees), and execution times per frame on Sintel. Numbers in parentheses correspond to the sets used for training the model.}\n  \\label{tab:sintel}\n  \\vspace{-12pt}\n\\end{table}\n\n\n\n\n\n\\subsection{Performance on optical flow benchmarks}\n\nWe use the Middlebury and Sintel benchmarks for evaluation of networks trained from scratch on their respective training sets. A network trained on the smaller Middlebury dataset performs decently on Sintel sequences with small motions. However, most include much faster motions that had to be retrained for.\n\n{\\noindent{\\normalfont\\normalsize\\bfseries{{Middlebury}}}\\hspace{6pt}} Flow maps estimated by our method on the Middlebury dataset \\cite{middlebury} are generally smooth and accurate (see {Fig.~}\\ref{fig:middlebury}). Most errors occur near boundaries of\nobjects that become, or cause occlusions. Altough our flow maps remain generally more blurry than those of state-of-the-art methods, some fine details are remarquably well preserved ({\\emph{e.g.}~} {Fig.~}\\ref{fig:middlebury}, second row). This blurriness, or imprecision in the spatial localization of motions, is a well-known drawback of filter-based motion estimation. Convolutional kernels of smaller extent would be desirable to provide better localization, but the extent of its response in the frequency domain ({Section~}\\ref{sect:principles}) would correspondingly increase, which would imply a coarser sampling of the signal spectrum and lesser accuracy in motion direction and speed. Comparisons with existing methods show performance on the level of classical methods. We obtain much better performance than the recent implementation of Solari {\\emph{et al.}}~\\cite{solari2015} of a filter-based method with no learning.\n\n\n\n\n\n\n\n\n{\\noindent{\\normalfont\\normalsize\\bfseries{{Sintel}}}\\hspace{6pt}} The MPI Sintel dataset \\cite{sintel} contains computer-generated scenes of a movie provided in ``clean'' and ``final'' versions, the latter including atmospheric effects, reflections, and defocus/motion blur. Flow maps estimated by our method ({Fig.~}\\ref{fig:sintel}) are often smooth. Flows in scenes with small motions are usually accurate, but they lack details at the objects' borders and near small image details. Although this is partly alleviated by our recurrent iterative processing within the network, large errors remain in scenes with fast motions. This is reflected by a poor quantitative performance (Table~\\ref{tab:sintel}). Additional insights can be gained by examining the flow maps ({Fig.~}\\ref{fig:sintel}). Errors arise not on the estimates of large motions, but on their localization, in particular near zones of (dis)occlusions. This is obvious {\\emph{e.g.}~} in {Fig.~}\\ref{fig:sintel}, last row, with a thin wing flapping over a blank sky. Although the actual motion (in yellow) is detected, it spills on both sides of the thin wing structure. Since such occlusons are caused by large motions, they result in a large penalty in EPE. As argued before \\cite{sintel}, good overall performance in such situations clearly require reasoning over larger spatial and/or temporal extent than the local motions cues that our method was designed around.\n\nInteresting comparisons can be made with the competing approach Flownet \\cite{flownet}. It uses a more standard deep architecture with numerous convolutional and pooling layers. It also includes a variational refinement to improve the precision of motion estimates from the CNN. As discussed in \\cite{flownet}, this refinement cannot correct large errors of correspondingly large motions. For comparison, we applied this same post-processing to our own results. Our results right off the CNN on Middlebury are already accurate, and the post-processing brings only marginal improvement (Table~\\ref{tab:sintel}). The refinement on Flownet has a stronger effect: the output of their CNN is less precise, and it benefits more from this refinement. Looking at the Sintel dataset, the situation is very different. The main metric (the average EPE) is dominated by large motions, which are the weak point of the filter-based principles ({Section~}\\ref{sect:principles}) that we rely on. Flownet is particularly good at long-range matching thanks to its deep architecture, and this results in vastly superior performance. As stated above, the refinement is of little use with large motions, and brings minimal improvement to either method on Sintel. In conclusion, the different design choices in Flownet and our approach seem complimentary in different regimes. It would be interesting to investigate how to combine their strengths.\n\n\n\n\n\n\n\\begin{figure}[h]\n  \\vspace{-3pt}\n  \\scriptsize\n  \\begin{center}\n  \n  \\begin{tabular}{cccc}\n  \\vspace{1pt}Input & Ground truth & As proposed & Flownet \\cite{flownet} \\\\\n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-img-{1}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-gt-{1}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-us-{1}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-flownets-{1}.jpg}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-img-{5}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-gt-{5}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-us-{5}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-flownets-{5}.jpg}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-img-{3}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-gt-{3}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-us-{3}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-flownets-{3}.jpg}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-img-{4}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-gt-{4}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-us-{4}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-flownets-{4}.jpg}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-img-{2}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-gt-{2}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-us-{2}.jpg}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Middlebury-flownets-{2}.jpg}}    \\end{tabbing}   \\end{minipage}\\\\ \n  \n  \n  \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-img-{1}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-gt-{1}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-us-{1}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-flownets-{1}.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n  \n  \n  \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-img-{5}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-gt-{5}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-us-{5}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-flownets-{5}.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n  \\vspace{3pt}      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-img-{6}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-gt-{6}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-us-{6}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel-flownets-{6}.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n  \n  \n  \n  \n  \n  \\vspace{1pt}Input & Ground truth & As proposed & Occlusions \\\\\n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{9-30}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{9-30}gt.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{9-30}us.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{9-30}occ.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{12-1}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{12-1}gt.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{12-1}us.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{12-1}occ.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{20-24}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{20-24}gt.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{20-24}us.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{20-24}occ.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n        \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{23-1}.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{23-1}gt.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{23-1}us.png}}    \\end{tabbing}   \\end{minipage}&      \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[width=20mm]{Sintel2-{23-1}occ.png}}    \\end{tabbing}   \\end{minipage}\\\\ \n  \\end{tabular}\n  \\end{center}\n  \\vspace{-6pt}\n  \\caption{Estimated flow on sequences from the Middlebury (top five) and Sintel (others) datasets. Most failure cases ({\\emph{e.g.}~} bottom two) occur near (dis)occlusions, which are common on the Sintel dataset due to large motions of small objects and the small relative camera field-of-view.}\n  \\label{fig:sintel}\n  \\label{fig:middlebury}\n  \\vspace{-5pt}\n\\end{figure}\n\n\n\\subsection{Applicability to transparent motions and dynamic textures}\n\nWe tested the applicability of our method on scenes that are challenging (dynamic textures) or impossible (transparencies) to handle with traditional optical flow methods. There are no established benchmarks related to motion estimation and dynamic textures. Recent works \\cite{derpanis2012,derpanis2010,teney2014,teney2015} that highlighted the potential of filter-based motion features in such situation focused on applications such as segmentation \\cite{teney2014,teney2015} or scene recognition \\cite{derpanis2012,derpanis2010}. In {Fig.~}\\ref{fig:dynamictextures}, we show scenes containing dynamic textures (water, steam) from which we identified the dominant motion. The flow estimated by a typical method \\cite{brox2004} is typically noisy and/or inaccurate, as the usual assumption of brightness constancy does not hold ({\\emph{e.g.}~} flickering effect on the water surface, changes of brightness/transparency of the steam, etc.). Although no ground truth is available for these scenes, the flow estimated by our methods is more reliable in comparison. We then demonstrate the ability of our distributed representation to capture multiple motions at a single location (transparencies and semi-transparencies), thus going beyond the optical flow representation of pixelwise displacements. We show features in {Fig.~}\\ref{fig:dynamictextures}) from three sequences. The first depicts two alpha-blended (in equal proportions) textures moving in opposite directions, thus simulating transparency. The other two depict persons moving behind a fence in directions different than the fence itself \\cite{derpanis2010}. Feature vectors from different locations in the image are visualized as radial bins (orientations) of concentric rings (speeds). Larger values (brighter bins) indicate motion evidence. As expected, areas with simple translations produce one major peak, whereas areas with transparencies produce correspondingly more complex, multimodal distributions\\footnote{These experiments used a model trained on the Middlebury dataset.}.\n\n\\setlength{\\fboxsep}{0pt}\n\\setlength{\\fboxrule}{.3pt}\n\n\\begin{figure}[t]\n  \\begin{center}\n  \\scriptsize\n  \n  \n  \\begin{tabular}{ccccl}\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{SmokeWall.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River1.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{Backcurrent.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River2.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\\\~Input\\\\~frame}    \\end{tabbing}   \\end{minipage}\\\\\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{SmokeWall-2.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River1-2.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{Backcurrent-2.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River2-2.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\\\~Flow as\\\\~proposed}    \\end{tabbing}   \\end{minipage}\\\\\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{SmokeWall-1.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River1-1.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{Backcurrent-1.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[height=11.5mm]{River2-1.jpg}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\\\~Flow\\\\~using \\cite{brox2004}}    \\end{tabbing}   \\end{minipage}\\\\\n  \\end{tabular}\n  \\end{center}\n  \n  \\caption{The extraction of optical flow on dynamic textures is challenging for traditional methods, as transparencies ({\\emph{e.g.}~} with steam, left) or flicker ({\\emph{e.g.}~} on water ripples, middle right) violate the typical assumption of brightness constancy. The core of our approach relies on the analysis of the frequency contents of the video, and produces more stable and reliable motion estimates.}\n  \\label{fig:dynamictextures}\n  \\vspace{-7pt}\n\\end{figure}\n\n\n\\begin{figure}[t]\n  \\begin{center}\n  \n  \\resizebox{\\linewidth}{!}{\n  \\scriptsize\n  \n  \\begin{tabular}{cccc}\n    Input & Traditionnal & \\multicolumn{2}{c}{{As proposed}} \\vspace{-3pt} \\\\\n    frame & optical flow \\cite{brox2004} & \\multicolumn{2}{c}{Dominant flow~/~Motion features} \\\\\n\n    \n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Reflections.pdf}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Reflections-1.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Reflections-2.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\vspace{.2mm}\\includegraphics[height=9mm]{Reflections-features1.png}\\\\     \\includegraphics[height=9mm]{Reflections-features2.png}}    \\end{tabbing}   \\end{minipage}\\\\\n\n    \n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence1.pdf}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence1-1.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence1-2.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[height=9mm]{Fence1-featuresBg.png}\\\\     \\includegraphics[height=9mm]{Fence1-features3.png}}    \\end{tabbing}   \\end{minipage}\\\\\n\n    \n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence2.pdf}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence2-1.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\fbox{\\includegraphics[width=21mm,height=19mm]{Fence2-2.png}}}    \\end{tabbing}   \\end{minipage}&\n       \\begin{minipage}[t]{\\textwidth}   \\begin{tabbing}    ~\\[-\\baselineskip]    {\\includegraphics[height=9mm]{Fence2-features2.png}\\\\     \\includegraphics[height=9mm]{Fence2-features1.png}}    \\end{tabbing}   \\end{minipage}\\\\\n  \\end{tabular}\n  } \n  \\end{center}\n  \n  \\caption{In scenes with multiple, transparent motions, traditional optical flow methods fail and typically produce incoherent results. Our method identifies a more stable dominant motion. More importantly, our higher-dimensional motion descriptor can capture multiple motions at single locations (red squares; white arrows indicate approximate ground truth direction of motion; see text for details).}\n  \\label{fig:dynamictextures}\n  \\vspace{-3pt}\n\\end{figure}\n\n\n\\section{Conclusions and future work}\n\nWe showed how to identify optical flow entirely within a convolutional neural network. By reasoning about required invariances and by using signal processing principles, we designed a simple architecture that can be trained end-to-end, from pixels to dense flow fields. We also showed how to enforce strict rotation invariance by constraining the weights, thus reducing the number of parameters and enabling training on small datasets. The resulting network performs on the Middlebury benchmark with performance comparable to classical methods, but inferior to the best engineered methods.\n\nWe believe the approach presented here bears two major advantages over existing optical flow algorithms. First, building upon the classical motion energy model, our approach is able to produce high-dimensional features that can capture non-rigid, transparent, or superimposed motions, which traditional optical flow cannot represent. Second, it constitutes a method for motion estimation formulated entirely as a shallow, easily-trainable CNN, without requiring any post-processing. Its potential is to be used as a building block in deeper architectures ({\\emph{e.g.}~} for activity or object recognition in videos) offering the possibility for fine-tuning the representation of motion. The potential of these two aspects will deserve further exploration and should be addressed in future work.\n\n\n\n\n{\\small\n\\bibliographystyle{ieee}\n\\bibliography{Bibliography}\n}\n\n\n", "itemtype": "equation", "pos": 27526, "prevtext": "\n\nwhere $T$ is a constant that fixes the number of hidden units. The decoding is performed pixelwise, {\\emph{i.e.}~} $\\mathcal{H}_k^{3}$ and $\\mathcal{H}_k^{3}$ are $1{\\nobreak\\hspace{-.2em}}\\times{\\nobreak\\hspace{-.2em}} 1$.\nIntuitively, the activations of the hidden layer ({Eq.\\,}\\ref{eq:decoding}) represent scores for motions at $S$ and $O$ discrete speeds and orientations, of which the softmax picks out the highest. Assuming a unimodal distribution of \nscores ({\\emph{i.e.}~} a single motion at any pixel), the output layer interpolates these scores and maps them to a 2D flow vector for every pixel (see {Section~}\\ref{sect:training}).\n\n\n\\subsection{Invariance to in-plane rotations}\n\\label{sect:orientationInvariance}\nIn our context, rotation invariance implies that a rotated input must produce a correspondingly rotated output. Note the contrast with image recognition where rotated inputs should give a \\emph{same} output. All of our learned weights ({Eq.\\,}\\ref{eq:motionFilters}--\\ref{eq:decoding}) are split into groups corresponding to discrete orientations. The key is to enforce these groups of weights to be equivalent, {\\emph{i.e.}~} so that they make the same use of features from the preceding layer at the same \\emph{relative} orientations. In addition, convolutional kernels need to be 2D rotations of each other. These strict requirements allow us to maintain only a single version of the weights at a canonical orientation, and generate the others when evaluating the network (see {Fig.~}\\ref{fig:weights}). During training with backpropagation, the gradients are aligned with this canonical orientation and averaged to update the single version of the weights.\n\nFormally, let us consider a convolutional layer\\footnote{The general formulation applies to convolutional layers as well as to our pixelwise weights ({Eq.\\,}\\ref{eq:decoding}, \\ref{eq:output}), in which case the 2D rotation of the kernel has no effect.} ${\\ell\\hspace{-.1em}+\\hspace{-.1em}1}$. The feature maps $x^{{\\ell}}$ (respectively $x^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}$) are split into $O$ ($P$) groups of $M$ ($N$) channels. For example, in {Eq.\\,}\\ref{eq:smoothing}, $O{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} P$ and $M{\\nobreak\\hspace{-.22em}}={\\nobreak\\hspace{-.22em}} N$. The groups of channels correspond to regular orientations ${\\theta^{{\\ell}}}_{i}$ (${\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}$) in $[0,2\\pi[$. Considering the convolution weights $\\mathcal{H}$ and their slice $h_{imjn}$ the 2D kernel acting on the input (respectively output) channel of orientation ${\\theta^{{\\ell}}}_{i}$ (${\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}$), we constrain the weights as follows:\n\n", "index": 17, "text": "\\begin{gather}\n  \\label{eq:rotationTies1}\n  h_{imjn} ~=~ {\\operatorname{rotate2D}} _{{\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}-{\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j'}} \\big( h_{i'mj'n} \\big) \n  \\\\\n  \\label{eq:rotationTies2}\n  \\forall ~i,i',j,j',m,n~~\\textrm{s.t.}~~cos({\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j'}-{\\theta^{{\\ell}}}_{i'})=cos({\\theta^{{\\ell\\hspace{-.1em}+\\hspace{-.1em}1}}}_{j}-{\\theta^{{\\ell}}}_{i})\n\\end{gather}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle h_{imjn}~{}=~{}{\\operatorname{rotate2D}}_{{\\theta^{{\\ell\\hskip-1%&#10;.0pt+\\hskip-1.0pt1}}}_{j}-{\\theta^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}}_{j^{%&#10;\\prime}}}\\big{(}h_{i^{\\prime}mj^{\\prime}n}\\big{)}\" display=\"block\"><mrow><mpadded width=\"+3.3pt\"><msub><mi>h</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>n</mi></mrow></msub></mpadded><mo rspace=\"5.8pt\">=</mo><mrow><msub><mo>rotate2D</mo><mrow><mmultiscripts><mi>\u03b8</mi><none/><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow><mi>j</mi><none/></mmultiscripts><mo>-</mo><mmultiscripts><mi>\u03b8</mi><none/><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow><msup><mi>j</mi><mo>\u2032</mo></msup><none/></mmultiscripts></mrow></msub><mo>\u2061</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><msub><mi>h</mi><mrow><msup><mi>i</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><msup><mi>j</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mi>n</mi></mrow></msub><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall~{}i,i^{\\prime},j,j^{\\prime},m,n~{}~{}\\textrm{s.t.}~{}~{}%&#10;cos({\\theta^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}}_{j^{\\prime}}-{\\theta^{{\\ell}}}%&#10;_{i^{\\prime}})=cos({\\theta^{{\\ell\\hskip-1.0pt+\\hskip-1.0pt1}}}_{j}-{\\theta^{{%&#10;\\ell}}}_{i})\" display=\"block\"><mrow><mrow><mrow><mo rspace=\"5.8pt\">\u2200</mo><mi>i</mi></mrow><mo>,</mo><msup><mi>i</mi><mo>\u2032</mo></msup><mo>,</mo><mi>j</mi><mo>,</mo><msup><mi>j</mi><mo>\u2032</mo></msup><mo>,</mo><mi>m</mi><mo>,</mo><mrow><mpadded width=\"+6.6pt\"><mi>n</mi></mpadded><mo>\u2062</mo><mpadded width=\"+6.6pt\"><mtext>s.t.</mtext></mpadded><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\u03b8</mi><none/><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow><msup><mi>j</mi><mo>\u2032</mo></msup><none/></mmultiscripts><mo>-</mo><mmultiscripts><mi>\u03b8</mi><none/><mi mathvariant=\"normal\">\u2113</mi><msup><mi>i</mi><mo>\u2032</mo></msup><none/></mmultiscripts></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mmultiscripts><mi>\u03b8</mi><none/><mrow><mpadded width=\"-1pt\"><mi mathvariant=\"normal\">\u2113</mi></mpadded><mo rspace=\"1.5pt\">+</mo><mn>1</mn></mrow><mi>j</mi><none/></mmultiscripts><mo>-</mo><mmultiscripts><mi>\u03b8</mi><none/><mi mathvariant=\"normal\">\u2113</mi><mi>i</mi><none/></mmultiscripts></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}]