[{"file": "1601.03928.tex", "nexttext": "\nwhich will call \\emph{numbering function}. Thus, each element of  $M$ uniquely corresponds to an element of Boolean array $H[\\; ]$  with size equal to the cardinality $|M|$  of the set  $M$. Moreover, the element  $x\\in M$ is \\emph{selected} if $H[b(x)]=1$  and $x$  is \\emph{not selected} if  $H[b(x)]=0$.\n\nThe next algorithm is a modification of the well-known method, known as ''Sieve of Era\\-to\\-sthe\\-nes'' [\\cite{Reingold,markovska}] solves Problem \\ref{problem1}.\n\n\\begin{algorithm}\\label{Algorithm1}\nReceives exactly one representative of each equivalence class of the factor-set  $\\widetilde{M}=M_{/\\sim}$.\n\n\\textbf{Input}: Finite set $M$\n\n\\textbf{Output}: Set $N\\subseteq M$\n\n\\begin{enumerate}\n\\item\t $N:=\\emptyset$;\n\n\\item\tDeclare a Boolean array $H[\\; ]$  with size equal to the cardinality $|M|$  of the set $M$  and put $H[b(x)]:=0$  for all $x\\in M$;\n\n\\item\tFor every $x\\in M$  such that $H[b(x)]=0$\\textbf{ do}\n\n\\hspace{1cm}\\{ \\textbf{Begin} of loop 1\n\n\\item\t\\hspace{1cm}$N:=N\\cup \\{x\\}$;\n\n\\item\t\\hspace{1cm}$H[b(x)]:=1$;\n\n\\item\\label{6}\t\\hspace{1cm}Using the procedure $K(x)$  obtain the set $P_x =\\{y\\in M \\; |\\;y\\sim x \\}$;\n\n\\item\t\\hspace{1cm}For every $y\\in P_x$  obtained in step \\ref{6} \\textbf{do}\n\n\\hspace{2cm} \\{ \\textbf{Begin} of loop 2\n\n\\item \\hspace{2cm} $H[b(y)]:=1$;\n\n\\hspace{2cm} \\textbf{End} of loop 2 \\}\n\n\\hspace{1cm}\\textbf{End} of loop 1 \\}\n\n\\item\tEnd of the algorithm.\n\\end{enumerate}\n\\end{algorithm}\n\nAlgorithm \\ref{Algorithm1} has a number of disadvantages, the main of which is that it is practically inapplicable for programs when a sufficiently great number of elements is present in the base set $M$. This limitation comes from the maximum integer, which can be used in the corresponding programming environment. For example, by standard in the C++ language the biggest number of the type \\textbf{unsigned long int} is equal to $2^{32} - 1$, which in a number of cases is insufficient for the previously defined array $H[\\; ]$  to be completely addressed. The purpose of this article is to avoid this problem by using a multidimensional Boolean array, the elements of which have a one-to-one correspondence to the elements of the base set, with a much smaller range of the indices. There are many publications related to multidimensional arrays, for example [\\cite{arxiv}], but they are not used for our specific goals and objectives. Another solution to the problem is the use of dynamic data structures or other special programming techniques [\\cite{Collins,Sutter,Tan}] but it is not the subject of consideration in this article. \t\n\n\\emph{Binary (or Boolean, or (0,1)-matrix)} is a matrix whose elements are equal to 0 or 1.\n\nLet ${\\cal B}_{m\\times n}$  be the set of all $m\\times n$  binary matrices. It is well known that\n\n\n", "itemtype": "equation", "pos": 1976, "prevtext": "\n\n\n\n\n\\begin{flushright}\n\n{\\Large \\textbf{\\\\On an application of multidimensional arrays}}\\[5mm]\n{\\large \\textbf{Krasimir Yordzhev$^\\mathrm{*}$\\footnote{\\emph{E-mail: yordzhev@swu.bg}}  }}\\[1mm]\n{\\footnotesize \\it South-West University ''Neofit Rilski'',\\\\ Blagoevgrad, Bulgaria}\n\\end{flushright}\n\n\n\n{\\Large \\textbf{Abstract}}\\[4mm]\n\\fbox{\n\\begin{minipage}{5.4in}{\\footnotesize This article discusses some difficulties in the implementation of combinatorial algorithms associated with the choice of all elements with certain properties among the elements of a set with great cardinality.The problem has been resolved by using multidimensional arrays. Illustration of the method is a solution of the problem of obtaining one representative from each equivalence class with respect to the described in the article equivalence relation in the set of all $m\\sim n$  binary matrices. This equivalence relation has an application in the mathematical modeling in the textile industry.\n} \\end{minipage}}\\[1mm]\n\\footnotesize{\\it{Keywords:} binary matrix; equivalence relation; factor-set; cardinality; multidimensional array }\\[1mm]\n\\footnotesize{{2010 Mathematics Subject Classification:} 05B20; 68P05}\n\n\n\n\\section{Introduction and task formulation}\\label{I1}\nThe following problem often occurs in computer science:\n\\begin{problem}\\label{problem1}\nLet $M$  be a finite set and let $\\sim$  be an equivalence relation in $M$. Describe and implement an algorithm that receives exactly one representative from each equivalence class with respect to  $\\sim$.\n\\end{problem}\n\nAs a consequence of this problem follows the combinatorial problem of finding the cardinality of the factor set $\\widetilde{M} = M_{/\\sim}$   consisting of all equivalence classes of $M$  with respect of  $\\sim$.\n\nWe assume that for every  $x\\in M$, there is a procedure $K(x)$  which receives all elements of  $M$, which are equivalent to  $x$.\n\nSince $M$  is a finite set, then there exists bijective mapping\n\n", "index": 1, "text": "$$b\\; :\\; \\leftrightarrow \\left\\{ 1,2,\\ldots ,\\left| M\\right| \\right\\} ,$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"b\\;:\\;\\leftrightarrow\\left\\{1,2,\\ldots,\\left|M\\right|\\right\\},\" display=\"block\"><mrow><mpadded width=\"+2.8pt\"><mi>b</mi></mpadded><mo rspace=\"5.3pt\">:</mo><mo>\u2194</mo><mrow><mo>{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mo>|</mo><mi>M</mi><mo>|</mo><mo>}</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\n\nIn this work, we will consider and solve the following special case of Problem \\ref{problem1}:\n\n\\begin{problem}\\label{problem2}\n Let ${\\cal B}_{m\\times n}$  be the set of all $m\\times n$  binary matrices and let  $X,Y\\in {\\cal B}_{m\\times n}$. We define an equivalence relation $\\rho$  as follows: $X\\rho Y$ if and only if we can obtain $X$  from $Y$  by a sequential moving of the last row or column to the first place. Find the cardinality $|{\\cal B}_{m\\times n/\\rho} |$  of the factor-set $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$  and receive a single representative of each equivalence class.\n\\end{problem}\n\nThe proof that $\\rho$  is an equivalence relation is trivial and we will omit it here.\n\nThe equivalence classes of ${\\cal B}_{m\\times n}$   by the equivalence relation $\\rho$  are a particular kind of \\emph{double coset} [\\cite{r2,r4,r6}]. They make use of substitutions group theory and linear representation of finite group theory [\\cite{r4,r6}].\n\nWhen $m=n$, the elements of the factor-set $\\widetilde{M} ={\\cal B}_{n\\times n/\\rho}$  put carry into practice in the textile technology [\\cite{b2,textile}].\n\nIn [\\cite{y9}] an algorithm is shown, which utilizes theoretical graphical methods for finding the factor set  $\\widetilde{S} =S_{n/\\rho}$, where $S_{n} \\subset {\\cal B}_{n\\times n}$  is a set of all permutation matrices, i.e. binary matrices having exactly one 1 on each row and each column. In [\\cite{az}] we extended this problem in the case when $\\rho$  is an arbitrary permutation.\n\nThe author of this paper is not familiar with an existing a general formula expressed as a function of $m$ and $n$ for finding  $|{\\cal B}_{m\\times n/\\rho} |$.  The goal of this paper is to describe an effective algorithm for finding the number of elements of the factor set  $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$, as well as finding a single representative of each equivalence class. Here we will describe an algorithm, which overcomes some difficulties, which would inevitably arise with sufficiently great m and n if we apply the classical algorithm (Algorithm \\ref{Algorithm1}). The main difficulty arises from the great number of elements of $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$  with comparatively small integers $m$  and $n$, according to formula (\\ref{eq1}).\n\nFor undefined notions and definitions, we refer to [\\cite{r1,sachkov}].\n\n\n\n\\section{Description of an algorithm with the use of a multi\\-di\\-men\\-si\\-o\\-nal array}\\label{I3}\n\\begin{thm} \\label{Theorem1} Let us denote by ${\\cal P}_n$  the set\n\n", "itemtype": "equation", "pos": 4821, "prevtext": "\nwhich will call \\emph{numbering function}. Thus, each element of  $M$ uniquely corresponds to an element of Boolean array $H[\\; ]$  with size equal to the cardinality $|M|$  of the set  $M$. Moreover, the element  $x\\in M$ is \\emph{selected} if $H[b(x)]=1$  and $x$  is \\emph{not selected} if  $H[b(x)]=0$.\n\nThe next algorithm is a modification of the well-known method, known as ''Sieve of Era\\-to\\-sthe\\-nes'' [\\cite{Reingold,markovska}] solves Problem \\ref{problem1}.\n\n\\begin{algorithm}\\label{Algorithm1}\nReceives exactly one representative of each equivalence class of the factor-set  $\\widetilde{M}=M_{/\\sim}$.\n\n\\textbf{Input}: Finite set $M$\n\n\\textbf{Output}: Set $N\\subseteq M$\n\n\\begin{enumerate}\n\\item\t $N:=\\emptyset$;\n\n\\item\tDeclare a Boolean array $H[\\; ]$  with size equal to the cardinality $|M|$  of the set $M$  and put $H[b(x)]:=0$  for all $x\\in M$;\n\n\\item\tFor every $x\\in M$  such that $H[b(x)]=0$\\textbf{ do}\n\n\\hspace{1cm}\\{ \\textbf{Begin} of loop 1\n\n\\item\t\\hspace{1cm}$N:=N\\cup \\{x\\}$;\n\n\\item\t\\hspace{1cm}$H[b(x)]:=1$;\n\n\\item\\label{6}\t\\hspace{1cm}Using the procedure $K(x)$  obtain the set $P_x =\\{y\\in M \\; |\\;y\\sim x \\}$;\n\n\\item\t\\hspace{1cm}For every $y\\in P_x$  obtained in step \\ref{6} \\textbf{do}\n\n\\hspace{2cm} \\{ \\textbf{Begin} of loop 2\n\n\\item \\hspace{2cm} $H[b(y)]:=1$;\n\n\\hspace{2cm} \\textbf{End} of loop 2 \\}\n\n\\hspace{1cm}\\textbf{End} of loop 1 \\}\n\n\\item\tEnd of the algorithm.\n\\end{enumerate}\n\\end{algorithm}\n\nAlgorithm \\ref{Algorithm1} has a number of disadvantages, the main of which is that it is practically inapplicable for programs when a sufficiently great number of elements is present in the base set $M$. This limitation comes from the maximum integer, which can be used in the corresponding programming environment. For example, by standard in the C++ language the biggest number of the type \\textbf{unsigned long int} is equal to $2^{32} - 1$, which in a number of cases is insufficient for the previously defined array $H[\\; ]$  to be completely addressed. The purpose of this article is to avoid this problem by using a multidimensional Boolean array, the elements of which have a one-to-one correspondence to the elements of the base set, with a much smaller range of the indices. There are many publications related to multidimensional arrays, for example [\\cite{arxiv}], but they are not used for our specific goals and objectives. Another solution to the problem is the use of dynamic data structures or other special programming techniques [\\cite{Collins,Sutter,Tan}] but it is not the subject of consideration in this article. \t\n\n\\emph{Binary (or Boolean, or (0,1)-matrix)} is a matrix whose elements are equal to 0 or 1.\n\nLet ${\\cal B}_{m\\times n}$  be the set of all $m\\times n$  binary matrices. It is well known that\n\n\n", "index": 3, "text": "\\begin{equation}\\label{eq1}\n\\left| {\\cal B}_{m\\times n} \\right| = 2^{mn}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\left|{\\cal B}_{m\\times n}\\right|=2^{mn}\" display=\"block\"><mrow><mrow><mo>|</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mi>m</mi><mo>\u00d7</mo><mi>n</mi></mrow></msub><mo>|</mo></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>\u2062</mo><mi>n</mi></mrow></msup></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\n  Then a one-to-one correspondence (bijection) between the elements of the Cartesian product\n  $\\displaystyle {\\cal P}_n^m =\\underbrace{{\\cal P}_n \\times {\\cal P}_n \\times \\cdots \\times {\\cal P}_n}_m $  and the elements of the set ${B}_{m\\times n}$  of all  $m\\times n$  binary matrices exists.\n\\end{thm}\n\n\\begin{proof}\nWe consider the mapping  $\\alpha  : {\\cal P}_n^m\n\\to {\\cal B}_{m\\times n}$, defined in the following way: If  $\\pi\\in {\\cal P}_n^m$ and $\\pi =<p_1 ,p_2 ,\\ldots ,p_m >$  then let us denote by  $z_i$,  $i=1,2,\\ldots ,m$, the representation of the integer  $p_i$ in a binary notation, and if less than $n$ digits 0 or 1 are necessary, we fill $z_i$ from the left with insignificant zeros, so that $z_i$  will be written with exactly $n$ digits. Since by definition,  $p_i \\in {\\cal P}_n $, i.e.  $0\\le p_i \\le 2^n -1$, this will always be possible. Then we form an $m\\times n$   binary matrix, so that the $i$-th row is  $z_i ,$ $i=1,2,\\ldots m$. Apparently this is a correctly defined mapping of  ${\\cal P}_n^m$ to ${\\cal B}_{m\\times n}$. It is clear that for different $n$-tuples from ${\\cal P}_n^m$  with the help of $\\alpha$  we will obtain different matrices from  ${\\cal B}_{m\\times n}$, i.e. $\\alpha$  is an injection. Conversely, rows of each binary matrix can be considered as natural numbers, written in binary system by using exactly $n$ digits 0 or 1, eventually with insignificant zeros in the beginning, that is, these numbers belong to the set  ${\\cal P}_n =\\{ 0,1,\\ldots ,2^n -1\\}$. Therefore each  $m\\times n$ Binary matrix corresponds to an $m$-tuple of numbers   $<p_1 ,p_2 ,\\ldots ,p_m >\\in {\\cal P}_m^n$, that is,  $\\alpha$ is a surjection. Hence  $\\alpha$ is a bijection.\n\\end{proof}\n\nIt is easy to see the validity of the following statement, which in fact shows the meaning of our considerations.\n\n\\begin{prop}\\label{propmu}\nLet us denote by  $\\mu$ the maximum integer, which we use when coding the elements of the set ${\\cal B}_{m\\times n}$  by means of the bijection, defined in Theorem \\ref{Theorem1}. Then, for sufficiently great $m$ and $n$, the following is valid:\n\n", "itemtype": "equation", "pos": 7442, "prevtext": "\n\nIn this work, we will consider and solve the following special case of Problem \\ref{problem1}:\n\n\\begin{problem}\\label{problem2}\n Let ${\\cal B}_{m\\times n}$  be the set of all $m\\times n$  binary matrices and let  $X,Y\\in {\\cal B}_{m\\times n}$. We define an equivalence relation $\\rho$  as follows: $X\\rho Y$ if and only if we can obtain $X$  from $Y$  by a sequential moving of the last row or column to the first place. Find the cardinality $|{\\cal B}_{m\\times n/\\rho} |$  of the factor-set $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$  and receive a single representative of each equivalence class.\n\\end{problem}\n\nThe proof that $\\rho$  is an equivalence relation is trivial and we will omit it here.\n\nThe equivalence classes of ${\\cal B}_{m\\times n}$   by the equivalence relation $\\rho$  are a particular kind of \\emph{double coset} [\\cite{r2,r4,r6}]. They make use of substitutions group theory and linear representation of finite group theory [\\cite{r4,r6}].\n\nWhen $m=n$, the elements of the factor-set $\\widetilde{M} ={\\cal B}_{n\\times n/\\rho}$  put carry into practice in the textile technology [\\cite{b2,textile}].\n\nIn [\\cite{y9}] an algorithm is shown, which utilizes theoretical graphical methods for finding the factor set  $\\widetilde{S} =S_{n/\\rho}$, where $S_{n} \\subset {\\cal B}_{n\\times n}$  is a set of all permutation matrices, i.e. binary matrices having exactly one 1 on each row and each column. In [\\cite{az}] we extended this problem in the case when $\\rho$  is an arbitrary permutation.\n\nThe author of this paper is not familiar with an existing a general formula expressed as a function of $m$ and $n$ for finding  $|{\\cal B}_{m\\times n/\\rho} |$.  The goal of this paper is to describe an effective algorithm for finding the number of elements of the factor set  $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$, as well as finding a single representative of each equivalence class. Here we will describe an algorithm, which overcomes some difficulties, which would inevitably arise with sufficiently great m and n if we apply the classical algorithm (Algorithm \\ref{Algorithm1}). The main difficulty arises from the great number of elements of $\\widetilde{M} ={\\cal B}_{m\\times n/\\rho}$  with comparatively small integers $m$  and $n$, according to formula (\\ref{eq1}).\n\nFor undefined notions and definitions, we refer to [\\cite{r1,sachkov}].\n\n\n\n\\section{Description of an algorithm with the use of a multi\\-di\\-men\\-si\\-o\\-nal array}\\label{I3}\n\\begin{thm} \\label{Theorem1} Let us denote by ${\\cal P}_n$  the set\n\n", "index": 5, "text": "\\begin{equation}\\label{(11)}\n{\\cal P}_n =\\left\\{ 0,1,\\ldots ,2^n -1 \\right\\}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"{\\cal P}_{n}=\\left\\{0,1,\\ldots,2^{n}-1\\right\\}\" display=\"block\"><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mi>n</mi></msub><mo>=</mo><mrow><mo>{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn></mrow><mo>}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\n\\end{prop}\n\\begin{proof} Trivial. \\end{proof}\n\nLet $a$ and $b$  be integers,  $b\\ne 0$. With $a/b$ we will denote the operation ''integer division'' of $a$ by $b$, i.e. if the division has a remainder, then the fractional part is cut, and with  $a\\% b$ we will denote the remainder when dividing $a$  by  $b$. In other words, if $\\displaystyle \\frac{a}{b} = p+\\frac{q}{b}$, where $p$ and $q$ are integers, $0\\le q< b$ then by definition $a/b =p$, $a\\% b =q$.\n\nWe consider the function\t\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n  Then a one-to-one correspondence (bijection) between the elements of the Cartesian product\n  $\\displaystyle {\\cal P}_n^m =\\underbrace{{\\cal P}_n \\times {\\cal P}_n \\times \\cdots \\times {\\cal P}_n}_m $  and the elements of the set ${B}_{m\\times n}$  of all  $m\\times n$  binary matrices exists.\n\\end{thm}\n\n\\begin{proof}\nWe consider the mapping  $\\alpha  : {\\cal P}_n^m\n\\to {\\cal B}_{m\\times n}$, defined in the following way: If  $\\pi\\in {\\cal P}_n^m$ and $\\pi =<p_1 ,p_2 ,\\ldots ,p_m >$  then let us denote by  $z_i$,  $i=1,2,\\ldots ,m$, the representation of the integer  $p_i$ in a binary notation, and if less than $n$ digits 0 or 1 are necessary, we fill $z_i$ from the left with insignificant zeros, so that $z_i$  will be written with exactly $n$ digits. Since by definition,  $p_i \\in {\\cal P}_n $, i.e.  $0\\le p_i \\le 2^n -1$, this will always be possible. Then we form an $m\\times n$   binary matrix, so that the $i$-th row is  $z_i ,$ $i=1,2,\\ldots m$. Apparently this is a correctly defined mapping of  ${\\cal P}_n^m$ to ${\\cal B}_{m\\times n}$. It is clear that for different $n$-tuples from ${\\cal P}_n^m$  with the help of $\\alpha$  we will obtain different matrices from  ${\\cal B}_{m\\times n}$, i.e. $\\alpha$  is an injection. Conversely, rows of each binary matrix can be considered as natural numbers, written in binary system by using exactly $n$ digits 0 or 1, eventually with insignificant zeros in the beginning, that is, these numbers belong to the set  ${\\cal P}_n =\\{ 0,1,\\ldots ,2^n -1\\}$. Therefore each  $m\\times n$ Binary matrix corresponds to an $m$-tuple of numbers   $<p_1 ,p_2 ,\\ldots ,p_m >\\in {\\cal P}_m^n$, that is,  $\\alpha$ is a surjection. Hence  $\\alpha$ is a bijection.\n\\end{proof}\n\nIt is easy to see the validity of the following statement, which in fact shows the meaning of our considerations.\n\n\\begin{prop}\\label{propmu}\nLet us denote by  $\\mu$ the maximum integer, which we use when coding the elements of the set ${\\cal B}_{m\\times n}$  by means of the bijection, defined in Theorem \\ref{Theorem1}. Then, for sufficiently great $m$ and $n$, the following is valid:\n\n", "index": 7, "text": "\\begin{equation}\\label{(12)}\n\\mu =\\max \\left( 2^n -1,m\\right) \\ll |{\\cal B}_{m\\times n}\n|=2^{mn}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\mu=\\max\\left(2^{n}-1,m\\right)\\ll|{\\cal B}_{m\\times n}|=2^{mn}\" display=\"block\"><mrow><mi>\u03bc</mi><mo>=</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mi>m</mi><mo>)</mo></mrow></mrow><mo>\u226a</mo><mrow><mo stretchy=\"false\">|</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mi>m</mi><mo>\u00d7</mo><mi>n</mi></mrow></msub><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>\u2062</mo><mi>n</mi></mrow></msup></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\nwhere $\\%$  and  $/$  are the defined in the above operations.\n\n\\begin{defn}\\label{Definition1}\n Let $\\alpha$   be the defined in the proof of Theorem \\ref{Theorem1} bijection and let the functions $f_r ,f_c : {\\cal P}_n^m \\to\n{\\cal P}_n^m$  be defined such that for every $\\pi =<p_1 ,p_2 ,\\ldots ,p_m > \\in {\\cal P}_n^m$\n\n", "itemtype": "equation", "pos": 10246, "prevtext": "\t\n\\end{prop}\n\\begin{proof} Trivial. \\end{proof}\n\nLet $a$ and $b$  be integers,  $b\\ne 0$. With $a/b$ we will denote the operation ''integer division'' of $a$ by $b$, i.e. if the division has a remainder, then the fractional part is cut, and with  $a\\% b$ we will denote the remainder when dividing $a$  by  $b$. In other words, if $\\displaystyle \\frac{a}{b} = p+\\frac{q}{b}$, where $p$ and $q$ are integers, $0\\le q< b$ then by definition $a/b =p$, $a\\% b =q$.\n\nWe consider the function\t\n\n\n", "index": 9, "text": "\\begin{equation}\\label{(13)}\n\\xi (a) =\\left( a\\% 2\\right) 2^{n-1} +a/2 ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\xi(a)=\\left(a\\%2\\right)2^{n-1}+a/2,\" display=\"block\"><mrow><mrow><mrow><mi>\u03be</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo>(</mo><mrow><mrow><mi>a</mi><mo lspace=\"0pt\" rspace=\"3.5pt\">%</mo></mrow><mo>\u2062</mo><mn>2</mn></mrow><mo>)</mo></mrow><mo>\u2062</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo>+</mo><mrow><mi>a</mi><mo>/</mo><mn>2</mn></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere $\\%$  and  $/$  are the defined in the above operations.\n\n\\begin{defn}\\label{Definition1}\n Let $\\alpha$   be the defined in the proof of Theorem \\ref{Theorem1} bijection and let the functions $f_r ,f_c : {\\cal P}_n^m \\to\n{\\cal P}_n^m$  be defined such that for every $\\pi =<p_1 ,p_2 ,\\ldots ,p_m > \\in {\\cal P}_n^m$\n\n", "index": 11, "text": "\\begin{equation}\\label{(15)}\nf_r (\\pi )=<p_m ,p_1 ,p_2 ,\\ldots p_{m-1} >\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"f_{r}(\\pi)=&lt;p_{m},p_{1},p_{2},\\ldots p_{m-1}&gt;\" display=\"block\"><mrow><msub><mi>f</mi><mi>r</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mo>&lt;</mo><msub><mi>p</mi><mi>m</mi></msub><mo>,</mo><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><msub><mi>p</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>&gt;</mo></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\nwhere the function  $\\xi (a) $ is the defined with (\\ref{(13)}).\n\\end{defn}\n\n\\begin{thm}\\label{Theorem2}\nLet $A\\in {\\cal B}_{m\\times n}$  be an arbitrary $m\\times n$  binary matrix and let $\\alpha$ be the defined in the proof of Theorem \\ref{Theorem1} bijection. Let us to get the matrices\n\n", "itemtype": "equation", "pos": 10745, "prevtext": "\t\n\n", "index": 13, "text": "\\begin{equation}\\label{(16)}\nf_c (\\pi )=< \\xi (p_1 ), \\xi (p_2 ),\\ldots ,\\xi (p_m )>,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"f_{c}(\\pi)=&lt;\\xi(p_{1}),\\xi(p_{2}),\\ldots,\\xi(p_{m})&gt;,\" display=\"block\"><mrow><msub><mi>f</mi><mi>c</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mo>&lt;</mo><mi>\u03be</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>\u03be</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>\u03be</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mi>m</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>&gt;</mo><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\nand\t\t\t\t\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere the function  $\\xi (a) $ is the defined with (\\ref{(13)}).\n\\end{defn}\n\n\\begin{thm}\\label{Theorem2}\nLet $A\\in {\\cal B}_{m\\times n}$  be an arbitrary $m\\times n$  binary matrix and let $\\alpha$ be the defined in the proof of Theorem \\ref{Theorem1} bijection. Let us to get the matrices\n\n", "index": 15, "text": "\\begin{equation}\\label{(17)}\nB=\\alpha \\left( f_r \\left( \\alpha^{-1} (A)\\right)\\right)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"B=\\alpha\\left(f_{r}\\left(\\alpha^{-1}(A)\\right)\\right)\" display=\"block\"><mrow><mi>B</mi><mo>=</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mi>\u03b1</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\n\nThen $B$ is obtained from $A$ by moving the last row to the first place, and $C$ is obtained from $A$ by moving the last column to the first place (respectively the first row or column becomes the second, the second becomes the third respectively etc.).\n\\end{thm}\n\n\\begin{proof} Let  $\\pi =<p_1 ,p_2 ,\\ldots ,p_m >=\\alpha^{-1} (A)\\in {\\cal P}_n^m$. Then the integer  $p_i$, $0\\le p_i \\le 2^n -1$, $i=1,2,\\ldots ,m$  will correspond to the $i$-th row of the matrix $A$. Then obviously, the matrix $B=\\alpha (f_r (<p_1 ,p_2 ,\\ldots ,p_m >))=\\alpha (<p_m ,p_1 ,p_2 ,\\ldots ,p_{m-1} >)$  is obtained from $A$ by moving the last row in the place of the first one, and moving the remaining rows one row below.\n\nLet $p_i \\in {\\cal P}_n =\\left\\{ 0,1,\\ldots ,2^n -1 \\right\\}$, $i=1,2,\\ldots ,m$. Then $d_i =p_i \\% 2$  gives the last digit of the binary notation of the integer  $p_i$. If  $p_i$ is written in binary notation with precisely $n$  digits, optionally with insignificant zeros in the beginning, then by applying integer division of  $p_i$   by 2, we practically remove the last digit $d_i$  and we move it to the first position, in case we multiply by $2^{n-1}$  and add it to  $p_i /2$. This is, by definition, how the function  $\\xi (p_i )$ works. Hence, the $m\\times n$ binary matrix $C=\\alpha (f_c (<p_1 ,p_2 ,\\ldots , p_m >))=\\alpha (<\\xi (p_1 ),\\xi (p_2 ),\\ldots ,\\xi (p_m )>)) $  is obtained from the matrix $A$ by moving the last column to the first position, and all the other columns are moved one column to the right.\n\\end{proof}\n\nFrom the definitions of the functions  $f_r$, according to (\\ref{(15)}) and  $f_c$, according to (\\ref{(16)}) it is easy to verify the validity of the following\n\\begin{prop} \\label{Proposition2}\nIf by definition\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\t\nand\t\t\t\t\n\n", "index": 17, "text": "\\begin{equation}\\label{(18)}\nC=\\alpha \\left( f_c \\left( \\alpha^{-1} (A)\\right)\\right)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"C=\\alpha\\left(f_{c}\\left(\\alpha^{-1}(A)\\right)\\right)\" display=\"block\"><mrow><mi>C</mi><mo>=</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mi>\u03b1</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\t\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\t\n\nThen $B$ is obtained from $A$ by moving the last row to the first place, and $C$ is obtained from $A$ by moving the last column to the first place (respectively the first row or column becomes the second, the second becomes the third respectively etc.).\n\\end{thm}\n\n\\begin{proof} Let  $\\pi =<p_1 ,p_2 ,\\ldots ,p_m >=\\alpha^{-1} (A)\\in {\\cal P}_n^m$. Then the integer  $p_i$, $0\\le p_i \\le 2^n -1$, $i=1,2,\\ldots ,m$  will correspond to the $i$-th row of the matrix $A$. Then obviously, the matrix $B=\\alpha (f_r (<p_1 ,p_2 ,\\ldots ,p_m >))=\\alpha (<p_m ,p_1 ,p_2 ,\\ldots ,p_{m-1} >)$  is obtained from $A$ by moving the last row in the place of the first one, and moving the remaining rows one row below.\n\nLet $p_i \\in {\\cal P}_n =\\left\\{ 0,1,\\ldots ,2^n -1 \\right\\}$, $i=1,2,\\ldots ,m$. Then $d_i =p_i \\% 2$  gives the last digit of the binary notation of the integer  $p_i$. If  $p_i$ is written in binary notation with precisely $n$  digits, optionally with insignificant zeros in the beginning, then by applying integer division of  $p_i$   by 2, we practically remove the last digit $d_i$  and we move it to the first position, in case we multiply by $2^{n-1}$  and add it to  $p_i /2$. This is, by definition, how the function  $\\xi (p_i )$ works. Hence, the $m\\times n$ binary matrix $C=\\alpha (f_c (<p_1 ,p_2 ,\\ldots , p_m >))=\\alpha (<\\xi (p_1 ),\\xi (p_2 ),\\ldots ,\\xi (p_m )>)) $  is obtained from the matrix $A$ by moving the last column to the first position, and all the other columns are moved one column to the right.\n\\end{proof}\n\nFrom the definitions of the functions  $f_r$, according to (\\ref{(15)}) and  $f_c$, according to (\\ref{(16)}) it is easy to verify the validity of the following\n\\begin{prop} \\label{Proposition2}\nIf by definition\n\n", "index": 19, "text": "\\begin{equation}\\label{(19)}\nf_r^0 (\\pi )=f_c^0 (\\pi )=\\pi\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"f_{r}^{0}(\\pi)=f_{c}^{0}(\\pi)=\\pi\" display=\"block\"><mrow><mrow><msubsup><mi>f</mi><mi>r</mi><mn>0</mn></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mi>f</mi><mi>c</mi><mn>0</mn></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\u03c0</mi></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\t\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\t\t\n\n", "index": 21, "text": "\\begin{equation}\\label{(20)}\nf_r^k (\\pi )=f_r \\left( f_r^{k-1} (\\pi )\\right)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"f_{r}^{k}(\\pi)=f_{r}\\left(f_{r}^{k-1}(\\pi)\\right)\" display=\"block\"><mrow><mrow><msubsup><mi>f</mi><mi>r</mi><mi>k</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mi>f</mi><mi>r</mi><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\nwhere $\\pi\\in {\\cal P}_n^m$ and $k$ is a positive integer, then\n\n", "itemtype": "equation", "pos": 13276, "prevtext": "\t\t\n\n", "index": 23, "text": "\\begin{equation}\\label{(21)}\nf_c^k (\\pi ) =f_c \\left( f_c^{k-1} (\\pi )\\right) ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"f_{c}^{k}(\\pi)=f_{c}\\left(f_{c}^{k-1}(\\pi)\\right),\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>f</mi><mi>c</mi><mi>k</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>f</mi><mi>c</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mi>f</mi><mi>c</mi><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\t\nand\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere $\\pi\\in {\\cal P}_n^m$ and $k$ is a positive integer, then\n\n", "index": 25, "text": "\\begin{equation}\\label{(22)}\nf_r^m (\\pi )=\\pi\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"f_{r}^{m}(\\pi)=\\pi\" display=\"block\"><mrow><mrow><msubsup><mi>f</mi><mi>r</mi><mi>m</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\u03c0</mi></mrow></math>", "type": "latex"}, {"file": "1601.03928.tex", "nexttext": "\t\t\n\\end{prop}\n\n\\begin{proof} Trivial.\n\\end{proof}\n\nAs a direct consequence of Theorem \\ref{Theorem1}, Theorem \\ref{Theorem2}, Proposition \\ref{Proposition2} and their constructive proofs, it follows that the following algorithm that finds exactly one representative of each equivalence class with respect to the defined in Problem \\ref{problem2} equivalence relation  $\\rho$   and that calculates the cardinality of the factor set  ${{\\cal B}_{m\\times n}}_{/\\rho}$.\n\n\\begin{algorithm}\\label{Algorithm2} Receives exactly one representative of each equivalence class of the factor-set  $\\widetilde{M}=M_{/\\rho}$ and calculates the cardinality of the factor set $\\widetilde{M}=M_{/\\rho}$  when $m$ and $n$ are given.\n\n\\begin{enumerate}\n\\item We declare the $m$-dimensional Boolean arrays $W1$ and $W2$ which we will be indexed by using the elements of the set  ${\\cal P}_n^m$, i.e. $W1[<p_1 ,p_2 ,\\ldots ,p_m >]$  will correspond to the element  $<p_1 ,p_2 ,\\ldots ,p_m > \\in{\\cal P}_n^m$. We proceed analogically with the array  $W2$.\n\t\n\\item Initially we take all elements of $W1$ and $W2$  to be 0. In $W1$  we will remember all elements selected from ${\\cal B}_{m\\times n}$  (one for each equivalence class) by changing $W1[<p_1 ,p_2 ,\\ldots ,p_m >]$ to 1 if we have selected the element $\\alpha ( <p_1 ,p_2 ,\\ldots ,p_m >)$  for a representative of the respective equivalence class. We will change the elements of  $W2$ to 1 for each selection of an element from   ${\\cal B}_{m\\times n}$, i.e. for each  $\\pi'' \\in {\\cal P}_n^m$, for which there exists  $\\pi' \\in {\\cal P}_n^m$, such that  $W1[\\pi' ]=1$  and  $\\alpha (\\pi'' )\\rho \\alpha (\\pi' )$, or in other words, $\\pi'$ and $\\pi''$ encode  two different matrices of the same equivalence class as we have chosen $\\alpha (\\pi' )$  for a representative of this equivalence class.\n\n\\item We declare the counter  $N$, which we initialize by 0. In case of normal ending of the algorithm, $N$  will be showing the cardinality of the factor set  ${{\\cal B}_{m\\times n}}_{/\\rho}$.\n\n\\item While a zero element exists in \u00d0\u00b2 $W2$  \\textbf{do}\n\n\\hspace{1cm}\t\\{ \\textbf{Begin} of loop 1\n\n\\item \\hspace{1cm} We choose the minimal $\\pi =<p_1 ,\\pi_2 ,\\ldots ,\\pi_m >\\in {\\cal P}_n^m$  according to the lexicographic order, for which  $W1[\\pi ]=0$.\n\n\\item \\hspace{1cm}   $W1[\\pi ]:=1$;\n\n\\item \\hspace{1cm}  $N:=N+1$;\n\n\\item \\hspace{1cm} For $i=1,2,\\ldots ,m$  \\textbf{do}\n\n\\hspace{2cm}\t\t\\{ \\textbf{Begin} of loop 2\n\n\\item \\hspace{2cm} $\\pi = f_r^i (\\pi )$.\n\n\n\\item \\hspace{2cm} For $j=1,2,\\ldots , ,n$  \\textbf{do}\n\n\\hspace{3cm} \\{ \\textbf{Begin} of loop 3\n\n\\item \\hspace{3cm} $\\pi :=f_c^j (\\pi )$;\n\n\\item \\hspace{3cm} $W2[\\pi ]:=1$;\n\n\\hspace{3cm}\tEnd of loop 3\\}\n\n\\hspace{2cm}\tEnd of loop 2\\}\n\n\\hspace{1cm}\tEnd of loop 1\\}\n\n\\item \\textbf{End} of the algorithm.\n\\end{enumerate}\n\\end{algorithm}\n\n\n\\section{CONCLUSIONS}\n\nApplying the above ideas, a computer program that receives a computer program that gets only one representative from each equivalence class of the factor-set  $\\widetilde{B}_{n\\times n} =B_{n\\times n/\\rho}$. The purpose of these calculations was to describe and classify some textile structures [\\cite{textile}]. The results relate to obtaining quantitative estimation of all kinds of textile fabric.\n\nIn fact, the cardinality of the factor-set M coincides with an integer sequence noted in On-Line Encyclopedia of Integer Sequences [\\cite{A179043}] as number A179043, namely\n\n\\begin{center}\nA179043=\\{ 2, 7, 64, 4156, 1342208, 1908897152, 11488774559744, 288230376353050816, 29850020237398264483840, 12676506002282327791964489728, 21970710674130840874443091905462272, 154866286100907105149651981766316633972736, ... \\}\n\\end{center}\n\n\n\n\n\\begin{thebibliography}{}\n\\bibitem[\\protect\\citeauthoryear{Aigner}{1979}]{r1}\nAigner,  M. (1979) Combinatorial Theory. {Springer-Verlag}.\n\\bibitem[\\protect\\citeauthoryear{Borzunov}{1983}]{b2}\nBorzunov,C. W. (1983) Thextile Industry-survey Information. v.3. Moscow: {CNII ITEILP}, . (in Russian)\n\\bibitem[\\protect\\citeauthoryear{Bogopolski}{2008}]{r2}\nBogopolski, O (2008) Introduction to Group Theory. Zurich: {European Mathematical Society}.\n\\bibitem[\\protect\\citeauthoryear{Collins}{2002}]{Collins}\nCollins, W. J. (2002) Data structures and the standard template library. {McGraw-Hill}.\n\\bibitem[\\protect\\citeauthoryear{Curtis and Rainer}{1962}]{r4}\nCurtis, C. W.  and Rainer, I.(1962, 2006) Representation Theory of Finite Groups and Associative Algebras.  New York: {Wiley-Interscience}.\n\\bibitem[\\protect\\citeauthoryear{De Vos}{2010}]{r6}\nDe Vos, A. (2010) Reversible Computing - Fundamentals, Quantum Computing, and Applications. {Wiley}.\n\\bibitem[\\protect\\citeauthoryear{Mishra}{2014}]{arxiv}\nMishra, P. (2014) A New Algorithm for Updating and Querying Sub-arrays of Multidimensional Arrays. arXiv: 1311.6093.\n\\bibitem[\\protect\\citeauthoryear{Reingold, Nievergeld and Deo}{1977}]{Reingold}\nReingold, E.M., Nievergeld, J. and Deo N. (1977) Combinatorial algorithms -- Theory and practice. {Prentice Hall}.\n\\bibitem[\\protect\\citeauthoryear{Sutter}{2002}]{Sutter}\nSutter, H. (2002) Exeptional C++, {Addison-Wesley}.\n\\bibitem[\\protect\\citeauthoryear{Sachkov and. Tarakanov}{2002}]{sachkov}\nV. N. Sachkov and. Tarakanov,  V. E (2002) Combinatorics of Nonnegative Matrices, {Amer. Math. Soc}.\n\\bibitem[\\protect\\citeauthoryear{Tan, Steeb and Hardy}{2001}]{Tan}\nTan Kiat Shi,  Steeb W.-H. and Hardy Y. (2001) Symbolic C++: An Introduction to Computer Algebra using Object-Oriented Programming. {Springer}.\n\\bibitem[\\protect\\citeauthoryear{Yordzhev}{2005}]{y9}\nYordzhev, K. (2005) On an equivalence relation in the set of the permutation matrices. {in:  Discrete Mathematics and Applications, SWU Blagoevgrad (BG) and University of Potsdam(GER):}  pp 77--87.\n\\bibitem[\\protect\\citeauthoryear{Yordzhev}{2014}]{az}\nYordzhev, K. (2014)  On the cardinality of a factor set in the symmetric group. {Asian-European Journal of Mathematics}, Vol. 7, No. 2  1450027 (14 pages), DOI: 10.1142/S1793557114500272\n\\bibitem[\\protect\\citeauthoryear{Yordzhev and Kostadinova}{2012}]{textile}\nYordzhev, K. and Kostadinova H. (2012) Mathematical Modelling in the Textile Industry. {Bulletin of Mathematical Sciences \\& Applications}, Vol. 1, No. 1, pp. 20 -35.\n\\bibitem[\\protect\\citeauthoryear{Yordzhev and Markovska}{2007}]{markovska}\nYordzhev, K. and Markovska, A. (2007) Method of the Multidimensional Sieve in the Practical Realization of some Combinatorial Algorithms. Proceedings of Int. Sc. Conf. {UNITECH 07}, 23.11 -- 24.11. 2007, Gabrovo, Bulgaria, Vol. II, pp. 451--456.\n\\bibitem[\\protect\\citeauthoryear{Encyclopedia}{2015}]{A179043}\nOn-Line Encyclopedia of Integer Sequences (2015). A179043--Number of  $n\\times n$  checkered tori,  \\href{http://oeis.org/A179043}{http://oeis.org/A179043}. {\\it (Last accessed on 15 Jan 2016)}\\[6mm]\n\n\n\n\n\\end{thebibliography}\n\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\t\t\nand\n\n", "index": 27, "text": "\\begin{equation}\\label{(23)}\nf_c^n (\\pi )=\\pi .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"f_{c}^{n}(\\pi)=\\pi.\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>f</mi><mi>c</mi><mi>n</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\u03c0</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}]