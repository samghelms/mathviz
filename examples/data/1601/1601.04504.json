[{"file": "1601.04504.tex", "nexttext": "is a set of permutations in $S_n$ with locality $d$, and optimal asymptotic rate $\\frac{d}{d+1}$.\n\\end{lemma}\n\n\\begin{proof}\n\tSince for any $k,~2\\le k\\le d$, we have that $p_k=A(\\sum_{j=1}^{k-1}p_j,i_{k-1})$, it follows from the definition of $A$ that $p_i\\in S_{\\frac{n}{d+1}}$ for all $i\\in\\{1,\\ldots,d+1\\}$.\n\tTherefore, any $\\pi\\in S$ results from a concatenation of $d+1$ permutations on disjoint $\\frac{n}{d+1}$-subsets of $\\{0,\\ldots,n-1\\}$, and thus $S\\subseteq S_n$. Since $p_{d+1}=\\sum_{j=1}^d p_j$, it follows that any symbol of any $\\pi\\triangleq (\\pi_0,\\ldots,\\pi_{n-1})\\in S$ can be computed from $d$ other symbols, since for all $j\\in\\{0,\\ldots,\\frac{n}{d+1}-1\\}$ we have \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\maketitle\n\n\\begin{abstract}\nThe problem of storing permutations in a distributed manner arises in several common scenarios, such as efficient updates of a large, encrypted, or compressed data set. This problem may be addressed in either a combinatorial or a coding approach. The former approach boils down to presenting large sets of permutations with \\textit{locality}, that is, any symbol of the permutation can be computed from a small set of other symbols. In the latter approach, a permutation may be coded in order to achieve locality. Both approaches must present low \\textit{query complexity} to allow the user to find an element efficiently. We discuss both approaches, and give a particular focus to the combinatorial one.\n\nIn the combinatorial approach, we provide upper and lower bounds for the maximal size of a set of permutations with locality, and provide several simple constructions which attain the upper bound. In cases where the upper bound is not attained, we provide alternative constructions using a variety of tools, such as Reed-Solomon codes, permutation polynomials, and multi-permutations. In addition, several low-rate constructions of particular interest are discussed.\n\nIn the coding approach we discuss an alternative representation of permutations, present a paradigm for supporting arbitrary powers of the stored permutation, and conclude with a proof of concept that permutations may be stored more efficiently than ordinary strings over the same alphabet.\n\n\n\n\\end{abstract}\n\n\\footnotetext[1]{Massachusetts Institute of Technology, Cambridge, MA, medard@mit.edu.}\n\\footnotetext[2]{Department of Computer Science, Technion, Haifa 3200003, Israel, \\{yaakobi,netanel.raviv\\}@gmail.com.}\n\\footnotetext[3]{The work of Netanel Raviv was done while he was a visiting student at MIT, under the supervision of Prof. M\\'{e}dard.}\n\n\n\\section{Introduction}\\label{section:introduction}\nFor an integer $n$, let $S_n$ be the group of all permutations on $n$ elements. Given a permutation $\\pi\\in S_n$ we consider the problem of storing a representation of $\\pi$ in a distributed system of storage nodes. This problem arises when considering efficient \\textit{permutation updates} to a distributed storage system. For example, in a system which stores large entries whose order commonly changes, one might prefer to store the permutation of the entries, rather than constantly shift them around. Alternatively, the stored file may be \\textit{signed} or \\textit{hashed} (using cryptographic primitives), and storing the permutation alongside the file allows to update the file without altering its signature. The given file may also be compressed using a \\textit{source code}, and storing the permutation enables to perform permutation updates without the need to decompress the file. Perhaps the most natural example for such a scenario is the common operation of \\textit{cut and paste}, which may be modelled as a permutation update, and briefly discussed in Subsection~\\ref{section:motivation}. \n\nAbove all questions of efficiency, in very simple storage schemes, a permutation update might require to decode the file (see Subsection~\\ref{section:motivation}). Storing the permutation alongside $x$ allows a permutation update to be made without decoding the file, at the price of storage overhead.\n\nThe crux of enabling efficient storage lies in the notion of \\textit{locality}, that is, any failed storage node may be reconstructed by accessing a small number of its neighbors. The corresponding coding problem is often referred to as \\textit{symbol locality}, in which every symbol of a codeword is a function of a small set of other symbols~\\cite{family}. Another approach towards efficient storage stems from \\textit{array codes}, in which each storage node stores a large set of symbols from the codeword (e.g.,~\\cite{LongMDS} and references therein). For simplicity, in this paper we consider symbol locality. Furthermore, since our underlying motivation is allowing \\textit{small} updates to be done efficiently, we disregard the notion of minimum distance between the stored permutations, and focus solely on locality. Occasionally, we will discuss local correction of simultaneous erasures, as in~\\cite{Kamath}. \n\nAs mentioned earlier, locality in permutations may be considered in either a combinatorial or a coding approach. Under the combinatorial one, the underlying motivation is set aside, and the problem boils down to finding (or bounding the maximum size of) sets of permutations which present locality. This approach is the main one in this paper. Under the coding approach, the given permutation may be coded in order to achieve locality. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tSeveral natural questions, which are irrelevant in ordinary storage, may arise when discussing storage of permutations. For example, a storage system which stores $\\pi\\in S_n$ may be required to answer either $\\pi^{-1}(i)=?$ or $\\pi(i)=?$ quickly. These questions are denoted by Q1 and Q2, respectively, and notice that without this additional requirement, storing permutations reduces to storing binary strings of length $\\ceil*{\\log(n!)}$ by enumerative encoding. \n\tIn the combinatorial approach, either one of Q1 or Q2 becomes trivial, depending if we consider the permutation at hand as $\\left(\\pi(1),\\ldots,\\pi(n)\\right)$ or $\\left(\\pi^{-1}(1),\\ldots,\\pi^{-1}(n)\\right)$. \n\tFor example, when storing the latter, answering Q1 is straightforward, and answering Q2 is possible by inspecting $\\pi^{-1}(i),\\pi^{-1}({\\pi^{-1}(i)}),\\ldots,$ etc., until $i$ is found (see~\\cite[ch.~1.3, p.~29]{DummitAndFoote}). Hence, the number of required queries for Q1 is 1 (or $\\log n$ bits), and for Q2 it is at most the length of the longest cycle in $\\pi$. Although it is not the general purpose of this research, we take initial steps towards efficient retrieval of $\\pi(i)$ and $\\pi^{-1}(i)$ simultaneously. \n\tClearly, allowing the permutation to be encoded provides more freedom in devising storage techniques. However, maintaining a concise representation which enables Q1 and Q2 to be answered quickly is a rather involved question, which was studied in the past in a non-distributed setting (e.g. \\cite{MunroSuccinct,Succincter}, see further details in Section~\\ref{section:previousWork}).\n\nSince a variety of mathematical techniques are used throughout this paper, in each technique we consider the permutations in $S_n$ as operating on a different sets of symbols. These sets may be either $[n]\\triangleq\\{1,\\ldots,n\\}$ or $\\{0,\\ldots,n-1\\}$. \nAlternatively, we may assume that $n$ is a power of prime, and $\\{0,1,\\ldots,n-1\\}$ is an enumeration of the elements in ${\\mathbb{F}}_n$, the finite field with $n$ elements, where the additive identity element of ${\\mathbb{F}}_n$ is denoted by ``0'' and the multiplicative identity element is denoted by ``1''. Unless otherwise stated, we consider permutations in the \\textit{one line representation} (one-liner, in short), that is, $\\pi\\triangleq\\left(\\pi_1,\\ldots,\\pi_n\\right)=\\left(\\pi^{-1}(1),\\ldots,\\pi^{-1}(n)\\right)$. Given a set $S\\subseteq S_n$, we say that $S$ has locality $d$ if for any $\\pi\\in S$, any symbol $\\pi_i$ may be computed from $d$ other symbols of $\\pi$. The \\textit{rate} of $S$ is defined as $\\log{|S|}/\\log(n!)$, the identity permutation is denoted by ${\\mbox{Id}}$, and $\\circ$ denotes the concatenation of sequences.\n\nThis paper is organized as follows. Additional motivation for studying storage of permutations is given in Subsection~\\ref{section:motivation}. Section~\\ref{section:previousWork} summarizes related previous work. Section~\\ref{section:bounds} discusses upper and (existential) lower bounds on the maximal possible size of subsets of $S_n$ which present locality. Section~\\ref{section:highRate} provides several simple constructions, some of which attain the upper bound presented in Section~\\ref{section:bounds}. A construction which shows a connection to Reed-Solomon codes via permutation polynomials, and a construction via multi-permutations are also given in Section~\\ref{section:highRate}. Section~\\ref{section:lowRate} contains two subsections which present sets of permutations of particular interest and \\textit{low} rate, which have low locality. The set from Subsection~\\ref{section:Linf} will be later shown to have a more efficient representation (Subsection~\\ref{section:LinfAlternative}). The coding approach is discussed in Section~\\ref{section:efficient}, in which the main result is a technique which allows to compute every \\textit{power} of the stored permutation very efficiently, and is strongly based on~\\cite{MunroSuccinct}. Subsection~\\ref{section:beating} shows a preliminary proof of concept that permutations may be stored using less redundancy bits than ordinary strings, and shows a concrete technique of doing so, attaining a negligible advantage. Concluding remarks and problems for future research are given in Section~\\ref{section:discussion}.\n\n\n\n\n\n\n\\normalsize\n\n\\subsection{Motivation}\\label{section:motivation}\nThis subsection presents a general motivation for distributed storage of permutations through common file updates, and through applications in cryptography. We begin by showing that in a certain simple scenario, permuting the coordinates of the stored file without decoding is impossible.\n\nAssume that a file $x$, which contains $n$ entries, is divided into two halves $x_1,x_2$ and stored in three nodes using the simplest parity check code $x_1,x_2,x_1+x_2$. In addition, assume the user would like to apply $\\pi\\in S_{n/2}$ on $x_1$. Applying $\\pi$ only over the systematic part, that is, update the system to contain $\\pi(x_1),x_2,x_1+x_2$, clearly does not maintain the error correction capability. On the other hand, updating the parity node to contain $\\pi(x_1)+x_2$ without knowing either $x_1$ or $x_2$ is information theoretically impossible, as illustrated in the following lemma.\n\n\\begin{lemma}\\label{lemma:ITbound}\n\tIf $x_1$ and $x_2$ are strings of length $n/2$ over a field ${\\mathbb{F}}_q$, then given a nontrivial $\\pi\\in S_{n/2}$ and $x_1+x_2$, it is information theoretically impossible to compute $\\pi(x_1)+x_2$.\n\\end{lemma}\n\n\\begin{proof}\n\tIt is widely known that given $x_1+x_2$, one cannot infer any information on either of the entries of $x_1$ and $x_2$. We show that if $\\pi(x_1)+x_2$ may be computed, then some information about certain symbols of $x_1$ can be inferred.\n\t\n\tKnowing $x_1+x_2$ and $\\pi(x_1)+x_2$, we may calculate $\\alpha\\triangleq\\pi(x_1)+x_2-(x_1+x_2)=\\pi(x_1)-x_1$. Furthermore, since $\\pi\\in S_{n/2}$ is nontrivial, we may arbitrarily choose one cycle $(i_1,i_2,\\ldots,i_t)$ from the disjoint cycle representation of $\\pi$, for some $t>1$. Hence, we may assemble the following linear system of equations, in the variables $x_1^{i_1},x_1^{i_2},\\ldots,x_1^{i_t}$.\n\t\\begin{eqnarray}\n\t\\begin{pmatrix}\\label{equation:ITbound}\n\t-1 & ~ & ~ & ~ & 1 \\\\\n\t1 & -1 & ~ & ~ & 0 \\\\\n\t0 & 1 & -1 & ~ & 0 \\\\\n\t~ & ~ & \\ddots & \\ddots & \\vdots \\\\\n\t0 & ~ & ~ & 1 & -1 \n\t\\end{pmatrix}\\cdot\n\t\\begin{pmatrix}\n\tx_1^{i_1}\\\\\n\tx_1^{i_2}\\\\\n\t\\vdots\\\\\n\tx_1^{i_t}\n\t\\end{pmatrix}=\n\t\\begin{pmatrix}\n\t\\alpha_{i_1}\\\\\n\t\\alpha_{i_2}\\\\\n\t\\vdots\\\\\n\t\\alpha_{i_t}\n\t\\end{pmatrix}\n\t\\end{eqnarray}\n\tSince the matrix in~\\eqref{equation:ITbound} has rank $t-1>0$, and since the system \\textit{has} a solution, we have that the affine space of solutions of this system is of dimension 1. Therefore, the sequence $x_1^{i_1},\\ldots,x_1^{i_t}$ may have one of possible $q$ values, rather than $q^t$ values. Since $t>1$, the claim follows.\n\t\n\t\n\t\n\t\n\t\n\t\n\\end{proof}\n\nFurthermore, two very common updates may be modeled as a special case of permutation updates. One is the well-known \\textit{cut-paste} operation, in which a portion of data is removed and placed elsewhere in the file. The other one is the \\textit{replacement} operation, in which two distinct portions of equal size switch places. The following lemmas present the structure and number of the permutations of these two operations.\n\n\\begin{lemma}\\label{lemma:cutPastePermutation}\nA cut-paste update is a permutation update whose corresponding permutation is a cyclic shift. In particular, if a portion of $\\alpha$ consecutive symbols, beginning at position $s$ in the file, is being moved to position $t$, the corresponding permutation is a cycle of length $t-s+1$, which performs a cyclic shift of $\\alpha$ spots to the elements between positions $s$ and $t$.\n\\end{lemma}\n\nIt should be noted that for $\\alpha=1$ and $s\\ne t$, Lemma~\\ref{lemma:cutPastePermutation} describes a set of permutations called \\textit{translocations}. Translocations are the building blocks of the Ulam metric~\\cite[Proposition~3]{Ulam1}, which is an essential tool for error-correction in flash memories~\\cite{Ulam1} and DNA research~\\cite{DezaSurvey}.\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{lemma}\\label{lemma:replacementPermutation}\nA replacement update is a permutation update whose corresponding permutation is a product of disjoint transpositions. \n\\end{lemma}\n\nTranspositions can be seen as the building blocks of the transposition metric, considered in~\\cite{Konstantinova}. The number of cut-paste and replacement operations is rather small, as shown in the following lemma, which is easy to prove.\n\n\n\\begin{lemma}\\label{lemma:replacementCounting}\nThe number of replacement updates on a file of $n$ elements is $O(n^3)$, and the number of cut-paste operations on a file of $n$ elements is $O(n^3)$.\n\\end{lemma}\n\n\n\n\n\n\n\nClearly, storing one of $O(n^3)$ possible values requires $O(\\log n)$ bits. Therefore, providing an efficient answer to Q1 and Q2 becomes trivial, since obtaining \\textit{all} information about one of these permutations is possible by reading $O(\\log n)$ bits. Thus, these specific permutations, however common, will not be discussed further in this paper. For other types of permutations which may arise in daily scenarios, see Section~\\ref{section:lowRate}.\n\nSimilar questions were studied from a cryptographic perspective. The works of~\\cite{Incremental1,Incremental2} initiated the research of cryptographic primitives, such as hash functions or signature schemes, that enable efficient updates. That is, small changes in the file may be incorporated into its hash (or signature) efficiently, without requiring to recompute it from scratch. The updates considered in~\\cite{Incremental1,Incremental2} are of different nature (replacement rather than permutations), and the file is not stored in a distributed manner, yet the underlying motivation is highly similar, that is, how to perform efficient updates to a stored file, without the need to encode it anew. \n\nOur work may be used in conjunction with any existing (distributed) cryptosystem, which was not necessarily meant for updates, while enabling permutation updates to be done efficiently. Furthermore, in coding-based cryptosystems (such as the McEliece cryptosystem~\\cite{McEliese}) any update of the un-encrypted file is inefficient. This is since any change of a symbol in the un-encrypted file requires changing at least as many symbols of its encrypted counterpart as the minimum distance of the underlying code.\n\n\n\n\\section{Previous Work}\\label{section:previousWork}\nCoding over $S_n$, endowed with either of several possible metrics~\\cite{DezaSurvey}, was extensively studied under many different motivations. For example, codes in $S_n$ under the Kendall's~$\\tau$ metric~\\cite{Barg} and the infinity metric~\\cite{LimitedMagnitude} were shown to be useful for non-volatile memories, and  codes under the Hamming metric (also known as permutation arrays) were shown to be useful for power-line communication~\\cite{powerline}. In all of these works, the permutations are encodings of messages, and hence should maintain minimum distance constraints. In this work, however, the permutation itself is of interest, and thus minimum distance is not considered. In addition, when taking the coding approach, the added redundancy need not to comply with any combinatorial constraints, e.g., to result in a permutation of a larger base set.\n\nAs mentioned in the Introduction, we consider permutations in their one line representation (one-liner, in short). Our problem may be seen as allowing local \\textit{erasure} correction of permutations in the one-liner. Erasure and deletion correction of permutation codes was discussed in~\\cite{erasures}. In this work it was shown that the most suitable metric for erasure correction (called ``stable erasure'' in~\\cite{erasures}) is the Hamming metric, that measures the number of entries in which the one-liners differ. However, the work of~\\cite{erasures} was motivated by the rank modulation scheme in flash memories and thus locality was not discussed. \n\nFurthermore, it is obvious that a permutation array with minimum Hamming distance $n-d+1$ allows local erasure correction of any symbol from any $d$ other symbols. However, constructing permutation arrays with minimum Hamming distance is an infamously hard problem, let alone in the high distance region~\\cite{PermutationsHamming}. Moreover, construction of permutation arrays with minimum Hamming distance is \\textit{not} equivalent to finding sets of permutations with locality, since the inverse is clearly untrue, that is, a set with locality $d$ does not imply a permutation array with minimum Hamming distance $n-d+1$.\n\nA similar motivation lies behind the work of~\\cite{Synchronizing}, where the authors considered updates of a distributed storage system which involve \\textit{deletions} and \\textit{insertions} to a file which is stored in a distributed system. Clearly, a permutation update can be seen as a series of deletions and insertions. The so-called ``scheme P''~\\cite[Section 4.2]{Synchronizing} provides a framework for maintaining a file $x\\in{\\mathbb{F}}_q^n$  in a distributed storage system under insertions and deletions. The entire file is assumed to be stored using an arbitrary array-code, and the deletions and insertions are taking place with respect to any specific block. Interestingly, a deletion is treated as a permutation, where the deleted symbol is replaced with the symbol 0 and pushed to the end of the block. A set of permutation matrices $\\{A^{(i)}\\}$, one for each block, is stored in the system to keep track of the permuted symbols. An insertion is treated similarly, keeping track of the location of insertion using the permutation matrices. The overhead of storing the matrices $\\{A^{(i)}\\}_{i\\in[n]}$ is improved by using the fact that the entire matrices need not to be stored, and we may settle for the \\textit{locations} of the edits. Our work may be seen as an extension of scheme P from~\\cite{Synchronizing} to \\textit{permutation} updates, as we handle various types of larger sets of permutations. \n\n\n\n\nRecall that we are interested in supporting the queries Q1 or Q2. A similar problem, which relates to general strings rather than to permutations, was addressed in the past as a problem about data structures. A representation technique called ``the succincter'', which enables one-symbol recovery\\footnote{One-symbol recovery is the term used in~\\cite{Succincter} for returning a given entry of the stored string, without requiring to decode it.}, was discussed in~\\cite{Succincter}. This representation requires only slightly more bits than the optimal one, but it seems to be superfluous when discussing large alphabets. Formally, according to~\\cite[Theorem~1]{Succincter}, for any $t$, a file $x$ of length $n$ over an alphabet $\\Sigma$ can be represented by $O(|\\Sigma|\\log n)+f(n,x,t)$ for some function $f$, while allowing one-symbol recovery in $O(t)$ time. In our scenario we have that $\\Sigma=[n]$, and optimal one-symbol recovery is trivially possible by using an $n\\log n$ bit representation.\n\n\nWhen considering the coding approach, a standard technique may be the use of \\textit{Locally Recoverable Codes} (LRCs). An $(m,k,d)$ LRC is a code that produces an $m$-symbol codeword from a $k$-symbol message, such that any symbol of the produced codeword may be recovered by contacting at most $d$ other symbols. LRCs have been subject to extensive research in recent years~\\cite{family}, mainly due to their application in distributed storage systems. Consider any permutation $\\pi\\in S_n$ as a string over the alphabet\\footnote{More precisely, the alphabet $[n]$ when seen as a subset of a large enough finite field ${\\mathbb{F}}_q$, over whom the construction of the LRC is possible.} $[n]$, and encode it to $m$ symbols using an optimal \\textit{systematic} LRC (e.g.,~\\cite{family}). Singleton-optimal LRCs that encode $n=k$ symbols to $m$ symbols and admit locality of $d$ must satisfy $q\\ge m$, and~\\cite[Theorem~2.1]{family}\n\\begin{eqnarray}\\label{equation:LRCRateBound}\n\\frac{n}{m}\\le \\frac{d}{d+1},\n\\end{eqnarray}\ni.e., their \\textit{rate} is bounded from above by $d/(d+1)$. Thus, $n/d$ redundant information symbols are required to achieve locality of $d$. Using the combinatorial approach (and some of the techniques in the coding approach, see Section~\\ref{section:LinfAlternative}) we achieve smaller storage overhead, in the price of not being able to store any permutation. Moreover, in Subsection~\\ref{section:lowerBound} it will be shown that there exists a \\textit{coset} of an optimal locally recoverable code~$C$, which contains a set $S$ of words that can be considered as permutations. However, this claim is merely existential, and does not provide any significant insights on the structure of $S$.\n\n\n\n\n\n\n\n\n\n\n\n\\section{Bounds}\\label{section:bounds}\nLet $A(n,d)$ be the maximum size of a subset of $S_n$ with locality $d$. This section presents an upper bound and an existential lower bound on $A(n,d)$. The upper bound in Subsection~\\ref{section:upper} is an adaptation of a bound for LRCs (\\cite[Theorem~2.1]{family}, given in~\\eqref{equation:LRCRateBound}). This upper bound is later improved for $d=1$, and is attained by a certain construction in Section~\\ref{section:concatenation} to follow. To obtain an existential lower bound, in Subsection~\\ref{section:lowerBound} it is shown that an optimal LRC has a coset which contains a set of permutations with the same locality as the LRC itself. For certain small values of locality, an equivalent lower bound will also be derived in Subsection~\\ref{section:lowerBound} by a connection to a classical problem in chess.\n\nNotice that in this section the combinatorial approach is considered. This clearly does not fully reflect the entire spectrum of techniques that might be used to store permutations. Nevertheless, it presents the limitation of a certain approach towards storage of permutations, which is the main one in this paper. \n\n\\subsection{Upper Bounds}\\label{section:upper}\nThe bound for LRCs~\\eqref{equation:LRCRateBound} can be used as-is if $n$ is a power of prime, and the set of permutations is considered as a non-linear code in ${\\mathbb{F}}_n^n$. By a simple adaptation of~\\cite[Theorem~2.1]{family} to non-linear codes, we have that a non-linear code in ${\\mathbb{F}}_n^n$ with locality $d$ contains at most $n^{\\floor*{dn/(d+1)}}$ codewords. This bound may be improved by utilizing the combinatorial structure of permutations.\n\nThe following bound, as the one given in~\\eqref{equation:LRCRateBound}, assumes a \\textit{non-adaptive} decoder. That is, it is assumed that for a given erased entry $i$, the decoder accesses a set $I_i$ of $d$ entries, and receives all their content at once. A different approach, which is partially implemented in Section~\\ref{section:MinMax}, is to access the non-erased symbols in an adaptive manner, where the locations of the latter ones depend on the content of the former ones. The following lemma, due to~\\cite{family}, is a variant of a classic result by~\\cite{Alon}.\n\n\\begin{lemma}\\label{lemma:Alon}\n\\cite[Theorem A.1]{family} If $G$ is a directed graph on $n$ vertices then there exists an induced directed acyclic subgraph of $G$ on at least \n\\begin{eqnarray*}\n\\frac{n}{1+\\frac{1}{n}\\sum_i d_i^{out}}\n\\end{eqnarray*}\nvertices, where $d_i^{out}$ is the outgoing degree of vertex $i$.\n\\end{lemma}\n\nThis lemma provides the following adaptation of~\\cite[Theorem 2.1]{family} to permutations.\n\n\\begin{theorem}\\label{theorem:bound}\n$A(n,d)\\le \\frac{n!}{\\ceil*{\\frac{n}{d+1}}!}$.\n\\end{theorem}\n\n\\begin{proof}\nLet $C\\subseteq S_n$ be a set of permutations with locality $d$, and let $G$ be a directed graph whose vertex set is $[n]$, and $(i,j)$ is an edge if entry $j$ in $\\pi\\in C$ is required for the local correction of entry $i$. Notice that since $C$ has locality $d$, Lemma~\\ref{lemma:Alon} implies that $G$ has an induced directed acyclic subgraph on a set $U$ of at least $\\ceil*{\\frac{n}{d+1}}$ vertices. Since this subgraph is acyclic, it contains a vertex $i$ with no outgoing edges. Hence, entry $i$ is a function of entries in $[n]\\setminus U$. Repeating this argument for the induced graph on $U\\setminus\\{i\\}$, we have that there exists a vertex $i'$ with no outgoing edges to $U\\setminus\\{i\\}$. Hence, entry $i'$ is a function of entries in $[n]\\setminus(U\\setminus\\{i\\})$. Since entry $i$ is a function of entries in $[n]\\setminus U$, we have that $i'$ is also a function of entries in $[n]\\setminus U$. Iterating over all vertices in $U$, we have that there are at least $\\ceil*{\\frac{n}{d+1}}$ entries that depend on the other $\\floor*{\\frac{dn}{d+1}}$ entries.\n\nTherefore, there exists a set of at most $\\floor*{\\frac{dn}{d+1}}$ entries, which determines the entire permutation. There are ${ n \\choose \\floor*{\\frac{dn}{d+1}}}$ different ways to choose the elements in these entries, and $\\floor*{\\frac{dn}{d+1}}!$ ways to permute them. Therefore, the size of $C$ is at most\n\\begin{eqnarray*}\n{ n \\choose \\floor*{\\frac{dn}{d+1}}}\\cdot \\floor*{\\frac{dn}{d+1}}!&=&\\frac{n!}{\\floor*{\\frac{dn}{d+1}}!\\cdot\\left(n-\\floor*{\\frac{dn}{d+1}}\\right)!}\\cdot\\floor*{\\frac{dn}{d+1}}!\\\\\n&=&\\frac{n!}{\\left(n-\\floor*{\\frac{dn}{d+1}}\\right)!}=\\frac{n!}{\\ceil*{\\frac{n}{d+1}}!}\n\\end{eqnarray*}\n\\end{proof}\n\nAs a simple corollary of Theorem~\\ref{theorem:bound} we obtain an upper bound on the rate of a set of permutations with locality $d$. Notice that by the Stirling approximation of the factorial function, we have that $\\log(n!)\\approx n\\log n$, and hence the optimal rate implied by Theorem~\\ref{theorem:bound} is\n\\begin{eqnarray}\\label{equation:lowerBoundRate}\n\\nonumber\t\\frac{\\log \\left(\\frac{n!}{\\ceil*{\\frac{n}{d+1}}!}\\right)}{\\log(n!)}&=&1-\\frac{\\log \\left(\\ceil*{\\frac{n}{d+1}}!\\right)}{\\log(n!)}\\\\\n&\\overset{n\\to\\infty}{\\longrightarrow}&1-\\frac{\\frac{n}{d+1}\\cdot\\log\\left(\\frac{n}{d+1}\\right)}{n\\log n}\\\\\n\\nonumber\n&=&\\frac{d}{d+1}+\\frac{\\log(d+1)}{n\\log n(d+1)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{d}{d+1}.\n\\end{eqnarray}\n\nThe trivial subset $C=S_n$ admits locality of $d=n-1$, and attains the upper bound. In addition, the \\textit{alternating group}, and its complement, have locality of $n-2$ (see Subsection~\\ref{section:alternating}). According to these examples, it is clear that $A(n,n-1)=n!$ and $A(n,n-2)=n!/2$, and hence, any upper bound will coincide with the one given in Theorem~\\ref{theorem:bound} for $d\\in\\{n-1,n-2\\}$. \n\nFor $d<n-2$ there exists a large gap between this bound and the sizes of the sets presented in this paper. This gap may be resolved for $d=1$ by using a graph theoretic argument on the dependency graph in the proof of Theorem~\\ref{theorem:bound}. In what follows, we say that a directed graph $G$ is connected if removing the directions from the edges of $G$ yields an undirected connected graph $T$. If $T$ is not connected, then every connected component of $T$ is considered as a connected component of $G$.\n\n\\begin{lemma}\\label{lemma:graphCycle}\nIf $G$ is a directed graph of constant out-degree one, then any connected component of $G$ contains precisely one cycle.\n\\end{lemma}\n\n\\begin{proof}\nLet $G'$ be a connected component of $G$. If $G'$ contains no vertex with in-degree zero, then it is a cycle, and the claim is clear. Else, let $v_1$ be a node in $G'$ with in-degree zero. Since $G$ has constant degree one, it follows that there exists a unique path $v_1\\to\\ldots\\to v_t$, such that all vertices are distinct, and $t$ is maximal. Since $v_t$ has out-degree one, it follows that $G'$ contains a cycle.\n\nIf $G'$ contains no other nodes besides $v_1,\\ldots,v_t$, then it contains precisely one cycle, and the claim follows. If $G'$ contains no other node with in-degree zero, we have that $G'$ contains two connected components, a contradiction. Hence, let $v_{t+1}$ be another node in $G$ of in-degree zero. Similarly, $G$ also contains a path $v_{t+1}\\to\\ldots\\to v_s$ with distinct nodes and a maximal $s$ such that $s\\notin \\{v_1,\\ldots,v_t\\}$. The node $v_s$ has out-degree one, and hence must be connected to another node $u$ in $G'$. If $u\\in\\{v_{t+1},\\ldots,v_s\\}$, we have that $G'$ contains two connected components, a contradiction. Therefore, the path $v_{t+1},\\ldots,v_s$ is connected to one of the nodes $v_1,\\ldots,v_t$, and thus no additional cycle is possible. By iterating this argument until all vertices of $G'$ are traversed, we have that $G'$ contains precisely one cycle.\n\\end{proof}\n\nAs a result, we obtain the following bound on the maximal size of sets of permutations with locality one.\n\n\\begin{theorem}\\label{theorem:bound1}\n$A(n,1)\\le n!!\\triangleq\\prod_{i=0}^{\\ceil*{n/2}-1}(n-2i)$.\n\\end{theorem}\n\n\\begin{proof}\nLet $C\\subseteq S_n$ be a set with locality one, and let $G$ be a directed graph whose vertex set is the set of entries $[n]$, and $(i,j)$ is an edge if entry $j$ in $\\pi\\in C$ is required for the local correction of entry~$i$. Since $G$ has locality one, it follow that any vertex in $G$ has out-degree one. Furthermore, for any edge $(i,j)$, fixing value of $\\pi_j$ determines the value of $\\pi_i$. \n\nLet $G_1,\\ldots,G_t$ be the connected components of $G$. According to Lemma~\\ref{lemma:graphCycle}, each $G_i$ contains precisely one cycle. Clearly, fixing the value of any entry in such a cycle, determines the value of all other entries in its connected component. Hence, the entire permutation $\\pi\\in C$ is determined by fixing the value of $t$ of its entries, one entry in the unique cycle in each connected component. Since each connected component contains at least two nodes, we have that the maximum size of $C$ is \n\\begin{eqnarray*}\nn\\cdot(n-2)\\cdot(n-4)\\cdot\\ldots\\cdot\\left(n-2\\left(\\ceil*{\\frac{n}{2}}-1\\right)\\right)\n\\end{eqnarray*}\n\\end{proof}\n\nSince the set constructed in Section~\\ref{section:concatenation} below attains the bound of Theorem~\\ref{theorem:bound1} for $d=1$, we have that $A(n,1)=n!!$. Generalizing the techniques in the proof of Theorem~\\ref{theorem:bound1} to any locality seems to be related to extinction problems in cellular automata on graphs~\\cite{automata}, and might improve the bound given in Theorem~\\ref{theorem:bound} for many special cases.\n\n\\subsection{Lower Bound}\\label{section:lowerBound}\nOptimal LRC of length $n$ and locality $d$ may easily be constructed over ${\\mathbb{Z}}_n$, the set of integers modulo~$n$. This is done by adding $n/(d+1)$ ``parity checks'' to all disjoint sets of $d$ consecutive symbols in ${\\mathbb{Z}}_n^{n-n/(d+1)}$. The rate of this code attains the upper bound of $\\frac{n-n/(d+1)}{n}=\\frac{d}{d+1}$, given in~\\eqref{equation:LRCRateBound}, and since the code is linear, all its cosets have locality $d$ as well. Since $n!$ of the words in ${\\mathbb{Z}}_n^n$ are permutations, we obtain the following existential \\textit{lower} bound on $A(n,d)$.\n\n\\begin{theorem}\\label{theorem:lowerBound}\n$A(n,d)\\ge n!/n^{n/(d+1)}$.\n\\end{theorem}\n\n\\begin{proof}\nLet $C$ be an optimal linear LRC of length $n$ and locality $d$ over ${\\mathbb{Z}}_n$. Since $C$ is linear, it has $\\frac{n^n}{n^{dn/(d+1)}}=n^{n/(d+1)}$ cosets, and each of which has locality $d$ as well. Since $n!$ of the words in ${\\mathbb{Z}}_n^n$ are permutations, it follows by the pigeonhole principle that one of the cosets of $C$ contains a set of at least $n!/n^{n/(d+1)}$ permutations. \n\\end{proof}\n\nThe rate which is implied by Theorem~\\ref{theorem:lowerBound} asymptotically attains the rate of the upper bound from Theorem~\\ref{theorem:bound}, given in~\\eqref{equation:lowerBoundRate}, since\n\n\\begin{eqnarray*}\n\t\\frac{\\log \\left(\\frac{n!}{n^{\\frac{n}{d+1}}} \\right)}{\\log(n!)}=1-\\frac{\\frac{n}{d+1}\\cdot\\log n}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{d}{d+1}.\n\\end{eqnarray*}\n\nOn the other hand, Theorem~\\ref{theorem:lowerBound} provides a set with higher redundancy than the potential upper bound, where the redundancy of a set $S$ is defined as $\\log(n!)-\\log(|S|)$. Using the same techniques as in~\\eqref{equation:lowerBoundRate}, we have that the redundancy of the set from Theorem~\\ref{theorem:lowerBound} is\n\\begin{eqnarray*}\n\\log(n!) - \\log \\left(\\frac{n!}{n^{n/(d+1)}}\\right)\\approx \\frac{n}{d+1}\\log n,\n\\end{eqnarray*}\nwhere the potential redundancy implied by Theorem~\\ref{theorem:bound} is \n\n\\begin{eqnarray*}\n\\log (n!)-\\log\\left(\\frac{n!}{\\ceil{\\frac{n}{d+1}}}\\right)\\approx \\frac{n}{d+1} \\log \\frac{n}{d+1}.\n\\end{eqnarray*}\n\nTherefore, it may be possible to achieve sets with redundancy up to $n\\cdot\\frac{\\log (d+1)}{d+1}$ \\textit{smaller} than the one obtained in Theorem~\\ref{theorem:lowerBound}.\n\n\\begin{remark}\n\tThe proof of Theorem~\\ref{theorem:lowerBound} relies on a simple construction of $C$, an optimal LRC with low minimum Hamming distance. Similarly, it is possible to replace $C$ with an LRC of higher minimum Hamming distance (e.g.,~\\cite{family}) and obtain an existence proof for a set of permutations with locality \\emph{and} minimum Hamming distance. Since minimum distance constraints are not discussed in this paper, we choose the former approach for simplicity.\n\\end{remark}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}\n\t\n\t\\definecolor{ffffff}{rgb}{1.,1.,1.}\n\t\\definecolor{aqaqaq}{rgb}{0.6274509803921569,0.6274509803921569,0.6274509803921569}\n\t\\begin{tikzpicture}[line cap=round,scale=0.87,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]\n\t\\clip(2.,8.) rectangle (23.,14.);\n\t\\fill[line width=1.6pt,color=aqaqaq,fill=aqaqaq,fill opacity=0.5] (4.,13.) -- (5.,13.) -- (5.,12.) -- (4.,12.) -- cycle;\n\t\\fill[line width=1.6pt,color=aqaqaq,fill=aqaqaq,fill opacity=0.5] (8.,12.) -- (7.,12.) -- (7.,11.) -- (8.,11.) -- cycle;\n\t\\fill[line width=1.6pt,color=aqaqaq,fill=aqaqaq,fill opacity=0.5] (6.,11.) -- (6.,10.) -- (5.,10.) -- (5.,11.) -- cycle;\n\t\\fill[line width=1.6pt,color=aqaqaq,fill=aqaqaq,fill opacity=0.5] (3.,10.) -- (4.,10.) -- (4.,9.) -- (3.,9.) -- cycle;\n\t\\fill[line width=1.6pt,color=aqaqaq,fill=aqaqaq,fill opacity=0.5] (7.,8.) -- (7.,9.) -- (6.,9.) -- (6.,8.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (11.,13.) -- (12.,13.) -- (12.,12.) -- (11.,12.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (13.,13.) -- (14.,13.) -- (14.,12.) -- (13.,12.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (12.,12.) -- (13.,12.) -- (13.,11.) -- (12.,11.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (14.,12.) -- (15.,12.) -- (15.,11.) -- (14.,11.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (10.,12.) -- (11.,12.) -- (11.,11.) -- (10.,11.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (11.,11.) -- (12.,11.) -- (12.,10.) -- (11.,10.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (13.,11.) -- (14.,11.) -- (14.,10.) -- (13.,10.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (10.,10.) -- (11.,10.) -- (11.,9.) -- (10.,9.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (12.,10.) -- (13.,10.) -- (13.,9.) -- (12.,9.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (14.,10.) -- (15.,10.) -- (15.,9.) -- (14.,9.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (11.,9.) -- (12.,9.) -- (12.,8.) -- (11.,8.) -- cycle;\n\t\\fill[fill=black,fill opacity=1.0] (13.,9.) -- (14.,9.) -- (14.,8.) -- (13.,8.) -- cycle;\n\t\\draw (3.,13.)-- (8.,13.);\n\t\\draw (8.,13.)-- (8.,8.);\n\t\\draw (3.,13.)-- (3.,8.);\n\t\\draw (8.,8.)-- (3.,8.);\n\t\\draw (4.,13.)-- (4.,8.);\n\t\\draw (5.,13.)-- (5.,8.);\n\t\\draw (6.,13.)-- (6.,8.);\n\t\\draw (7.,13.)-- (7.,8.);\n\t\\draw (8.,12.)-- (3.,12.);\n\t\\draw (3.,11.)-- (8.,11.);\n\t\\draw (3.,10.)-- (8.,10.);\n\t\\draw (3.,9.)-- (8.,9.);\n\t\\draw (10.,13.)-- (15.,13.);\n\t\\draw (15.,13.)-- (15.,8.);\n\t\\draw (10.,13.)-- (10.,8.);\n\t\\draw (15.,8.)-- (10.,8.);\n\t\\draw (11.,13.)-- (11.,8.);\n\t\\draw (12.,13.)-- (12.,8.);\n\t\\draw (13.,13.)-- (13.,8.);\n\t\\draw (14.,13.)-- (14.,8.);\n\t\\draw (15.,12.)-- (10.,12.);\n\t\\draw (10.,11.)-- (15.,11.);\n\t\\draw (10.,10.)-- (15.,10.);\n\t\\draw (10.,9.)-- (15.,9.);\n\t\\draw (3.5,12.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (4.5,12.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (5.5,12.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (6.5,12.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (7.5,12.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (4.5,11.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (5.5,10.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (6.5,9.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (7.5,8.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (5.5,11.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (6.5,10.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (7.5,9.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (3.5,8.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (6.5,11.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (7.5,10.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (3.5,9.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (4.5,8.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (7.5,11.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (3.5,10.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (4.5,9.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (5.5,8.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (3.5,11.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (4.5,10.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (5.5,9.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (6.5,8.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw [line width=1.6pt,color=aqaqaq] (4.,13.)-- (5.,13.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (5.,13.)-- (5.,12.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (5.,12.)-- (4.,12.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (4.,12.)-- (4.,13.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (8.,12.)-- (7.,12.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (7.,12.)-- (7.,11.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (7.,11.)-- (8.,11.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (8.,11.)-- (8.,12.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (6.,11.)-- (6.,10.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (6.,10.)-- (5.,10.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (5.,10.)-- (5.,11.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (5.,11.)-- (6.,11.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (3.,10.)-- (4.,10.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (4.,10.)-- (4.,9.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (4.,9.)-- (3.,9.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (3.,9.)-- (3.,10.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (7.,8.)-- (7.,9.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (7.,9.)-- (6.,9.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (6.,9.)-- (6.,8.);\n\t\\draw [line width=1.6pt,color=aqaqaq] (6.,8.)-- (7.,8.);\n\t\\draw [color=ffffff](11.5,12.5) node[anchor=center] {$\\Huge \\queen$};\n\t\\draw [color=ffffff](14.5,11.5) node[anchor=center] {$\\Huge \\queen$};\n\t\\draw (12.5,10.5) node[anchor=center] {$\\Huge \\queen$};\n\t\\draw [color=ffffff](10.5,9.5) node[anchor=center] {$\\Huge \\queen$};\n\t\\draw [color=ffffff](13.5,8.5) node[anchor=center] {$\\Huge \\queen$};\n\t\\draw (11.,13.)-- (12.,13.);\n\t\\draw (12.,13.)-- (12.,12.);\n\t\\draw (12.,12.)-- (11.,12.);\n\t\\draw (11.,12.)-- (11.,13.);\n\t\\draw (13.,13.)-- (14.,13.);\n\t\\draw (14.,13.)-- (14.,12.);\n\t\\draw (14.,12.)-- (13.,12.);\n\t\\draw (13.,12.)-- (13.,13.);\n\t\\draw (12.,12.)-- (13.,12.);\n\t\\draw (13.,12.)-- (13.,11.);\n\t\\draw (13.,11.)-- (12.,11.);\n\t\\draw (12.,11.)-- (12.,12.);\n\t\\draw (14.,12.)-- (15.,12.);\n\t\\draw (15.,12.)-- (15.,11.);\n\t\\draw (15.,11.)-- (14.,11.);\n\t\\draw (14.,11.)-- (14.,12.);\n\t\\draw (10.,12.)-- (11.,12.);\n\t\\draw (11.,12.)-- (11.,11.);\n\t\\draw (11.,11.)-- (10.,11.);\n\t\\draw (10.,11.)-- (10.,12.);\n\t\\draw (11.,11.)-- (12.,11.);\n\t\\draw (12.,11.)-- (12.,10.);\n\t\\draw (12.,10.)-- (11.,10.);\n\t\\draw (11.,10.)-- (11.,11.);\n\t\\draw (13.,11.)-- (14.,11.);\n\t\\draw (14.,11.)-- (14.,10.);\n\t\\draw (14.,10.)-- (13.,10.);\n\t\\draw (13.,10.)-- (13.,11.);\n\t\\draw (10.,10.)-- (11.,10.);\n\t\\draw (11.,10.)-- (11.,9.);\n\t\\draw (11.,9.)-- (10.,9.);\n\t\\draw (10.,9.)-- (10.,10.);\n\t\\draw (12.,10.)-- (13.,10.);\n\t\\draw (13.,10.)-- (13.,9.);\n\t\\draw (13.,9.)-- (12.,9.);\n\t\\draw (12.,9.)-- (12.,10.);\n\t\\draw (14.,10.)-- (15.,10.);\n\t\\draw (15.,10.)-- (15.,9.);\n\t\\draw (15.,9.)-- (14.,9.);\n\t\\draw (14.,9.)-- (14.,10.);\n\t\\draw (11.,9.)-- (12.,9.);\n\t\\draw (12.,9.)-- (12.,8.);\n\t\\draw (12.,8.)-- (11.,8.);\n\t\\draw (11.,8.)-- (11.,9.);\n\t\\draw (13.,9.)-- (14.,9.);\n\t\\draw (14.,9.)-- (14.,8.);\n\t\\draw (14.,8.)-- (13.,8.);\n\t\\draw (13.,8.)-- (13.,9.);\n\t\\draw (3.5,13.5) node[anchor=center] {$0$};\n\t\\draw (4.5,13.5) node[anchor=center] {$1$};\n\t\\draw (5.5,13.5) node[anchor=center] {$2$};\n\t\\draw (6.5,13.5) node[anchor=center] {$3$};\n\t\\draw (7.5,13.5) node[anchor=center] {$4$};\n\t\\draw (2.5,12.5) node[anchor=center] {$0$};\n\t\\draw (2.5,11.5) node[anchor=center] {$1$};\n\t\\draw (2.5,10.5) node[anchor=center] {$2$};\n\t\\draw (2.5,9.5) node[anchor=center] {$3$};\n\t\\draw (2.5,8.5) node[anchor=center] {$4$};\n\t\\draw (17   ,12.5) node[anchor=center] {$\\Huge \\textbf {0}$};\n\t\\draw (18   ,12.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (19   ,12.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (20   ,12.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (21   ,12.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (17,10.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (19,10.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (18,10.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (20,10.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\draw (21,10.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw [line width=2.pt] (16.5,9.5)-- (21.5,9.5);\n\t\\draw (19,11.5) node[anchor=center] {$\\Huge\\textbf{+}$};\n\t\\draw (17,8.5) node[anchor=center] {$\\Huge\\textbf{3}$};\n\t\\draw (18,8.5) node[anchor=center] {$\\Huge\\textbf{0}$};\n\t\\draw (19,8.5) node[anchor=center] {$\\Huge\\textbf{2}$};\n\t\\draw (20,8.5) node[anchor=center] {$\\Huge\\textbf{4}$};\n\t\\draw (21,8.5) node[anchor=center] {$\\Huge\\textbf{1}$};\n\t\\end{tikzpicture}\\caption{The equivalence of a transversal in a cyclic Latin square, an arrangement of non attacking semi-queens in a torodial chessboard, and a permutation $\\sigma$ such that ${\\mbox{Id}}+\\sigma$ is a permutation.}\\label{figure:LatinChessSumperm}\n\\end{figure}\n\nFor certain small values of $d$, a similar lower bound can be derived from a well-studied problem in combinatorics, which is described in the remainder of this subsection. A \\textit{Latin square} of order $n$ is a square $n\\times n$ matrix with entries in $\\{0,\\ldots,n-1\\}$, such that in each row and in each column, all entires are distinct. A \\textit{cyclic} Latin square is a Latin square such that entry $(i,j)$ equals $(i-j)\\bmod n$~\\cite{McKay}. A \\textit{transversal} in a Latin square is a set of positions such that no two share the same row, column, or value. A transversal in a cyclic Latin square is equivalent to the following chess problem. A \\textit{semi-queen} is a queen that cannot move on the north-east south-west diagonal. \nIn an $n\\times n$ \\textit{toroidal chessboard}, it is possible to move across the generalized diagonals $\\{(i,j)\\vert i-j\\equiv t\\bmod n\\}$ for all $t\\in\\{0,\\ldots,n-1\\}$, even if the positions are not connected in the ordinary chessboard.\nIt is readily verified that a transversal in a cyclic Latin square of order~$n$ corresponds to a configuration of $n$ non-attacking semi-queens in an $n\\times n$ toroidal chess board, which in turn corresponds to a permutation $\\sigma\\in S_n$ such that ${\\mbox{Id}}+\\sigma\\in S_n$, where the sum is taken $\\bmod~n$ (see Figure~\\ref{figure:LatinChessSumperm}).\n\nFor a permutation $\\pi\\in S_n$ let $P(\\pi)\\triangleq\\{\\sigma\\in S_n\\vert \\pi+\\sigma\\in S_n\\}$. For any two permutations $\\pi_1,\\pi_2\\in S_n$, by applying a proper permutation of entries we get a bijection between $P(\\pi_1)$ and $P(\\pi_2)$, and hence, $|P(\\pi_1)|=|P(\\pi_2)|$. Therefore, for any $\\pi\\in S_n$, the size of $P(\\pi)$ depends only on $n$, and is thus denoted by $t_n$. Estimating $t_n$ is a well-known problem which was resolved only recently~\\cite{additiveTriples}. However, given $\\pi\\in S_n$, constructing the set $P(\\pi)$ explicitly is still an open problem.\n\n\\begin{theorem}\\label{theorem:SumOfPermutations}\n\t\\cite[Theorem 1.2]{additiveTriples} If $n$ is an odd integer then $t_n=\\left(e^{-1/2}+o(1)\\right)n!^2/n^{n-1}$.\n\\end{theorem}\n\nAssume that there exists an efficient algorithm $A$ that on input $(p,i)$, where $p\\in S_n$ and $1\\le i\\le t_n$, outputs the $i$-th permutation $\\sigma\\in S_n$ such that $p+\\sigma\\in S_n$. The existence of $A$ provides an efficient algorithmic construction of an asymptotically optimal set of permutations with locality.\n\n\\begin{lemma}\\label{lemma:chess}\n\tFor an odd $n$, an integer $d=2^{o(\\log n)}$ such that $d+1|n$, and integers $i_1,\\ldots,i_{d-1}$ such that $1\\le i_j\\le t_n$ for all $j\\in[d-1]$, let\n\t\\begin{eqnarray*}\n\tp_1&\\in& S_{\\frac{n}{d+1}}\\\\\n\tp_2&\\triangleq&A(p_1,i_1)\\\\\n\tp_3&\\triangleq&A(p_1+p_2,i_2)\\\\\n\tp_4&\\triangleq&A(p_1+p_2+p_3,i_3)\\\\\n\t&\\ldots&\\\\\n\tp_d&\\triangleq&A\\left(\\sum_{j=1}^{d-1}p_j,i_{d-1}\\right)\\\\\n\tp_{d+1}&\\triangleq &\\sum_{j=1}^d p_j,\n\t\\end{eqnarray*}\n\tand define \n\t\\begin{eqnarray*}\n\t\\pi_{p_1,i_1,\\ldots,i_{d-1}}&\\triangleq &p_1\\circ\\left(p_2+\\overline{1}\\cdot \\frac{n}{d+1}\\right)\\circ\\left(p_3+\\overline{1}\\cdot \\frac{2n}{d+1}\\right)\\circ\\left(p_4+\\overline{1}\\cdot \\frac{3n}{d+1}\\right)\\circ\\ldots\\\\&~&\\phantom{p_1} \\circ\\left(p_d+\\overline{1}\\cdot\\frac{(d-1)n}{d+1}\\right)\\circ\\left(p_{d+1}+\\overline{1}\\cdot \\frac{dn}{d+1}\\right)\n\t\\end{eqnarray*}\n\twhere $\\overline{1}$ is the all 1's vector of length $\\frac{n}{d+1}$. The resulting set\n", "index": 1, "text": "\\[S\\triangleq \\{\\pi_{p_1,i_1,\\ldots,i_{d-1}}\\vert p_1\\in S_{n/(d+1)},~1\\le i_1,\\ldots,i_{d-1}\\le t_n\\}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"S\\triangleq\\{\\pi_{p_{1},i_{1},\\ldots,i_{d-1}}|p_{1}\\in S_{n/(d+1)},~{}1\\leq i_%&#10;{1},\\ldots,i_{d-1}\\leq t_{n}\\}\" display=\"block\"><mrow><mi>S</mi><mo>\u225c</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>\u03c0</mi><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>i</mi><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub><mo stretchy=\"false\">|</mo><mrow><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>\u2208</mo><msub><mi>S</mi><mrow><mi>n</mi><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msub></mrow><mo rspace=\"5.8pt\">,</mo><mrow><mrow><mn>1</mn><mo>\u2264</mo><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi></mrow></mrow><mo>,</mo><mrow><msub><mi>i</mi><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2264</mo><msub><mi>t</mi><mi>n</mi></msub></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04504.tex", "nexttext": "\n\t\n\t\n\tAccording to Theorem~\\ref{theorem:SumOfPermutations}, the size of $S$ is\n", "itemtype": "equation", "pos": 46798, "prevtext": "is a set of permutations in $S_n$ with locality $d$, and optimal asymptotic rate $\\frac{d}{d+1}$.\n\\end{lemma}\n\n\\begin{proof}\n\tSince for any $k,~2\\le k\\le d$, we have that $p_k=A(\\sum_{j=1}^{k-1}p_j,i_{k-1})$, it follows from the definition of $A$ that $p_i\\in S_{\\frac{n}{d+1}}$ for all $i\\in\\{1,\\ldots,d+1\\}$.\n\tTherefore, any $\\pi\\in S$ results from a concatenation of $d+1$ permutations on disjoint $\\frac{n}{d+1}$-subsets of $\\{0,\\ldots,n-1\\}$, and thus $S\\subseteq S_n$. Since $p_{d+1}=\\sum_{j=1}^d p_j$, it follows that any symbol of any $\\pi\\triangleq (\\pi_0,\\ldots,\\pi_{n-1})\\in S$ can be computed from $d$ other symbols, since for all $j\\in\\{0,\\ldots,\\frac{n}{d+1}-1\\}$ we have \n", "index": 3, "text": "\\[\\pi_{\\frac{dn}{d+1}+j}-\\frac{dn}{d+1}=\\sum_{i=1}^d\\left(\\pi_{\\frac{in}{d+1}+j}-\\frac{in}{d+1}\\right).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\pi_{\\frac{dn}{d+1}+j}-\\frac{dn}{d+1}=\\sum_{i=1}^{d}\\left(\\pi_{\\frac{in}{d+1}+%&#10;j}-\\frac{in}{d+1}\\right).\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03c0</mi><mrow><mfrac><mrow><mi>d</mi><mo>\u2062</mo><mi>n</mi></mrow><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mi>j</mi></mrow></msub><mo>-</mo><mfrac><mrow><mi>d</mi><mo>\u2062</mo><mi>n</mi></mrow><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></munderover><mrow><mo>(</mo><mrow><msub><mi>\u03c0</mi><mrow><mfrac><mrow><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mi>j</mi></mrow></msub><mo>-</mo><mfrac><mrow><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04504.tex", "nexttext": "Since $d=2^{o(\\log n)}$ we have that $\\frac{\\log d}{\\log n}\\overset{n\\to\\infty}{\\longrightarrow}0$, and thus the asymptotic rate of $S$ is\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log|S|}{\\log(n!)}&\\overset{n\\to\\infty}{\\longrightarrow}&\\frac{(2d-1) \\frac{n}{d+1}\\log\\frac{n}{d+1}-\\left(\\frac{n}{d+1}-1\\right)(d-1)\\log \\frac{n}{d+1}}{n\\log n}\\\\ &=&\\frac{\\frac{d}{d+1}\\cdot n+d-1}{n}\\cdot\\frac{\\log\\frac{n}{d+1}}{\\log n}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{d}{d+1}.\n\t\\end{eqnarray*}\n\\end{proof}\n\nA non-efficient implementation of $A$ may be obtained simply by traversing all permutations in~$S_n$. However, providing an efficient implementation of $A$ requires a rigorous understanding of the structure of the permutations in $P({\\mbox{Id}})$, which seems beyond the scope of contemporary knowledge. A subset of $P({\\mbox{Id}})$ of approximate size $\\sqrt{n}^{\\sqrt{n}}$ is given in~\\cite{Cooper}, but it is too small to provide a non-trivial construction. \n\n\t\\begin{remark}\nWe note that a converse claim may also be made. That is, given an optimal set of permutations with constant locality $d\\ge 2$, which is constructed according to the outline of Lemma~\\ref{lemma:chess}, one may explicitly construct the set $P(\\text{Id})$. Since an explicit construction of $P(Id)$ is not known, this may serve as a hardness result for the construction of a set of permutations with constant locality $d\\ge 2$. However, since the outline of the construction in Lemma~\\ref{lemma:chess} is highly restrictive, such a hardness result might not seem insightful enough.\n\t\\end{remark}\n\n\\section{High Rate Constructions}\\label{section:highRate}\nThis section presents several simple constructions of sets of permutations with locality, some of which attain the upper bound given in Section~\\ref{section:upper}. The well-known \\textit{alternating group} and its complement will be shown in Subsection~\\ref{section:alternating} to have locality of $n-2$, and attain the upper bound given in Theorem~\\ref{theorem:bound}. Another simple set of permutations, discussed in Section~\\ref{section:concatenation}, is those that may be seen as a concatenation of $n/h$ permutations in $S_h$, for some $h$ which divides $n$. The locality of the latter relies on the trivial observation that any single erasure in a permutation may be corrected without requiring additional redundancy. For $h=2$, this set attains the upper bound given in Theorem~\\ref{theorem:bound1}. Subsection~\\ref{section:rangeRestricted} shows a similar technique which achieves high locality. Subsection~\\ref{section:fromCodes} and Subsection~\\ref{section:multipermutations}\nenhance the construction of Subsection~\\ref{section:concatenation} by using Reed-Solomon codes over permutation polynomials, and by using multi-permutations. The results of this section are summarized in Table~\\ref{table:highRateSummary}, in which three locality regimes are considered for comparison.\n \t\n\\begin{table*}[ht]\n\t{\\centering\n\t\t\\begin{tabular}{|c|c|c|c|c|}\n\t\t\t\\hline\n\t\t\t\\multirow{2}{*}{Section} & \t\t\t\\multirow{2}{*}{Technique} & \t\t\t\\multirow{2}{*}{Locality} & Asymptotic & \t\t\t\\multirow{2}{*}{Comments} \\\\ \n\t\t\t~&~&~&Rate&~\\\\ \\hline\\hline\n\t\t\t\\ref{section:alternating} & The alternating group. & $n-2$ & $ 1$&Strictly optimal.\\\\ \\hline\n\t\t\t\\multirow{4}{*}{\\ref{section:concatenation}} & \\multirow{4}{*}{Concatenation.} & \\multirow{2}{*}{$d = O(1)$} & \\multirow{2}{*}{$\\frac{1}{d+1}$}&Strictly optimal for $d=1$. \\\\ ~&~&~&~&At least $n$ times smaller than~\\ref{section:fromCodes}.\\\\\\cline{3-5}\n\t\t\t~&~&$\\Theta(n^\\epsilon)$& $ \\epsilon$&-\\\\ \\cline{3-5}\n\t\t\t~&~&$\\Theta(n)$ & $ 1$ &-\\\\ \\hline\n\t\t\t\\ref{section:rangeRestricted} & Range-restriction. & $\\Theta(n)$ & $ 1$ &-\\\\ \\hline\n\t\t\t\\multirow{3}{*}{\\ref{section:fromCodes}} & \\multirow{3}{*}{Reed-Solomon codes.} & 6 & $ 1/2$ & $n=2^k$ for some $k$. \\\\ \\cline{3-5}\n\t\t\t~&~& 7 & $ 1/2$ & $n=\\pm 2\\mod 5$, and a prime power. \\\\ \\cline{3-5}\n\t\t\t~&~& 7 & $ 1/2$ & $n=5^k$ for some $k$.\\\\ \\hline\n\t\t\t\\multirow{3}{*}{\\ref{section:multipermutations}} & \\multirow{3}{*}{Multi-permutations} & $\\Theta(1)$ & 1/2 & Incomparable with~\\ref{section:fromCodes}.\\\\ \\cline{3-5}\n\t\t\t~&~& $\\Theta(n^\\epsilon)$ & $(1+\\epsilon)/2$ & Larger rate than~\\ref{section:concatenation} for same locality.\\\\ \\cline{3-5}\n\t\t\t~&~& $\\Theta(n)$ & $1$ & -\\\\ \\hline\n\t\t\\end{tabular}\n\t\t\\caption{Summary of the results in\\label{table:highRateSummary} Section~\\ref{section:highRate}.}\\label{table1}\n\t}\n\\end{table*}\n\n\\subsection{The Alternating Group}\\label{section:alternating}\nIt is widely known~\\cite{Bona} that any permutation may be represented as a product of transpositions (cycles of length two). Although many different products of transpositions may represent the same permutation, all representations of a given permutation either contain an even or an odd number of transpositions. For a permutations $\\pi\\in S_n$, if the number of transpositions in any representation is even, we say that $\\pi$ is even and its \\textit{sign} is 1. Otherwise it is odd, and its sign is -1. The set of all even permutations, which forms a subgroup of $S_n$ of size $n!/2$, is called \\textit{the alternating group} and denoted by $A_n$. In what follows we show that the sets $A_n$ and $S_n\\setminus A_n$ have locality of $n-2$. This fact will follow from the next simple lemma.\n\n\\begin{lemma}\\label{lemma:alternatingLocality}\nIf $\\pi$ and $\\sigma$ are two distinct permutations in $S_n$ whose one-liners agree on $n-2$ entries, then one of $\\{\\pi,\\sigma\\}$ is odd and the other is even.\n\\end{lemma}\n\n\\begin{proof}\nLet $\\{i_j\\}_{j\\in[n-2]}$ be the set of entries on whom $\\pi$ and $\\sigma$ agree, and let $\\{\\alpha_j\\}_{j\\in[n-2]}$ be the subset of $[n]$ such that for all $j\\in[n-2]$, $\\pi_{i_j}=\\sigma_{i_j}=\\alpha_j$. Clearly, $\\pi$ and $\\sigma$ differ only in the arrangement of the elements in $[n]\\setminus \\{\\alpha_j\\}_{j\\in[n-2]}$. Therefore, $\\pi$ may be obtained from $\\sigma$ by applying a single transposition which switches between the elements of $[n]\\setminus \\{\\alpha_j\\}_{j\\in[n-2]}$, and hence $\\pi$ and $\\sigma$ have opposite signs.\n\\end{proof}\n\n\\begin{corollary}\nThe sets $A_n$ and $S_n\\setminus A_n$ have locality of $n-2$.\n\\end{corollary}\n\\begin{proof}\nIf a symbol of the stored permutation $\\pi$ is missing, by observing any $n-2$ of the remaining symbols there exists exactly two possibilities for $\\pi$. According to Lemma~\\ref{lemma:alternatingLocality}, one of these options is an odd permutation and the other is even. Hence, restricting the system to store only permutations from either $A_n$ or $S_n\\setminus A_n$, we have only one possible permutation, and thus both $A_n$ or $S_n\\setminus A_n$ admit locality of $n-2$.\n\\end{proof}\n\nAlthough the results in this subsection are rather simple, they shed some light on the tightness of the bound given in Theorem~\\ref{theorem:bound}. Since $d=n-2$ we have that $n!/(\\ceil*{n/(d+1)}!)=n!/(\\ceil*{n/(n-1)}!=n!/2$, and thus $A_n$ and $S_n\\setminus A_n$ are optimal sets with locality $n-2$.\n\n\\subsection{Concatenation of Short Permutations}\\label{section:concatenation}\nObviously, in the one-line representation, any single symbol may easily be computed from all other symbols. This principle leads to simple sets of permutations which can be stored efficiently.\n\nConsider the set $S$ of permutations in $S_n$ which may be viewed as a concatenation of $n/h$ shorter permutations on $h$ elements, for some integer $h$ which divides $n$. That is, their one-liner may be viewed as a concatenation of $n/h$ one-liners, each of which is a permutation of either of the sets $\\{1,\\ldots,h\\},\\{h+1,\\ldots,2h\\},$ etc. Clearly, $S$ contains $(h!)^{n/h}\\cdot (n/h)!$ permutations. A subset of $S$, in which the $i$-th permutation is on the set $\\{(i-1)h+1,\\ldots,i\\cdot h\\}$, was considered in~\\cite[Corollary 19]{LimitedMagnitude}, where it was shown to be an optimal anticode under the infinity metric $d_\\infty$ (see Definition~\\ref{definition:dInf} in Section~\\ref{section:Linf} to follow).\n\n\n\n\\begin{lemma}\nIf $\\pi\\in S$ then any symbol $\\pi_i$ can be computed from $h-1$ other symbols, i.e., the set $S$ has locality $d=h-1$.\n\\end{lemma}\n\n\\begin{proof}\nSince $\\pi\\in S$ it follows that $\\{\\pi_{h\\cdot\\floor{i/h}+1},\\ldots,\\pi_i,\\ldots,\\pi_{(h+1)\\cdot\\floor{i/h}}\\}=\\{jh+1,\\ldots,(j+1)h\\}$. Hence, observing the value of $\\pi_{h\\cdot\\floor{i/h}+1},\\ldots,\\pi_{(h+1)\\cdot\\floor{i/h}}$ (excluding $\\pi_i$) the range $\\{jh+1,\\ldots,(j+1)h\\}$ can be identified, and $\\pi_i$ is the missing value in it.\n\\end{proof}\n\nNote that multiple erasures can be corrected simultaneously, as long as they do not reside in the same short permutation. Two erasures from the same short permutation cannot be corrected simultaneously. In addition, Q1 can be answered trivially, and Q2 requires finding the suitable sub-permutation in $n/h$ queries, and additional $h$ queries to locate the desired element.\n\nSince $d=h-1$, we have that $|S|=(d+1)!^{n/(d+1)}\\cdot (n/(d+1))!$, and for $d=1$ we have that \n\\begin{eqnarray*}\n|S|&=&2^{n/2}\\cdot (n/2)!=\\left(\\frac{n}{2}\\right)\\cdot 2\\cdot \\left(\\frac{n}{2}-1\\right)\\cdot 2 \\cdot \\ldots\\cdot (1)\\cdot 2\\\\\n&=&n\\cdot (n-2)\\cdot(n-4)\\cdot\\ldots\\cdot 2=n!!.\n\\end{eqnarray*}\n\nHence, for $d=1$ this construction attains the bound of Theorem~\\ref{theorem:bound1} with equality. However, for any $d=O(1)$, $d\\ge 2$, it can be shown that these sets \\textit{do not} attain the optimal rate, since they are superseded by the existential lower bound of Theorem~\\ref{theorem:lowerBound}.\n\n\\begin{lemma}\\label{lemma:concatentationNotOptimal}\n\tIf $h=O(1)$, the set $S$ (of locality $d=h-1$) have rate $\\frac{1}{d+1}$ as $n$ tends to infinity.\n\\end{lemma}\n\\begin{proof}\n\t\n\tBy the construction above, we have that\n\t\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log\\left((d+1)!^{\\frac{n}{d+1}}\\cdot\\left(\\frac{n}{d+1}\\right)!\\right)}{\\log(n!)}&=&\\frac{\\log\\left((d+1)!\\right)}{d+1}\\cdot \\frac{n}{\\log(n!)}+\\frac{\\log\\left((\\frac{n}{d+1})!\\right)}{\\log(n!)},\n\t\\end{eqnarray*}\n\tand since $d$ is constant, it follows that \n\t\\begin{eqnarray*}\n\t\t&\\overset{n\\to\\infty}{\\longrightarrow}&\\frac{\\log\\left((d+1)!\\right)}{\\log(n)\\cdot(d+1)}+\\frac{\\frac{n}{d+1}\\cdot\\log\\left(\\frac{n}{d+1}\\right)}{n\\log(n)}\\\\\n\t\t&=&\\frac{\\log\\left((d+1)!\\right)}{\\log(n)\\cdot(d+1)}+\\frac{1}{d+1}-\\frac{\\log(d+1)}{\\log(n)\\cdot(d+1)}\\\\&=&\\frac{\\log(d!)}{\\log(n)\\cdot(d+1)}+\\frac{1}{d+1}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{1}{d+1}.\n\t\\end{eqnarray*}\n\\end{proof}\n\nBy choosing $h=\\Theta(n^\\epsilon)$ for some constant $0<\\epsilon<1$, we achieve a non-vanishing rate.\n\\begin{lemma}\n\tIf $h=\\Theta(n^\\epsilon)$, the sets $S$ (of locality $d=h-1$) have rate $\\epsilon$ as $n$ tends to infinity.\n\\end{lemma}\n\\begin{proof}\n\t\t\\begin{eqnarray*}\n\t\t\t\\frac{\\log\\left((d+1)!^{\\frac{n}{d+1}}\\cdot\\left(\\frac{n}{d+1}\\right)!\\right)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{n(d+1)\\log(d+1)+n\\log(\\frac{n}{d+1})}{(d+1)n\\log n}\t\t\t\\overset{n\\to\\infty}{\\longrightarrow}\\epsilon\n\t\t\\end{eqnarray*}\n\\end{proof}\n\nIn the high locality regime, where $d=\\Theta(n)$, we may similarly prove that the rate of these codes approaches 1 as $n$ approaches infinity. \n\n\\begin{lemma}\\label{lemma:concatentationOptimal}\n\tIf $h=\\Theta(n)$, the sets $S$ (of locality $d=h-1$) have rate $1$ as $n$ tends to infinity.\n\\end{lemma}\n\n\n\n\n\n\n\n\n\\subsection{Concatenation of Range-Restricted Permutations}\\label{section:rangeRestricted}\nIn this subsection we provide a technique for producing sets of permutations with high locality $d\\ge n/2$. For a set of symbols $\\Sigma$ let $S(\\Sigma)$ denote the set of all permutations of $\\Sigma$, that is, the set of all injective functions from $[|\\Sigma|]$ to $\\Sigma$. In this subsection we use the alphabet $\\Sigma=\\{0,\\ldots,n-1\\}$, and hence $S(\\Sigma)=S_n$. Let $h$ be an integer which divides $n$, and for $i\\in\\{0,\\ldots,n/h-1\\}$ let\n\\begin{eqnarray*}\nS_i\\triangleq S(\\{ih,ih+1,\\ldots,(i+1)h-1\\})\\circ S([n]\\setminus\\{ih,ih+1,\\ldots,(i+1)h-1\\}).\n\\end{eqnarray*}\n\n\\begin{lemma}\nThe set $S^h\\triangleq \\cup_{i=0}^{n/h-1}S_i$ has locality $d=n-h-1$.\n\\end{lemma}\n\\begin{proof}\nTo repair a missing symbol $\\pi_j,0\\le j\\le n-1$ in $\\pi\\in S^h$, distinguish between the cases $j\\le h-1$ and $j\\ge h$. If $j\\le h-1$, $\\pi_j$ may clearly be computed from $\\{\\pi_i\\}_{i\\in\\{0,\\ldots,h-1\\}\\setminus\\{j\\}}$. If $j\\ge h$, the set of symbols $\\{\\pi_i\\}_{i\\in\\{h,\\ldots,n-1\\}\\setminus\\{j\\}}$ must contain a gap of $h$ consecutive numbers, which are located in the prefix of $\\pi$. After identifying this gap, the missing symbol $\\pi_j$ may easily be deduced.\n\\end{proof}\n\nThe set $S^h$ contains $\\frac{n}{h}\\cdot h!\\cdot (n-h)!=n\\cdot (h-1)!\\cdot(n-h)!$ and it does not attain the upper bound given in Theorem~\\ref{theorem:bound}. For constant $h$ the rate of $S^h$ asymptotically approaches 1 as $n$ goes to infinity, since\n\\begin{eqnarray*}\n\\frac{\\log(n\\cdot (h-1)!\\cdot(n-h)!)}{\\log(n!)}\\ge\\frac{\\log((n-h)!)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}1.\n\\end{eqnarray*}\n\nEqual rate may be obtained for lower locality, where $h=\\Theta(n)$; if $h=\\delta n$ for some constant $0<\\delta<1$, then\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log(n\\cdot (h-1)!\\cdot(n-h)!)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{\\delta n \\log (\\delta n)+(1-\\delta)n\\log((1-\\delta)n)}{n\\log n}=\\delta+(1-\\delta)=1.\n\t\\end{eqnarray*}\n\tAn identical rate is also obtained by choosing $h=\\Theta(n^\\epsilon)$. Hence, the best choice of parameters for this technique seems to be $h=\\Theta(n)$, since it results in low locality and optimal rate.\n\n\\subsection{Extended Construction from Error-Correcting Codes}\\label{section:fromCodes}\nThis section provides a recursive construction of a set of permutations in $S_n$ with locality, from two constituent ingredients. The first ingredient is a set of permutations $S\\subseteq S_{n-t}$ with locality $d$, for some given $t$ and $d$. The second ingredient is an error-correcting code $T$, in which all codewords consist of $t$ distinct symbols. \n\nA \\textit{symbol replacement function} $f$ is an injective function which maps one alphabet to another. Given a permutation $\\pi$ and a symbol replacement function $f$ let $f(\\pi)$ be the result of replacing the symbols of $\\pi$ according to $f$. For a set of permutations $S$ let $f(S)\\triangleq\\{f(\\pi)\\vert \\pi\\in S\\}$. The construction of this section relies on the following observation.\n\n\\begin{observation}\\label{observation:replacement}\nIf $S\\subseteq S_{n-t}$ is a set of permutations with locality $d$ and $f$ is a symbol replacement function, then $f(S)$ is a set of permutations with locality $d$ as well.\n\\end{observation}\n\nUsing a proper symbol replacement function $f$, a permutation $f(\\pi)$ for $\\pi\\in S$ is concatenated to a codeword from $T$ to create a permutation in $S_n$. This symbol replacement  function is given in the following definition, which is followed by an example.\n\n\\begin{definition}\\label{definition:replacement}\nFor any integers $1<t<n$, let $\\pi$ be a permutation in $S_{n-t}$ and $e\\in[n]^t$ be a word with $t$ distinct symbols $\\{\\sigma_1,\\ldots,\\sigma_t\\}\\triangleq E\\subseteq[n]$. Let $f_E$ be the following symbol replacement function \n\\begin{eqnarray*}\n f_E:[n-t]&\\to&\\left([n-t]\\setminus E\\right)\\cup\\{n-t+1,\\ldots,n-t+|E\\cap [n-t]\\}\\\\\nf_E(i)&=&\n\n\n\n\n\\begin{cases}\ni, & i\\notin E.\\\\%\\cap [n-d].\\\\\n~\\\\\n\\shortstack{j,\\\\~\\\\~} & \\shortstack{\\mbox{For some integer $s$, $i$ and $j$ are the $s$-smallest numbers }\\\\ \\mbox{in $E\\cap[n-t]$ and $\\{n-t+1,\\ldots,n\\}\\setminus E$, respectively.}}\n\\end{cases}\n\\end{eqnarray*}\nThat is, $f_E$ maps each element which does not appear in $E$ to itself, and each element which appears in~$E$ is mapped to a symbol in $\\{n-t+1,\\ldots,n\\}$ which does not appear in $E$, in an increasing manner. Using $f_E$, define the operator $\\odot$ as\n\\begin{eqnarray*}\n\\pi\\odot e\\triangleq f_E(\\pi)\\circ e,\n\\end{eqnarray*}\nwhere $\\circ$ denotes the ordinary concatenation of strings.\n\\end{definition}\nSince symbols in $\\pi$ which occur in both $\\pi$ and $e$ are replaced with symbols that do not appear in either $\\pi$ nor $e$, we have that $\\pi\\odot e$ is a permutation in $S_n$, as illustrated by the following example.\n\\begin{example}\nFor $n=7$ and $t=3$, let $\\pi=(1,2,3,4)$, $e = (3,4,7)$, and $E = \\{3,4,7\\}$. By Definition~\\ref{definition:replacement} we have that\n\\begin{eqnarray*}\nf_E(1)=1,~f_E(2)=2,~f_E(3)=5,~f_E(4)=6,~\\mbox{and~}\n\\pi\\odot e = f_E(\\pi)\\circ e=(1,2,5,6,3,4,7)\\in S_7.\n\\end{eqnarray*}\n\\end{example}\n\nThe operation $\\odot$ is used to extend an existing set $S\\subseteq S_{n-t}$ with locality to a subset of $S_n$ with a larger locality by using an error-correcting MDS code $T$. \n\n\\begin{lemma}\\label{lemma:replacementConcatenation}\nFor integers $1<t< n$, if $S\\subseteq S_{n-t}$ is a set with locality $d$ and $T$ is an MDS code in $[n]^t$ with minimum distance $\\delta$ and distinct symbols, then $S\\odot T\\triangleq\\{s\\odot e\\vert s\\in S,~e\\in T\\}\\subseteq S_n$ is a set of permutations with locality $d+t-\\delta+1$. \n\\end{lemma}\n\\begin{proof}\nLet $\\pi=s\\odot e$ be a permutation in $S\\odot T$. To repair a missing symbol $\\pi_j$ for $1\\le j\\le n$ we distinguish between the cases $j\\le n-t$ and $j>n-t$. If $j>n-t$, by the minimum distance property of the MDS code $T$ we may obtain $\\pi_j$ by accessing $t-\\delta+1$ symbols from $e$. If $j\\le n-t$, then by accessing $t-\\delta+1$ symbols from $e$ we may identify the function $f_E$ used to define the operator $\\odot$ (Definition~\\ref{definition:replacement}). Once $f_E$ is known, the symbol $\\pi_j$ may be obtained by using Observation~\\ref{observation:replacement}.\n\\end{proof}\n\nThis technique can be used to obtain explicit sets with constant locality $d\\ge 2$, which are the largest ones in this paper for this locality. Unfortunately, to the best of our knowledge the asymptotic rate of these sets does not exceed $\\frac{1}{2}$, and hence they are not optimal. Moreover, since a set with locality $1$ also has locality $d\\ge 2$ for any $d$, the sets of locality 1 from Subsection~\\ref{section:concatenation} can be used for any locality greater than 1, while obtaining rate of $\\frac{1}{2}$ as well. Nevertheless, for small values of $d$ we are able to construct explicit sets with locality $d$ which contain more permutations than the sets with locality 1 from Subsection~\\ref{section:concatenation}. \n\nTo provide good examples by this technique, we must construct error-correcting codes in which all codewords consist of distinct symbols. For this purpose, assume that $n$ is a power of prime, and $\\{0,1,\\ldots,n-1\\}$ are representations of the elements of ${\\mathbb{F}}_n$.\n\nRecall that a \\textit{Reed-Solomon} code is given by evaluations of degree restricted polynomials on a fixed set of distinct elements from a large enough finite field. These codes contain sub-codes which are suitable for our purpose. The codewords in these sub-codes are obtained by evaluations of \\textit{permutation polynomials}. A permutation polynomial is a polynomial which represents an injective function from ${\\mathbb{F}}_n$ to itself. In spite of the very limited knowledge on permutation polynomials in general, all permutation polynomials of degree at most 5 are known (see~\\cite[Table 2]{powerline}). For example, we have the following lemma.\n\n\\begin{lemma}\\label{lemma:permutationPolynomials}\\cite[Table~2]{powerline} \n\t\n\t\\begin{enumerate}\n\t\t\\item If $n$ is a power of 2, then there exist at least  $(n-1)(2n+\\frac{n(n^2+2)}{3})$ permutation polynomials of degree at most 4 over ${\\mathbb{F}}_n$.\n\t\t\\item If $n$ is a prime power and $n\\equiv\\pm 2~(\\bmod 5)$, then there exist at least $n^3(n-1)$ permutation polynomials of degree at most 5 over ${\\mathbb{F}}_n$.\n\t\t\\item If $n$ is a prime power and $n\\equiv 0~(\\bmod 5)$, then there exist at least $\\frac{1}{2}n^2(n-1)^2$ permutation polynomials of degree at most 5 over ${\\mathbb{F}}_n$.\n\t\\end{enumerate}\n\\end{lemma}\n\nAs a corollary, we obtain the following constructions.\n\n\\begin{example}\\label{example:locality5} ~\n\t\n\t\\begin{enumerate}\n\t\t\\item Let $n$ be an integer power of 2, and let $S\\subseteq S_{n-6}$ be an optimal set with locality 1 (which exists by Subsection~\\ref{section:concatenation}, since $n-6$ is even). Let $T$ be a subset of a Reed-Solomon code of dimension $5$ and length $6$ over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 4. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 1), the set $B_1\\triangleq S\\odot T$ contains $(n-6)!!\\cdot (n-1)(2n+\\frac{n(n^2+2)}{3})$ permutations, and has locality 6.\n\t\t\\item Let $n$ be a odd prime power and $n\\equiv\\pm 2~(\\bmod 5)$ (such as $7,17,23,\\ldots$ etc.), and let $S\\subseteq S_{n-7}$ be an optimal set with locality 1, as above. Let $T$ be a subset of a Reed-Solomon code of dimension~6 and length 7 over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 5. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 2), the set $B_2\\triangleq S\\odot T$ contains $(n-7)!!\\cdot n^3(n-1)$ permutations, and has locality 7.\n\t\t\\item Let $n$ be a prime power and $n\\equiv0~(\\bmod 5)$ (i.e., n is a power of 5), and let $S\\subseteq S_{n-7}$ be an optimal set with locality 1, as above. Let $T$ be a subset of a Reed-Solomon code of dimension~6 and length 7 over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 5. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 3), the set $B_3\\triangleq S\\odot T$ contains $(n-7)!!\\cdot \\frac{1}{2}n^2(n-1)^2$ permutations, and has locality 7.\n\t\\end{enumerate}\n\n\\end{example}\n\nNotice that an optimal set $A\\subseteq S_n$ with locality 1, which may be seen as having any larger locality, contains $n!!$ permutations (see Section~\\ref{section:concatenation}). The set $B_1$ is larger, since $n!!=(n-6)!!\\cdot \\Theta(n^3)$ and $|B_1|=(n-6)!!\\cdot \\Theta(n^4)$. Similarly, for odd values of $n$, Section~\\ref{section:concatenation} provides a set $A$ of size $(n-1)!!$ and locality 1. The sets $B_2$ and $B_3$ are larger, since $|A|=(n-1)!!=(n-7)!!\\cdot \\Theta(n^3)$, where both $|B_2|$ and $|B_3|$ equal $(n-7)!!\\cdot \\Theta(n^4)$. Hence, the construction of this section provides sets which are at least $n$ times larger than those given in Section~\\ref{section:concatenation}, and have larger constant locality.\n\n\\subsection{High-Locality Construction From Multi-Permutations}\\label{section:multipermutations}\n\nWhile constructing sets of permutations with constant locality $d\\ge 2$ and rate above $\\frac{1}{2}$ seems hard, it is fairly easy to construct sets with such rate and locality $d=\\Theta(n^\\epsilon)$, for constant $0\\le \\epsilon\\le 1$. Such a set is obtained from Section~\\ref{section:concatenation} by taking $h=\\Theta(n^\\epsilon)$. However, the resulting rate is\n\\begin{eqnarray*}\n\\frac{\\log\\left((h!)^{n/h}\\left(\\frac{n}{h}!\\right)\\right)}{\\log n!}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{\\log n^\\epsilon}{\\log n}+\\frac{n^{1-\\epsilon}(1-\\epsilon)\\log n}{n\\log n}=\\epsilon,\n\\end{eqnarray*}\nwhere Theorem~\\ref{theorem:lowerBound} guarantees that for this locality, there exist sets with rate which tends to 1 as $n$ tends to infinity.\n\nIn this subsection it is shown that the construction from Section~\\ref{section:concatenation} may be enhanced by using multi-permutations, achieving a rate of $\\frac{1}{2}+\\frac{\\epsilon}{2}$ for locality $d=\\Theta(n^\\epsilon)$. The methods and notations in this subsection are strongly based on~\\cite{SaritAndEitan}.\n\nFor nonnegative integers $\\ell$ and $m$, a \\textit{balanced multi-set} $\\{1^m,2^m,\\ldots,\\ell^m\\}$ is a collection of the elements in $[\\ell]$, where each element appears $m$ times. A \\textit{multi-permutation} on a balanced multi-set is a string of length $\\ell m$, which is given by a function $\\sigma: [\\ell m]\\to [\\ell]$ such that for all $i\\in[\\ell]$, $\\left|\\left\\{j\\vert \\sigma(j)=i\\right\\}\\right|=m$. The set of all multi-permutations is denoted by $S_{\\ell,m}$, and its size is $\\frac{(m\\ell)!}{(m!)^\\ell}$. To distinguish between different appearances of the same element in a multi-permutation $\\sigma$, for $j\\in[m\\ell]$, $i\\in[\\ell]$, and $r\\in [m]$ we denote $\\sigma(j)=i_r$ and $\\sigma^{-1}(i_r)=j$ if the $j$-th position of $\\sigma$ contains the $r$-th appearance of $i$.\n\n\\begin{example}\\label{example:multi-permutation}\n\tIf $m=2$ and $\\ell=3$ then $\\pi = (1,1,2,3,2,3)$ is a multi-permutation on the balanced multi-set $\\{1,1,2,2,3,3\\}$. To refer to the second appearance of $2$ we say that $\\pi(5)=2_2$.\n\\end{example}\n\n\n\n\n\nWe are interested in multi-permutations with \\textit{two} appearances of each element, and therefore assume that $m=2$ and $\\ell=n/2$ (although some of the definitions in the sequel have counterparts for any $m$ and $\\ell$ such that $n=m\\ell$). In particular, we consider such multi-permutations in which any two appearances of the same element are not too far apart. To this end, the following definition is required.\n\n\\begin{definition}\\label{definition:multi-PermutationsDistance}\n\tIf $\\pi\\in S_{n/2,2}$ and $t\\in[n]$ then,\n\t\\begin{eqnarray*}\n\t\tw(\\pi)&\\triangleq&\\max_{i\\in [n/2]}\\left|\\pi^{-1}(i_1)-\\pi^{-1}(i_2)\\right|,\\text{ and}\\\\\n\t\tB_t&\\triangleq&\\{\\pi\\in S_{n/2,2}\\vert w(\\pi)\\le t\\}.\n\t\\end{eqnarray*}\n\\end{definition}\n\nThat is, $w(\\pi)$ indicates the maximum distance between two appearances of the same element, or alternatively, $w(\\pi)-1$ indicates the maximum number of elements between two appearances of the same element in $\\pi$. For a given $t$, $B_t$ be is the set of all multi-permutations in $S_{n/2,2}$ in which every two identical elements are separated by at most $t-1$ other elements. Clearly, the multi-permutation~$\\pi$ which was given in Example~\\ref{example:multi-permutation} is in $B_2$.\n\nTo construct ``ordinary'' permutations in $S_n$ from multi-permutations in $S_{n/2,2}$ we use the term \\textit{assignment of permutations}. As in Subsection~\\ref{section:rangeRestricted}, for a set of elements $\\Sigma$ we denote by $S(\\Sigma)$ the set of all permutations of $\\Sigma$ (that is, the set of all injective functions $f:\\{1,\\ldots,|\\Sigma|\\}\\to \\Sigma$).\n\n\\begin{definition}\\label{definition:assignmentOfPermutations}\n\tIf $\\pi\\in S_{n/2,2}$ and $\\gamma_1,\\ldots,\\gamma_{n/2}$ are permutations such that $\\gamma_i\\in S\\left(\\{2i-1,2i\\}\\right)$ for all~$i$, then $\\sigma=\\pi(\\gamma_1,\\ldots,\\gamma_{n/2})$ is the permutation in $S_n$ such that for all $1\\le j\\le n$, if $\\pi(j)=i_r$ then $\\sigma(j)=\\gamma_i(r)$.\n\\end{definition}\n\n\\begin{example}\\label{example:assignmentOfPermutations}\n\tIf $\\pi=(1,1,2,3,2,3)\\in S_{3,2}$ and $\\gamma_1=(1,2),~\\gamma_2=(4,3),$ and $\\gamma_3=(6,5)$ then $\\sigma=\\pi(\\gamma_1,\\gamma_2,\\gamma_3)=(1,2,4,6,3,5)\\in S_6$.\n\\end{example}\n\nNote that by choosing $h=2$ in the construction which appears in Subsection~\\ref{section:concatenation}, the resulting set $S$ can be described as\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\t\n\t\n\tAccording to Theorem~\\ref{theorem:SumOfPermutations}, the size of $S$ is\n", "index": 5, "text": "\\[\\frac{n}{d+1}!(t_{\\frac{n}{d+1}})^{d-1}=\\Theta\\left(\\frac{\\frac{n}{d+1}!^{2d-1}}{\\left(\\frac{n}{d+1}\\right)^{\\left(\\frac{n}{d+1}-1\\right)(d-1)}}\\right).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\frac{n}{d+1}!(t_{\\frac{n}{d+1}})^{d-1}=\\Theta\\left(\\frac{\\frac{n}{d+1}!^{2d-1%&#10;}}{\\left(\\frac{n}{d+1}\\right)^{\\left(\\frac{n}{d+1}-1\\right)(d-1)}}\\right).\" display=\"block\"><mrow><mrow><mrow><mrow><mfrac><mi>n</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo lspace=\"0pt\" rspace=\"3.5pt\">!</mo></mrow><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mfrac><mi>n</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo>=</mo><mrow><mi mathvariant=\"normal\">\u0398</mi><mo>\u2062</mo><mrow><mo>(</mo><mfrac><msup><mrow><mfrac><mi>n</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo lspace=\"0pt\" rspace=\"3.5pt\">!</mo></mrow><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>d</mi></mrow><mo>-</mo><mn>1</mn></mrow></msup><msup><mrow><mo>(</mo><mfrac><mi>n</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>)</mo></mrow><mrow><mrow><mo>(</mo><mrow><mfrac><mi>n</mi><mrow><mi>d</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>-</mo><mn>1</mn></mrow><mo>)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msup></mfrac><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04504.tex", "nexttext": "Hence, the construction in the following lemma may be seen as a generalization of the construction from Subsection~\\ref{section:concatenation}.\n\n\\begin{lemma}\\label{lemma:multi-permutationsLocality}\n\tFor a nonnegative integer $t$, the set\n", "itemtype": "equation", "pos": -1, "prevtext": "Since $d=2^{o(\\log n)}$ we have that $\\frac{\\log d}{\\log n}\\overset{n\\to\\infty}{\\longrightarrow}0$, and thus the asymptotic rate of $S$ is\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log|S|}{\\log(n!)}&\\overset{n\\to\\infty}{\\longrightarrow}&\\frac{(2d-1) \\frac{n}{d+1}\\log\\frac{n}{d+1}-\\left(\\frac{n}{d+1}-1\\right)(d-1)\\log \\frac{n}{d+1}}{n\\log n}\\\\ &=&\\frac{\\frac{d}{d+1}\\cdot n+d-1}{n}\\cdot\\frac{\\log\\frac{n}{d+1}}{\\log n}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{d}{d+1}.\n\t\\end{eqnarray*}\n\\end{proof}\n\nA non-efficient implementation of $A$ may be obtained simply by traversing all permutations in~$S_n$. However, providing an efficient implementation of $A$ requires a rigorous understanding of the structure of the permutations in $P({\\mbox{Id}})$, which seems beyond the scope of contemporary knowledge. A subset of $P({\\mbox{Id}})$ of approximate size $\\sqrt{n}^{\\sqrt{n}}$ is given in~\\cite{Cooper}, but it is too small to provide a non-trivial construction. \n\n\t\\begin{remark}\nWe note that a converse claim may also be made. That is, given an optimal set of permutations with constant locality $d\\ge 2$, which is constructed according to the outline of Lemma~\\ref{lemma:chess}, one may explicitly construct the set $P(\\text{Id})$. Since an explicit construction of $P(Id)$ is not known, this may serve as a hardness result for the construction of a set of permutations with constant locality $d\\ge 2$. However, since the outline of the construction in Lemma~\\ref{lemma:chess} is highly restrictive, such a hardness result might not seem insightful enough.\n\t\\end{remark}\n\n\\section{High Rate Constructions}\\label{section:highRate}\nThis section presents several simple constructions of sets of permutations with locality, some of which attain the upper bound given in Section~\\ref{section:upper}. The well-known \\textit{alternating group} and its complement will be shown in Subsection~\\ref{section:alternating} to have locality of $n-2$, and attain the upper bound given in Theorem~\\ref{theorem:bound}. Another simple set of permutations, discussed in Section~\\ref{section:concatenation}, is those that may be seen as a concatenation of $n/h$ permutations in $S_h$, for some $h$ which divides $n$. The locality of the latter relies on the trivial observation that any single erasure in a permutation may be corrected without requiring additional redundancy. For $h=2$, this set attains the upper bound given in Theorem~\\ref{theorem:bound1}. Subsection~\\ref{section:rangeRestricted} shows a similar technique which achieves high locality. Subsection~\\ref{section:fromCodes} and Subsection~\\ref{section:multipermutations}\nenhance the construction of Subsection~\\ref{section:concatenation} by using Reed-Solomon codes over permutation polynomials, and by using multi-permutations. The results of this section are summarized in Table~\\ref{table:highRateSummary}, in which three locality regimes are considered for comparison.\n \t\n\\begin{table*}[ht]\n\t{\\centering\n\t\t\\begin{tabular}{|c|c|c|c|c|}\n\t\t\t\\hline\n\t\t\t\\multirow{2}{*}{Section} & \t\t\t\\multirow{2}{*}{Technique} & \t\t\t\\multirow{2}{*}{Locality} & Asymptotic & \t\t\t\\multirow{2}{*}{Comments} \\\\ \n\t\t\t~&~&~&Rate&~\\\\ \\hline\\hline\n\t\t\t\\ref{section:alternating} & The alternating group. & $n-2$ & $ 1$&Strictly optimal.\\\\ \\hline\n\t\t\t\\multirow{4}{*}{\\ref{section:concatenation}} & \\multirow{4}{*}{Concatenation.} & \\multirow{2}{*}{$d = O(1)$} & \\multirow{2}{*}{$\\frac{1}{d+1}$}&Strictly optimal for $d=1$. \\\\ ~&~&~&~&At least $n$ times smaller than~\\ref{section:fromCodes}.\\\\\\cline{3-5}\n\t\t\t~&~&$\\Theta(n^\\epsilon)$& $ \\epsilon$&-\\\\ \\cline{3-5}\n\t\t\t~&~&$\\Theta(n)$ & $ 1$ &-\\\\ \\hline\n\t\t\t\\ref{section:rangeRestricted} & Range-restriction. & $\\Theta(n)$ & $ 1$ &-\\\\ \\hline\n\t\t\t\\multirow{3}{*}{\\ref{section:fromCodes}} & \\multirow{3}{*}{Reed-Solomon codes.} & 6 & $ 1/2$ & $n=2^k$ for some $k$. \\\\ \\cline{3-5}\n\t\t\t~&~& 7 & $ 1/2$ & $n=\\pm 2\\mod 5$, and a prime power. \\\\ \\cline{3-5}\n\t\t\t~&~& 7 & $ 1/2$ & $n=5^k$ for some $k$.\\\\ \\hline\n\t\t\t\\multirow{3}{*}{\\ref{section:multipermutations}} & \\multirow{3}{*}{Multi-permutations} & $\\Theta(1)$ & 1/2 & Incomparable with~\\ref{section:fromCodes}.\\\\ \\cline{3-5}\n\t\t\t~&~& $\\Theta(n^\\epsilon)$ & $(1+\\epsilon)/2$ & Larger rate than~\\ref{section:concatenation} for same locality.\\\\ \\cline{3-5}\n\t\t\t~&~& $\\Theta(n)$ & $1$ & -\\\\ \\hline\n\t\t\\end{tabular}\n\t\t\\caption{Summary of the results in\\label{table:highRateSummary} Section~\\ref{section:highRate}.}\\label{table1}\n\t}\n\\end{table*}\n\n\\subsection{The Alternating Group}\\label{section:alternating}\nIt is widely known~\\cite{Bona} that any permutation may be represented as a product of transpositions (cycles of length two). Although many different products of transpositions may represent the same permutation, all representations of a given permutation either contain an even or an odd number of transpositions. For a permutations $\\pi\\in S_n$, if the number of transpositions in any representation is even, we say that $\\pi$ is even and its \\textit{sign} is 1. Otherwise it is odd, and its sign is -1. The set of all even permutations, which forms a subgroup of $S_n$ of size $n!/2$, is called \\textit{the alternating group} and denoted by $A_n$. In what follows we show that the sets $A_n$ and $S_n\\setminus A_n$ have locality of $n-2$. This fact will follow from the next simple lemma.\n\n\\begin{lemma}\\label{lemma:alternatingLocality}\nIf $\\pi$ and $\\sigma$ are two distinct permutations in $S_n$ whose one-liners agree on $n-2$ entries, then one of $\\{\\pi,\\sigma\\}$ is odd and the other is even.\n\\end{lemma}\n\n\\begin{proof}\nLet $\\{i_j\\}_{j\\in[n-2]}$ be the set of entries on whom $\\pi$ and $\\sigma$ agree, and let $\\{\\alpha_j\\}_{j\\in[n-2]}$ be the subset of $[n]$ such that for all $j\\in[n-2]$, $\\pi_{i_j}=\\sigma_{i_j}=\\alpha_j$. Clearly, $\\pi$ and $\\sigma$ differ only in the arrangement of the elements in $[n]\\setminus \\{\\alpha_j\\}_{j\\in[n-2]}$. Therefore, $\\pi$ may be obtained from $\\sigma$ by applying a single transposition which switches between the elements of $[n]\\setminus \\{\\alpha_j\\}_{j\\in[n-2]}$, and hence $\\pi$ and $\\sigma$ have opposite signs.\n\\end{proof}\n\n\\begin{corollary}\nThe sets $A_n$ and $S_n\\setminus A_n$ have locality of $n-2$.\n\\end{corollary}\n\\begin{proof}\nIf a symbol of the stored permutation $\\pi$ is missing, by observing any $n-2$ of the remaining symbols there exists exactly two possibilities for $\\pi$. According to Lemma~\\ref{lemma:alternatingLocality}, one of these options is an odd permutation and the other is even. Hence, restricting the system to store only permutations from either $A_n$ or $S_n\\setminus A_n$, we have only one possible permutation, and thus both $A_n$ or $S_n\\setminus A_n$ admit locality of $n-2$.\n\\end{proof}\n\nAlthough the results in this subsection are rather simple, they shed some light on the tightness of the bound given in Theorem~\\ref{theorem:bound}. Since $d=n-2$ we have that $n!/(\\ceil*{n/(d+1)}!)=n!/(\\ceil*{n/(n-1)}!=n!/2$, and thus $A_n$ and $S_n\\setminus A_n$ are optimal sets with locality $n-2$.\n\n\\subsection{Concatenation of Short Permutations}\\label{section:concatenation}\nObviously, in the one-line representation, any single symbol may easily be computed from all other symbols. This principle leads to simple sets of permutations which can be stored efficiently.\n\nConsider the set $S$ of permutations in $S_n$ which may be viewed as a concatenation of $n/h$ shorter permutations on $h$ elements, for some integer $h$ which divides $n$. That is, their one-liner may be viewed as a concatenation of $n/h$ one-liners, each of which is a permutation of either of the sets $\\{1,\\ldots,h\\},\\{h+1,\\ldots,2h\\},$ etc. Clearly, $S$ contains $(h!)^{n/h}\\cdot (n/h)!$ permutations. A subset of $S$, in which the $i$-th permutation is on the set $\\{(i-1)h+1,\\ldots,i\\cdot h\\}$, was considered in~\\cite[Corollary 19]{LimitedMagnitude}, where it was shown to be an optimal anticode under the infinity metric $d_\\infty$ (see Definition~\\ref{definition:dInf} in Section~\\ref{section:Linf} to follow).\n\n\n\n\\begin{lemma}\nIf $\\pi\\in S$ then any symbol $\\pi_i$ can be computed from $h-1$ other symbols, i.e., the set $S$ has locality $d=h-1$.\n\\end{lemma}\n\n\\begin{proof}\nSince $\\pi\\in S$ it follows that $\\{\\pi_{h\\cdot\\floor{i/h}+1},\\ldots,\\pi_i,\\ldots,\\pi_{(h+1)\\cdot\\floor{i/h}}\\}=\\{jh+1,\\ldots,(j+1)h\\}$. Hence, observing the value of $\\pi_{h\\cdot\\floor{i/h}+1},\\ldots,\\pi_{(h+1)\\cdot\\floor{i/h}}$ (excluding $\\pi_i$) the range $\\{jh+1,\\ldots,(j+1)h\\}$ can be identified, and $\\pi_i$ is the missing value in it.\n\\end{proof}\n\nNote that multiple erasures can be corrected simultaneously, as long as they do not reside in the same short permutation. Two erasures from the same short permutation cannot be corrected simultaneously. In addition, Q1 can be answered trivially, and Q2 requires finding the suitable sub-permutation in $n/h$ queries, and additional $h$ queries to locate the desired element.\n\nSince $d=h-1$, we have that $|S|=(d+1)!^{n/(d+1)}\\cdot (n/(d+1))!$, and for $d=1$ we have that \n\\begin{eqnarray*}\n|S|&=&2^{n/2}\\cdot (n/2)!=\\left(\\frac{n}{2}\\right)\\cdot 2\\cdot \\left(\\frac{n}{2}-1\\right)\\cdot 2 \\cdot \\ldots\\cdot (1)\\cdot 2\\\\\n&=&n\\cdot (n-2)\\cdot(n-4)\\cdot\\ldots\\cdot 2=n!!.\n\\end{eqnarray*}\n\nHence, for $d=1$ this construction attains the bound of Theorem~\\ref{theorem:bound1} with equality. However, for any $d=O(1)$, $d\\ge 2$, it can be shown that these sets \\textit{do not} attain the optimal rate, since they are superseded by the existential lower bound of Theorem~\\ref{theorem:lowerBound}.\n\n\\begin{lemma}\\label{lemma:concatentationNotOptimal}\n\tIf $h=O(1)$, the set $S$ (of locality $d=h-1$) have rate $\\frac{1}{d+1}$ as $n$ tends to infinity.\n\\end{lemma}\n\\begin{proof}\n\t\n\tBy the construction above, we have that\n\t\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log\\left((d+1)!^{\\frac{n}{d+1}}\\cdot\\left(\\frac{n}{d+1}\\right)!\\right)}{\\log(n!)}&=&\\frac{\\log\\left((d+1)!\\right)}{d+1}\\cdot \\frac{n}{\\log(n!)}+\\frac{\\log\\left((\\frac{n}{d+1})!\\right)}{\\log(n!)},\n\t\\end{eqnarray*}\n\tand since $d$ is constant, it follows that \n\t\\begin{eqnarray*}\n\t\t&\\overset{n\\to\\infty}{\\longrightarrow}&\\frac{\\log\\left((d+1)!\\right)}{\\log(n)\\cdot(d+1)}+\\frac{\\frac{n}{d+1}\\cdot\\log\\left(\\frac{n}{d+1}\\right)}{n\\log(n)}\\\\\n\t\t&=&\\frac{\\log\\left((d+1)!\\right)}{\\log(n)\\cdot(d+1)}+\\frac{1}{d+1}-\\frac{\\log(d+1)}{\\log(n)\\cdot(d+1)}\\\\&=&\\frac{\\log(d!)}{\\log(n)\\cdot(d+1)}+\\frac{1}{d+1}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{1}{d+1}.\n\t\\end{eqnarray*}\n\\end{proof}\n\nBy choosing $h=\\Theta(n^\\epsilon)$ for some constant $0<\\epsilon<1$, we achieve a non-vanishing rate.\n\\begin{lemma}\n\tIf $h=\\Theta(n^\\epsilon)$, the sets $S$ (of locality $d=h-1$) have rate $\\epsilon$ as $n$ tends to infinity.\n\\end{lemma}\n\\begin{proof}\n\t\t\\begin{eqnarray*}\n\t\t\t\\frac{\\log\\left((d+1)!^{\\frac{n}{d+1}}\\cdot\\left(\\frac{n}{d+1}\\right)!\\right)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{n(d+1)\\log(d+1)+n\\log(\\frac{n}{d+1})}{(d+1)n\\log n}\t\t\t\\overset{n\\to\\infty}{\\longrightarrow}\\epsilon\n\t\t\\end{eqnarray*}\n\\end{proof}\n\nIn the high locality regime, where $d=\\Theta(n)$, we may similarly prove that the rate of these codes approaches 1 as $n$ approaches infinity. \n\n\\begin{lemma}\\label{lemma:concatentationOptimal}\n\tIf $h=\\Theta(n)$, the sets $S$ (of locality $d=h-1$) have rate $1$ as $n$ tends to infinity.\n\\end{lemma}\n\n\n\n\n\n\n\n\n\\subsection{Concatenation of Range-Restricted Permutations}\\label{section:rangeRestricted}\nIn this subsection we provide a technique for producing sets of permutations with high locality $d\\ge n/2$. For a set of symbols $\\Sigma$ let $S(\\Sigma)$ denote the set of all permutations of $\\Sigma$, that is, the set of all injective functions from $[|\\Sigma|]$ to $\\Sigma$. In this subsection we use the alphabet $\\Sigma=\\{0,\\ldots,n-1\\}$, and hence $S(\\Sigma)=S_n$. Let $h$ be an integer which divides $n$, and for $i\\in\\{0,\\ldots,n/h-1\\}$ let\n\\begin{eqnarray*}\nS_i\\triangleq S(\\{ih,ih+1,\\ldots,(i+1)h-1\\})\\circ S([n]\\setminus\\{ih,ih+1,\\ldots,(i+1)h-1\\}).\n\\end{eqnarray*}\n\n\\begin{lemma}\nThe set $S^h\\triangleq \\cup_{i=0}^{n/h-1}S_i$ has locality $d=n-h-1$.\n\\end{lemma}\n\\begin{proof}\nTo repair a missing symbol $\\pi_j,0\\le j\\le n-1$ in $\\pi\\in S^h$, distinguish between the cases $j\\le h-1$ and $j\\ge h$. If $j\\le h-1$, $\\pi_j$ may clearly be computed from $\\{\\pi_i\\}_{i\\in\\{0,\\ldots,h-1\\}\\setminus\\{j\\}}$. If $j\\ge h$, the set of symbols $\\{\\pi_i\\}_{i\\in\\{h,\\ldots,n-1\\}\\setminus\\{j\\}}$ must contain a gap of $h$ consecutive numbers, which are located in the prefix of $\\pi$. After identifying this gap, the missing symbol $\\pi_j$ may easily be deduced.\n\\end{proof}\n\nThe set $S^h$ contains $\\frac{n}{h}\\cdot h!\\cdot (n-h)!=n\\cdot (h-1)!\\cdot(n-h)!$ and it does not attain the upper bound given in Theorem~\\ref{theorem:bound}. For constant $h$ the rate of $S^h$ asymptotically approaches 1 as $n$ goes to infinity, since\n\\begin{eqnarray*}\n\\frac{\\log(n\\cdot (h-1)!\\cdot(n-h)!)}{\\log(n!)}\\ge\\frac{\\log((n-h)!)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}1.\n\\end{eqnarray*}\n\nEqual rate may be obtained for lower locality, where $h=\\Theta(n)$; if $h=\\delta n$ for some constant $0<\\delta<1$, then\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log(n\\cdot (h-1)!\\cdot(n-h)!)}{\\log(n!)}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{\\delta n \\log (\\delta n)+(1-\\delta)n\\log((1-\\delta)n)}{n\\log n}=\\delta+(1-\\delta)=1.\n\t\\end{eqnarray*}\n\tAn identical rate is also obtained by choosing $h=\\Theta(n^\\epsilon)$. Hence, the best choice of parameters for this technique seems to be $h=\\Theta(n)$, since it results in low locality and optimal rate.\n\n\\subsection{Extended Construction from Error-Correcting Codes}\\label{section:fromCodes}\nThis section provides a recursive construction of a set of permutations in $S_n$ with locality, from two constituent ingredients. The first ingredient is a set of permutations $S\\subseteq S_{n-t}$ with locality $d$, for some given $t$ and $d$. The second ingredient is an error-correcting code $T$, in which all codewords consist of $t$ distinct symbols. \n\nA \\textit{symbol replacement function} $f$ is an injective function which maps one alphabet to another. Given a permutation $\\pi$ and a symbol replacement function $f$ let $f(\\pi)$ be the result of replacing the symbols of $\\pi$ according to $f$. For a set of permutations $S$ let $f(S)\\triangleq\\{f(\\pi)\\vert \\pi\\in S\\}$. The construction of this section relies on the following observation.\n\n\\begin{observation}\\label{observation:replacement}\nIf $S\\subseteq S_{n-t}$ is a set of permutations with locality $d$ and $f$ is a symbol replacement function, then $f(S)$ is a set of permutations with locality $d$ as well.\n\\end{observation}\n\nUsing a proper symbol replacement function $f$, a permutation $f(\\pi)$ for $\\pi\\in S$ is concatenated to a codeword from $T$ to create a permutation in $S_n$. This symbol replacement  function is given in the following definition, which is followed by an example.\n\n\\begin{definition}\\label{definition:replacement}\nFor any integers $1<t<n$, let $\\pi$ be a permutation in $S_{n-t}$ and $e\\in[n]^t$ be a word with $t$ distinct symbols $\\{\\sigma_1,\\ldots,\\sigma_t\\}\\triangleq E\\subseteq[n]$. Let $f_E$ be the following symbol replacement function \n\\begin{eqnarray*}\n f_E:[n-t]&\\to&\\left([n-t]\\setminus E\\right)\\cup\\{n-t+1,\\ldots,n-t+|E\\cap [n-t]\\}\\\\\nf_E(i)&=&\n\n\n\n\n\\begin{cases}\ni, & i\\notin E.\\\\%\\cap [n-d].\\\\\n~\\\\\n\\shortstack{j,\\\\~\\\\~} & \\shortstack{\\mbox{For some integer $s$, $i$ and $j$ are the $s$-smallest numbers }\\\\ \\mbox{in $E\\cap[n-t]$ and $\\{n-t+1,\\ldots,n\\}\\setminus E$, respectively.}}\n\\end{cases}\n\\end{eqnarray*}\nThat is, $f_E$ maps each element which does not appear in $E$ to itself, and each element which appears in~$E$ is mapped to a symbol in $\\{n-t+1,\\ldots,n\\}$ which does not appear in $E$, in an increasing manner. Using $f_E$, define the operator $\\odot$ as\n\\begin{eqnarray*}\n\\pi\\odot e\\triangleq f_E(\\pi)\\circ e,\n\\end{eqnarray*}\nwhere $\\circ$ denotes the ordinary concatenation of strings.\n\\end{definition}\nSince symbols in $\\pi$ which occur in both $\\pi$ and $e$ are replaced with symbols that do not appear in either $\\pi$ nor $e$, we have that $\\pi\\odot e$ is a permutation in $S_n$, as illustrated by the following example.\n\\begin{example}\nFor $n=7$ and $t=3$, let $\\pi=(1,2,3,4)$, $e = (3,4,7)$, and $E = \\{3,4,7\\}$. By Definition~\\ref{definition:replacement} we have that\n\\begin{eqnarray*}\nf_E(1)=1,~f_E(2)=2,~f_E(3)=5,~f_E(4)=6,~\\mbox{and~}\n\\pi\\odot e = f_E(\\pi)\\circ e=(1,2,5,6,3,4,7)\\in S_7.\n\\end{eqnarray*}\n\\end{example}\n\nThe operation $\\odot$ is used to extend an existing set $S\\subseteq S_{n-t}$ with locality to a subset of $S_n$ with a larger locality by using an error-correcting MDS code $T$. \n\n\\begin{lemma}\\label{lemma:replacementConcatenation}\nFor integers $1<t< n$, if $S\\subseteq S_{n-t}$ is a set with locality $d$ and $T$ is an MDS code in $[n]^t$ with minimum distance $\\delta$ and distinct symbols, then $S\\odot T\\triangleq\\{s\\odot e\\vert s\\in S,~e\\in T\\}\\subseteq S_n$ is a set of permutations with locality $d+t-\\delta+1$. \n\\end{lemma}\n\\begin{proof}\nLet $\\pi=s\\odot e$ be a permutation in $S\\odot T$. To repair a missing symbol $\\pi_j$ for $1\\le j\\le n$ we distinguish between the cases $j\\le n-t$ and $j>n-t$. If $j>n-t$, by the minimum distance property of the MDS code $T$ we may obtain $\\pi_j$ by accessing $t-\\delta+1$ symbols from $e$. If $j\\le n-t$, then by accessing $t-\\delta+1$ symbols from $e$ we may identify the function $f_E$ used to define the operator $\\odot$ (Definition~\\ref{definition:replacement}). Once $f_E$ is known, the symbol $\\pi_j$ may be obtained by using Observation~\\ref{observation:replacement}.\n\\end{proof}\n\nThis technique can be used to obtain explicit sets with constant locality $d\\ge 2$, which are the largest ones in this paper for this locality. Unfortunately, to the best of our knowledge the asymptotic rate of these sets does not exceed $\\frac{1}{2}$, and hence they are not optimal. Moreover, since a set with locality $1$ also has locality $d\\ge 2$ for any $d$, the sets of locality 1 from Subsection~\\ref{section:concatenation} can be used for any locality greater than 1, while obtaining rate of $\\frac{1}{2}$ as well. Nevertheless, for small values of $d$ we are able to construct explicit sets with locality $d$ which contain more permutations than the sets with locality 1 from Subsection~\\ref{section:concatenation}. \n\nTo provide good examples by this technique, we must construct error-correcting codes in which all codewords consist of distinct symbols. For this purpose, assume that $n$ is a power of prime, and $\\{0,1,\\ldots,n-1\\}$ are representations of the elements of ${\\mathbb{F}}_n$.\n\nRecall that a \\textit{Reed-Solomon} code is given by evaluations of degree restricted polynomials on a fixed set of distinct elements from a large enough finite field. These codes contain sub-codes which are suitable for our purpose. The codewords in these sub-codes are obtained by evaluations of \\textit{permutation polynomials}. A permutation polynomial is a polynomial which represents an injective function from ${\\mathbb{F}}_n$ to itself. In spite of the very limited knowledge on permutation polynomials in general, all permutation polynomials of degree at most 5 are known (see~\\cite[Table 2]{powerline}). For example, we have the following lemma.\n\n\\begin{lemma}\\label{lemma:permutationPolynomials}\\cite[Table~2]{powerline} \n\t\n\t\\begin{enumerate}\n\t\t\\item If $n$ is a power of 2, then there exist at least  $(n-1)(2n+\\frac{n(n^2+2)}{3})$ permutation polynomials of degree at most 4 over ${\\mathbb{F}}_n$.\n\t\t\\item If $n$ is a prime power and $n\\equiv\\pm 2~(\\bmod 5)$, then there exist at least $n^3(n-1)$ permutation polynomials of degree at most 5 over ${\\mathbb{F}}_n$.\n\t\t\\item If $n$ is a prime power and $n\\equiv 0~(\\bmod 5)$, then there exist at least $\\frac{1}{2}n^2(n-1)^2$ permutation polynomials of degree at most 5 over ${\\mathbb{F}}_n$.\n\t\\end{enumerate}\n\\end{lemma}\n\nAs a corollary, we obtain the following constructions.\n\n\\begin{example}\\label{example:locality5} ~\n\t\n\t\\begin{enumerate}\n\t\t\\item Let $n$ be an integer power of 2, and let $S\\subseteq S_{n-6}$ be an optimal set with locality 1 (which exists by Subsection~\\ref{section:concatenation}, since $n-6$ is even). Let $T$ be a subset of a Reed-Solomon code of dimension $5$ and length $6$ over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 4. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 1), the set $B_1\\triangleq S\\odot T$ contains $(n-6)!!\\cdot (n-1)(2n+\\frac{n(n^2+2)}{3})$ permutations, and has locality 6.\n\t\t\\item Let $n$ be a odd prime power and $n\\equiv\\pm 2~(\\bmod 5)$ (such as $7,17,23,\\ldots$ etc.), and let $S\\subseteq S_{n-7}$ be an optimal set with locality 1, as above. Let $T$ be a subset of a Reed-Solomon code of dimension~6 and length 7 over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 5. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 2), the set $B_2\\triangleq S\\odot T$ contains $(n-7)!!\\cdot n^3(n-1)$ permutations, and has locality 7.\n\t\t\\item Let $n$ be a prime power and $n\\equiv0~(\\bmod 5)$ (i.e., n is a power of 5), and let $S\\subseteq S_{n-7}$ be an optimal set with locality 1, as above. Let $T$ be a subset of a Reed-Solomon code of dimension~6 and length 7 over ${\\mathbb{F}}_n$, which corresponds to all permutation polynomials of degree at most 5. According to Lemma~\\ref{lemma:replacementConcatenation} and Lemma~\\ref{lemma:permutationPolynomials} (part 3), the set $B_3\\triangleq S\\odot T$ contains $(n-7)!!\\cdot \\frac{1}{2}n^2(n-1)^2$ permutations, and has locality 7.\n\t\\end{enumerate}\n\n\\end{example}\n\nNotice that an optimal set $A\\subseteq S_n$ with locality 1, which may be seen as having any larger locality, contains $n!!$ permutations (see Section~\\ref{section:concatenation}). The set $B_1$ is larger, since $n!!=(n-6)!!\\cdot \\Theta(n^3)$ and $|B_1|=(n-6)!!\\cdot \\Theta(n^4)$. Similarly, for odd values of $n$, Section~\\ref{section:concatenation} provides a set $A$ of size $(n-1)!!$ and locality 1. The sets $B_2$ and $B_3$ are larger, since $|A|=(n-1)!!=(n-7)!!\\cdot \\Theta(n^3)$, where both $|B_2|$ and $|B_3|$ equal $(n-7)!!\\cdot \\Theta(n^4)$. Hence, the construction of this section provides sets which are at least $n$ times larger than those given in Section~\\ref{section:concatenation}, and have larger constant locality.\n\n\\subsection{High-Locality Construction From Multi-Permutations}\\label{section:multipermutations}\n\nWhile constructing sets of permutations with constant locality $d\\ge 2$ and rate above $\\frac{1}{2}$ seems hard, it is fairly easy to construct sets with such rate and locality $d=\\Theta(n^\\epsilon)$, for constant $0\\le \\epsilon\\le 1$. Such a set is obtained from Section~\\ref{section:concatenation} by taking $h=\\Theta(n^\\epsilon)$. However, the resulting rate is\n\\begin{eqnarray*}\n\\frac{\\log\\left((h!)^{n/h}\\left(\\frac{n}{h}!\\right)\\right)}{\\log n!}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{\\log n^\\epsilon}{\\log n}+\\frac{n^{1-\\epsilon}(1-\\epsilon)\\log n}{n\\log n}=\\epsilon,\n\\end{eqnarray*}\nwhere Theorem~\\ref{theorem:lowerBound} guarantees that for this locality, there exist sets with rate which tends to 1 as $n$ tends to infinity.\n\nIn this subsection it is shown that the construction from Section~\\ref{section:concatenation} may be enhanced by using multi-permutations, achieving a rate of $\\frac{1}{2}+\\frac{\\epsilon}{2}$ for locality $d=\\Theta(n^\\epsilon)$. The methods and notations in this subsection are strongly based on~\\cite{SaritAndEitan}.\n\nFor nonnegative integers $\\ell$ and $m$, a \\textit{balanced multi-set} $\\{1^m,2^m,\\ldots,\\ell^m\\}$ is a collection of the elements in $[\\ell]$, where each element appears $m$ times. A \\textit{multi-permutation} on a balanced multi-set is a string of length $\\ell m$, which is given by a function $\\sigma: [\\ell m]\\to [\\ell]$ such that for all $i\\in[\\ell]$, $\\left|\\left\\{j\\vert \\sigma(j)=i\\right\\}\\right|=m$. The set of all multi-permutations is denoted by $S_{\\ell,m}$, and its size is $\\frac{(m\\ell)!}{(m!)^\\ell}$. To distinguish between different appearances of the same element in a multi-permutation $\\sigma$, for $j\\in[m\\ell]$, $i\\in[\\ell]$, and $r\\in [m]$ we denote $\\sigma(j)=i_r$ and $\\sigma^{-1}(i_r)=j$ if the $j$-th position of $\\sigma$ contains the $r$-th appearance of $i$.\n\n\\begin{example}\\label{example:multi-permutation}\n\tIf $m=2$ and $\\ell=3$ then $\\pi = (1,1,2,3,2,3)$ is a multi-permutation on the balanced multi-set $\\{1,1,2,2,3,3\\}$. To refer to the second appearance of $2$ we say that $\\pi(5)=2_2$.\n\\end{example}\n\n\n\n\n\nWe are interested in multi-permutations with \\textit{two} appearances of each element, and therefore assume that $m=2$ and $\\ell=n/2$ (although some of the definitions in the sequel have counterparts for any $m$ and $\\ell$ such that $n=m\\ell$). In particular, we consider such multi-permutations in which any two appearances of the same element are not too far apart. To this end, the following definition is required.\n\n\\begin{definition}\\label{definition:multi-PermutationsDistance}\n\tIf $\\pi\\in S_{n/2,2}$ and $t\\in[n]$ then,\n\t\\begin{eqnarray*}\n\t\tw(\\pi)&\\triangleq&\\max_{i\\in [n/2]}\\left|\\pi^{-1}(i_1)-\\pi^{-1}(i_2)\\right|,\\text{ and}\\\\\n\t\tB_t&\\triangleq&\\{\\pi\\in S_{n/2,2}\\vert w(\\pi)\\le t\\}.\n\t\\end{eqnarray*}\n\\end{definition}\n\nThat is, $w(\\pi)$ indicates the maximum distance between two appearances of the same element, or alternatively, $w(\\pi)-1$ indicates the maximum number of elements between two appearances of the same element in $\\pi$. For a given $t$, $B_t$ be is the set of all multi-permutations in $S_{n/2,2}$ in which every two identical elements are separated by at most $t-1$ other elements. Clearly, the multi-permutation~$\\pi$ which was given in Example~\\ref{example:multi-permutation} is in $B_2$.\n\nTo construct ``ordinary'' permutations in $S_n$ from multi-permutations in $S_{n/2,2}$ we use the term \\textit{assignment of permutations}. As in Subsection~\\ref{section:rangeRestricted}, for a set of elements $\\Sigma$ we denote by $S(\\Sigma)$ the set of all permutations of $\\Sigma$ (that is, the set of all injective functions $f:\\{1,\\ldots,|\\Sigma|\\}\\to \\Sigma$).\n\n\\begin{definition}\\label{definition:assignmentOfPermutations}\n\tIf $\\pi\\in S_{n/2,2}$ and $\\gamma_1,\\ldots,\\gamma_{n/2}$ are permutations such that $\\gamma_i\\in S\\left(\\{2i-1,2i\\}\\right)$ for all~$i$, then $\\sigma=\\pi(\\gamma_1,\\ldots,\\gamma_{n/2})$ is the permutation in $S_n$ such that for all $1\\le j\\le n$, if $\\pi(j)=i_r$ then $\\sigma(j)=\\gamma_i(r)$.\n\\end{definition}\n\n\\begin{example}\\label{example:assignmentOfPermutations}\n\tIf $\\pi=(1,1,2,3,2,3)\\in S_{3,2}$ and $\\gamma_1=(1,2),~\\gamma_2=(4,3),$ and $\\gamma_3=(6,5)$ then $\\sigma=\\pi(\\gamma_1,\\gamma_2,\\gamma_3)=(1,2,4,6,3,5)\\in S_6$.\n\\end{example}\n\nNote that by choosing $h=2$ in the construction which appears in Subsection~\\ref{section:concatenation}, the resulting set $S$ can be described as\n", "index": 7, "text": "\\[S=\\{\\pi(\\gamma_1,\\ldots,\\gamma_{n/2})~\\vert~ \\forall i,\\gamma_i\\in S(\\{2i-1,2i\\})\\text{ and } \\pi \\in B_1\\}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"S=\\{\\pi(\\gamma_{1},\\ldots,\\gamma_{n/2})~{}|~{}\\forall i,\\gamma_{i}\\in S(\\{2i-1%&#10;,2i\\})\\text{ and }\\pi\\in B_{1}\\}.\" display=\"block\"><mrow><mrow><mi>S</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b3</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>\u03b3</mi><mrow><mi>n</mi><mo>/</mo><mn>2</mn></mrow></msub><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><mrow><mrow><mrow><mo>\u2200</mo><mi>i</mi></mrow><mo>,</mo><msub><mi>\u03b3</mi><mi>i</mi></msub></mrow><mo>\u2208</mo><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><mi>\u03c0</mi></mrow><mo>\u2208</mo><msub><mi>B</mi><mn>1</mn></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04504.tex", "nexttext": " has locality $4t$.\n\\end{lemma}\n\n\\begin{proof}\n\tFor $i\\in [n/2]$ we say that the elements $\\{2i-1,2i\\}$ are \\textit{counterparts}. Assume that a symbol $\\pi_i$ is erased, and let\n\t\\begin{eqnarray*}\n\tD&\\triangleq&\\{\\pi_{i-t},\\ldots,\\pi_{i-1},\\pi_{i+1},\\ldots,\\pi_{i+t}\\}\\\\\n\t\\overline{D}&\\triangleq&\\{\\pi_{i-2t},\\ldots,\\pi_{i-1},\\pi_i,\\pi_{i+1},\\ldots,\\pi_{i+2t}\\},\n\t\\end{eqnarray*}\n\twhere we omit all $\\pi_j$'s for which $j\\notin [n]$. By the definition of $A_t$, all the counterparts of the elements in $D$ are in $\\overline{D}$. However, there exists $\\sigma\\in D$ which is the counterpart of $\\pi_i$, and hence, $\\sigma$'s counterpart is not to be found in $\\overline{D}\\setminus\\{\\pi_i\\}$. Therefore, computing $\\pi_i$ is possible by inspecting $\\overline{D}\\setminus\\{\\pi_i\\}$, and returning the counterpart of the only element in $D$ whose counterpart is not in $\\overline{D}\\setminus\\{\\pi_i\\}$. The claim follows since $|\\overline{D}\\setminus\\{\\pi_i\\}|=4t$.\n\\end{proof}\n\nUsing this lemma, we are able to provide a set with high locality $\\Theta(n^\\epsilon)$, and asymptotic rate strictly above~$\\frac{1}{2}$. To bound this rate from below we require a lower bound on the size of $B_t$ from Definition~\\ref{definition:multi-PermutationsDistance}.\n\n\\begin{lemma}\\label{lemma:BtLowerBound}\n\t$|B_t|\\ge \\left(\\frac{t!}{(t/2)!}\\right)^{n/t}\\cdot \\frac{n}{2}!\\cdot 2^{-n/2}$.\n\\end{lemma}\n\n\\begin{proof}\n\tSince our goal is an asymptotic computation, we may w.l.o.g. assume that $t\\vert n$ and $2|t$. Let $E$ be the set of multi-permutations $\\pi\\in S_{n/2,2}$ that can be written as a concatenation  $\\pi=\\pi^{(1)}\\circ\\ldots\\circ\\pi^{(n/t)}$ of $\\frac{n}{t}$ multi-permutations on $t/2$ pairs of identical elements. A simple combinatorial calculation shows that\n\t\\begin{eqnarray*}\n\t|E|&\\ge& \\prod _{i=1}^{n/t}(\\text{no. of options to choose }\\pi^{(i)})\\\\\n\t&\\ge & \\left({n/2 \\choose t/2}\\cdot \\frac{t!}{2^{t/2}}\\right)\\cdot \\left({n/2-t/2 \\choose t/2}\\cdot \\frac{t!}{2^{t/2}}\\right)\\cdot \\ldots \\cdot \\left(1\\cdot \\frac{t!}{2^{t/2}}\\right)\\\\\n\t&=&\\left(\\frac{t!}{2^{t/2}}\\right)^{n/t}\\cdot \\frac{(n/2)!}{(n/2-t/2)!(t/2)!}\\cdot \\frac{(n/2-t/2)!}{(n/2-2\\cdot t/2)!(t/2)!}\\cdot\\ldots\\cdot \\frac{(t/2)!}{(t/2)!}\\\\\n\t&=&\\left(\\frac{t!}{2^{t/2}}\\right)^{n/t}\\cdot\\frac{(n/2)!}{(t/2)!^{n/t}}=\\left(\\frac{t!}{(t/2)!}\\right)^{n/t}\\cdot \\frac{n}{2}!\\cdot 2^{-n/2}.\n\t\\end{eqnarray*}\n\tSince clearly $E\\subseteq B_t$, the claim follows.\n\\end{proof}\nLemma~\\ref{lemma:BtLowerBound} allows us to bound the asymptotic rate of the set $A_t$  which was defined in Lemma~\\ref{lemma:multi-permutationsLocality}.\n\n\\begin{theorem}\n\tIf $t=\\Theta(n^\\epsilon)$ then $\\lim_{n\\to\\infty} \\frac{\\log|A_t|}{\\log n!}\\ge \\frac{1}{2}+\\frac{\\epsilon}{2}$.\n\\end{theorem}\n\n\\begin{proof}\n\tAccording to Lemma~\\ref{lemma:BtLowerBound}, we have that $|A_t|\\ge |B_t|\\cdot 2^{n/2}$. Using the fact that $t=\\Theta(n^\\epsilon)$ and the approximation $\\log(n!)\\approx n\\log n$, we have\n\t\\begin{eqnarray*}\n\t\t\\frac{\\log|A_t|}{\\log n!}&\\ge& \\frac{\\log(|B_t|\\cdot 2^{n/2})}{\\log n!}\\\\\n\t\t&=& \\frac{\\log\\left(\\left(\\frac{t!}{(t/2)!}\\right)^{n/t}\\cdot \\frac{n}{2}!\\right)}{\\log n!}\\\\\n\t\t&=& \\frac{n\\log(t!)-n\\log((t/2)!)}{t\\log n!}+\\frac{\\log((n/2)!)}{\\log n!}\\\\\n\t\t&\\overset{n\\to\\infty}{\\longrightarrow}& \\frac{nt\\log t-n\\frac{t}{2}\\log((t/2))}{tn\\log n}+\\frac{\\frac{n}{2}\\log((n/2))}{n\\log n}\\\\\n\t\t&=&\\frac{\\epsilon\\log n-\\frac{\\epsilon}{2}\\log n+\\frac{1}{2}}{\\log n}+\\frac{\\log n-1}{2\\log n}\\overset{n\\to\\infty}{\\longrightarrow}\\frac{1}{2}+\\frac{\\epsilon}{2}.\n\t\\end{eqnarray*}\n\\end{proof}\n\n\\section{Construction of Specific Families}\\label{section:lowRate}\n\\subsection{Light Permutations by the Infinity Norm}\\label{section:Linf}\nIn this subsection it is shown that permutations which involve small-magnitude shifts (in comparison with the original file), can be stored efficiently. Answering Q1 requires downloading one symbol, whereas answering Q2 requires downloading a small number of adjacent symbols. An alternative and shorter representation, in which Q2 requires downloading one symbol and Q1 requires downloading a few, will be discussed in Subsection~\\ref{section:LinfAlternative}.\n\nThese permutations arise naturally when considering any ranking of items, in which an initial conjectured ranking is imposed, and any item is not expected to exceed its initial ranking by more than a certain bound.\n\n\\begin{definition}\\label{definition:dInf}\nIf $\\pi$ and $\\sigma$ are two permutations in $S_n$, then $d_\\infty(\\pi,\\sigma)\\triangleq \\max\\left\\{\\left|\\pi(i)-\\sigma(i)\\right|\\right\\}_{i\\in[n]}$. If $e$ is the identity permutation in $S_n$ then $\\ell_\\infty(\\pi)\\triangleq d_\\infty(\\pi,e)$, and for any $r\\in\\{0,\\ldots,n-1\\}$, let ${\\mathcal{B}}_\\infty(e,r)$ (${\\mathcal{B}}_r$ in short) be the ball of radius $r$ around $e$, that is, ${\\mathcal{B}}_\\infty(e,r)\\triangleq\\{\\pi\\in S_n~\\vert~\\ell_\\infty(\\pi)\\le r\\}$.\n\\end{definition}\n\n\n\nRecall that we denote $\\pi=(\\pi_1,\\ldots,\\pi_n)\\triangleq(\\pi^{-1}(1),\\ldots,\\pi^{-1}(n))$, and for convenience, we say that $\\pi_j=0$ for any $j\\notin[n]$. \n\nProviding a closed-form expression for $|{\\mathcal{B}}_r|$ is a notorious open problem. An efficient algorithm for computing $|{\\mathcal{B}}_r|$ is given in~\\cite[Corollary~5]{Moshe1}, from which the estimation $|{\\mathcal{B}}_2|\\approx2.16^n$ follows~\\cite[Example~2]{Moshe1}. This estimation clearly implies that $|{\\mathcal{B}}_r|$ is (at least) exponential in $n$ for any $r$. On the other hand, by~\\cite[Theorem~18]{LimitedMagnitude} we have that the size of an \\textit{anti-code} of maximum $d_\\infty$-distance $2r$ is at most $(2r+1)!^{n/(2r+1)}$. As ${\\mathcal{B}}_r$ is clearly an anti-code of maximum $d_\\infty$-distance $2r$, we have that $|{\\mathcal{B}}_r|\\le (2r+1)!^{n/(2r+1)}$.\n\nThe locality of the set ${\\mathcal{B}}_r$ relies on the following series of lemmas. The first lemma shows that an erasure in $\\pi\\in{\\mathcal{B}}_r$ can be corrected by inspecting the entries in radius $2r$ from it.\n\n\\begin{lemma}\\label{lemma:LinfRepair}\nIf $\\pi\\in{\\mathcal{B}}_r$ then for all $j\\in [n]$, $\\pi_j$ is a function of $\\pi_{j-2r},\\ldots,\\pi_{j-1},\\pi_{j+1}\\ldots,\\pi_{j+2r}$.\n\\end{lemma}\n\\begin{proof}\nSince $\\pi\\in{\\mathcal{B}}_r$, for any $t\\in[n]$ we have that $t\\in\\{\\pi_{t-r},\\ldots,\\pi_{t+r}\\}$ and $\\pi_t\\in\\{t-r,\\ldots,t+r\\}$. Therefore, \n\\begin{eqnarray*}\n\\pi_j&\\in&\\{j-r,\\ldots,j,\\ldots,j+r\\},\\mbox{ and}\\\\\n\\{j-r,\\ldots,j,\\ldots,j+r\\}&\\subseteq&\\{\\pi_{j-2r},\\ldots,\\pi_j,\\ldots,\\pi_{j+2r}\\}.\n\\end{eqnarray*}\nThis implies that\n\\begin{eqnarray*}\n\\{j-r,\\ldots,j,\\ldots,j+r\\}\\setminus\\{\\pi_{j-2r},\\ldots,\\pi_{j-1},\\pi_{j+1},\\ldots,\\pi_{j+2r}\\}=\\{\\pi_j\\},\n\\end{eqnarray*}\nand hence, $\\pi_j$ may be computed given $\\pi_{j-2r},\\ldots,\\pi_{j-1},\\pi_{j+1},\\ldots,\\pi_{j+2r}$.\n\\end{proof}\n\nLemma~\\ref{lemma:LinfRepair} implies a correction algorithm for simultaneous erasures, in scenarios where the correction by Lemma~\\ref{lemma:LinfRepair} is impossible.\n\n\n\n\\begin{lemma}\\label{lemma:LinfReconstruct}\nIf $\\pi\\in {\\mathcal{B}}_r$, then any set of erasures in which any two are separated by at least $2r-1$ non-erased symbols can be corrected.\n\\end{lemma}\n\\begin{proof}\nLet $E\\triangleq\\{s_1,\\ldots,s_t\\}$ be the set of missing symbols in $\\pi$. For each $s_i\\in E$ define the \\textit{radius of possibility} $R(s_i)\\triangleq\\{s_i-r,\\ldots,s_i+r\\}$ (a radius, in short), which is the set of the possible locations of the missing symbol $s_i$. Clearly, if $\\pi$ contains a single erasure in locations $R(s_i)$, then this erasure can be corrected to $s_i$. Hence, it suffices to show that for every $t$, the set $\\{R(s_i)\\}_{i=1}^t$ contains at least one radius which contains a single erasure.\n\nAssume for contradiction that every radius in $\\{R(s_i)\\}_{i=1}^t$ contains at least two erasures. Notice that since the erasures are at least $2r-1$ apart, every radius contains \\textit{exactly} two erasures. Let $j$ be the location of the leftmost erasure, and assume w.l.o.g that it is contained in two  radii $R(s_1)$ and $R(s_2)$. Since both radii contain two erasures, they both must contain the erasure located to the right of $j$, at $j+2r$. Hence, since the size of both radii is $2r+1$, we have that $R(s_1)=R(s_2)=\\{j,\\ldots,j+2r\\}$, and thus $s_1=s_2$, a contradiction.\n\\end{proof}\n\n\n\n\n\n\n\n\n\n\n\n\n\nSince permutations in ${\\mathcal{B}}_r$ involve small-magnitude shifts, Q2 can be answered by inspecting the values of $2r$ locations, $r$ to the right and $r$ to the left of location $i$. Permutations in ${\\mathcal{B}}_r$ admit a shorter representation, for which Q2 can be answered immediately, and Q1 requires inspecting $2r$ other symbols (see Subsection~\\ref{section:LinfAlternative}). \n \n\\subsection{MinMax Permutations}\\label{section:MinMax}\nThe following set of permutations, called ``MinMax'', includes many natural ones. E.g., all single left (right) cyclic shifts of any prefix (suffix) of the file. These permutations arise in the context of content consumption, such as news or tweets, in which the consumer begins with an arbitrary item of a feed, and either proceeds forward or backwards from the set of consecutive items which he read so far.\n\n\\begin{definition}\\label{definition:MinMax}\nThe set of MinMax permutations ${\\mathcal{M}}$ consists of two subsets denoted ${\\mathcal{M}}_L$ and ${\\mathcal{M}}_R$. The subset ${\\mathcal{M}}_L$  (${\\mathcal{M}}_R$) consists of all permutations in which every element is either greater than the maximal element to his left (right) by 1, or smaller than the minimal element to his left (right) by 1. That is,\n\\begin{eqnarray*}\n{\\mathcal{M}}_L&\\triangleq& \\left\\{\\pi\\in S_n~\\vert~\\forall i,~\\pi_i\\in\\{\\max_{j<i}\\pi_j+1,\\min_{j<i}\\pi_j-1\\}\\right\\},\\\\\n{\\mathcal{M}}_R&\\triangleq& \\left\\{\\pi\\in S_n~\\vert~\\forall i,~\\pi_i\\in\\{\\max_{j>i}\\pi_j+1,\\min_{j>i}\\pi_j-1\\}\\right\\},~\\mbox{and}\\\\\n{\\mathcal{M}}&\\triangleq&{\\mathcal{M}}_L\\cup {\\mathcal{M}}_R.\n\\end{eqnarray*}\n\\end{definition}\n\n\\begin{example}\n\tFor $n=7$,\n\t\\begin{itemize}\n\t\t\\item The permutation $(3,4,5,2,1,6,7)$ is in ${\\mathcal{M}}_L$ but not in ${\\mathcal{M}}_R$.\n\t\t\\item The permutation $(1,2,3,4,5,6,7)$ is in ${\\mathcal{M}}_L$ and in ${\\mathcal{M}}_R$.\n\t\t\\item The permutation $(3,5,1,2,7,6,4)$ is neither in ${\\mathcal{M}}_L$ nor in ${\\mathcal{M}}_R$.\n\t\\end{itemize} \n\\end{example}\n\n\\noindent The following lemma provides an alternative to Definition~\\ref{definition:MinMax}, and will be used in the sequel.\n\n\\begin{lemma}\\label{lemma:consecutive}\n$\\pi\\in{\\mathcal{M}}_L$ if and only if for all $i\\in [n]$, the set $\\{\\pi_1,\\ldots,\\pi_i\\}$ contains consecutive numbers. Similarly, $\\pi\\in{\\mathcal{M}}_R$ if and only if for all $i\\in [n]$, the set $\\{\\pi_i,\\ldots,\\pi_n\\}$ contains consecutive numbers. \n\\end{lemma}\n\n\\begin{proof}\nFor $\\pi\\in{\\mathcal{M}}_L$ we prove by induction on $i$ that the set $\\{\\pi_1,\\ldots,\\pi_i\\}$ contains consecutive numbers. For $i=1$ the claim is clear. For an arbitrary $i>1$, by the induction hypothesis we have that $\\{\\pi_1,\\ldots,\\pi_{i-1}\\}$ is a set of consecutive numbers. By the definition of ${\\mathcal{M}}_L$ we have that $\\pi_i\\in\\{\\max_{j<i}\\pi_j+1,\\min_{j<i}\\pi_j-1\\}$, and hence the set $\\{\\pi_1,\\ldots,\\pi_{i}\\}$ is a set of consecutive numbers as well.\n\nOn the other hand, if for all $i$ the set $\\{\\pi_1,\\ldots,\\pi_i\\}$ contains consecutive numbers, we show by induction on $i$ that $\\pi_i\\in\\{\\max_{j<i}\\pi_j+1,\\min_{j<i}\\pi_j-1\\}$. For $i=1$ the claim is clear. For an arbitrary $i>1$, by the induction hypothesis we have that $\\pi_{i-1}\\in\\{\\max_{j<i-1}\\pi_j+1,\\min_{j<i-1}\\pi_j-1\\}$. W.l.o.g assume that $\\pi_{i-1}=\\max_{j<i-1}\\pi_j+1$, and hence $\\pi_{i-1}>\\pi_j$ for all $j<i-1$. Therefore, since the set $\\{\\pi_1,\\ldots,\\pi_i\\}$ contains consecutive numbers, we have that either $\\pi_i>\\pi_{i-1}$, and hence $\\pi_i=\\max_{j<i}\\pi_j+1$, or $\\pi_i<\\pi_{i-1}$, and hence $\\pi_i=\\min_{j<i}\\pi_j-1$. For the case $\\pi_{i-1}=\\min_{j<i-1}\\pi_j-1$, the proof is similar, and if $\\pi\\in{\\mathcal{M}}_R$, the proof is symmetric.\n\\end{proof}\n\n\\begin{corollary}\\label{corollary:MinMaxFirstLast}\nIf $\\pi\\in{\\mathcal{M}}_L$ then $\\pi_n\\in\\{1,n\\}$, and if $\\pi\\in{\\mathcal{M}}_R$ then $\\pi_1\\in\\{1,n\\}$.\n\\end{corollary}\n\n\\begin{proof}\nIf $\\pi\\in {\\mathcal{M}}_L$, by Lemma~\\ref{lemma:consecutive} we have that $\\{\\pi_1,\\ldots,\\pi_{n-1}\\}$ is a set of consecutive numbers from $[n]$, and hence it is either $\\{1,\\ldots,n-1\\}$ or $\\{2,\\ldots,n\\}$. Therefore, $\\pi_n\\in\\{1,n\\}$. If $\\pi\\in{\\mathcal{M}}_R$, the proof is symmetric.\n\\end{proof}\n\nAlbeit the simple structure of their elements, the sets ${\\mathcal{M}}_L$ and ${\\mathcal{M}}_R$ are rather large, as shown below.\n\n\\begin{lemma}\\label{lemma:MinMaxSize}\n$|{\\mathcal{M}}_L|=|{\\mathcal{M}}_R|=2^{n-1}$.\n\\end{lemma}\n\\begin{proof}\nLet ${\\mathcal{M}}_{L,i}$ be the set ${\\mathcal{M}}_L$ for $n=i$, and let $M_{L,i}$ be its size. According to Corollary~\\ref{corollary:MinMaxFirstLast}, for any $i$, if $\\pi\\in{\\mathcal{M}}_{L,i}$ then $\\pi_i\\in\\{1,i\\}$. Therefore, $\\pi\\in{\\mathcal{M}}_{L,i}$ corresponds to exactly two permutations $\\pi^{(1)},\\pi^{(2)}\\in{\\mathcal{M}}_{L,i+1}$. The first permutation is $\\pi^{(1)}=(\\pi_1,\\ldots,\\pi_{i},i+1)$, where the second is $\\pi^{(2)}=(\\pi_1+1,\\ldots,\\pi_{i}+1,1)$. Since this mapping clearly covers the entire set ${\\mathcal{M}}_{L,i+1}$, we have that $M_{L,i+1}=2M_{L,i}$, and since $M_{L,1}=1$, the claim follows. The proof for ${\\mathcal{M}}_R$ is symmetric.\n\\end{proof}\n\n\\begin{lemma}\\label{lemma:MinMaxIntersection}\n${\\mathcal{M}}_L\\cap{\\mathcal{M}}_R=\\{(1,\\ldots,n),(n,\\ldots,1)\\}$.\n\\end{lemma}\n\n\\begin{proof}\nIf $\\pi\\in{\\mathcal{M}}_L\\cap{\\mathcal{M}}_R$, then according to Corollary~\\ref{corollary:MinMaxFirstLast} we have that $\\{\\pi_1,\\pi_n\\}=\\{1,n\\}$. By Definition~\\ref{definition:MinMax}, if $(\\pi_1,\\pi_n)=(1,n)$ then $\\pi=(1,\\ldots,n)$, and if $(\\pi_1,\\pi_n)=(n,1)$ then $\\pi=(n,\\ldots,1)$.\n\\end{proof}\n\n\\begin{corollary}\\label{corollary:MinMaxSize}\n$|{\\mathcal{M}}|=2^n-2$.\n\\end{corollary}\n\\begin{proof}\nBy Lemma~\\ref{lemma:MinMaxSize} and Lemma~\\ref{lemma:MinMaxIntersection}, $|{\\mathcal{M}}|=|{\\mathcal{M}}_L|+|{\\mathcal{M}}_R|-|{\\mathcal{M}}_L\\cap {\\mathcal{M}}_R|=2^n-2$.\n\\end{proof}\n\nThe locality of ${\\mathcal{M}}_L$ and ${\\mathcal{M}}_R$ relies on the following lemma. \n\n\\begin{lemma}\\label{lemma:MinMaxLRepair}\nIf $\\pi\\in{\\mathcal{M}}_L$, then every $\\pi_i$ is a function of at most three other symbols of $\\pi$.\n\\end{lemma}\n\\begin{proof}\nWe distinguish among the following three cases.\n\\begin{description}\n\\item[$\\mathbf{i=1}$.]We compute $\\pi_1$ from $\\pi_2$ and $\\pi_3$. Notice that by Definition~\\ref{definition:MinMax}, $|\\pi_3-\\pi_2|\\le 2$, since otherwise $\\pi_3$ does not satisfy the required condition. Given the value of $\\pi_2$, we have that either $\\pi_1=\\pi_2+1$ or $\\pi_1=\\pi_2-1$. If $\\pi_3=\\pi_2\\pm 1$, we are done. If $\\pi_3-\\pi_2=2$, then by Definition~\\ref{definition:MinMax} we have that $\\pi_3=\\max\\{\\pi_1,\\pi_2\\}+1$, and hence $\\pi_1=\\pi_2+1$. Similarly, if $\\pi_2-\\pi_3=2$ we have that $\\pi_3=\\min\\{\\pi_1,\\pi_2\\}-1$, and hence $\\pi_1=\\pi_2-1$.\n\n\\item[$\\mathbf{i=n}$.]We compute $\\pi_n$ from $\\pi_{n-1}$ and $\\pi_{n-2}$. By Corollary~\\ref{corollary:MinMaxFirstLast}, we have that $\\pi_n\\in\\{1,n\\}$, and hence, if $\\{1,n\\}\\cap \\{\\pi_{n-1},\\pi_{n-2}\\}\\ne \\varnothing$, we are done. Else, if $\\pi_{n-1}>\\pi_{n-2}$, we have that $\\pi_{n-1}>\\pi_j$ for all $j<n-1$. Since $\\pi_{n-1}$ is larger than $n-2$ numbers in $[n]$ we have that $\\pi_{n-1}\\in\\{n-1,n\\}$. Since the case $\\pi_{n-1}=n$ was already considered, we have that $\\pi_{n-1}=n-1$, and hence, $\\pi_n=n$. On the other hand, if $\\pi_{n-1}<\\pi_{n-2}$, then similarly, $\\pi_{n-1}<\\pi_j$ for all $j<n-1$, and hence $\\pi_n=1$.\n\n\\item[$\\mathbf{i\\notin\\{1,n\\}}$.]We compute $\\pi_i$ from $\\pi_{i-1},\\pi_{i+1}$, and if $i>2$ we require an arbitrary $\\pi_j$ for $j<i-1$. Let $A\\triangleq\\{\\pi_1,\\ldots,\\pi_i\\}$ and $n\\triangleq\\{\\pi_1,\\ldots,\\pi_{i-2}\\}$. According to Lemma~\\ref{lemma:consecutive} and Definition~\\ref{definition:MinMax}, if $\\pi_{i-1}<\\pi_{i+1}$ we have that $A=\\{\\pi_{i+1}-i,\\ldots,\\pi_{i+1}-1\\}$, and if $\\pi_{i-1}>\\pi_{i+1}$, we have that $A=\\{\\pi_{i+1}+1,\\ldots,\\pi_{i+1}+i\\}$. If $i=2$, and thus $n=\\varnothing$, we have that $\\pi_i$ is the only element in the singleton $A\\setminus\\{\\pi_{i-1}\\}$. Otherwise, we examine \\textit{any} $\\pi_j$ for $j<i-1$ in order to distinguish between the cases $n=\\{\\pi_{i-1}+1,\\ldots,\\pi_{i-1}+i-2\\}$ and $n=\\{\\pi_{i-1}-(i-2),\\ldots,\\pi_{i-1}-1\\}$. Knowing $n$, we have that $\\pi_i$ is the only symbol in the singleton $A\\setminus(n\\cup\\{\\pi_{i-1}\\})$.\n\\end{description}\n\\end{proof}\n\nSince permutations in ${\\mathcal{M}}_R$ are entirely symmetric to the ones in ${\\mathcal{M}}_L$, we have that by replacing $i$ for $n-i+1$ in the proof of Lemma~\\ref{lemma:MinMaxLRepair}, we are able to prove the following.\n\n\\begin{lemma}\\label{lemma:MinMaxRRepair}\nIf $\\pi\\in{\\mathcal{M}}_R$, then every $\\pi_i$ is a function of at most three other symbols of $\\pi$.\n\\end{lemma}\n\nNotice that the repair algorithms, which are induced by Lemma~\\ref{lemma:MinMaxLRepair}, slightly differ for $\\pi\\in{\\mathcal{M}}_L$ and $\\pi\\in{\\mathcal{M}}_R$. Therefore, the user must know if the stored permutation belongs to ${\\mathcal{M}}_L$ or to ${\\mathcal{M}}_R$. Clearly, this information may be stored in the system with \\textit{one} additional bit. Alternatively, it can also be differed by querying either one of $\\pi_1,\\pi_n$, as shown in the following lemma. \n\n\n\n\n\n\n\n\\begin{lemma}\\label{lemma:MinMaxID}\nFor $\\pi\\in{\\mathcal{M}}$, if $\\pi_1\\notin\\{1,n\\}$ then $\\pi\\in{\\mathcal{M}}_L$, and if $\\pi_1\\in\\{1,n\\}$ then $\\pi\\in{\\mathcal{M}}_R$. Similarly, if $\\pi_n\\notin\\{1,n\\}$ then $\\pi\\in{\\mathcal{M}}_R$, and if $\\pi_n\\in\\{1,n\\}$ then $\\pi\\in{\\mathcal{M}}_L$.\n\\end{lemma}\n\n\\begin{proof}\nIf $\\pi_1\\notin\\{1,n\\}$ then by Corollary~\\ref{corollary:MinMaxFirstLast} we have that $\\pi\\notin{\\mathcal{M}}_R$, and hence $\\pi\\in{\\mathcal{M}}_L$. On the other hand, if $\\pi_1\\in\\{1,n\\}$ then $\\pi$ may be either in ${\\mathcal{M}}_L$ or in ${\\mathcal{M}}_R$. However, if $\\pi\\in{\\mathcal{M}}_L$ and $\\pi_1\\in\\{1,n\\}$, it follows by Definition~\\ref{definition:MinMax} that either $\\pi=(1,\\ldots,n)$ or $\\pi=(n,\\ldots,1)$, which by Lemma~\\ref{lemma:MinMaxIntersection} implies that $\\pi\\in{\\mathcal{M}}_R$. The second part of the proof is symmetric.\n\\end{proof}\n\nAs a corollary of Lemma~\\ref{lemma:MinMaxLRepair}, Lemma~\\ref{lemma:MinMaxRRepair}, and Lemma~\\ref{lemma:MinMaxID}, we have the following.\n\n\\begin{corollary}\nIf $\\pi\\in{\\mathcal{M}}$, then every $\\pi_i$ is a function of at most four other symbols of $\\pi$.\n\\end{corollary}\n\nIn the sequel we analyse patterns of erasures that can be corrected simultaneously. To this end, we devise the following graph $G$ (Figure~\\ref{figure:MinMaxDependency}), which follows from Lemma~\\ref{lemma:MinMaxLRepair}.\n\n\n\n\n\nThe vertices of $G$ correspond to subsets of locations in the permutation, where we denote $i$ instead of $\\{i\\}$ for convenience. A directed edge $(i,S)$ exists if the repair of $\\pi_i$ requires precisely one (arbitrary) symbol $\\pi_j,~j\\in S$. An analogue graph may be achieved for $\\pi\\in{\\mathcal{M}}_R$ by replacing $i$ for $n-i+1$ in each set.\n\n\\begin{center}\n\\begin{figure}[here]\n\\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.6cm,y=0.6cm]\n\n\\clip(0.8,1.8) rectangle (31.,9.45);\n\\draw(5.,3.) circle (0.5cm);\n\\draw (5,3) node[anchor=center] {$1$};\n\\draw(3.,7.) circle (0.5cm);\n\\draw (3,7) node[anchor=center] {$2$};\n\\draw(7.,7.) circle (0.5cm);\n\\draw (7,7) node[anchor=center] {$3$};\n\\draw(11.,7.) circle (0.5cm);\n\\draw (11,7) node[anchor=center] {$4$};\n\\draw(11.,3.) circle (0.5cm);\n\\draw (11,3) node[anchor=center] {$[2]$};\n\\draw(15.,7.) circle (0.5cm);\n\\draw (15,7) node[anchor=center] {$5$};\n\\draw(15.,3.) circle (0.5cm);\n\\draw (15,3) node[anchor=center] {$[3]$};\n\\draw(21.,7.) circle (0.6cm);\n\\draw (21,7) node[anchor=center] {$n-2$};\n\\draw(25.,7.) circle (0.6cm);\n\\draw (25,7) node[anchor=center] {$n-1$};\n\\draw(29.,7.) circle (0.5cm);\n\\draw (29,7) node[anchor=center] {$n$};\n\\draw(21.,3.) circle (0.7cm);\n\\draw (21,3) node[anchor=center] {$[n-4]$};\n\\draw(25.,3.) circle (0.7cm);\n\\draw (25,3) node[anchor=center] {$[n-3]$};\n\\draw [->] (6.,7.5) -- (4.,7.5);\n\\draw [->] (4.,6.5) -- (6.,6.5);\n\\draw [->] (6.,7.5) -- (4.,7.5);\n\\draw [->] (4.,6.5) -- (6.,6.5);\n\\draw [->] (10.,7.5) -- (8.,7.5);\n\\draw [->] (8.,6.5) -- (10.,6.5);\n\\draw [->] (10.,7.5) -- (8.,7.5);\n\\draw [->] (8.,6.5) -- (10.,6.5);\n\\draw [->] (14.,7.5) -- (12.,7.5);\n\\draw [->] (12.,6.5) -- (14.,6.5);\n\\draw [->] (14.,7.5) -- (12.,7.5);\n\\draw [->] (12.,6.5) -- (14.,6.5);\n\\draw [->] (24.,7.5) -- (22.,7.5);\n\\draw [->] (22.,6.5) -- (24.,6.5);\n\\draw [->] (24.,7.5) -- (22.,7.5);\n\\draw [->] (22.,6.5) -- (24.,6.5);\n\\draw [->] (28.,7.5) -- (26.,7.5);\n\\draw [->] (26.,6.5) -- (28.,6.5);\n\\draw [->] (28.,7.5) -- (26.,7.5);\n\\draw [->] (26.,6.5) -- (28.,6.5);\n\\draw [->] (11,6) -- (11,4);\n\\draw [->] (15,6) -- (15,4);\n\\draw [->] (21,5.85) -- (21,4.25);\n\\draw [->] (25,5.85) -- (25,4.25);\n\\draw [->] (2.5,6.) -- (4.30209652225,3.71619182888);\n\n\n\\draw [->] (5,4) -- (3.5,6);\n\\draw [->] (5,4) -- (6.5,6);\n\\draw [->] (7.5,6.) -- (5.70710678119,3.70710678119);\n\\draw [shift={(25,4)}] plot[domain=0.842135259481:2.30056253786,variable=\\t]({1.*5.43873484651*cos(\\t r)+0.*5.43873484651*sin(\\t r)},{0.*5.43873484651*cos(\\t r)+1.*5.43873484651*sin(\\t r)});\n\\draw [dash pattern=on 2pt off 2pt] (16.25,7.)-- (19.75,7.);\n\\draw [dash pattern=on 2pt off 2pt] (16.25,3.)-- (19.5,3.);\n\\draw [->] (21.530510491,8.18885518618) -- (21.3773478494,8.05714611287);\n\\end{tikzpicture}\\caption{The dependency graph between the symbols of a MinMax permutation $\\pi\\in{\\mathcal{M}}_L$. Nodes represent subsets of symbol locations, where $\\{i\\}$ is denoted by $i$. An edge $(i,S)$ indicates that the repair of symbol $\\pi_i$ requires exactly one arbitrary symbol $\\pi_j,j\\in S$.}\\label{figure:MinMaxDependency}\n\\end{figure}\n\\end{center}\n\nFor a vertex $v$ in $G$ which corresponds to a singleton, let $\\Gamma(v)$ be its set of outgoing neighbors. A vertex $u$ which corresponds to a subset $S$ is called \\textit{active}, if there exists $j\\in S$ such that $\\pi_j$ is available to the user. According to Lemma~\\ref{lemma:MinMaxLRepair}, a symbol $\\pi_i$ is repairable if all nodes in $\\Gamma(i)$ are active. The following lemma presents the sets of erasures that may be simultaneously corrected. A symmetric analogue of Lemma~\\ref{lemma:MinMaxPath} for $\\pi\\in{\\mathcal{M}}_R$ may be proved similarly.\n\n\\begin{lemma}\\label{lemma:MinMaxPath}\nGiven a set of erased symbols, a permutation $\\pi\\in{\\mathcal{M}}_L$ can be reconstructed if every path of erased symbols in $G$ is finite, and terminates with a node $i$ such that every node in $\\Gamma(i)$ is active. \n\\end{lemma}\n\n\\begin{proof}\nAssume that $\\{\\pi_i\\}_{i\\in E}$ is a set of missing symbols, such that every path in $G$ whose vertex set is contained in $E$, terminates with a node $i$ such that $\\Gamma(i)$ are active. Using induction on the maximum length of those paths, we get that $\\pi$ can be reconstructed. If this maximum length is 1, $\\pi$ clearly can be reconstructed. If it is greater than $1$, we may repair all terminal nodes in all maximum length paths, and use the induction hypothesis.\n\\end{proof}\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Efficient Representation of Permutations}\\label{section:efficient}\n\\subsection{Light Permutations by the Infinity Norm - An Alternative Representation}\\label{section:LinfAlternative}\nA permutation $\\pi\\in{\\mathcal{B}}_r$ can be mapped to a list of size $n$, which indicates the displacement $\\pi(i)-i$ for each $i\\in[n]$. This mapping, denoted by $s(\\pi)$, requires $n(\\log r+1)$ bits. By storing this representation rather then the one-liner, we may answer Q2 simply by inspecting $s(\\pi)_i$ and returning $i+s(\\pi)_i$. Since permutations in ${\\mathcal{B}}_r$ involve small-magnitude shifts, to answer Q1 we may look at $s(\\pi)_j$ for $j\\in\\{i-r,\\ldots,i+r-1\\}$, return the unique $j$ such that $j+s(\\pi)_j=i$, or return $i+r$ if no such $j$ exists. The equivalent claims of Lemma~\\ref{lemma:LinfRepair} and Lemma~\\ref{lemma:LinfReconstruct} are given below.\n\n\\begin{lemma}\\label{lemma:LinfAlternativeRepair}\nIf $\\pi\\in{\\mathcal{B}}_r$ then for all $j\\in[n]$, $s(\\pi)_j$ is a function of $s(\\pi)_{j-2r},\\ldots,s(\\pi)_{j-1},s(\\pi)_{j+1},\\ldots,$  $s(\\pi)_{j+2r}$.\n\\end{lemma}\n\n\\begin{proof}\nThe missing entry $s(\\pi)_j$, specifying the shift of the element $j$, is computed by maintaining a binary array $A$ which indicates which are the known ``occupied'' positions in the one-liner of $\\pi$. Once we are left with a single non-occupied position $A_\\ell$ for some $\\ell$, we infer that element $j$ could only be located at $\\ell$, and compute its shift.\n\nFormally, initialize an array $A$ of $2r+1$ zeros, whose entries are indexed by $\\{j-r,\\ldots,j,\\ldots,j+r\\}$, which are all possible positions of $j$. Set entry $A_i$ to one if and only if there exists $t\\in\\{j-2r,\\ldots,j-1,j+1,\\ldots,j+2r\\}$ such that $t+s(\\pi)_t=i$. Consequently, entry $A_i$ will indicate if one of the elements $\\{j-2r,\\ldots,j-1,j+1,j+2r\\}$, whose location is known from $s(\\pi)_{j-2r},\\ldots,s(\\pi)_{j-1},s(\\pi)_{j+1},\\ldots,s(\\pi)_{j+2r}$, is located in position $i$. \n\nSince $\\pi\\in{\\mathcal{B}}_r$, for each $i\\in\\{j-r,\\ldots,j,\\ldots,j+r\\}$ there exist a unique $t\\in\\{j-2r,\\ldots,j,\\ldots,j+2r\\}$ such that $t+s(\\pi)_t=i$. Therefore, there exists a unique entry $\\ell$ in $A$ which remains zero, and hence, $s(\\pi)_{j}=\\ell-j$.\n\\end{proof}\n\n\\begin{lemma}\\label{lemma:LinfAlternativeReconstruction}\nIf $\\pi\\in {\\mathcal{B}}_r$, then any set of erasures in $s(\\pi)$, in which any two are separated by at least $2r-1$ non-erased symbols, can be corrected.\n\\end{lemma}\n\n\\begin{proof}\nAs in the proof of Lemma~\\ref{lemma:LinfAlternativeRepair}, we use an auxiliary array whose entries specify which are the occupied positions in the one-liner of $\\pi$.\n\nInitialize an array $A$ of $n$ zeros, and for each non-erased symbol $s(\\pi)_j$ set $A_{s(\\pi)_j+j}$ to one. Let $E=\\{u_i\\}_{i=1}^t$ be the set of indices of zeros in $A$, that is, $A_\\ell=0$ if and only if $\\ell\\in E$, and notice that the number of zeros in $A$ equals the number of erasures. For each $i\\in[t]$ define the radius of possibility $R(i)\\triangleq\\left\\{\\max\\{u_i-\\ell,1\\}\\right\\}_{\\ell=r}^{-r}$ (radius, in short). Clearly, if there exists a single erasure among $\\{s(\\pi)_\\ell~\\vert~\\ell\\in R(i)\\}$, say in $s(\\pi)_{\\ell_0}$, then it may be corrected to $u_i-\\ell_0$. Hence, it suffices to show that for any $t$, there exists an $i\\in[t]$ such that there is a single erasure among $\\{s(\\pi)_\\ell~\\vert~\\ell\\in R(i)\\}$.\n\nAssume for contradiction that all radii contain at least two erasures. Since any two erasures have at least $2r-1$ non-erased symbol between them, and since all radii consist of $2r+1$ consecutive integers, we have that each radius contains \\textit{exactly} two erasures. Now let $e_1<\\ldots<e_t$ be the indices of the erasures in $s(\\pi)$, and notice that each radius must contain exactly $e_i$ and $e_{i+1}$ for some $i\\in[t-1]$. Therefore, the maximum number of radii is $t-1$, a contradiction.\n\\end{proof}\n\n\\subsection{Supporting Arbitrary Powers - a framework}\\label{section:powers}\nIn this section we present a framework for storing a permutation $\\pi$ from a set $T$, while allowing the user to query $\\pi^{k}(i)$ for any $i\\in[n]$ and any integer $k$ (positive or negative, where $\\pi^0(i)=i$ for all $i\\in[n]$). This framework will be presented with respect to a general set $T$, and the properties of the resulting system will depend on the specific choice of $T$.\n\nThis framework is strongly based on~\\cite{MunroSuccinct}, which provides an algorithm for representing any permutation $\\pi\\in S_n$. In~\\cite{MunroSuccinct}, the queries $\\pi^k(i)=?$ are answered using a \\textit{rank-select} data structure which is maintained separately from $\\pi$. This data structure requires as much as $n+o(n)$ additional bits of storage, and is required in its entirety for any operation. For this reason, we modify the techniques of~\\cite{MunroSuccinct} to achieve a scheme which is applicable for distributed storage systems. In addition, to obtain locality, this scheme can be combined with the techniques that were developed in earlier sections.\n\nA permutation $\\pi\\in S_n$ may be given in its disjoint cycle representation. This representation is not unique, as each cycle may be cyclically shifted, and cycles may be permuted. For a disjoint cycle representation $y(\\pi)$ of a permutation $\\pi$, let $\\overline{y(\\pi)}$ denote the string obtained by omitting all brackets from $y(\\pi)$, e.g.,\n\\begin{eqnarray*}\ny(\\pi) &=& (1 2 3)(4 5)\\\\\n\\overline{y(\\pi)} &=& 1~2~3~4~5.\n\\end{eqnarray*}\nClearly, $\\overline{y(\\pi)}$ may be considered as a one-liner of a different permutation. Relying on this principle, we present a framework for storing permutations.\n\nLet $S\\subseteq S_n$ be a set of permutations with locality $d$, enabling an answer for Q1 by downloading $q_1$ symbols, and an answer for Q2 by downloading $q_2$ symbols. In addition, let $t$ be the maximum length of a cycle in a permutation in $S$. Let $\\gamma(S)$ be the set of all permutations $\\pi\\in S_n$ that have a disjoint cycle representation $y(\\pi)$, such that the one-liner $\\overline{y(\\pi)}$ is in $S$. That is,\n\n\\begin{eqnarray*}\n\\gamma(S)\\triangleq\\left\\{ \\pi\\in S_n~\\vert~\\exists y(\\pi)~\\mbox{ s.t. } \\overline{y(\\pi)}\\in S\\right\\}.\n\\end{eqnarray*}\n\nNotice that $S$ and $\\gamma(S)$ are not equal. E.g., for $n=4$, by Corollary~\\ref{corollary:MinMaxSize} there are 14 MinMax permutations, but a simple computer search shows that 23 permutations $\\pi\\in S_4$ have a disjoint cycle representation $y(\\pi)$ such that $\\overline{y(\\pi)}$ is a one-liner of a MinMax permutation. \n\nWe encode a permutation $\\pi\\in\\gamma(S)$ to a sequence of $n$ triples $\\{(\\psi_i,c_i,\\ell_i)\\}_{i=1}^n$, where for all $i$, $\\psi_i\\in [n]$ and $c_i,\\ell_i\\in[t]$. Each triple is then placed in a storage node. Let $i_1,i_2,\\ldots$ be integers such that the representation\n\\begin{eqnarray*}\ny(\\pi)=(i_1,\\pi(i_1),\\pi^2(i_1),\\ldots)(i_2,\\pi(i_2),\\pi^2(i_2),\\ldots)\\ldots\n\\end{eqnarray*}\nsatisfies $\\overline{y(\\pi)}\\in S$, and let $\\psi\\in S$ be the permutation whose one-liner is $\\overline{y(\\pi)}$. That is,\n\\begin{eqnarray*}\n\\psi=(\\psi_1,\\ldots,\\psi_n)\\triangleq (i_1,\\pi(i_1),\\pi^2(i_1),\\ldots,i_2,\\pi(i_2),\\pi^2(i_2),\\ldots).\n\\end{eqnarray*}\nFor a symbol $\\psi_i$, let $c_i$ be the length of the cycle in $y(\\pi)$ that contains $\\psi_i$, and let $\\ell_i$ be the location of $\\psi_i$ in this cycle. \n\nIf node $v_i$ fails, use the repair algorithm for $S$ to obtain $\\psi_i$. In addition, download $c_{i-1},\\ell_{i-1},c_{i+1},\\ell_{i+1}$  from nodes $v_{i-1},v_{i+1}$ and obtain $c_i,\\ell_i$ by the following guidelines.\n\\begin{eqnarray*}\n\\mbox{if }c_{i-1}&=&\\ell_{i-1}\\mbox{ then } \n\\begin{cases}\nc_i=\\ell_i=1 & \\mbox{if }\\ell_{i+1}=1\\\\\nc_i=c_{i+1},~\\ell_i=1 & \\mbox{if }\\ell_{i+1}\\ne 1\n\\end{cases}, \\mbox{ and}\\\\\n\\mbox{if }c_{i-1}&\\ne&\\ell_{i-1}\\mbox{ then } c_i=c_{i-1},~\\ell_i=\\ell_{i-1}+1.\n\\end{eqnarray*}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{lemma}\\label{lemma:PowersAlg}\nThis system is capable of providing $\\pi^k(i)$ for any $\\pi\\in S_n$, $i\\in[n]$, and any integer $k$ by downloading $(q_1+q_2)\\log n + 2\\log t$ bits.\n\\end{lemma}\n\n\\begin{proof}\nGiven $i$ and $k$, perform the following algorithm.\n\\begin{enumerate}\n\\item Find $j\\triangleq\\psi(i)$ by downloading $q_1\\log n$ bits.\n\\item Download $c_j$ and $\\ell_j$ from $v_j$ ($2\\log t$ bits).\n\\item Compute $s\\triangleq j-\\ell_j+(\\ell_j+k)_{\\mod c_j}$.\n\\item Return $\\psi_s=\\psi^{-1}(s)$ by downloading $q_2\\log n$ bits.\n\\end{enumerate}\nClearly, these steps require downloading $(q_1+q_2)\\log n + 2\\log t$ bits. We are left to show that $\\psi_s=\\pi^k(i)$. Step 1 of the algorithm provides the \\textit{location} of symbol $i$ in the one-liner $\\psi$, since $\\psi_j=\\psi^{-1}(j)=i$. In step 3, the expression $j-\\ell_j$ is the starting point of the cycle which contains symbol $i$, and by adding $(\\ell_j+k)_{\\mod c_j}$ we have the location $s$ of the element $\\pi^k(i)$. \n\\end{proof}\n\n\\begin{example}\nLet $y(\\pi)=(1~0~2)(4~3~5)(7~6)$ be a disjoint cycle representation of a permutation $\\pi$ on eight elements. Clearly, $\\overline{y(\\pi)}=1~0~2~4~3~5~7~6$ is a one-liner of a permutation $\\psi\\in{\\mathcal{B}}_\\infty(e,1)={\\mathcal{B}}_1$ (see Section~\\ref{section:Linf}), and thus $q_1=1$ and $q_2=2$. The permutation $\\pi$ is stored on $v_0,\\ldots,v_7$ as follows.\n\\begin{center}\n\\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|}\n\\hline\n~&$v_0$&$v_1$&$v_2$&$v_3$&$v_4$&$v_5$&$v_6$&$v_7$ \\\\ \\hline\\hline\n$\\psi_i$ & 1 & 0 & 2 & 4 & 3 & 5 & 7 & 6 \\\\ \\hline\n$c_i$    & 3 & 3 & 3 & 3 & 3 & 3 & 2 & 2 \\\\ \\hline\n$\\ell_i$ & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 \\\\ \\hline\n\\end{tabular}\n\\end{center}\n\nFor example, follow the algorithm in Lemma~\\ref{lemma:PowersAlg} for answering $\\pi^2(3)$ (that is, $i=3$ and $k=2$). Using the algorithm for ${\\mathcal{B}}_1$, in step 1 the user finds the location of $3$ in the one-liner, which is $j=4$. The user later downloads $(c_4,\\ell_4)=(3,1)$ from $v_4$, computes $s=4-1+(1+2)_{\\mod 3}=3$. In step 4 the user downloads $\\psi_3=4$ from $v_3$, which equals $\\pi^2(3)$.\n\\end{example}\n\nThe obvious drawback of this system is the large storage overhead of $2n\\log t$, on top of the $n\\log n$ bits which are required to store $\\psi$. With no known restriction on $t$, the total storage in this system is approximately $3n\\log n$. However, a considerable advantage is the ability to obtain any power of the stored permutation, with a small computational overhead. \n\nFor a given set $S\\subseteq S_n$, natural questions to ask are what is the size of $\\gamma(S)$, and what is the structure of the permutations in $\\gamma(S)$. The answers to these two questions seem rather involved. Therefore, in Table~\\ref{table:sizes} we provide an insight towards the answer to the former, using a computer search, and for small values of $n$. It is evident from this table that the size of $\\gamma(S)$ is most likely much larger than the size of $S$.\n\\begin{table}[h]\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|c|c|c|c|}\n\\hline\n$n$ & $n!$ & $|{\\mathcal{M}}|$  (Definition~\\ref{definition:MinMax}) & $|\\gamma({\\mathcal{M}})|$ & $|{\\mathcal{B}}_1|$ (Definition~\\ref{definition:dInf}) & $|\\gamma({\\mathcal{B}}_1)|$ & $|{\\mathcal{B}}_2|$ & $|\\gamma({\\mathcal{B}}_2)|$\n\\\\ \\hline\n3 & 6     & 6   & 6    & 3  & 6     & 6   & 6\\\\ \\hline\n4 & 24    & 14  & 23   & 5  & 22    & 14  & 24\\\\ \\hline\n5 & 120   & 30  & 99   & 8  & 66    & 31  & 117\\\\ \\hline\n6 & 720   & 62  & 400  & 13 & 192   & 73  & 567\\\\ \\hline\n7 & 5040  & 126 & 1532 & 21 & 560   & 172 & 2371\\\\ \\hline\n8 & 40320 & 254 & 5713 & 34 & 1660  & 400 & 9262\\\\ \\hline\n\\end{tabular}\n\\caption{Sizes of certain permutations sets for small values of $n$.}\\label{table:sizes}\n\\end{center}\n\\end{table}\n\n\\subsection{Beating LRCs - a proof of concept}\\label{section:beating}\nConsider the scenario in which we would like to store \\textit{any} permutation using minimal redundancy. A possible simple solution is to use LRCs (Subsection~\\ref{section:previousWork}), which will require at least $\\frac{n}{d}$ additional symbols, or $\\frac{n}{d}\\log n$ additional bits, according to~\\eqref{equation:LRCRateBound}. This minimal redundancy may be achieved by adding a ``parity check'' symbol for any of $n/d$ disjoint $d$-subsets of symbols. In this section, it is shown that the fact that we are operating over permutations may be utilized to reduce the redundancy for $d\\in\\{2,3\\}$. Although the improvement is negligible, it may be shown to achieve the information theoretic lower bound, and may constitute a proof of concept for future research.\n\nFor locality $d=2$, we present the following storage scheme, where we assume for simplicity that $n$ is even. To store a permutation $\\pi\\in S_n$, encode it as follows\n\\begin{eqnarray*}\n(\\pi_1,\\ldots,\\pi_n)\\mapsto(\\sigma_1,\\ldots,\\sigma_{n+n/2})\\triangleq(\\pi_1,\\ldots,\\pi_n,\\pi_1-\\pi_2,\\pi_3-\\pi_4,\\ldots).\n\\end{eqnarray*}\n\nNotice that since $\\pi$ is a permutation, each of the elements $\\sigma_{n+1},\\ldots,\\sigma_{n+n/2}$ may be represented using $\\log(n-1)$ bits. For each $i\\in\\{1,\\ldots,\\ceil{n/2}\\}$, any one erasure from $\\{\\sigma_{2i},\\sigma_{2i-1},\\sigma_{n+i}\\}$ can be repaired using the other two non-erased symbols.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor locality $d=3$, we assume that $n$ is a power of prime and the entries $\\{0,1,\\ldots,n-1\\}$ of the permutation are the elements of the finite field ${\\mathbb{F}}_n$. We use the function $f(x,y,z)=\\frac{x-y}{z-y}$, and the following lemma.\n\n\\begin{lemma}\\label{lemma:fDistinct3}\nFor field elements $a_1,a_2,a_3$, $f(a_1,a_2,a_3)\\in\\{2,\\ldots,n-1\\}$ if and only if $a_1,a_2,a_3$ are distinct.\n\\end{lemma}\n\n\\begin{proof}\nIf $f(a_1,a_2,a_3)\\in\\{2,\\ldots,n-1\\}$ then $f$ is well-defined over $(a_1,a_2,a_3)$, and hence $a_2\\ne a_3$. In addition, if $a_1= a_2$ then $f(a_1,a_2,a_3)=0$, and similarly, if $a_1=a_3$ then $f(a_1,a_2,a_3)=1$. Hence, $a_1,a_2,a_3$ are distinct. Conversely, if $a_1,a_2,a_3$ are distinct, then $f(a_1,a_2,a_3)$ is well-defined, and cannot output neither 0 nor 1.\n\\end{proof}\n\nAccording to Lemma~\\ref{lemma:fDistinct3}, when $f$ is applied over a subset of symbols of a permutation, the result may be represented by $\\log(n-2)$ bits. This gives rise to the following scheme. For simplicity assume that $3\\vert n$, although this scheme may be slightly changed to fit any prime power. To store $\\pi\\in S_n$, encode it as follows\n\\begin{eqnarray*}\n(\\pi_1,\\ldots,\\pi_n)\\mapsto(\\sigma_1,\\ldots,\\sigma_{n+n/3})\\triangleq\\left(\\pi_1,\\ldots,\\pi_n,f(\\pi_1,\\pi_2,\\pi_3),\\ldots,f(\\pi_{n-2},\\pi_{n-1},\\pi_n)\\right).\n\\end{eqnarray*}\n\nClearly, for each $i\\in\\{1,\\ldots,n/3\\}$, any one erasure from $\\{\\sigma_{3i},\\sigma_{3i-1},\\sigma_{3i-2},\\sigma_{n+i}\\}$ can be repaired using the other three non-erased symbols.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe above schemes use $n\\log n+\\frac{n}{d}\\log(n-d+1)$ bits to store the $n\\log n$ bits of \\textit{any} permutation~$\\pi$, for $d\\in\\{2,3\\}$. For comparison, using the corresponding LRC requires $n\\log n+\\frac{n}{d}\\log n$ bits.\n\nClearly, over an alphabet of size $n$, the information theoretic bound on the amount of required redundancy for a one-erasure correcting code is $\\log n$. Note that with the additional assumption that the string contains $d$ distinct symbols, this bound reduces to $\\log(n-d+1)$. The latter bound is achieved by the above schemes for $d\\in\\{2,3\\}$. We conjecture that for any $d$, there exists a proper redundancy function $f$ which allows one-erasure correction. That is, the function $f$ provides output from a set of size $n-d+1$, when applied over inputs that contain distinct values. In addition, the improvement in the case of minimal redundancy is highly negligible, and we assume that this could be improved for larger redundancy.\n\n\\section{Discussion and Open Problems}\\label{section:discussion}\nIn this paper we discussed locality in permutations, motivated by applications in distributed storage. We have discussed two aspects of this problem, the combinatorial one and the coding one. In the combinatorial aspect, we discussed locality in permutations without any encoding, and in the coding aspect we allowed the permutation to be encoded in order to obtain this locality. \n\nIn the combinatorial aspect, we provided upper and lower bound for the maximal size of a set of permutations with locality, provided several simple constructions with high rate, and several interesting constructions with low rate. In the coding aspect we presented a method of encoding certain permutations in order to obtain locality, and to support arbitrary powers of the permutation. We have concluded with a proof of concept which shows that any permutation may be stored with smaller redundancy than an ordinary string.\n\nThroughout the paper we assumed that low query complexity is to be maintained. Clearly, if no such constraint is assumed, any permutation can be represented using $\\ceil*{\\log(n!)}$ bits, and stored using an LRC. However, when a query complexity requirement is imposed, there seems to be much more to be studied, and our results are hardly adequate comparing with the potential possibilities. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor simplicity, we assumed that each node stores a single symbol from~$[n]$, and focused on symbol locality. This convention may be adjusted to achieve storage systems with different parameters. E.g., in Subsection~\\ref{section:concatenation} we considered permutation that can be considered as a concatenation of permutations on $h$ elements. These permutations may alternatively be stored on $h$ nodes, where node $i$ stores all $i$-th elements of the concatenated permutations. In this system any single node failure may be corrected by downloading the content of all other nodes. To achieve better locality, the data may be partitioned among a larger number of nodes. Techniques such as this open a gateway towards the equivalent of \\textit{array codes} for permutations, which constitutes a vast area for future consideration as well.\n\nFinally, we list herein a few specific open problems which were left unanswered in this paper.\n\n\\begin{enumerate}\n\\item Close the gap between the upper bound in Theorem~\\ref{theorem:bound} and the lower bound in Theorem~\\ref{theorem:lowerBound}, potentially by using the methods of Theorem~\\ref{theorem:bound1}.\n\\item Provide an explicit construction of sets with constant locality $d\\ge 2$ and optimal rate $\\frac{d}{d+1}$. The existence of these sets is guaranteed by Theorem~\\ref{theorem:lowerBound}.\n\n\\item Find the connection between a set of permutations $S$ and its corresponding $\\gamma(S)$ (Section~\\ref{section:powers}).\n\\item Find a proper ``parity'' function $f$ for any $d$ in Section~\\ref{section:beating}.\n\\item Find additional large sets of permutations that have good locality.\n\\item Explore the locality of permutations under different representation techniques.\n\\item Endow $S_n$ with one of many possible metrics, and explore the locality of codes with a good minimum distance by this metric.\n\\end{enumerate}\n\n\\section*{Acknowledgments}\n\tThe work of Netanel Raviv was supported in part by the Aharon and Ephraim Katzir study grant, the IBM Ph.D. fellowship, and the Israeli Science Foundation (ISF), Jerusalem, Israel, under Grant no.~10/12. The authors would like to thank Ahmad Beirami for fruitful discussions.\n\n\\begin{thebibliography}{10}\n\\bibitem{Alon}\nN.~Alon and J.~H.~Spencer, ``The probabilistic method'', John Wiley \\& Sons, 2004.\n\n\n\n\n\\bibitem{Barg}\nA.~Barg and A.~Mazumdar, ``Codes in permutations and error correction for rank modulation'', \\textit{IEEE Transactions on Information Theory}, vol.~56, no.~7, pp.~3158--3165, 2010.\n\n\\bibitem{Incremental1}\nM.~Bellare, O.~Goldreich, and S.~Goldwasser, ``Incremental cryptography: The case of hashing and signing'', \\textit{Advances in Cryptology (CRYPTO)}, Springer Berlin Heidelberg, pp.~216--233, 1994.\n\n\\bibitem{Incremental2}\nM.~Bellare, O.~Goldreich, and S.~Goldwasser, ``Incremental cryptography and application to virus protection'', \\textit{ACM 27th Annual Symposium on Theory of Computing (STOC)}, pp.~45--56, 1995.\n\n\\bibitem{PermutationsHamming}\nI.~F.~Blake, G.~Cohen, and M.~Deza, ``Coding with permutations'', \\textit{Information and Control}, vol.~43, no.~1, pp.~1--19, 1979.\n\n\\bibitem{Bona}\nM.~B\\'{o}na, ``Combinatorics of permutations'', CRC Press, 2012.\n\n\\bibitem{SaritAndEitan}\nS.~Buzaglo and E.~Yaakobi, ``On the capacity of constrained permutation codes for rank modulation'', \\emph{Submitted to IEEE Transactions on Information Theory.}\n\n\\bibitem{powerline}\nW.~Chu, C.~J.~Colbourn, and P.~Dukes, ``Constructions for permutation codes in powerline communications'', \\textit{Designs, Codes and Cryptography}, vol.~32, no.~1-3, pp.~51--64, 2004.\n\n\\bibitem{Cooper}\nC.~Cooper, ``A lower bound for the number of good permutations'', \\textit{Data Recording, Storage and Processing} (Nat. Acad. Sci. Ukraine), vol.~213, pp.~15--25, 2000.\u00e2\u0080\u008f\n\n\\bibitem{DezaSurvey}\nM.~Deza and T.~Huang, ``Metrics on permutations, a survey'', \\textit{Journal of Combinatorics}, Information and System Sciences, 1998.\n\n\\bibitem{DummitAndFoote}\nD.~S.~Dummit and R.~M.~Foote, ``Abstract algebra'', Englewood Cliffs, N.J.: Prentice Hall, 1991.\n\n\\bibitem{additiveTriples}\nS.~Eberhard, F.~Manners, and R.~Mrazovi\\'{c}, ``Additive triples of bijections, or the toroidal semiqueens problem'', \\textit{arXiv:1510.05987}, 2015.\u00e2\u0080\u008f\n\n\\bibitem{Ulam1}\nF.~Farnoud, V.~Skachek, and O.~Milenkovic, ``Error-correction in flash memories via codes in the Ulam metric'', \\textit{IEEE Transactions on Information Theory}, vol.~59, no.~5, pp.3003--3020, 2013.\n\n\\bibitem{erasures}\nR.~Gabrys, E.~Yaakobi, F.~Farnoud, J.~Bruck, ``Codes correcting erasures and deletions for rank modulation'', \\textit{IEEE International Symposium on Information Theory (ISIT)}, pp.~2759--2763, 2014.\n\n\n\n\n\n\n\n\n\n\n\\bibitem{Kamath}\nN.~Prakash, G.~M.~Kamath, V.~Lalitha, and P.~V.~Kumar, ``Optimal linear codes with a local-error-correction property''.\\textit{IEEE International Symposium on Information Theory (ISIT)}, pp.~2776--2780, 2012.\n\n\\bibitem{Konstantinova}\nE.~Konstantinova, V.~Levenshtein, and J.~Siemons, ``Reconstruction of permutations distorted by single transposition errors'', \\textit{arXiv:math/0702191}, 2007.\n\n\n\n\n\\bibitem{McEliese}\nR.~J.~McEliece, ``A public-key cryptosystem based on algebraic coding theory'', \\textit{DSN progress report }42.44 (1978): 114-116.\n\n\\bibitem{McKay}\nB.~D.~McKay, J.~C.~McLeod, and I.~M.~Wanless, ``The number of transversals in a Latin square'', \\textit{Designs, Codes and Cryptography} vol.~40, no.~3, pp.269--284, 2006.\u00e2\u0080\u008f\u00e2\u0080\u008f\n\n\\bibitem{MunroSuccinct}\nJ.~I.~Munro, R.~Raman, V.~Raman, and S.~Rao, ``Succinct representations of permutations and functions'', \\textit{Theoretical Computer Science}, vol.~438, pp.~74--88, 2012.\n\n\\bibitem{Succincter}\nM.~Patrascu, ``Succincter'', \\textit{49th Annual IEEE Symposium on Foundations of Computer Science (FOCS)}, pp.~305--313, 2008.\n  \n\\bibitem{Synchronizing}\nS.~E.~Rouayheb, S.~Goparaju, H.~M.~Kiah, and O.~Milenkovic, ``Synchronizing edits in distributed storage networks''. \\textit{arXiv:1409.1551}, 2014.\n\n\\bibitem{Moshe1}\nM.~Schwartz, ``Efficiently computing the permanent and Hafnian of some banded Toeplitz matrices'', \\textit{Linear Algebra and its Applications}, vol.~430, no~.4, pp.~1364--1374, 2009.\n\n\\bibitem{family}\nI.~Tamo and A.~Barg, ``A family of optimal locally recoverable codes'', \\textit{IEEE Transactions on Information Theory}, vol.~60, no~.8, pp.~4661--4676, 2014.\n\n\\bibitem{LimitedMagnitude}\nI.~Tamo and M.~Schwartz, ``Correcting limited-magnitude errors in the rank-modulation scheme'', \\textit{IEEE Transactions on Information Theory}, vol.~56, no.~6, pp.2551--2560, 2010\u00e2\u0080\u008f.\n\n\\bibitem{LongMDS}\n{I. Tamo, Z. Wang, and J. Bruck,}\n``Long MDS codes for optimal repair bandwidth'', \\textit{IEEE International Symposium on Information Theory (ISIT)}, pp. 1182--1186, 2012.\n\n\\bibitem{automata}\nA.~Wu, A.~Rosenfeld, ``Cellular graph automata. I. basic concepts, graph property measurement, closure properties'', \\textit{Information and Control}, vol.~42, no.~3, pp~305--329, 1979.\n\n\\end{thebibliography}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "Hence, the construction in the following lemma may be seen as a generalization of the construction from Subsection~\\ref{section:concatenation}.\n\n\\begin{lemma}\\label{lemma:multi-permutationsLocality}\n\tFor a nonnegative integer $t$, the set\n", "index": 9, "text": "\\[A_t\\triangleq\\{\\pi(\\gamma_1,\\ldots,\\gamma_{n/2})~\\vert~\\forall i,~\\gamma_i\\in S(\\{2i-1,2i\\}), \\text{ and }\\pi\\in B_t\\}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"A_{t}\\triangleq\\{\\pi(\\gamma_{1},\\ldots,\\gamma_{n/2})~{}|~{}\\forall i,~{}\\gamma%&#10;_{i}\\in S(\\{2i-1,2i\\}),\\text{ and }\\pi\\in B_{t}\\}\" display=\"block\"><mrow><msub><mi>A</mi><mi>t</mi></msub><mo>\u225c</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b3</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>\u03b3</mi><mrow><mi>n</mi><mo>/</mo><mn>2</mn></mrow></msub><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">|</mo><mrow><mrow><mrow><mrow><mo>\u2200</mo><mi>i</mi></mrow><mo rspace=\"5.8pt\">,</mo><msub><mi>\u03b3</mi><mi>i</mi></msub></mrow><mo>\u2208</mo><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><mi>\u03c0</mi></mrow><mo>\u2208</mo><msub><mi>B</mi><mi>t</mi></msub></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>", "type": "latex"}]