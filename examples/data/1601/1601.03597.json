[{"file": "1601.03597.tex", "nexttext": "\nIn order to incorporate the geometry information into the\ndiscretization, many of the aforementioned methods must integrate\na function over the domain, or the surface.\nIn order to evaluate these integrals, a discretized\nrepresentation of $\\Omega$, or $\\partial\\Omega$, is needed.\n\nAn efficient algorithm to reconstruct the interface between $\\Omega$ and its\ncomplement is the \\emph{marching cubes} algorithm presented in\n\\cite{Lorensen1987}. It originates from the field of computer graphics\nand is used to visualize volume data on a structured hexahedral grid.\nFor each grid element a case number can be generated based on the sign\nof $\\Phi$ at the cell vertices. This key is than used as an index\ninto a look-up table where the triangulation of the interface for this\nspecific configuration is stored.\nThis algorithm can be applied straight forward to tetrahedra, known as\n\\emph{marching tetrahedra} and other geometries\n\\cite{elvins1992survey}. As the case for cubes is the most challenging\none, as we will discuss later, we only consider cubes throughout this\npaper.\n\nThere are several cases where the interface can not be uniquely\ndetermined based only on the sign of $\\Phi$ at the corners. These\nambiguities can be resolved as presented in \\cite{Chernyaev1995} with\nthe \\emph{marching cubes 33} algorithm. For\neach face being ambiguous it is checked if two diagonally\nopposing vertices are connected over the face. In addition, a test\nneeds to be performed, if two vertices could be connected through the\nelement. For each case, the set of necessary tests is stored in a table. The\nresulting triangulation of the interface is topologically\ncorrect.\nAn implementation and completion of this algorithm has been published\nin \\cite{Lewiner2003}. As we will discuss later, also\n  this implementation lacks support for some special cases in 3D,\n  where the topology is not properly retained.\n\nA method which uses this idea for geometric integration over irregular\ndomains has been presented in \\cite{Min2007}. First cubes are\ntriangulated into simplices independent of $\\Phi$. To these simplices,\na marching cubes type algorithm is applied to obtain a discrete\nrepresentation of $\\Omega$ which is then used for integration.\nUsing only simplices has the benefit that the\namount of possible triangulation cases is significantly reduced. The\ndownside is that the multilinear level-set is projected onto a linear\nlevel-set, resulting in a systematic distortion of the reconstruction\nalong the newly introduced diagonals of cubes. Even with a symmetric\ncriss-cross triangulation, these systematic error can not be avoided\ncompletely.\n\n\n\n\n\n\n\n\n\n\nIn this paper we employ the marching cubes ideas for geometric\nintegration. We provide volume triangulations of the\ninterior and exterior domain, along with the interface triangulation.\nThese triangulations are topologically correct and consistent with\neach other. This allows for geometric integration over implicitly\ndescribed domains.  The partitioning into interior and exterior of\neach element's face based on the volume triangulation is consistent\nwith the triangulation which results from the application of the lower\ndimensional algorithm to the face. Although we only discuss the case\nof hexahedral elements, the algorithm is implemented for different\ndimensions and element types.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the next section we introduce mathematical\npreliminaries and discuss the required consistencies. Section\n\\ref{sec:existing-approaches} elaborates the existing approaches, which\nwere already briefly mentioned in the introduction.\nThe major contribution of this paper is the presentation of a\n\\emph{topology\npreserving marching cubes} ({\\textsf{TPMC}}) construction\nin Section \\ref{sec:algorithm},\n\n\n\n\nwhere we also compare the\nresults of out new approach to the existing ones for chosen typical\npathologic cases. The method is implemented as a C++ library, using\npython for automatic code generation as\ndiscussed in\nSection \\ref{sec:implementation}.\nFinally, in Section \\ref{sec:evaluation} numerical\nexperiments are presented which verify the accuracy and the topologic consistency for the\n{\\textsf{TPMC}}{} algorithm.\n\n\\section{Preliminaries}\n\\label{sec:preliminaries}\n\n\\subsection{Implicitly described domains}\nLet $\\hat\\Omega\\subset{\\mathbb{R}}^d$ denote a polygonal outer domain of dimension $d\\in{\\mathbb{N}}$.\nA subdomain $\\Omega\\subset\\hat\\Omega\\subset{\\mathbb{R}}^d$ is described using a\n\nlevel-set function $\\Phi$, see \\eqref{eq:levelset},\n\n\n\n\n\n\n\n\nlike illustrated in Figure \\ref{fig:levelset}.\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=4]\n  \\draw (.5,.5) node {$\\Phi<0$};\n  \\draw (.25,.85) node {$\\Phi>0$};\n  \\draw[gray] (.5,.5) ++(45:{.25}) -- +(.075,.075) node[above, black] {$\\Phi=0$};\n  \\draw (1,0.9) node[right] {\\rlap{$\\hat\\Omega=[0,1]^2$}};\n  \\draw (0,0.9) node[left] {\\rlap{~}};\n  \\draw[thick] (.5,.5) circle ({.25});\n  \\draw[thick] (0,0) rectangle (1,1);\n\\end{tikzpicture}\n  \\caption{Illustration of level-set function $\\Phi(x)= \\|x-(0.5,0.5)^T\\|_2-0.25$ on $\\hat\\Omega=[0,1]^2$}\n  \\label{fig:levelset}\n\\end{figure}\n\nThe boundary $\\partial\\Omega$ corresponds to the zero level-set $\\Phi^{-1}(0) := \\{ x \\in \\hat \\Omega \\mathrel{\\vert} \\Phi(x) = 0 \\}$.\nWe call $\\partial\\Omega$ the interface.\nWithout loss of generality we restrict the threshold value to 0.\nA level-set function with an arbitrary threshold $\\alpha\\in{\\mathbb{R}}$ can be obtained by using $\\tilde\\Phi(x):=\\Phi(x)-\\alpha$.\n\nNote that it is also possible to describe the motion of a moving interface from an Eulerian point of view in terms of a level-set function and an associated PDE, where $\\Phi(x,t)$ satisfies the level-set advection equation\n\n", "itemtype": "equation", "pos": 3298, "prevtext": "\n\n\\lstset{\nbasicstyle=\\fontfamily{zlmtt}\\selectfont, language=C++,\n\nnumbers=left,\nnumbersep=5pt,\nnumberstyle=\\sffamily\\tiny\\color{gray},\ncommentstyle=\\color{gray}\\emph,\nkeywordstyle={\\fontseries{b}\\selectfont\\color{gray}},\nkeywords={std, tpmc},\nkeywordstyle=[2]{\\fontseries{b}\\selectfont},\nkeywords=[2]{vector, array, Coordinate, static, unsigned, int, double,\ntypedef, size_t},\notherkeywords={::},\n}\n\n\\title{Geometric Integration Over Irregular Domains with\n  topologic Guarantees}\n  \\author{Christian Engwer\\thanks{\n    Institute for Computational und Applied Mathematics Einsteinstra\\ss e 62, 48149 M\\\"unster, Germany;\n  \\{christian.engwer, andreas.nuessing\\}@uni-muenster.de} \\and Andreas N\u00c3\u00bc\u00c3\u009fing $^*$\n}\n\n\n\\maketitle\n\n\\begin{abstract}\n  Implicitly described domains are a well established tool in the\n  simulation of time dependent problems, e.g. using level-set methods.\n  In order to solve partial differential equations on such domains, a\n  range of numerical methods was developed, e.g. the Immersed Boundary\n  method, Unfitted Finite Element or Unfitted discontinuous Galerkin\n  methods, eXtended or Generalised Finite Element methods, just to\n  name a few. Many of these methods involve integration over cut-cells\n  or their boundaries, as they are described by sub-domains of the\n  original level-set mesh.\n\n  We present a new algorithm to geometrically evaluate the integrals over\n  domains described by a first-order, conforming level-set function.\n  The integration is\n  based on a polyhedral reconstruction of the implicit geometry,\n  following the concepts of the Marching Cubes algorithm.\n  The algorithm preserves various topological properties of the implicit geometry in\n  its polyhedral reconstruction, making it suitable for Finite Element computations.\n  Numerical experiments show second order accuracy of the\n  integration.\n\n  An implementation of the algorithm is available as free software,\n  which allows for an easy incorporation into other projects. The\n  software is in productive use within the DUNE framework~\\cite{dune08:2}.\n\n\\end{abstract}\n\n\\section{Introduction}\n\\label{sec:introduction}\n\nWhen dealing with partial differential equations (PDEs), methods using\nimplicitly described domains have established themselves as an\nalternative to the traditional work flow using geometry adapted\nmeshes.  These methods usually solve the PDE on a larger domain and\nthe actual geometry information is incorporated later on.  Some\npopular methods are the Immersed Boundary method \\cite{peskin77},\nUnfitted Finite Element \\cite{Barrett:1987:FUF} or Unfitted\ndiscontinuous Galerkin methods \\cite{engwer2009udg}, eXtended\n\\cite{dolbow2001efe} or Generalised Finite Element methods\n\\cite{strouboulis2001gfe}.\n\nOne popular class of implicit domain descriptions is via a scalar function,\nusually a so called level-set function \\cite{osher1988levelset_first} or a phase-field\nfunction \\cite{fix1982phasefield_first}. These approaches are\nparticularly attractive, as they can easily describe moving domains\nand even topology changes. In the following we have only very few\nrequirements on the implicit description. A domain $\\Omega\\subset {\\mathbb{R}}^d$ is described\nusing a continuous scalar function $\\Phi: \\hat\\Omega \\subset {\\mathbb{R}}^d \\rightarrow {\\mathbb{R}}$ such that:\n\n", "index": 1, "text": "\\begin{equation}\n  \\label{eq:levelset}\n  \\Phi(x)\n  \\begin{cases}\n    < 0 &, \\text{ if }x\\in\\Omega \\\\\n    = 0 &, \\text{ if }x\\in\\partial\\Omega \\\\\n    > 0 &, \\text{ else.}\n  \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\Phi(x)\\begin{cases}&lt;0&amp;,\\text{ if }x\\in\\Omega\\\\&#10;=0&amp;,\\text{ if }x\\in\\partial\\Omega\\\\&#10;&gt;0&amp;,\\text{ else.}\\end{cases}\" display=\"block\"><mrow><mi mathvariant=\"normal\">\u03a6</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi/><mo>&lt;</mo><mn>0</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mo>,</mo><mtext>\u00a0if\u00a0</mtext><mi>x</mi><mo>\u2208</mo><mi mathvariant=\"normal\">\u03a9</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mn>0</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mo>,</mo><mtext>\u00a0if\u00a0</mtext><mi>x</mi><mo>\u2208</mo><mo>\u2202</mo><mi mathvariant=\"normal\">\u03a9</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi/><mo>&gt;</mo><mn>0</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mo>,</mo><mtext>\u00a0else.</mtext></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nwhere $\\mathbf{v}(x,t)$ is a velocity field corresponding to the evolution of $\\Omega$ and $\\Gamma$.\n\nIn practice the level-set is given as a discrete scalar function $\\Phi_h$.\nA common choice is to use a conforming first order discretization,\nwhich is also assumed in this paper.\n\nWe consider a mesh ${\\mathcal{M}}(\\hat\\Omega)$, which is a discretization of the domain $\\hat\\Omega\\subset {\\mathbb{R}}^d$.\nThe following properties hold:\n${\\mathcal{M}}(\\hat\\Omega) = \\{{E}_i| i \\in \\lbrace 0,\\dots,N-1\\rbrace \\}$ forms a partition of $\\hat\\Omega$ with ${E}_i \\cap {E}_j = \\emptyset$ if $i \\ne j$ and $\\bigcup_i \\bar {E}_i = \\bar{\\hat\\Omega}$.\n$E_i$ denotes the codimension 0 elements of ${\\mathcal{M}}$, i.e. the mesh cells.\nIn 3D we only consider meshes with cubes, simplices, prisms and pyramids.\nIn many cases a mesh consists either of cubes or simplices.\nIn 2D only cubes and simplices are considered.\n\nApart from mesh cells we identify the following sub entities of ${\\mathcal{M}}$:\nfaces ${\\gamma}$ ~(codimension 1), edges ${\\kappa}$ ~(codimension $d-1$) and vertices ${\\xi}$ ~(codimension $d$).\nWhen looking at the codimension it becomes obvious, that in 2D faces and edges are the same.\nWe still want to distinguish these to avoid confusion, when it comes to generalizations of the algorithm.\nFor a formal definition of the grid and its properties, as we consider\nit, we refer to \\cite{Bastian2008}.\n\nThe discrete level-set is given as a scalar, continuous and piecewise\nmulti-linear function.\nWe choose a representation using vertex values. As $\\Phi_h$ is linear\nalong edges ${\\kappa}_i$ it can be written as:\n\n", "itemtype": "equation", "pos": 9193, "prevtext": "\nIn order to incorporate the geometry information into the\ndiscretization, many of the aforementioned methods must integrate\na function over the domain, or the surface.\nIn order to evaluate these integrals, a discretized\nrepresentation of $\\Omega$, or $\\partial\\Omega$, is needed.\n\nAn efficient algorithm to reconstruct the interface between $\\Omega$ and its\ncomplement is the \\emph{marching cubes} algorithm presented in\n\\cite{Lorensen1987}. It originates from the field of computer graphics\nand is used to visualize volume data on a structured hexahedral grid.\nFor each grid element a case number can be generated based on the sign\nof $\\Phi$ at the cell vertices. This key is than used as an index\ninto a look-up table where the triangulation of the interface for this\nspecific configuration is stored.\nThis algorithm can be applied straight forward to tetrahedra, known as\n\\emph{marching tetrahedra} and other geometries\n\\cite{elvins1992survey}. As the case for cubes is the most challenging\none, as we will discuss later, we only consider cubes throughout this\npaper.\n\nThere are several cases where the interface can not be uniquely\ndetermined based only on the sign of $\\Phi$ at the corners. These\nambiguities can be resolved as presented in \\cite{Chernyaev1995} with\nthe \\emph{marching cubes 33} algorithm. For\neach face being ambiguous it is checked if two diagonally\nopposing vertices are connected over the face. In addition, a test\nneeds to be performed, if two vertices could be connected through the\nelement. For each case, the set of necessary tests is stored in a table. The\nresulting triangulation of the interface is topologically\ncorrect.\nAn implementation and completion of this algorithm has been published\nin \\cite{Lewiner2003}. As we will discuss later, also\n  this implementation lacks support for some special cases in 3D,\n  where the topology is not properly retained.\n\nA method which uses this idea for geometric integration over irregular\ndomains has been presented in \\cite{Min2007}. First cubes are\ntriangulated into simplices independent of $\\Phi$. To these simplices,\na marching cubes type algorithm is applied to obtain a discrete\nrepresentation of $\\Omega$ which is then used for integration.\nUsing only simplices has the benefit that the\namount of possible triangulation cases is significantly reduced. The\ndownside is that the multilinear level-set is projected onto a linear\nlevel-set, resulting in a systematic distortion of the reconstruction\nalong the newly introduced diagonals of cubes. Even with a symmetric\ncriss-cross triangulation, these systematic error can not be avoided\ncompletely.\n\n\n\n\n\n\n\n\n\n\nIn this paper we employ the marching cubes ideas for geometric\nintegration. We provide volume triangulations of the\ninterior and exterior domain, along with the interface triangulation.\nThese triangulations are topologically correct and consistent with\neach other. This allows for geometric integration over implicitly\ndescribed domains.  The partitioning into interior and exterior of\neach element's face based on the volume triangulation is consistent\nwith the triangulation which results from the application of the lower\ndimensional algorithm to the face. Although we only discuss the case\nof hexahedral elements, the algorithm is implemented for different\ndimensions and element types.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the next section we introduce mathematical\npreliminaries and discuss the required consistencies. Section\n\\ref{sec:existing-approaches} elaborates the existing approaches, which\nwere already briefly mentioned in the introduction.\nThe major contribution of this paper is the presentation of a\n\\emph{topology\npreserving marching cubes} ({\\textsf{TPMC}}) construction\nin Section \\ref{sec:algorithm},\n\n\n\n\nwhere we also compare the\nresults of out new approach to the existing ones for chosen typical\npathologic cases. The method is implemented as a C++ library, using\npython for automatic code generation as\ndiscussed in\nSection \\ref{sec:implementation}.\nFinally, in Section \\ref{sec:evaluation} numerical\nexperiments are presented which verify the accuracy and the topologic consistency for the\n{\\textsf{TPMC}}{} algorithm.\n\n\\section{Preliminaries}\n\\label{sec:preliminaries}\n\n\\subsection{Implicitly described domains}\nLet $\\hat\\Omega\\subset{\\mathbb{R}}^d$ denote a polygonal outer domain of dimension $d\\in{\\mathbb{N}}$.\nA subdomain $\\Omega\\subset\\hat\\Omega\\subset{\\mathbb{R}}^d$ is described using a\n\nlevel-set function $\\Phi$, see \\eqref{eq:levelset},\n\n\n\n\n\n\n\n\nlike illustrated in Figure \\ref{fig:levelset}.\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=4]\n  \\draw (.5,.5) node {$\\Phi<0$};\n  \\draw (.25,.85) node {$\\Phi>0$};\n  \\draw[gray] (.5,.5) ++(45:{.25}) -- +(.075,.075) node[above, black] {$\\Phi=0$};\n  \\draw (1,0.9) node[right] {\\rlap{$\\hat\\Omega=[0,1]^2$}};\n  \\draw (0,0.9) node[left] {\\rlap{~}};\n  \\draw[thick] (.5,.5) circle ({.25});\n  \\draw[thick] (0,0) rectangle (1,1);\n\\end{tikzpicture}\n  \\caption{Illustration of level-set function $\\Phi(x)= \\|x-(0.5,0.5)^T\\|_2-0.25$ on $\\hat\\Omega=[0,1]^2$}\n  \\label{fig:levelset}\n\\end{figure}\n\nThe boundary $\\partial\\Omega$ corresponds to the zero level-set $\\Phi^{-1}(0) := \\{ x \\in \\hat \\Omega \\mathrel{\\vert} \\Phi(x) = 0 \\}$.\nWe call $\\partial\\Omega$ the interface.\nWithout loss of generality we restrict the threshold value to 0.\nA level-set function with an arbitrary threshold $\\alpha\\in{\\mathbb{R}}$ can be obtained by using $\\tilde\\Phi(x):=\\Phi(x)-\\alpha$.\n\nNote that it is also possible to describe the motion of a moving interface from an Eulerian point of view in terms of a level-set function and an associated PDE, where $\\Phi(x,t)$ satisfies the level-set advection equation\n\n", "index": 3, "text": "\\begin{equation*}\n  \\label{eq:level_set_advection_equation}\n  \\Phi_t + \\mathbf{v} \\cdot \\nabla \\Phi = 0 \\qquad \\text{in } \\hat\\Omega,\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\Phi_{t}+\\mathbf{v}\\cdot\\nabla\\Phi=0\\qquad\\text{in }\\hat{\\Omega},\" display=\"block\"><mrow><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>t</mi></msub><mo>+</mo><mrow><mi>\ud835\udc2f</mi><mo>\u22c5</mo><mrow><mo>\u2207</mo><mo>\u2061</mo><mi mathvariant=\"normal\">\u03a6</mi></mrow></mrow></mrow><mo>=</mo><mrow><mn>0</mn><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003</mo><mrow><mtext>in\u00a0</mtext><mo>\u2062</mo><mover accent=\"true\"><mi mathvariant=\"normal\">\u03a9</mi><mo stretchy=\"false\">^</mo></mover></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nwith ${\\xi}_0$ and ${\\xi}_1$ denoting the vertices associated with ${\\kappa}_i$.\n\n\\subsection{Numerical integration over implicitly described domains}\nThe aim of the presented algorithm is to compute the integral of a\nfunction $f:\\hat\\Omega\\to{\\mathbb{R}}$ over the domain $\\Omega$ described by a\ndiscrete level-set function $\\Phi_h$. In the following discussion\ngeometry described by $\\Phi_h$ is considered the exact geometry.\nThe integration over the domain\nboundary $\\partial\\Omega$ or the complement $\\hat\\Omega\\setminus\\overline\\Omega$ can\nbe done in a similar manner. Using a triangulation ${\\mathcal{M}}(\\hat\\Omega)$\nof $\\hat\\Omega$, we compute a sub-triangulation $\\{E_i^j\\}$ of the intersection of\neach element $E_i$ and $\\Omega$.\n\n", "itemtype": "equation", "pos": 10961, "prevtext": "\nwhere $\\mathbf{v}(x,t)$ is a velocity field corresponding to the evolution of $\\Omega$ and $\\Gamma$.\n\nIn practice the level-set is given as a discrete scalar function $\\Phi_h$.\nA common choice is to use a conforming first order discretization,\nwhich is also assumed in this paper.\n\nWe consider a mesh ${\\mathcal{M}}(\\hat\\Omega)$, which is a discretization of the domain $\\hat\\Omega\\subset {\\mathbb{R}}^d$.\nThe following properties hold:\n${\\mathcal{M}}(\\hat\\Omega) = \\{{E}_i| i \\in \\lbrace 0,\\dots,N-1\\rbrace \\}$ forms a partition of $\\hat\\Omega$ with ${E}_i \\cap {E}_j = \\emptyset$ if $i \\ne j$ and $\\bigcup_i \\bar {E}_i = \\bar{\\hat\\Omega}$.\n$E_i$ denotes the codimension 0 elements of ${\\mathcal{M}}$, i.e. the mesh cells.\nIn 3D we only consider meshes with cubes, simplices, prisms and pyramids.\nIn many cases a mesh consists either of cubes or simplices.\nIn 2D only cubes and simplices are considered.\n\nApart from mesh cells we identify the following sub entities of ${\\mathcal{M}}$:\nfaces ${\\gamma}$ ~(codimension 1), edges ${\\kappa}$ ~(codimension $d-1$) and vertices ${\\xi}$ ~(codimension $d$).\nWhen looking at the codimension it becomes obvious, that in 2D faces and edges are the same.\nWe still want to distinguish these to avoid confusion, when it comes to generalizations of the algorithm.\nFor a formal definition of the grid and its properties, as we consider\nit, we refer to \\cite{Bastian2008}.\n\nThe discrete level-set is given as a scalar, continuous and piecewise\nmulti-linear function.\nWe choose a representation using vertex values. As $\\Phi_h$ is linear\nalong edges ${\\kappa}_i$ it can be written as:\n\n", "index": 5, "text": "\\begin{align*}\n  \\Phi_h ({\\xi}_0+t({\\xi}_1-{\\xi}_0))=\\Phi_h({\\xi}_0)+t\\Phi_h({\\xi}_1)~,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Phi_{h}({\\xi}_{0}+t({\\xi}_{1}-{\\xi}_{0}))=\\Phi_{h}({\\xi}_{0})+t%&#10;\\Phi_{h}({\\xi}_{1})~{},\" display=\"inline\"><mrow><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03be</mi><mn>0</mn></msub><mo>+</mo><mrow><mi>t</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03be</mi><mn>1</mn></msub><mo>-</mo><msub><mi>\u03be</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03be</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mi>t</mi><mo>\u2062</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03be</mi><mn>1</mn></msub><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nThe first approximation is unavoidable, the approximation in the last\nstep is due to our numerical integration and is subject of the\ndiscussion in the section.\nThe integration over a simple element $E$ (e.g. a simplex or cube) can be done on its reference element using a common quadrature rule:\n\n", "itemtype": "equation", "pos": 11802, "prevtext": "\nwith ${\\xi}_0$ and ${\\xi}_1$ denoting the vertices associated with ${\\kappa}_i$.\n\n\\subsection{Numerical integration over implicitly described domains}\nThe aim of the presented algorithm is to compute the integral of a\nfunction $f:\\hat\\Omega\\to{\\mathbb{R}}$ over the domain $\\Omega$ described by a\ndiscrete level-set function $\\Phi_h$. In the following discussion\ngeometry described by $\\Phi_h$ is considered the exact geometry.\nThe integration over the domain\nboundary $\\partial\\Omega$ or the complement $\\hat\\Omega\\setminus\\overline\\Omega$ can\nbe done in a similar manner. Using a triangulation ${\\mathcal{M}}(\\hat\\Omega)$\nof $\\hat\\Omega$, we compute a sub-triangulation $\\{E_i^j\\}$ of the intersection of\neach element $E_i$ and $\\Omega$.\n\n", "index": 7, "text": "\\begin{align*}\n  \\int_{\\lbrace \\Phi<0\\rbrace}fdx\n  & = \\sum_{i}\\int_{E_i\\cap\\lbrace \\Phi<0\\rbrace}fdx \\\\\n  & \\approx \\sum_{i}\\int_{E_i\\cap\\lbrace \\Phi_h<0\\rbrace}fdx \\\\\n  & \\approx \\sum_{i}\\sum_{j}\\int_{E_i^j}fdx\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\int_{\\{\\Phi&lt;0\\}}fdx\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">\u03a6</mi><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>x</mi></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{i}\\int_{E_{i}\\cap\\{\\Phi&lt;0\\}}fdx\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><msub><mi>E</mi><mi>i</mi></msub><mo>\u2229</mo><mrow><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">\u03a6</mi><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow></mrow></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>x</mi></mrow></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\approx\\sum_{i}\\int_{E_{i}\\cap\\{\\Phi_{h}&lt;0\\}}fdx\" display=\"inline\"><mrow><mi/><mo>\u2248</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><msub><mi>E</mi><mi>i</mi></msub><mo>\u2229</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>h</mi></msub><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow></mrow></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>x</mi></mrow></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\approx\\sum_{i}\\sum_{j}\\int_{E_{i}^{j}}fdx\" display=\"inline\"><mrow><mi/><mo>\u2248</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>j</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msubsup><mi>E</mi><mi>i</mi><mi>j</mi></msubsup></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>x</mi></mrow></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nHere, $T_E$ denotes a bijective map between $E$ and its reference\nelement and $J_{T_E}$ denotes its Jacobian. In the literature different\nchoices of reference elements are considered. We follow the definition\nused by the DUNE project. A list of these reference elements is given\nin Figure \\ref{fig:reference_elements}.\n\n\\begin{figure}\n  \\centering\n  \\parbox{0.25\\linewidth}{\\centering 2D cube}\\quad\n  \\parbox{0.25\\linewidth}{\\centering 3D simplex}\\quad\n  \\parbox{0.3\\linewidth}{\\centering 3D cube}\\\\\n  \\parbox{0.25\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_quadrilateral}}\\quad\n  \\parbox{0.25\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_simplex}}\\quad\n  \\parbox{0.3\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_cube}}\n  \\caption{Vertex numbering and positions in the reference elements.}\n  \\label{fig:reference_elements}\n\\end{figure}\n\n\\subsection{Topological guarantees}\nIn order to allow the algorithm to be employed in a wide range of\ndifferent methods, we demand that a sub-triangulation fulfills certain topological guarantees.\n\\begin{enumerate}\n\\item The connectivity pattern of the cell vertices must be preserved within each subentity.\n  In particular this means that vertices connected along an edge, face or volume, should still be connected via the same subentity.\n\\item This requirement is related to the previous point.\n  The curved interface \\mbox{$\\partial\\Omega \\equiv \\Phi_h^{-1}(0)$} partitions each grid cell into patches belonging to either $\\Omega$ or the complement $\\hat\\Omega\\setminus\\Omega$.\n  We require that the number of patches and their domain association is preserved for the polygonal reconstruction.\n\\item The vertices of the reconstructed interface lie on the exact\n  zero level-set (of the discrete level-set function), i.e. for each vertex ${\\xi}_i$ the property\n  \n", "itemtype": "equation", "pos": 12324, "prevtext": "\nThe first approximation is unavoidable, the approximation in the last\nstep is due to our numerical integration and is subject of the\ndiscussion in the section.\nThe integration over a simple element $E$ (e.g. a simplex or cube) can be done on its reference element using a common quadrature rule:\n\n", "index": 9, "text": "\\begin{align*}\n  \\int_E fdx = \\sum_{k} f(T_E(q_k)) w_k |\\det(J_{T_E}(q_k))|\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\int_{E}fdx=\\sum_{k}f(T_{E}(q_{k}))w_{k}|\\det(J_{T_{E}}(q_{k}))|\" display=\"inline\"><mrow><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>E</mi></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>x</mi></mrow></mrow></mrow><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>k</mi></munder></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>T</mi><mi>E</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>w</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mo movablelimits=\"false\">det</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>J</mi><msub><mi>T</mi><mi>E</mi></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\n  holds.\n\\end{enumerate}\n\n\\section{Existing approaches}\n\\label{sec:existing-approaches}\n\nIn this section we discuss existing approaches\nfor computing a polygonal reconstruction of the\ninterface $\\partial\\Omega$ on hexahedral meshes. Extensions to other\nelement types and other dimensions are always possible.\n\nA well known algorithm is the marching cubes algorithm \\cite{Lorensen1987}.\nIn \\cite{engwer2009udg} we described how integration rules for $\\Omega$ can be constructed, following the ideas\nof the marching cubes algorithm.\nIn the following we refer to this algorithm as \\emph{{\\textsf{MC}}{}}.\n\n\nThe general idea is to only consider the sign of the function values\nin the vertices. Depending on these values $2^{2^\\text{dim}}$\ndifferent configuration can be distinguished, which can be reduced to\n15 basic cases in 3D by taking rotation and mirroring into account. This allows to quickly reconstruct\nthe interface using predefined rules.\n\nA similar approach was presented in \\cite{Min2007}, where the authors basically propose integration rules constructed similar to marching tetrahedrons \\cite{gueziec1995mt};\ncubes are split into simplices using the Kuhn triangulation \\cite{freudenthal1942} and then tetrahedra are triangulated based on their vertex values.\nIn the following we refer to this algorithm as \\emph{{\\textsf{K/MT}}{}}.\n\nAs described in different publications, the classic marching cubes algorithm is not able to preserve the topology of the original iso-surface.\n\\cite{Chernyaev1995} describes how in the marching cubes 33 additional evaluations in the face or volume help to resolve those ambiguities.\nA full implementation was published in \\cite{Lewiner2003}.\nIn the following we refer to this algorithm as \\emph{{\\textsf{MC33}}{}}.\n\\begin{figure}\n  \\centering\n\n  \\includegraphics[width=0.8\\textwidth]{pics/topologicproblems}\n\n  \\caption{Comparing the existing algorithms: Problems in maintaining\n    the topology for the reconstructed interface.\n    Gray area: original sub-domain.\n    Dots: reconstruction points (black: outside, white: inside).\n    Dashed line: reconstructed interface. }\n  \\label{fig:topologicproblems}\n\\end{figure}\nNone of the existing approaches can fulfill all of the afore described\ntopological guarantees.\n\nWhile the first property is not fulfilled by the classic {\\textsf{MC}}{} algorithm, the {\\textsf{MC33}}{} algorithm describes an approach, which guarantees this consistency, at least for most cases.\nIn Section \\ref{sec:algorithm} we will describe the cases where the {\\textsf{MC33}}{} reconstruction is not sufficient.\nThe {\\textsf{K/MT}}{} algorithm on the other hand seems to solve the problem of\nsuch ambiguities, as the reconstruction on a simplex is always\nunique. The reconstruction is unique, but in general not correct, as\nthe algorithm implicitly chooses one\nsolution, due to the previous Kuhn triangulation and by this introduces a preferential direction.\n\nDifficulties arise regarding the third property, which is fulfilled by neither the {\\textsf{MC33}}{} algorithm, nor the {\\textsf{K/MT}}{} approach.\nIn the case of {\\textsf{MC33}}{}, nodes in the cube are introduced as weighted\naverages of the position of cell vertices to describe a reconstruction\nin certain special cases. Such cases can not arise in 2D, but only\nin 3D.\nUsing these nodes in the polygonal reconstruction of the interface\n$\\partial\\Omega$, is sufficient from a visualization point of view,\nbut not for simulation purposes, as in general the nodes do not lie on\nthe interface. Depending on the numerical algorithm and the model this\ncan lead to systematic errors, e.g. in a curvature reconstruction.\n\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=4]\n\\fill[lightgray] (.5,.5) circle (0.45);\n\\draw[gray,step=0.25] (0,0) grid (1,1);\n\\draw[gray] (0.0,0.0) -- (0.25,0.25);\n\\draw[gray] (0.0,0.25) -- (0.25,0.5);\n\\draw[gray] (0.0,0.5) -- (0.25,0.75);\n\\draw[gray] (0.0,0.75) -- (0.25,1.0);\n\\draw[gray] (0.25,0.0) -- (0.5,0.25);\n\\draw[gray] (0.25,0.25) -- (0.5,0.5);\n\\draw[gray] (0.25,0.5) -- (0.5,0.75);\n\\draw[gray] (0.25,0.75) -- (0.5,1.0);\n\\draw[gray] (0.5,0.0) -- (0.75,0.25);\n\\draw[gray] (0.5,0.25) -- (0.75,0.5);\n\\draw[gray] (0.5,0.5) -- (0.75,0.75);\n\\draw[gray] (0.5,0.75) -- (0.75,1.0);\n\\draw[gray] (0.75,0.0) -- (1.0,0.25);\n\\draw[gray] (0.75,0.25) -- (1.0,0.5);\n\\draw[gray] (0.75,0.5) -- (1.0,0.75);\n\\draw[gray] (0.75,0.75) -- (1.0,1.0);\n\\draw[thick] (0.25,0.132647574033) -- (0.181801948466,0.181801948466);\n\\draw[thick] (0.132647574033,0.25) -- (0.181801948466,0.181801948466);\n\\draw[thick] (0.132647574033,0.25) -- (0.088196601125,0.338196601125);\n\\draw[thick] (0.05,0.5) -- (0.088196601125,0.338196601125);\n\\draw[thick] (0.05,0.5) -- (0.0853553390593,0.585355339059);\n\\draw[thick] (0.132647574033,0.75) -- (0.0853553390593,0.585355339059);\n\\draw[thick] (0.132647574033,0.75) -- (0.25,0.867352425967);\n\\draw[thick] (0.5,0.05) -- (0.338196601125,0.088196601125);\n\\draw[thick] (0.25,0.132647574033) -- (0.338196601125,0.088196601125);\n\\draw[thick] (0.5,0.95) -- (0.414644660941,0.914644660941);\n\\draw[thick] (0.25,0.867352425967) -- (0.414644660941,0.914644660941);\n\\draw[thick] (0.75,0.132647574033) -- (0.585355339059,0.0853553390593);\n\\draw[thick] (0.5,0.05) -- (0.585355339059,0.0853553390593);\n\\draw[thick] (0.75,0.867352425967) -- (0.661803398875,0.911803398875);\n\\draw[thick] (0.5,0.95) -- (0.661803398875,0.911803398875);\n\\draw[thick] (0.75,0.132647574033) -- (0.867352425967,0.25);\n\\draw[thick] (0.867352425967,0.25) -- (0.914644660941,0.414644660941);\n\\draw[thick] (0.95,0.5) -- (0.914644660941,0.414644660941);\n\\draw[thick] (0.95,0.5) -- (0.911803398875,0.661803398875);\n\\draw[thick] (0.867352425967,0.75) -- (0.911803398875,0.661803398875);\n\\draw[thick] (0.867352425967,0.75) -- (0.818198051534,0.818198051534);\n\\draw[thick] (0.75,0.867352425967) -- (0.818198051534,0.818198051534);\n\\end{tikzpicture} \n\n\\quad  \\begin{tikzpicture}[scale=4]\n\\fill[lightgray] (.5,.5) circle (0.45);\n\\draw[gray,step=0.25] (0,0) grid (1,1);\n\\draw[thick] (0.25,0.132647574033) -- (0.132647574033,0.25);\n\\draw[thick] (0.132647574033,0.25) -- (0.05,0.5);\n\\draw[thick] (0.05,0.5) -- (0.132647574033,0.75);\n\\draw[thick] (0.132647574033,0.75) -- (0.25,0.867352425967);\n\\draw[thick] (0.25,0.132647574033) -- (0.5,0.05);\n\\draw[thick] (0.25,0.867352425967) -- (0.5,0.95);\n\\draw[thick] (0.5,0.05) -- (0.75,0.132647574033);\n\\draw[thick] (0.5,0.95) -- (0.75,0.867352425967);\n\\draw[thick] (0.75,0.132647574033) -- (0.867352425967,0.25);\n\\draw[thick] (0.867352425967,0.25) -- (0.95,0.5);\n\\draw[thick] (0.95,0.5) -- (0.867352425967,0.75);\n\\draw[thick] (0.867352425967,0.75) -- (0.75,0.867352425967);\n\\end{tikzpicture} \n\n  \\caption{reconstructed interface of a circle using the {\\textsf{K/MT}}{} approach (left) and {\\textsf{MC33}}{} (right)}\n  \\label{fig:kmt_circle}\n\\end{figure}\n\nThe {\\textsf{K/MT}}{} algorithm first applies a simplex triangulation.\nOn each simplex, the level-set function is assumed to be linear, which is not correct, as it is actually bi-linear in 2D or tri-linear in 3D.\nThis leads to reconstructed points, which are slightly off the interface.\nIn addition, the triangulation into simplices introduces an anisotropy\nin the reconstructed interface, see Figure \\ref{fig:kmt_circle}.\n\nFurther examples of violated consistencies are shown in Section\n\\ref{sec:algorithm:consistencies}, where we will also discuss how to\nprevent these problems using the proposed {\\textsf{TPMC}}{} algorithm.\n\n\\section{Algorithm}\n\\label{sec:algorithm}\n\nIn the following section, we will describe the algorithm for computing\nthe sub-triangulation of a single grid cell using the vertex values of\nthe level-set function. All computations can be performed on the\nreference element in cell local coordinates.\n\n\\subsection{General Idea}\n\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}\n  \n  \\tikzstyle{inout}=[rectangle, draw, ultra thick]\n  \\tikzstyle{method}=[rounded corners,draw]\n  \\tikzstyle{closer}=[node distance=0.8cm]\n  \\tikzstyle{close}=[node distance=1cm]\n  \\tikzstyle{far}=[node distance=2cm]\n  \\tikzstyle{connection}=[->, >=stealth']\n  \\tikzstyle{entryexit}=[->, >=stealth', thick]\n  \n  \\node (in) [inout] {\\textit{input}};\n  \\node (entry) [above of=in, closer] {};\n  \\node (key)[method,close, below of=in] {compute key};\n  \\node (tests) [method,far, below right of=key] {perform tests};\n  \\node (coord) [method,far, below left of=tests] {compute coordinates};\n  \\node (out) [inout,close, below of=coord] {\\textit{output}};\n  \\node (exit) [below of=out, closer] {};\n  \n  \\path (entry) edge[entryexit] (in)\n        (in) edge[connection] (key)\n        (key) edge[connection]             node[right] {\\textit{ambiguous}} (tests)\n              edge[connection, bend right] node[left]  {\\textit{non-ambiguous}} (coord)\n        (tests) edge[connection] (coord)\n        (coord) edge[connection] (out)\n        (out) edge[entryexit] (exit);\n\\end{tikzpicture}\n  \\caption{structure of the general algorithm for the generation of a sub-triangulation}\n  \\label{fig:gen-subtriang}\n\\end{figure}\n\nThe main idea is to map a set of corner values to a table-index.\nThe index gives access to different tables which store precomputed general triangulations of the interior, exterior and interface of $\\Omega$.\nBased on this general triangulation we can compute the actual triangulation by incorporating the corner values.\nThe basic algorithmic structure is sketched in Figure \\ref{fig:gen-subtriang}.\n\nThe generation of the table index is subdivided into two steps: the computation of a key and, if necessary, the application of certain tests if the key is ambiguous.\nThe key of a sequence of corner values $(v_0,\\dots,v_{n-1})$ of\n$\\Phi_h$ is defined as\n\n", "itemtype": "equation", "pos": 14250, "prevtext": "\nHere, $T_E$ denotes a bijective map between $E$ and its reference\nelement and $J_{T_E}$ denotes its Jacobian. In the literature different\nchoices of reference elements are considered. We follow the definition\nused by the DUNE project. A list of these reference elements is given\nin Figure \\ref{fig:reference_elements}.\n\n\\begin{figure}\n  \\centering\n  \\parbox{0.25\\linewidth}{\\centering 2D cube}\\quad\n  \\parbox{0.25\\linewidth}{\\centering 3D simplex}\\quad\n  \\parbox{0.3\\linewidth}{\\centering 3D cube}\\\\\n  \\parbox{0.25\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_quadrilateral}}\\quad\n  \\parbox{0.25\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_simplex}}\\quad\n  \\parbox{0.3\\linewidth}{\\includegraphics[height=\\linewidth]{pics/ref_cube}}\n  \\caption{Vertex numbering and positions in the reference elements.}\n  \\label{fig:reference_elements}\n\\end{figure}\n\n\\subsection{Topological guarantees}\nIn order to allow the algorithm to be employed in a wide range of\ndifferent methods, we demand that a sub-triangulation fulfills certain topological guarantees.\n\\begin{enumerate}\n\\item The connectivity pattern of the cell vertices must be preserved within each subentity.\n  In particular this means that vertices connected along an edge, face or volume, should still be connected via the same subentity.\n\\item This requirement is related to the previous point.\n  The curved interface \\mbox{$\\partial\\Omega \\equiv \\Phi_h^{-1}(0)$} partitions each grid cell into patches belonging to either $\\Omega$ or the complement $\\hat\\Omega\\setminus\\Omega$.\n  We require that the number of patches and their domain association is preserved for the polygonal reconstruction.\n\\item The vertices of the reconstructed interface lie on the exact\n  zero level-set (of the discrete level-set function), i.e. for each vertex ${\\xi}_i$ the property\n  \n", "index": 11, "text": "\\begin{equation*}\n    \\Phi_h({\\xi}_i) = 0\n  \\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\Phi_{h}({\\xi}_{i})=0\" display=\"block\"><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03be</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nwhere $\\chi_M$ denotes the indicator function\n\n", "itemtype": "equation", "pos": 23982, "prevtext": "\n  holds.\n\\end{enumerate}\n\n\\section{Existing approaches}\n\\label{sec:existing-approaches}\n\nIn this section we discuss existing approaches\nfor computing a polygonal reconstruction of the\ninterface $\\partial\\Omega$ on hexahedral meshes. Extensions to other\nelement types and other dimensions are always possible.\n\nA well known algorithm is the marching cubes algorithm \\cite{Lorensen1987}.\nIn \\cite{engwer2009udg} we described how integration rules for $\\Omega$ can be constructed, following the ideas\nof the marching cubes algorithm.\nIn the following we refer to this algorithm as \\emph{{\\textsf{MC}}{}}.\n\n\nThe general idea is to only consider the sign of the function values\nin the vertices. Depending on these values $2^{2^\\text{dim}}$\ndifferent configuration can be distinguished, which can be reduced to\n15 basic cases in 3D by taking rotation and mirroring into account. This allows to quickly reconstruct\nthe interface using predefined rules.\n\nA similar approach was presented in \\cite{Min2007}, where the authors basically propose integration rules constructed similar to marching tetrahedrons \\cite{gueziec1995mt};\ncubes are split into simplices using the Kuhn triangulation \\cite{freudenthal1942} and then tetrahedra are triangulated based on their vertex values.\nIn the following we refer to this algorithm as \\emph{{\\textsf{K/MT}}{}}.\n\nAs described in different publications, the classic marching cubes algorithm is not able to preserve the topology of the original iso-surface.\n\\cite{Chernyaev1995} describes how in the marching cubes 33 additional evaluations in the face or volume help to resolve those ambiguities.\nA full implementation was published in \\cite{Lewiner2003}.\nIn the following we refer to this algorithm as \\emph{{\\textsf{MC33}}{}}.\n\\begin{figure}\n  \\centering\n\n  \\includegraphics[width=0.8\\textwidth]{pics/topologicproblems}\n\n  \\caption{Comparing the existing algorithms: Problems in maintaining\n    the topology for the reconstructed interface.\n    Gray area: original sub-domain.\n    Dots: reconstruction points (black: outside, white: inside).\n    Dashed line: reconstructed interface. }\n  \\label{fig:topologicproblems}\n\\end{figure}\nNone of the existing approaches can fulfill all of the afore described\ntopological guarantees.\n\nWhile the first property is not fulfilled by the classic {\\textsf{MC}}{} algorithm, the {\\textsf{MC33}}{} algorithm describes an approach, which guarantees this consistency, at least for most cases.\nIn Section \\ref{sec:algorithm} we will describe the cases where the {\\textsf{MC33}}{} reconstruction is not sufficient.\nThe {\\textsf{K/MT}}{} algorithm on the other hand seems to solve the problem of\nsuch ambiguities, as the reconstruction on a simplex is always\nunique. The reconstruction is unique, but in general not correct, as\nthe algorithm implicitly chooses one\nsolution, due to the previous Kuhn triangulation and by this introduces a preferential direction.\n\nDifficulties arise regarding the third property, which is fulfilled by neither the {\\textsf{MC33}}{} algorithm, nor the {\\textsf{K/MT}}{} approach.\nIn the case of {\\textsf{MC33}}{}, nodes in the cube are introduced as weighted\naverages of the position of cell vertices to describe a reconstruction\nin certain special cases. Such cases can not arise in 2D, but only\nin 3D.\nUsing these nodes in the polygonal reconstruction of the interface\n$\\partial\\Omega$, is sufficient from a visualization point of view,\nbut not for simulation purposes, as in general the nodes do not lie on\nthe interface. Depending on the numerical algorithm and the model this\ncan lead to systematic errors, e.g. in a curvature reconstruction.\n\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=4]\n\\fill[lightgray] (.5,.5) circle (0.45);\n\\draw[gray,step=0.25] (0,0) grid (1,1);\n\\draw[gray] (0.0,0.0) -- (0.25,0.25);\n\\draw[gray] (0.0,0.25) -- (0.25,0.5);\n\\draw[gray] (0.0,0.5) -- (0.25,0.75);\n\\draw[gray] (0.0,0.75) -- (0.25,1.0);\n\\draw[gray] (0.25,0.0) -- (0.5,0.25);\n\\draw[gray] (0.25,0.25) -- (0.5,0.5);\n\\draw[gray] (0.25,0.5) -- (0.5,0.75);\n\\draw[gray] (0.25,0.75) -- (0.5,1.0);\n\\draw[gray] (0.5,0.0) -- (0.75,0.25);\n\\draw[gray] (0.5,0.25) -- (0.75,0.5);\n\\draw[gray] (0.5,0.5) -- (0.75,0.75);\n\\draw[gray] (0.5,0.75) -- (0.75,1.0);\n\\draw[gray] (0.75,0.0) -- (1.0,0.25);\n\\draw[gray] (0.75,0.25) -- (1.0,0.5);\n\\draw[gray] (0.75,0.5) -- (1.0,0.75);\n\\draw[gray] (0.75,0.75) -- (1.0,1.0);\n\\draw[thick] (0.25,0.132647574033) -- (0.181801948466,0.181801948466);\n\\draw[thick] (0.132647574033,0.25) -- (0.181801948466,0.181801948466);\n\\draw[thick] (0.132647574033,0.25) -- (0.088196601125,0.338196601125);\n\\draw[thick] (0.05,0.5) -- (0.088196601125,0.338196601125);\n\\draw[thick] (0.05,0.5) -- (0.0853553390593,0.585355339059);\n\\draw[thick] (0.132647574033,0.75) -- (0.0853553390593,0.585355339059);\n\\draw[thick] (0.132647574033,0.75) -- (0.25,0.867352425967);\n\\draw[thick] (0.5,0.05) -- (0.338196601125,0.088196601125);\n\\draw[thick] (0.25,0.132647574033) -- (0.338196601125,0.088196601125);\n\\draw[thick] (0.5,0.95) -- (0.414644660941,0.914644660941);\n\\draw[thick] (0.25,0.867352425967) -- (0.414644660941,0.914644660941);\n\\draw[thick] (0.75,0.132647574033) -- (0.585355339059,0.0853553390593);\n\\draw[thick] (0.5,0.05) -- (0.585355339059,0.0853553390593);\n\\draw[thick] (0.75,0.867352425967) -- (0.661803398875,0.911803398875);\n\\draw[thick] (0.5,0.95) -- (0.661803398875,0.911803398875);\n\\draw[thick] (0.75,0.132647574033) -- (0.867352425967,0.25);\n\\draw[thick] (0.867352425967,0.25) -- (0.914644660941,0.414644660941);\n\\draw[thick] (0.95,0.5) -- (0.914644660941,0.414644660941);\n\\draw[thick] (0.95,0.5) -- (0.911803398875,0.661803398875);\n\\draw[thick] (0.867352425967,0.75) -- (0.911803398875,0.661803398875);\n\\draw[thick] (0.867352425967,0.75) -- (0.818198051534,0.818198051534);\n\\draw[thick] (0.75,0.867352425967) -- (0.818198051534,0.818198051534);\n\\end{tikzpicture} \n\n\\quad  \\begin{tikzpicture}[scale=4]\n\\fill[lightgray] (.5,.5) circle (0.45);\n\\draw[gray,step=0.25] (0,0) grid (1,1);\n\\draw[thick] (0.25,0.132647574033) -- (0.132647574033,0.25);\n\\draw[thick] (0.132647574033,0.25) -- (0.05,0.5);\n\\draw[thick] (0.05,0.5) -- (0.132647574033,0.75);\n\\draw[thick] (0.132647574033,0.75) -- (0.25,0.867352425967);\n\\draw[thick] (0.25,0.132647574033) -- (0.5,0.05);\n\\draw[thick] (0.25,0.867352425967) -- (0.5,0.95);\n\\draw[thick] (0.5,0.05) -- (0.75,0.132647574033);\n\\draw[thick] (0.5,0.95) -- (0.75,0.867352425967);\n\\draw[thick] (0.75,0.132647574033) -- (0.867352425967,0.25);\n\\draw[thick] (0.867352425967,0.25) -- (0.95,0.5);\n\\draw[thick] (0.95,0.5) -- (0.867352425967,0.75);\n\\draw[thick] (0.867352425967,0.75) -- (0.75,0.867352425967);\n\\end{tikzpicture} \n\n  \\caption{reconstructed interface of a circle using the {\\textsf{K/MT}}{} approach (left) and {\\textsf{MC33}}{} (right)}\n  \\label{fig:kmt_circle}\n\\end{figure}\n\nThe {\\textsf{K/MT}}{} algorithm first applies a simplex triangulation.\nOn each simplex, the level-set function is assumed to be linear, which is not correct, as it is actually bi-linear in 2D or tri-linear in 3D.\nThis leads to reconstructed points, which are slightly off the interface.\nIn addition, the triangulation into simplices introduces an anisotropy\nin the reconstructed interface, see Figure \\ref{fig:kmt_circle}.\n\nFurther examples of violated consistencies are shown in Section\n\\ref{sec:algorithm:consistencies}, where we will also discuss how to\nprevent these problems using the proposed {\\textsf{TPMC}}{} algorithm.\n\n\\section{Algorithm}\n\\label{sec:algorithm}\n\nIn the following section, we will describe the algorithm for computing\nthe sub-triangulation of a single grid cell using the vertex values of\nthe level-set function. All computations can be performed on the\nreference element in cell local coordinates.\n\n\\subsection{General Idea}\n\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}\n  \n  \\tikzstyle{inout}=[rectangle, draw, ultra thick]\n  \\tikzstyle{method}=[rounded corners,draw]\n  \\tikzstyle{closer}=[node distance=0.8cm]\n  \\tikzstyle{close}=[node distance=1cm]\n  \\tikzstyle{far}=[node distance=2cm]\n  \\tikzstyle{connection}=[->, >=stealth']\n  \\tikzstyle{entryexit}=[->, >=stealth', thick]\n  \n  \\node (in) [inout] {\\textit{input}};\n  \\node (entry) [above of=in, closer] {};\n  \\node (key)[method,close, below of=in] {compute key};\n  \\node (tests) [method,far, below right of=key] {perform tests};\n  \\node (coord) [method,far, below left of=tests] {compute coordinates};\n  \\node (out) [inout,close, below of=coord] {\\textit{output}};\n  \\node (exit) [below of=out, closer] {};\n  \n  \\path (entry) edge[entryexit] (in)\n        (in) edge[connection] (key)\n        (key) edge[connection]             node[right] {\\textit{ambiguous}} (tests)\n              edge[connection, bend right] node[left]  {\\textit{non-ambiguous}} (coord)\n        (tests) edge[connection] (coord)\n        (coord) edge[connection] (out)\n        (out) edge[entryexit] (exit);\n\\end{tikzpicture}\n  \\caption{structure of the general algorithm for the generation of a sub-triangulation}\n  \\label{fig:gen-subtriang}\n\\end{figure}\n\nThe main idea is to map a set of corner values to a table-index.\nThe index gives access to different tables which store precomputed general triangulations of the interior, exterior and interface of $\\Omega$.\nBased on this general triangulation we can compute the actual triangulation by incorporating the corner values.\nThe basic algorithmic structure is sketched in Figure \\ref{fig:gen-subtriang}.\n\nThe generation of the table index is subdivided into two steps: the computation of a key and, if necessary, the application of certain tests if the key is ambiguous.\nThe key of a sequence of corner values $(v_0,\\dots,v_{n-1})$ of\n$\\Phi_h$ is defined as\n\n", "index": 13, "text": "\\begin{align*}\n  \\operatorname{key}(v_0,\\dots,v_{n-1}):=\\sum_{i=0}^{n-1}\\chi_{{\\mathbb{R}}^{\\ge0}}(v_i)2^i,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\operatorname{key}(v_{0},\\dots,v_{n-1}):=\\sum_{i=0}^{n-1}\\chi_{{%&#10;\\mathbb{R}}^{\\geq 0}}(v_{i})2^{i},\" display=\"inline\"><mrow><mrow><mrow><mo>key</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mn>0</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>v</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><msub><mi>\u03c7</mi><msup><mi>\u211d</mi><mrow><mi/><mo>\u2265</mo><mn>0</mn></mrow></msup></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mn>2</mn><mi>i</mi></msup></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nAn example for the key computation on a two dimensional square is shown in Figure \\ref{fig:key-generation}.\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=2]\n  \\begin{scope}[domain=0:.5, samples=21]\n    \\fill[lightgray] (0,0) -- plot (\\x,{1.0+1.0/(2.0*\\x-2.0)});\n    \\draw (0,0) -- plot (\\x,{1.0+1.0/(2.0*\\x-2.0)});\n  \\end{scope}\n  \\draw (0,0) rectangle (1,1);\n  \\foreach \\x/\\y/\\l/\\a in {1/0/$v_1=1$/below right, 0/1/$v_2=1$/above left, 1/1/$v_3=1$/above right} {\n    \\fill[gray] (\\x,\\y) circle ({0.05}) node[\\a, black] {\\l};\n  }\n  \\foreach \\x/\\y/\\l/\\a in {0/0/$v_0=-1$/below left} {\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},-{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},-{0.05});\n    \\draw (\\x,\\y) node[\\a] {\\l};\n  }\n  \\node (anker) at (0.5,0) {};\n  \\node[below of=anker] {$\\operatorname{key}(v_0,v_1,v_2,v_3)=0111_2=14$};\n\\end{tikzpicture}\n\n  \\caption{generation of the key for a two dimensional square domain based on\n           the level set values in the corners}\n  \\label{fig:key-generation}\n\\end{figure}\nFor some cases, this key describes the topology completely.\nOther cases require additional tests to determine the triangulation.\nWe distinguish between two types of tests: face tests and center tests.\n\nThe triangulation of a quadratic face is ambiguous, if diagonally opposing vertices have the same and neighboring vertices a different sign.\nFor such a case, a test needs to be performed to decide if the face center is in $\\Omega$ or $\\hat\\Omega\\setminus\\overline\\Omega$.\nThe interface on the ambiguous face builds a hyperbola.\nAn example for such an interface can be seen in Figure \\ref{fig:hyperbola}.\n\\begin{figure}[b]\n  \\centering\n  \\begin{tikzpicture}[scale=2.5]\n  \\begin{scope}[domain=0.0:{{0.5}/({1.2}+{0.5})}, samples=21]\n    \\fill[lightgray] (0,0) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n    \\draw (0,0) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n  \\end{scope}\n  \\begin{scope}[domain={{1.2}/({1.2}+{1.4})}:1.0, samples=21]\n    \\fill[lightgray] (1,1) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n    \\draw (1,1) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n  \\end{scope}\n  \\draw[dashed, gray] ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},0) -- ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},1.0);\n  \\draw[dashed, gray] (0,{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})}) -- (1.0,{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})});\n  \\fill[gray] ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})}) circle ({0.05}) node[below right,black] {$(c_x,c_y)$};\n  \\draw (0,0) rectangle (1,1);\n  \\foreach \\x/\\y/\\l/\\a in {1/0/$v_1=B$/below right, 0/1/$v_2=C$/above left} {\n    \\fill[gray] (\\x,\\y) circle ({0.05}) node[\\a, black] {\\l};\n  }\n  \\foreach \\x/\\y/\\l/\\a in {0/0/$v_0=A$/below left, 1/1/$v_3=D$/above right} {\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},-{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},-{0.05});\n    \\draw (\\x,\\y) node[\\a] {\\l};\n  }\n\\end{tikzpicture}\n\n  \\caption{Interface of an ambiguous case on a quadratic face. $v_0$ and $v_3$ are negative and $v_1$ and $v_2$ are positive. The interface forms a hyperbola with its center located at $(c_x, c_y)$.}\n  \\label{fig:hyperbola}\n\\end{figure}\nThe sign of the face center is given as the sign of the hyperbolas center.\nFor vertex values $A,B,C,D$ at vertices $0,1,2,3$\nrespectively, the center is located (in local\ncoordinates of the face) at\n \n", "itemtype": "equation", "pos": 24149, "prevtext": "\nwhere $\\chi_M$ denotes the indicator function\n\n", "index": 15, "text": "\\begin{align*}\n  \\chi_M(x):=\n  \\begin{cases}\n    1 &,x\\in M \\\\\n    0 &,x\\not\\in M\n  \\end{cases}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\chi_{M}(x):=\\begin{cases}1&amp;,x\\in M\\\\&#10;0&amp;,x\\not\\in M\\end{cases}.\" display=\"inline\"><mrow><mrow><mrow><msub><mi>\u03c7</mi><mi>M</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mo>,</mo><mi>x</mi><mo>\u2208</mo><mi>M</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mo>,</mo><mi>x</mi><mo>\u2209</mo><mi>M</mi></mrow></mtd></mtr></mtable></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nand its sign can be computed as\n\n", "itemtype": "equation", "pos": 27971, "prevtext": "\nAn example for the key computation on a two dimensional square is shown in Figure \\ref{fig:key-generation}.\n\\begin{figure}\n  \\centering\n  \\begin{tikzpicture}[scale=2]\n  \\begin{scope}[domain=0:.5, samples=21]\n    \\fill[lightgray] (0,0) -- plot (\\x,{1.0+1.0/(2.0*\\x-2.0)});\n    \\draw (0,0) -- plot (\\x,{1.0+1.0/(2.0*\\x-2.0)});\n  \\end{scope}\n  \\draw (0,0) rectangle (1,1);\n  \\foreach \\x/\\y/\\l/\\a in {1/0/$v_1=1$/below right, 0/1/$v_2=1$/above left, 1/1/$v_3=1$/above right} {\n    \\fill[gray] (\\x,\\y) circle ({0.05}) node[\\a, black] {\\l};\n  }\n  \\foreach \\x/\\y/\\l/\\a in {0/0/$v_0=-1$/below left} {\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},-{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},-{0.05});\n    \\draw (\\x,\\y) node[\\a] {\\l};\n  }\n  \\node (anker) at (0.5,0) {};\n  \\node[below of=anker] {$\\operatorname{key}(v_0,v_1,v_2,v_3)=0111_2=14$};\n\\end{tikzpicture}\n\n  \\caption{generation of the key for a two dimensional square domain based on\n           the level set values in the corners}\n  \\label{fig:key-generation}\n\\end{figure}\nFor some cases, this key describes the topology completely.\nOther cases require additional tests to determine the triangulation.\nWe distinguish between two types of tests: face tests and center tests.\n\nThe triangulation of a quadratic face is ambiguous, if diagonally opposing vertices have the same and neighboring vertices a different sign.\nFor such a case, a test needs to be performed to decide if the face center is in $\\Omega$ or $\\hat\\Omega\\setminus\\overline\\Omega$.\nThe interface on the ambiguous face builds a hyperbola.\nAn example for such an interface can be seen in Figure \\ref{fig:hyperbola}.\n\\begin{figure}[b]\n  \\centering\n  \\begin{tikzpicture}[scale=2.5]\n  \\begin{scope}[domain=0.0:{{0.5}/({1.2}+{0.5})}, samples=21]\n    \\fill[lightgray] (0,0) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n    \\draw (0,0) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n  \\end{scope}\n  \\begin{scope}[domain={{1.2}/({1.2}+{1.4})}:1.0, samples=21]\n    \\fill[lightgray] (1,1) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n    \\draw (1,1) -- plot (\\x,{({0.5}-({1.2}+{0.5})*\\x)/({1.2}+{0.5}-({0.5}+2.0*{1.2}+{1.4})*\\x)});\n  \\end{scope}\n  \\draw[dashed, gray] ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},0) -- ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},1.0);\n  \\draw[dashed, gray] (0,{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})}) -- (1.0,{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})});\n  \\fill[gray] ({({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})},{({0.5}+{1.2})/({0.5}+2.0*{1.2}+{1.4})}) circle ({0.05}) node[below right,black] {$(c_x,c_y)$};\n  \\draw (0,0) rectangle (1,1);\n  \\foreach \\x/\\y/\\l/\\a in {1/0/$v_1=B$/below right, 0/1/$v_2=C$/above left} {\n    \\fill[gray] (\\x,\\y) circle ({0.05}) node[\\a, black] {\\l};\n  }\n  \\foreach \\x/\\y/\\l/\\a in {0/0/$v_0=A$/below left, 1/1/$v_3=D$/above right} {\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +({0.05},-{0.05});\n    \\draw[ultra thick] (\\x,\\y) -- +(-{0.05},-{0.05});\n    \\draw (\\x,\\y) node[\\a] {\\l};\n  }\n\\end{tikzpicture}\n\n  \\caption{Interface of an ambiguous case on a quadratic face. $v_0$ and $v_3$ are negative and $v_1$ and $v_2$ are positive. The interface forms a hyperbola with its center located at $(c_x, c_y)$.}\n  \\label{fig:hyperbola}\n\\end{figure}\nThe sign of the face center is given as the sign of the hyperbolas center.\nFor vertex values $A,B,C,D$ at vertices $0,1,2,3$\nrespectively, the center is located (in local\ncoordinates of the face) at\n \n", "index": 17, "text": "\\begin{align*}\n  (c_x,c_y):=\\left(\\frac{A-C}{A-B-C+D},\n    \\frac{A-B}{A-B-C+D}\\right).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(c_{x},c_{y}):=\\left(\\frac{A-C}{A-B-C+D},\\frac{A-B}{A-B-C+D}%&#10;\\right).\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mi>x</mi></msub><mo>,</mo><msub><mi>c</mi><mi>y</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>:=</mo><mrow><mo>(</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>A</mi><mo>-</mo><mi>C</mi></mrow><mrow><mrow><mi>A</mi><mo>-</mo><mi>B</mi><mo>-</mo><mi>C</mi></mrow><mo>+</mo><mi>D</mi></mrow></mfrac></mstyle><mo>,</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>A</mi><mo>-</mo><mi>B</mi></mrow><mrow><mrow><mi>A</mi><mo>-</mo><mi>B</mi><mo>-</mo><mi>C</mi></mrow><mo>+</mo><mi>D</mi></mrow></mfrac></mstyle><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nFor further details, we refer to \\cite{Chernyaev1995}. In three space\ndimensions further ambiguities can occur.\n\nVertices which are not connected via a face can still be connected\nthrough the volume. This means that the iso-surface forms a kind of\ntube through the element.\nA method to test this has been presented in \\cite{Chernyaev1995} which we will recall here.\nLet $v$ and $w$ denote two vertices on opposite ends of a diagonal of the cube\nwhich have the same sign and are not connected via a set of faces. If and only\nif $v$ and $w$ are connected through the cubes volume, there exists a plane\nparallel to a face on which the projections of $v$ and $w$ are connected. This\nconnection can be explicitly calculated in terms of the cubes vertex values.\nLet $A_0,B_0,C_0$ and $D_0$ denote the values at the vertices of the face containing $v$\nand $A_1,B_1,C_1$ and $D_1$ denote the values at the vertices of the face containing $w$,\nwhile $A_0$ denotes the value at $v$ and $D_1$ denotes the value at $w$.\nWe assume that $A_0$ and $D_1$ have a positive sign.\nThe value along an edge perpendicular to the two faces is given by the linear functions $A_t,B_t,C_t,D_t$ for $t\\in[0,1]$.\nTo calculate the connection, we consider the following quadratic function\n\n", "itemtype": "equation", "pos": 28103, "prevtext": "\nand its sign can be computed as\n\n", "index": 19, "text": "\\begin{align*}\n  {\\operatorname{sgn}}(A){\\operatorname{sgn}}(AD-BC).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\operatorname{sgn}}(A){\\operatorname{sgn}}(AD-BC).\" display=\"inline\"><mrow><mrow><mrow><mo>sgn</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mo>sgn</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mi>D</mi></mrow><mo>-</mo><mrow><mi>B</mi><mo>\u2062</mo><mi>C</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nwhere the coefficients $a,b,c\\in{\\mathbb{R}}$ are given by\n\n", "itemtype": "equation", "pos": 29443, "prevtext": "\nFor further details, we refer to \\cite{Chernyaev1995}. In three space\ndimensions further ambiguities can occur.\n\nVertices which are not connected via a face can still be connected\nthrough the volume. This means that the iso-surface forms a kind of\ntube through the element.\nA method to test this has been presented in \\cite{Chernyaev1995} which we will recall here.\nLet $v$ and $w$ denote two vertices on opposite ends of a diagonal of the cube\nwhich have the same sign and are not connected via a set of faces. If and only\nif $v$ and $w$ are connected through the cubes volume, there exists a plane\nparallel to a face on which the projections of $v$ and $w$ are connected. This\nconnection can be explicitly calculated in terms of the cubes vertex values.\nLet $A_0,B_0,C_0$ and $D_0$ denote the values at the vertices of the face containing $v$\nand $A_1,B_1,C_1$ and $D_1$ denote the values at the vertices of the face containing $w$,\nwhile $A_0$ denotes the value at $v$ and $D_1$ denotes the value at $w$.\nWe assume that $A_0$ and $D_1$ have a positive sign.\nThe value along an edge perpendicular to the two faces is given by the linear functions $A_t,B_t,C_t,D_t$ for $t\\in[0,1]$.\nTo calculate the connection, we consider the following quadratic function\n\n", "index": 21, "text": "\\begin{equation}\n  p:[0,1]\\to{\\mathbb{R}}; t\\mapsto A_tD_t-B_tC_t=at^2+bt+c\\,, \\label{eq:quadratic}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"p:[0,1]\\to{\\mathbb{R}};t\\mapsto A_{t}D_{t}-B_{t}C_{t}=at^{2}+bt+c\\,,\" display=\"block\"><mrow><mrow><mi>p</mi><mo>:</mo><mrow><mrow><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><mo>\u2192</mo><mi>\u211d</mi></mrow><mo>;</mo><mrow><mi>t</mi><mo>\u21a6</mo><mrow><mrow><msub><mi>A</mi><mi>t</mi></msub><mo>\u2062</mo><msub><mi>D</mi><mi>t</mi></msub></mrow><mo>-</mo><mrow><msub><mi>B</mi><mi>t</mi></msub><mo>\u2062</mo><msub><mi>C</mi><mi>t</mi></msub></mrow></mrow><mo>=</mo><mrow><mrow><mi>a</mi><mo>\u2062</mo><msup><mi>t</mi><mn>2</mn></msup></mrow><mo>+</mo><mrow><mi>b</mi><mo>\u2062</mo><mi>t</mi></mrow><mo>+</mo><mpadded width=\"+1.7pt\"><mi>c</mi></mpadded></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nThe value of $p$ corresponds to the value of the center of the hyperbola on the given plane.\nThe positive areas are connected, if $p$ has a maximum at $t_{\\operatorname{max}} \\in [0,1]$ with $p(t_{\\operatorname{max}})>0$ and the values $A_t,B_t,C_t,D_t$ have the correct sign. Otherwise they are separated.\nAgain, we refer to \\cite{Chernyaev1995} for a detailed description.\n\nThe necessary tests for a specific case form a tree structure, which\nis traversed in order to calculate the table index.\nA table containing the necessary tests is available in an online resource of \\cite{Lewiner2003}.\nNote though, that we found two tests to be missing: for cases 10 and 12 with positive tests for both ambiguous faces, one has to check whether the exterior vertices are connected through the cube.\n\nOnce the table index has been computed, it can be used to retrieve general triangulations.\nSuch a triangulation describes its local elements using the vertex numbering of the reference element.\nThe actual coordinates are computed using the vertex values.\nWe distinguish between five types of vertices which are described in Section \\ref{sec:construction_of_vertices}.\n\n\\subsection{Additional consistencies}\n\\label{sec:algorithm:consistencies}\n\nAs noted in Section \\ref{sec:preliminaries} additional consistencies\nare required to ensure the topological guarantees. The {\\textsf{MC33}}{}\nimproves the classical {\\textsf{MC}}{} algorithm to ensure topological\nconsistency for the reconstructed interface. While this is sufficient\nfor visualization, it is in general not sufficient for numerical\nsimulations.\n\n\\begin{figure}[t]\n \\centering\n \\includegraphics[width=0.3\\textwidth]{pics/test_levelset}\n \\includegraphics[width=0.3\\textwidth]{pics/test_lewiner}\n \\includegraphics[width=0.3\\textwidth]{pics/test_our}\n \\caption{\n    Violation of the topologic consistency in a face (front), using {\\textsf{MC33}}{} and the correct reconstruction using {\\textsf{TPMC}}.\n    Left: discrete level-set, center: reconstruction from {\\textsf{MC33}}{}\n    (case 6.1.2 of \\cite{Lewiner2003}), right: {\\textsf{TPMC}}{}\n    reconstruction.\n    For the choice of vertex values see Table \\ref{tab:face_error}.}\n   \\label{fig:face_error}\n\\end{figure}\n\n\\begin{table}[t]\n  \\centering\n    \\begin{tabular}{l|rrrrrrrr}\n      \\hline\\hline\n      \\rule{0pt}{3ex}Vtx & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n      Pos & (0,0,0) & (0,0,1) & (0,1,0) & (0,1,1) & (1,0,0) & (1,0,1) & (1,1,0) & (1,1,1) \\\\\n      Value & -4 & 4 & -1 & -1 & 2 & -3 & 5 & -1\\[1ex]\n      \\hline\\hline\n    \\end{tabular}\n  \\caption{Vertex values for the example illustrated\n    in Figure \\ref{fig:face_error}.}\\label{tab:face_error}\n\\end{table}\n\nWe want to illustrate the issue with a concrete example. Figure\n\\ref{fig:face_error} shows on the left the correct interface of a\ntri-linear function with vertex values as listed in table\n\\ref{tab:face_error}. After resolving the ambiguities the {\\textsf{MC33}}{}\nalgorithm provides a reconstruction where parts of the interface are\nnot in the interior of the cell anymore, but are pushed into the\nfrontal face of the cube; the volume which lies in-between vanishes when using\nthe discrete level-set function. This leads to an\nunresolvable inconsistency between the trace of the volume\nreconstruction and a direct reconstruction in the cube face.\nTherefore, these reconstructions do not fulfill the topological\nguarantees and are not accurate enough for numerical purposes.  This\nissue can be resolved, by adding interior points to reconstruct the\ninterface and especially the vanishing volume more accurately.\n\n\\subsection{Construction of Vertices}\n\\label{sec:construction_of_vertices}\n\nBased on the general reconstruction rule stored in the look-up table\nthe actual reconstruction is computed. This requires the construction\nof vertices based on the actual vertex values. We distinguish between\nfive types of vertices:\n\\begin{enumerate}\n\\item \\emph{original vertices}:\\\\\n  For the volume reconstruction we have to incorporate the vertices of the\n  reference element, our implementation is based on a dimension\n  independent numbering used in the DUNE framework (see Figure \\ref{fig:reference_elements}).\n\\item \\emph{edge vertices}:\\\\\n  These vertices describe the position of the interface along an edge\n  of the reference element. As the level-set is linear along an edge\n  the position is easily computed as weighted average\n  \n", "itemtype": "equation", "pos": 29617, "prevtext": "\nwhere the coefficients $a,b,c\\in{\\mathbb{R}}$ are given by\n\n", "index": 23, "text": "\\begin{align*}\n  a =& (A_1-A_0)(D_1-D_0)-(C_1-C_0)(B_1-B_0) \\\\\n  b =& D_0(A_1-A_0)+A_0(D_1-D_0)-B_0(C_1-C_0)-C_0(B_1-B_0) \\\\\n  \n  \n  c =& A_0D_0-B_0C_0\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle a=\" display=\"inline\"><mrow><mi>a</mi><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(A_{1}-A_{0})(D_{1}-D_{0})-(C_{1}-C_{0})(B_{1}-B_{0})\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>-</mo><msub><mi>A</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>-</mo><msub><mi>D</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>-</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>-</mo><msub><mi>B</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle b=\" display=\"inline\"><mrow><mi>b</mi><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle D_{0}(A_{1}-A_{0})+A_{0}(D_{1}-D_{0})-B_{0}(C_{1}-C_{0})-C_{0}(B%&#10;_{1}-B_{0})\" display=\"inline\"><mrow><mrow><mrow><msub><mi>D</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>-</mo><msub><mi>A</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>-</mo><msub><mi>D</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><msub><mi>B</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>-</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mn>1</mn></msub><mo>-</mo><msub><mi>B</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\par&#10;\\par&#10; c=\" display=\"inline\"><mrow><mi>c</mi><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle A_{0}D_{0}-B_{0}C_{0}\" display=\"inline\"><mrow><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>\u2062</mo><msub><mi>D</mi><mn>0</mn></msub></mrow><mo>-</mo><mrow><msub><mi>B</mi><mn>0</mn></msub><mo>\u2062</mo><msub><mi>C</mi><mn>0</mn></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\n  where $A,B$ denote the level-set values of the vertices at $x_A,x_B$ of the edge.\n\\end{enumerate}\nIn order to resolve the issues described in Section \\ref{sec:algorithm:consistencies} we require additional vertices in the interior of the cell.\n\\begin{enumerate}[resume]\n\\item \\emph{maximum vertices}:\\\\\n  By maximum vertices we denote the vertices given by the maximum of the quadratic function $p$ defined in equation \\eqref{eq:quadratic} of the interior connectivity test.\n\n  Such a vertex is located at the ``center'' of the constriction of a tube-like structure. For an example\n  of such a structure see Figure \\ref{fig:face_error} and an example of a maximum vertex see Figure \\ref{fig:vertex_max_and_root}.\n  They are not used directly in the triangulation since they do not lie on the interface, but are used as helper vertices for vertices of type \\ref{it:interiorvertices}.\n\\item \\emph{root vertices}: \\\\\n  Root vertices are defined similar to maximum vertices and are given by the roots of the quadratic function $p$ defined in equation \\eqref{eq:quadratic}.\n  If the interior connectivity test is positive,\n  there is a plane (defined by $t_{\\operatorname{max}}$) parallel to a given face of the cube where the restricted interface forms a hyperbola.\n  Moving the plane along its normal and following the path of the center of the hyperbola, the root vertices are given by the intersection of the path with the interface.\n  An example for a root vertex is shown in Figure \\ref{fig:vertex_max_and_root}.\n  Note that such a point always exists as in this case the sign at the\n  center of the hyperbola is known to change.\n\\item\\label{it:interiorvertices} \\emph{interior vertices}:\\\\\n  \n  \n  \n  These points are\n  computed as the intersection between the iso-surface and an a-priori\n  chosen line. As the line is not axis-aligned and the level-set\n  function $\\Phi_h$ is tri-linear we can have up to three intersection\n  points along the line. We compute all intersection simultaneously\n  using the Aberth algorithm \\cite{aberth1973}.\n  The latter is a Newton-type iterative method for finding the roots of a\n  polynomial. It makes sure that no two approximations converge to the same\n  roots.\n\\end{enumerate}\n\n\\begin{figure}[t]\n \\centering\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_max}\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_root}\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_intersection}\n \\caption{\n   Maximum vertex (left), root vertex (center) and intersection vertex (right) for the basic case 6.1.2. For the choice of vertex values see Table \\ref{tab:face_error}.  }\n   \\label{fig:vertex_max_and_root}\n\\end{figure}\n\n\\begin{example}[Construction of interior; case 6.1.2]\n  \\label{example:construction}\n  To illustrate the different steps of the algorithm,\n  we consider the example illustrated in Figure \\ref{fig:face_error}.\n  The according vertex values are listed in Table\n  \\ref{tab:face_error} and the vertex value yield the key $01001010_2=82$,\n  which correspond to the basic case 6 (see \\cite{Lewiner2003}). This\n  case is ambiguous as vertices $1$ and $6$, which are connected via a diagonal through the cube,\n  have the same sign and are not connected over faces of the cube.\n  To perform the corresponding test, we compute the coefficients of the quadratic function with respect to the front face, which is given as\n  \n", "itemtype": "equation", "pos": 34185, "prevtext": "\nThe value of $p$ corresponds to the value of the center of the hyperbola on the given plane.\nThe positive areas are connected, if $p$ has a maximum at $t_{\\operatorname{max}} \\in [0,1]$ with $p(t_{\\operatorname{max}})>0$ and the values $A_t,B_t,C_t,D_t$ have the correct sign. Otherwise they are separated.\nAgain, we refer to \\cite{Chernyaev1995} for a detailed description.\n\nThe necessary tests for a specific case form a tree structure, which\nis traversed in order to calculate the table index.\nA table containing the necessary tests is available in an online resource of \\cite{Lewiner2003}.\nNote though, that we found two tests to be missing: for cases 10 and 12 with positive tests for both ambiguous faces, one has to check whether the exterior vertices are connected through the cube.\n\nOnce the table index has been computed, it can be used to retrieve general triangulations.\nSuch a triangulation describes its local elements using the vertex numbering of the reference element.\nThe actual coordinates are computed using the vertex values.\nWe distinguish between five types of vertices which are described in Section \\ref{sec:construction_of_vertices}.\n\n\\subsection{Additional consistencies}\n\\label{sec:algorithm:consistencies}\n\nAs noted in Section \\ref{sec:preliminaries} additional consistencies\nare required to ensure the topological guarantees. The {\\textsf{MC33}}{}\nimproves the classical {\\textsf{MC}}{} algorithm to ensure topological\nconsistency for the reconstructed interface. While this is sufficient\nfor visualization, it is in general not sufficient for numerical\nsimulations.\n\n\\begin{figure}[t]\n \\centering\n \\includegraphics[width=0.3\\textwidth]{pics/test_levelset}\n \\includegraphics[width=0.3\\textwidth]{pics/test_lewiner}\n \\includegraphics[width=0.3\\textwidth]{pics/test_our}\n \\caption{\n    Violation of the topologic consistency in a face (front), using {\\textsf{MC33}}{} and the correct reconstruction using {\\textsf{TPMC}}.\n    Left: discrete level-set, center: reconstruction from {\\textsf{MC33}}{}\n    (case 6.1.2 of \\cite{Lewiner2003}), right: {\\textsf{TPMC}}{}\n    reconstruction.\n    For the choice of vertex values see Table \\ref{tab:face_error}.}\n   \\label{fig:face_error}\n\\end{figure}\n\n\\begin{table}[t]\n  \\centering\n    \\begin{tabular}{l|rrrrrrrr}\n      \\hline\\hline\n      \\rule{0pt}{3ex}Vtx & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n      Pos & (0,0,0) & (0,0,1) & (0,1,0) & (0,1,1) & (1,0,0) & (1,0,1) & (1,1,0) & (1,1,1) \\\\\n      Value & -4 & 4 & -1 & -1 & 2 & -3 & 5 & -1\\[1ex]\n      \\hline\\hline\n    \\end{tabular}\n  \\caption{Vertex values for the example illustrated\n    in Figure \\ref{fig:face_error}.}\\label{tab:face_error}\n\\end{table}\n\nWe want to illustrate the issue with a concrete example. Figure\n\\ref{fig:face_error} shows on the left the correct interface of a\ntri-linear function with vertex values as listed in table\n\\ref{tab:face_error}. After resolving the ambiguities the {\\textsf{MC33}}{}\nalgorithm provides a reconstruction where parts of the interface are\nnot in the interior of the cell anymore, but are pushed into the\nfrontal face of the cube; the volume which lies in-between vanishes when using\nthe discrete level-set function. This leads to an\nunresolvable inconsistency between the trace of the volume\nreconstruction and a direct reconstruction in the cube face.\nTherefore, these reconstructions do not fulfill the topological\nguarantees and are not accurate enough for numerical purposes.  This\nissue can be resolved, by adding interior points to reconstruct the\ninterface and especially the vanishing volume more accurately.\n\n\\subsection{Construction of Vertices}\n\\label{sec:construction_of_vertices}\n\nBased on the general reconstruction rule stored in the look-up table\nthe actual reconstruction is computed. This requires the construction\nof vertices based on the actual vertex values. We distinguish between\nfive types of vertices:\n\\begin{enumerate}\n\\item \\emph{original vertices}:\\\\\n  For the volume reconstruction we have to incorporate the vertices of the\n  reference element, our implementation is based on a dimension\n  independent numbering used in the DUNE framework (see Figure \\ref{fig:reference_elements}).\n\\item \\emph{edge vertices}:\\\\\n  These vertices describe the position of the interface along an edge\n  of the reference element. As the level-set is linear along an edge\n  the position is easily computed as weighted average\n  \n", "index": 25, "text": "\\begin{equation*}\n    x_{\\{A,B\\}} = x_A \\frac{B}{B - A} + x_B \\frac{A}{A - B}\n  \\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"x_{\\{A,B\\}}=x_{A}\\frac{B}{B-A}+x_{B}\\frac{A}{A-B}\" display=\"block\"><mrow><msub><mi>x</mi><mrow><mo stretchy=\"false\">{</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo stretchy=\"false\">}</mo></mrow></msub><mo>=</mo><mrow><mrow><msub><mi>x</mi><mi>A</mi></msub><mo>\u2062</mo><mfrac><mi>B</mi><mrow><mi>B</mi><mo>-</mo><mi>A</mi></mrow></mfrac></mrow><mo>+</mo><mrow><msub><mi>x</mi><mi>B</mi></msub><mo>\u2062</mo><mfrac><mi>A</mi><mrow><mi>A</mi><mo>-</mo><mi>B</mi></mrow></mfrac></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\n  This function has a maximum at $t_{\\operatorname{max}}=7/84\\in[0,1]$ and $p(t_{\\operatorname{max}})=5/168>0$.\n  The values of the projections are $A_{t_{\\operatorname{max}}}=1/12$, $B_{t_{\\operatorname{max}}}=-1$, $C_{t_{\\operatorname{max}}}=-9/14$ and $D_{t_{\\operatorname{max}}}=3/14$.\n  These values show, that in the plane of $t_{\\operatorname{max}}$, $A_0$ and $D_1$ are connected.\n  This result corresponds to the basic case 6.1.2.\n\n  For this basic case we query the look-up tables and obtain\n  reconstruction rules for interior, exterior and interface, which\n  describes a set of parts as a list of vertices and a list of\n  elements/faces. These describe primitive geometric objects, suitable\n  for numerical integration.\n  In our implementation the reconstruction of the interior,\n  exterior and interface contain lists of 23, 21 and 15 parts\n  respectively.  The vertices in these lists are encoded via their\n  associated subentity in the reference element.  The lists for the specific case\n  6.1.2 contain for example reference vertex $3$, which is located at\n  $(1,1,0)$.  Another example is the intersection vertex between the\n  reference vertices $1$ (located at $(1,0,0)$) and $3$.  This vertex\n  is found by linear interpolation from the vertex values $4$ and $-1$\n  which gives $(1,4/5,0)$.  A more complex example is the intersection\n  vertex between the maximum vertex and the middle point on the edge\n  of vertices $0$ and $2$ as shown in the right Figure\n  \\ref{fig:vertex_max_and_root}.  First, we compute the maximum vertex\n  by computing the center of the hyperbola in the plane parallel to\n  the front face at $t_{\\operatorname{max}}=7/84$. This vertex is\n  given as approximately $(0.61017, 0.45238, 0.44552)$ (see Figure\n  \\ref{fig:vertex_max_and_root} left). In general $\\Phi$ is locally a\n  trilinear function, thus we use the Aberth-method to\n  get the intersection with interface of the line between this maximum\n  vertex and the center $(0,0.5,0)$ of the edge between vertices $0$\n  and $2$. The intersection vertex is approximately $(0.54437,\n  0.45752, 0.39748)$.  We compute the vertex position for each vertex\n  in the list by the methods defined above.  From these vertices we\n  can construct the volume of the interior and exterior as the union\n  of the respective parts.\n\\end{example}\n\n\\section{Implementation}\n\\label{sec:implementation}\n\nAn implementation of the algorithm is available via\n\\texttt{python-pip}, all tests performed in this paper are available\nfor download from ZENODO~\\cite{download-tpmc}. A python\nlibrary contains a list of all basic cases and their associated\ninformation. From the basic cases the python code computes the full\nlist and can then generate C++ code. This generated code only uses\nstandard C++ components and can easily be used in other projects. The\ncode is in productive use in DUNE for our implementation of the Unfitted Dicontinuous\nGalerkin method~\\cite{engwer2010:duneudg}.\n\nThe C++ library stores all information in a set of different look-up\ntables. The tests are stored as binary trees in breadth-first\norder as an implicit data structure in arrays. The library provides a basic interface to perform the\ntests and export geometric reconstructions as sets\nof sets of vertices. The library is templated, so that it can work\nwith user defined container types and coordinate types. This allows to incorporate it\ninto existing projects, without having to change internal data\nstructures. As the look-up tables are stored as plain C arrays, they can also\nbe incorporated into C or Fortran applications.\n\n\\subsection{Look-up tables}\nThe geometric information of the sub-triangulation parts for each case is stored in three different tables:\n\\begin{enumerate}\n\\item Reconstruction of the interface $\\Gamma$\n\\item Reconstruction of $\\Omega$\n\\item Reconstruction of the complement of $\\Omega$\n\\end{enumerate}\nNote that we store two different tables for $\\Omega$ and its complement.\nNaively a sub-triangulation of the complement\n$\\hat\\Omega\\setminus\\Omega$ could be computed by simply inverting the sign of the level set function.\nHowever, the resulting triangulation of $\\hat\\Omega$ will in general\nno longer form a partition, it might contain holes or overlapping parts.\nTo avoid this, both sub-triangulations have to be constructed with a matching interface.\nThe vertices of the parts are encoded using their position in the reference element.\nThe ordering of the vertices of each interface part is done such that\nthe normal vectors to $\\Gamma$ can be computed using the right hand\nrule, i.e. the direction of the normal vector of an interface part with vertices $x_0,x_1,x_2,\\dots$ is given by the cross product of the tangential axes: $(x_1-x_0)\\times(x_2-x_0)$.\n\nIn addition to the general geometric information we store information about the connectivity pattern w.r.t. each sub-domain.\nFor each sub-triangulation part and each vertex we store an index of the local connected component it belongs to.\nUsing this information, the global connectivity pattern can be computed without geometric coordinate comparisons.\n\nLook-up tables are provided for all primitive geometries up to\ndimension three, i.e. for lines, triangles, quadrilateral, tetrahedra,\nprisms, pyramids and hexahedra. Thus the library can be used with a\nbroad range of discrete level-set representations.\n\n\\subsection{Example}\n\nFollowing the sketch in Figure \\ref{fig:gen-subtriang} we first compute a\nkey based on given vertex values. If we encounter an ambiguous case,\nthis involves a set of different tests, which are retrieved from a\nbinary tree stored in\ntable \\texttt{table\\_cube3d\\_mc33\\_face\\_test\\_order}. In the next\nstep we compute all internal vertices listed in; as these computations might be\nexpensive, it is done in a seperate step to avoid repetitive\ncomputation. The list of necessary\nvertices is stored in \\texttt{table\\_cube3d\\_vertices}. As the last step, we retrieve the\ndesired information, e.g. the reconstruction of the interior domain\n$\\Omega$. In this particular example\n\\texttt{table\\_cube3d\\_cases\\_offsets} yields offsets into a\nreconstruction table, e.g. \\texttt{table\\_cube3dsym\\_codim\\_0\\_interior}\nfor the interior domain.\n\nThe corresponding C++ user code to compute the construction described in\nExample \\ref{example:construction} is listed in Algorithm \\ref{alg:usercode}.\n\\begin{algorithm}[t]\n\\caption{C++ user code to compute an interior domain decomposition, as\n  described in Example \\ref{example:construction}.}\n\\begin{lstlisting}\n// some necessary typedefs\nstatic unsigned int dim = 3;\ntypedef std::array<double,dim> Coordinate;\n// instantiate the algorithm and some additional\n// structures\ntpmc::MarchingCubes<double, dim, Coordinate> mc;\ntpmc::GeometryType geometry = tpmc::cube;\nstd::vector<Coordinate> vertices;\nvertices.reserve(mc.getMaximalVertexCount(geometry));\n// describe the geometry\nstd::vector<double> vertex_values =\n    {-4.0, 4.0, -1.0, -1.0, 2.0, -3.0, 5.0, -1.0};\n// compute the key\nstd::size_t key = mc.getKey(vertex_values.begin(),\n                            vertex_values.end());\n// compute additional vertices and append them\nmc.getVertices(vertex_values.begin(), vertex_values.end(),\n               key,\n               std::back_inserter(vertices)\n              );\n// compute interior reconstruction and store them in\n// decomposition\nstd::vector< std::vector<int> > decomposition;\nmc.getElements(geometry, key, tpmc::InteriorDomain,\n               std::back_inserter(decomposition)\n              );\n\\end{lstlisting}\n\\label{alg:usercode}\n\\end{algorithm}\n\nThe decomposition of the interior domain is described as a cell-to-vertex\nmap in the form $C_i \\rightarrow \\{ v_j \\}$. Each entry describes a\nprimitive geometry.\nThis map is stored in the \\lstinline!decomposition! variable.\nGiven the vertex numbers of a cell the actual coordinates are\nobtained by a lookup in the vector of vertex coordinates, stored in\n\\lstinline!vertices!. This description follows the approach used in\nmost mesh file formats.\n\n\\section{Evaluation}\n\\label{sec:evaluation}\n\nWe present different numerical tests to evaluate the accuracy, the\nrobustness and the efficiency of the proposed algorithm.\n\n\\subsection{Surface Integral over two entangled Tori}\nTo evaluate the convergence rate of the integration method, we use a test level-set function representing two tori.\nWe set $\\hat\\Omega=[0,1]^3\\subset{\\mathbb{R}}^3$ as the outer domain.\nFor a unit vector $n\\in{\\mathbb{R}}^3$ we define its associated hyperplane as $H(n):=\\lbrace x\\in\\hat\\Omega|\\langle x,n\\rangle=0\\rbrace$.\nThe orthogonal projection onto $H(n)$ is then given by $P(n)(x)=x-\\langle x,n\\rangle n$.\nThe level-set function of a torus with radius $R\\in{\\mathbb{R}}$ and tube\nradius $r\\in{\\mathbb{R}}$ in a hyperplane $H(n)$ is given by\n\n", "itemtype": "equation", "pos": 37654, "prevtext": "\n  where $A,B$ denote the level-set values of the vertices at $x_A,x_B$ of the edge.\n\\end{enumerate}\nIn order to resolve the issues described in Section \\ref{sec:algorithm:consistencies} we require additional vertices in the interior of the cell.\n\\begin{enumerate}[resume]\n\\item \\emph{maximum vertices}:\\\\\n  By maximum vertices we denote the vertices given by the maximum of the quadratic function $p$ defined in equation \\eqref{eq:quadratic} of the interior connectivity test.\n\n  Such a vertex is located at the ``center'' of the constriction of a tube-like structure. For an example\n  of such a structure see Figure \\ref{fig:face_error} and an example of a maximum vertex see Figure \\ref{fig:vertex_max_and_root}.\n  They are not used directly in the triangulation since they do not lie on the interface, but are used as helper vertices for vertices of type \\ref{it:interiorvertices}.\n\\item \\emph{root vertices}: \\\\\n  Root vertices are defined similar to maximum vertices and are given by the roots of the quadratic function $p$ defined in equation \\eqref{eq:quadratic}.\n  If the interior connectivity test is positive,\n  there is a plane (defined by $t_{\\operatorname{max}}$) parallel to a given face of the cube where the restricted interface forms a hyperbola.\n  Moving the plane along its normal and following the path of the center of the hyperbola, the root vertices are given by the intersection of the path with the interface.\n  An example for a root vertex is shown in Figure \\ref{fig:vertex_max_and_root}.\n  Note that such a point always exists as in this case the sign at the\n  center of the hyperbola is known to change.\n\\item\\label{it:interiorvertices} \\emph{interior vertices}:\\\\\n  \n  \n  \n  These points are\n  computed as the intersection between the iso-surface and an a-priori\n  chosen line. As the line is not axis-aligned and the level-set\n  function $\\Phi_h$ is tri-linear we can have up to three intersection\n  points along the line. We compute all intersection simultaneously\n  using the Aberth algorithm \\cite{aberth1973}.\n  The latter is a Newton-type iterative method for finding the roots of a\n  polynomial. It makes sure that no two approximations converge to the same\n  roots.\n\\end{enumerate}\n\n\\begin{figure}[t]\n \\centering\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_max}\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_root}\n \\includegraphics[width=0.3\\textwidth]{pics/vertex_intersection}\n \\caption{\n   Maximum vertex (left), root vertex (center) and intersection vertex (right) for the basic case 6.1.2. For the choice of vertex values see Table \\ref{tab:face_error}.  }\n   \\label{fig:vertex_max_and_root}\n\\end{figure}\n\n\\begin{example}[Construction of interior; case 6.1.2]\n  \\label{example:construction}\n  To illustrate the different steps of the algorithm,\n  we consider the example illustrated in Figure \\ref{fig:face_error}.\n  The according vertex values are listed in Table\n  \\ref{tab:face_error} and the vertex value yield the key $01001010_2=82$,\n  which correspond to the basic case 6 (see \\cite{Lewiner2003}). This\n  case is ambiguous as vertices $1$ and $6$, which are connected via a diagonal through the cube,\n  have the same sign and are not connected over faces of the cube.\n  To perform the corresponding test, we compute the coefficients of the quadratic function with respect to the front face, which is given as\n  \n", "index": 27, "text": "\\begin{align*}\n    p(t)=-42t^2+37t-8\n  \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle p(t)=-42t^{2}+37t-8\" display=\"inline\"><mrow><mrow><mi>p</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo>-</mo><mrow><mn>42</mn><mo>\u2062</mo><msup><mi>t</mi><mn>2</mn></msup></mrow></mrow><mo>+</mo><mrow><mn>37</mn><mo>\u2062</mo><mi>t</mi></mrow></mrow><mo>-</mo><mn>8</mn></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\n\\begin{figure}\n \\centering\n \\includegraphics[width=0.45\\linewidth]{pics/torigray}\\hspace{0.25cm}\n \\begin{tikzpicture}[scale=2]\n  \\fill[lightgray!50!white] (0,-0.2) rectangle (1.6,0.2);\n  \\draw[gray!50!white,dashed] (0,0) -- (1.6,0);\n  \\draw[gray!50!white,thick] (0,0.2) -- (1.6,0.2);\n  \\draw[gray!50!white,thick] (0,-0.2) -- (1.6,-0.2);\n  \\fill[lightgray] (0,0) circle (1.0);\n  \\fill[white] (0,0) circle (0.6);\n  \\begin{scope}\n    \\clip (0,0) circle (0.6);\n    \\fill[lightgray!50!white] (0,-0.2) rectangle (1.6,0.2);\n    \\draw[gray!50!white,dashed] (0,0) -- (1.6,0);\n    \\draw[gray!50!white,thick] (0,0.2) -- (1.6,0.2);\n    \\draw[gray!50!white,thick] (0,-0.2) -- (1.6,-0.2);\n  \\end{scope}\n  \\fill[lightgray] (0,0) circle (0.2);\n  \\fill[lightgray] (1.6,0) circle (0.2);\n  \\fill[gray] (0,0) circle (0.02);\n  \\fill[gray] (1.6,0) circle (0.02);\n  \\draw[gray,dashed] (0,0) circle (0.8);\n  \\draw[gray,thick] (0,0) circle (1.0);\n  \\draw[gray,thick] (0,0) circle (0.6);\n  \\draw[gray,thick] (0,0) circle (0.2);\n  \\draw[gray,thick] (1.6,0) circle (0.2);\n  \\draw[decorate,decoration={brace,amplitude=3pt}] \n      (-0.8,0.05) -- (-0.6,0.05); \n  \\draw (-0.7,0) node[above=0.15] {$r$};\n  \\draw[decorate,decoration={brace,amplitude=3pt,mirror}] \n      (-0.8,-0.05) -- (0,-0.05); \n  \\draw (-0.4,0) node[below=0.15] {$R$};\n  \\draw[decorate,decoration={brace,amplitude=3pt}] \n      (0.2,0.05) -- (0.6,0.05); \n  \\draw (0.4,0) node[above=0.15] {$d$};\n\\end{tikzpicture}\n\n \\caption{reconstructed interface of the test problem of two entangled tori and a cut along the hyperplane associated with one torus.}\n \\label{fig:tori_interface}\n\\end{figure}\n\nFor $\\phi\\in[0,\\pi)$, we set\n\n", "itemtype": "equation", "pos": 46491, "prevtext": "\n  This function has a maximum at $t_{\\operatorname{max}}=7/84\\in[0,1]$ and $p(t_{\\operatorname{max}})=5/168>0$.\n  The values of the projections are $A_{t_{\\operatorname{max}}}=1/12$, $B_{t_{\\operatorname{max}}}=-1$, $C_{t_{\\operatorname{max}}}=-9/14$ and $D_{t_{\\operatorname{max}}}=3/14$.\n  These values show, that in the plane of $t_{\\operatorname{max}}$, $A_0$ and $D_1$ are connected.\n  This result corresponds to the basic case 6.1.2.\n\n  For this basic case we query the look-up tables and obtain\n  reconstruction rules for interior, exterior and interface, which\n  describes a set of parts as a list of vertices and a list of\n  elements/faces. These describe primitive geometric objects, suitable\n  for numerical integration.\n  In our implementation the reconstruction of the interior,\n  exterior and interface contain lists of 23, 21 and 15 parts\n  respectively.  The vertices in these lists are encoded via their\n  associated subentity in the reference element.  The lists for the specific case\n  6.1.2 contain for example reference vertex $3$, which is located at\n  $(1,1,0)$.  Another example is the intersection vertex between the\n  reference vertices $1$ (located at $(1,0,0)$) and $3$.  This vertex\n  is found by linear interpolation from the vertex values $4$ and $-1$\n  which gives $(1,4/5,0)$.  A more complex example is the intersection\n  vertex between the maximum vertex and the middle point on the edge\n  of vertices $0$ and $2$ as shown in the right Figure\n  \\ref{fig:vertex_max_and_root}.  First, we compute the maximum vertex\n  by computing the center of the hyperbola in the plane parallel to\n  the front face at $t_{\\operatorname{max}}=7/84$. This vertex is\n  given as approximately $(0.61017, 0.45238, 0.44552)$ (see Figure\n  \\ref{fig:vertex_max_and_root} left). In general $\\Phi$ is locally a\n  trilinear function, thus we use the Aberth-method to\n  get the intersection with interface of the line between this maximum\n  vertex and the center $(0,0.5,0)$ of the edge between vertices $0$\n  and $2$. The intersection vertex is approximately $(0.54437,\n  0.45752, 0.39748)$.  We compute the vertex position for each vertex\n  in the list by the methods defined above.  From these vertices we\n  can construct the volume of the interior and exterior as the union\n  of the respective parts.\n\\end{example}\n\n\\section{Implementation}\n\\label{sec:implementation}\n\nAn implementation of the algorithm is available via\n\\texttt{python-pip}, all tests performed in this paper are available\nfor download from ZENODO~\\cite{download-tpmc}. A python\nlibrary contains a list of all basic cases and their associated\ninformation. From the basic cases the python code computes the full\nlist and can then generate C++ code. This generated code only uses\nstandard C++ components and can easily be used in other projects. The\ncode is in productive use in DUNE for our implementation of the Unfitted Dicontinuous\nGalerkin method~\\cite{engwer2010:duneudg}.\n\nThe C++ library stores all information in a set of different look-up\ntables. The tests are stored as binary trees in breadth-first\norder as an implicit data structure in arrays. The library provides a basic interface to perform the\ntests and export geometric reconstructions as sets\nof sets of vertices. The library is templated, so that it can work\nwith user defined container types and coordinate types. This allows to incorporate it\ninto existing projects, without having to change internal data\nstructures. As the look-up tables are stored as plain C arrays, they can also\nbe incorporated into C or Fortran applications.\n\n\\subsection{Look-up tables}\nThe geometric information of the sub-triangulation parts for each case is stored in three different tables:\n\\begin{enumerate}\n\\item Reconstruction of the interface $\\Gamma$\n\\item Reconstruction of $\\Omega$\n\\item Reconstruction of the complement of $\\Omega$\n\\end{enumerate}\nNote that we store two different tables for $\\Omega$ and its complement.\nNaively a sub-triangulation of the complement\n$\\hat\\Omega\\setminus\\Omega$ could be computed by simply inverting the sign of the level set function.\nHowever, the resulting triangulation of $\\hat\\Omega$ will in general\nno longer form a partition, it might contain holes or overlapping parts.\nTo avoid this, both sub-triangulations have to be constructed with a matching interface.\nThe vertices of the parts are encoded using their position in the reference element.\nThe ordering of the vertices of each interface part is done such that\nthe normal vectors to $\\Gamma$ can be computed using the right hand\nrule, i.e. the direction of the normal vector of an interface part with vertices $x_0,x_1,x_2,\\dots$ is given by the cross product of the tangential axes: $(x_1-x_0)\\times(x_2-x_0)$.\n\nIn addition to the general geometric information we store information about the connectivity pattern w.r.t. each sub-domain.\nFor each sub-triangulation part and each vertex we store an index of the local connected component it belongs to.\nUsing this information, the global connectivity pattern can be computed without geometric coordinate comparisons.\n\nLook-up tables are provided for all primitive geometries up to\ndimension three, i.e. for lines, triangles, quadrilateral, tetrahedra,\nprisms, pyramids and hexahedra. Thus the library can be used with a\nbroad range of discrete level-set representations.\n\n\\subsection{Example}\n\nFollowing the sketch in Figure \\ref{fig:gen-subtriang} we first compute a\nkey based on given vertex values. If we encounter an ambiguous case,\nthis involves a set of different tests, which are retrieved from a\nbinary tree stored in\ntable \\texttt{table\\_cube3d\\_mc33\\_face\\_test\\_order}. In the next\nstep we compute all internal vertices listed in; as these computations might be\nexpensive, it is done in a seperate step to avoid repetitive\ncomputation. The list of necessary\nvertices is stored in \\texttt{table\\_cube3d\\_vertices}. As the last step, we retrieve the\ndesired information, e.g. the reconstruction of the interior domain\n$\\Omega$. In this particular example\n\\texttt{table\\_cube3d\\_cases\\_offsets} yields offsets into a\nreconstruction table, e.g. \\texttt{table\\_cube3dsym\\_codim\\_0\\_interior}\nfor the interior domain.\n\nThe corresponding C++ user code to compute the construction described in\nExample \\ref{example:construction} is listed in Algorithm \\ref{alg:usercode}.\n\\begin{algorithm}[t]\n\\caption{C++ user code to compute an interior domain decomposition, as\n  described in Example \\ref{example:construction}.}\n\\begin{lstlisting}\n// some necessary typedefs\nstatic unsigned int dim = 3;\ntypedef std::array<double,dim> Coordinate;\n// instantiate the algorithm and some additional\n// structures\ntpmc::MarchingCubes<double, dim, Coordinate> mc;\ntpmc::GeometryType geometry = tpmc::cube;\nstd::vector<Coordinate> vertices;\nvertices.reserve(mc.getMaximalVertexCount(geometry));\n// describe the geometry\nstd::vector<double> vertex_values =\n    {-4.0, 4.0, -1.0, -1.0, 2.0, -3.0, 5.0, -1.0};\n// compute the key\nstd::size_t key = mc.getKey(vertex_values.begin(),\n                            vertex_values.end());\n// compute additional vertices and append them\nmc.getVertices(vertex_values.begin(), vertex_values.end(),\n               key,\n               std::back_inserter(vertices)\n              );\n// compute interior reconstruction and store them in\n// decomposition\nstd::vector< std::vector<int> > decomposition;\nmc.getElements(geometry, key, tpmc::InteriorDomain,\n               std::back_inserter(decomposition)\n              );\n\\end{lstlisting}\n\\label{alg:usercode}\n\\end{algorithm}\n\nThe decomposition of the interior domain is described as a cell-to-vertex\nmap in the form $C_i \\rightarrow \\{ v_j \\}$. Each entry describes a\nprimitive geometry.\nThis map is stored in the \\lstinline!decomposition! variable.\nGiven the vertex numbers of a cell the actual coordinates are\nobtained by a lookup in the vector of vertex coordinates, stored in\n\\lstinline!vertices!. This description follows the approach used in\nmost mesh file formats.\n\n\\section{Evaluation}\n\\label{sec:evaluation}\n\nWe present different numerical tests to evaluate the accuracy, the\nrobustness and the efficiency of the proposed algorithm.\n\n\\subsection{Surface Integral over two entangled Tori}\nTo evaluate the convergence rate of the integration method, we use a test level-set function representing two tori.\nWe set $\\hat\\Omega=[0,1]^3\\subset{\\mathbb{R}}^3$ as the outer domain.\nFor a unit vector $n\\in{\\mathbb{R}}^3$ we define its associated hyperplane as $H(n):=\\lbrace x\\in\\hat\\Omega|\\langle x,n\\rangle=0\\rbrace$.\nThe orthogonal projection onto $H(n)$ is then given by $P(n)(x)=x-\\langle x,n\\rangle n$.\nThe level-set function of a torus with radius $R\\in{\\mathbb{R}}$ and tube\nradius $r\\in{\\mathbb{R}}$ in a hyperplane $H(n)$ is given by\n\n", "index": 29, "text": "\\begin{align*}\n \\Phi_{R,r}(n)(x):=\\sqrt{(\\|P(n)(x)\\|-R)^2+\\langle x,n\\rangle^2}-r~.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Phi_{R,r}(n)(x):=\\sqrt{(\\|P(n)(x)\\|-R)^{2}+\\langle x,n\\rangle^{2%&#10;}}-r~{}.\" display=\"inline\"><mrow><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><msqrt><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo>\u2225</mo><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mo>-</mo><mi>R</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo stretchy=\"false\">\u27e8</mo><mi>x</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">\u27e9</mo></mrow><mn>2</mn></msup></mrow></msqrt><mo>-</mo><mpadded width=\"+3.3pt\"><mi>r</mi></mpadded></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nand define the level-set function of two entangled tori (see Figure\n\\ref{fig:tori_interface}), centered at $c$:\n\n", "itemtype": "equation", "pos": 48244, "prevtext": "\n\\begin{figure}\n \\centering\n \\includegraphics[width=0.45\\linewidth]{pics/torigray}\\hspace{0.25cm}\n \\begin{tikzpicture}[scale=2]\n  \\fill[lightgray!50!white] (0,-0.2) rectangle (1.6,0.2);\n  \\draw[gray!50!white,dashed] (0,0) -- (1.6,0);\n  \\draw[gray!50!white,thick] (0,0.2) -- (1.6,0.2);\n  \\draw[gray!50!white,thick] (0,-0.2) -- (1.6,-0.2);\n  \\fill[lightgray] (0,0) circle (1.0);\n  \\fill[white] (0,0) circle (0.6);\n  \\begin{scope}\n    \\clip (0,0) circle (0.6);\n    \\fill[lightgray!50!white] (0,-0.2) rectangle (1.6,0.2);\n    \\draw[gray!50!white,dashed] (0,0) -- (1.6,0);\n    \\draw[gray!50!white,thick] (0,0.2) -- (1.6,0.2);\n    \\draw[gray!50!white,thick] (0,-0.2) -- (1.6,-0.2);\n  \\end{scope}\n  \\fill[lightgray] (0,0) circle (0.2);\n  \\fill[lightgray] (1.6,0) circle (0.2);\n  \\fill[gray] (0,0) circle (0.02);\n  \\fill[gray] (1.6,0) circle (0.02);\n  \\draw[gray,dashed] (0,0) circle (0.8);\n  \\draw[gray,thick] (0,0) circle (1.0);\n  \\draw[gray,thick] (0,0) circle (0.6);\n  \\draw[gray,thick] (0,0) circle (0.2);\n  \\draw[gray,thick] (1.6,0) circle (0.2);\n  \\draw[decorate,decoration={brace,amplitude=3pt}] \n      (-0.8,0.05) -- (-0.6,0.05); \n  \\draw (-0.7,0) node[above=0.15] {$r$};\n  \\draw[decorate,decoration={brace,amplitude=3pt,mirror}] \n      (-0.8,-0.05) -- (0,-0.05); \n  \\draw (-0.4,0) node[below=0.15] {$R$};\n  \\draw[decorate,decoration={brace,amplitude=3pt}] \n      (0.2,0.05) -- (0.6,0.05); \n  \\draw (0.4,0) node[above=0.15] {$d$};\n\\end{tikzpicture}\n\n \\caption{reconstructed interface of the test problem of two entangled tori and a cut along the hyperplane associated with one torus.}\n \\label{fig:tori_interface}\n\\end{figure}\n\nFor $\\phi\\in[0,\\pi)$, we set\n\n", "index": 31, "text": "\\begin{align*}\n n_1(\\phi):=\\begin{pmatrix}\n       \\cos(\\phi)\\\\\n       \\sin(\\phi)\\\\\n       0\n      \\end{pmatrix},\\quad\n n_2(\\phi):=\\begin{pmatrix}\n       -\\sin(\\phi)\\\\\n       \\cos(\\phi)\\\\\n       0\n      \\end{pmatrix},\\quad\n n_3:=\\begin{pmatrix}\n       0\\\\\n       0\\\\\n       1\n      \\end{pmatrix},\\quad\n c:=\\begin{pmatrix}\n     0.5\\\\\n     0.5\\\\\n     0.5\n    \\end{pmatrix}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle n_{1}(\\phi):=\\begin{pmatrix}\\cos(\\phi)\\\\&#10;\\sin(\\phi)\\\\&#10;0\\end{pmatrix},\\quad n_{2}(\\phi):=\\begin{pmatrix}-\\sin(\\phi)\\\\&#10;\\cos(\\phi)\\\\&#10;0\\end{pmatrix},\\quad n_{3}:=\\begin{pmatrix}0\\\\&#10;0\\\\&#10;1\\end{pmatrix},\\quad c:=\\begin{pmatrix}0.5\\\\&#10;0.5\\\\&#10;0.5\\end{pmatrix}\" display=\"inline\"><mrow><mrow><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mo>(</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mo>(</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><msub><mi>n</mi><mn>3</mn></msub><mo>:=</mo><mrow><mo>(</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi>c</mi><mo>:=</mo><mrow><mo>(</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0.5</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nThe surface area of the level-set $\\Phi_{R,r,\\phi}$ can be computed\nanalytically as\n\n", "itemtype": "equation", "pos": 48739, "prevtext": "\nand define the level-set function of two entangled tori (see Figure\n\\ref{fig:tori_interface}), centered at $c$:\n\n", "index": 33, "text": "\\begin{align*}\n \\Phi_{R,r,\\phi}(x):=\\min\\Big(&\\Phi_{R,r}(n_1(\\phi))\\Big(x-c+\\frac{R}{2}\\cdot n_3\\Big),\\\\\n      &\\Phi_{R,r}(n_2(\\phi))\\Big(x-c-\\frac{R}{2}\\cdot n_3\\Big)\\Big)~.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Phi_{R,r,\\phi}(x):=\\min\\Big{(}\" display=\"inline\"><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>:=</mo><mi>min</mi><mo maxsize=\"160%\" minsize=\"160%\">(</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Phi_{R,r}(n_{1}(\\phi))\\Big{(}x-c+\\frac{R}{2}\\cdot n_{3}\\Big{)},\" display=\"inline\"><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><mi>x</mi><mo>-</mo><mi>c</mi></mrow><mo>+</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mi>R</mi><mn>2</mn></mfrac></mstyle><mo>\u22c5</mo><msub><mi>n</mi><mn>3</mn></msub></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Phi_{R,r}(n_{2}(\\phi))\\Big{(}x-c-\\frac{R}{2}\\cdot n_{3}\\Big{)}%&#10;\\Big{)}~{}.\" display=\"inline\"><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mi>x</mi><mo>-</mo><mi>c</mi><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mi>R</mi><mn>2</mn></mfrac></mstyle><mo>\u22c5</mo><msub><mi>n</mi><mn>3</mn></msub><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mo maxsize=\"160%\" minsize=\"160%\" rspace=\"5.8pt\">)</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\nThe surface of the reconstructed interface using a structured grid with diameter $h$ is denoted by $S_h(\\Phi_{R,r,\\phi})$.\nThe relative error of a reconstructed surface is defined as\n\n", "itemtype": "equation", "pos": 49011, "prevtext": "\nThe surface area of the level-set $\\Phi_{R,r,\\phi}$ can be computed\nanalytically as\n\n", "index": 35, "text": "\\begin{align*}\n S(\\Phi_{R,r,\\phi}):=\\int_{\\Gamma_{R,r,\\phi}}1ds=8\\pi^2Rr\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle S(\\Phi_{R,r,\\phi}):=\\int_{\\Gamma_{R,r,\\phi}}1ds=8\\pi^{2}Rr\" display=\"inline\"><mrow><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mstyle displaystyle=\"true\"><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi mathvariant=\"normal\">\u0393</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub></msub></mstyle><mrow><mn>1</mn><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>s</mi></mrow></mrow></mrow><mo>=</mo><mrow><mn>8</mn><mo>\u2062</mo><msup><mi>\u03c0</mi><mn>2</mn></msup><mo>\u2062</mo><mi>R</mi><mo>\u2062</mo><mi>r</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03597.tex", "nexttext": "\n\nWe define $d = R - 2r$ as the distance between the two tori. For $d =\n0$ the two tori touch and the topology changes, the aspect ratio $R/r$ in this case is\n$2$.\n\nWe set $R=0.25$ with a distance $d=0.1$,\ni.e. we choose the minor radius $r=\\frac{R-d}{2}=0.075$ and set $\\phi=0$.\nIn order to investigate the robustness of the method to grid perturbation, we shift the center of the tori\nrandomly by a maximum $h$. For each grid size, we generate $30$ random datasets.\nThe results of the relative surface error for different grid sizes are\nlisted in Table \\ref{tab:plot_accuracy}.\n\n\\begin{table}\n  \\centering\n    \\begin{tabular}{@{\\quad}r@{\\qquad\\quad}l@{\\quad$-$\\quad}l@{\\quad\\qquad}l@{~~$\\pm$~~}l@{\\quad}}\n      \\hline\\hline\n      \\rule{0pt}{1.9ex}grid size & $\\min(e_S)$ & $\\max(e_S)$ & $\\overline{e_S}$ & $\\sigma_1$ \\\\\\hline\n      \n      \n      \n      \n      \n      16  & 0.0451   & 0.0509   & 0.046   & $3.2\\%$ \\\\ \n      32  & 0.0108   & 0.0114   & 0.0110   & $1.8\\%$ \\\\ \n      64  & 0.00266  & 0.00275  & 0.00270  & $1.1\\%$ \\\\ \n      128 & 0.0006672   & 0.00067563 & 0.0006738 & $0.3\\%$ \\\\ \n      256 & 0.0001674 & 0.0001686 & 0.0001681 & $0.2\\%$ \\\\ \n      \\hline\\hline\n    \\end{tabular}\n  \\caption{Relative error $e_S$ of the surface of the two tori test problem computed with {\\textsf{TPMC}}{} as compared to the analytic solution. The level-set is discretized on a three dimensional structured grid with rectangular element. For each grid size we generate $30$ randomly shifted datasets}\n  \\label{tab:plot_accuracy}\n\\end{table}\n\nWe can observe a second order convergence rate, as it is expected for a polygonal approximation.\nIn addition, the computation is robust with respect to grid perturbation, since the variance tends to zero as $h$ is reduced.\n\n\\subsection{Robustness to Rotation}\nFor $d \\rightarrow 0$ the topology changes, as the two tori ``merge''. In the discrete\nreconstruction this happens already for $d > 0$.\nIn this test we compute, for different\ndirections $\\phi$ of the two tori, the critical distance $d_c$ at which the\ntopology changes, i.e. the number of\ndiscrete connected components switches from three to two.\nIn this test the grid size is fixed $h=\\frac1{64}$ and $R=0.25$, as in\nthe first test.\nFor values of $\\phi \\in [0,\\pi)$ we modify the\nminor radius $r = \\frac{R-d}{2}$ to compute the critical\ndistance $d_c = x\\cdot h$, using a\nbisection method.\nFigure \\ref{fig:plot_topology_change} shows the critical distance with ({\\textsf{TPMC}}) and\nwithout ({\\textsf{MC}}) ambiguity-resolution (smaller is better).\n\n\n\n\n\n\n\n\n\n\\begin{figure}[H]\n  \\centering\n  \\includegraphics[width=0.75\\textwidth]{plots/plot_topology_change/topologychange}\n  \\caption{Two entangled tori are rotated in a three dimensional structured grid with rectangular elements. The distance between the tori is reduced and the distance at which the topology changes is noted in this figure as a multiple of $h$; smaller is better. The solid line represents the data obtained by {\\textsf{MC}}{} and the dashed one the data obtained by {\\textsf{TPMC}}{}. {\\textsf{MC}}{} is not robust with respect to the orientation of the tori.}\n  \\label{fig:plot_topology_change}\n\\end{figure}\n\nFor the method with ambiguity-resolution, the topology change occurs\nrelatively stable at a distance below $h$, yielding a sub-voxel resolution.\nWithout the ambiguity-resolution, meaning an anisotropic choice in an ambiguous case, the distance depends on the angle $\\phi$ and is overall above $h$.\n\n\\subsection{Performance}\n\nIn order to evaluate the performance overhead of {\\textsf{TPMC}}{} as compared to {\\textsf{MC}}{}, we generate pseudo-random values in $[-1.0,1.0]$ for each vertex of a three dimensional structured grid.\nWe construct $30$ data sets for each grid size and compute the unique key for each grid cell using {\\textsf{TPMC}}{} and {\\textsf{MC}}{}.\nFor each data set, we average the time consumption over $30$ iterations.\nWe measure both the isolated time used for ambiguity resolution, and the total time consumption including the grid iteration.\n\nThis is a worst case scenario, as $\\Phi$ is usually a smooth function,\nso this test will encounter significantly more ambiguous case than\nan average application.\n\nThe resulting ratios between time for {\\textsf{TPMC}}{} and {\\textsf{MC}}{} can be seen in Table \\ref{tab:plot_time_comparison}.\nThe table also shows the number of face and center tests in relation to the number of key computations.\n\\begin{table}\n  \\centering\n    \\begin{tabular}{@{\\quad}rr@{ $\\pm$ }lr@{ $\\pm$ }l@{\\qquad}cc@{\\quad}}\n      \\hline\\hline\n      \\rule{0pt}{1.9ex}grid size\n          & \\multicolumn{2}{c}{\\quad ambiguity resolution\\qquad}\n          & \\multicolumn{2}{c}{total}\n          & \\multicolumn{2}{c}{test fraction}\\\\\n          & \\quad \\phantom{ambi}$\\overline{T}_\\text{rel}$ & $\\sigma_1$\n          & $\\overline{T}_\\text{rel}$ & $\\sigma_1$\n          & face & center\\\\\\hline\n        \n        \n        \n        \n        \n        \n        16  & 2.27 & 2.07$\\%$ & 1.23 & 2.57$\\%$ & 76.0$\\%$ & 22.0$\\%$\\\\\n        32  & 2.20 & 1.24$\\%$ & 1.18 & 0.48$\\%$ & 74.8$\\%$ & 21.8$\\%$\\\\\n        64  & 2.17 & 0.72$\\%$ & 1.17 & 0.25$\\%$ & 74.9$\\%$ & 21.8$\\%$\\\\\n        128 & 2.18 & 0.64$\\%$ & 1.17 & 0.34$\\%$ & 74.8$\\%$ & 21.8$\\%$\\\\\n        256 & 2.19 & 1.86$\\%$ & 1.18 & 0.50$\\%$ & 74.8$\\%$ & 21.8$\\%$\\\\\\hline\\hline\n    \\end{tabular}\n  \\caption{Worst case test: Relative time consumption ${T_{\\operatorname{rel}}}=T_{\\text{{\\textsf{TPMC}}{}}}/T_{\\text{{\\textsf{MC}}{}}}$ for {\\textsf{TPMC}}{} as compared to\n    {\\textsf{MC}}{} on a three dimensional structured grid with $N$ rectangular\n    cells in each dimension. The timings are either the time used for\n    ambiguity resolution or the total time, including grid\n    iteration. We also show the fraction of tests involving face or center\n    tests. For each grid size we compute 30 random datasets.}\n  \\label{tab:plot_time_comparison}\n\\end{table}\nWe observe an increased time consumption of {\\textsf{TPMC}}{} by a factor of approximately $2.2$ for the ambiguity resolution, which can be expected due to the need for additional tests.\nFor approximately three out of four key computations we need a face test and for two out of five we need a center test.\nWhen taking also the iteration over the simple structured grid into\naccount, the factor already reduces to approximately $1.18$.\nWe note that for a computationally more expensive grid iteration, for example using an unstructured grid, the factor will further decrease.\nAs mentioned before, we want to point out that for smoother data, the need for\nadditional tests is in general significantly smaller than for random\ndata and therefore the performance overhead of the proposed method\nwill significantly smaller.\n\n\\section{Conclusion}\n\\label{sec:conclusion}\n\nWe proposed a method for geometric integration over implicitly described domains.\nThe method shows second order accuracy and a topologically correct representation of the geometry.\nThe method is robust with respect to grid perturbation while imposing only a small performance overhead when compared to a non-correct algorithm.\nFor an extension of the method to multiple level sets, one might consider a recursive application of the presented method.\nFor such a purpose, the interpolation of the vertices has to be modified to take higher order edges into account.\n\n\\bibliographystyle{plainurl}\n\\bibliography{literature}\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 49280, "prevtext": "\nThe surface of the reconstructed interface using a structured grid with diameter $h$ is denoted by $S_h(\\Phi_{R,r,\\phi})$.\nThe relative error of a reconstructed surface is defined as\n\n", "index": 37, "text": "\\begin{align*}\n e_S:=\\frac{|S(\\Phi_{R,r,\\phi})-S_h(\\Phi_{R,r,\\phi})|}{S(\\Phi_{R,r,\\phi})}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle e_{S}:=\\frac{|S(\\Phi_{R,r,\\phi})-S_{h}(\\Phi_{R,r,\\phi})|}{S(\\Phi%&#10;_{R,r,\\phi})}\" display=\"inline\"><mrow><msub><mi>e</mi><mi>S</mi></msub><mo>:=</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msub><mi>S</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mi>R</mi><mo>,</mo><mi>r</mi><mo>,</mo><mi>\u03d5</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mstyle></mrow></math>", "type": "latex"}]