[{"file": "1601.04203.tex", "nexttext": "\nThe nice numbers between 1000 and 3000 are:\n\n", "itemtype": "equation", "pos": 12404, "prevtext": "\n\n\\conferenceinfo{}{}\n\\CopyrightYear{2015}\n\\crdata{000-0-0000-0000-0/00/00}\n\n\\markboth{C. Musco, M. Sviridenko, J. Thaler}{Determining Tournament Payout Structures for Daily Fantasy Sports}\n\n\n\\title{Determining Tournament Payout Structures for Daily Fantasy Sports}\n\\author{\nCHRISTOPHER MUSCO\n\\affil{Yahoo Labs, New York.}\nMAXIM SVIRIDENKO\n\\affil{Yahoo Labs, New York.}\nJUSTIN THALER\n\\affil{Yahoo Labs, New York.}\n}\n\n\\begin{abstract}\nWith an exploding global market and the recent introduction of online cash prize tournaments, fantasy sports contests are quickly becoming a central part of the social gaming and sports industries. For sports fans and online media companies, fantasy sports contests are an opportunity for large financial gains. However, they present a host of technical challenges that arise from the complexities involved in running a web-scale, prize driven fantasy sports platform.\n\nWe initiate the study of these challenges by examining one concrete problem in particular: how to algorithmically generate contest payout structures that are 1) economically motivating and appealing to contestants and 2) reasonably structured and succinctly representable. We formalize this problem and present a general two-staged approach for producing satisfying payout structures given constraints on contest size, entry fee, prize bucketing, etc.\n\nWe then propose and evaluate several potential algorithms for solving the payout problem efficiently, including methods based on dynamic programming, integer programming, and heuristic techniques. Experimental results show that a carefully designed heuristic scales very well, even to contests with over 100,000 prize winners. \n\nOur approach extends beyond fantasy sports -- it is suitable for generating engaging payout structures for any contest with a large number of entrants and a large number of prize winners, including other massive online games, poker tournaments, and real-life sports tournaments.\n\\end{abstract}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{bottomstuff}\nAuthor email addresses: \n\\texttt{cpmusco@mit.edu},\n\\texttt{sviri@yahoo-inc.com},\n\\texttt{jthaler@fas.harvard.edu}.\n\\end{bottomstuff}\n\n\n\\maketitle\n\n\\section{Introduction}\nIn many competitions, a large number of entrants compete against each other and are then {ordered} based on performance. Prize money is distributed to the entrants based on their rank in the order, with higher ranks receiving more money than lower ranks. \nThe question that we are interested in is: how should prize money be distributed among the entrants?  That is, how much money should \n go to the winner of the contest? How much to 2nd place? How much to 1,128th place? \n\n\\subsection{Motivation} \nWe became interested in this problem in the context of daily \\emph{fantasy sports}\\footnote{In fantasy sports, participants build a team of real-world athletes, and the team earns points based on the actual real-world performance of the athletes. For example, if a participant in a fantasy basketball league has Lebron James on his or her team, then they will earn points based on the statistics Lebron James produces in actual basketball games.\nTraditional fantasy sports competitions run for an entire professional sports season; daily sports competitions typically run for just a single day or week.\nThe Fantasy Sports Trade Association Estimates that more than 56 million people are actively playing traditional fantasy sports in 2015 \\cite{fstaDemo}.}, a growing sector of online fantasy sports competitions  where users pay a fee to enter and can win real prize money. \n\nIn 2006, the United States passed a law called the Unlawful Internet Gambling Enforcement Act (UIGEA), which was designed to regulate internet gambling. While it toppled the U.S. online poker industry, the UIGEA classified certain fantasy sports as \\emph{games of skill}, legalizing the wagering of money on such competitions. The daily fantasy sports industry emerged shortly thereafter. \n\nAs of 2015, there are two dominant companies in the industry: FanDuel and DraftKings.\n\nThese companies reported a combined \\$87 million in revenue in 2014, and as of August 2015 are running contests with hundreds of thousands of entrants and up to \\$10 million in prizes. Some analysts project that annual industry wide revenue will exceed \\$2 billion within the next 5 years \\cite{eilersResearch}. \n\nYahoo launched a daily fantasy sports product in July 2015. Work on the contest management portion of this product has led to many interesting economic and algorithmic challenges involving player pricing, contest revenue maximization, fill-rate prediction and of course, payout structure generation. \n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{The Importance of Payout Structure.}}}\nPayout structure has been identified as an important factor in determining how appealing a competition is to users. \nPayouts are regularly discussed on forums and websites devoted to the daily fantasy sports industry, and these structures have a substantial effect on the strategies that contest entrants pursue (see, e.g., \\cite{roto1,roto2,roto3,roto4,roto5}). \n\nFurthermore, considerable attention has also been devoted to payout structures in related contexts. For example, many popular articles discuss the payout structures used in World Series of Poker (WSOP) events (see Section \\ref{sec:poker} for details), and at least one prominent poker tournament director has said that ``payout structure could determine whether or not a player comes back to the game.'' \\cite{poker2}. \n\n\n\n\n\n\\subsection{Payouts in Daily Fantasy Sports}\n\nFor some types of fantasy sports contests, the appropriate payout structure is obvious. For example, in a ``Double Up'' contest, roughly half of the entrants win back twice the entry fee, while the other half wins nothing. \nHowever, some of the most popular contests are analogous to real-world golf and poker tournaments, in which the winner should win a very large amount of money, second place should win slightly less, and so on. We refer to such competitions as \\emph{tournaments}.  \n\nOne could manually determine a payout structure that seems reasonable for every tournament offered, but this is unprincipled and laborious, especially considering the huge variety of tournaments offered on Yahoo's daily fantasy platform (currently $>100$ daily, with more variety expected as the product expands). Furthermore, given typical constraints, manually constructing even a single payout structure is quite difficult, even ``virtually impossible'' in the words of the current WSOP Tournament Director \\cite{poker2}. \n\nThe challenge is more present than ever in the age of online contests, where the number of contestants and prizes awarded can be orders of magnitude larger than in traditional gaming and sporting tournaments.\nAccordingly, our goal is to develop efficient algorithms for automatically determining payout structures. \n\n\\subsection{Summary of Contributions}\nOur contributions are two-fold. First, we (partially) formalize the properties that a payout structure for a daily fantasy tournament should satisfy.\nSecond, we present several algorithms for calculating such payout structures based on a general two stage framework. In particular, we present an efficient heuristic that scales to extremely large tournaments and is currently in production at Yahoo.\n\nOur methods are not specific to fantasy sports and can be used for any tournament, particularly those in which the number of distinct payouts is large, and the competition results in a\ntotal order on the entrants (aside from the possibility of ties, which are discussed in Section \\ref{sec:discuss}).\nIn addition to most golf, fishing, and online or offline poker competitions, massive online gaming  tournaments (where many large prize pools are crowd-funded) are organized in this manner \\cite{crowdfunding}.\n\n\\section{Payout Structure Requirements}\n\n\\label{sec:requirements}\n Before describing our algorithm, it is helpful to be more precise about the properties that we would like our payout structure to satisfy.\nLet $P_i$ denote the money paid out to the $i$th place finisher. \nA couple of requirements are self-evident.\n\\begin{itemize}\n\\item \\textsf{\\small{\\textbf{Prize Pool Requirement:}}} The total amount of money paid to the users must be equal to the Total Prize Pool. This is a hard requirement, for legal reasons: if Yahoo says it will pay out \\$1 million, Yahoo must pay out exactly \\$1 million. \n\\item \\textsf{\\small{\\textbf{Monotonicity Requirement:}}} The prizes should satisfy \\emph{monotonicity}. First place should win at least as much as second place, who should win at least as much as third place, and so on.\n\\end{itemize}\n\n\\noindent There are less obvious requirements as well.\n\\begin{itemize}\n\\item \\textsf{\\small{\\textbf{Bucketing Requirement}}}: To concisely publish payout structures,  prizes should fall into a manageable set of ``buckets'' such that all users within one bucket get the same prize. Yahoo cannot pay out thousands of distinct prize amounts.\n\n\\item \\textsf{\\small{\\textbf{Nice Number Requirement}}}: Prizes should be paid in amounts that are aesthetically pleasing. Paying a prize of $\\$1,000$ is preferable to $\\$1,012.11$, or even to $\\$1,012$.  \n\n\\item \\textsf{\\small{\\textbf{Minimum Payout Requirement}}}: It is typically unsatisfying to win back an amount smaller than the entry fee paid to enter the contest. So any place awarded a non-zero amount should receive at least some minimum amount $E$. Typically, we set $E$ to be 1.5 times the entry fee.\n\\end{itemize}\n\\noindent Finally, the following characteristic is desirable:\n\\begin{itemize}\n\\item \\textsf{\\small{\\textbf{Monotonic  Bucket Sizes}}}: Buckets should increase in size when we move from higher ranks to lower ranks.\nFor example, it is undesirable for 348 users to receive a payout of \\$20, 2 users to receive a payout of \\$15, and 642 users to receive a payout of \\$10. \nIt would be preferable in this case for 349 users to receive a payout of \\$20, and 643 users to receive a payout of \\$10. \n\\end{itemize}\n\n\n\nOf course, it is not enough to simply find a payout structure satisfying all of the requirements above. For example,\na winner-take-all payout structure satisfies all requirements, but is not appealing to entrants. \nThus, our algorithms proceed in two stages. We first determine an ``initial'', or ideal, payout structure that\ncaptures some intuitive notions of attractiveness and fairness. We then modify the initial payout structure \\emph{as little as possible} to satisfy the requirements. \n\n\\subsection{Discussion} \n\\label{sec:discuss} Three final remarks regarding requirements are in order.\n\n\\medskip\n\\noindent \\textsf{\\small{\\textbf{Small Contests.}}} In tournaments with few entrants, it is acceptable to pay each winner a distinct prize. In this case, the bucketing requirement is superfluous, and determining payouts becomes much easier. \n\n\\medskip\n\\noindent \\textsf{\\small{\\textbf{Handling Ties.}}} In daily fantasy sports and other domains such as poker and golf, entrants who tie for a rank typically split all prizes due to those entrants equally. Accordingly, even if the initial payout structure satisfies the Nice Number Requirement, the actual payouts may not. However,\nthis is inconsequential: the purpose of the Nice Number Requirement is to ensure that aesthetically pleasing payouts are published, not to ensure that aesthetically pleasing payouts are received. \n\n\\medskip \\noindent \\textsf{\\small{\\textbf{What are ``Nice Numbers''?}}}\nThere are many ways to define nice numbers, i.e., the numbers that we deem aesthetically pleasing. \nOur algorithms will work with any such definition, as long as it comes with an algorithm that, given a number $a \\in \\mathbb{R}$,\ncan efficiently return the largest nice number less than or equal to $a$. \nHere we give one possible definition.\n\n\\begin{defi}[Nice Number]\n\\label{def:nice_numbers}\nA nonnegative integer $X\\in Z_+$ is a ``nice number'' if $X=A\\cdot 10^K$ where $K, A \\in Z_+$, and $A\\le 1000$ satisfies all of the following properties:\n\\begin{enumerate}\n\\item  if $A\\ge 10$ then $A$ is a multiple of $5$;\n\\item  if $A\\ge 100$ then $A$ is a multiple of $25$;\n\\item if $A\\ge 250$ then $A$ is a multiple of $50$.\n\\end{enumerate}\n\\end{defi}\n\\noindent Under Definition \\ref{def:nice_numbers}, the nice numbers less than or equal to 1000 are:\n\n", "index": 1, "text": "\\begin{align*}\n\\{1, 2, 3, \\dots, 10, 15, 20, \\dots, 95, 100, 125, 150,\n\\dots, 225, 250, 300, 350, \\dots, 950, 1000\\}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{1,2,3,\\dots,10,15,20,\\dots,95,100,125,150,\\dots,225,250,300,350%&#10;,\\dots,950,1000\\}.\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>10</mn><mo>,</mo><mn>15</mn><mo>,</mo><mn>20</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>95</mn><mo>,</mo><mn>100</mn><mo>,</mo><mn>125</mn><mo>,</mo><mn>150</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>225</mn><mo>,</mo><mn>250</mn><mo>,</mo><mn>300</mn><mo>,</mo><mn>350</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>950</mn><mo>,</mo><mn>1000</mn><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": "\n\n\\begin{figure*}[h]\n\\centering\n\\includegraphics[width=\\textwidth]{bassmaster_open_2015.eps}\n\\caption{Bassmaster Open payouts are not quite ``nice numbers'' \\protect\\cite{bassmasterInfo}.}\n\\label{fig:bmaster_failure}\n\\end{figure*}\n\n\\subsection{Prior Work} \n\\label{sec:prior_work}\nWhile our exact requirements have not been previously formalized, observation of published payout structures for a variety of contests suggests that similar guiding principals are standard. Moreover, manually determining payouts to match these requirements is, anecdotally, not an easy task. \n\nFor example, while the nice number requirement is often ignored, this may not be from lack of trying: prior attempts to satisfy the constraint often only partially succeed. For example, consider the 2015 Bassmaster Open fishing tournament, which paid out a top prize of \\$51,400, instead of the rounder \\$51,000 or \\$50,000 (see Figure \\ref{fig:bmaster_failure}). The Bassmaster payout structure also violates our constraint on bucket size monotonicity. It is not hard to find similar examples of ``partially optimized'' payout structures for poker \\cite{pokerPayoutsFailure,poker2}, golf  \\cite{usopenprizes}, and other tournament types.\n\n\\medskip \\noindent\n\\textsf{\\small{\\textbf{Payout Structures for Poker.}}} \\label{sec:poker}\nSeveral popular articles describe the efforts of the World Series Of Poker (WSOP),  in conjunction with Adam Schwartz of Washington and Lee University,\nto automate the determination of a payout structure for their annual ``Main Event'' \\cite{poker1,poker2}. After noting the difficulty of manually choosing payouts,\nWSOP asked Schwartz to provide them with an algorithm. His solution, which was based on Newton's Method, was combined with manual intervention to determine the final payout structure for 2005. \nUntil at least 2007, WSOP still utilized considerable manual intervention when determining payouts.\n\nIn 2009, WSOP and Schwartz updated the algorithm, and reduced or removed the need for manual intervention. While we are unaware of a formal description of their solution, it appears to be very different from ours; Schwartz has stated that their solution attempts to obtain payout structures with a ``constant second derivative'' \\cite{poker1,poker2} (our solutions do not satisfy this property). Additionally, their work departs qualitatively from ours in that they do not satisfy nice number requirements or explicitly consider bucket size requirements.\n\n\\medskip \\noindent\n\\textsf{\\small{\\textbf{Piecewise Function Approximation.}}}\nAs mentioned, our payout structure algorithms proceed in two stages. An initial payout curve is first generated with a separate payout for every winning position. The curve is then modified to fit our constraints, which in particular requires bucketing payouts so that a limited number of distinct prizes are paid. We seek the bucketed curve closest to our initial payout curve.\n\nThis curve modification task is similar to the well studied problem of optimal approximation of a function by a histogram (i.e., a piecewise constant function). This problem has received considerable attention, especially for applications to database query optimization \\cite{Ioannidis:2003}. While a number of algorithmic results give exact and approximate solutions \\cite{Jagadish:1998,Guha:2006}, even for the same distance metric employed in Section \\ref{sub:rounding}, unfortunately no known solutions easily adapt to handle our additional constraints beyond bucketing.\n\nWe do note that our dynamic programming solution given in Section \\ref{subsec:dyno} can be viewed as a many dimensional extension of the classic algorithm from \\cite{Jagadish:1998}, with additional dimensions necessary to track our additional constraints.\n\n\\section{Our Solution} \nLet $B$ denote the total prize pool, $N$ denote the number of entrants who should win a non-zero amount, and  $P_i$ denote the prize that we decide to award to place $i$. In general, $B$, $P_1$ and $N$ are user-defined parameters. \n$P_1$ can vary widely in fantasy sports contests, anywhere from $.05\\cdot B$ to nearly $.5\\cdot B$, but $.15 \\cdot B$ is a standard choice (i.e., first place wins 15\\% of the prize pool).  Typically, $N$ is roughly 25\\% of the total number of contest entrants, although it varies as well.\n\nAs described in Section \\ref{sec:requirements}, our solution proceeds in two stages. We first determine an initial payout structure that does not necessarily satisfy the bucketing or nice number requirements. The initial payout for place $i$ will be denoted $\\pi_i$. The second stage modifies the initial payout structure to satisfy these requirements. In particular, we search for the feasible payout structure with the least difference from our initial payouts, measured in terms of sum-of-squared error.\n\n\\subsection{Determining the Initial Payout Structure}\\label{sec:initial_structure} First, to satisfy the Minimum Payout Requirement, we start by giving each winning place $E$ dollars. This leaves $B-N \\cdot E$ additional dollars to disperse among the $N$ winners. How should we do this?\n\nWe have decided that it is best to disperse the remaining budget according to a \\emph{power law}. That is, the amount of the budget that is given to place $i$ should be proportional to $1/i^{\\alpha}$ for some fixed constant $\\alpha > 0$. It is easy to see that for \\emph{any} positive value of $\\alpha$, the resulting payouts will satisfy the Monotonicity Requirement, but there is a unique value of $\\alpha$ ensuring that the payouts sum to exactly the Total Prize Pool $B$. \nSpecifically, we choose the exponent $\\alpha$ to satisfy \n", "itemtype": "equation", "pos": 12579, "prevtext": "\nThe nice numbers between 1000 and 3000 are:\n\n", "index": 3, "text": "\\begin{align*}\n\\{1000, 1250, 1500, 1750, 2000, 2250, 2500, 3000\\}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{1000,1250,1500,1750,2000,2250,2500,3000\\}.\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mn>1000</mn><mo>,</mo><mn>1250</mn><mo>,</mo><mn>1500</mn><mo>,</mo><mn>1750</mn><mo>,</mo><mn>2000</mn><mo>,</mo><mn>2250</mn><mo>,</mo><mn>2500</mn><mo>,</mo><mn>3000</mn><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": " We can efficiently solve this equation for $\\alpha$ to additive error less than $.01$ via binary search. We then define the ideal payout to place $i$ \nto be $\\pi_i := E +  \\frac{P_1-E}{i^\\alpha}$. This definition ensures both that first place gets paid exactly $\\$P_1$, and that the sum of all of the tentative payouts is exactly $B$.\n\n\\begin{figure}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{power_law.eps} \n\\caption{Ideal Payouts Using Power Law Method.}\n\\label{fig1}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{exp_law.eps}\n\\caption{Ideal Payouts Using Exponential Distribution.}\n\\label{fig2}\n\\end{subfigure}\n\\caption{Possible initial payout structure when $N=\\text{10,000}$, $P_1=\\text{150,000}$, and $B=\\text{1 million}$.}\n\\label{examplefig}\n\\end{figure}\n\nWhy use a power law? The most pragmatic answer is that, empirically, a power law ensures that as we move from 1st place to 2nd to 3rd and so on, payouts drop off at a nice pace: fast enough that the very top finishers are richly rewarded relative to the rest of the pack, but slow enough that users in, say, the 10th percentile still win a lot of money. An initial curve based on a power law also encourages increased prize differences between higher places, a property cited as a desirable by WSOP organizers \\cite{poker2}.\n\nThere are other sociological justifications -- for example, wealth in real societies roughly follows a power law distribution, and humans should be intuitively comfortable with payouts that mirror the real world \\cite{pareto1896cours,chatterjee2005econophysics}. \n\nFor illustration, consider a tournament where 40,000 entrants vie for \\$1 million in prizes. \nIf first place receives 15\\% of the prize pool and 25\\% of all entrants should win a non-zero amount, then $P_1 =\\$150,000$ and $N=10,000$. \nFigure \\ref{fig1} reveals the initial set of payouts determined by our power law method. Note that the y axis on this plot uses a logarithmic scale, so although the dots for first and second place appear very close, in fact first place is winning slightly more than twice as much as second place. \n\nFigure \\ref{fig2} reveals what the initial payouts would be if we used an exponential distribution instead, with prizes proportional to $1/\\alpha^i$ rather than $1/i^\\alpha$. Such distributions are a popular choice for smaller tournaments, but the plot reveals that they yield much more top-heavy payouts than a power law approach. In fact, only the top few dozen places receive more than the minimum prize in our example.\n\n\n\nAs further justification, we check in Figure \\ref{fig:empirical_payouts} that a power law roughly models payouts for existing fantasy sports contests and other large tournaments. Since $\\log(i^\\alpha) = \\alpha\\log(i)$, plotting payouts with both axes on a logarithmic scale will reveal a roughly linear trend when the payout distribution approximates a power law. Thus, the plots demonstrate that all of these existing fantasy sports contests have payout structures that are consistent with a power law. On the other hand, for an exponential distribution, $\\log(1/\\alpha^i) = i\\log(1/\\alpha)$, which is not linear in $\\log(i)$. \n\n\\begin{figure}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{empirical_power_law_fantasy.eps} \n\\caption{Large Fantasy Sports Tournaments.}\n\\label{empirical_payouts:sub1}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{empirical_power_law_nonfantasy.eps}\n\\caption{Other Well Known Tournaments.}\n\\label{empirical_payouts:sub2}\n\\end{subfigure}\n\\caption{Log plots of existing tournament payout structures indicate linear structure.}\n\\label{fig:empirical_payouts}\n\\end{figure}\n\nObtaining quantitative goodness-of-fit metrics for power law distributions can be a difficult task \\cite{clauset2009power} especially given heavy ``value binning'' \\cite{virkar2014power}, which is of course present in tournament payout structures. Nevertheless, standard fitting and testing routines \\cite{powerLawCode} yield an average $p$-value of $.237$ when a power law is fit to the payouts from Figure \\ref{fig:empirical_payouts}. This value is in line with calculated $p$-values for well known empirical power law distributions that have binned values \\cite{virkar2014power}.\n\nOverall, the power law's simplicity, empirical effectiveness, and historical justification make it an ideal candidate for generating initial prize values.\n\n\\subsection{Satisfying the Remaining Requirements}\n\\label{sub:rounding}\n\\begin{figure*}[h]\n\\begin{mymathbox}\n\\begin{problem}[Payout Structure Optimization]\n\\label{main_problem}\nFor a given set of ideal payouts $\\{\\pi_1, \\ldots, \\pi_N\\}$ for $N$ contest winners, a total prize pool of $B$, and minimum payout $E$, find $(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ to optimize:\n\\begin{eqnarray*}\n\\min \\sum_{j=1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2&\\text{subject to:}&\\\\\nE \\le \\Pi_r<\\Pi_{r-1}< \\dots< \\Pi_1,& & \\hspace{-0mm} \\text{(Monotonicity \\& Min. Payout Requirements)}\\\\\n\n\\sum_{j=1}^r\\Pi_j|S_j|=B,&& \\text{(Prize Pool Requirement)}\\\\\n\\Pi_j \\mbox{ is a ``nice number'' },& j=1,\\ldots r, &\\text{(Nice Number Requirement)}\\\\\n\\sum_{j=1}^r |S_j|=N,&& \\text{(Ensure Exactly $N$ Winners)}\\\\\n0\\leq |S_1| \\leq |S_{2}| < \\dots \\leq |S_r|,&&\\text{(Monotonic Bucket Sizes}\\footnote{Setting $S_1 = \\emptyset$,  $S_2 = \\emptyset$, etc. corresponds to choosing a payout structure with fewer buckets than the maximum allowed.}\\text{)}\n\\end{eqnarray*}\n$\\textit{where } S_j = \\left\\{\\sum_{i < j} |S_i|+1, \\sum_{i < j} |S_i|+2, \\ldots, \\sum_{i \\leq j} |S_i|\\right\\} \\text{ for } j \\in [r]\\footnote{For ease of notation we use $[T]$ to denote the set of integers $\\{1,2,\\ldots,T\\}$.}.$\n\\end{problem}\n\\end{mymathbox}\n\\end{figure*}\n\nNow that we have an initial payout structure $(\\pi_1, \\dots, \\pi_N)$, our goal becomes to identify a related payout structure that is ``close'' to this ideal one, but satisfies the Bucketing, Nice Number, and Monotonic Bucket Size requirements. To accomplish this, we need a way to measure ``closeness'' of payout structures. There are many options, but the one we have found works well in practice is (squared) Euclidean distance: we define the distance between two payout structures $(P_1, \\dots, P_N)$ and $(Q_1, \\dots, Q_N)$ to be $\\sum_{i=1}^N (P_i - Q_i)^2$. \nThis metric is equivalent to the popular ``V-optimal'' measure for approximation of a function by a general histogram \\cite{Ioannidis:1995}.\n\n\n\nWith a measure of closeness in hand, our task becomes equivalent to solving a particular optimization problem, formalized as Problem  \\ref{main_problem}.\nSpecifically, suppose we are given a target number of buckets $r$. Then the goal is to partition the set  $\\{1,\\ldots, N\\}$ into $r$ buckets $S_1,\\ldots,S_r$ (each containing a set of consecutive places), and to choose a set of payouts $\\Pi_1, \\dots, \\Pi_r$ for each bucket such that\n$(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ is an optimal solution to Problem \\ref{main_problem}.  \n\nOne advantage of our approach is that Problem \\ref{main_problem} is agnostic to the initial curve $(\\pi_1, \\dots, \\pi_N)$. Our algorithms could just as easily be applied to an ideal payout curve generated, for example, using the ``constant second derivative'' methodology of the World Series of Poker \\cite{poker2}.\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Problem Feasibility.}}}\nNote that, for a given set of constraints, Problem \\ref{main_problem} \\emph{could} be infeasible as formulated: it may be that no assignment to $(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ satisfies the nice number and bucket size monotonicity constraints while simultaneously giving payouts that sum to our total prize pool, $B$. \nWhile we have observed that the problem is feasible for virtually all fantasy sports tournaments (see Section \\ref{sec:experiments}), we note that it is easy to add flexibility into our constraints so that a feasible solution always exists.\n\nIn particular, both our dynamic programming and integer programming solution can be modified to handle a softer constraint on $N$. For example, we could add a fixed objective function penalty for any extra or fewer winners than $N$, eliminating the hard constraint entirely.\n\nWith this change, Problem 3.1 would be feasible whenever B is a nice-number: we could trivially award a prize of B to first place and prizes of zero to all other players (B is a nice-number for virtually all daily fantasy contests). As we show experimentally in Section \\ref{sec:experiments}, there are typically many feasible solutions, the best of which are vastly better than the trivial ``winner-take-all'' solution.\n\n\\subsection{Exact Solution via Dynamic Programming}\n\\label{subsec:dyno}\nWhile Problem \\ref{main_problem} has complex structure (it is neither linear nor convex), when a solution exists, it can be solved exactly in pseudo-polynomial time via multi-dimensional dynamic programming. \n\nThe runtime of the dynamic program depends on the number of potential prize assignments, which includes all of the nice numbers between $E$ and $B$. Since many reasonable definitions for nice numbers (including our Definition \\ref{def:nice_numbers}) choose these numbers to spread out exponentially as they increase, with the effect that the number of nice numbers below a fixed value $x$ is proportional to $\\log(x)$, we assume that this value is bounded by $O(\\log B)$.\n\n\\begin{theorem}[Dynamic Programming Solution]\n\\label{thm:dynamic}\nAssuming that there are $O(\\log B)$ nice numbers in the range $[E,B]$, then Problem \\ref{main_problem} can be solved in pseudo-polynomial time $O(rN^3B\\log^2B)$.\n\\end{theorem}\nA formal description of the dynamic program and short proof of its correctness are included in Appendix \\ref{app:dyno_proof}.\nUnfortunately, despite a reasonable theoretical runtime, the dynamic program requires $O(rN^2 B \\log B)$ space, which quickly renders the solution infeasible in practice.\n\n\\section{Integer Linear Program}\n\\label{sec:offtheshelf}\n\n\\begin{figure*}[h]\n\\begin{mymathbox}\n\\begin{problem}[Payout Structure Integer Program]\\label{integer_program}\nFor a given set of ideal payouts $\\{\\pi_1, \\ldots, \\pi_N\\}$, a total prize pool of $B$, a given set of acceptable prize payouts $\\{p_1 > p_2 > \\ldots > p_m\\}$, and an allowed budget of $r$ buckets solve:\n\\begin{eqnarray*}\n\\min \\sum_{i\\in[N],j\\in[r],k\\in[m]} x_{i,j,k}\\cdot (\\pi_i - p_k)^2&\\text{subject to:}&\\\\\n\\textbf{\\small{Problem constraints:}}\\\\\n\n\\sum_{k\\in[m]} (k+1/2)\\cdot\\tilde{x}_{j,k}  - k\\cdot\\tilde{x}_{j+1,k} \\leq 0,&j\\in[r-1], &\\text{(Monotonicity Requirements)}\\\\\n\n\\sum_{i\\in[N],j\\in[r],k\\in[m]} x_{i,j,k} \\cdot p_k=B,&& \\text{(Prize Pool Requirement)}\\\\\n\\sum_{i\\in[N], k\\in[m]} x_{i,j,k}  - x_{i,j+1,k} \\leq 0,&j\\in[r-1],&\\text{(Monotonic Bucket Sizes)}\\\\\n\\textbf{\\small{Consistency constraints:}}\\\\\n\\sum_{j\\in[r],k\\in[m]} x_{i,j,k} = 1,&i\\in[N],&\\text{(One Bucket Per Winner)}\\\\\n\\sum_{k\\in[m]} \\tilde{x}_{j,k} \\leq 1,&j\\in[r],&\\text{(One Prize Per Bucket)}\\\\\n&i\\in[N],&\\\\\n\\tilde{x}_{j,k}  - x_{i,j,k} \\geq 0,&j\\in[r], &\\text{(Prize Consistency)}\\\\\n& k\\in[m],&\\\\\n\\end{eqnarray*}\n\\end{problem}\n\\end{mymathbox}\n\\end{figure*}\nAlternatively, despite its complexity, we show that   it is possible to formulate Problem \\ref{main_problem} as a standard integer linear program. Since integer programming is computationally hard in general, this does not immediately yield an efficient algorithm for the problem. However, it does allow for the application of off-the-shelf optimization packages to the payout structure problem. \n\n\nTo keep the formulation as general as possible, assume that we are given a fixed set of acceptable prize payouts, $\\{p_1 > p_2 > \\ldots > p_m\\}$ (where typically $m > r$). These payouts may be generated, for example, using Definition \\ref{def:nice_numbers} for nice numbers. In our implementation, the highest acceptable prize is set to $p_1 = P_1$, where $P_1$ is the pre-specified winning prize. Additionally, to enforce the minimum payout requirement, we chose $p_m \\geq E$. Our integer program, formalized as Problem \\ref{integer_program}, involves the following variables:\n\\begin{itemize}\n\\item $N\\times r \\times m$ \\emph{binary} ``contestant variables'' $x_{i,j,k}$. In our final solution, $x_{i,j,k} = 1$ if and only if contestant $i$ is placed in prize bucket $S_j$ and receives payout $p_k$.\n\\item $r\\times m$ \\emph{binary} ``auxiliary variables'' $\\tilde{x}_{j,k}$.\n$\\tilde{x}_{j,k} = 1$ if and only if bucket $S_j$ is assigned payout $p_k$. Constraints ensure that $x_{i,j,k}$ only equals $1$ when $\\tilde{x}_{j,k} = 1$. If, for a particular $j$, $\\tilde{x}_{j,k} = 0$ for all $k$ then  $S_j$ is not assigned a payout, meaning that the bucket is not used. \n\\end{itemize}\n\n\nIt is easy to extract a payout structure from any solution to the integer program. Proving that the structure conforms to the constraints of Problem \\ref{main_problem} is a bit more involved. The proof appears in Appendix \\ref{app:ip_proof} under the following theorem:\n\n\\begin{theorem}[Integer Programming Solution]\n\\label{thm:integer}\nAny solution satisfying the constraints of integer programming Problem \\ref{integer_program} gives a solution to Problem \\ref{main_problem}.\n\\end{theorem} \n\n\\section{Heuristic Algorithm}\n\\label{sec:heuristic}\nNext we describe a heuristic algorithm for Problem \\ref{main_problem} that is used in production at Yahoo. The algorithm is less rigorous than our integer program and can potentially generate payout structures that violate constraints. However, it scales much better than the IP and experimentally produces stellar payouts. The heuristic  proceeds in four stages.\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 1: Initialize Bucket Sizes}}}\n\\smallskip\n\n\\noindent First the algorithm chooses tentative bucket sizes $|S_1|\\le |S_2|\\le \\ldots\\le |S_r|$. We set $|S_1|=|S_2|=|S_3|=|S_4|=1$. The choice to use 4 ``singleton buckets'', is flexible: while it is our default, the algorithm is easily modified to accommodate more. If $N-\\sum_{i=1}^4|S_i|=1$, we define $|S_5|=1$ and stop. Otherwise we set $|S_t|=\\lceil \\beta\\cdot |S_{t-1}|\\rceil $ where $\\beta\\ge 1$ is a parameter of the heuristic algorithm.  \nThe algorithm stops when $\\lceil\\beta^2 |S_t| \\rceil + \\lceil \\beta |S_t| \\rceil +\\sum_{i=1}^t|S_i|>N$ and $\\lceil \\beta |S_t| \\rceil+\\sum_{i=1}^t|S_i|\\le N$. We define \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\begin{figure*}[h]\n\\centering\n\\includegraphics[width=\\textwidth]{bassmaster_open_2015.eps}\n\\caption{Bassmaster Open payouts are not quite ``nice numbers'' \\protect\\cite{bassmasterInfo}.}\n\\label{fig:bmaster_failure}\n\\end{figure*}\n\n\\subsection{Prior Work} \n\\label{sec:prior_work}\nWhile our exact requirements have not been previously formalized, observation of published payout structures for a variety of contests suggests that similar guiding principals are standard. Moreover, manually determining payouts to match these requirements is, anecdotally, not an easy task. \n\nFor example, while the nice number requirement is often ignored, this may not be from lack of trying: prior attempts to satisfy the constraint often only partially succeed. For example, consider the 2015 Bassmaster Open fishing tournament, which paid out a top prize of \\$51,400, instead of the rounder \\$51,000 or \\$50,000 (see Figure \\ref{fig:bmaster_failure}). The Bassmaster payout structure also violates our constraint on bucket size monotonicity. It is not hard to find similar examples of ``partially optimized'' payout structures for poker \\cite{pokerPayoutsFailure,poker2}, golf  \\cite{usopenprizes}, and other tournament types.\n\n\\medskip \\noindent\n\\textsf{\\small{\\textbf{Payout Structures for Poker.}}} \\label{sec:poker}\nSeveral popular articles describe the efforts of the World Series Of Poker (WSOP),  in conjunction with Adam Schwartz of Washington and Lee University,\nto automate the determination of a payout structure for their annual ``Main Event'' \\cite{poker1,poker2}. After noting the difficulty of manually choosing payouts,\nWSOP asked Schwartz to provide them with an algorithm. His solution, which was based on Newton's Method, was combined with manual intervention to determine the final payout structure for 2005. \nUntil at least 2007, WSOP still utilized considerable manual intervention when determining payouts.\n\nIn 2009, WSOP and Schwartz updated the algorithm, and reduced or removed the need for manual intervention. While we are unaware of a formal description of their solution, it appears to be very different from ours; Schwartz has stated that their solution attempts to obtain payout structures with a ``constant second derivative'' \\cite{poker1,poker2} (our solutions do not satisfy this property). Additionally, their work departs qualitatively from ours in that they do not satisfy nice number requirements or explicitly consider bucket size requirements.\n\n\\medskip \\noindent\n\\textsf{\\small{\\textbf{Piecewise Function Approximation.}}}\nAs mentioned, our payout structure algorithms proceed in two stages. An initial payout curve is first generated with a separate payout for every winning position. The curve is then modified to fit our constraints, which in particular requires bucketing payouts so that a limited number of distinct prizes are paid. We seek the bucketed curve closest to our initial payout curve.\n\nThis curve modification task is similar to the well studied problem of optimal approximation of a function by a histogram (i.e., a piecewise constant function). This problem has received considerable attention, especially for applications to database query optimization \\cite{Ioannidis:2003}. While a number of algorithmic results give exact and approximate solutions \\cite{Jagadish:1998,Guha:2006}, even for the same distance metric employed in Section \\ref{sub:rounding}, unfortunately no known solutions easily adapt to handle our additional constraints beyond bucketing.\n\nWe do note that our dynamic programming solution given in Section \\ref{subsec:dyno} can be viewed as a many dimensional extension of the classic algorithm from \\cite{Jagadish:1998}, with additional dimensions necessary to track our additional constraints.\n\n\\section{Our Solution} \nLet $B$ denote the total prize pool, $N$ denote the number of entrants who should win a non-zero amount, and  $P_i$ denote the prize that we decide to award to place $i$. In general, $B$, $P_1$ and $N$ are user-defined parameters. \n$P_1$ can vary widely in fantasy sports contests, anywhere from $.05\\cdot B$ to nearly $.5\\cdot B$, but $.15 \\cdot B$ is a standard choice (i.e., first place wins 15\\% of the prize pool).  Typically, $N$ is roughly 25\\% of the total number of contest entrants, although it varies as well.\n\nAs described in Section \\ref{sec:requirements}, our solution proceeds in two stages. We first determine an initial payout structure that does not necessarily satisfy the bucketing or nice number requirements. The initial payout for place $i$ will be denoted $\\pi_i$. The second stage modifies the initial payout structure to satisfy these requirements. In particular, we search for the feasible payout structure with the least difference from our initial payouts, measured in terms of sum-of-squared error.\n\n\\subsection{Determining the Initial Payout Structure}\\label{sec:initial_structure} First, to satisfy the Minimum Payout Requirement, we start by giving each winning place $E$ dollars. This leaves $B-N \\cdot E$ additional dollars to disperse among the $N$ winners. How should we do this?\n\nWe have decided that it is best to disperse the remaining budget according to a \\emph{power law}. That is, the amount of the budget that is given to place $i$ should be proportional to $1/i^{\\alpha}$ for some fixed constant $\\alpha > 0$. It is easy to see that for \\emph{any} positive value of $\\alpha$, the resulting payouts will satisfy the Monotonicity Requirement, but there is a unique value of $\\alpha$ ensuring that the payouts sum to exactly the Total Prize Pool $B$. \nSpecifically, we choose the exponent $\\alpha$ to satisfy \n", "index": 5, "text": "$$B-N\\cdot E=\\sum_{i=1}^N\\frac{P_1-E}{i^\\alpha}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"B-N\\cdot E=\\sum_{i=1}^{N}\\frac{P_{1}-E}{i^{\\alpha}}.\" display=\"block\"><mrow><mrow><mrow><mi>B</mi><mo>-</mo><mrow><mi>N</mi><mo>\u22c5</mo><mi>E</mi></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mfrac><mrow><msub><mi>P</mi><mn>1</mn></msub><mo>-</mo><mi>E</mi></mrow><msup><mi>i</mi><mi>\u03b1</mi></msup></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": "\nAn initial value for $\\beta$ can be determined by solving the equation $\\beta + \\beta^2 + \\ldots +  \\beta^{r-4} = N - 4$ using the exact same binary search procedure described in Section \\ref{sec:initial_structure} for finding the parameter of our idea power law payout curve. If the number of buckets returned by the heuristic using the initial $\\beta$ is larger than $r$, we increase $\\beta$ and iterate. \n\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 2: Initialize Prizes}}}\n\\smallskip\n\n\\noindent Next, beginning with the first bucket, we round the first tentative prize, $\\pi_1$, down to the nearest nice number. The difference between $\\pi_1$ and the rounded nice number is called the {\\it leftover}, which we denote by $L$.\nIteratively, for each bucket $S_2, \\ldots, S_t$ we add all the tentative prizes in the bucket together and the leftover from the previous buckets. Let $R_t$ be this number. We define $\\Pi_t$ to equal $R_t/|S_t|$ rounded down to the nearest nice number. If the computed prize for bucket $t$ is greater than or equal to the prize in bucket $t-1$, $\\Pi_{t-1}$, we simply merge all member of $S_t$ into $S_{t-1}$, assigning them prize $\\Pi_{t-1}$.\nAt the end we may have some non-zero leftover $L$ remaining from the last bucket.\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 3: Post-Process Non-monotonic Bucket Sizes}}}\n\\smallskip\n\n\\noindent Although the initial buckets from Step 1 increase in size, potential bucket merging in Step 2 could lead to violations in the Monotonic Bucket Size constraint. \nTo correct this issue, whenever $|S_t|$ is larger than $|S_{t+1}|$, we shift users to bucket $t+1$ until the situation is corrected. As a result we decrease the prizes for some users and increase the leftover $L$ by the corresponding amount. We repeat this process starting from $S_1$ and ending at our lowest prize level bucket.\n \n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 4: Spend Leftover Funds}}}\n\\smallskip\n\n\\noindent Finally, we modify our payouts to spend the leftover $L$.  We first spend as much as possible on ranks 2 through 4, which are contained in singleton buckets. We avoid modifying first prize because it is often given as a hard requirement -- e.g. we want pay exactly \\$1 million to the winner. In order from $i=2$ to $4$ we adjust $\\Pi_i$ to equal $\\min\\{\\Pi_i+L,(\\Pi_{i-1}+\\Pi_i)/2\\}$, rounded down to a nice number. This spends as much of $L$ as possible, while avoiding too large an increase in each prize. \n\nIf $L$ remains non-zero, we first try to adjust only the final (largest) bucket, $S_k$.\nIf $L\\ge |S_k|$ then we set $\\Pi_k=\\Pi_k+1$ and $L=L-|S_k|$, i.e. we increase the prize for every user in $S_k$ by $1$. Note that this could lead to nice number violations, which are not corrected. We repeat this process (possibly merging buckets) until $L<|S_k|$. If at this point $L$ is divisible by $\\Pi_k$ we increase $|S_k|$ by $L/\\Pi_k$ (thereby increasing the number of users winning nonzero prizes beyond $N$). \n\nIf $L$ is not divisible by $\\Pi_k$, we rollback our changes to the last bucket and attempt to spend $L$ on the last \\emph{two} buckets. Compute the amount of money available, which is the sum of all prizes in these buckets plus $L$. Fix the last bucket prize to be the minimal possible amount, $E$. Enumerate over possible sizes and integer prize amounts  for the penultimate bucket, again ignoring nice number constraints. If the last bucket can be made to have integer size (with payout $E$), store the potential solution and evaluate a ``constraint cost'' to penalize how much it violates constraints. The constraint cost charges $100$ for each unit of difference if the number of winners is less than $N$, $1$ for each unit of difference if the number of winners is larger than $N$, and $10$ for each unit of violation in bucket size monotonicity. Out of all solutions generated return the one with minimal constraint cost.\n\n\\section{Experiments}\n\\label{sec:experiments}\n\nWe conclude with experiments that confirm the effectiveness of both the integer program (Section \\ref{sec:offtheshelf}) and our heuristic (Section \\ref{sec:heuristic}). Both algorithms were implemented in Java and tested on a commodity laptop with a 2.6 GHz Intel Core i7 processor and 16 GB of 1600 MHz DDR3 memory.\n\nFor the integer program, we employ the off-the-shelf, open source GNU Linear Programming Kit (GLPK), accessed through the SCPSolver frontend \\cite{GLPK,scpsolver}. The package uses a branch-and-cut algorithm for IPs with a simplex method for underlying linear program relaxations.\n\nWe construct experimental payout structures for a variety of daily fantasy tournaments from Yahoo, FanDuel, and DraftKings and test on non-fantasy tournaments as well. \n\nFor non-Yahoo contests, $P_1$ is set to the published winning prize or, when necessary, to a nearby nice number. The maximum number of buckets $r$ is set to match the number of buckets used in the published payout structure, although we cap the value at $30$ for most contests and $40$ for extremely large contests ($>50,000$ winners). For fantasy sports, $E$ is set to the nearest nice number above $1.5$ times the entry fee. For all other contests  (which often lack entry fees or have a complex qualification structure) $E$ is set to the nearest nice number above the published minimum prize.\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Quantitative Comparison.}}}\nOur results can be evaluated by computing the Euclidean distance between our ideal pay out curve, $\\{\\pi_1, \\ldots, \\pi_n\\}$, and the bucketed curve $\\{\\Pi_1, \\ldots \\Pi_m\\}$. In heuristic solutions, if $m$ does not equal $n$, we extend the curves with zeros to compute the distance (which penalizes extra or missing winners as much as possible). Our experimental data is included in Table \\ref{tab:main_table}. Entries of ``--'' indicate that the integer program did not run to completion, possibly because no solution to Problem \\ref{integer_program} exists. The cost presented is the sum of squared distances from the bucketed payouts to ideal power law payouts, as defined in Problem \\ref{main_problem}. Note that we do not provide a cost for the \\emph{source} payout structure since, besides the Yahoo contests, these structures were not designed to fit our proposed ideal payout curve and thus cannot be expected to achieve small objective function values.\n\n\\begin{table*}[h]\n\\tbl{Accuracy and Runtime (in milliseconds) for Integer Program (IP) vs. Heuristic (Heur.) Solutions\\label{tab:main_table}}{\n\\tiny\n\n\\centering \n\\begin{tabular}{||c|c|c|c|c|c||c|c||c|c|c||} \n\\hhline{|t:======:t:==:t:===:t|}\nSource&\\specialcell{Prize Pool} & \\specialcell{Top Prize} & \\specialcell{Min. Prize} &\\specialcell{\\# of\\\\ Winners} & \\specialcell{\\# of\\\\ Buckets}& \\specialcell{IP \\\\ Cost} & \\specialcell{IP Time \\\\(ms)} & \\specialcell{Heur. \\\\Cost} & \\specialcell{Heur. Time \\\\(ms)} & \\specialcell{Heur. \\\\ Extra Winners} \\\\\n\\hhline{||-|-|-|-|-|-||-|-||---||}\nYahoo & 90 & 25 & 2& 30 & 7& .89 &7.6k &2.35 & 1 & 0 \\\\ \nYahoo & 180 & 55 & 3& 30 & 10& 2.82 &725k &3.44 & 1 & 0\\\\ \nDraftKings & 500 & 100 & 8& 20 & 10& 6.15 &2.1k &9.21 & 1 &0 \\\\ \nYahoo & 2250 & 650 & 150& 7 & 7& 32.4 &4.0k &187.4 & 1 &0 \\\\\nYahoo & 3000 & 300 & 2& 850 & 25& -- &-- &86.9 & 7 & 2 \\\\ \nFanDuel & 4000 & 900 & 50& 40 & 12& 20.7 &3716k &58.2 & 2 &1 \\\\ \nFanDuel & 4000 & 800 & 75& 16 & 7& 46.6 &2.9k &230.1 & 1 &4 \\\\ \nDraftKings & 5000 & 1250 & 150& 11 & 8& 52.5 &6.8k &123.5 & 1 &0 \\\\ \nYahoo & 10000 & 1000 & 7& 550 & 25& -- &-- &97.3 & 8 &1 \\\\ \nDraftKings & 10000 & 1500 & 75& 42 & 12& 61.3 &1291k &173.7 & 2 &0 \\\\ \nFanDuel & 18000 & 4000 & 150& 38 & 10& 161.8 &131k &347.0 & 5 &0 \\\\ \nFanDuel & 100000 & 10000 & 2& 23000 & 25& -- &-- &3.1k & 152 &34 \\\\ \nBassmaster & 190700 & 50000 & 2000& 40 & 15& -- &-- & 3.5k\\textsuperscript{*} & 3 &0 \\\\ \nBassmaster & 190000\\textsuperscript{$\\dagger$}\\ & 50000 & 2000& 40 & 15& 2.5k &3462k & 2.8k & 1 &0 \\\\ \nFLW Fishing & 751588 & 100000 & 9000& 60 & 25& -- &-- & 6.0k\\textsuperscript{*} & 3 &0 \\\\ \nFLW Fishing & 751500\\textsuperscript{$\\dagger$}\\ & 100000 & 9000& 60 & 25& -- &-- & 6.0k & 2 &0 \\\\ \nFanDuel & 1000000 & 100000 & 15& 16000 & 25& -- &-- &5.3k & 203 &7 \\\\ \nDraftKings & 1000000 & 100000 & 5& 85000 & 40& -- &-- & 25.9k & 1.2k &0 \\\\ \nBassmaster & 1031500 & 30000 & 10000& 55 & 25& -- &-- & 13.5k\\textsuperscript{*} & 14 &0 \\\\ \nFanDuel & 5000000 & 1000000 & 40& 46000 & 30& -- &-- &44.3k & 1.0k &0 \\\\ \nPGA Golf & 9715981 & 1800000 & 20000& 69 & 69& -- &-- & 254.5k\\textsuperscript{*} & 24 &0 \\\\ \nPGA Golf & 1000000\\textsuperscript{$\\dagger$}\\ & 1800000 & 20000& 75 & 75& -- &-- & 215.9k\\textsuperscript{**} & 23 &9 \\\\ \nDraftKings & 10000000 & 2000000 & 25& 125000 & 40& -- &-- & 78.7k & 1.7k &0 \\\\ \nPoker Stars& 10393400 & 1750000 & 15000& 160 & 25& -- &-- & 133.0k\\textsuperscript{*} & 27 &0 \\\\ \nWSOP & 60348000 & 8000000 & 15000& 1000 & 30& -- &-- & 462.3k\\textsuperscript{*} & 17 &0 \\\\ \n\\hhline{|b:======:b:==:b:===:b|}\n\\multicolumn{11}{l}{{\\rule{0pt}{5.4ex}}\\specialcellleft{\\textsuperscript{$\\dagger$}\\footnotesize{Contest is identical to the contest in the preceding row, but with the prize pool rounded to a nearby} \\\\ \\footnotesize{number in an effort to force a solution involving only nice numbers to exist.}}}\\\\\n\\multicolumn{11}{l}{{\\rule{0pt}{2.9ex}}\\textsuperscript{*}\\footnotesize{Heuristic produced solution with (unavoidable) nice number constraint violation for a single bucket.}}\\\\\n\\multicolumn{11}{l}{{\\rule{0pt}{2.9ex}}\\textsuperscript{**}\\footnotesize{Heuristic produced solution with (avoidable) nice number constraint violation for a single bucket.}}\\\\\n\\end{tabular}}\n\\end{table*}\n\nAs expected, when it succeeds in finding a solution, the integer program consistently outperforms the heuristic. However, the difference is rarely large, with heuristic cost typically below 5x that of the IP. Furthermore, the heuristic runs in less than 1.5 seconds for even the most challenging contests. The heuristic's ability to generate payout structures when no solution to Problem 4.1 exists is also a substantial advantage: it always returns a solution, but potentially with a slightly different number of winners paid or with a single constraint violation in the last two buckets (either a non-nice number payout or more winners in the penultimate bucket than in the final bucket).\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Constraint Violations.}}}\nIn our experiments, our heuristic actually only produced nice number violations, with no bucket size monotonicity violations for any experiment. Note that 6 of the 7 nice number violations are unavoidable given the input minimum prize and prize pool. For example, consider the Fishing League Worldwide (FLW) fishing tournament with a prize pool of \\$751,588 and a minimum prize of \\$9,000. Since all nice numbers greater than or equal to \\$9000 are multiples of \\$5000, it is impossible to construct a fully satisfiable set of payouts summing to \\$751,588. In all cases besides one (the PGA tournament with prize pool \\$9,715,981) simply rounding the prize pool to a nearby number produced an input for which the heuristic output a solution with no constraint violations. However, in settings where the prize pool \\emph{must} be a non-nice number (i.e., cannot be rounded up or down to a nice number, for whatever reason), our heuristic's flexibility is an advantage over the more rigid integer program.\n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{fanduel2.eps} \n\\caption{FanDuel, Baseball}\n\\end{subfigure}\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{fanduel1.eps}\n\\caption{FanDuel, Baseball}\n\\label{subfig:fduel2}\n\\end{subfigure}\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{draftkings1.eps}\n\\caption{DraftKings, Baseball}\n\\label{subfig:dkings1}\n\\end{subfigure}\n\\caption{Payout Structures for Small Daily Fantasy Contests}\n\\label{fig:small_contests}\n\\end{figure*}\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Qualitative Comparison.}}}\nBeyond quantitative measures to compare algorithms for Problem \\ref{main_problem}, evaluating our two stage framework as a whole requires a more qualitative approach. Accordingly, we include plots comparing our generated payout structures to existing published structures. \n\nFor small fantasy sports contests (Figure \\ref{fig:small_contests}) both of our algorithms match payouts from FanDuel and DraftKings extremely well, often overlapping for large sections of the discretized payout curve. To our knowledge, FanDuel and DraftKings have not publicly discussed their methods for computing payouts; their methods may involve considerable manual intervention, so matching these structures algorithmically is encouraging.\nIn some cases, notably in Figures \\ref{subfig:dkings1} and \\ref{subfig:fduel2}, our payout curve is ``flatter'', meaning there is a smaller separation between the top prizes and lower prizes. Many poker and daily fantasy sports players prefer flatter structures due to reduced payout variance \\cite{roto1,roto2}. \n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{fanduelLarge1.eps} \n\\caption{FanDuel, Football}\n\\label{fig:large_contests_fd}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{DraftKingsLarge1.eps}\n\\caption{DraftKings, Football}\n\\label{fig:large_contests_dk}\n\\end{subfigure}\n\\caption{Payout Structures for Large Daily Fantasy Contests}\n\\label{fig:large_contests}\n\\end{figure*}\n\nWe compare larger fantasy contest payouts in Figure \\ref{fig:large_contests}, plotting the $x$ axis on a log scale due to a huge number of winning places (16,000 and 125,000 for  \\ref{fig:large_contests_fd} and  \\ref{fig:large_contests_dk} respectively).\nAgain our results are very similar to those of FanDuel and DraftKings, with our methods producing only slightly flatter payouts.\n\n\nWe also show that both of our algorithms can easily construct high quality payout structures for non-fantasy sports tournaments, avoiding the difficulties discussed in Section \\ref{sec:prior_work}. Returning to the Bassmaster example from Figure \\ref{fig:bmaster_failure}, we show more satisfying structures generated by our IP and heuristic algorithm in Figure \\ref{fig:bmaster_fixed}. For the IP, we rounded the prize pool to \\$190,000 from \\$190,700 to ensure a solution to Problem \\ref{integer_program} exists. However, even for the original prize pool, our heuristic solution has just one non-nice number payout of \\$2,700 and no other constraint violations. Both solutions visibly avoid the issue of non-monotonic bucket sizes exhibited by the published Bassmaster payout structure.\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=.8\\textwidth]{bassmaster_fixed.eps}\n\\caption{Alternative Bassmaster Open 2015 Payouts}\n\\label{fig:bmaster_fixed}\n\\end{figure}\n\nWe conclude with an example from the popular World Series of Poker. The 2015 Main Event payed out \\$60,348,000 to 1000 winners in  31 buckets with far from ``nice number'' prizes \\cite{wsop_events}.\n\n\n\n\nHowever, several months prior to the WSOP tournament, the organizers published a very different \\emph{tentative} payout structure \\cite{pokerPayoutsFailure}, that appears to have attempted to satisfy many of the constraints of Problem \\ref{main_problem}: it uses mostly nice number prizes and nearly satisfies our bucket size monotonicity constraint (see Figure \\ref{fig:wsop_tent}). \n\nThis tentative payout structure suggests that WSOP organizers originally sought a better solution than the payout structure actually used. Perhaps the effort was abandoned due to time constraints: the World Series of Poker prize pool is not finalized until just before the event (it depends on the total number of entries).\n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{wsop_2015_tentative2.eps} \n\\caption{WSOP 2015 Tentative Prizes}\n\\label{fig:wsop_tent}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{wsop_fix.eps}\n\\caption{Generated ``Nice'' Payout Structure}\n\\label{fig:wsop_fix}\n\\end{subfigure}\n\\caption{Payout Structure Generation for WSOP 2015 Main Event }\n\\label{fig:wsop}\n\\end{figure*}\n\n We show in Table \\ref{tab:wsop} that our heuristic can rapidly (in 17 milliseconds) generate an aesthetically pleasing payout structure for the final prize pool with the initially planned top prize of \\$8 million, and just one minor nice number violation (our final bucket pays \\$20,150). Our output and the actual WSOP payout structure are also compared visually in Figure \\ref{fig:wsop_fix} to the power curve used in the first stage of our algorithm. In keeping with the WSOP tradition of paying out separate prizes to places 1-9 (the players who make it to the famous ``November Nine'' final table) we run our heuristic with 9 guaranteed singleton buckets instead of 4 (see Section \\ref{sec:heuristic} for details).\n\n\\begin{table}[h]\n\\tbl{An alternative ``nice number'' payout structure  for the World Series of Poker 2015 Main Event.\\label{tab:wsop}}{\n\\scriptsize\n\\centering \n\\begin{tabular}{||c|c||c|c||} \n\\hhline{|t:==:t:==:t|}\n\\multicolumn{2}{||c||}{\\specialcell{2015 WSOP \\\\Payouts}} & \\multicolumn{2}{|c||}{\\specialcell{Our Alternative \\\\Payouts}} \\\\\n\\hline\nPlace & Prize & Place & Prize \\\\\n\\hline\n1 & \\$7,680,021 & 1& \\$8,000,000 \\\\\n2 & \\$4,469,171 & 2& \\$4,000,000 \\\\\n3 & \\$3,397,103 & 3& \\$2,250,000 \\\\\n4 & \\$2,614,558  & 4& \\$1,750,000 \\\\\n5 & \\$1,910,971 & 5& \\$1,250,000 \\\\\n6 & \\$1,426,072 & 6& \\$1,000,000\\\\\n7 & \\$1,203,193 & 7 & \\$950,000 \\\\\n8 & \\$1,097,009 & 8& \\$850,000 \\\\\n9 & \\$1,001,020 & 9& \\$700,000\\\\\n10 & \\$756,897 & \\multirow{2}{*}{10 - 13}& \\multirow{2}{*}{\\$650,000} \\\\\n11 - 12& \\$526,778 & & \\\\\n13 - 15& \\$411,453 & \\multirow{2}{*}{14 - 17}& \\multirow{2}{*}{\\$500,000} \\\\\n16 - 18& \\$325,034 & & \\\\\n\\multirow{2}{*}{19 - 27}& \\multirow{2}{*}{\\$262,574} & 18 - 23& \\$300,000 \\\\\n& & 24 - 29& \\$225,000  \\\\\n28 - 36& \\$211,821 & 30 - 35& \\$200,000  \\\\\n36 - 45& \\$164,086 &  36 - 42& \\$150,000 \\\\\n46 - 54& \\$137,300 & 43 - 59& \\$125,000\\\\\n55 - 63& \\$113,764  & \\multirow{3}{*}{60 - 77}& \\$95,000 \\\\\n64 - 72& \\$96,445& &  \\\\\n73 - 81& \\$79,668 & & \\\\\n82 - 90& \\$68,624 & \\multirow{2}{*}{78 - 99}& \\multirow{2}{*}{\\$75,000} \\\\\n91 - 99& \\$55,649& & \\\\\n\\multirow{2}{*}{100 - 162}& \\multirow{2}{*}{\\$46,890} & 100 - 128& \\$60,000 \\\\\n & & 128 - 164& \\$55,000 \\\\\n163 - 225& \\$40,433 & 165 - 254& \\$45,000 \\\\\n226 - 288& \\$34,157 & \\multirow{2}{*}{255 - 345}& \\multirow{2}{*}{\\$35,000} \\\\\n289 - 351& \\$29,329 & &  \\\\\n352 - 414& \\$24,622 & \\multirow{2}{*}{346 - 441}& \\multirow{2}{*}{\\$25,000} \\\\\n415 - 477& \\$21,786 & &\\\\\n478 - 549&  \\$19,500 &\\multirow{2}{*}{442 - 710} & \\multirow{2}{*}{\\$22,500} \\\\\n550 - 648& \\$17,282 & & \\\\\n649 - 1000& \\$15,000 & 711 - 1000& \\$20,150 \\\\\n\\hhline{|b:==:b:==:b|}\n\\end{tabular}\n}\n\\end{table}\n\n\\bibliography{EC_PayoutsPaper}{}\n\\bibliographystyle{ACM-Reference-Format-Journals}\n\n\\appendix\n\\section{Dynamic Programming Details}\n\\label{app:dyno_proof}\n\\begin{reptheorem}{thm:dynamic}[Dynamic Programming Solution]\nAssuming that there are $O(\\log B)$ nice numbers in the range $[E,B]$, then Problem \\ref{main_problem} can be solved in pseudo-polynomial time $O(rN^3B\\log^2B)$.\n\\end{reptheorem}\n\\begin{proof}\nWe can construct a dynamic program that chooses buckets and prizes in order from the lowest awarded places to the winner: $(S_r, \\Pi_r), (S_{r-1}, \\Pi_{r-1}),\\ldots (S_{1}, \\Pi_{1})$.\nSuppose you have already selected $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$. Since our objective function can be separated as\n$\\sum_{j=1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2 = \\sum_{j=1}^i \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2 +  \\sum_{j=i+1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2$, \nthe task of choosing the optimal $(S_{i}, \\Pi_{i}), \\ldots, (S_{1}, \\Pi_{1})$ then reduces to solving a smaller instance of Problem \\ref{main_problem}, with:\n\\begin{enumerate}\n\\item $N$ = the number of winners remaining, i.e. those not placed in $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$.\n\\item $B$ = the prize budget remaining, i.e. whatever was not consumed by $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$.\n\\item $E$ = the smallest nice number greater than maximum prize given so far, $\\Pi_{i+1}$.\n\\item An additional constraint on maximum bucket size, which must be less than $|S_{i+1}|$.\n\\end{enumerate}\nThus, for a given tuple of (winners consumed, budget consumed, $\\Pi_{i+1}$, $|S_{i+1}|$), our choice for $(S_{i}, \\Pi_{i}), \\ldots, (S_{1}, \\Pi_{1})$ can ignore any other aspects of $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$. Accordingly, it suffices to store the optimal assignment to $(S_r, \\Pi_r), \\ldots,\\allowbreak (S_{i+1}, \\Pi_{i+1})$ for each such 4-tuple. There are at worst $N\\times B\\times O(\\log B) \\times N = O(N^2 B \\log B)$ tuples. \n\nNow, given all assignments for $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$ that are optimal for some tuple, one simple way to generate the set of optimal assignments for $(S_r, \\Pi_r), \\ldots, (S_{i}, \\Pi_{i})$ is to try adding every possible $(S_{i}, \\Pi_{i})$ (there are $\\leq N\\log B$ of them) to each optimal assignment. For each new assignment generated, we check if it has lower cost than the current best assignment to $(S_r, \\Pi_r), \\ldots, (S_{i}, \\Pi_{i})$ for the tuple induced by the choice of $(S_{i}, \\Pi_{i})$ (or just store it if no other assignment has induced the tuple before). In total this update procedure takes time $O(N\\log B) \\times O(N^2 B \\log B)$ time. It must be repeated $r$ times, once for each bucket added. Our total runtime is thus $O(rN^3B\\log^2 B)$.\n\\end{proof}\nThe dynamic program solution requires $O(r N^2 B \\log B)$ space to store the optimal assignment for each tuple at the current iteration.\n\n\\section{Integer Programming Details}\n\\label{app:ip_proof}\n\\begin{reptheorem}{thm:integer}[Integer Programming Solution]\nAny solution satisfying the constraints of integer programming Problem \\ref{integer_program} gives a solution to Problem \\ref{main_problem}.\n\\end{reptheorem}\n\n\\begin{proof}\nGiven a solution to Problem \\ref{integer_program}, a solution to Problem \\ref{main_problem} is obtained by first checking each auxiliary variable. If $\\tilde{x}_{j,k} = 1$, then $\\Pi_j$ is set to $p_k$. The second consistency constraint ensures that for a given $j$, $\\tilde{x}_{j,k}$ can equal 1 for at most one value of $k$. Thus, each $\\Pi_j$ is assigned at most once. If no $\\tilde{x}_{j,k}$ is equal to 1 for a given $j$, then $\\Pi_j$ and accordingly $S_j$, remain unused in our solution.\n\nThe winners for bucket $S_j$ are simply all values of $i$ for which $x_{i,j,k}$ is equal to 1. Our first consistency constraint ensures that for a given $i$, $x_{i,j,k}$ is 1 exactly once, meaning that each winner is assigned to a single bucket. The third consistency constraint ensures that $x_{i,j,k} = 1$ only when $\\tilde{x}_{j,k} = 1$, which ensures that each winner in bucket $S_j$ is assigned the correct payout, $\\Pi_j = p_k$. \n\nAccordingly, any solution to Problem \\ref{integer_program} produces a valid payout structure and we just need to prove that it conforms to the constraints of our original optimization problem.\n\n Recalling that, for a given $i$, $x_{i,j,k} = 1$ for exactly one pair $(j,k)$, it is straight forward to see that the objective function and prize pool constraint are equivalent those from Problem \\ref{main_problem} as long. The bucket size monotonicity constraint is also simple to verify: $\\sum_{i\\in[N], k\\in[m]} x_{i,j,k}$ is exactly equal to the number of winners assigned to bucket $j$, $|S_j|$. So our constraint correctly verifies that $|S_j| \\leq |S_{j+1}|$ for all $j$.\n\nFor the monotonicity requirement, notice that $\\sum_{k\\in[m]} (k+\\frac{1}{2})\\cdot\\tilde{x}_{j,k}$ simply equals $k + \\frac{1}{2}$ whenever $\\Pi_j = p_k$ in our solution. Similarly $\\sum_{k\\in[m]} k\\cdot\\tilde{x}_{j+1,k}$ equals $k$ when $\\Pi_{j+1} = p_k$. Since lower values of $k$ correspond to higher prize payouts (recall that $p_1 > p_2 > \\ldots p_k$), the first constraint in our integer program therefore ensures that $\\Pi_j$ is strictly greater than $\\Pi_{j+1}$. There are a number of ways to enforce the ``strictly'' requirement besides adding the $\\frac{1}{2}$ where we did. However, this particular approach gracefully allows the constraint to be satisfied when \\emph{no prize} is assigned to bucket $S_j$ (i.e. the bucket is not used in our solution. In that case $\\sum_{k\\in[m]} (k+\\frac{1}{2})\\cdot\\tilde{x}_{j,k}$ will equal zero since $\\tilde{x}_{j,k}$ will equal 0 for all $k$. We would run into an issue if say, bucket $S_j$ is not used but bucket $S_{j-1}$ is. Accordingly, any solution to Problem \\ref{integer_program} not using $r$ buckets must leave the lowest number sets empty, in accordance with the convention from Problem \\ref{main_problem}.\n\nFinally, note that we did not include any inequalities to ensure that each bucket contains a contiguous range of winners -- for examples winners 6 through 11 or 54 through 75. We can avoid this costly constraint because it is implicitly enforced by our choice of objective function and the monotonicity of ideal payouts. Suppose some bucket contains a non-contiguous set of winners. Then for at least two winning positions $i > j$ it must be that the prize given to winner $i$, $p_{low}$, is less than the prize given to winner $j$, $p_{high}$. At the same time, we know that for our ideal payouts, $\\pi_i \\geq \\pi_j$. We argue that such a configuration cannot exist in an optimal solution to Problem \\ref{integer_program} because switching the prizes so that $i$ receives $p_{high}$ and $j$ receives $p_{low}$ gives a strictly better solution.\n\nFirst off, clearly switching the prizes will not effect our other constraints: total payout amount and bucket sizes will remain unchanged. Now, our cost function is simply additive over each winner, and the cost incurred by players $i$ and $j$ in the non-contiguous ordering is:\n\n", "itemtype": "equation", "pos": 32836, "prevtext": " We can efficiently solve this equation for $\\alpha$ to additive error less than $.01$ via binary search. We then define the ideal payout to place $i$ \nto be $\\pi_i := E +  \\frac{P_1-E}{i^\\alpha}$. This definition ensures both that first place gets paid exactly $\\$P_1$, and that the sum of all of the tentative payouts is exactly $B$.\n\n\\begin{figure}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{power_law.eps} \n\\caption{Ideal Payouts Using Power Law Method.}\n\\label{fig1}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{exp_law.eps}\n\\caption{Ideal Payouts Using Exponential Distribution.}\n\\label{fig2}\n\\end{subfigure}\n\\caption{Possible initial payout structure when $N=\\text{10,000}$, $P_1=\\text{150,000}$, and $B=\\text{1 million}$.}\n\\label{examplefig}\n\\end{figure}\n\nWhy use a power law? The most pragmatic answer is that, empirically, a power law ensures that as we move from 1st place to 2nd to 3rd and so on, payouts drop off at a nice pace: fast enough that the very top finishers are richly rewarded relative to the rest of the pack, but slow enough that users in, say, the 10th percentile still win a lot of money. An initial curve based on a power law also encourages increased prize differences between higher places, a property cited as a desirable by WSOP organizers \\cite{poker2}.\n\nThere are other sociological justifications -- for example, wealth in real societies roughly follows a power law distribution, and humans should be intuitively comfortable with payouts that mirror the real world \\cite{pareto1896cours,chatterjee2005econophysics}. \n\nFor illustration, consider a tournament where 40,000 entrants vie for \\$1 million in prizes. \nIf first place receives 15\\% of the prize pool and 25\\% of all entrants should win a non-zero amount, then $P_1 =\\$150,000$ and $N=10,000$. \nFigure \\ref{fig1} reveals the initial set of payouts determined by our power law method. Note that the y axis on this plot uses a logarithmic scale, so although the dots for first and second place appear very close, in fact first place is winning slightly more than twice as much as second place. \n\nFigure \\ref{fig2} reveals what the initial payouts would be if we used an exponential distribution instead, with prizes proportional to $1/\\alpha^i$ rather than $1/i^\\alpha$. Such distributions are a popular choice for smaller tournaments, but the plot reveals that they yield much more top-heavy payouts than a power law approach. In fact, only the top few dozen places receive more than the minimum prize in our example.\n\n\n\nAs further justification, we check in Figure \\ref{fig:empirical_payouts} that a power law roughly models payouts for existing fantasy sports contests and other large tournaments. Since $\\log(i^\\alpha) = \\alpha\\log(i)$, plotting payouts with both axes on a logarithmic scale will reveal a roughly linear trend when the payout distribution approximates a power law. Thus, the plots demonstrate that all of these existing fantasy sports contests have payout structures that are consistent with a power law. On the other hand, for an exponential distribution, $\\log(1/\\alpha^i) = i\\log(1/\\alpha)$, which is not linear in $\\log(i)$. \n\n\\begin{figure}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{empirical_power_law_fantasy.eps} \n\\caption{Large Fantasy Sports Tournaments.}\n\\label{empirical_payouts:sub1}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{empirical_power_law_nonfantasy.eps}\n\\caption{Other Well Known Tournaments.}\n\\label{empirical_payouts:sub2}\n\\end{subfigure}\n\\caption{Log plots of existing tournament payout structures indicate linear structure.}\n\\label{fig:empirical_payouts}\n\\end{figure}\n\nObtaining quantitative goodness-of-fit metrics for power law distributions can be a difficult task \\cite{clauset2009power} especially given heavy ``value binning'' \\cite{virkar2014power}, which is of course present in tournament payout structures. Nevertheless, standard fitting and testing routines \\cite{powerLawCode} yield an average $p$-value of $.237$ when a power law is fit to the payouts from Figure \\ref{fig:empirical_payouts}. This value is in line with calculated $p$-values for well known empirical power law distributions that have binned values \\cite{virkar2014power}.\n\nOverall, the power law's simplicity, empirical effectiveness, and historical justification make it an ideal candidate for generating initial prize values.\n\n\\subsection{Satisfying the Remaining Requirements}\n\\label{sub:rounding}\n\\begin{figure*}[h]\n\\begin{mymathbox}\n\\begin{problem}[Payout Structure Optimization]\n\\label{main_problem}\nFor a given set of ideal payouts $\\{\\pi_1, \\ldots, \\pi_N\\}$ for $N$ contest winners, a total prize pool of $B$, and minimum payout $E$, find $(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ to optimize:\n\\begin{eqnarray*}\n\\min \\sum_{j=1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2&\\text{subject to:}&\\\\\nE \\le \\Pi_r<\\Pi_{r-1}< \\dots< \\Pi_1,& & \\hspace{-0mm} \\text{(Monotonicity \\& Min. Payout Requirements)}\\\\\n\n\\sum_{j=1}^r\\Pi_j|S_j|=B,&& \\text{(Prize Pool Requirement)}\\\\\n\\Pi_j \\mbox{ is a ``nice number'' },& j=1,\\ldots r, &\\text{(Nice Number Requirement)}\\\\\n\\sum_{j=1}^r |S_j|=N,&& \\text{(Ensure Exactly $N$ Winners)}\\\\\n0\\leq |S_1| \\leq |S_{2}| < \\dots \\leq |S_r|,&&\\text{(Monotonic Bucket Sizes}\\footnote{Setting $S_1 = \\emptyset$,  $S_2 = \\emptyset$, etc. corresponds to choosing a payout structure with fewer buckets than the maximum allowed.}\\text{)}\n\\end{eqnarray*}\n$\\textit{where } S_j = \\left\\{\\sum_{i < j} |S_i|+1, \\sum_{i < j} |S_i|+2, \\ldots, \\sum_{i \\leq j} |S_i|\\right\\} \\text{ for } j \\in [r]\\footnote{For ease of notation we use $[T]$ to denote the set of integers $\\{1,2,\\ldots,T\\}$.}.$\n\\end{problem}\n\\end{mymathbox}\n\\end{figure*}\n\nNow that we have an initial payout structure $(\\pi_1, \\dots, \\pi_N)$, our goal becomes to identify a related payout structure that is ``close'' to this ideal one, but satisfies the Bucketing, Nice Number, and Monotonic Bucket Size requirements. To accomplish this, we need a way to measure ``closeness'' of payout structures. There are many options, but the one we have found works well in practice is (squared) Euclidean distance: we define the distance between two payout structures $(P_1, \\dots, P_N)$ and $(Q_1, \\dots, Q_N)$ to be $\\sum_{i=1}^N (P_i - Q_i)^2$. \nThis metric is equivalent to the popular ``V-optimal'' measure for approximation of a function by a general histogram \\cite{Ioannidis:1995}.\n\n\n\nWith a measure of closeness in hand, our task becomes equivalent to solving a particular optimization problem, formalized as Problem  \\ref{main_problem}.\nSpecifically, suppose we are given a target number of buckets $r$. Then the goal is to partition the set  $\\{1,\\ldots, N\\}$ into $r$ buckets $S_1,\\ldots,S_r$ (each containing a set of consecutive places), and to choose a set of payouts $\\Pi_1, \\dots, \\Pi_r$ for each bucket such that\n$(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ is an optimal solution to Problem \\ref{main_problem}.  \n\nOne advantage of our approach is that Problem \\ref{main_problem} is agnostic to the initial curve $(\\pi_1, \\dots, \\pi_N)$. Our algorithms could just as easily be applied to an ideal payout curve generated, for example, using the ``constant second derivative'' methodology of the World Series of Poker \\cite{poker2}.\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Problem Feasibility.}}}\nNote that, for a given set of constraints, Problem \\ref{main_problem} \\emph{could} be infeasible as formulated: it may be that no assignment to $(S_1, \\dots, S_r, \\Pi_1, \\dots, \\Pi_r)$ satisfies the nice number and bucket size monotonicity constraints while simultaneously giving payouts that sum to our total prize pool, $B$. \nWhile we have observed that the problem is feasible for virtually all fantasy sports tournaments (see Section \\ref{sec:experiments}), we note that it is easy to add flexibility into our constraints so that a feasible solution always exists.\n\nIn particular, both our dynamic programming and integer programming solution can be modified to handle a softer constraint on $N$. For example, we could add a fixed objective function penalty for any extra or fewer winners than $N$, eliminating the hard constraint entirely.\n\nWith this change, Problem 3.1 would be feasible whenever B is a nice-number: we could trivially award a prize of B to first place and prizes of zero to all other players (B is a nice-number for virtually all daily fantasy contests). As we show experimentally in Section \\ref{sec:experiments}, there are typically many feasible solutions, the best of which are vastly better than the trivial ``winner-take-all'' solution.\n\n\\subsection{Exact Solution via Dynamic Programming}\n\\label{subsec:dyno}\nWhile Problem \\ref{main_problem} has complex structure (it is neither linear nor convex), when a solution exists, it can be solved exactly in pseudo-polynomial time via multi-dimensional dynamic programming. \n\nThe runtime of the dynamic program depends on the number of potential prize assignments, which includes all of the nice numbers between $E$ and $B$. Since many reasonable definitions for nice numbers (including our Definition \\ref{def:nice_numbers}) choose these numbers to spread out exponentially as they increase, with the effect that the number of nice numbers below a fixed value $x$ is proportional to $\\log(x)$, we assume that this value is bounded by $O(\\log B)$.\n\n\\begin{theorem}[Dynamic Programming Solution]\n\\label{thm:dynamic}\nAssuming that there are $O(\\log B)$ nice numbers in the range $[E,B]$, then Problem \\ref{main_problem} can be solved in pseudo-polynomial time $O(rN^3B\\log^2B)$.\n\\end{theorem}\nA formal description of the dynamic program and short proof of its correctness are included in Appendix \\ref{app:dyno_proof}.\nUnfortunately, despite a reasonable theoretical runtime, the dynamic program requires $O(rN^2 B \\log B)$ space, which quickly renders the solution infeasible in practice.\n\n\\section{Integer Linear Program}\n\\label{sec:offtheshelf}\n\n\\begin{figure*}[h]\n\\begin{mymathbox}\n\\begin{problem}[Payout Structure Integer Program]\\label{integer_program}\nFor a given set of ideal payouts $\\{\\pi_1, \\ldots, \\pi_N\\}$, a total prize pool of $B$, a given set of acceptable prize payouts $\\{p_1 > p_2 > \\ldots > p_m\\}$, and an allowed budget of $r$ buckets solve:\n\\begin{eqnarray*}\n\\min \\sum_{i\\in[N],j\\in[r],k\\in[m]} x_{i,j,k}\\cdot (\\pi_i - p_k)^2&\\text{subject to:}&\\\\\n\\textbf{\\small{Problem constraints:}}\\\\\n\n\\sum_{k\\in[m]} (k+1/2)\\cdot\\tilde{x}_{j,k}  - k\\cdot\\tilde{x}_{j+1,k} \\leq 0,&j\\in[r-1], &\\text{(Monotonicity Requirements)}\\\\\n\n\\sum_{i\\in[N],j\\in[r],k\\in[m]} x_{i,j,k} \\cdot p_k=B,&& \\text{(Prize Pool Requirement)}\\\\\n\\sum_{i\\in[N], k\\in[m]} x_{i,j,k}  - x_{i,j+1,k} \\leq 0,&j\\in[r-1],&\\text{(Monotonic Bucket Sizes)}\\\\\n\\textbf{\\small{Consistency constraints:}}\\\\\n\\sum_{j\\in[r],k\\in[m]} x_{i,j,k} = 1,&i\\in[N],&\\text{(One Bucket Per Winner)}\\\\\n\\sum_{k\\in[m]} \\tilde{x}_{j,k} \\leq 1,&j\\in[r],&\\text{(One Prize Per Bucket)}\\\\\n&i\\in[N],&\\\\\n\\tilde{x}_{j,k}  - x_{i,j,k} \\geq 0,&j\\in[r], &\\text{(Prize Consistency)}\\\\\n& k\\in[m],&\\\\\n\\end{eqnarray*}\n\\end{problem}\n\\end{mymathbox}\n\\end{figure*}\nAlternatively, despite its complexity, we show that   it is possible to formulate Problem \\ref{main_problem} as a standard integer linear program. Since integer programming is computationally hard in general, this does not immediately yield an efficient algorithm for the problem. However, it does allow for the application of off-the-shelf optimization packages to the payout structure problem. \n\n\nTo keep the formulation as general as possible, assume that we are given a fixed set of acceptable prize payouts, $\\{p_1 > p_2 > \\ldots > p_m\\}$ (where typically $m > r$). These payouts may be generated, for example, using Definition \\ref{def:nice_numbers} for nice numbers. In our implementation, the highest acceptable prize is set to $p_1 = P_1$, where $P_1$ is the pre-specified winning prize. Additionally, to enforce the minimum payout requirement, we chose $p_m \\geq E$. Our integer program, formalized as Problem \\ref{integer_program}, involves the following variables:\n\\begin{itemize}\n\\item $N\\times r \\times m$ \\emph{binary} ``contestant variables'' $x_{i,j,k}$. In our final solution, $x_{i,j,k} = 1$ if and only if contestant $i$ is placed in prize bucket $S_j$ and receives payout $p_k$.\n\\item $r\\times m$ \\emph{binary} ``auxiliary variables'' $\\tilde{x}_{j,k}$.\n$\\tilde{x}_{j,k} = 1$ if and only if bucket $S_j$ is assigned payout $p_k$. Constraints ensure that $x_{i,j,k}$ only equals $1$ when $\\tilde{x}_{j,k} = 1$. If, for a particular $j$, $\\tilde{x}_{j,k} = 0$ for all $k$ then  $S_j$ is not assigned a payout, meaning that the bucket is not used. \n\\end{itemize}\n\n\nIt is easy to extract a payout structure from any solution to the integer program. Proving that the structure conforms to the constraints of Problem \\ref{main_problem} is a bit more involved. The proof appears in Appendix \\ref{app:ip_proof} under the following theorem:\n\n\\begin{theorem}[Integer Programming Solution]\n\\label{thm:integer}\nAny solution satisfying the constraints of integer programming Problem \\ref{integer_program} gives a solution to Problem \\ref{main_problem}.\n\\end{theorem} \n\n\\section{Heuristic Algorithm}\n\\label{sec:heuristic}\nNext we describe a heuristic algorithm for Problem \\ref{main_problem} that is used in production at Yahoo. The algorithm is less rigorous than our integer program and can potentially generate payout structures that violate constraints. However, it scales much better than the IP and experimentally produces stellar payouts. The heuristic  proceeds in four stages.\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 1: Initialize Bucket Sizes}}}\n\\smallskip\n\n\\noindent First the algorithm chooses tentative bucket sizes $|S_1|\\le |S_2|\\le \\ldots\\le |S_r|$. We set $|S_1|=|S_2|=|S_3|=|S_4|=1$. The choice to use 4 ``singleton buckets'', is flexible: while it is our default, the algorithm is easily modified to accommodate more. If $N-\\sum_{i=1}^4|S_i|=1$, we define $|S_5|=1$ and stop. Otherwise we set $|S_t|=\\lceil \\beta\\cdot |S_{t-1}|\\rceil $ where $\\beta\\ge 1$ is a parameter of the heuristic algorithm.  \nThe algorithm stops when $\\lceil\\beta^2 |S_t| \\rceil + \\lceil \\beta |S_t| \\rceil +\\sum_{i=1}^t|S_i|>N$ and $\\lceil \\beta |S_t| \\rceil+\\sum_{i=1}^t|S_i|\\le N$. We define \n\n", "index": 7, "text": "$$|S_{t+1}|=\\left \\lfloor \\frac{N-\\sum_{i=1}^t|S_i|}{2}\\right\\rfloor,\\ \n|S_{t+2}|=\\left \\lceil \\frac{N-\\sum_{i=1}^t |S_i|}{2}\\right\\rceil.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"|S_{t+1}|=\\left\\lfloor\\frac{N-\\sum_{i=1}^{t}|S_{i}|}{2}\\right\\rfloor,\\ |S_{t+2%&#10;}|=\\left\\lceil\\frac{N-\\sum_{i=1}^{t}|S_{i}|}{2}\\right\\rceil.\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mo>\u230a</mo><mfrac><mrow><mi>N</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></msubsup><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mn>2</mn></mfrac><mo>\u230b</mo></mrow></mrow><mo rspace=\"7.5pt\">,</mo><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mo>\u2308</mo><mfrac><mrow><mi>N</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></msubsup><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mn>2</mn></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": "\nWhen the prizes are switched, the cost is:\n\n", "itemtype": "equation", "pos": 59042, "prevtext": "\nAn initial value for $\\beta$ can be determined by solving the equation $\\beta + \\beta^2 + \\ldots +  \\beta^{r-4} = N - 4$ using the exact same binary search procedure described in Section \\ref{sec:initial_structure} for finding the parameter of our idea power law payout curve. If the number of buckets returned by the heuristic using the initial $\\beta$ is larger than $r$, we increase $\\beta$ and iterate. \n\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 2: Initialize Prizes}}}\n\\smallskip\n\n\\noindent Next, beginning with the first bucket, we round the first tentative prize, $\\pi_1$, down to the nearest nice number. The difference between $\\pi_1$ and the rounded nice number is called the {\\it leftover}, which we denote by $L$.\nIteratively, for each bucket $S_2, \\ldots, S_t$ we add all the tentative prizes in the bucket together and the leftover from the previous buckets. Let $R_t$ be this number. We define $\\Pi_t$ to equal $R_t/|S_t|$ rounded down to the nearest nice number. If the computed prize for bucket $t$ is greater than or equal to the prize in bucket $t-1$, $\\Pi_{t-1}$, we simply merge all member of $S_t$ into $S_{t-1}$, assigning them prize $\\Pi_{t-1}$.\nAt the end we may have some non-zero leftover $L$ remaining from the last bucket.\n\n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 3: Post-Process Non-monotonic Bucket Sizes}}}\n\\smallskip\n\n\\noindent Although the initial buckets from Step 1 increase in size, potential bucket merging in Step 2 could lead to violations in the Monotonic Bucket Size constraint. \nTo correct this issue, whenever $|S_t|$ is larger than $|S_{t+1}|$, we shift users to bucket $t+1$ until the situation is corrected. As a result we decrease the prizes for some users and increase the leftover $L$ by the corresponding amount. We repeat this process starting from $S_1$ and ending at our lowest prize level bucket.\n \n\\smallskip\n\\noindent  \\textsf{\\small{\\textbf{Stage 4: Spend Leftover Funds}}}\n\\smallskip\n\n\\noindent Finally, we modify our payouts to spend the leftover $L$.  We first spend as much as possible on ranks 2 through 4, which are contained in singleton buckets. We avoid modifying first prize because it is often given as a hard requirement -- e.g. we want pay exactly \\$1 million to the winner. In order from $i=2$ to $4$ we adjust $\\Pi_i$ to equal $\\min\\{\\Pi_i+L,(\\Pi_{i-1}+\\Pi_i)/2\\}$, rounded down to a nice number. This spends as much of $L$ as possible, while avoiding too large an increase in each prize. \n\nIf $L$ remains non-zero, we first try to adjust only the final (largest) bucket, $S_k$.\nIf $L\\ge |S_k|$ then we set $\\Pi_k=\\Pi_k+1$ and $L=L-|S_k|$, i.e. we increase the prize for every user in $S_k$ by $1$. Note that this could lead to nice number violations, which are not corrected. We repeat this process (possibly merging buckets) until $L<|S_k|$. If at this point $L$ is divisible by $\\Pi_k$ we increase $|S_k|$ by $L/\\Pi_k$ (thereby increasing the number of users winning nonzero prizes beyond $N$). \n\nIf $L$ is not divisible by $\\Pi_k$, we rollback our changes to the last bucket and attempt to spend $L$ on the last \\emph{two} buckets. Compute the amount of money available, which is the sum of all prizes in these buckets plus $L$. Fix the last bucket prize to be the minimal possible amount, $E$. Enumerate over possible sizes and integer prize amounts  for the penultimate bucket, again ignoring nice number constraints. If the last bucket can be made to have integer size (with payout $E$), store the potential solution and evaluate a ``constraint cost'' to penalize how much it violates constraints. The constraint cost charges $100$ for each unit of difference if the number of winners is less than $N$, $1$ for each unit of difference if the number of winners is larger than $N$, and $10$ for each unit of violation in bucket size monotonicity. Out of all solutions generated return the one with minimal constraint cost.\n\n\\section{Experiments}\n\\label{sec:experiments}\n\nWe conclude with experiments that confirm the effectiveness of both the integer program (Section \\ref{sec:offtheshelf}) and our heuristic (Section \\ref{sec:heuristic}). Both algorithms were implemented in Java and tested on a commodity laptop with a 2.6 GHz Intel Core i7 processor and 16 GB of 1600 MHz DDR3 memory.\n\nFor the integer program, we employ the off-the-shelf, open source GNU Linear Programming Kit (GLPK), accessed through the SCPSolver frontend \\cite{GLPK,scpsolver}. The package uses a branch-and-cut algorithm for IPs with a simplex method for underlying linear program relaxations.\n\nWe construct experimental payout structures for a variety of daily fantasy tournaments from Yahoo, FanDuel, and DraftKings and test on non-fantasy tournaments as well. \n\nFor non-Yahoo contests, $P_1$ is set to the published winning prize or, when necessary, to a nearby nice number. The maximum number of buckets $r$ is set to match the number of buckets used in the published payout structure, although we cap the value at $30$ for most contests and $40$ for extremely large contests ($>50,000$ winners). For fantasy sports, $E$ is set to the nearest nice number above $1.5$ times the entry fee. For all other contests  (which often lack entry fees or have a complex qualification structure) $E$ is set to the nearest nice number above the published minimum prize.\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Quantitative Comparison.}}}\nOur results can be evaluated by computing the Euclidean distance between our ideal pay out curve, $\\{\\pi_1, \\ldots, \\pi_n\\}$, and the bucketed curve $\\{\\Pi_1, \\ldots \\Pi_m\\}$. In heuristic solutions, if $m$ does not equal $n$, we extend the curves with zeros to compute the distance (which penalizes extra or missing winners as much as possible). Our experimental data is included in Table \\ref{tab:main_table}. Entries of ``--'' indicate that the integer program did not run to completion, possibly because no solution to Problem \\ref{integer_program} exists. The cost presented is the sum of squared distances from the bucketed payouts to ideal power law payouts, as defined in Problem \\ref{main_problem}. Note that we do not provide a cost for the \\emph{source} payout structure since, besides the Yahoo contests, these structures were not designed to fit our proposed ideal payout curve and thus cannot be expected to achieve small objective function values.\n\n\\begin{table*}[h]\n\\tbl{Accuracy and Runtime (in milliseconds) for Integer Program (IP) vs. Heuristic (Heur.) Solutions\\label{tab:main_table}}{\n\\tiny\n\n\\centering \n\\begin{tabular}{||c|c|c|c|c|c||c|c||c|c|c||} \n\\hhline{|t:======:t:==:t:===:t|}\nSource&\\specialcell{Prize Pool} & \\specialcell{Top Prize} & \\specialcell{Min. Prize} &\\specialcell{\\# of\\\\ Winners} & \\specialcell{\\# of\\\\ Buckets}& \\specialcell{IP \\\\ Cost} & \\specialcell{IP Time \\\\(ms)} & \\specialcell{Heur. \\\\Cost} & \\specialcell{Heur. Time \\\\(ms)} & \\specialcell{Heur. \\\\ Extra Winners} \\\\\n\\hhline{||-|-|-|-|-|-||-|-||---||}\nYahoo & 90 & 25 & 2& 30 & 7& .89 &7.6k &2.35 & 1 & 0 \\\\ \nYahoo & 180 & 55 & 3& 30 & 10& 2.82 &725k &3.44 & 1 & 0\\\\ \nDraftKings & 500 & 100 & 8& 20 & 10& 6.15 &2.1k &9.21 & 1 &0 \\\\ \nYahoo & 2250 & 650 & 150& 7 & 7& 32.4 &4.0k &187.4 & 1 &0 \\\\\nYahoo & 3000 & 300 & 2& 850 & 25& -- &-- &86.9 & 7 & 2 \\\\ \nFanDuel & 4000 & 900 & 50& 40 & 12& 20.7 &3716k &58.2 & 2 &1 \\\\ \nFanDuel & 4000 & 800 & 75& 16 & 7& 46.6 &2.9k &230.1 & 1 &4 \\\\ \nDraftKings & 5000 & 1250 & 150& 11 & 8& 52.5 &6.8k &123.5 & 1 &0 \\\\ \nYahoo & 10000 & 1000 & 7& 550 & 25& -- &-- &97.3 & 8 &1 \\\\ \nDraftKings & 10000 & 1500 & 75& 42 & 12& 61.3 &1291k &173.7 & 2 &0 \\\\ \nFanDuel & 18000 & 4000 & 150& 38 & 10& 161.8 &131k &347.0 & 5 &0 \\\\ \nFanDuel & 100000 & 10000 & 2& 23000 & 25& -- &-- &3.1k & 152 &34 \\\\ \nBassmaster & 190700 & 50000 & 2000& 40 & 15& -- &-- & 3.5k\\textsuperscript{*} & 3 &0 \\\\ \nBassmaster & 190000\\textsuperscript{$\\dagger$}\\ & 50000 & 2000& 40 & 15& 2.5k &3462k & 2.8k & 1 &0 \\\\ \nFLW Fishing & 751588 & 100000 & 9000& 60 & 25& -- &-- & 6.0k\\textsuperscript{*} & 3 &0 \\\\ \nFLW Fishing & 751500\\textsuperscript{$\\dagger$}\\ & 100000 & 9000& 60 & 25& -- &-- & 6.0k & 2 &0 \\\\ \nFanDuel & 1000000 & 100000 & 15& 16000 & 25& -- &-- &5.3k & 203 &7 \\\\ \nDraftKings & 1000000 & 100000 & 5& 85000 & 40& -- &-- & 25.9k & 1.2k &0 \\\\ \nBassmaster & 1031500 & 30000 & 10000& 55 & 25& -- &-- & 13.5k\\textsuperscript{*} & 14 &0 \\\\ \nFanDuel & 5000000 & 1000000 & 40& 46000 & 30& -- &-- &44.3k & 1.0k &0 \\\\ \nPGA Golf & 9715981 & 1800000 & 20000& 69 & 69& -- &-- & 254.5k\\textsuperscript{*} & 24 &0 \\\\ \nPGA Golf & 1000000\\textsuperscript{$\\dagger$}\\ & 1800000 & 20000& 75 & 75& -- &-- & 215.9k\\textsuperscript{**} & 23 &9 \\\\ \nDraftKings & 10000000 & 2000000 & 25& 125000 & 40& -- &-- & 78.7k & 1.7k &0 \\\\ \nPoker Stars& 10393400 & 1750000 & 15000& 160 & 25& -- &-- & 133.0k\\textsuperscript{*} & 27 &0 \\\\ \nWSOP & 60348000 & 8000000 & 15000& 1000 & 30& -- &-- & 462.3k\\textsuperscript{*} & 17 &0 \\\\ \n\\hhline{|b:======:b:==:b:===:b|}\n\\multicolumn{11}{l}{{\\rule{0pt}{5.4ex}}\\specialcellleft{\\textsuperscript{$\\dagger$}\\footnotesize{Contest is identical to the contest in the preceding row, but with the prize pool rounded to a nearby} \\\\ \\footnotesize{number in an effort to force a solution involving only nice numbers to exist.}}}\\\\\n\\multicolumn{11}{l}{{\\rule{0pt}{2.9ex}}\\textsuperscript{*}\\footnotesize{Heuristic produced solution with (unavoidable) nice number constraint violation for a single bucket.}}\\\\\n\\multicolumn{11}{l}{{\\rule{0pt}{2.9ex}}\\textsuperscript{**}\\footnotesize{Heuristic produced solution with (avoidable) nice number constraint violation for a single bucket.}}\\\\\n\\end{tabular}}\n\\end{table*}\n\nAs expected, when it succeeds in finding a solution, the integer program consistently outperforms the heuristic. However, the difference is rarely large, with heuristic cost typically below 5x that of the IP. Furthermore, the heuristic runs in less than 1.5 seconds for even the most challenging contests. The heuristic's ability to generate payout structures when no solution to Problem 4.1 exists is also a substantial advantage: it always returns a solution, but potentially with a slightly different number of winners paid or with a single constraint violation in the last two buckets (either a non-nice number payout or more winners in the penultimate bucket than in the final bucket).\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Constraint Violations.}}}\nIn our experiments, our heuristic actually only produced nice number violations, with no bucket size monotonicity violations for any experiment. Note that 6 of the 7 nice number violations are unavoidable given the input minimum prize and prize pool. For example, consider the Fishing League Worldwide (FLW) fishing tournament with a prize pool of \\$751,588 and a minimum prize of \\$9,000. Since all nice numbers greater than or equal to \\$9000 are multiples of \\$5000, it is impossible to construct a fully satisfiable set of payouts summing to \\$751,588. In all cases besides one (the PGA tournament with prize pool \\$9,715,981) simply rounding the prize pool to a nearby number produced an input for which the heuristic output a solution with no constraint violations. However, in settings where the prize pool \\emph{must} be a non-nice number (i.e., cannot be rounded up or down to a nice number, for whatever reason), our heuristic's flexibility is an advantage over the more rigid integer program.\n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{fanduel2.eps} \n\\caption{FanDuel, Baseball}\n\\end{subfigure}\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{fanduel1.eps}\n\\caption{FanDuel, Baseball}\n\\label{subfig:fduel2}\n\\end{subfigure}\n\\begin{subfigure}{0.33\\textwidth}\n\\centering\n\\includegraphics[width=1\\textwidth]{draftkings1.eps}\n\\caption{DraftKings, Baseball}\n\\label{subfig:dkings1}\n\\end{subfigure}\n\\caption{Payout Structures for Small Daily Fantasy Contests}\n\\label{fig:small_contests}\n\\end{figure*}\n\n\\medskip\n\\noindent  \\textsf{\\small{\\textbf{Qualitative Comparison.}}}\nBeyond quantitative measures to compare algorithms for Problem \\ref{main_problem}, evaluating our two stage framework as a whole requires a more qualitative approach. Accordingly, we include plots comparing our generated payout structures to existing published structures. \n\nFor small fantasy sports contests (Figure \\ref{fig:small_contests}) both of our algorithms match payouts from FanDuel and DraftKings extremely well, often overlapping for large sections of the discretized payout curve. To our knowledge, FanDuel and DraftKings have not publicly discussed their methods for computing payouts; their methods may involve considerable manual intervention, so matching these structures algorithmically is encouraging.\nIn some cases, notably in Figures \\ref{subfig:dkings1} and \\ref{subfig:fduel2}, our payout curve is ``flatter'', meaning there is a smaller separation between the top prizes and lower prizes. Many poker and daily fantasy sports players prefer flatter structures due to reduced payout variance \\cite{roto1,roto2}. \n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{fanduelLarge1.eps} \n\\caption{FanDuel, Football}\n\\label{fig:large_contests_fd}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{DraftKingsLarge1.eps}\n\\caption{DraftKings, Football}\n\\label{fig:large_contests_dk}\n\\end{subfigure}\n\\caption{Payout Structures for Large Daily Fantasy Contests}\n\\label{fig:large_contests}\n\\end{figure*}\n\nWe compare larger fantasy contest payouts in Figure \\ref{fig:large_contests}, plotting the $x$ axis on a log scale due to a huge number of winning places (16,000 and 125,000 for  \\ref{fig:large_contests_fd} and  \\ref{fig:large_contests_dk} respectively).\nAgain our results are very similar to those of FanDuel and DraftKings, with our methods producing only slightly flatter payouts.\n\n\nWe also show that both of our algorithms can easily construct high quality payout structures for non-fantasy sports tournaments, avoiding the difficulties discussed in Section \\ref{sec:prior_work}. Returning to the Bassmaster example from Figure \\ref{fig:bmaster_failure}, we show more satisfying structures generated by our IP and heuristic algorithm in Figure \\ref{fig:bmaster_fixed}. For the IP, we rounded the prize pool to \\$190,000 from \\$190,700 to ensure a solution to Problem \\ref{integer_program} exists. However, even for the original prize pool, our heuristic solution has just one non-nice number payout of \\$2,700 and no other constraint violations. Both solutions visibly avoid the issue of non-monotonic bucket sizes exhibited by the published Bassmaster payout structure.\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=.8\\textwidth]{bassmaster_fixed.eps}\n\\caption{Alternative Bassmaster Open 2015 Payouts}\n\\label{fig:bmaster_fixed}\n\\end{figure}\n\nWe conclude with an example from the popular World Series of Poker. The 2015 Main Event payed out \\$60,348,000 to 1000 winners in  31 buckets with far from ``nice number'' prizes \\cite{wsop_events}.\n\n\n\n\nHowever, several months prior to the WSOP tournament, the organizers published a very different \\emph{tentative} payout structure \\cite{pokerPayoutsFailure}, that appears to have attempted to satisfy many of the constraints of Problem \\ref{main_problem}: it uses mostly nice number prizes and nearly satisfies our bucket size monotonicity constraint (see Figure \\ref{fig:wsop_tent}). \n\nThis tentative payout structure suggests that WSOP organizers originally sought a better solution than the payout structure actually used. Perhaps the effort was abandoned due to time constraints: the World Series of Poker prize pool is not finalized until just before the event (it depends on the total number of entries).\n\n\\begin{figure*}[h]\n\\centering\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{wsop_2015_tentative2.eps} \n\\caption{WSOP 2015 Tentative Prizes}\n\\label{fig:wsop_tent}\n\\end{subfigure}\n\\hfill\n\\begin{subfigure}{0.48\\textwidth}\n\\centering\n\\includegraphics[width=\\textwidth]{wsop_fix.eps}\n\\caption{Generated ``Nice'' Payout Structure}\n\\label{fig:wsop_fix}\n\\end{subfigure}\n\\caption{Payout Structure Generation for WSOP 2015 Main Event }\n\\label{fig:wsop}\n\\end{figure*}\n\n We show in Table \\ref{tab:wsop} that our heuristic can rapidly (in 17 milliseconds) generate an aesthetically pleasing payout structure for the final prize pool with the initially planned top prize of \\$8 million, and just one minor nice number violation (our final bucket pays \\$20,150). Our output and the actual WSOP payout structure are also compared visually in Figure \\ref{fig:wsop_fix} to the power curve used in the first stage of our algorithm. In keeping with the WSOP tradition of paying out separate prizes to places 1-9 (the players who make it to the famous ``November Nine'' final table) we run our heuristic with 9 guaranteed singleton buckets instead of 4 (see Section \\ref{sec:heuristic} for details).\n\n\\begin{table}[h]\n\\tbl{An alternative ``nice number'' payout structure  for the World Series of Poker 2015 Main Event.\\label{tab:wsop}}{\n\\scriptsize\n\\centering \n\\begin{tabular}{||c|c||c|c||} \n\\hhline{|t:==:t:==:t|}\n\\multicolumn{2}{||c||}{\\specialcell{2015 WSOP \\\\Payouts}} & \\multicolumn{2}{|c||}{\\specialcell{Our Alternative \\\\Payouts}} \\\\\n\\hline\nPlace & Prize & Place & Prize \\\\\n\\hline\n1 & \\$7,680,021 & 1& \\$8,000,000 \\\\\n2 & \\$4,469,171 & 2& \\$4,000,000 \\\\\n3 & \\$3,397,103 & 3& \\$2,250,000 \\\\\n4 & \\$2,614,558  & 4& \\$1,750,000 \\\\\n5 & \\$1,910,971 & 5& \\$1,250,000 \\\\\n6 & \\$1,426,072 & 6& \\$1,000,000\\\\\n7 & \\$1,203,193 & 7 & \\$950,000 \\\\\n8 & \\$1,097,009 & 8& \\$850,000 \\\\\n9 & \\$1,001,020 & 9& \\$700,000\\\\\n10 & \\$756,897 & \\multirow{2}{*}{10 - 13}& \\multirow{2}{*}{\\$650,000} \\\\\n11 - 12& \\$526,778 & & \\\\\n13 - 15& \\$411,453 & \\multirow{2}{*}{14 - 17}& \\multirow{2}{*}{\\$500,000} \\\\\n16 - 18& \\$325,034 & & \\\\\n\\multirow{2}{*}{19 - 27}& \\multirow{2}{*}{\\$262,574} & 18 - 23& \\$300,000 \\\\\n& & 24 - 29& \\$225,000  \\\\\n28 - 36& \\$211,821 & 30 - 35& \\$200,000  \\\\\n36 - 45& \\$164,086 &  36 - 42& \\$150,000 \\\\\n46 - 54& \\$137,300 & 43 - 59& \\$125,000\\\\\n55 - 63& \\$113,764  & \\multirow{3}{*}{60 - 77}& \\$95,000 \\\\\n64 - 72& \\$96,445& &  \\\\\n73 - 81& \\$79,668 & & \\\\\n82 - 90& \\$68,624 & \\multirow{2}{*}{78 - 99}& \\multirow{2}{*}{\\$75,000} \\\\\n91 - 99& \\$55,649& & \\\\\n\\multirow{2}{*}{100 - 162}& \\multirow{2}{*}{\\$46,890} & 100 - 128& \\$60,000 \\\\\n & & 128 - 164& \\$55,000 \\\\\n163 - 225& \\$40,433 & 165 - 254& \\$45,000 \\\\\n226 - 288& \\$34,157 & \\multirow{2}{*}{255 - 345}& \\multirow{2}{*}{\\$35,000} \\\\\n289 - 351& \\$29,329 & &  \\\\\n352 - 414& \\$24,622 & \\multirow{2}{*}{346 - 441}& \\multirow{2}{*}{\\$25,000} \\\\\n415 - 477& \\$21,786 & &\\\\\n478 - 549&  \\$19,500 &\\multirow{2}{*}{442 - 710} & \\multirow{2}{*}{\\$22,500} \\\\\n550 - 648& \\$17,282 & & \\\\\n649 - 1000& \\$15,000 & 711 - 1000& \\$20,150 \\\\\n\\hhline{|b:==:b:==:b|}\n\\end{tabular}\n}\n\\end{table}\n\n\\bibliography{EC_PayoutsPaper}{}\n\\bibliographystyle{ACM-Reference-Format-Journals}\n\n\\appendix\n\\section{Dynamic Programming Details}\n\\label{app:dyno_proof}\n\\begin{reptheorem}{thm:dynamic}[Dynamic Programming Solution]\nAssuming that there are $O(\\log B)$ nice numbers in the range $[E,B]$, then Problem \\ref{main_problem} can be solved in pseudo-polynomial time $O(rN^3B\\log^2B)$.\n\\end{reptheorem}\n\\begin{proof}\nWe can construct a dynamic program that chooses buckets and prizes in order from the lowest awarded places to the winner: $(S_r, \\Pi_r), (S_{r-1}, \\Pi_{r-1}),\\ldots (S_{1}, \\Pi_{1})$.\nSuppose you have already selected $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$. Since our objective function can be separated as\n$\\sum_{j=1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2 = \\sum_{j=1}^i \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2 +  \\sum_{j=i+1}^r \\sum_{i\\in S_j}(\\pi_i-\\Pi_{j})^2$, \nthe task of choosing the optimal $(S_{i}, \\Pi_{i}), \\ldots, (S_{1}, \\Pi_{1})$ then reduces to solving a smaller instance of Problem \\ref{main_problem}, with:\n\\begin{enumerate}\n\\item $N$ = the number of winners remaining, i.e. those not placed in $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$.\n\\item $B$ = the prize budget remaining, i.e. whatever was not consumed by $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$.\n\\item $E$ = the smallest nice number greater than maximum prize given so far, $\\Pi_{i+1}$.\n\\item An additional constraint on maximum bucket size, which must be less than $|S_{i+1}|$.\n\\end{enumerate}\nThus, for a given tuple of (winners consumed, budget consumed, $\\Pi_{i+1}$, $|S_{i+1}|$), our choice for $(S_{i}, \\Pi_{i}), \\ldots, (S_{1}, \\Pi_{1})$ can ignore any other aspects of $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$. Accordingly, it suffices to store the optimal assignment to $(S_r, \\Pi_r), \\ldots,\\allowbreak (S_{i+1}, \\Pi_{i+1})$ for each such 4-tuple. There are at worst $N\\times B\\times O(\\log B) \\times N = O(N^2 B \\log B)$ tuples. \n\nNow, given all assignments for $(S_r, \\Pi_r), \\ldots, (S_{i+1}, \\Pi_{i+1})$ that are optimal for some tuple, one simple way to generate the set of optimal assignments for $(S_r, \\Pi_r), \\ldots, (S_{i}, \\Pi_{i})$ is to try adding every possible $(S_{i}, \\Pi_{i})$ (there are $\\leq N\\log B$ of them) to each optimal assignment. For each new assignment generated, we check if it has lower cost than the current best assignment to $(S_r, \\Pi_r), \\ldots, (S_{i}, \\Pi_{i})$ for the tuple induced by the choice of $(S_{i}, \\Pi_{i})$ (or just store it if no other assignment has induced the tuple before). In total this update procedure takes time $O(N\\log B) \\times O(N^2 B \\log B)$ time. It must be repeated $r$ times, once for each bucket added. Our total runtime is thus $O(rN^3B\\log^2 B)$.\n\\end{proof}\nThe dynamic program solution requires $O(r N^2 B \\log B)$ space to store the optimal assignment for each tuple at the current iteration.\n\n\\section{Integer Programming Details}\n\\label{app:ip_proof}\n\\begin{reptheorem}{thm:integer}[Integer Programming Solution]\nAny solution satisfying the constraints of integer programming Problem \\ref{integer_program} gives a solution to Problem \\ref{main_problem}.\n\\end{reptheorem}\n\n\\begin{proof}\nGiven a solution to Problem \\ref{integer_program}, a solution to Problem \\ref{main_problem} is obtained by first checking each auxiliary variable. If $\\tilde{x}_{j,k} = 1$, then $\\Pi_j$ is set to $p_k$. The second consistency constraint ensures that for a given $j$, $\\tilde{x}_{j,k}$ can equal 1 for at most one value of $k$. Thus, each $\\Pi_j$ is assigned at most once. If no $\\tilde{x}_{j,k}$ is equal to 1 for a given $j$, then $\\Pi_j$ and accordingly $S_j$, remain unused in our solution.\n\nThe winners for bucket $S_j$ are simply all values of $i$ for which $x_{i,j,k}$ is equal to 1. Our first consistency constraint ensures that for a given $i$, $x_{i,j,k}$ is 1 exactly once, meaning that each winner is assigned to a single bucket. The third consistency constraint ensures that $x_{i,j,k} = 1$ only when $\\tilde{x}_{j,k} = 1$, which ensures that each winner in bucket $S_j$ is assigned the correct payout, $\\Pi_j = p_k$. \n\nAccordingly, any solution to Problem \\ref{integer_program} produces a valid payout structure and we just need to prove that it conforms to the constraints of our original optimization problem.\n\n Recalling that, for a given $i$, $x_{i,j,k} = 1$ for exactly one pair $(j,k)$, it is straight forward to see that the objective function and prize pool constraint are equivalent those from Problem \\ref{main_problem} as long. The bucket size monotonicity constraint is also simple to verify: $\\sum_{i\\in[N], k\\in[m]} x_{i,j,k}$ is exactly equal to the number of winners assigned to bucket $j$, $|S_j|$. So our constraint correctly verifies that $|S_j| \\leq |S_{j+1}|$ for all $j$.\n\nFor the monotonicity requirement, notice that $\\sum_{k\\in[m]} (k+\\frac{1}{2})\\cdot\\tilde{x}_{j,k}$ simply equals $k + \\frac{1}{2}$ whenever $\\Pi_j = p_k$ in our solution. Similarly $\\sum_{k\\in[m]} k\\cdot\\tilde{x}_{j+1,k}$ equals $k$ when $\\Pi_{j+1} = p_k$. Since lower values of $k$ correspond to higher prize payouts (recall that $p_1 > p_2 > \\ldots p_k$), the first constraint in our integer program therefore ensures that $\\Pi_j$ is strictly greater than $\\Pi_{j+1}$. There are a number of ways to enforce the ``strictly'' requirement besides adding the $\\frac{1}{2}$ where we did. However, this particular approach gracefully allows the constraint to be satisfied when \\emph{no prize} is assigned to bucket $S_j$ (i.e. the bucket is not used in our solution. In that case $\\sum_{k\\in[m]} (k+\\frac{1}{2})\\cdot\\tilde{x}_{j,k}$ will equal zero since $\\tilde{x}_{j,k}$ will equal 0 for all $k$. We would run into an issue if say, bucket $S_j$ is not used but bucket $S_{j-1}$ is. Accordingly, any solution to Problem \\ref{integer_program} not using $r$ buckets must leave the lowest number sets empty, in accordance with the convention from Problem \\ref{main_problem}.\n\nFinally, note that we did not include any inequalities to ensure that each bucket contains a contiguous range of winners -- for examples winners 6 through 11 or 54 through 75. We can avoid this costly constraint because it is implicitly enforced by our choice of objective function and the monotonicity of ideal payouts. Suppose some bucket contains a non-contiguous set of winners. Then for at least two winning positions $i > j$ it must be that the prize given to winner $i$, $p_{low}$, is less than the prize given to winner $j$, $p_{high}$. At the same time, we know that for our ideal payouts, $\\pi_i \\geq \\pi_j$. We argue that such a configuration cannot exist in an optimal solution to Problem \\ref{integer_program} because switching the prizes so that $i$ receives $p_{high}$ and $j$ receives $p_{low}$ gives a strictly better solution.\n\nFirst off, clearly switching the prizes will not effect our other constraints: total payout amount and bucket sizes will remain unchanged. Now, our cost function is simply additive over each winner, and the cost incurred by players $i$ and $j$ in the non-contiguous ordering is:\n\n", "index": 9, "text": "\\begin{align*}\n(\\pi_i - p_{low})^2 + &(\\pi_j - p_{high})^2 = \\\\ &\\pi_i^2 - 2\\pi_ip_{low} + p_{low}^2 + \\pi_j^2 - 2\\pi_jp_{high} + p_{high}^2.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(\\pi_{i}-p_{low})^{2}+\" display=\"inline\"><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>-</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>+</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(\\pi_{j}-p_{high})^{2}=\" display=\"inline\"><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>-</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\pi_{i}^{2}-2\\pi_{i}p_{low}+p_{low}^{2}+\\pi_{j}^{2}-2\\pi_{j}p_{%&#10;high}+p_{high}^{2}.\" display=\"inline\"><mrow><mrow><mrow><mrow><mrow><msubsup><mi>\u03c0</mi><mi>i</mi><mn>2</mn></msubsup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow></mrow><mo>+</mo><msubsup><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>\u03c0</mi><mi>j</mi><mn>2</mn></msubsup></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow></mrow><mo>+</mo><msubsup><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow><mn>2</mn></msubsup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": "\nThe difference in cost after the switch is therefore equal to:\n\n", "itemtype": "equation", "pos": 59240, "prevtext": "\nWhen the prizes are switched, the cost is:\n\n", "index": 11, "text": "\\begin{align*}\n(\\pi_i - p_{high})^2 + &(\\pi_j - p_{low})^2 = \\\\&\\pi_i^2 - 2\\pi_ip_{high} + p_{high}^2 + \\pi_j^2 - 2\\pi_jp_{low} + p_{low}^2.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(\\pi_{i}-p_{high})^{2}+\" display=\"inline\"><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>-</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>+</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(\\pi_{j}-p_{low})^{2}=\" display=\"inline\"><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>-</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\pi_{i}^{2}-2\\pi_{i}p_{high}+p_{high}^{2}+\\pi_{j}^{2}-2\\pi_{j}p_{%&#10;low}+p_{low}^{2}.\" display=\"inline\"><mrow><mrow><mrow><mrow><mrow><msubsup><mi>\u03c0</mi><mi>i</mi><mn>2</mn></msubsup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow></mrow><mo>+</mo><msubsup><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>\u03c0</mi><mi>j</mi><mn>2</mn></msubsup></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow></mrow><mo>+</mo><msubsup><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow><mn>2</mn></msubsup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04203.tex", "nexttext": "\nThe last step follows from the fact that $(\\pi_i - \\pi_j) \\geq 0$ and $(p_{high} -p_{low}) > 0$. Since switching payouts reduces our cost, it follows that any solution without contiguous bucket members cannot be optimal. Note that, even with monotonic ideal payouts, this would not have been the case if we had used, for example, $\\ell_1$ cost $\\sum_{i\\in[N],j\\in[r],k\\in[m]} x_{i,j,k}\\cdot |\\pi_i - p_k|$.\n\nWith this last implicit constraint verified, we conclude the proof that Problem \\ref{integer_program} can be used to obtain a valid payout structure obeying all of the constraints of our original Problem \\ref{main_problem}.\n\\end{proof}\n\n\n", "itemtype": "equation", "pos": 59457, "prevtext": "\nThe difference in cost after the switch is therefore equal to:\n\n", "index": 13, "text": "\\begin{align*}\n- 2\\pi_ip_{high} - &2\\pi_jp_{low} - (- 2\\pi_ip_{low} - 2\\pi_jp_{high}) \\\\\n&= -2\\left(\\pi_ip_{high} -\\pi_ip_{low} + \\pi_jp_{low} -\\pi_jp_{high}\\right)\\\\\n&= -2(\\pi_i - \\pi_j)(p_{high} -p_{low}) \\leq 0.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle-2\\pi_{i}p_{high}-\" display=\"inline\"><mrow><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow></mrow><mo>-</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 2\\pi_{j}p_{low}-(-2\\pi_{i}p_{low}-2\\pi_{j}p_{high})\" display=\"inline\"><mrow><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow><mo>-</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-2\\left(\\pi_{i}p_{high}-\\pi_{i}p_{low}+\\pi_{j}p_{low}-\\pi_{j}p_{%&#10;high}\\right)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo>(</mo><mrow><mrow><mrow><mrow><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow><mo>-</mo><mrow><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow></mrow><mo>+</mo><mrow><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow></mrow><mo>-</mo><mrow><msub><mi>\u03c0</mi><mi>j</mi></msub><mo>\u2062</mo><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-2(\\pi_{i}-\\pi_{j})(p_{high}-p_{low})\\leq 0.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c0</mi><mi>i</mi></msub><mo>-</mo><msub><mi>\u03c0</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>p</mi><mrow><mi>h</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>h</mi></mrow></msub><mo>-</mo><msub><mi>p</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>w</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2264</mo><mn>0</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}]