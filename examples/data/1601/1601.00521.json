[{"file": "1601.00521.tex", "nexttext": "\nwhere $\\theta_{i_k}^k (q_k)   $    is a primitive basis function,\nwith\n\n", "itemtype": "equation", "pos": 2901, "prevtext": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\title{Using symmetry-adapted  optimized sum-of-products  basis functions to calculate vibrational spectra}\n\n\n\n\n\n\n\\author[metz]{Arnaud Leclerc}\n\\ead{Arnaud.Leclerc@univ-lorraine.fr}\n\n\\author[kingston]{Tucker Carrington \\corref{corres}}\n\\ead{Tucker.Carrington@queensu.ca}\n\n\n\\address[metz]{Universit\\'e de Lorraine, UMR CNRS 7565 SRSMC, \\\\ 1 boulevard Arago 57070 Metz, France}\n\n\\address[kingston]{Chemistry Department, Queen's University, Kingston, Ontario K7L 3N6, Canada}\n\n\\cortext[corres]{Corresponding author}\n\n\n\n\n\n\n\n\\begin{abstract}\n\n\n\nVibrational spectra can be computed without storing full-dimensional vectors by using low-rank sum-of-products (SOP) basis functions.  We introduce symmetry constraints in the SOP basis functions to make it possible to separately calculate  states  in different  symmetry subgroups.  This is done using a power method to compute eigenvalues and an alternating least squares method to optimize basis functions.  Owing to the fact that the power method favours the convergence of the lowest states, one must be careful   not to exclude basis functions of some symmetries.  Exploiting symmetry facilitates making assignments and improves the accuracy.   The method is applied to the acetonitrile  molecule.\n\n\n\n\n\\end{abstract}\n\n\n\\maketitle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Introduction}\n\n\n\n\nIt is difficult to calculate vibrational spectra of molecules with more than four atoms without making approximations.   The most systematic and general method \ninvolves computing eigenvalues and eigenvectors of a basis  representation of the corresponding Hamiltonian operator. \n\n   The Hamiltonian  matrix is often so large that it is \nbest to use iterative eigensolvers.  \n  A direct product (DP) basis is convenient because it \nfacilitates the evaluation of the  matrix-vector products required to use  an  iterative eigensolver\n\\cite{bramley1993}. \n\n   The basis functions are products of functions of a single\ncoordinate.  To use an iterative eigensolver, there is no  need to store a matrix, but it $is$ necessary to store a few vectors.    Because the size of the DP basis is\n $n^D$,  where $n$ is a representative  number of 1D basis functions for each coordinate and $D$ the number of coordinates, \neven storing vectors requires more memory than is available on most computers, if $D >$ 12 (i.e. 6 atoms).    \n\n\nThe size of the basis, and of the vectors, can be reduced by  optimizing 1-D basis functions \\cite{mctdhbook}, \nor by  forgoing the advantages of a DP basis and using instead contracted basis functions \\cite{carter1988} or by  \npruning a large DP  basis  \\cite{davis,avila2011_2}. \n\nAnother strategy is to use sum-of-products (SOP) basis functions which can be represented in a\n primitive DP basis as a tensor in what is called CP format \\cite{kolda2009}. \n The key idea is that a SOP basis function can be written,\n\n\n", "index": 1, "text": "\\begin{equation}    \nF(q_1, \\dots, q_D) \\simeq \\sum_{i_1=0}^{n_1-1} \\dots \\sum_{i_D=0}^{n_D-1} F_{i_1 i_2\\dots i_D}  \n\\prod_{k=1}^D \\theta_{i_k}^k (q_k),\n\\label{wavefunction}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"F(q_{1},\\dots,q_{D})\\simeq\\sum_{i_{1}=0}^{n_{1}-1}\\dots\\sum_{i_{D}=0}^{n_{D}-1%&#10;}F_{i_{1}i_{2}\\dots i_{D}}\\prod_{k=1}^{D}\\theta_{i_{k}}^{k}(q_{k}),\" display=\"block\"><mrow><mrow><mrow><mi>F</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>q</mi><mi>D</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2243</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi>i</mi><mi>D</mi></msub><mo>=</mo><mn>0</mn></mrow><mrow><msub><mi>n</mi><mi>D</mi></msub><mo>-</mo><mn>1</mn></mrow></munderover><mrow><msub><mi>F</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>i</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><msub><mi>i</mi><mi>D</mi></msub></mrow></msub><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><msubsup><mi>\u03b8</mi><msub><mi>i</mi><mi>k</mi></msub><mi>k</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\nStoring $F_{i_1 i_2 \\dots i_D}$ \nrequires only storing \none-dimensional vectors ${\\bf f}^{(\\ell,k)}$  \\cite{rrbpm2014,phillip}.\n\n\n\nThe SOP basis functions are not contracted in the usual sense;  they are also not selected from a DP basis.    \n\nAll the primitive DP basis functions can contribute to a  single SOP basis function. \nOne must choose SOP basis functions that \nspan a space which includes the wavefunctions of interest.\nThis is the main idea of the reduced rank block power method (RRBPM) introduced  in Ref. \\cite{rrbpm2014}. \n\nIts key advantage is that the memory cost of the method \nscales  as $\\mathcal{O}(nD)$.  This makes it possible to calculate \n energy levels and wavefunctions of molecules with 20 degrees of freedom \n with a few GB of memory. \n\n\n\n\nIn  Ref.  \\cite{rrbpm2014} symmetry is not used.   It is important to take advantage of symmetry for two reasons. \n (1)   Exploiting symmetry makes it possible to assign states one computes to \nirreducible representations of the symmetry group of the Hamiltonian operator\n\\cite{bunkerjensen,wilson1955}. \n(2) Exploiting symmetry makes it possible to \nreduce the CPU and memory cost of computing a spectrum.     In the RRBPM case, the CPU cost is reduced because the number of power iterations decreases when  computing levels \nof a single irrep since  the effective density of states decreases.     \n\n\n\nIn this letter we  introduce the basic ideas required to  exploit symmetry. \nIn section~\\ref{theorysec} we present the theoretical arguments and we explain how to construct efficient symmetry-constrained SOP basis functions. \nThe method is then applied to a realistic 12D Hamiltonian in section~\\ref{results}. \nWe show that   reflection in a $\\sigma_v$ plane  can be used to improve the calculation of vibrational levels of  acetonitrile, without  jeopardizing  the memory advantage of the RRBPM. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Theory \\label{theorysec}}\n\n\n\\subsection{Reduced-rank block power method (RRBPM) \\label{resrrbpm} }\n\n\n\n\nWe assume that the potential energy surface (PES) is known and is in SOP form.  We label the coordinates  $q_k$,\n $k=1\\dots D$.\nThere is a primitive basis,  $\\theta_{i_k}^k(q_k)$, $i_k=0,\\dots,n_k-1$, for each coordinate.  \nThe SOP basis functions are of the form of {Eq.\\,(\\ref{{wavefunction}})} with  $ F_{i_1 i_2\\dots i_D} $ as in {Eq.\\,(\\ref{{sop}})}.   \nThe memory cost is \n $RDn$.    Each  basis function can be written\n\n\n", "itemtype": "equation", "pos": 3162, "prevtext": "\nwhere $\\theta_{i_k}^k (q_k)   $    is a primitive basis function,\nwith\n\n", "index": 3, "text": "\\begin{equation}\nF_{i_1 i_2 \\dots i_D} \\simeq \\sum_{\\ell=1}^R  \\prod_{k=1}^D f^{(\\ell,k)}_{i_k} ~.\n\\label{sop}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"F_{i_{1}i_{2}\\dots i_{D}}\\simeq\\sum_{\\ell=1}^{R}\\prod_{k=1}^{D}f^{(\\ell,k)}_{i%&#10;_{k}}~{}.\" display=\"block\"><mrow><mrow><msub><mi>F</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>i</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><msub><mi>i</mi><mi>D</mi></msub></mrow></msub><mo>\u2243</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mpadded width=\"+3.3pt\"><msubsup><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mpadded></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\n\nThe SOP basis vectors, each of which has the form of {Eq.\\,(\\ref{{sop}})}, are made using a shifted  block power method.    This requires applying\n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ to each vector in a block.  \n\n$\\sigma $ depends on  the block size  and the largest eigenvalue of  ${\\bf{H}}$   \\cite{rrbpm2014}.\n\nCalculations are fast because only one-dimensional matrix-vector products are needed.\n\nEach application of    \n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ \nto a vector increases its rank by a factor of $(P+1)$, where $P$ is the number of terms in the Hamiltonian.\nIn the RRBPM, the rank of vectors is reduced, after each step that increases their rank,  by using  \nan       alternating least square method described in Ref. \\cite{beylkin2005}. \nTo reduce the rank of \n  ${\\bf F}^{\\text{old}}$   from     $R^{\\text{old}}$         to  $R^{\\text{new}}$,  the ALS  algorithm  uses an iterative process to find  vectors  \n $^{\\text{new}}f^{(\\ell,k)}_{i_k}$  to \n minimize    $ \\parallel {\\bf F}^{\\text{new}} - {\\bf F}^{\\text{old}} \\parallel $.       \nThis is done for each \n\n\n coordinate  successively. This gives rise to a succession of systems of $R^{\\text{new}}$   linear equations   to be solved with $n_k$ different right-hand-sides for each coordinate $q_k$.\n\n\nThe main steps in the algorithm are: \n\\begin{itemize}\n\\item Apply \n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ \n in parallel over a block of SOP vectors \n\\item Reduce the rank using alternating least squares.\n\\item Every 10 to 20 iterations, orthogonalize the vectors, make a matrix representing \n $\\hat{H}$  in this  SOP  basis set.\n\\item Diagonalize the matrix to obtain eigenvalues and eigenvectors .    \n\n\\item Reduce the rank, update the vectors and iterate.\n\\end{itemize}\n\n\n\nUnless special precautions are taken, an  SOP basis, generated as explained above,  cannot be ordered so that the corresponding Hamiltonian matrix is block diagonal. \nOur goal in this letter is to demonstrate that it is possible to make a symmetrized SOP basis and use it to obtain accurate energy levels.   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Symmetric and antisymmetric sum-of-products basis functions}\n\n\nThe most common way to take advantage of symmetry when computing a spectrum is to introduce symmetry-adapted basis functions in which the \nHamiltonian matrix is block-diagonal.   \nWhen using an iterative eigensolver this is often not the best approach.  The reason is that evaluating matrix-vector products\nwith a matrix obtained by representing the Hamiltonian operator in a symmetry-adapted basis may be costly.\n\nThe most straightforward approach when using an iterative eigensolver is to do different calculations for start vectors with different \nsymmetries \\cite{poulin1996,bramley1993}\n\nThis works because the Hamiltonian is invariant with respect to all symmetry operations and therefore \napplying the Hamiltonian to a vector does not change its symmetry. \nIn this letter  we use this \n idea  to make  symmetry-adapted    SOP basis functions from matrix-vector products.\n\n\n\n\n\nThe SOP basis functions we use transform like irreducible representations (irreps) of a sub-group of the full molecular symmetry group.    We shall explain \nthe ideas for a sub-group  $\\{ R, E \\}$, where $E$ is the identity operation.   We assume that all of the coordinates are symmetric   or \nantisymmetric, i.e.,\n\\begin{eqnarray}\n& q_k \\text{ symmetric   } :  & q_k \\overset{R}{\\rightarrow} q_k,  \\\\\n& q_k \\text{ antisymmetric  } : & q_k \\overset{R}{\\rightarrow} -q_k.\n\\end{eqnarray}\n\nThe primitive  1-D  basis functions are chosen so that some are even and some are odd.    \n\nWe use a harmonic primitive basis so \n\n\\begin{eqnarray}\n & \\theta_{i_k=even}^k(q_k) \\overset{q_k \\rightarrow -q_k}{\\longrightarrow} \\theta_{i_k=even}^k(q_k), \\\\\n & \\theta_{i_k=odd}^k(q_k) \\overset{q_k \\rightarrow -q_k}{\\longrightarrow} -\\theta_{i_k=odd}^k(q_k).\n\\end{eqnarray}\n\n\n\n\n\n\n\nThis means that some basis functions change sign (i.e. are symmetric)  and others do not (i.e. are antisymmetric)  when $R$ is applied.   \n\n\nAll   $ \\theta_{i_k}^k(q_k) $ of symmetric coordinates are symmetric. \n $ \\theta_{i_k=even}^k(q_k) $ of antisymmetric coordinates are symmetric. \n$ \\theta_{i_k=odd}^k(q_k) $ of antisymmetric coordinates are antisymmetric. \nWhen $R$ is applied to a primitive D-d basis function,  $\\prod_{k=1}^D \\theta_{i_k}^k (q_k) $, its sign changes if the number of factors for which $i_k$ is odd is \nitself odd, otherwise applying $R$ to   $\\prod_{k=1}^D \\theta_{i_k}^k (q_k) $ does not change the sign.   \nThe  D-d basis is therefore split into two parts, one symmetric and one antisymmetric. \n\n\n\n\n\n\nThroughout the discussion we  use  $e$ and $o$ to indicate even (symmetric) or odd (antisymmetric)  functions (coordinates).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnowing the symmetry properties of the primitive basis functions enables us to choose SOP start vectors that are symmetric  or antisymmetric.  \n\nThe symmetry depends  on which $\\theta_{i_k}^k(q_k)$   in      Eq. \\ref{Fexpansion} have nonzero  coefficients.  \nAn SOP vector is antisymmetric   (symmetric) if applying $R$ to the corresponding function changes (does not change) its sign.  \n\n  This makes it possible \nto separately compute even  and odd wavefunctions.   To illustrate the ideas,   consider an example with three coordinates of which \n $q_1$ and $q_2$ are antisymmetric  coordinates and $q_3$ is a symmetric coordinate.   \n\n\nIf  \nwe consider a single product function whose constituent   1-D  vectors\n(${\\bf f}^{(\\ell=1,k)}={\\bf f}^{(k)}$)\n  are \n\n\n", "itemtype": "equation", "pos": 5712, "prevtext": "\nStoring $F_{i_1 i_2 \\dots i_D}$ \nrequires only storing \none-dimensional vectors ${\\bf f}^{(\\ell,k)}$  \\cite{rrbpm2014,phillip}.\n\n\n\nThe SOP basis functions are not contracted in the usual sense;  they are also not selected from a DP basis.    \n\nAll the primitive DP basis functions can contribute to a  single SOP basis function. \nOne must choose SOP basis functions that \nspan a space which includes the wavefunctions of interest.\nThis is the main idea of the reduced rank block power method (RRBPM) introduced  in Ref. \\cite{rrbpm2014}. \n\nIts key advantage is that the memory cost of the method \nscales  as $\\mathcal{O}(nD)$.  This makes it possible to calculate \n energy levels and wavefunctions of molecules with 20 degrees of freedom \n with a few GB of memory. \n\n\n\n\nIn  Ref.  \\cite{rrbpm2014} symmetry is not used.   It is important to take advantage of symmetry for two reasons. \n (1)   Exploiting symmetry makes it possible to assign states one computes to \nirreducible representations of the symmetry group of the Hamiltonian operator\n\\cite{bunkerjensen,wilson1955}. \n(2) Exploiting symmetry makes it possible to \nreduce the CPU and memory cost of computing a spectrum.     In the RRBPM case, the CPU cost is reduced because the number of power iterations decreases when  computing levels \nof a single irrep since  the effective density of states decreases.     \n\n\n\nIn this letter we  introduce the basic ideas required to  exploit symmetry. \nIn section~\\ref{theorysec} we present the theoretical arguments and we explain how to construct efficient symmetry-constrained SOP basis functions. \nThe method is then applied to a realistic 12D Hamiltonian in section~\\ref{results}. \nWe show that   reflection in a $\\sigma_v$ plane  can be used to improve the calculation of vibrational levels of  acetonitrile, without  jeopardizing  the memory advantage of the RRBPM. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Theory \\label{theorysec}}\n\n\n\\subsection{Reduced-rank block power method (RRBPM) \\label{resrrbpm} }\n\n\n\n\nWe assume that the potential energy surface (PES) is known and is in SOP form.  We label the coordinates  $q_k$,\n $k=1\\dots D$.\nThere is a primitive basis,  $\\theta_{i_k}^k(q_k)$, $i_k=0,\\dots,n_k-1$, for each coordinate.  \nThe SOP basis functions are of the form of {Eq.\\,(\\ref{{wavefunction}})} with  $ F_{i_1 i_2\\dots i_D} $ as in {Eq.\\,(\\ref{{sop}})}.   \nThe memory cost is \n $RDn$.    Each  basis function can be written\n\n\n", "index": 5, "text": "\\begin{equation}\nF(q_1, \\dots, q_D)=\\sum_{\\ell =1}^R \\prod_{k=1}^D \\phi^{(\\ell,k)} (q_k)  \n=\\sum_{\\ell =1}^R \\prod_{k=1}^D \\left( \\sum_{i_k=0}^{n_k-1} f^{(\\ell,k)}_{i_k} \\theta_{i_k}^k(q_k) \\right) ~. \n\\label{Fexpansion}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"F(q_{1},\\dots,q_{D})=\\sum_{\\ell=1}^{R}\\prod_{k=1}^{D}\\phi^{(\\ell,k)}(q_{k})=%&#10;\\sum_{\\ell=1}^{R}\\prod_{k=1}^{D}\\left(\\sum_{i_{k}=0}^{n_{k}-1}f^{(\\ell,k)}_{i_%&#10;{k}}\\theta_{i_{k}}^{k}(q_{k})\\right)~{}.\" display=\"block\"><mrow><mrow><mrow><mi>F</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>q</mi><mi>D</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><msup><mi>\u03d5</mi><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mo>(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi>i</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><mrow><msub><mi>n</mi><mi>k</mi></msub><mo>-</mo><mn>1</mn></mrow></munderover><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>\u2062</mo><msubsup><mi>\u03b8</mi><msub><mi>i</mi><mi>k</mi></msub><mi>k</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>q</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo rspace=\"5.8pt\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\nthen the function represented by  $ \\prod_{k=1}^3 \n f^{(k)}_{i_k} $ \nis necessarily symmetric because \n$ f^{(k)}_{i_k} =0,  k =1,2$ if $i_k $  is odd. \nWe denote the function represented by $ \\prod_{k=1}^3 \n f^{(k)}_{i_k} $  as $ee$.     \n\n\n\n\n\n\n\n\n\nOf course,  functions made from\n\n", "itemtype": "equation", "pos": 11459, "prevtext": "\n\nThe SOP basis vectors, each of which has the form of {Eq.\\,(\\ref{{sop}})}, are made using a shifted  block power method.    This requires applying\n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ to each vector in a block.  \n\n$\\sigma $ depends on  the block size  and the largest eigenvalue of  ${\\bf{H}}$   \\cite{rrbpm2014}.\n\nCalculations are fast because only one-dimensional matrix-vector products are needed.\n\nEach application of    \n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ \nto a vector increases its rank by a factor of $(P+1)$, where $P$ is the number of terms in the Hamiltonian.\nIn the RRBPM, the rank of vectors is reduced, after each step that increases their rank,  by using  \nan       alternating least square method described in Ref. \\cite{beylkin2005}. \nTo reduce the rank of \n  ${\\bf F}^{\\text{old}}$   from     $R^{\\text{old}}$         to  $R^{\\text{new}}$,  the ALS  algorithm  uses an iterative process to find  vectors  \n $^{\\text{new}}f^{(\\ell,k)}_{i_k}$  to \n minimize    $ \\parallel {\\bf F}^{\\text{new}} - {\\bf F}^{\\text{old}} \\parallel $.       \nThis is done for each \n\n\n coordinate  successively. This gives rise to a succession of systems of $R^{\\text{new}}$   linear equations   to be solved with $n_k$ different right-hand-sides for each coordinate $q_k$.\n\n\nThe main steps in the algorithm are: \n\\begin{itemize}\n\\item Apply \n ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ \n in parallel over a block of SOP vectors \n\\item Reduce the rank using alternating least squares.\n\\item Every 10 to 20 iterations, orthogonalize the vectors, make a matrix representing \n $\\hat{H}$  in this  SOP  basis set.\n\\item Diagonalize the matrix to obtain eigenvalues and eigenvectors .    \n\n\\item Reduce the rank, update the vectors and iterate.\n\\end{itemize}\n\n\n\nUnless special precautions are taken, an  SOP basis, generated as explained above,  cannot be ordered so that the corresponding Hamiltonian matrix is block diagonal. \nOur goal in this letter is to demonstrate that it is possible to make a symmetrized SOP basis and use it to obtain accurate energy levels.   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Symmetric and antisymmetric sum-of-products basis functions}\n\n\nThe most common way to take advantage of symmetry when computing a spectrum is to introduce symmetry-adapted basis functions in which the \nHamiltonian matrix is block-diagonal.   \nWhen using an iterative eigensolver this is often not the best approach.  The reason is that evaluating matrix-vector products\nwith a matrix obtained by representing the Hamiltonian operator in a symmetry-adapted basis may be costly.\n\nThe most straightforward approach when using an iterative eigensolver is to do different calculations for start vectors with different \nsymmetries \\cite{poulin1996,bramley1993}\n\nThis works because the Hamiltonian is invariant with respect to all symmetry operations and therefore \napplying the Hamiltonian to a vector does not change its symmetry. \nIn this letter  we use this \n idea  to make  symmetry-adapted    SOP basis functions from matrix-vector products.\n\n\n\n\n\nThe SOP basis functions we use transform like irreducible representations (irreps) of a sub-group of the full molecular symmetry group.    We shall explain \nthe ideas for a sub-group  $\\{ R, E \\}$, where $E$ is the identity operation.   We assume that all of the coordinates are symmetric   or \nantisymmetric, i.e.,\n\\begin{eqnarray}\n& q_k \\text{ symmetric   } :  & q_k \\overset{R}{\\rightarrow} q_k,  \\\\\n& q_k \\text{ antisymmetric  } : & q_k \\overset{R}{\\rightarrow} -q_k.\n\\end{eqnarray}\n\nThe primitive  1-D  basis functions are chosen so that some are even and some are odd.    \n\nWe use a harmonic primitive basis so \n\n\\begin{eqnarray}\n & \\theta_{i_k=even}^k(q_k) \\overset{q_k \\rightarrow -q_k}{\\longrightarrow} \\theta_{i_k=even}^k(q_k), \\\\\n & \\theta_{i_k=odd}^k(q_k) \\overset{q_k \\rightarrow -q_k}{\\longrightarrow} -\\theta_{i_k=odd}^k(q_k).\n\\end{eqnarray}\n\n\n\n\n\n\n\nThis means that some basis functions change sign (i.e. are symmetric)  and others do not (i.e. are antisymmetric)  when $R$ is applied.   \n\n\nAll   $ \\theta_{i_k}^k(q_k) $ of symmetric coordinates are symmetric. \n $ \\theta_{i_k=even}^k(q_k) $ of antisymmetric coordinates are symmetric. \n$ \\theta_{i_k=odd}^k(q_k) $ of antisymmetric coordinates are antisymmetric. \nWhen $R$ is applied to a primitive D-d basis function,  $\\prod_{k=1}^D \\theta_{i_k}^k (q_k) $, its sign changes if the number of factors for which $i_k$ is odd is \nitself odd, otherwise applying $R$ to   $\\prod_{k=1}^D \\theta_{i_k}^k (q_k) $ does not change the sign.   \nThe  D-d basis is therefore split into two parts, one symmetric and one antisymmetric. \n\n\n\n\n\n\nThroughout the discussion we  use  $e$ and $o$ to indicate even (symmetric) or odd (antisymmetric)  functions (coordinates).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnowing the symmetry properties of the primitive basis functions enables us to choose SOP start vectors that are symmetric  or antisymmetric.  \n\nThe symmetry depends  on which $\\theta_{i_k}^k(q_k)$   in      Eq. \\ref{Fexpansion} have nonzero  coefficients.  \nAn SOP vector is antisymmetric   (symmetric) if applying $R$ to the corresponding function changes (does not change) its sign.  \n\n  This makes it possible \nto separately compute even  and odd wavefunctions.   To illustrate the ideas,   consider an example with three coordinates of which \n $q_1$ and $q_2$ are antisymmetric  coordinates and $q_3$ is a symmetric coordinate.   \n\n\nIf  \nwe consider a single product function whose constituent   1-D  vectors\n(${\\bf f}^{(\\ell=1,k)}={\\bf f}^{(k)}$)\n  are \n\n\n", "index": 7, "text": "\\begin{equation}\n f^{(1)}_{i_1} =\n\\left(\n\\begin{array}{c}\nf^{(1)}_{0} \\\\ \n0 \\\\ \nf^{(1)}_{2} \\\\ \n0 \\\\ \nf^{(1)}_{4} \\\\ \n\\vdots\n\\end{array}\\right)\n\n\n\n\n\\;, \\quad\n\n f^{(2)}_{i_2} = \n\\left(\n\\begin{array}{c}\nf^{(2)}_{0} \\\\ \n0 \\\\ \nf^{(2)}_{2} \\\\ \n0 \\\\  \nf^{(2)}_{4} \\\\  \n\\vdots\n\\end{array}\\right)\n\n\n\n\\quad\n\\text{ and }\n\\quad\n\n\n f^{(3)}_{i_3} = \n\\left(\n\\begin{array}{c}\nf^{(3)}_{0} \\\\\nf^{(3)}_{1} \\\\ \nf^{(3)}_{2} \\\\ \nf^{(3)}_{3} \\\\ \nf^{(3)}_{4} \\\\ \n\\vdots\n\\end{array}\\right)\n\\label{ex3D}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"f^{(1)}_{i_{1}}=\\left(\\begin{array}[]{c}f^{(1)}_{0}\\\\&#10;0\\\\&#10;f^{(1)}_{2}\\\\&#10;0\\\\&#10;f^{(1)}_{4}\\\\&#10;\\vdots\\end{array}\\right)\\par&#10;\\par&#10;\\par&#10;\\par&#10;\\;,\\quad\\par&#10; f^{(2)}_{i_{2}}=%&#10;\\left(\\begin{array}[]{c}f^{(2)}_{0}\\\\&#10;0\\\\&#10;f^{(2)}_{2}\\\\&#10;0\\\\&#10;f^{(2)}_{4}\\\\&#10;\\vdots\\end{array}\\right)\\par&#10;\\par&#10;\\par&#10;\\quad\\text{ and }\\quad\\par&#10;\\par&#10; f^{(3)%&#10;}_{i_{3}}=\\left(\\begin{array}[]{c}f^{(3)}_{0}\\\\&#10;f^{(3)}_{1}\\\\&#10;f^{(3)}_{2}\\\\&#10;f^{(3)}_{3}\\\\&#10;f^{(3)}_{4}\\\\&#10;\\vdots\\end{array}\\right)\" display=\"block\"><mrow><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>0</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo rspace=\"5.3pt\">)</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>0</mn><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>\u00a0and\u00a0</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>3</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>0</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\n\nare also symmetric. \nWe call this an $oo$ function.      \n\nSimilarly, antisymmetric  \nfunctions can be   $eo $  or $ oe $.   \nWe denote these \n $eo$ and $oe$ functions.  \n  A general  \nantisymmetric  \n  function is a sum of  functions of both these ``types''.    \n \n\n\n\n\n\nIf there are $M$ antisymmetric coordinates then a type will be labelled by $M$ letters and   \nthere are  $T=2^{M-1}$ different types. \nIn formulae, types will be  labelled by an integer $t$, for example\n$ee \\Leftrightarrow t=1$ and $oo \\Leftrightarrow t=2$. \nA general $ F_{i_1 i_2 \\dots i_D}  $  is   a sum of SOP, one for each type,  \n\n", "itemtype": "equation", "pos": 12233, "prevtext": "\nthen the function represented by  $ \\prod_{k=1}^3 \n f^{(k)}_{i_k} $ \nis necessarily symmetric because \n$ f^{(k)}_{i_k} =0,  k =1,2$ if $i_k $  is odd. \nWe denote the function represented by $ \\prod_{k=1}^3 \n f^{(k)}_{i_k} $  as $ee$.     \n\n\n\n\n\n\n\n\n\nOf course,  functions made from\n\n", "index": 9, "text": "\\begin{equation}\n f^{(1)}_{i_1} =\n\\left(\n\\begin{array}{c}\n0 \\\\ \nf^{(1)}_{1} \\\\ \n0 \\\\ \nf^{(1)}_{3} \\\\ \n0 \\\\ \n\\vdots\n\\end{array}\\right)\n\n\\; , \\quad\n f^{(2)}_{i_2} =\n\\left(\n\\begin{array}{c}\n0 \\\\ \nf^{(2)}_{1} \\\\ \n0 \\\\ \nf^{(2)}_{3} \\\\  \n0 \\\\  \n\\vdots\n\\end{array}\\right)\n\n\\quad\n\\text{ and }\n\\quad\n f^{(3)}_{i_3} =\n\\left(\n\\begin{array}{c}\nf^{(3)}_{0} \\\\ \nf^{(3)}_{1} \\\\ \nf^{(3)}_{2} \\\\ \nf^{(3)}_{3} \\\\ \nf^{(3)}_{4} \\\\ \n\\vdots\n\\end{array}\\right) ~,\n\\label{ex3D2}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"f^{(1)}_{i_{1}}=\\left(\\begin{array}[]{c}0\\\\&#10;f^{(1)}_{1}\\\\&#10;0\\\\&#10;f^{(1)}_{3}\\\\&#10;0\\\\&#10;\\vdots\\end{array}\\right)\\par&#10;\\;,\\quad f^{(2)}_{i_{2}}=\\left(\\begin{array}[]{c}%&#10;0\\\\&#10;f^{(2)}_{1}\\\\&#10;0\\\\&#10;f^{(2)}_{3}\\\\&#10;0\\\\&#10;\\vdots\\end{array}\\right)\\par&#10;\\quad\\text{ and }\\quad f^{(3)}_{i_{3}}=\\left(%&#10;\\begin{array}[]{c}f^{(3)}_{0}\\\\&#10;f^{(3)}_{1}\\\\&#10;f^{(3)}_{2}\\\\&#10;f^{(3)}_{3}\\\\&#10;f^{(3)}_{4}\\\\&#10;\\vdots\\end{array}\\right)~{},\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo rspace=\"5.3pt\">)</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>\u00a0and\u00a0</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><msubsup><mi>f</mi><msub><mi>i</mi><mn>3</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>0</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><msubsup><mi>f</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></msubsup></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr></mtable><mo rspace=\"5.8pt\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "    \n\nThe number of terms of type $t$ in the  SOP is denoted $R_t$ with $\\sum_{t=1}^T  R_t = R$, $R$ being the total rank of  $F_{i_1 i_2 \\dots i_D}    $   .\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Symmetry-adapted  RRBPM \\label{theosymSOP}}\n\n\n\n\nAs explained at the beginning of the previous subsection,   it should be possible to compute states of a given symmetry by using a block of start vectors each of \nwhich has the right  symmetry.  \nFor the example with three coordinates, one can calculate symmetric \nstates by starting with a block of symmetric \n vectors.   The existence of \ndifferent types, all of which are symmetric, \ncomplicates this somewhat.   There are symmetric \nstates  for which the largest term  in an equation like    {Eq.\\,(\\ref{{Fexpansion}})}  has a\n\n\nproduct of an even function of $q_1$ and an even function of $q_2$ and other symmetric \nstates   for which the largest term  in an equation like    {Eq.\\,(\\ref{{Fexpansion}})} has a\nproduct of an odd  function of $q_1$ and an odd function of $q_2$.  \nTo favour the convergence of both types of states,  we use start vectors that are \n low-rank SOP with one term of each type. \n\n\n\n\n\nGoing back to the 3D example, this choice corresponds to taking a start vector with two terms, one of which is made from the vectors of \n \\eqref{ex3D}\n and the other from the vectors of    \\eqref{ex3D2}.\n In this \npaper   the non-zero components are random.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe ALS reduction is a crucial step in the RRBPM.  \n\nThe reduction begins with initial   $  f^{(\\ell_t ,k)}_{i_k} ~$ values,\nwhich are optimized to give the best $^{\\text{new}}f^{(\\ell_t ,k)}_{i_k} ~$.    \nWhen random initial values are used,  \n${\\bf{F^{\\text{new}}}}$ does not   have symmetry properties, even when  ${\\bf{F^{\\text{old}}}}$ does.     \n\n\n\n\n\nIt would be possible to \nobtain an  ${\\bf{F^{\\text{new}}}}$ of a particular symmetry   (e.g., for the 3-d example,  symmetric)\nby using  initial   $  f^{(\\ell_t ,k)}_{i_k} ~$ chosen so that each term in \n${\\bf{F}^{\\text{inital}}}$  is of one of the types consistent with that symmetry (e.g., for the 3-d example,  ee or oo).   \nHowever, according  to the equations of Ref.  \\cite{beylkin2005}, when   one attempts to reduce  a SOP of type $t'$   using  an  \n${\\bf{F}^{\\text{inital}}}$  that is type $t$, with  $t' \\ne t$,  \n\n one obtains  new   $  f^{(\\ell_t ,k)}_{i_k} ~$  that are identically zero.     It is therefore better\nto  reduce each term in \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nare also symmetric. \nWe call this an $oo$ function.      \n\nSimilarly, antisymmetric  \nfunctions can be   $eo $  or $ oe $.   \nWe denote these \n $eo$ and $oe$ functions.  \n  A general  \nantisymmetric  \n  function is a sum of  functions of both these ``types''.    \n \n\n\n\n\n\nIf there are $M$ antisymmetric coordinates then a type will be labelled by $M$ letters and   \nthere are  $T=2^{M-1}$ different types. \nIn formulae, types will be  labelled by an integer $t$, for example\n$ee \\Leftrightarrow t=1$ and $oo \\Leftrightarrow t=2$. \nA general $ F_{i_1 i_2 \\dots i_D}  $  is   a sum of SOP, one for each type,  \n\n", "index": 11, "text": "\\begin{equation}\nF_{i_1 i_2 \\dots i_D} \\simeq \n\\sum_{t=1}^{T} \n\\sum_{\\ell_t =1}^{R_t}  \n\\prod_{k=1}^D f^{(\\ell_t ,k)}_{i_k} ~.\n\\label{sopsym}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"F_{i_{1}i_{2}\\dots i_{D}}\\simeq\\sum_{t=1}^{T}\\sum_{\\ell_{t}=1}^{R_{t}}\\prod_{k%&#10;=1}^{D}f^{(\\ell_{t},k)}_{i_{k}}~{}.\" display=\"block\"><mrow><mrow><msub><mi>F</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>i</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><msub><mi>i</mi><mi>D</mi></msub></mrow></msub><mo>\u2243</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msub><mi>R</mi><mi>t</mi></msub></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mpadded width=\"+3.3pt\"><msubsup><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mpadded></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "   \nwith initial  $  f^{(\\ell_t ,k)}_{i_k} ~$  chosen so that the initial $F^t_{i_1 i_2 \\dots i_D} $ is of the same type.    \n\n\nFor the 3-D    example in the previous subsection  \nthis means that to reduce    the  $ee$ terms one must use an initial  $F^t_{i_1 i_2 \\dots i_D} $  that is $ee$.   \n\n\nSeparately reducing the terms in {Eq.\\,(\\ref{{sepred}})} also has the advantage that it enables us to ensure that  all types are represented in all vectors.\nIf one does not reduce separately, even  when  each   start vector is a sum of terms of different types, the  terms of the vectors generated by the RRBPM can \n be mostly or exclusively \nvectors of one type.   This is due to  the fact that the RRBPM drives vectors towards the ground state.\n\n\n\n\nTo ensure that each RRBPM vector will have contributions from all types we reduce separately and  impose  ${R_t^{\\text{new}}} $ values.  \n\n\n\n\n\n\n\n\n\nThis can be done by separating and then reducing and merging:\n\n", "itemtype": "equation", "pos": -1, "prevtext": "    \n\nThe number of terms of type $t$ in the  SOP is denoted $R_t$ with $\\sum_{t=1}^T  R_t = R$, $R$ being the total rank of  $F_{i_1 i_2 \\dots i_D}    $   .\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Symmetry-adapted  RRBPM \\label{theosymSOP}}\n\n\n\n\nAs explained at the beginning of the previous subsection,   it should be possible to compute states of a given symmetry by using a block of start vectors each of \nwhich has the right  symmetry.  \nFor the example with three coordinates, one can calculate symmetric \nstates by starting with a block of symmetric \n vectors.   The existence of \ndifferent types, all of which are symmetric, \ncomplicates this somewhat.   There are symmetric \nstates  for which the largest term  in an equation like    {Eq.\\,(\\ref{{Fexpansion}})}  has a\n\n\nproduct of an even function of $q_1$ and an even function of $q_2$ and other symmetric \nstates   for which the largest term  in an equation like    {Eq.\\,(\\ref{{Fexpansion}})} has a\nproduct of an odd  function of $q_1$ and an odd function of $q_2$.  \nTo favour the convergence of both types of states,  we use start vectors that are \n low-rank SOP with one term of each type. \n\n\n\n\n\nGoing back to the 3D example, this choice corresponds to taking a start vector with two terms, one of which is made from the vectors of \n \\eqref{ex3D}\n and the other from the vectors of    \\eqref{ex3D2}.\n In this \npaper   the non-zero components are random.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe ALS reduction is a crucial step in the RRBPM.  \n\nThe reduction begins with initial   $  f^{(\\ell_t ,k)}_{i_k} ~$ values,\nwhich are optimized to give the best $^{\\text{new}}f^{(\\ell_t ,k)}_{i_k} ~$.    \nWhen random initial values are used,  \n${\\bf{F^{\\text{new}}}}$ does not   have symmetry properties, even when  ${\\bf{F^{\\text{old}}}}$ does.     \n\n\n\n\n\nIt would be possible to \nobtain an  ${\\bf{F^{\\text{new}}}}$ of a particular symmetry   (e.g., for the 3-d example,  symmetric)\nby using  initial   $  f^{(\\ell_t ,k)}_{i_k} ~$ chosen so that each term in \n${\\bf{F}^{\\text{inital}}}$  is of one of the types consistent with that symmetry (e.g., for the 3-d example,  ee or oo).   \nHowever, according  to the equations of Ref.  \\cite{beylkin2005}, when   one attempts to reduce  a SOP of type $t'$   using  an  \n${\\bf{F}^{\\text{inital}}}$  that is type $t$, with  $t' \\ne t$,  \n\n one obtains  new   $  f^{(\\ell_t ,k)}_{i_k} ~$  that are identically zero.     It is therefore better\nto  reduce each term in \n\n", "index": 13, "text": "\\begin{equation}\nF_{i_1 i_2 \\dots i_D}   = \\sum_t   F^t_{i_1 i_2 \\dots i_D} = \\sum_{t=1}^{T} \n\\sum_{\\ell_t =1}^{R_t}  \n\\prod_{k=1}^D f^{(\\ell_t ,k)}_{i_k} \n\\label{sepred}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"F_{i_{1}i_{2}\\dots i_{D}}=\\sum_{t}F^{t}_{i_{1}i_{2}\\dots i_{D}}=\\sum_{t=1}^{T}%&#10;\\sum_{\\ell_{t}=1}^{R_{t}}\\prod_{k=1}^{D}f^{(\\ell_{t},k)}_{i_{k}}\" display=\"block\"><mrow><msub><mi>F</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>i</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><msub><mi>i</mi><mi>D</mi></msub></mrow></msub><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>t</mi></munder><msubsup><mi>F</mi><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>i</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><msub><mi>i</mi><mi>D</mi></msub></mrow><mi>t</mi></msubsup></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msub><mi>R</mi><mi>t</mi></msub></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><msubsup><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\n\n\n\n\n\n\n\n  $R^{\\text{new}}  = \\sum_t \n R_t^{\\text{new}} $ is fixed before the calculation is started, but how do we choose   ${R_t^{\\text{new}}} $?  We have considered three strategies.   \nOne option  is \n\n", "itemtype": "equation", "pos": 17044, "prevtext": "   \nwith initial  $  f^{(\\ell_t ,k)}_{i_k} ~$  chosen so that the initial $F^t_{i_1 i_2 \\dots i_D} $ is of the same type.    \n\n\nFor the 3-D    example in the previous subsection  \nthis means that to reduce    the  $ee$ terms one must use an initial  $F^t_{i_1 i_2 \\dots i_D} $  that is $ee$.   \n\n\nSeparately reducing the terms in {Eq.\\,(\\ref{{sepred}})} also has the advantage that it enables us to ensure that  all types are represented in all vectors.\nIf one does not reduce separately, even  when  each   start vector is a sum of terms of different types, the  terms of the vectors generated by the RRBPM can \n be mostly or exclusively \nvectors of one type.   This is due to  the fact that the RRBPM drives vectors towards the ground state.\n\n\n\n\nTo ensure that each RRBPM vector will have contributions from all types we reduce separately and  impose  ${R_t^{\\text{new}}} $ values.  \n\n\n\n\n\n\n\n\n\nThis can be done by separating and then reducing and merging:\n\n", "index": 15, "text": "\\begin{equation}\n\\begin{array}{c}\n\\sum_{t=1}^{T} \\sum_{\\ell_t =1}^{R_t^{\\text{old}}}  \\prod_{k=1}^D {}^{\\text{old}}f^{(\\ell_t ,k)}_{i_k} \\\\\n\\swarrow \\qquad \\downarrow \\text{(separation) } \\downarrow \\qquad \\searrow \\bigstrut[t,b]  \\\\\n\\sum_{\\ell_1 =1}^{R_1^{\\text{old}}}  \\prod_{k=1}^D {}^{\\text{old}}f^{(\\ell_1 ,k)}_{i_k}\n\\dots\n\\sum_{\\ell_t =1}^{R_t^{\\text{old}}}  \\prod_{k=1}^D {}^{\\text{old}}f^{(\\ell_t ,k)}_{i_k}\n\\dots\n\\sum_{\\ell_T =1}^{R_T^{\\text{old}}}  \\prod_{k=1}^D {}^{\\text{old}}f^{(\\ell_T ,k)}_{i_k} \\\\\n\\downarrow \\qquad \\qquad \\qquad \\downarrow \\text{ (ALS reductions) } \\downarrow \\qquad \\qquad \\qquad \\downarrow \\bigstrut[t,b]   \\\\\n\\sum_{\\ell_1 =1}^{R_1^{\\text{new}}}  \\prod_{k=1}^D {}^{\\text{new}}f^{(\\ell_1 ,k)}_{i_k}\n\\dots\n\\sum_{\\ell_t =1}^{R_t^{\\text{new}}}  \\prod_{k=1}^D {}^{\\text{new}}f^{(\\ell_t ,k)}_{i_k}\n\\dots\n\\sum_{\\ell_T =1}^{R_T^{\\text{new}}}  \\prod_{k=1}^D {}^{\\text{new}}f^{(\\ell_T ,k)}_{i_k} \\\\\n\\searrow \\qquad \\downarrow \\text{ (merging) } \\downarrow \\qquad \\swarrow \\bigstrut[t,b] \\\\\n\\sum_{t=1}^{T} \\sum_{\\ell_t =1}^{R_t^{\\text{new}}}  \\prod_{k=1}^D {}^{\\text{new}}f^{(\\ell_t ,k)}_{i_k}  \\\\\n\\end{array}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{c}\\sum_{t=1}^{T}\\sum_{\\ell_{t}=1}^{R_{t}^{\\text{old}}}\\prod_{k%&#10;=1}^{D}{}^{\\text{old}}f^{(\\ell_{t},k)}_{i_{k}}\\\\&#10;\\swarrow\\qquad\\downarrow\\text{(separation) }\\downarrow\\qquad\\searrow\\bigstrut[%&#10;t,b]\\\\&#10;\\sum_{\\ell_{1}=1}^{R_{1}^{\\text{old}}}\\prod_{k=1}^{D}{}^{\\text{old}}f^{(\\ell_{%&#10;1},k)}_{i_{k}}\\dots\\sum_{\\ell_{t}=1}^{R_{t}^{\\text{old}}}\\prod_{k=1}^{D}{}^{%&#10;\\text{old}}f^{(\\ell_{t},k)}_{i_{k}}\\dots\\sum_{\\ell_{T}=1}^{R_{T}^{\\text{old}}}%&#10;\\prod_{k=1}^{D}{}^{\\text{old}}f^{(\\ell_{T},k)}_{i_{k}}\\\\&#10;\\downarrow\\qquad\\qquad\\qquad\\downarrow\\text{ (ALS reductions) }\\downarrow%&#10;\\qquad\\qquad\\qquad\\downarrow\\bigstrut[t,b]\\\\&#10;\\sum_{\\ell_{1}=1}^{R_{1}^{\\text{new}}}\\prod_{k=1}^{D}{}^{\\text{new}}f^{(\\ell_{%&#10;1},k)}_{i_{k}}\\dots\\sum_{\\ell_{t}=1}^{R_{t}^{\\text{new}}}\\prod_{k=1}^{D}{}^{%&#10;\\text{new}}f^{(\\ell_{t},k)}_{i_{k}}\\dots\\sum_{\\ell_{T}=1}^{R_{T}^{\\text{new}}}%&#10;\\prod_{k=1}^{D}{}^{\\text{new}}f^{(\\ell_{T},k)}_{i_{k}}\\\\&#10;\\searrow\\qquad\\downarrow\\text{ (merging) }\\downarrow\\qquad\\swarrow\\bigstrut[t,%&#10;b]\\\\&#10;\\sum_{t=1}^{T}\\sum_{\\ell_{t}=1}^{R_{t}^{\\text{new}}}\\prod_{k=1}^{D}{}^{\\text{%&#10;new}}f^{(\\ell_{t},k)}_{i_{k}}\\\\&#10;\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>t</mi><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>\u2199</mo><mo separator=\"true\">\u2003\u2003</mo><mo>\u2193</mo><mtext>(separation)\u00a0</mtext><mo>\u2193</mo><mo separator=\"true\">\u2003\u2003</mo><mo>\u2198</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bigstrut</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mn>1</mn><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mn>1</mn></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>t</mi><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>T</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>T</mi><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>T</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>\u2193</mo><mo separator=\"true\">\u2003\u2003\u2003\u2003\u2003\u2003</mo><mo>\u2193</mo><mtext>\u00a0(ALS reductions)\u00a0</mtext><mo>\u2193</mo><mo separator=\"true\">\u2003\u2003\u2003\u2003\u2003\u2003</mo><mo>\u2193</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bigstrut</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mn>1</mn><mtext>new</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mn>1</mn></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>new</mtext></mmultiscripts><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>t</mi><mtext>new</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>new</mtext></mmultiscripts><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>T</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>T</mi><mtext>new</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>T</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>new</mtext></mmultiscripts></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>\u2198</mo><mo separator=\"true\">\u2003\u2003</mo><mo>\u2193</mo><mtext>\u00a0(merging)\u00a0</mtext><mo>\u2193</mo><mo separator=\"true\">\u2003\u2003</mo><mo>\u2199</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bigstrut</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>t</mi><mtext>new</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mmultiscripts><mi>f</mi><msub><mi>i</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>new</mtext></mmultiscripts></mrow></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\nWe  call this    reduction strategy 1. \n\n\n\nReduction strategy 1 does not take into account that we should minimize errors introduced by rank reduction.   The error introduced by reduction with \n equal partial ranks will be large for vectors dominated by one type.  \n\n\n  We therefore also test strategy 2 in which \nthe partial ranks $R_{t}^{\\text{new}}$ \n are adjusted,  \nfor each ${\\bf{F}}$,   \n before each reduction so that they are proportional  to  \n\n", "itemtype": "equation", "pos": 18396, "prevtext": "\n\n\n\n\n\n\n\n  $R^{\\text{new}}  = \\sum_t \n R_t^{\\text{new}} $ is fixed before the calculation is started, but how do we choose   ${R_t^{\\text{new}}} $?  We have considered three strategies.   \nOne option  is \n\n", "index": 17, "text": "\\begin{equation}\nR_1^{\\text{new}}=R_t^{\\text{new}}=\\dots=R_T^{\\text{new}}.    \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"R_{1}^{\\text{new}}=R_{t}^{\\text{new}}=\\dots=R_{T}^{\\text{new}}.\" display=\"block\"><mrow><mrow><msubsup><mi>R</mi><mn>1</mn><mtext>new</mtext></msubsup><mo>=</mo><msubsup><mi>R</mi><mi>t</mi><mtext>new</mtext></msubsup><mo>=</mo><mi mathvariant=\"normal\">\u2026</mi><mo>=</mo><msubsup><mi>R</mi><mi>T</mi><mtext>new</mtext></msubsup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.00521.tex", "nexttext": "\n To avoid losing one of the  types, and therefore part of the space spanned by the primitive DP basis,\n we   keep at least one term of each type even if the  weight in\n {Eq.\\,(\\ref{{weight}})} \nis very small. \n\n\n\nAdjusted partial ranks minimize reduction error.   However, they  tend to lock in the character of the vectors. \n\n\nNear the end of the calculation,   when the   ${\\bf{F}}$   \n   are nearly eigenvectors, and  changing little  when ${\\bf{(H}}-\\sigma {\\bf{I}}  )$ is applied\nthere is no reason not to lock in the character.  \nAt the beginning of the calculation,  when the vectors change a lot after application of    ${\\bf{(H}}-\\sigma {\\bf{I}}  )$, it is important to allow\nthe character of the vectors to change and minimizing reduction error is less important.     \nTo ensure that \nthe character is not locked in too early in the calculation \nwe also use strategy 3.   In strategy 3,  the partial ranks  are fixed  until the number of iterations is large enough that    \n\n the dominant types of the SOP  basis vectors, which are becoming closer and closer to the eigenvectors, \nand the corresponding   eigenvalues    are   stabilized  \nand then we use partial ranks determined by \n{Eq.\\,(\\ref{{weight}})}.     \n Fixing the partial ranks at the beginning of the calculation ensures that some types  are not pushed out of the basis. \n\n\n\n\n\n\n\n\n\n\nThe memory cost of the symmetry-adapted RRBPM is very similar to that of the original RRBPM.   It \nscales as $\\mathcal{O} (n D B P R^{\\text{new}})$ where $n$ is a representative  number of primitive basis functions for a single  coordinate, \n$D$ is the number of coordinates, $B$ is the block size,      $P$ is the number of terms in the Hamiltonian and $R^{\\text{new}}$  is the total reduction rank. \nFor a subgroup with two irreps, the   symmetry-adapted RRBPM  makes it possible to reduce $B$ by about a factor of 2.  \n In other words  twice as many  eigenstates can be  obtained,  with the same amount of memory, with the symmetry-adapted RRBPM as with the original RRBPM.\n\nMoreover, half  the components of  $f^{(\\ell_{t} ,k)}_{i_k}$ for antisymmetric coordinates \nare zero and do not need to be stored in memory. \n\n\n\n\n\n\n\\section{Results and discussion \\label{results}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs an illustrative example we have calculated vibrational eigenstates of the acetonitrile molecule (CH$_3$CN), a 12D problem. \nWe use a  Hamiltonian in normal coordinates, \n\\begin{eqnarray}\nH(q_1,\\dots ,q_{12})\n&=& - \\frac{1}{2} \\sum_{i=1}^{12}  \\omega_i \\frac{\\partial ^2}{\\partial q_i^2}\n+ \\frac{1}{2} \\sum_{i=1}^{12} \\omega_i q_i^2\n+\\frac{1}{6} \\sum_{i=1}^{12}\\sum_{j=1}^{12} \\sum_{k=1}^{12} \\phi^{(3)}_{ijk} q_i q_j q_k \\nonumber \\\\\n&&+\\frac{1}{24} \\sum_{i=1}^{12} \\sum_{j=1}^{12} \\sum_{k=1}^{12} \\sum_{\\ell=1}^{12} \\phi^{(4)}_{ijk\\ell} q_i q_j q_k q_{\\ell}.\n\\end{eqnarray}\nThe SOP PES is deduced from \nthe quartic force field potential of B\\'egu\\'e \\emph{et al}. \\cite{begue2005}  \n\n by Avila and Carrington \\cite{avila2011}. \nCoordinates $q_1$ to $q_4$ are non degenerate, coordinates $q_5$ and $q_6$ are members of a doubly degenerate pair as are    \n $q_7$ and $q_8$; $q_9$ and $q_{10}$; and  $q_{11}$ and $q_{12}$. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  For  CH$_{3}$CN the symmetry group is \n $C_{3v}$ with  irreducible representations (irreps)  $A_{1}$, $A_{2}$, and $E$. \n We use a subgroup  and divide the basis into two blocks.\nThe non-degenerate normal coordinates, $q_{1}$, $q_{2}$, $q_{3},$ and $q_{4}$ \nand the degenerate\n normal coordinates  $(q_{5},q_{7},q_{9},q_{11})$, are all\nsymmetric with respect to  reflection in  a \n$\\sigma_{v}$ plane,  whereas  the degenerate normal modes  $(q_{6},q_{8},q_{10},q_{12})$, are antisymmetric with\n respect to the same   operation  \\cite{henry1960}. \nThe primitive basis set of products  of harmonic oscillator basis functions is split into two subsets,  one of which contains functions that \n change sign when  $\\sigma_v$ is applied and the other containing  functions that do not change sign when  $\\sigma_v$ is applied.  \n \n\n\n\n\n\n\n\n\nAccording to section \\ref{theorysec}, two separate calculations can be done. \n\nSymmetric  wavefunctions (which correlate with $A_1$ states and half of the $E$ states) are obtained by using \n SOP basis functions that are  sums of terms each of which is    one of    8 possible symmetric types.  The 8 types are characterized by \nwhether the  1-d functions of ($q_6,q_8,q_{10},q_{12}$) are even or odd:\n\\begin{eqnarray}\n(e,e,e,e); \\;\n(o,o,o,o); \\;\n(e,e,o,o); \\; \n(o,o,e,e); \\; \\nonumber \\\\\n(e,o,o,e); \\; \n(o,e,e,o); \\; \n(e,o,e,o); \\; \n(o,e,o,e).\n\\end{eqnarray}\nConversely,   \nantisymmetric wavefunctions (which correlate with $A_2$ states and half of the $E$ states) are obtained by using \n SOP basis functions that are  sums of terms each of which is    one of    8 possible antisymmetric  types.  The 8 types are also characterized by \nwhether their 1-d functions of ($q_6,q_8,q_{10},q_{12}$) are even or odd:\n $(e,e,e,o)$, $(o,o,o,e)$, etc. \n\n\n\n\n\n\n\n\nFour calculations are presented: RRBPM without symmetry adaptation and     $R^{\\text{new}} = 30  $;   \n symmetry-adapted  RRBPM with fixed partial ranks $R_t^{\\text{new}}=8$ (strategy 1); symmetry-adapted\n RRBPM with  partial ranks chosen according to strategy 2 and a \n total rank $R^{\\text{new}} = 30$;\n and  symmetry-adapted     RRBPM with   partial ranks chosen according to strategy 3 and   \nfixed at   $R_t=8$  at the beginning of the calculation and a total rank of  $R^{\\text{new}} = 30$   \nat the end of the calculation. \n\nIn all cases the number of power iterations is 6000 and the number of ALS iterations is 10.   \n  The even and odd calculations done with    symmetry-adapted RRBPM are done with a block size of 60.   A block size of \n70 is used for the calculations with the original RRBPM.\nThese parameters are chosen so that  \ntheir CPU costs are nearly equal.\n\nSeparately reducing a SOP with 8 terms for each of the 8 types, i.e. a total SOP with rank 64 is a little less costly than reducing a symmetry-free SOP with rank 30 but matrix-vector products with rank 64 are more costly. \n\n 1000 iterations for a block size  of 60  take two days using 30     AMD Opteron(tm) 6386 SE     CPUs\nat 2.8GHz. \n\n\n\n\n\n\n\\begin{figure}[htp]\n\\centering\n\\includegraphics[width=0.45\\linewidth]{fig1a_rang_fixe_vpsous_espace.ps}\n\\includegraphics[width=0.45\\linewidth]{fig1b_rang_adapt_vpsous_espace.ps}\\\\\n\\includegraphics[width=0.45\\linewidth]{fig1c_comparaison_vpsous_espace.ps}\n\\includegraphics[width=0.45\\linewidth]{fig1d_comparaison_vpsous_espace3.ps}\n\\caption{Eigenvalues as a function of the power iteration number, using symmetry-constrained SOP with the rank reduction strategy 1 (a) or strategy 2 (b) and zooms on the first (c) and the 43th eigenvalues (d). } \n\\label{convcurves}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\nThe convergence of several eigenvalues is shown  in fig. \\ref{convcurves}.  They converge well with  reduction strategy 1\n(fig. \\ref{convcurves} (a)).   \n\n\nLooking at the lowest  eigenvalues and comparing to Smolyak quadrature results of ref. \\cite{avila2011},\nit seems \n that using strategy 2 improves the  accuracy. For example the \n error \non the first \n transition frequency close to  $361$ cm$^{-1}$ is 0.05 cm$^{-1}$ using strategy 2 instead of 0.18 cm$^{-1}$ using strategy 1. \n\n\nHowever, using  strategy 2, we observe \nthat some levels converge  slowly  and others are missing, even  when the number  of   power iterations is large. \n The high-lying states of the block are particularly affected, see  Fig.  \\ref{convcurves} (b).\n\n\n\n\n\n This appears to be due to the fact that the  partial ranks  of some types are too small.   \nThe \nStrategy 3 works better.  Levels computed with strategy 3 are given in table  \\ref{tabwn}.   \n\n\n\n\n\\begin{table}\n\\caption{Transition wavenumbers from the ZPE for CH$_3$CN in cm$^{-1}$. \nThe bold values are those differing from more than 5 cm$^{-1}$ from the results of ref. \\cite{avila2011}.\nThe braces indicate neighbouring eigenvalues whose corresponding eigenvectors are mixed in linear combinations with different symmetries. }\n\\hspace{-3cm}\n{\\small\n\\begin{tabular}{ccccccc}  \n\\hline\n&&&\t\t\t\t\t\\multicolumn{2}{c}{RRBPM}  \n\t\t\t\t\t& \\multicolumn{2}{c}{RRBPM}    \\\\\nVib.\t&  \t\t\t& Results \n\t\t\t\t\t\t& \\multicolumn{2}{c}{without symmetry splitting}  \n\t\t\t\t\t\t\t\t\t\t\t& \\multicolumn{2}{c}{with symmetry splitting}    \n\t\t\t\t\t\t\t\t\t\t\t\\\\\\cline{4-7} \nAssig. \t&\tSym.\t& of ref. \\cite{avila2011} \n\t\t\t\t\t\t& Reduction & Reduction\t& \\multicolumn{2}{c}{Fixed rank for each type ($R_t=8$)} \\\\\n\t\t&\t\t\t& (Smolyak & rank=20 \t\t& rank=30\t\t& \\multicolumn{2}{c}{until $N_{pow}=3000$ then adaptive} \\\\\n\t\t& \t\t\t&\tquadrature)&  Ref. \\cite{rrbpm2014}\t&\t\t\t& \\multicolumn{2}{c}{with total reduc. rank $R=30$} \\\\\\cline{6-7} \n&&&&& subset $A_1 \\oplus E$ & subset $A_2 \\oplus E$ \\\\\n\\hline\nZPE \t\t\t\t\t& $A_1$\t& \t-\t\t& {9837.63} \t\t\t& {9837.51} \t\t\t& - & - \\\\\n$\\omega_{11}$ \t\t\t& $E$ \t& 360.99\t& {361.18, 361.25}\t& {361.07, 361.12}\t& {361.06}  & {361.13} \\\\\n$2 \\omega_{11}$ \t\t& $E$\t& 723.18 \t& {723.37, 724.38}\t& {723.27, 723.74}\t& {723.68}  & {723.39} \\\\\n$2 \\omega_{11}$\t\t\t& $A_1$ & 723.83\t& {724.96}\t\t\t& {724.42}\t\t\t& {724.49}  & - \\\\\n$\\omega_4$\t\t\t\t& $A_1$ & 900.66\t& {900.97}\t\t\t& {900.87}\t\t\t& {900.90}  & - \\\\\n$\\omega_9$\t\t\t\t& $E$ \t& 1034.13\t& {1034.50, 1034.55}\t& {1034.31, 1034.34}\t& {1034.29} & {1034.81} \\\\\n$3\\omega_{11}$\t\t\t& $A_2$ & 1086.55\t& {1087.95}\t\t\t& {1087.41}\t\t\t& -       & {1087.25} \\\\\n$3\\omega_{11}$\t\t\t& $A_1$ & 1086.55\t& {1088.58}\t\t\t& {1087.64}\t\t\t& {1087.33} & - \\\\\n$3\\omega_{11}$\t\t\t& $E$\t& 1087.78\t& {1090.75}, 1090.85\t& {1088.81, 1088.92}\t& {1088.43} & {1088.72} \\\\\n$\\omega_4+\\omega_{11}$\t& $E$\t& 1259.88\t& {1260.89, 1261.12}\t& {1260.80, 1260.87}\t& {1260.14} & {1260.55} \\\\\n$\\omega_3$\t\t\t\t& $A_1$ & 1388.97\t& {1391.76}\t\t\t& {1391.03}\t\t\t& {1390.32} & - \\\\\n$\\omega_9+\\omega_{11}$\t& $E$\t& 1394.69\t& \\multirow{2}{*}{\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\\left.\n\t\t\t\t\t\t\t\t\t\t\t\\begin{array}{rcl}\n\t\t\t\t\t\t\t\t\t\t\t{1395.74}, {1398.24} \\\\\n\t\t\t\t\t\t\t\t\t\t\t{1396.24}\n\t\t\t\t\t\t\t\t\t\t\t\\end{array}\n\t\t\t\t\t\t\t\t\t\t\t\\right\\rbrace\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t& {1396.80}, {1398.51}& {1396.09} & {1395.46} \\\\\n$\\omega_9+\\omega_{11}$\t& $A_2$\t& 1394.91\t& \t\t\t\t\t\t& \\multirow{2}{*}{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\left.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\begin{array}{rcl}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\\bf 1400.21},  \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\\bf 1402.98}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\end{array}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\right\\rbrace\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\t\t\t&  -      & {1396.04} \\\\\n$\\omega_9+\\omega_{11}$\t& $A_1$ & 1397.69\t& {1401.15}\t\t\t\t& \t\t\t\t\t\t& {1401.03} & -       \\\\\n$4\\omega_{11}$\t\t\t& $E$\t& 1451.10\t& {1452.92}, {\\bf1458.62}& {1452.09, 1452.26}\t& {1452.40} & {1452.02} \\\\\n$4\\omega_{11}$\t\t\t& $E$\t& 1452.83\t& \\multirow{2}{*}{\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\\left.\n\t\t\t\t\t\t\t\t\t\t\t\\begin{array}{rcl}\n\t\t\t\t\t\t\t\t\t\t\t{1456.24}, {\\bf1460.80} \\\\\n\t\t\t\t\t\t\t\t\t\t\t{\\bf 1464.40}\n\t\t\t\t\t\t\t\t\t\t\t\\end{array}\n\t\t\t\t\t\t\t\t\t\t\t\\right\\rbrace\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t& {1454.22, 1454.96}\t& {1454.61} & {1453.81} \\\\\t\n$4\\omega_{11}$\t\t\t& $A_1$\t& 1453.40\t& \t\t\t\t\t\t& {1455.37}\t\t\t& {1455.46} & -       \\\\\n$\\omega_7$\t\t\t\t& $E$\t& 1483.23\t& {1483.52, 1483.51}\t& {1483.43, 1483.47}\t& {1483.46} & {1484.22} \\\\\n$\\omega_4+2\\omega_{11}$\t& $E$\t& 1620.22\t& {1621.34}, 1623.05\t& {1620.98, 1622.06}\t& {1621.79} & {1620.90} \\\\\n\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots &\\vdots  \\\\ \n$\\omega_9+2\\omega_{11}$ & $E$ & 1759.772 &  {\\bf 1780.66, 1780.86} & {\\bf 1771.64, 1781.84} & {\\bf 1771.25} & {\\bf 1767.08} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots &\\vdots  \\\\\n$5\\omega_{11}$\t\t\t& $E$ \t& 1816.80\t& {\\bf 1823.34, 1830.31}\t& {1818.29, 1818.57}\t& {1818.42} & {1818.72} \\\\\n$5\\omega_{11}$\t\t\t& $A_2$ & 1818.95\t& {\\bf 1827.34}\t\t\t& {1823.01}\t\t\t& -       & {1820.93} \\\\\n$5\\omega_{11}$\t\t\t& $A_1$ & 1818.95\t& {\\bf 1832.19}\t\t\t& {\\bf 1823.98}\t\t\t& {1821.06}  & -         \\\\\n$5\\omega_{11}$\t\t\t& $E$\t& 1820.03\t&  1823.87, {\\bf 1828.40}\t& {1821.91}, {1823.55} & {1822.58} & {1822.27} \\\\   \n$\\omega_7+\\omega_{11}$\t& $A_2$ & 1844.23\t& \\multirow{2}{*}{\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\\left.\n\t\t\t\t\t\t\t\t\t\t\t\\begin{array}{rcl}\n\t\t\t\t\t\t\t\t\t\t\t{1845.57} \\\\\n\t\t\t\t\t\t\t\t\t\t\t{1846.85}, {\\bf 1849.44}\n\t\t\t\t\t\t\t\t\t\t\t\\end{array}\n\t\t\t\t\t\t\t\t\t\t\t\\right\\rbrace\n\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t\t& \\multirow{3}{*}{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\left.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\begin{array}{rcl}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{1845.89}, \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{1847.45, 1848.12} \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\\bf 1850.66}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\end{array}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\right\\rbrace\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t$\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t& -       & {1845.39} \\\\\n$\\omega_7+\\omega_{11}$\t& $E$\t& 1844.33\t& \t\t\t\t\t&\t\t\t\t\t& {1845.95} & {1847.24} \\\\\n$\\omega_7+\\omega_{11}$\t& $A_1$ & 1844.69\t& {1848.14}\t\t&\t\t\t\t\t& {1848.07}& -       \\\\\n\\vdots &\\vdots & \\vdots & \\vdots & \\vdots & \\vdots &\\vdots \\\\\n\\hline\n\\end{tabular}\n}\n\\label{tabwn}\n\\end{table}\n\n\n\n\n\n\nThe most important advantage of the symmetry-adapted RRBPM is that it provides symmetry labels.    It also improves the accuracy of some of the \nlevels reported in table \\ref{tabwn}. \nSome wavefunctions obtained with  the non-symmetrized RRBPM calculation  are nearly linear combinations of a few of  the \nessentially exact wavefunctions of \\cite{avila2011} \nwith similar energies but different symmetries     \\cite{rrbpm2014}.   \n These poorly converged  states are enclosed in  braces in the table. \nThe symmetry-adapted RRBPM calculation does a better job on these states for several reasons.   1) Owing to the    \n symmetry-adapted  SOP basis, there is no mixing between \nsymmetric and antisymmetric states.  \n     2) In the symmetry-adapted case the effective \ndensity of states is lower and therefore fewer power iterations are required to achieve a given convergence error. \n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[htp]\n\\centering\n\\includegraphics[width=\\linewidth]{fig2_difference_with_sparse_grids2.ps}\n\\caption{Differences between transition wavenumbers obtained using the RRBPM and the \"exact\" results of ref. \\cite{avila2011}, with or without symmetry constraints.} \n\\label{error}\n\\end{figure}\n\nDifferences between the levels  obtained with Smolyak quadrature \\cite{avila2011}  and levels obtained with the RRBPM, with and without symmetry adaptation, are \n reported in fig. \\ref{error}. \nFor most eigenvalues, both    differences   are less than  5 cm$^{-1}$.   \n\nSome errors are larger.   \nThe errors could be reduced by using contracted basis functions \\cite{phillip},   \nlarger ranks, and more power iterations. \nThe accuracy of the first several dozen \n eigenvalues is similar  with and without symmetry adaptation.\nSome of the higher levels are more accurate with  symmetry adaptation.   The non symmetry-adapted eigenvectors corresponding to \nthese levels are nearly linear combinations of exact eigenvectors of different symmetries. \n The symmetry-adapted method always has the advantage that it allows one to assign levels. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Conclusion}\n\n\nIn this letter we introduce a symmetry-adapted version of the RRBPM.   The memory cost of the  symmetry-adapted version  is similar to that of the    original RRBPM.\nIt is clear that by using a block of starting vectors of a given symmetry \n it is possible to compute states of that symmetry.  This enables one to obtain \nstates with symmetry labels and accelerates convergence of the power method.  \n\n\n\n\nUnless one is careful, it     is possible to make SOP basis vectors in which some ``types'' are missing or underrepresented.   We have developed several\nstrategies for dealing with this problem and shown that they are effective. \n\n\n  Starting vectors of a given symmetry are easily made from  \n $f^{(\\ell_{t} ,k)}_{i_k}$ that have appropriate symmetries.   \n  \nAccuracy can be improved by using contractions, increasing the ranks, and increasing the number of power iterations.     Better eigensolvers  \\cite{davidson1975,ribeiro2005} \nmight also be adapted to the SOP format.   \n\nThe key advantage of the RRBPM is its low memory cost:  less than 1GB is required  for a 12D problem.     The memory cost is actually reduced by introducing symmetry adaptation, but \nthe memory cost is so low that the reduction  is unimportant.    The major advantage of the symmetry-adapted approach is that levels are obtained with symmetry labels.   Accuracy is \nalso somewhat improved.  Ideas similar to those of this letter could be used with any subgroup for which it is possible to make  ${\\bf{F}}$ \nthat transform like irreps.    It should be possible to use projection operators to generate states of all symmetries from one set of \nmatrix-vector products, as in    the symmetry adapted Lanczos algorithm  \\cite{wang2001,chen2001},  \n this will obviate the need to use symmetry adapted coordinates, which we exploit in this Letter.   \n\n\n\n\n\n\n\n\n\n\n\n\\section*{Acknowledgments}\nSome  of the calculations were done   on computers purchased with a grant for the Canada Foundation for Innovation.  This research was funded by the \nNatural Sciences and Engineering Research Council of Canada.  \n\n\n\n\n\\bibliographystyle{elsarticle-num}\n\\bibliography{symmetric_RRBPM}\n\n\n\n\n", "itemtype": "equation", "pos": 18944, "prevtext": "\nWe  call this    reduction strategy 1. \n\n\n\nReduction strategy 1 does not take into account that we should minimize errors introduced by rank reduction.   The error introduced by reduction with \n equal partial ranks will be large for vectors dominated by one type.  \n\n\n  We therefore also test strategy 2 in which \nthe partial ranks $R_{t}^{\\text{new}}$ \n are adjusted,  \nfor each ${\\bf{F}}$,   \n before each reduction so that they are proportional  to  \n\n", "index": 19, "text": "\\begin{equation}\n\\vert\n\\langle {\\bf{F}}^{\\text{old},t} \\vert {\\bf{F}}^{\\text{old}} \\rangle \\vert\n=\n\\vert\n\\sum_{\\ell_{t} =1}^{R_{t}^{\\text{old}}} \n\\sum_{t'=1}^{T} \\sum_{\\ell_{t'} =1}^{R_{t'}^{\\text{old}}}  \n\\prod_{k=1}^D  \\langle {}^{\\text{old}} {\\bf f}^{(\\ell_{t} ,k)} \n\\vert {}^{\\text{old}}{\\bf f}^{(\\ell_{t'} ,k)}\n\\rangle  \n\\vert.\n\\label{weight}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"|\\langle{\\bf{F}}^{\\text{old},t}|{\\bf{F}}^{\\text{old}}\\rangle|=|\\sum_{\\ell_{t}=%&#10;1}^{R_{t}^{\\text{old}}}\\sum_{t^{\\prime}=1}^{T}\\sum_{\\ell_{t^{\\prime}}=1}^{R_{t%&#10;^{\\prime}}^{\\text{old}}}\\prod_{k=1}^{D}\\langle{}^{\\text{old}}{\\bf f}^{(\\ell_{t%&#10;},k)}|{}^{\\text{old}}{\\bf f}^{(\\ell_{t^{\\prime}},k)}\\rangle|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msup><mi>\ud835\udc05</mi><mrow><mtext>old</mtext><mo>,</mo><mi>t</mi></mrow></msup><mo stretchy=\"false\">|</mo><msup><mi>\ud835\udc05</mi><mtext>old</mtext></msup><mo stretchy=\"false\">\u27e9</mo></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><mi>t</mi><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msup><mi>t</mi><mo>\u2032</mo></msup><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msub><mi mathvariant=\"normal\">\u2113</mi><msup><mi>t</mi><mo>\u2032</mo></msup></msub><mo>=</mo><mn>1</mn></mrow><msubsup><mi>R</mi><msup><mi>t</mi><mo>\u2032</mo></msup><mtext>old</mtext></msubsup></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mo stretchy=\"false\">\u27e8</mo><mmultiscripts><mi>\ud835\udc1f</mi><none/><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><mi>t</mi></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts><mo stretchy=\"false\">|</mo><mmultiscripts><mi>\ud835\udc1f</mi><none/><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u2113</mi><msup><mi>t</mi><mo>\u2032</mo></msup></msub><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mtext>old</mtext></mmultiscripts><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}]