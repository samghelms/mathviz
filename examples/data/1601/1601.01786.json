[{"file": "1601.01786.tex", "nexttext": " This is a significant improvement compared to  the complexity  $O(|{\\mathcal{A}}|^8\\times|{\\mathcal{V}}|^7)$ in~\\cite{Lamali2013}.\n\n\\subsection{Simulations}\n\\label{sec:simul_without}\nWe implemented our algorithm (called PDA) and compared it to a classical BFS approach.\n\n\\subsubsection{Networks used for the simulations and methodology}\nLarge multi-layer topologies are generally not available. Some public ones as the Internet2 network~\\cite{Internet2} are not large enough to show the scaling of our algorithm. Thus we performed simulations on two topologies described in~\\cite{Mahajan2002}:\n\\begin{itemize}\n\\item Topology~$T1$ is a simplified version of Time Warner network. It has $41$ nodes and $296$ directed links.\n\\item Topology~$T2$ corresponds to the network of Exodus as in 2002. It has $79$ nodes and $294$ directed links.\n\\end{itemize}\n\nSince these topologies are not layered, the adaptation functions are randomly allocated to the nodes. For an alphabet~${\\mathcal{A}}$, there are $3|{\\mathcal{A}}|^2$ possible adaptation functions (for each ordered pair of protocols: a conversion, an encapsulation and a decapsulation). For each node $U$, each of these adaptation functions is available on $U$ with probability $p$. The source and the destination nodes are the diameter extremities, which corresponds to $5$ (resp. $10$) hops for Topology~$T1$ (resp. $T2$).\n\n\\subsubsection{Phase transition in path feasibility}\n\\label{sec:trans_phase}\nDepending on the network topology and the adaptation function distribution, there is not always a feasible path. It is interesting to know the probability of a feasible path existence according to probability $p$ in order to set appropriate parameters for the simulations. In case of path existence, knowing the probability that the shortest one involves loops allows comparing the different algorithms (some of them allow loops and others do not). To compute this probability, we performed $200$ runs for each value of $p$ and counted the number of times there was a feasible path.\n\nFigure~\\ref{fig:phase_trans} shows the evolution of feasible path existence probability according to $p$ and the proportion of shortest paths that involve loops. Not surprisingly, the probability of feasible path existence grows according to $p$. On both topologies, the probability of path existence reaches $50\\%$ when $p=0.22$ and follows a phase transition phenomenon. For example, in the interval $p\\in[0.10, 0.38]$, the probability of path existence in Topology~$T1$ grows from $5\\%$ to $90\\%$. This interval is the most suitable to perform simulations. The phase transition phenomenon also holds with more than $2$ protocols. The more the number of protocols is high, the more the phase transition is shifted to the left.\nIf there are few feasible paths (for small $p$), the probability that the shortest ones involve loops is high. However, this probability quickly decreases. For example, for $p>18\\%$, the proportion of shortest paths involving loops is less than $20\\%$ in Topology~$T1$. The trend of this proportion is not clear in $T2$, however it is less than $21\\%$ if $p>0.22$.\n\\begin{figure} \n\\centering\n\\includegraphics[width=0.45\\textwidth]{trans_phase3.png}\n\\caption{Probability of existence of a feasible path (and a loop in the shortest one) according to the probability of existence of an adaptation function.}\n\\label{fig:phase_trans}\n\\end{figure}\nThe phase transition phenomenon can be seen in~\\cite{Iqbal2015}. But the results consider only loopless paths and the distribution deals with technologies rather than adaptation functions. \n\n\\subsubsection{Simulation results}\n\\label{sec:simul_without_bandwidth}\nOur algorithm is compared to a classical BFS which explores all possible paths until reaching the destination. During the exploration process, all \\textit{dominated}\\footnote{In this context, a path dominates another one if they have the same extremities and the same protocol stack, and the first path is shorter.} paths are deleted. BFS can be seen as a version of the algorithm in~\\cite{K09} where the bandwidth constraint is relaxed. The first results showed that BFS algorithm is extremely slow even for small values of $p$ (processing time of the order of several hours). It was impossible to perform a comparison with our algorithm. Due to this tremendous running time, we fixed a maximum length to the explored paths by BFS algorithm. If a path exceeds $10$ hops (resp. $14$ hops) on Topology~$T1$ (resp. $T2$), it is deleted and no more considered. We performed $100$ runs for each value of $p$ and averaged the processing time.\n\\begin{figure} \n\\centering\n\\includegraphics[width=0.45\\textwidth]{PDA_vs_BFS2.png}\n\\caption{Comparison of processing time of PDA algorithm and BFS on Topologies $T1$ and $T2$.}\n\\label{fig:pda_vs_bfs}\n\\end{figure}\nFigure~\\ref{fig:pda_vs_bfs} shows the processing time of PDA algorithm and BFS algorithm on Topologies $T1$ and $T2$ according to the values of $p$. For small values of $p$ ($<0.22$ for $T1$ and $<0.04$ for $T2$) BFS algorithm is faster than PDA. However, the processing time of BFS explodes. We cannot put it on Figure~\\ref{fig:pda_vs_bfs} because it would be unreadable. For example, the processing time of BFS algorithm on Topology~$T2$ for $p=0.24$ is more than $14$ minutes, while that of PDA algorithm is $10$ seconds. On Topology~$T1$, for $p=0.38$, the processing time of BFS algorithm is more than $7$ minutes, while that of PDA algorithm is $7$ seconds.  These results show that our algorithm clearly outperforms the BFS approach.\n\\section{Addressing bandwidth constraint}\n\\label{sec:with}\nThis section studies the complexity of path computation under bandwidth constraint and proposes heuristic solutions to resolve the problem.\n\\subsection{Problem formalization}\nFor Traffic Engineering purposes, a feasible path may be constrained by a minimal bandwidth. But it is possible that feasible paths in a multi-layer network involve loops (i.e., involving the same link several times but using different protocols). It implies that the bandwidth constraint is no longer prunable: Even if the links with not enough bandwidth are deleted by topology filtering prior to path computation, other links can have enough bandwidth if they are selected once but not if more. For example, if a link has a capacity of $10$Gbps and the bandwidth constraint is $5$Gbps, then this link cannot be crossed more than twice. The (optimization) problem of computing the shortest path in a multi-layer network under bandwidth constraint is defined as follows:\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\author{\\IEEEauthorblockN{Mohamed~Lamine~Lamali\\IEEEauthorrefmark{1}, Nasreddine~Fergani\\IEEEauthorrefmark{1}, Johanne Cohen\\IEEEauthorrefmark{2}, H\\'elia Pouyllau\\IEEEauthorrefmark{3}\n\\IEEEauthorblockA{\\IEEEauthorrefmark{1}Nokia Bell Labs. France.}\n\\IEEEauthorblockA{\\IEEEauthorrefmark{2}LRI, Univ. Paris-Sud, CNRS, Universit\\'e Paris-Saclay. France.}\n\\IEEEauthorblockA{\\IEEEauthorrefmark{2}Thales Research \\& Technology. France.}\n}\n\\url{mohamed_lamine.lamali@nokia.com }\\ \\ \\\n\\url{johanne.cohen@lri.fr }\\ \\ \\ \n\\url{helia.pouyllau@thalesgroup.com}\n}\n\n\\title{Path computation in multi-layer networks: Complexity and algorithms\\thanks{Preprint of the paper accepted for IEEE INFOCOM $2016$.}}\n\n\n\\maketitle\n\n\\begin{abstract}\nCarrier-grade networks comprise several layers where different protocols coexist. Nowadays, most of these networks have different control planes to manage routing on different layers, leading to a suboptimal use of the network resources and additional operational costs. However, some routers are able to encapsulate, decapsulate and convert protocols and act as a liaison between these layers. A unified control plane would be useful to optimize the use of the network resources and automate the routing configurations. Software-Defined Networking (SDN) based architectures, such as OpenFlow, offer a chance to design such a control plane. One of the most important problems to deal with in this design is the path computation process. Classical path computation algorithms cannot resolve the problem as they do not take into account encapsulations and conversions of protocols. In this paper, we propose algorithms to solve this problem and study several cases: Path computation without bandwidth constraint, under bandwidth constraint and under other Quality of Service constraints. We study the complexity and the scalability of our algorithms and evaluate their performances on real topologies. The results show that they outperform the previous ones proposed in the literature.\n\n\\end{abstract}\n\n\n\\begin{IEEEkeywords}\nMulti-layer networks; Path computation; Protocol heterogeneity; Unified control plane.\n\\end{IEEEkeywords}\n\n\n\\section{Introduction}\nCarrier-grade networks generally encompass several layers involving different technologies and protocols. To support some services, such as a Virtual Private Network (VPN), a path across network equipments must be identified and the equipments be configured accordingly. Under stringent requirements of Quality of Service (QoS \\--- e.g., end-to-end delay, geographic zone avoidance, etc.), computing such a path within a single layer is not always possible. Hence, one of the key challenges is to determine the end-to-end path that uses the appropriate \\textit{adaptation functions} over the protocols: The mapping from a protocol to another being realized through \\textit{encapsulation} (e.g., Ethernet over IP/MPLS~\\cite{RFC4448}), \\textit{decapsulation} (the reverse operation) or \\textit{conversion} (e.g., IPv4 to IPv6~\\cite{RFC6144}) functions. Consequently, the path computation process should take into account the adaptation function capabilities of the network equipments in order to ensure \\textit{path feasibility}: If a protocol is encapsulated in another one, it must be decapsulated (or unwrapped) further in the path. If several encapsulations are nested, the corresponding decapsulations must occur in the right order. Here, the multi-layer context should be taken in a broad sense: Presence of several protocols and technologies that can be nested, encapsulated, converted, etc.\n\nDealing with protocol heterogeneity becomes increasingly important nowadays. In addition to the IPv4/IPv6 migration, this heterogeneity appears in tunneling, some architectures (e.g., The Pseudo-Wire architecture~\\cite{RFC3985} allows the emulation \\--- and thus the encapsulation \\--- of lower layer protocols over Packet-Switched Networks), hybrid networks (e.g., National Research and Education Networks \\--- NRENs \\--- which may have optical and IP interconnection points), and last but not least, most carrier-grade networks, which have separate control planes for IP and Transport layers. In all these contexts, a unified control plane would be very useful for optimizing the network resources and reduce operational and management costs. \n\nOpenFlow is a chance to design such a control plane. Some previous works~\\cite{das2010packet,liu2013field} present an OpenFlow-based architecture to achieve this challenge, but they only focus on the convergence of packet and circuit networks. Other works tackle the traffic engineering problem in SDNs but circumscribe it on a single layer~\\cite{Agarwal2013} or in the IPv4/IPv6 migration context~\\cite{Li2014}. However, an important problem to solve remains the path computation process in a multi-layer context. Taking into account the adaptation functions is not trivial and classical algorithms such as Dijkstra's one \\cite{Dijkstra1959} cannot achieve the task as they do not handle these functions.\n\nHere, we design several algorithms to compute shortest paths dealing with protocol changes and adaptation functions.\n\\subsection*{Our contributions:}\n\\begin{enumerate}\n\\item We widely generalize the model and the polynomial algorithms described in Lamali~\\textit{et~al.}~\\cite{Lamali2012, Lamali2013} to perform path computation in multi-layer networks (without bandwidth constraint). Our model takes into account all possible types of protocol changes (encapsulation, conversion, etc.) and any additive metric. We drastically improve the algorithm complexity and realize the first implementation, showing their efficiency on two real topologies.\n\\item For simulation purposes, we empirically study the distribution of adaptation functions over the network nodes and its impact on feasible path existence. We exhibit a phase transition phenomenon, i.e., a gap where the probability of existence of a feasible path hugely increases. \n\\item We prove that path computation in multi-layer networks under bandwidth constraint is $\\mathsf{NP}$-complete even with two protocols and on symmetric graphs, thus improving a result of Kuipers and  Dijkstra~\\cite{K09}. We also obtain results on the complexity of some subproblems: It is polynomial on \\emph{Directed Acyclic Graphs} (DAG) and the general problem is not approximable. We propose a new heuristic to resolve the problem and show its efficiency through simulations. \n\\item We propose the first algorithm to perform path computation in multi-layer networks under several QoS constraints by adapting the Self-Adaptive Multiple Constraints Routing Algorithm (SAMCRA \\--- Van~Mieghem and Kuipers~\\cite{Van04}) to the multi-layer context. We study its scalability through simulations.\n\\end{enumerate}\n\nThe paper is organized as follows: Section~\\ref{sec:prob_state} describes the problem of path computation in  multi-layer networks and recalls the related work; Section~\\ref{sec:model} formalizes the problem and describes our model of multi-layer network; Section~\\ref{sec:without} proposes algorithms to perform path computation without bandwidth constraint and shows their efficiency through simulations, it also studies the phase transition phenomenon in multi-layer networks; Section~\\ref{sec:with} studies the complexity  of path computation under bandwidth constraint and proposes heuristic solutions to tackle the problem; Section~\\ref{sec:qos2} proposes the first algorithm computing paths under additive QoS constraints and studies its scalability; finally, Section~\\ref{sec:conclusion} concludes the paper.\n\n\n\\section{Path computation in Multi-Layer Networks}\n\\label{sec:prob_state}\n\\subsection{Connectivity in multi-layer networks}\nWe aim to present the different concepts of path computation in multi-layer networks through an example. While this example relates to multi-domain multi-layer networks, the underlying problem of path computation is the same as in a single domain network\\footnote{The algorithms presented in this paper can be applied in a single-domain or a multi-domain context. For the latter, however, a mechanism for sharing the network information (such as the topology) is needed. This can be done through a PCE for example~\\cite{PCE}.}. Figure~\\ref{fig:realnet} (inspired by the Inter-Provider Reference Model~\\cite{RFC5659}) depicts a network involving multiple domains and  adaptation function capabilities of network equipments: A company owning a Local Area Network (LAN) wishes the Virtual Machines (VMs) of a data-center to be within the same routing domain (for instance through a Layer 2 VPN or a Generic Routing Encapsulation tunnel). Hence, the switches of the LAN and the VMs of the data-center must communicate through Ethernet datagrams and a path has to be determined across the Domains~$1$ and $2$.\n\\begin{figure*}[htb]\n\\centering\n\\includegraphics[width=\\textwidth]{realnet.png}\n\\caption{Carrier-grade network comprising several domains and different layers.}\n\\label{fig:realnet}\n\\end{figure*}\n\nOn Figure~\\ref{fig:realnet}, Domains~$1$ and $2$ use IPv6/MPLS-TE technology and are linked by equipments providing Ethernet encapsulation and decapsulation. The Provider Edge (PE) of Domain~$1$ is linked to the Customer Edge (CE) of the data-center. The adaptation capabilities of each node are shown above it.\nAn example of feasible path would cross the PE of Domain~$1$ converting IPv4 packets into IPv6 ones. Then it would apply the encapsulation and decapsulation of the border routers of Domains~$1$ and $2$ respectively and the PE of Domain~$2$ would apply a conversion of IPv6 packets into IPv4 ones. The protocol stacks of the packets at each stage are illustrated at the bottom of Figure~\\ref{fig:realnet}. As an example of unfeasible path, a direct Ethernet connection between the CE of the data-center and the border router of Domain~$1$ appears. This configuration leads to a decapsulation of an IPv6 packet from an Ethernet datagram (by the border router of Domain~$2$) whereas at this stage the datagram encapsulates IPv4 packets.\n\nThis example depicts the constraints to comply with when computing a multi-layer (and multi-domain, in this case) path: Being physically linked is not sufficient to establish connectivity. Protocol continuity (by analogy with wavelength continuity in optical networks) must hold and the adaptation functions should occur in the right order. Moreover, feasible paths can involve loops and their subpaths are not necessary feasible~\\cite{K09,Dijkstra2009}. Nowadays, such paths are manually determined and configurations are operated and applied by scripts.\n\\subsection{Related work}\nThe initial works dealing with protocol and technology heterogeneity circumscribed the problem at the optical layer. For instance, Chlamtac~\\textit{et~al.}~\\cite{Chlamtac1996} described a model and algorithms to compute a path under wavelength continuity constraints. Zhu~\\textit{et~al.}~\\cite{Zhu2003} addressed the same problem in WDM mesh networks tackling traffic grooming issues. In~\\cite{Gong2008}, Gong and Jabbari provided an algorithm to compute an optimal path under constraints on several layers: wavelength continuity, label continuity, etc. \n\nHowever, the models of these past works are not adapted to the problem of nested encapsulation and decapsulation capabilities for which a kind of stack mechanism is needed. In~\\cite{Dijkstra2008}, Dijkstra~\\textit{et~al.} addressed this issue  in the context of the ITU-T G.805 recommendations on adaptation functions. They stressed the lack of solutions on path computation. Kuipers and Dijkstra~\\cite{K09} demonstrated that the problem of path computation with encapsulation and decapsulation capabilities is $\\mathsf{NP}$-complete under bandwidth constraint. They proposed a Breadth-First Search (BFS) algorithm that explores all possible paths until finding a feasible one. In~\\cite{Lamali2012,Lamali2013}, Lamali~\\textit{et~al.} demonstrated that the problem is polynomial if the bandwidth constraint is relaxed. Their approach was to model the network as a Push-Down Automaton and to use automata and language theory tools to compute a shortest feasible path, but only considering the number of hops or adaptation functions. More recently, Iqbal~\\textit{et~al.}~\\cite{Iqbal2015} underlined the need of path computation algorithms in NRENs. They proposed a new matrix-based model for multi-layer networks and algorithms based on $k$-shortest paths and \\textit{LOOK-AHEAD} methods. However, the model deals with technologies\\footnote{A \\textit{technology} is an exhaustive description of the protocol stack at some node, e.g.,  IP over Ethernet over ATM.} instead of protocols. Thus, the nested protocols are not transparent to the nodes. Moreover, the proposed exact algorithm is exponential and can compute only loopless feasible paths.\n\\subsection{Proposed approach}\nOur goal is to study the path computation problem in a multi-layer context and to propose efficient algorithms to resolve it. To this end, we focus on three cases: Path computation without bandwidth constraint (by adapting the language theoretic approach of Lamali\\textit{~et~al.}~\\cite{Lamali2013}), under bandwidth constraint (by using graph transformation in order to overcome the problem complexity) and under several QoS constraints. The simulations showing the efficiency of our algorithms follow a methodology based on the probabilistic distribution of the adaptation functions over the nodes.\n\\section{Model and problem formalization}\n\\label{sec:model}\nThis section describes a mathematical model of multi-layer networks and formalizes the notion of path feasibility. \n\\subsection{Multi-layer network model}\n\\noindent{\\bf Notation convention.}  In order to avoid confusion, lowercase letters denote protocols (e.g., $a,b,c,x,y$) or functions (e.g., $f,h,\\ell$). Capital letters denote nodes and links (e.g., $U,V,E$). Finally, calligraphic letters denote sets (e.g., ${\\mathcal{G}},{\\mathcal{V}},{\\mathcal{E}}$).\n\\label{sec:graph_model}\n\nWe consider a multi-layer network as a $4$-tuple ${\\mathcal{N}}=({\\mathcal{G}}, {\\mathcal{A}}, {\\mathcal{F}}, h)$ where:\n\\begin{itemize}\n\\item ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is a directed graph modeling the network topology. The set of nodes ${\\mathcal{V}}$ models the routers of the network. The set of edges ${\\mathcal{E}}$ models the physical links between the routers. \n\\item ${\\mathcal{A}}=\\{a,b,c, \\dots \\}$ is the set of protocols available in the network, but not necessarily at each router.\n\\item For each node $U\\in{\\V}$, ${\\mathcal{F}}(U)$ is the set of adaptation functions available on node $U$. These functions are: \n\\begin{itemize}\n\\item \\textit{Conversion}: A protocol $a$ is converted into a protocol $b$ without any change of the possible underlying protocols. This function is denoted by $(a\\rightarrow b)$. E.g., Wavelength conversion on the optical layer, IPv4 to IPv6, etc.\n\\item \\textit{Passive function}: A protocol $a$ is left as it is. It is a classical retransmission without any protocol change and can be considered as a special case of protocol conversion where $a=b$. Thus it is denoted by $(a\\rightarrow a)$.\n\\item \\textit{Encapsulation}: A protocol $a$ is encapsulated in a protocol $b$. It is denoted by $(a\\rightarrow ab)$. \n\\item \\textit{Decapsulation}: A protocol $a$ is decapsulated from a protocol $b$. It is denoted by $\\overline{(a\\rightarrow ab)}$.\n\\end{itemize}\n\\item $h : {\\mathcal{V}}\\times{\\mathcal{F}}\\times {\\mathcal{V}} \\rightarrow \\Re_+$ is the \\textit{weight} function. The value $h(U,f,V)$ (where $U,V\\in {\\mathcal{V}}$ and $f\\in{\\mathcal{F}}(U)$ ) is the cost of using the link $(U,V)$ with the adaptation function $f$ on $U$. Hence, function $h$ allows representing any additive metric either associated only to the links or to both links and adaptation functions.\n\\end{itemize}\n\n\\subsection{Path feasibility}\n\\label{sec:path_feas}\nLet $(S,D)$ be a pair of nodes in ${\\mathcal{G}}$ corresponding to the source and the destination of the path to be computed.\nWe consider a path from $S$ to $D$ as a sequence of nodes and adaptation functions $Sf_0U_1f_1U_2f_2\\dots U_nf_nD$ where each $U_i$, $i=1,\\ldots,n$, is a node and each $f_i$ is an adaptation function ($f_0$ being fictitious). A path is \\textit{feasible} if: \n\\begin{enumerate}\n\\item The sequence $SU_1U_2\\dots U_nD$ is a path in ${\\mathcal{G}}=({\\V},{\\mathcal{E}})$ and each $f_i \\in {\\mathcal{F}}(U_i)$;\n\n\\item Each encapsulated protocol is decapsulated before reaching $D$ according to its encapsulation order and \\textit{protocol continuity} must hold (i.e., if the sequence contains a function $f_i$ s.t. $f_i=(a \\rightarrow b)$, $a,b \\in {\\mathcal{A}}$, then $f_{i+1}=(b \\rightarrow a')$ or $f_{i+1}=(b \\rightarrow b a')$ or $f_{i+1}=\\overline{(a'\\rightarrow a'b)}$, $a'\\in {\\mathcal{A}}$).\n\\end{enumerate}\n\nActually, the protocol sequences of feasible paths can be characterized as a well-parenthesized language~\\cite{Lamali2013}.\n\n\n\n\n\\section{Path computation without bandwidth constraint}\n\\label{sec:without}\nThis section proposes a polynomial algorithm to resolve the path computation problem without bandwidth constraint and evaluates it through simulations.\n\\subsection{A polynomial algorithm for path computation}\nLamali~\\textit{et~al}.~\\cite{Lamali2013} proposed a language theoretic approach to compute a shortest feasible path (involving encapsulations and decapsulations of protocols) in a multi-layer network. The metric considered was the number of hops or of encapsulations in the path. The approach comprises the following steps:\n\\begin{enumerate}\n\\item Consider the set of protocols as an alphabet and convert the multi-layer network into a Push-Down Automaton (PDA);\n\\item If the considered metric is the number of encapsulations, transform the automaton in order to bypass passive transitions;\n\\item Convert the PDA to a Context-Free Grammar (CFG);\n\\item \\label{it:shortest}Compute the shortest word generated by the CFG. It is the protocol sequence of a shortest path;\n\\item \\label{it:path}Compute a shortest path from this sequence.\n\\end{enumerate}\nWe made several improvements to these algorithms:\n\n\\begin{itemize}\n\\item The PDA building is modified in order to support protocol conversion by adding a new transition type;\n\\item The PDA transitions are weighted in order to reflect the weight function. Thus, our algorithm computes the shortest path according to any additive metric (instead of just the number of hops or encapsulations); \n\\item The PDA transformation is no longer useful thanks to the weight function: Simply put $h(U,f,V)=1$ (where $U,V\\in {\\mathcal{V}}$ and $f\\in{\\mathcal{F}}(U)$) for all triples where $f$ is an encapsulation, and $h(U,f,V)=0$ for all other triples. It is also possible to set different weights to each type of encapsulation and minimize the path cost according to these weights;\n\\item The conversion of the PDA into a CFG is adapted: As in~\\cite{Lamali2013}, each transition from the PDA is converted into a production rule set in the CFG according to a method described in~\\cite{Hop06}. However, the transition weights are assigned to the corresponding production rules;\n\\item Step~\\ref{it:shortest} is different: Since the production rules are weighted, the goal is no longer to compute the shortest word but the word having the minimum weight derivation tree. This is done thanks to Knuth's algorithm described in~\\cite{Knuth77}. This word corresponds to the protocol sequence of a shortest path to compute;\n\\item The algorithm computing the path matching the protocol sequence is modified in order to take into account the weights.\n\\end{itemize}\nDue to the lack of space, we cannot detail our improved algorithm. The interested reader can find it (together with its correctness proof and complexity study) in Appendix~\\ref{appendix:algos}.\n\nAdditionally to these improvements, the algorithm complexity is drastically decreased. In~\\cite{Lamali2013},  Step~\\ref{it:shortest} has a complexity of $O(|{\\mathcal{A}}|^8\\times|{\\mathcal{V}}|^7)$ in the worst case, which is the highest complexity in the whole process.\nImplementing Knuth's algorithm with Fibonacci heaps gives an $O(|\\mathcal{Q}|\\log|\\mathcal{Q}|+\\mathcal{|R|})$ complexity, where $|\\mathcal{Q}|$ is the number of nonterminals in the CFG and $|\\mathcal{R}|$ is the number of production rules~\\cite{Tarjan1987}. Since $|\\mathcal{Q}|=O(|{\\mathcal{A}}|^3\\times|{\\mathcal{V}}|^2)$ and $|\\mathcal{R}|=O(|{\\mathcal{A}}|^5\\times|{\\mathcal{V}}|^2\\times|{\\mathcal{E}}|)$ (see Appendix~\\ref{appendix:algos}), the complexity of the whole process is:\n", "index": 1, "text": "\n\\[O\\left(|{\\mathcal{A}}|^5\\times|V|^2\\times|{\\mathcal{E}}|\\right) \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"O\\left(|{\\mathcal{A}}|^{5}\\times|V|^{2}\\times|{\\mathcal{E}}|\\right)\" display=\"block\"><mrow><mi>O</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mrow><mo stretchy=\"false\">|</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo stretchy=\"false\">|</mo></mrow><mn>5</mn></msup><mo>\u00d7</mo><msup><mrow><mo stretchy=\"false\">|</mo><mi>V</mi><mo stretchy=\"false\">|</mo></mrow><mn>2</mn></msup><mo>\u00d7</mo><mrow><mo stretchy=\"false\">|</mo><mi class=\"ltx_font_mathcaligraphic\">\u2130</mi><mo stretchy=\"false\">|</mo></mrow></mrow><mo>)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01786.tex", "nexttext": "\nwhere $nb(E)$ is the number of times a link $E$ is crossed by path ${\\mathcal{P}}$, ${q}_b(E)$ is the bandwidth capacity of $E$ and ${q}_b^{min}$ is the bandwidth constraint.\n  \n\\subsection{Path computation complexity under bandwidth constraint}\nThe bandwidth constraint impacts the complexity of feasible path computation. In a single-layer network, computing a path under bandwidth constraint is trivial: It suffices to prune all the links without enough bandwidth. This is no longer possible in a multi-layer network. In fact, the decision problem is $\\mathsf{NP}$-complete as shown by Kuipers and Dijkstra~\\cite{K09}. But this proof does not work on symmetric directed graphs\\footnote{A symmetric directed graph is a graph where a link $(U,V)$ exists if and only if the reverse link $(V,U)$ exists.}. However, most communication networks are symmetric. We show that the decision version of the problem remains $\\mathsf{NP}$-complete even with two protocols and in a symmetric graph. Consider the following problem:\n\n\n\n{\\bf Problem (\\ref{def:BFP}')}. Given a multi-layer network ${\\mathcal{N}}=({\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}}), {\\mathcal{A}}, {\\mathcal{F}},h)$, a function  assigning to each link $E\\in{\\mathcal{E}}$ an available bandwidth ${q}_b(E)$, a bandwidth constraint ${q}_b^{min}$ and a pair $S$ and $D$ of nodes in ${\\mathcal{V}}$. Is there a feasible path from $S$ to $D$ satisfying the bandwidth constraint?\n\n\\begin{proposition}\n\\label{prop:NPsym}\nProblem~(\\ref{def:BFP}') is $\\mathsf{NP}$-complete with two protocols even if ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is a symmetric directed graph.\n\\end{proposition}\n\n\n\n\\begin{proof}\nClearly, the problem is in $\\mathsf{NP}$. Thus, we only detail the proof of $\\mathsf{NP}$-hardness.\n\nFirst consider the problem of finding a Hamiltonian path in a symmetric directed graph between two nodes $S'$ and $D'$. Call this problem SYM-HAM. SYM-HAM is $\\mathsf{NP}$-complete (for a detailed proof, see Appendix~\\ref{app:np-complete}).\n\n\nNow we provide a polynomial reduction from SYM-HAM to Problem~(\\ref{def:BFP}') restricted to symmetric directed graph and two protocols. Given an instance of SYM-HAM, i.e., a symmetric directed graph ${\\mathcal{H}}=({\\mathcal{V}}',{\\mathcal{E}}')$ and a pair of nodes $(S',D')$, we build an instance of Problem~(\\ref{def:BFP}'), i.e., a network ${\\mathcal{N}}=({\\mathcal{G}}, {\\mathcal{A}}, {\\mathcal{F}}, h)$ and a pair of nodes $(S,D)$ as following:\n\n\\noindent{\\bf Step~1: Splitting the nodes.} For each node $U'\\in {\\mathcal{V}}'$, four nodes $U_1,U_2, U_3$ and $U_4$ are created in ${\\mathcal{G}}$. Links $(U_i,U_{i+1})$ and $(U_{i+1},U_{i})$ are created for $i=1,\\dots,3$. For each link $(U',V')\\in {\\mathcal{E}}'$, a link $(U_1,V_1)$ is created in ${\\mathcal{G}}$. This step is illustrated on Figure~\\ref{fig:reduc_nodes_sym}.\n\n\\noindent{\\bf Step~2: Adding a tail.} ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is augmented by a set ${\\mathcal{C}}=\\{C_0,\\dots, C_{n+1}\\}$ of nodes ($n=|{\\mathcal{V}}'|$), where $C_0=S$ is the source node. There are a link $(C_i,C_{i+1})$ and a link $(C_{i+1},C_i)$ for $i=0,\\dots,n$. Moreover, there is also a link from $C_{n+1}$ to $S_1$ (the first node resulting from the splitting of $S'$) and conversely. Figure~\\ref{fig:reduc_graph_sym} shows this construction. Finally, two nodes $X$ and $D$ are added, as well as the four links $(D_1,X),(X,D_1),(X,D)$ and $(D,X)$ (recall that $D_1$ is the first node resulting from the splitting of $D'$, see Step~$1$).\n\n\n\\noindent{\\bf Step~3: Allocating the adaptation functions and available bandwidth.} All the links have available bandwidth $1$. The bandwidth constraint is set to $1$. Thus, any feasible path must cross a link at most once. There is no possible loop. \nLet the set of protocols be ${\\mathcal{A}}=\\{a,b\\}$. Node $S$ emits packets of protocol $a$. For $i=1\\dots,n$, each node $C_i$ in the tail can encapsulate protocol $a$ in itself. Node $C_{n+1}$ can only encapsulate $a$ in $b$. For each node $U'\\in{\\mathcal{V}}'$, node $U_1$ can encapsulate any protocol in $b$. Node $U_2$ can either decapsulate protocol $b$ from itself or passively transmit protocol $a$. Node $U_3$ can either decapsulate protocol $a$ from $b$ or passively transmit protocol $a$. Node $U_4$ is able to decapsulate protocol $a$ from itself. Finally, node $X$ can decapsulate protocol $a$ from $b$. Table~\\ref{tab:functions} summarizes the allocation of the adaptation functions.\n\n\\begin{figure*}[htb]\n\\centering\n\\includegraphics[width=0.65\\textwidth]{reduc_nodes_sym.png}\n\\centering\n\\caption{Reduction from SYM-HAM to feasible path under bandwidth constraint (node splitting).}\n\\label{fig:reduc_nodes_sym}\n\\end{figure*}\n\n\\begin{figure*}[htb]\n\\centering\n\\hspace{10mm}\n\\includegraphics[width=0.98\\textwidth]{reduc_graph_sym.png}\n\\caption{Reduction from SYM-HAM to feasible path under bandwidth constraint (graph transformation).}\n\\label{fig:reduc_graph_sym}\n\\end{figure*}\n\n\\begin{table}\n\t\\centering\n\t\t\\begin{tabular}{|l|l|}\n\t\t\\hline\n\t\t\tNode & Adaptation functions \\\\\n\t\t\t\\hline\n\t\t\t$C_i,\\ i=1\\dots n$  & $(a\\rightarrow aa)$ \\\\\n\t\t\t\\hline\n\t\t\t$C_{n+1}$  & $(a\\rightarrow ab)$ \\\\\n\t\t\t\\hline\n\t\t\t$U_1\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $(b\\rightarrow bb)$, $(a\\rightarrow ab)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_2\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(b\\rightarrow bb)}$, $(a\\rightarrow a)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_3\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(a\\rightarrow ab)}$, $(a\\rightarrow a)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_4\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(a\\rightarrow aa)}$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$X$  & $\\overline{(a\\rightarrow ab)}$ \\\\\n\t\t\t\\hline\t\t\t\t\n\t\t\\end{tabular}\n\t\\caption{The adaptation functions available on the nodes in the polynomial reduction.}\n\t\\label{tab:functions}\n\\end{table}\n\nNow, we prove that there is a Hamiltonian path from $S'$ to $D'$ in ${\\mathcal{H}}$ if and only if there is a feasible path from $S$ to $D$ in ${\\mathcal{N}}$ that satisfies the bandwidth constraint.\nFirst, assuming that there is a Hamiltonian path from $S'$ to $D'$ in ${\\mathcal{H}}$, we construct a feasible path ${\\mathcal{P}}$ in ${\\mathcal{N}}$ as follows: Starting from $S$ in ${\\mathcal{N}}$, ${\\mathcal{P}}$ crosses the tail and each $C_i$ ($i=1\\dots n$) adds an occurrence of protocol $a$ in the stack of encapsulated protocols. Then crossing $C_{n+1}$ adds $b$ as current protocol. Thus, at the end of the tail, there are $n+1$ encapsulated protocols $a$ (the one emitted by $S$ and $n$ occurrences added in the tail) and the current protocol is $b$. Following the same node order as in the Hamiltonian path, replace each occurrence of a node $U'\\in{\\mathcal{V}}'$ (including $S'$ and $D'$) in the Hamiltonian path by the sequence:\n\n\n", "itemtype": "equation", "pos": 27276, "prevtext": " This is a significant improvement compared to  the complexity  $O(|{\\mathcal{A}}|^8\\times|{\\mathcal{V}}|^7)$ in~\\cite{Lamali2013}.\n\n\\subsection{Simulations}\n\\label{sec:simul_without}\nWe implemented our algorithm (called PDA) and compared it to a classical BFS approach.\n\n\\subsubsection{Networks used for the simulations and methodology}\nLarge multi-layer topologies are generally not available. Some public ones as the Internet2 network~\\cite{Internet2} are not large enough to show the scaling of our algorithm. Thus we performed simulations on two topologies described in~\\cite{Mahajan2002}:\n\\begin{itemize}\n\\item Topology~$T1$ is a simplified version of Time Warner network. It has $41$ nodes and $296$ directed links.\n\\item Topology~$T2$ corresponds to the network of Exodus as in 2002. It has $79$ nodes and $294$ directed links.\n\\end{itemize}\n\nSince these topologies are not layered, the adaptation functions are randomly allocated to the nodes. For an alphabet~${\\mathcal{A}}$, there are $3|{\\mathcal{A}}|^2$ possible adaptation functions (for each ordered pair of protocols: a conversion, an encapsulation and a decapsulation). For each node $U$, each of these adaptation functions is available on $U$ with probability $p$. The source and the destination nodes are the diameter extremities, which corresponds to $5$ (resp. $10$) hops for Topology~$T1$ (resp. $T2$).\n\n\\subsubsection{Phase transition in path feasibility}\n\\label{sec:trans_phase}\nDepending on the network topology and the adaptation function distribution, there is not always a feasible path. It is interesting to know the probability of a feasible path existence according to probability $p$ in order to set appropriate parameters for the simulations. In case of path existence, knowing the probability that the shortest one involves loops allows comparing the different algorithms (some of them allow loops and others do not). To compute this probability, we performed $200$ runs for each value of $p$ and counted the number of times there was a feasible path.\n\nFigure~\\ref{fig:phase_trans} shows the evolution of feasible path existence probability according to $p$ and the proportion of shortest paths that involve loops. Not surprisingly, the probability of feasible path existence grows according to $p$. On both topologies, the probability of path existence reaches $50\\%$ when $p=0.22$ and follows a phase transition phenomenon. For example, in the interval $p\\in[0.10, 0.38]$, the probability of path existence in Topology~$T1$ grows from $5\\%$ to $90\\%$. This interval is the most suitable to perform simulations. The phase transition phenomenon also holds with more than $2$ protocols. The more the number of protocols is high, the more the phase transition is shifted to the left.\nIf there are few feasible paths (for small $p$), the probability that the shortest ones involve loops is high. However, this probability quickly decreases. For example, for $p>18\\%$, the proportion of shortest paths involving loops is less than $20\\%$ in Topology~$T1$. The trend of this proportion is not clear in $T2$, however it is less than $21\\%$ if $p>0.22$.\n\\begin{figure} \n\\centering\n\\includegraphics[width=0.45\\textwidth]{trans_phase3.png}\n\\caption{Probability of existence of a feasible path (and a loop in the shortest one) according to the probability of existence of an adaptation function.}\n\\label{fig:phase_trans}\n\\end{figure}\nThe phase transition phenomenon can be seen in~\\cite{Iqbal2015}. But the results consider only loopless paths and the distribution deals with technologies rather than adaptation functions. \n\n\\subsubsection{Simulation results}\n\\label{sec:simul_without_bandwidth}\nOur algorithm is compared to a classical BFS which explores all possible paths until reaching the destination. During the exploration process, all \\textit{dominated}\\footnote{In this context, a path dominates another one if they have the same extremities and the same protocol stack, and the first path is shorter.} paths are deleted. BFS can be seen as a version of the algorithm in~\\cite{K09} where the bandwidth constraint is relaxed. The first results showed that BFS algorithm is extremely slow even for small values of $p$ (processing time of the order of several hours). It was impossible to perform a comparison with our algorithm. Due to this tremendous running time, we fixed a maximum length to the explored paths by BFS algorithm. If a path exceeds $10$ hops (resp. $14$ hops) on Topology~$T1$ (resp. $T2$), it is deleted and no more considered. We performed $100$ runs for each value of $p$ and averaged the processing time.\n\\begin{figure} \n\\centering\n\\includegraphics[width=0.45\\textwidth]{PDA_vs_BFS2.png}\n\\caption{Comparison of processing time of PDA algorithm and BFS on Topologies $T1$ and $T2$.}\n\\label{fig:pda_vs_bfs}\n\\end{figure}\nFigure~\\ref{fig:pda_vs_bfs} shows the processing time of PDA algorithm and BFS algorithm on Topologies $T1$ and $T2$ according to the values of $p$. For small values of $p$ ($<0.22$ for $T1$ and $<0.04$ for $T2$) BFS algorithm is faster than PDA. However, the processing time of BFS explodes. We cannot put it on Figure~\\ref{fig:pda_vs_bfs} because it would be unreadable. For example, the processing time of BFS algorithm on Topology~$T2$ for $p=0.24$ is more than $14$ minutes, while that of PDA algorithm is $10$ seconds. On Topology~$T1$, for $p=0.38$, the processing time of BFS algorithm is more than $7$ minutes, while that of PDA algorithm is $7$ seconds.  These results show that our algorithm clearly outperforms the BFS approach.\n\\section{Addressing bandwidth constraint}\n\\label{sec:with}\nThis section studies the complexity of path computation under bandwidth constraint and proposes heuristic solutions to resolve the problem.\n\\subsection{Problem formalization}\nFor Traffic Engineering purposes, a feasible path may be constrained by a minimal bandwidth. But it is possible that feasible paths in a multi-layer network involve loops (i.e., involving the same link several times but using different protocols). It implies that the bandwidth constraint is no longer prunable: Even if the links with not enough bandwidth are deleted by topology filtering prior to path computation, other links can have enough bandwidth if they are selected once but not if more. For example, if a link has a capacity of $10$Gbps and the bandwidth constraint is $5$Gbps, then this link cannot be crossed more than twice. The (optimization) problem of computing the shortest path in a multi-layer network under bandwidth constraint is defined as follows:\n\n", "index": 3, "text": "\\begin{equation}\n\\label{def:BFP}\n\\begin{split}\n\\min &\\ h({\\mathcal{P}})=\\sum_{(U,f,V)\\in{\\mathcal{P}}}h(U,f,V)\\\\\n s.t.& \\left\\lbrace\\begin{array}{l}\n{\\mathcal{P}} \\text{ is a feasible path between $S$ and $D$}\\\\\n \\\\\n\\min_{E\\in {\\mathcal{P}}}\\dfrac{{q}_b(E)}{{nb}(E)}\\geq {q}_b^{min} \\\\\n\\end{array} \\right.\n\\end{split}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\begin{split}\\displaystyle\\min&amp;\\displaystyle\\ h({\\mathcal{P}})=\\sum_{(U,f,V)%&#10;\\in{\\mathcal{P}}}h(U,f,V)\\\\&#10;\\displaystyle s.t.&amp;\\displaystyle\\left\\{\\begin{array}[]{l}{\\mathcal{P}}\\text{ %&#10;is a feasible path between $S$ and $D$}\\\\&#10;\\\\&#10;\\min_{E\\in{\\mathcal{P}}}\\dfrac{{q}_{b}(E)}{{nb}(E)}\\geq{q}_{b}^{min}\\\\&#10;\\end{array}\\right.\\end{split}\" display=\"block\"><mtable columnspacing=\"0pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mi>min</mi></mtd><mtd columnalign=\"left\"><mrow><mrow><mpadded lspace=\"5pt\" width=\"+5pt\"><mi>h</mi></mpadded><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>U</mi><mo>,</mo><mi>f</mi><mo>,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></mrow></munder><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>U</mi><mo>,</mo><mi>f</mi><mo>,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mi>s</mi><mo>.</mo><mi>t</mi></mrow><mo>.</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mo>{</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo>\u2062</mo><mrow><mtext>\u00a0is a feasible path between\u00a0</mtext><mi>S</mi><mtext>\u00a0and\u00a0</mtext><mi>D</mi></mrow></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><munder><mi>min</mi><mrow><mi>E</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></mrow></munder><mo>\u2061</mo><mfrac><mrow><msub><mi>q</mi><mi>b</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mi>n</mi><mo>\u2062</mo><mi>b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow><mo>\u2265</mo><msubsup><mi>q</mi><mi>b</mi><mrow><mi>m</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow></msubsup></mrow></mtd></mtr></mtable><mi/></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.01786.tex", "nexttext": "\n\nThus, at node $U_1$ an encapsulation of protocol $b$ occurs, at $U_2$ protocol $b$ is decapsulated, at $U_3$ it is decapsulated again, and at $U_4$ protocol $a$ is decapsulated. Path ${\\mathcal{P}}$ then crosses passively nodes $U_3$ and $U_2$, and finally encapsulates protocol $b$ at $U_1$. Thus, at each time the path crosses a Sequence~\\eqref{eq:seq}, then one occurrence of protocol $a$ is removed from the protocol stack. Crossing all $U_4$ s.t. $U'\\in{\\mathcal{H}}$ removes all encapsulated occurrences of protocol $a$ except the first one. When the path  leaves $D_1$ to reach node $X$, the current protocol is $b$ and there is a last occurrence of protocol $a$ which is encapsulated. Finally, node $X$ decapsulates protocol $a$ from protocol $b$ and node $D$ receives protocol $a$ as emitted by $S$. Thus, ${\\mathcal{P}}$ is a feasible path, and each link is crossed at most once, the bandwidth constraint is satisfied. \n\nConversely, we show that from any feasible path ${\\mathcal{P}}$ satisfying the bandwidth constraint in ${\\mathcal{N}}$, one can extract a Hamiltonian path between $S'$ and $D'$ in ${\\mathcal{H}}$. A feasible path must cross all nodes $U_4$ s.t. $U'\\in{\\mathcal{V}}'$ in order to decapsulate all occurrences of protocol $a$ encapsulated when crossing the tail. Thus, it involves Sequence~\\eqref{eq:seq} for all $U'\\in {\\mathcal{V}}'$. By removing the tail part and the nodes $X$ and $D$ from ${\\mathcal{P}}$ and replacing each occurrence of Sequence~\\eqref{eq:seq} by the corresponding node $U'$, the resulting path starts from $S'$ and crosses all the nodes in ${\\mathcal{H}}$ before reaching $D'$. The only problem is the possibility that there are other sequences than Sequence~\\eqref{eq:seq} in the remaining path. There are two possible cases:\n\\begin{itemize}\n\\item An \\emph{incomplete} Sequence~\\eqref{eq:seq} where $U_4$ is not reached (e.g., $U_1 f U_2 f' U_3 f'' U_2 f''' U_1$): This cannot happen because such a sequence forbids to reach $U_4$ later, and thus one encapsulated occurrence of protocol $a$ is never decapsulated and ${\\mathcal{P}}$ cannot be feasible. Such a sequence cannot occur after an occurrence of Sequence~\\eqref{eq:seq} on the same nodes because if a node $U_i$ ($i=2,3$) is reached in a Sequence~\\eqref{eq:seq} it cannot be reached again due to the bandwidth constraint.\n\\item A sequence $U_1 f V_1 f' W_1$: Let ${\\mathcal{P}}$ be a feasible path from $S$ to $D$ containing a sequence $U_1 f V_1 f' W_1$ (where $U_1$ and $W_1$ may be the same node). These three nodes can only encapsulate protocol $a$ or $b$ in protocol $b$. Thus, after crossing such a sequence, there are three occurrences of protocol $b$ on the top of the protocol stack. However, in network ${\\mathcal{N}}$, there is no possible sequence of nodes and adaptation functions able to decapsulate protocol $b$ three consecutive times. Thus, ${\\mathcal{P}}$ is not feasible.\n\\end{itemize}\nThus, if a feasible path exists, then it contains only one occurrence of Sequence~\\eqref{eq:seq} for each node $U'\\in{\\mathcal{V}}'$. Replacing each Sequence~\\eqref{eq:seq} by the corresponding node in ${\\mathcal{V}}'$ induces a Hamiltonian path in ${\\mathcal{H}}$. This concludes the proof. \n\\end{proof}\n\nUnfortunately, the previous negative result implies:\n\\begin{corollary}\nProblem~\\eqref{def:BFP} is not approximable (unless $\\mathsf{P}=\\mathsf{NP}$).\n\\end{corollary}\n\t\n\\begin{proof}\nSince the existence of a feasible path (independently of its cost) is $\\mathsf{NP}$-complete to decide, any polynomial approximation algorithm would imply $\\mathsf{P}=\\mathsf{NP}$.\n\\end{proof}\t\nOn the other hand, the problem is tractable on some particular topologies:\n\\begin{corollary}\n\\label{cor:DAG}\nProblems~\\eqref{def:BFP} and (\\ref{def:BFP}') are polynomial if the graph ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is a Directed Acyclic Graph (DAG).\n\\end{corollary}\n\n\\begin{proof}\nThe $\\mathsf{NP}$-completeness of Problem~(\\ref{def:BFP}') results from the fact that the bandwidth constraint is not prunable when feasible paths involve loops. In a DAG, every link is involved at most once in a feasible path due to the absence of cycles. Thus the bandwidth constraint is prunable and the problem can be resolved using the method described in Section~\\ref{sec:without}.\n\\end{proof}\n\n\\subsection{DAG Heuristic}\nAs seen in Section~\\ref{sec:trans_phase}, shortest feasible paths involving loops are infrequent (for $p>20\\%$). Combining this fact with Corollary~\\ref{cor:DAG} suggests a heuristic to compute feasible path under bandwidth constraint: Convert the network into a DAG and perform the PDA algorithm to compute a shortest feasible path.\n\n\\noindent{\\bf DAG Conversion.} The network is converted into a DAG in the following way:\n\\begin{enumerate}\n\\item Set the number $0$ to node $S$ and $|{\\mathcal{V}}|-1$ to node $D$ (recall that $S$ and $D$ are the extremities of the graph diameter);\n\\item Perform a BFS algorithm starting from node $S$ and number the nodes in the visit order. The nodes at the same distance from $S$ are visited randomly, thus performing several times this heuristic does not always give the same node numbering and the same DAG;\n\\item Delete all the links that start at a node and end at a node with a smaller number.\n\\end{enumerate}\n\nThe DAG heuristic is as follows:\n\\begin{enumerate}\n\\item Convert the network into a DAG; \n\\item Prune the links without enough bandwidth;\n\\item Perform the PDA algorithm of Section~\\ref{sec:without}.\n\\end{enumerate}\n\n\n\\subsection{Simulations}\nWe study the efficiency of the DAG heuristic (called DAG-PDA) and compare it with the algorithm of Kuipers and Dijkstra~\\cite{K09}. The latter is an exact (and thus exponential) algorithm that performs a BFS and explores all the paths that are not dominated and that satisfy the bandwidth constraint. As in Section~\\ref{sec:simul_without_bandwidth}, the BFS algorithm is slow. Thus, we also compare our algorithm with DAG-BFS algorithm, where the network is converted into a DAG before performing the BFS.\nThe simulation conditions (parameters, topology, number of runs, etc.) are the same as in Section~\\ref{sec:simul_without_bandwidth}. The bandwidth capacity of the links is randomly and uniformly selected in the set $\\{1,2,\\dots,10\\}$. The bandwidth constraint is set to $2$.\n\\subsubsection{Comparison of the feasibility ratio}\nConverting the network topology into a DAG deletes some feasible paths in the original network. We measure how much feasible paths are lost by comparing the probability of feasible path existence before and after the DAG conversion according to the probability of existence of adaptation functions ($p$).\n \\begin{figure} \n \\centering\n \\includegraphics[width=0.45\\textwidth]{trans_phase_dag2.png}\n \\caption{Probability of feasible path existence before and after DAG conversion on Topologies $T1$ and $T2$.}\n \\label{fig:trans_phase_dag}\n \\end{figure}\nFigure~\\ref{fig:trans_phase_dag} shows that the probability of feasible path existence is shifted to the right after the DAG conversion. The ratio $\\frac{\\text{Probability of feasible path existence in T}i}{\\text{Probability of feasible path existence in DAG T}i}$ ($i=1,2$) is clearly decreasing and is less than $50\\%$ if $p>0.34$, which is important but balanced by the improvement of the processing time.\n\n\\subsubsection{Comparison of the processing time}\n\n \\begin{figure} \n \\centering\n \\includegraphics[width=0.45\\textwidth]{DAG-PDA_vs_DAG-BFS2.png}\n \\caption{Comparison of the processing time of DAG-PDA, DAG-BFS and BFS algorithms on Topologies $T1$ and $T2$.}\n \\label{fig:dag_pda}\n \\end{figure}\n\nFigure~\\ref{fig:dag_pda} shows the processing time of DAG-PDA, DAG-BFS and BFS algorithms on both topologies according to the probability of existence of an adaptation function. BFS algorithm is slow even for small values of $p$.\nFor $p<0.3$ (resp. $0.4$) on Topology~$T1$ (resp. $T2$), DAG-BFS is faster than DAG-PDA. Beyond these values, the processing time of DAG-BFS explodes. For example, for $p=0.5$, the processing time of DAG-BFS is more than $35$ minutes on Topology~$T1$ and more than $53$ minutes on Topology~$T2$, while that of DAG-PDA is $3.8$ seconds on $T1$ and $24$ seconds on $T2$. These results show that the DAG-PDA algorithm is clearly faster when there is a significant number of adaptation functions, but the exponential DAG-BFS algorithm is faster if there are few of them (for small values of $p$).\n\n\n\\section{Path computation under QoS constraints}\n\\label{sec:qos2}\n\\subsection{Multi-constrained feasible path}\n\\label{sec:multi_cons}\nLet ${\\mathcal{N}}$ be a multi-layer network. Each link $E=(U,V)$ is associated to a set of $m$ additive QoS metrics ${q}(E)=({q}_1(E),\\dots,{q}_m(E))$ in addition to its available bandwidth ${q}_b(E)$. These additive metrics can be the delay, logarithm of the packet-loss, etc.\n\n\nLet ${q}_b^{\\min}$ be the bandwidth constraint and ${q}^{max}=({q}_1^{\\max},{q}_2^{\\max}\\dots,{q}_m^{\\max})$ be a vector of QoS constraints, the problem of computing a shortest feasible path under these constraints is formalized as:\n\n", "itemtype": "equation", "pos": 34309, "prevtext": "\nwhere $nb(E)$ is the number of times a link $E$ is crossed by path ${\\mathcal{P}}$, ${q}_b(E)$ is the bandwidth capacity of $E$ and ${q}_b^{min}$ is the bandwidth constraint.\n  \n\\subsection{Path computation complexity under bandwidth constraint}\nThe bandwidth constraint impacts the complexity of feasible path computation. In a single-layer network, computing a path under bandwidth constraint is trivial: It suffices to prune all the links without enough bandwidth. This is no longer possible in a multi-layer network. In fact, the decision problem is $\\mathsf{NP}$-complete as shown by Kuipers and Dijkstra~\\cite{K09}. But this proof does not work on symmetric directed graphs\\footnote{A symmetric directed graph is a graph where a link $(U,V)$ exists if and only if the reverse link $(V,U)$ exists.}. However, most communication networks are symmetric. We show that the decision version of the problem remains $\\mathsf{NP}$-complete even with two protocols and in a symmetric graph. Consider the following problem:\n\n\n\n{\\bf Problem (\\ref{def:BFP}')}. Given a multi-layer network ${\\mathcal{N}}=({\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}}), {\\mathcal{A}}, {\\mathcal{F}},h)$, a function  assigning to each link $E\\in{\\mathcal{E}}$ an available bandwidth ${q}_b(E)$, a bandwidth constraint ${q}_b^{min}$ and a pair $S$ and $D$ of nodes in ${\\mathcal{V}}$. Is there a feasible path from $S$ to $D$ satisfying the bandwidth constraint?\n\n\\begin{proposition}\n\\label{prop:NPsym}\nProblem~(\\ref{def:BFP}') is $\\mathsf{NP}$-complete with two protocols even if ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is a symmetric directed graph.\n\\end{proposition}\n\n\n\n\\begin{proof}\nClearly, the problem is in $\\mathsf{NP}$. Thus, we only detail the proof of $\\mathsf{NP}$-hardness.\n\nFirst consider the problem of finding a Hamiltonian path in a symmetric directed graph between two nodes $S'$ and $D'$. Call this problem SYM-HAM. SYM-HAM is $\\mathsf{NP}$-complete (for a detailed proof, see Appendix~\\ref{app:np-complete}).\n\n\nNow we provide a polynomial reduction from SYM-HAM to Problem~(\\ref{def:BFP}') restricted to symmetric directed graph and two protocols. Given an instance of SYM-HAM, i.e., a symmetric directed graph ${\\mathcal{H}}=({\\mathcal{V}}',{\\mathcal{E}}')$ and a pair of nodes $(S',D')$, we build an instance of Problem~(\\ref{def:BFP}'), i.e., a network ${\\mathcal{N}}=({\\mathcal{G}}, {\\mathcal{A}}, {\\mathcal{F}}, h)$ and a pair of nodes $(S,D)$ as following:\n\n\\noindent{\\bf Step~1: Splitting the nodes.} For each node $U'\\in {\\mathcal{V}}'$, four nodes $U_1,U_2, U_3$ and $U_4$ are created in ${\\mathcal{G}}$. Links $(U_i,U_{i+1})$ and $(U_{i+1},U_{i})$ are created for $i=1,\\dots,3$. For each link $(U',V')\\in {\\mathcal{E}}'$, a link $(U_1,V_1)$ is created in ${\\mathcal{G}}$. This step is illustrated on Figure~\\ref{fig:reduc_nodes_sym}.\n\n\\noindent{\\bf Step~2: Adding a tail.} ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is augmented by a set ${\\mathcal{C}}=\\{C_0,\\dots, C_{n+1}\\}$ of nodes ($n=|{\\mathcal{V}}'|$), where $C_0=S$ is the source node. There are a link $(C_i,C_{i+1})$ and a link $(C_{i+1},C_i)$ for $i=0,\\dots,n$. Moreover, there is also a link from $C_{n+1}$ to $S_1$ (the first node resulting from the splitting of $S'$) and conversely. Figure~\\ref{fig:reduc_graph_sym} shows this construction. Finally, two nodes $X$ and $D$ are added, as well as the four links $(D_1,X),(X,D_1),(X,D)$ and $(D,X)$ (recall that $D_1$ is the first node resulting from the splitting of $D'$, see Step~$1$).\n\n\n\\noindent{\\bf Step~3: Allocating the adaptation functions and available bandwidth.} All the links have available bandwidth $1$. The bandwidth constraint is set to $1$. Thus, any feasible path must cross a link at most once. There is no possible loop. \nLet the set of protocols be ${\\mathcal{A}}=\\{a,b\\}$. Node $S$ emits packets of protocol $a$. For $i=1\\dots,n$, each node $C_i$ in the tail can encapsulate protocol $a$ in itself. Node $C_{n+1}$ can only encapsulate $a$ in $b$. For each node $U'\\in{\\mathcal{V}}'$, node $U_1$ can encapsulate any protocol in $b$. Node $U_2$ can either decapsulate protocol $b$ from itself or passively transmit protocol $a$. Node $U_3$ can either decapsulate protocol $a$ from $b$ or passively transmit protocol $a$. Node $U_4$ is able to decapsulate protocol $a$ from itself. Finally, node $X$ can decapsulate protocol $a$ from $b$. Table~\\ref{tab:functions} summarizes the allocation of the adaptation functions.\n\n\\begin{figure*}[htb]\n\\centering\n\\includegraphics[width=0.65\\textwidth]{reduc_nodes_sym.png}\n\\centering\n\\caption{Reduction from SYM-HAM to feasible path under bandwidth constraint (node splitting).}\n\\label{fig:reduc_nodes_sym}\n\\end{figure*}\n\n\\begin{figure*}[htb]\n\\centering\n\\hspace{10mm}\n\\includegraphics[width=0.98\\textwidth]{reduc_graph_sym.png}\n\\caption{Reduction from SYM-HAM to feasible path under bandwidth constraint (graph transformation).}\n\\label{fig:reduc_graph_sym}\n\\end{figure*}\n\n\\begin{table}\n\t\\centering\n\t\t\\begin{tabular}{|l|l|}\n\t\t\\hline\n\t\t\tNode & Adaptation functions \\\\\n\t\t\t\\hline\n\t\t\t$C_i,\\ i=1\\dots n$  & $(a\\rightarrow aa)$ \\\\\n\t\t\t\\hline\n\t\t\t$C_{n+1}$  & $(a\\rightarrow ab)$ \\\\\n\t\t\t\\hline\n\t\t\t$U_1\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $(b\\rightarrow bb)$, $(a\\rightarrow ab)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_2\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(b\\rightarrow bb)}$, $(a\\rightarrow a)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_3\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(a\\rightarrow ab)}$, $(a\\rightarrow a)$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$U_4\\ s.t.\\ U'\\in{\\mathcal{V}}'$  & $\\overline{(a\\rightarrow aa)}$ \\\\\n\t\t\t\\hline\t\t\t\n\t\t\t$X$  & $\\overline{(a\\rightarrow ab)}$ \\\\\n\t\t\t\\hline\t\t\t\t\n\t\t\\end{tabular}\n\t\\caption{The adaptation functions available on the nodes in the polynomial reduction.}\n\t\\label{tab:functions}\n\\end{table}\n\nNow, we prove that there is a Hamiltonian path from $S'$ to $D'$ in ${\\mathcal{H}}$ if and only if there is a feasible path from $S$ to $D$ in ${\\mathcal{N}}$ that satisfies the bandwidth constraint.\nFirst, assuming that there is a Hamiltonian path from $S'$ to $D'$ in ${\\mathcal{H}}$, we construct a feasible path ${\\mathcal{P}}$ in ${\\mathcal{N}}$ as follows: Starting from $S$ in ${\\mathcal{N}}$, ${\\mathcal{P}}$ crosses the tail and each $C_i$ ($i=1\\dots n$) adds an occurrence of protocol $a$ in the stack of encapsulated protocols. Then crossing $C_{n+1}$ adds $b$ as current protocol. Thus, at the end of the tail, there are $n+1$ encapsulated protocols $a$ (the one emitted by $S$ and $n$ occurrences added in the tail) and the current protocol is $b$. Following the same node order as in the Hamiltonian path, replace each occurrence of a node $U'\\in{\\mathcal{V}}'$ (including $S'$ and $D'$) in the Hamiltonian path by the sequence:\n\n\n", "index": 5, "text": "\\begin{equation}\n\\label{eq:seq}\n\\begin{split}\n& U_1(b\\rightarrow bb) U_2 \\overline{(b\\rightarrow bb)} U_3 \\overline{(a\\rightarrow ab)} U_4 \\overline{(a\\rightarrow aa)} U_3 (a\\rightarrow a)\\\\\n&  U_2 (a\\rightarrow a) U_1 (a\\rightarrow ab)\n\\end{split}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\begin{split}&amp;\\displaystyle U_{1}(b\\rightarrow bb)U_{2}\\overline{(b\\rightarrow&#10;bb%&#10;)}U_{3}\\overline{(a\\rightarrow ab)}U_{4}\\overline{(a\\rightarrow aa)}U_{3}(a%&#10;\\rightarrow a)\\\\&#10;&amp;\\displaystyle U_{2}(a\\rightarrow a)U_{1}(a\\rightarrow ab)\\end{split}\" display=\"block\"><mtable columnspacing=\"0pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd/><mtd columnalign=\"left\"><mrow><msub><mi>U</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>b</mi><mo>\u2192</mo><mi>b</mi><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><msub><mi>U</mi><mn>2</mn></msub><mover accent=\"true\"><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>\u2192</mo><mrow><mi>b</mi><mo>\u2062</mo><mi>b</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00af</mo></mover><msub><mi>U</mi><mn>3</mn></msub><mover accent=\"true\"><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2192</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00af</mo></mover><msub><mi>U</mi><mn>4</mn></msub><mover accent=\"true\"><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2192</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>a</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00af</mo></mover><msub><mi>U</mi><mn>3</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>\u2192</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><msub><mi>U</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>\u2192</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow><msub><mi>U</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>\u2192</mo><mi>a</mi><mi>b</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.01786.tex", "nexttext": "\n\n\\subsection{Complexity of multi-constrained feasible path computation}\n\\label{sec:complexity}\n\nThe problem of QoS multi-constrained path computation (on a single layer) is well studied. It is well-known that the decision version associated to this problem is $\\mathsf{NP}$-complete, even with $2$ additive and/or multiplicative constraints~\\cite{Wang96}. Van~Mieghem and Kuipers~\\cite{Van04} gave an exponential time algorithm but showed that the instances that really require an exponential computation time are infrequent. \nThe classical multi-constrained path problem is a particular case of Problem~\\ref{def:MCFP}, corresponding to the case where there is only one protocol and passive transitions. Thus the decision version associated to Problem~\\ref{def:MCFP} is also $\\mathsf{NP}$-complete. \n\n\n\n\n\\subsection{ML-SAMCRA}\n\\label{sec:qos}\nAs computing a multi-layer path under QoS constraints is $\\mathsf{NP}$-complete, any algorithm able to solve this problem is exponential in the worst case (unless $\\mathsf{P}=\\mathsf{NP}$). We propose to adapt the Self-Adaptive Multiple Constraints Routing Algorithm (SAMCRA) to the multi-layer context in order to compute a shortest feasible path under QoS constraints.\n\nSAMCRA is an exact QoS routing algorithm proposed by Van Mieghem and Kuipers~\\cite{Van04}. It computes the shortest path under several (additive) QoS constraints but it ignores the feasibility constraint as defined in our paper. SAMCRA has an exponential worst case complexity, but it exhibits a reasonable processing time in practice.\n\n\\subsubsection{The main concepts of SAMCRA}\nThe idea of SAMCRA is to maintain a path list from the source node $S$ to all other nodes until reaching the destination node $D$. It progressively removes the paths that do not comply with the QoS constraints. The main concepts of SAMCRA are:\n\\begin{itemize}\n\\item \\textit{Non-linear path length:} In SAMCRA, the path length is defined as a non-linear function of the QoS parameters of each link. It reduces the solution space to scan but the algorithm can apply with any metric. Hence, it is not a strict requirement.\n\\item \\textit{The $k$-shortest path algorithm:} The $k$-shortest path algorithm maintains the list of the paths that are not (yet) removed from the path list. \n\\item \\textit{Non-dominance:} A multi-constrained path ${\\mathcal{P}}$ \\textit{dominates} another path ${\\mathcal{P}}'$ if $\\forall i, \\sum_{E\\in {\\mathcal{P}}}{q}_i(E)\\leq\\sum_{E\\in {\\mathcal{P}}'}{q}_i(E)$ (i.e., if ${\\mathcal{P}}$ is better than ${\\mathcal{P}}'$ for each QoS parameter). A path ${\\mathcal{P}}$ is non-dominated if there is no path which dominates it. The concept of non-dominance induces a partial order over the paths. It avoids the exploration of several paths thus substantially reducing the average complexity of SAMCRA. \n\\end{itemize}\nThe path length definition is not impacted by the multi-layer context and using a linear path length function is not forbidden. The $k$-shortest path algorithm is not impacted either. However, the concept of dominance must be redefined to meet the path feasibility constraint and to take into account possible loops.\n\\subsubsection{Extension of the non-dominance definition}\nA multi-layer path is characterized by its nodes but also by its protocol stack at the destination node. Thus in the algorithm path list, each path should be stored with its protocol stack at its final node. A multi-layer path can involve the same link several times. Before checking if this path complies with some QoS parameters, the parameters of each link should be multiplied by the number of times this link is involved in the path. The bandwidth constraint is not prunable in multi-layer context, the new non-dominance definition should take it into account.\n\nA path ${\\mathcal{P}}$ dominates a path ${\\mathcal{P}}'$ if the four following conditions are satisfied:\n\\begin{itemize}\n\\item $\\min_{E\\in {\\mathcal{P}}}\\frac{{q}_b(E)}{nb_{\\mathcal{P}}(E)}\\geq\\min_{E\\in{\\mathcal{P}}'}\\frac{{q}_b(E)}{nb_{{\\mathcal{P}}'}(E)}$\n\\item $\\sum_{E\\in {\\mathcal{P}}}{q}_i(E)\\times nb_{\\mathcal{P}}(E)\\leq\\sum_{E\\in{\\mathcal{P}}'}{q}_i(E)\\times nb_{{\\mathcal{P}}'}(E)$ \\\\$\\forall i=1,\\dots,m$\n\\item ${\\mathcal{P}}$ and ${\\mathcal{P}}'$ have the same final node;\n\\item ${\\mathcal{P}}$ and ${\\mathcal{P}}'$ have the same protocol stack at this node.\n\\end{itemize}\nWhere $nb_{\\mathcal{P}}(E)$ (resp. $nb_{{\\mathcal{P}}'}(E)$) is the number of times the link $E$ is involved in path ${\\mathcal{P}}$ (resp. ${\\mathcal{P}}'$). According to this new definition of non-dominance, ML-SAMCRA explores all the possible paths until reaching the destination node with satisfactory QoS parameters. Along the exploration, it removes all paths that are dominated or not feasible. \n\n\\subsection{Simulations}\nWe know study the efficiency of ML-SAMCRA through simulations and check if it is as scalable in a multi-layer context as SAMCRA in a single layer context.\n\\begin{figure} \n\\centering\n\\includegraphics[width=0.45\\textwidth]{ML-SAMCRA2.png}\n\\caption{Processing time of ML-SAMCRA Topologies $T1$ and $T2$.}\n\\label{fig:ml_samcra}\n\\end{figure}\nFigure~\\ref{fig:ml_samcra} shows the processing time of ML-SAMCRA on Topologies~$T1$ and $T2$ according to the probability of existence of an adaptation function ($p$). The results show that for $p>0.08$ (resp. $0.10$) on Topology~$T1$ (resp. $T2$) the processing time explodes (more than  $1$ minutes). Clearly, ML-SAMCRA does not scale above these values. There are two reasons:\n\\begin{enumerate}\n\\item The paths are less comparable in term of the new non-dominance definition: They should have the same protocol stack. As there are less dominated paths, the algorithm complexity increases;\n\\item Taking into account loops increases the number and the length of the paths, which also increases the algorithm complexity.\n\\end{enumerate}\nSo, path computation under QoS constraints in multi-layer networks is more complex than in single layer networks. Thus, exact algorithms are suitable only for small instances.\n\\section{Conclusion}\n\\label{sec:conclusion}\n\nMost of carrier-grade networks manage their different layers thanks to separate control planes. Designing a unified control plane would allow the network resources to be optimized and the operational management costs to be reduced. One key problem to address is path computation taking into account the protocol heterogeneity and the multi-layer context dealing with encapsulation, conversion and decapsulation of protocols. This paper tackles this issue by partitioning it into three cases: Path computation without bandwidth constraint, under bandwidth constraint and under additive QoS constraints. For the first case, we widely generalized polynomial algorithms in the state of the art and decreased their complexity. Through simulations, we showed that they outperform previous approach in the literature. For the second case, we obtained several time complexity results and proposed efficient heuristics. Finally, we designed the first algorithm to resolve the third case. In future works, we plan to design heuristics to deal with additive QoS metrics, as the exact approach seems to be not scalable. The problem of efficient generation of random topologies being widely open, it would be interesting to analytically study the phase transition phenomenon in order to generate topologies having a suitable number of feasible paths. \n\n\n\\bibliographystyle{IEEEtran}\n\n\\bibliography{automata_infocom}\n\n\n\n\\appendices\n\n\\section{Polynomial algorithms for path computation in multi-layer networks}\n\\label{appendix:algos}\nThe sequence of protocols involved in a feasible multi-layer path is a context-free language. Based on this fact,  Lamali~\\textit{et~al.}~\\cite{Lamali2013} used automata and language theory tools to compute the shortest feasible path in hops or in adaptation functions. We improve their algorithm in order to compute the shortest path according to any additive metric. We also substantially reduce its complexity.\n\\label{sec:wpda}\n\\subsection {Theoretical language aspects of multi-layer paths}\n\nConsidering a path ${\\mathcal{P}} = Sf_0U_1f_1U_2f_2\\dots U_nf_nD$, let $H_{\\mathcal{P}}=f_1\\dots f_n$ denotes the sequence of adaptation functions along ${\\mathcal{P}}$. Let define as an alphabet the set $\\overline{{\\mathcal{A}}}=\\{\\overline{a} \\mid a\\in{\\mathcal{A}}\\}$ and the set $\\underline{{\\mathcal{A}}}=\\{\\underline{a}\\mid a\\in{\\mathcal{A}}\\}$. \n\n${\\mathcal{T}}_{\\mathcal{P}} = x_1\\dots x_{n+1}$ is the sequence of protocols used along path ${\\mathcal{P}}$. It is called the \\emph{trace} of ${\\mathcal{P}}$. For each $x_i$:\n\t\\begin{itemize}\n\t\t\\item $x_i = a$ and $x_{i+1}=b$, $\\overline{b}$ or $\\underline{b}$ means that $U_i$ converts protocol $a$ into $b$ ( $a,b,\\overline{b}, \\underline{b} \\in {{\\mathcal{A}}} \\cup \\overline{{\\mathcal{A}}}\\cup \\underline{{\\mathcal{A}}}$) \n\t\t\\item $x_i = \\overline{a}$ and $x_{i+1} = b$, $\\overline{b}$ or $\\underline{b}$ means that $U_i$ encapsulates protocol $a$ in $b$\n\t\t\\item $x_i = \\underline{a}$ and $x_{i+1} = b$, $\\overline{b}$ or $\\underline{b}$ means that $U_i$ decapsulates protocol $b$ from $a$.\n\t\\end{itemize}\n\t\nHere, some additional definitions are needed.\t\nThe set of protocol conversions available on node $U$ is denoted by ${\\cal CO}(U)$. The set of encapsulations available on node $U$ is denoted by ${\\cal EN}(U)$ and the set of decapsulations  available on node $U$ is denoted by ${\\cal CO}(U)$.\n\n\t$In(U)$ (resp. $Out(U)$) is the set of protocols that node $U$ can receive (resp. send). More formally: \t\n\n\n\t\\begin{itemize}\n\t\\item If $(a\\rightarrow b)\\in {\\cal CO}(U)$ then $a\\in In(U)$ and $b\\in Out(U)$\n\t\\item If $(a\\rightarrow ab)\\in {\\cal EN}(U)$ then $a\\in In(U)$ and $b\\in Out(U)$\n\t\\item If $\\overline{(a\\rightarrow ab)}\\in {\\cal DE}(U)$ then $b\\in In(U)$ and $a\\in Out(U)$\n\t\\end{itemize}\n\n\t\nObviously, several paths can have the same trace. The set of traces of the feasible paths in a network ${\\mathcal{N}}$ is a context-free language but it is not regular as the encapsulations and decapsulations should be balanced. In fact, it is a well-parenthesized language, and thus requires a stack to be recognized and computed. PDAs are the classical tools to recognize context-free languages. Using weighted PDAs allows associating a weight to each link and adaptation function in order to model any additive metric.\n\\subsection{Definition of WPDA}\nA weighted PDA (WPDA) is a $8$-tuple\n${\\mathcal{PDA}} =({\\mathcal{S}}, {\\Sigma}, {\\Gamma}, {\\delta}, Q_0, {Z_0}, {{\\mathcal{S}}_F}, \\omega)$\n\nwhere ${\\mathcal{S}}$ is the set of states, ${\\Sigma}$ is the input alphabet, ${\\Gamma}$ is the stack symbol set (i.e., stack alphabet) not necessarily different from ${\\Sigma}$, ${\\delta}$ is the set of transitions, $Q_0$ is the initial state, ${Z_0}$ is the initial stack symbol, ${{\\mathcal{S}}_F}$ is the set of final (accepting) states and $\\omega$ is a weight function over the set of transitions (i.e., $\\omega :\\ {\\delta} \\rightarrow \\Re_+$).\n\nA transition $t\\in {\\delta}$ is denoted by $t=(Q_i,\\langle x, \\alpha, \\beta\\rangle,Q_j)$, where $Q_i$ is the state of ${\\mathcal{PDA}}$ before the transition, $Q_j$ is the state after the transition, $x\\in{\\Sigma}\\cup\\{\\epsilon\\}$ is an input symbol, $\\alpha\\in{\\Gamma}$ is the symbol which is popped from the top of the stack, and $\\beta\\in\\Gamma^*$ is the symbol sequence which is pushed on the top of the stack.\n\n{\\bf Remark.} WPDAs are more often formalized as $6$-tuples ${\\mathcal{PDA}} =({\\mathcal{S}}, {\\Gamma}, \\mathcal{M}, q_0, {Z_0}, {{\\mathcal{S}}_F})$ where $\\mathcal{M}$, called the \\textit{Push-Down transition matrix}, is a matrix over a semiring of formal power series. The input alphabet ${\\Sigma}$, the transitions set ${\\delta}$ and the weight function $\\omega$ are expressed by a single entity $\\mathcal{M}\\in((\\mathcal{R}\\langle\\langle{\\Sigma}^*\\rangle\\rangle)^{{\\mathcal{S}}\\times{\\mathcal{S}}})^{{\\Gamma}^*\\times{\\Gamma}^*}$, where $\\mathcal{R}\\langle\\langle{\\Sigma}^*\\rangle\\rangle$ denotes the collection of all power series from ${\\Sigma}^*$ into a semiring $\\mathcal{R}$. For simplification purposes, we opted for defining a WPDA as a classical PDA with a weight function over the transition set. For the theoretical foundations of WPDAs, the interested reader can refer to~\\cite{petre2009}.\n\n\n\n\\subsection{From the graph to the WPDA}\nAlgorithm~\\ref{algo:net_pda} converts a multi-layer network ${\\mathcal{N}}$ with a specified pair of nodes $(S,D)$ into a WPDA ${\\mathcal{PDA}} = ({\\mathcal{S}}, {\\Sigma}, {\\Gamma}, {\\delta}, Q_0, {Z_0}, {{\\mathcal{S}}_F}={Q_F}, \\omega)$. \n\nComputing a feasible path requires to know the current protocol and the last encapsulated one (in order to know if a decapsulation can be performed). Thus Algorithm~\\ref{algo:net_pda} creates a state $U_x$ for each node $U$ and each protocol $x\\in In(U)$. Being in state $U_x$ indicates that the current protocol is $x$. The last encapsulated protocol is the one on the top of the stack.\n\nThe conversion functions $(x\\rightarrow y)$ between node $U$ and node $V$ are turned into transitions $(U_x, \\langle x, \\alpha, \\alpha\\rangle, V_y)$ in the WPDA. The encapsulation functions $(x\\rightarrow xy)$ are converted into pushes of $x$ on the stack $(U_x, \\langle \\overline{x}, \\alpha, x\\alpha\\rangle, V_y)$ and the decapsulation functions into pops of $x$ from the stack $(U_y, \\langle \\underline{y},x, \\emptyset\\rangle, V_x)$.\n\n\\begin{algorithm}[!]\n\\caption{Convert a network into a WPDA}\n\\label{algo:net_pda}\n\\begin{algorithmic}\n\\Require A network ${\\mathcal{N}}=({\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}}), {\\mathcal{A}}, {\\mathcal{F}}, h)$, a source $S$ and a destination $D$\n\\Ensure A WPDA ${\\mathcal{PDA}}= ({\\mathcal{S}}, {\\Sigma}, {\\Gamma}, {\\delta}, Q_0, {Z_0}, \\{Q_F\\}, \\omega)$\n\n\\State ${\\Sigma} \\gets {\\mathcal{A}} \\cup \\overline{{\\mathcal{A}}}\\cup \\underline{{\\mathcal{A}}} $ ; $\\Gamma \\gets {\\mathcal{A}} \\cup \\{ {Z_0}\\} $ \n\\State Create ${\\mathcal{S}}$ (the set of states of the WPDA) according to Procedure~\\ref{algo:crea_states}\n\\State Build the transition set ${\\delta}$ according to:\n\\State \\hspace{6mm} \\--- Procedure~\\ref{algo:conv_trans} for the set of conversion functions\n\\State \\hspace{6mm} \\--- Procedure~\\ref{algo:encap_push} for the set of encapsulation functions\n\\State \\hspace{6mm} \\--- Procedure~\\ref{algo:decap_pop} for the set of decapsulation functions\n\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\\setcounter{algorithm}{0}\n\\floatname{algorithm}{Procedure}\n\n\\begin{algorithm}[!]\n\\caption{Create ${\\mathcal{S}}$, the set of states of the WPDA}\n\\label{algo:crea_states}\n\\begin{algorithmic}\n\\State Create a single state $Q_0$ corresponding to node $S$\n\\State Create a fictitious final state $Q_F$\n\\State For each node $U\\neq S$ in ${\\V}$, for each protocol $x \\in In(U)$, create a state $U_x$ \n\\For{each state $U_x$ s.t. $(S,U)\\in {\\mathcal{E}}$, for each $x\\in Out(S)$}\n\\State Create the transition $t=(Q_0, \\langle\\epsilon, Z_0, Z_0\\rangle, U_x)$\n\\State $\\omega(t) \\gets 0$\n\\EndFor\n\\For{each $x\\in In(D)$}\n\\State Create the transition $t=(D_x, \\langle x, Z_0, \\emptyset\\rangle, Q_F)$\n\\State $\\omega(t)\\gets 0$\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\\begin{algorithm}\n\\caption{Transform the conversions}\n\\label{algo:conv_trans}\n\\begin{algorithmic}\n\\For{each link $(U,V)\\in {\\mathcal{E}}$ s.t. $U\\neq S$}\n\\For{each $(x\\rightarrow y)\\in {\\cal CO}(U)$}\n\n\\If{$y\\in In(V)$}\n\t\\For{all $\\alpha\\in{\\Gamma}$}\n\t\\State Create the transition $t=(U_x, \\langle x, \\alpha, \\alpha\\rangle, V_y)$\n\t\\State $\\omega(t)\\gets h(U,(x\\rightarrow y),V)$\n\t\\EndFor\n\n\\EndIf\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\\begin{algorithm}\n\\caption{Transform the encapsulations}\n\\label{algo:encap_push}\n\\begin{algorithmic}\n\\For{each link $(U,V)\\in {\\mathcal{E}}$ s.t. $U\\neq S$}\n\\For{each $(x\\rightarrow xy)\\in {\\cal EN}(U)$}\n\n\\If{$y\\in In(V)$}\n\t\\For{all $\\alpha\\in{\\Gamma}$}\n\t\\State Create the transition $t=(U_x, \\langle \\overline{x}, \\alpha, x\\alpha\\rangle, V_y)$\n\t\\State $\\omega(t)\\gets h(U,(x\\rightarrow xy),V)$\n\t\\EndFor\n\n\\EndIf\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\\begin{algorithm}[!]\n\\caption{Transform the decapsulations}\n\\label{algo:decap_pop}\n\\begin{algorithmic}\n\\For{each link $(U,V)\\in {\\mathcal{E}}$ s.t. $U\\neq S$}\n\\For{each $\\overline{(x\\rightarrow xy)}\\in {\\cal DE}(U)$}\n\n\\If{$x\\in In(V)$}\n\t\\State Create the transition $t=(U_y, \\langle \\underline{y},x, \\emptyset\\rangle, V_x)$\n\t\\State $\\omega(t)\\gets h(U,\\overline{(x\\rightarrow xy)},V)$\n\n\\EndIf\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\\floatname{algorithm}{Algorithm}\n\\setcounter{algorithm}{1}\n\n\n\\noindent{\\bf Complexity of Algorithm~\\ref{algo:net_pda}.} The complexity of Algorithm~\\ref{algo:net_pda} is in $O(|{\\mathcal{A}}|^3\\times|{\\mathcal{E}}|)$. The number of states created by Procedure~\\ref{algo:crea_states} is at worst $2+|{\\mathcal{A}}|\\times(|{\\mathcal{V}}|-1)$, and the complexity of Procedure~\\ref{algo:crea_states} is in $O(|{\\mathcal{A}}|\\times|{\\mathcal{V}}|)$. The number of transitions created by Procedure~\\ref{algo:conv_trans} and by Procedure~\\ref{algo:encap_push} is in $O(|{\\mathcal{A}}|^3\\times|{\\mathcal{E}}|)$, which is also an upper bound for their complexity. The complexity of Procedure~\\ref{algo:decap_pop} is bounded by $O(|{\\mathcal{A}}|^2\\times|{\\mathcal{E}}|)$. \n\n\\begin{proposition}\n\\label{prop:equi}\nA path ${\\mathcal{P}}$ in a network ${\\mathcal{N}}$ is feasible if and only if its trace ${\\mathcal{T}}_{\\mathcal{P}}$ is accepted by ${\\mathcal{PDA}}$. \n\\end{proposition}\n\n\\begin{proof}\nConsider a feasible path ${\\mathcal{P}}=Sf_0U_1f_1U_2f_2\\dots U_nf_nD$. By construction, for each $3$-tuple $(U_i,f_i,U_{i+1})$ there is a transition:\n\\begin{itemize} \n\\item $t=({(U_i)}_x,\\langle x,\\alpha,\\alpha\\rangle,{(U_{i+1})}_y)$ if $f_i=(x\\rightarrow y)$\n\\item $t=({(U_i)}_x,\\langle \\overline{x},\\alpha,x\\alpha\\rangle,{(U_{i+1})}_y)$ if $f_i=(x\\rightarrow xy)$\n\\item $t=({(U_i)}_x,\\langle \\underline{x},y,\\emptyset\\rangle,{(U_{i+1})}_y)$ if $f_i=\\overline{(y\\rightarrow yx)}$\n\\end{itemize}\nThis transition recognizes the $i$-th letter of the trace ${\\mathcal{T}}_{\\mathcal{P}}$. It is easy to show by induction that ${\\mathcal{T}}_{\\mathcal{P}}$ is accepted by the automaton.\n\nConversely, if a trace ${\\mathcal{T}}_{\\mathcal{P}}$ is accepted by a transition sequence $t_1\\dots t_n$ where each $t_i=({(U_i)}_x,\\langle x,\\alpha,\\beta\\rangle,{(U_{i+1})}_y)$. Then there is an adaptation function:\n\\begin{itemize}\n\\item $f_i=(x\\rightarrow y)\\in {\\cal CO}(U_i)$ if $t_i=({(U_i)}_x,\\langle x,\\alpha,\\alpha\\rangle,{(U_{i+1})}_y)$\n\\item $f_i=(x\\rightarrow xy)\\in {\\cal EN}(U_i)$ if $t_i=({(U_i)}_x,\\langle \\overline{x},\\alpha,x\\alpha\\rangle,{(U_{i+1})}_y)$\n\\item $f_i=\\overline{(y\\rightarrow yx)}\\in {\\cal DE}(U_i)$ if $t_i=({(U_i)}_x,\\langle \\underline{x},y,\\emptyset\\rangle,{(U_{i+1})}_y)$\n\\end{itemize}\nThus the path $Sf_0U_1f_1U_2f_2\\dots U_nf_nd$ is feasible in ${\\mathcal{N}}$.\n\\end{proof}\n\n\n\n\nThe weight of a path ${\\mathcal{P}}=Sf_0U_1f_1U_2f_2\\dots U_nf_nD$ is defined as the sum of the weights of its links and its adaptation functions. It is denoted by $h({\\mathcal{P}})\\overset{def}{=}\\sum_{i=1}^nh(U_i,f_i,U_{i+1})$ with $U_{n+1}=D$. \n\nWe define the weight of a transition sequence as the sum of the weights of each transition (i.e., $\\omega(\\{t_1,t_2,\\dots,t_n\\})=\\sum_{i=1}^n\\omega(t_i)$). The weigh of a word $w$, denoted by $\\omega(w)$, is the weight of the transitions that accept $w$ in ${\\mathcal{PDA}}$. But as ${\\mathcal{PDA}}$ may be nondeterministic, it is possible that several transition sequences accept the same word. Thus we consider only the sequence of transitions of minimum weight that accepts $w$. More formally, $\\omega(w)=\\min_{t_1,\\dots, t_n\\in {\\delta}}\\omega(\\{t_1,\\dots t_n\\})$ s.t. $\\{t_1,\\dots t_n\\}$ accepts $w$.\n\\begin{lemma}\nIf ${\\mathcal{PDA}}$ accepts the trace ${\\mathcal{T}}_{\\mathcal{P}}$ of a path ${\\mathcal{P}}$, then $\\omega({\\mathcal{T}}_{\\mathcal{P}})=h({\\mathcal{P}}^*)$, where ${\\mathcal{P}}^*$ is the path of minimum weight having ${\\mathcal{T}}_{\\mathcal{P}}$ as trace.\n\\end{lemma}\n\\begin{proof}\nBy definition, $\\omega({\\mathcal{T}}_{\\mathcal{P}})=\\omega(\\{t_1,\\dots,t_n\\})$, where $\\{t_1,\\dots,t_n\\}$ is the transition sequence with minimal weight which accepts ${\\mathcal{T}}_{\\mathcal{P}}$. From $\\{t_1,\\dots,t_n\\}$, it is possible to build the path ${\\mathcal{P}}^*$ (inversing the conversion in Algorithm~\\ref{algo:net_pda}) such that ${\\mathcal{T}}_{{\\mathcal{P}}^*}={\\mathcal{T}}_{\\mathcal{P}}$ and $h({\\mathcal{P}}^*)=\\omega({\\mathcal{T}}_{\\mathcal{P}})$.\n\nSuppose that $\\exists {\\mathcal{P}}'$ s.t. ${\\mathcal{T}}_{{\\mathcal{P}}'}={\\mathcal{T}}_{\\mathcal{P}}$ and $h({\\mathcal{P}}')<\\omega({\\mathcal{T}}_{\\mathcal{P}})$, then it is possible to build from ${\\mathcal{P}}'$ a sequence of transitions that corresponds to the links and adaptation functions involved in ${\\mathcal{P}}'$ (as in Algorithm~\\ref {algo:net_pda}). Let this sequence be $t_1'\\dots,t_n'$. The weight of each transition $t_i'$ corresponds to the weight of an adaptation function associated to a link in ${\\mathcal{P}}'$. The weight of $t_1'\\dots,t_n'$ is then less than $\\omega({\\mathcal{T}}_{\\mathcal{P}})$, and by Proposition~\\ref{prop:equi}, this sequence accepts ${\\mathcal{T}}_{\\mathcal{P}}$. This is inconsistent with the definition of $\\omega({\\mathcal{T}}_{\\mathcal{P}})$.\n\\end{proof}\n\n\n\n\\subsection{Computing the minimal weight trace} \n\\label{sec:short_word}\nIn order to compute the minimum weight trace and its corresponding path, ${\\mathcal{PDA}}$ is converted into a weighted Context-Free Grammar (WCFG). \n\n\\subsubsection{From the WPDA to a WCFG} \n\\label{sec:pda-cfg}\nA WCFG is a CFG with a weight function over the set of production rules. The conversion of a PDA into a CFG is well-known. The conversion of a WPDA into a WCFG is done in the same way, in addition the weight of each transition is assigned to the corresponding production rules (called rules in Algorithm~\\ref{WPDA-WCFG}) in the WCFG.\n\nAlgorithm~\\ref{WPDA-WCFG} is an adaptation of the general method described in~\\cite{Hop06}. It converts ${\\mathcal{PDA}}$ into a WCFG ${\\mathcal{CFG}}= ({\\mathcal Q},\\Sigma, [Q_0],{\\mathcal R},\\pi)$ where:\n\\begin{itemize}\n\\item ${\\mathcal Q}$ is the set of nonterminals,\n\\item $\\Sigma$ is the alphabet or set of terminals (the same as the WPDA input alphabet),\n\\item $[Q_0]$ is the initial symbol (initial nonterminal, or axiom),\n\\item ${\\mathcal R}$ is the set of production rules,\n\\item $\\pi : {\\mathcal R}\\rightarrow \\Re_+$ is the weight function over the set of production rules.\n\\end{itemize}\n\n\n\\begin{algorithm}\n\\caption{Convert a WPDA into a WCFG}\n\\label{WPDA-WCFG}\n\\begin{algorithmic}\n\\Require ${\\mathcal{PDA}} = ({\\mathcal{S}}, {\\Sigma}, {\\Gamma}, {\\delta}, Q_0, {Z_0}, \\{Q_F\\}, \\omega)$\n\\Ensure ${\\mathcal{CFG}}= ({\\mathcal Q},\\Sigma, [Q_0],{\\mathcal R},\\pi)$\n\\State Create the axiom $[Q_0]$\n\\For{each state $U_x \\in {\\mathcal{S}}$}\n\t\\State Create the nonterminal $[Q_0Z_0U_x]$ \n\t\\State Create the rule $[Q_0] \\rightarrow [Q_0Z_0U_x]$\n\\EndFor\n\\For{each transition $(U_x,\\langle x,\\alpha,\\beta \\rangle,V_y)$}\n\t\\If{$\\beta=\\emptyset$ (pop)}\n\t\t\\State Create a nonterminal $[U_x\\alpha V_y]$ \n\t\t\\State Create the rule $r = [U_x\\alpha V_y] \\rightarrow x$\n\t\t\\State $\\pi(r)\\gets \\omega(U_x,\\langle x,\\alpha,\\emptyset \\rangle,V_y)$\n\t\\EndIf\n\t\\If{$\\beta=\\alpha$ (conversion transition)}\n\t\t\\For{each $Q_i\\in {\\mathcal{S}}$}\n\t\t\\State Create nonterminals $[U_x\\alpha Q_i]$ and $[V_y\\alpha Q_i]$\n\t\t\\State Create the rule $r=[U_x\\alpha Q_i] \\rightarrow x[V_y\\alpha Q_i]$\n\t\t\\State $\\pi(r)\\gets \\omega(U_x,\\langle x,\\alpha,\\beta\\rangle,V_y)$\n\t\t\\EndFor\n\t\\EndIf\n\t\\If{$\\beta=x\\alpha, \\ x \\in \\Gamma$ (push)}\n\t \t\\For{each $(Q_i,Q_j)\\in {{\\mathcal{S}}}^2$}\n\t\t\\State Create nonterminals $[U_x\\alpha Q_j]$, $[V_y\\alpha Q_i]$ and $[Q_i\\alpha Q_j]$\n\t\t\\State Create the rule $r=[U_x\\alpha Q_j] \\rightarrow x[V_yxQ_i][Q_i\\alpha Q_j]$\n\t\t\\State $\\pi(r)\\gets \\omega(U_x,\\langle x,\\alpha,x\\alpha\\rangle,V_y)$\n\t\t\\EndFor\n\t\\EndIf\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\\noindent{\\bf Complexity of Algorithm~\\ref{WPDA-WCFG}.} The number of nonterminals is bounded by $O(|\\Gamma|\\times|{\\mathcal{S}}|^2)$ (as each nonterminal is in the form $[Q_ixQ_j]$ with $Q_i,Q_j\\in{\\mathcal{S}}$ and $x\\in \\Gamma$. The number of production rules is bounded by $O(|{\\delta}|\\times|{\\mathcal{S}}|^2)$. Thus the worst case complexity of Algorithm \\ref{WPDA-WCFG} is bounded by $O(|\\delta|\\times|{\\mathcal{S}}|^2)$. This corresponds to $O\\left(|{\\mathcal{A}}|^5\\times|{\\mathcal{V}}|^2\\times|{\\mathcal{E}}|\\right)$.\n\n\n\\subsubsection{The minimum weight derivation tree}\n\\label{sec:min_trace}\nGenerating the minimum weight trace (and then the minimum weight path) requires to build its derivation tree. Let $[X]$ be a nonterminal, we define $\\ell([X])$ as the sum of the weights of the productions needed for, starting from $[X]$, deriving a word in ${\\Sigma}^*$. Thus $\\ell([Q_0])$ is the weight of the minimum weight trace.\n\nThe function is $\\ell :{\\{{\\mathcal Q}\\cup \\Sigma \\cup \\{\\epsilon\\}\\}}^*\\rightarrow \\mathbb{N}\\cup\\{\\infty\\}$ s.t.:\n\\begin{itemize}\n\\item if $w = \\epsilon$ or $w \\in{\\Sigma}$ then $\\ell(w) = 0$,\n\\item if $w=\\alpha_1\\dots\\alpha_n$ (with $\\alpha_i \\in \\{{\\mathcal Q}\\cup \\Sigma \\cup \\{\\epsilon\\}\\}$) then $\\ell(w) = \\sum_{i=1}^n\\ell(\\alpha_i)$.\n\\item Let $r_1=[X]\\rightarrow \\gamma_1,r_2=[X]\\rightarrow \\gamma_2,\\dots,r_k=[X]\\rightarrow\\gamma_k$ be the set of production rules having $[X]$ as left part. Then $\\ell([X])=\\min\\{\\pi(r_1)+\\ell(\\gamma_1),\\dots,\\pi(r_k)+\\ell(\\gamma_k)\\}$\n\\end{itemize}\n\nKnuth's algorithm~\\cite{Knuth77} can be adapted to compute the minimum weight derivation tree of a grammar. This corresponds to the weight of ${\\mathcal{T}}_{\\mathcal{P}}$, where ${\\mathcal{P}}$ is the shortest path to compute. The adapted algorithm maintains a list of production rules and updates the $\\ell[X]$ according to the formula above. The sketch of the algorithm is as follows:\n\\begin{itemize}\n\\item Initialize $\\ell([X])$ to $\\infty$ for each nonterminal $[X]$\n\\item  For each production rule $[X]\\rightarrow \\alpha_1\\dots \\alpha_n$ update $\\ell([X])$ as follows:\n\\\\$\\ell([X]) \\gets \\min\\{\\ell([X]),\\pi(r)+\\sum_{i=1}^n\\ell(\\alpha_i)\\}$\n\\end{itemize}\nThe algorithm terminates when all the $\\ell[X]$ have the right value and no additional update is possible. Implementing this algorithm with Fibonacci heaps leads to a $O(|\\mathcal{Q}|\\log|\\mathcal{Q}|+\\mathcal{|R|})$ complexity~\\cite{Tarjan1987}, which corresponds to $O(|{\\mathcal{A}}|^5\\times|V|^2\\times|{\\mathcal{E}}|)$.\n\nWith the correct values of $\\ell[X]$, it is trivial to generate the word with the minimum weight derivation tree.\n\n\n\n\\subsection{Deriving the shortest path from its trace}\n\\label{sec:word-path}\nAlgorithm \\ref{find-C} is a generalization of an algorithm proposed in~\\cite{Lamali2013}.\nIt takes as input the minimum weight trace ${\\mathcal{T}}_{{\\mathcal{P}}}$ accepted by ${\\mathcal{PDA}}$ and computes the path ${\\mathcal{P}}$ that matches it\\footnote{It is possible that several paths match the trace. In this case the path can be chosen randomly or according to a load-balancing policy.}. \n\nAlgorithm \\ref{find-C} starts on $nodes[1]=S$ then checks at each step all the links in ${\\mathcal{E}}$ which match the current letter (protocol) in ${\\mathcal{T}}_{\\mathcal{P}}$. If ${\\mathcal{T}}_{\\mathcal{P}} = x_1x_2\\dots x_n$ $(x_i \\in {\\mathcal{A}}\\cup\\overline{{\\mathcal{A}}}\\cup\\underline{{\\mathcal{A}}})$, then at each step $i$, the algorithm starts from each node $U$ in $nodes[i]$ and adds to $links[i]$ all the links $(U,V)$ which match $x_i$. Each $V$ is added in $nodes[i+1]$. The value $weights[(U,V),i]$ is the cost of using link $(U,V)$ at step $i$. It corresponds to the weight $h(U,f_i,V)$ where $f_i$ is the adaptation function used at step $i$. When the trace ${\\mathcal{T}}_{\\mathcal{P}}$ is completely covered, a classical shortest path algorithm from $S$ to $D$ in the graph $(nodes, links, weights)$ computes the minimum weight path.\n\\begin{algorithm}\n\\caption{Computing the shortest path}\n\\label{find-C}\n\\begin{algorithmic}\n\\Require{The network ${\\mathcal{N}}$ and ${\\mathcal{T}}_{\\mathcal{P}}$}\n\\Ensure{The shortest path ${\\mathcal{P}}$}\n\\State $nodes[1] \\gets S$ ; $i \\gets 2$\n\\While{The trace is not completely covered}\n\\For{each $U \\in nodes[i]$, $V \\in{\\V} \\ s. t.\\ (U,V) \\in {\\mathcal{E}}$}\n\t\\If{$x_i\\in{\\mathcal{A}}$, $x_i\\in Out(U)$, $x_i\\in In(V)$ and $(x_{i-1}\\rightarrow x_i)\\in {\\cal CO}(U)$}\n\t\t\\State Add $(U,V)$ in $links[i]$ and $V$ in $nodes[i+1]$\n\t\t\\State $weights[(U,V),i]\\gets h(U,(x_{i-1}\\rightarrow x_i),V)$\n\t\\EndIf\n\t\\If{$x_i\\in\\overline{{\\mathcal{A}}}$, $x_i\\in Out(U)$, $x_i\\in In(V)$ and $(x_{i-1}\\rightarrow x_{i-1}x_i)\\in {\\cal EN}(U)$}\n\t\t\\State Add $(U,V)$ in $links[i]$ and $V$ in $nodes[i+1]$\n\t\t\\State $weights[(U,V),i]\\gets h(U,(x_{i-1}\\rightarrow x_{i-1}x_i),V)$\n\t\\EndIf\n\t\\If{$x_i\\in\\underline{{\\mathcal{A}}}$, $x_i\\in Out(U)$, $x_i\\in In(V)$ and $\\overline{(x_i\\rightarrow x_ix_{i-1})}\\in {\\cal DE}(U)$}\n\t\t\\State Add $(U,V)$ in $links[i]$ and $V$ in $nodes[i+1]$\n\t\t\\State $weights[(U,V),i]\\gets h(U,\\overline{(x_i\\rightarrow x_i x_{i-1})},V)$\n\t\\EndIf\n\\EndFor\n\\State $i++$\n\\EndWhile\n\\State Compute The shortest path from $S$ to $D$ in $(nodes, links)$\n\\end{algorithmic}\n\\end{algorithm}\n\n\\noindent{\\bf Complexity of Algorithm \\ref{find-C}.} The complexity of Algorithm \\ref{find-C} is bounded by $O(|{\\mathcal{T}}_{\\mathcal{P}}|\\times|{\\mathcal V}|\\times|{\\mathcal{E}}|)$ in the worst case.\n\n\n\n\\section{Proof that SYM-HAM is $\\mathsf{NP}$-complete}\n\\label{app:np-complete}\n{\\bf Problem SYM-HAM.} Given a directed symmetric graph ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ and a pair of nodes $(S,D)$, is there a Hamiltonian path from $S$ to $D$ in ${\\mathcal{G}}$?\n\n\\begin{proposition}\nSYM-HAM is $\\mathsf{NP}$-complete.\n\\end{proposition}\n\n\\begin{proof}\nFirst, it is clear that SYM-HAM is in $\\mathsf{NP}$. Thus, we prove its $\\mathsf{NP}$-hardness by providing a polynomial reduction from the Hamiltonian path problem in \\emph{undirected} graphs to SYM-HAM. Consider an undirected graph ${\\mathcal{H}}=({\\mathcal{V}}',{\\mathcal{E}}')$ and a pair of nodes $(S',D')$. It is $\\mathsf{NP}$-complete to know whether there is an undirected Hamiltonian path between $S'$ and $D'$. The reduction builds an instance of SYM-HAM as follows:\n A graph ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ where ${\\mathcal{V}}={\\mathcal{V}}'$. For each undirected edge $(U,V)$ in ${\\mathcal{H}}$, create the directed links $(U,V)$ and $(V,U)$ in ${\\mathcal{G}}$.\n\nLet ${\\mathcal{P}}'=SU_1U_2\\dots U_nD$ be a Hamiltonian path in ${\\mathcal{H}}$. For each edge $(U_i,U_{i+1})$ in ${\\mathcal{H}}$, one can take the corresponding directed link $(U_i,U_{i+1})$ in ${\\mathcal{G}}$ and construct a Hamiltonian path in ${\\mathcal{G}}$.\n\nNow let ${\\mathcal{P}}'=SU_1U_2\\dots U_nD$ be a (directed) Hamiltonian path in ${\\mathcal{G}}$. By replacing each link $(U_i,U_{i+1})$ by the corresponding undirected edge (in ${\\mathcal{H}}$), one obtains a path visiting all the nodes exactly once in ${\\mathcal{H}}$ (as ${\\mathcal{G}}$ and ${\\mathcal{H}}$ have the same set of nodes). Thus, the obtained path is a Hamiltonian path in ${\\mathcal{H}}$.\n\nSo ${\\mathcal{H}}$ admits an undirected Hamiltonian path between $S'$ and $D'$ if and only if ${\\mathcal{G}}$ admits a directed Hamiltonian path from $S$ to $D$.\n\\end{proof}\n\n\n\n\n\n", "itemtype": "equation", "pos": 43653, "prevtext": "\n\nThus, at node $U_1$ an encapsulation of protocol $b$ occurs, at $U_2$ protocol $b$ is decapsulated, at $U_3$ it is decapsulated again, and at $U_4$ protocol $a$ is decapsulated. Path ${\\mathcal{P}}$ then crosses passively nodes $U_3$ and $U_2$, and finally encapsulates protocol $b$ at $U_1$. Thus, at each time the path crosses a Sequence~\\eqref{eq:seq}, then one occurrence of protocol $a$ is removed from the protocol stack. Crossing all $U_4$ s.t. $U'\\in{\\mathcal{H}}$ removes all encapsulated occurrences of protocol $a$ except the first one. When the path  leaves $D_1$ to reach node $X$, the current protocol is $b$ and there is a last occurrence of protocol $a$ which is encapsulated. Finally, node $X$ decapsulates protocol $a$ from protocol $b$ and node $D$ receives protocol $a$ as emitted by $S$. Thus, ${\\mathcal{P}}$ is a feasible path, and each link is crossed at most once, the bandwidth constraint is satisfied. \n\nConversely, we show that from any feasible path ${\\mathcal{P}}$ satisfying the bandwidth constraint in ${\\mathcal{N}}$, one can extract a Hamiltonian path between $S'$ and $D'$ in ${\\mathcal{H}}$. A feasible path must cross all nodes $U_4$ s.t. $U'\\in{\\mathcal{V}}'$ in order to decapsulate all occurrences of protocol $a$ encapsulated when crossing the tail. Thus, it involves Sequence~\\eqref{eq:seq} for all $U'\\in {\\mathcal{V}}'$. By removing the tail part and the nodes $X$ and $D$ from ${\\mathcal{P}}$ and replacing each occurrence of Sequence~\\eqref{eq:seq} by the corresponding node $U'$, the resulting path starts from $S'$ and crosses all the nodes in ${\\mathcal{H}}$ before reaching $D'$. The only problem is the possibility that there are other sequences than Sequence~\\eqref{eq:seq} in the remaining path. There are two possible cases:\n\\begin{itemize}\n\\item An \\emph{incomplete} Sequence~\\eqref{eq:seq} where $U_4$ is not reached (e.g., $U_1 f U_2 f' U_3 f'' U_2 f''' U_1$): This cannot happen because such a sequence forbids to reach $U_4$ later, and thus one encapsulated occurrence of protocol $a$ is never decapsulated and ${\\mathcal{P}}$ cannot be feasible. Such a sequence cannot occur after an occurrence of Sequence~\\eqref{eq:seq} on the same nodes because if a node $U_i$ ($i=2,3$) is reached in a Sequence~\\eqref{eq:seq} it cannot be reached again due to the bandwidth constraint.\n\\item A sequence $U_1 f V_1 f' W_1$: Let ${\\mathcal{P}}$ be a feasible path from $S$ to $D$ containing a sequence $U_1 f V_1 f' W_1$ (where $U_1$ and $W_1$ may be the same node). These three nodes can only encapsulate protocol $a$ or $b$ in protocol $b$. Thus, after crossing such a sequence, there are three occurrences of protocol $b$ on the top of the protocol stack. However, in network ${\\mathcal{N}}$, there is no possible sequence of nodes and adaptation functions able to decapsulate protocol $b$ three consecutive times. Thus, ${\\mathcal{P}}$ is not feasible.\n\\end{itemize}\nThus, if a feasible path exists, then it contains only one occurrence of Sequence~\\eqref{eq:seq} for each node $U'\\in{\\mathcal{V}}'$. Replacing each Sequence~\\eqref{eq:seq} by the corresponding node in ${\\mathcal{V}}'$ induces a Hamiltonian path in ${\\mathcal{H}}$. This concludes the proof. \n\\end{proof}\n\nUnfortunately, the previous negative result implies:\n\\begin{corollary}\nProblem~\\eqref{def:BFP} is not approximable (unless $\\mathsf{P}=\\mathsf{NP}$).\n\\end{corollary}\n\t\n\\begin{proof}\nSince the existence of a feasible path (independently of its cost) is $\\mathsf{NP}$-complete to decide, any polynomial approximation algorithm would imply $\\mathsf{P}=\\mathsf{NP}$.\n\\end{proof}\t\nOn the other hand, the problem is tractable on some particular topologies:\n\\begin{corollary}\n\\label{cor:DAG}\nProblems~\\eqref{def:BFP} and (\\ref{def:BFP}') are polynomial if the graph ${\\mathcal{G}}=({\\mathcal{V}},{\\mathcal{E}})$ is a Directed Acyclic Graph (DAG).\n\\end{corollary}\n\n\\begin{proof}\nThe $\\mathsf{NP}$-completeness of Problem~(\\ref{def:BFP}') results from the fact that the bandwidth constraint is not prunable when feasible paths involve loops. In a DAG, every link is involved at most once in a feasible path due to the absence of cycles. Thus the bandwidth constraint is prunable and the problem can be resolved using the method described in Section~\\ref{sec:without}.\n\\end{proof}\n\n\\subsection{DAG Heuristic}\nAs seen in Section~\\ref{sec:trans_phase}, shortest feasible paths involving loops are infrequent (for $p>20\\%$). Combining this fact with Corollary~\\ref{cor:DAG} suggests a heuristic to compute feasible path under bandwidth constraint: Convert the network into a DAG and perform the PDA algorithm to compute a shortest feasible path.\n\n\\noindent{\\bf DAG Conversion.} The network is converted into a DAG in the following way:\n\\begin{enumerate}\n\\item Set the number $0$ to node $S$ and $|{\\mathcal{V}}|-1$ to node $D$ (recall that $S$ and $D$ are the extremities of the graph diameter);\n\\item Perform a BFS algorithm starting from node $S$ and number the nodes in the visit order. The nodes at the same distance from $S$ are visited randomly, thus performing several times this heuristic does not always give the same node numbering and the same DAG;\n\\item Delete all the links that start at a node and end at a node with a smaller number.\n\\end{enumerate}\n\nThe DAG heuristic is as follows:\n\\begin{enumerate}\n\\item Convert the network into a DAG; \n\\item Prune the links without enough bandwidth;\n\\item Perform the PDA algorithm of Section~\\ref{sec:without}.\n\\end{enumerate}\n\n\n\\subsection{Simulations}\nWe study the efficiency of the DAG heuristic (called DAG-PDA) and compare it with the algorithm of Kuipers and Dijkstra~\\cite{K09}. The latter is an exact (and thus exponential) algorithm that performs a BFS and explores all the paths that are not dominated and that satisfy the bandwidth constraint. As in Section~\\ref{sec:simul_without_bandwidth}, the BFS algorithm is slow. Thus, we also compare our algorithm with DAG-BFS algorithm, where the network is converted into a DAG before performing the BFS.\nThe simulation conditions (parameters, topology, number of runs, etc.) are the same as in Section~\\ref{sec:simul_without_bandwidth}. The bandwidth capacity of the links is randomly and uniformly selected in the set $\\{1,2,\\dots,10\\}$. The bandwidth constraint is set to $2$.\n\\subsubsection{Comparison of the feasibility ratio}\nConverting the network topology into a DAG deletes some feasible paths in the original network. We measure how much feasible paths are lost by comparing the probability of feasible path existence before and after the DAG conversion according to the probability of existence of adaptation functions ($p$).\n \\begin{figure} \n \\centering\n \\includegraphics[width=0.45\\textwidth]{trans_phase_dag2.png}\n \\caption{Probability of feasible path existence before and after DAG conversion on Topologies $T1$ and $T2$.}\n \\label{fig:trans_phase_dag}\n \\end{figure}\nFigure~\\ref{fig:trans_phase_dag} shows that the probability of feasible path existence is shifted to the right after the DAG conversion. The ratio $\\frac{\\text{Probability of feasible path existence in T}i}{\\text{Probability of feasible path existence in DAG T}i}$ ($i=1,2$) is clearly decreasing and is less than $50\\%$ if $p>0.34$, which is important but balanced by the improvement of the processing time.\n\n\\subsubsection{Comparison of the processing time}\n\n \\begin{figure} \n \\centering\n \\includegraphics[width=0.45\\textwidth]{DAG-PDA_vs_DAG-BFS2.png}\n \\caption{Comparison of the processing time of DAG-PDA, DAG-BFS and BFS algorithms on Topologies $T1$ and $T2$.}\n \\label{fig:dag_pda}\n \\end{figure}\n\nFigure~\\ref{fig:dag_pda} shows the processing time of DAG-PDA, DAG-BFS and BFS algorithms on both topologies according to the probability of existence of an adaptation function. BFS algorithm is slow even for small values of $p$.\nFor $p<0.3$ (resp. $0.4$) on Topology~$T1$ (resp. $T2$), DAG-BFS is faster than DAG-PDA. Beyond these values, the processing time of DAG-BFS explodes. For example, for $p=0.5$, the processing time of DAG-BFS is more than $35$ minutes on Topology~$T1$ and more than $53$ minutes on Topology~$T2$, while that of DAG-PDA is $3.8$ seconds on $T1$ and $24$ seconds on $T2$. These results show that the DAG-PDA algorithm is clearly faster when there is a significant number of adaptation functions, but the exponential DAG-BFS algorithm is faster if there are few of them (for small values of $p$).\n\n\n\\section{Path computation under QoS constraints}\n\\label{sec:qos2}\n\\subsection{Multi-constrained feasible path}\n\\label{sec:multi_cons}\nLet ${\\mathcal{N}}$ be a multi-layer network. Each link $E=(U,V)$ is associated to a set of $m$ additive QoS metrics ${q}(E)=({q}_1(E),\\dots,{q}_m(E))$ in addition to its available bandwidth ${q}_b(E)$. These additive metrics can be the delay, logarithm of the packet-loss, etc.\n\n\nLet ${q}_b^{\\min}$ be the bandwidth constraint and ${q}^{max}=({q}_1^{\\max},{q}_2^{\\max}\\dots,{q}_m^{\\max})$ be a vector of QoS constraints, the problem of computing a shortest feasible path under these constraints is formalized as:\n\n", "index": 7, "text": "\\begin{equation}\n\\label{def:MCFP}\n\\begin{split}\n\\min &\\ h({\\mathcal{P}})=\\sum_{(U,f,V)\\in{\\mathcal{P}}}h(U,f,V)\\\\\n s.t.& \\left\\lbrace\\begin{array}{l}\n{\\mathcal{P}} \\text{ is a feasible path between $S$ and $D$}\\\\\n \\\\\n\\min_{E\\in{\\mathcal{P}}}\\dfrac{{q}_b(E)}{{nb}(E)}\\geq {q}_b^{\\min} \\\\\n \\\\ \n\\sum_{E\\in{\\mathcal{P}}}\\left({q}_i(E)\\times{nb}(E)\\right)\\leq {q}_i^{\\max},\\ i=1\\dots m\\\\\n\\end{array} \\right.\n\\end{split}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\begin{split}\\displaystyle\\min&amp;\\displaystyle\\ h({\\mathcal{P}})=\\sum_{(U,f,V)%&#10;\\in{\\mathcal{P}}}h(U,f,V)\\\\&#10;\\displaystyle s.t.&amp;\\displaystyle\\left\\{\\begin{array}[]{l}{\\mathcal{P}}\\text{ %&#10;is a feasible path between $S$ and $D$}\\\\&#10;\\\\&#10;\\min_{E\\in{\\mathcal{P}}}\\dfrac{{q}_{b}(E)}{{nb}(E)}\\geq{q}_{b}^{\\min}\\\\&#10;\\\\&#10;\\sum_{E\\in{\\mathcal{P}}}\\left({q}_{i}(E)\\times{nb}(E)\\right)\\leq{q}_{i}^{\\max}%&#10;,\\ i=1\\dots m\\\\&#10;\\end{array}\\right.\\end{split}\" display=\"block\"><mtable columnspacing=\"0pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mi>min</mi></mtd><mtd columnalign=\"left\"><mrow><mrow><mpadded lspace=\"5pt\" width=\"+5pt\"><mi>h</mi></mpadded><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>U</mi><mo>,</mo><mi>f</mi><mo>,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></mrow></munder><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>U</mi><mo>,</mo><mi>f</mi><mo>,</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mi>s</mi><mo>.</mo><mi>t</mi></mrow><mo>.</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mo>{</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo>\u2062</mo><mrow><mtext>\u00a0is a feasible path between\u00a0</mtext><mi>S</mi><mtext>\u00a0and\u00a0</mtext><mi>D</mi></mrow></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><munder><mi>min</mi><mrow><mi>E</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></mrow></munder><mo>\u2061</mo><mfrac><mrow><msub><mi>q</mi><mi>b</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mi>n</mi><mo>\u2062</mo><mi>b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow><mo>\u2265</mo><msubsup><mi>q</mi><mi>b</mi><mi>min</mi></msubsup></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>E</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></mrow></munder><mrow><mo>(</mo><mrow><mrow><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u00d7</mo><mi>n</mi></mrow><mo>\u2062</mo><mi>b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow><mo>\u2264</mo><msubsup><mi>q</mi><mi>i</mi><mi>max</mi></msubsup></mrow><mo rspace=\"7.5pt\">,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi>m</mi></mrow></mrow></mrow></mtd></mtr></mtable><mi/></mrow></mtd></mtr></mtable></math>", "type": "latex"}]