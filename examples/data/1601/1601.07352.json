[{"file": "1601.07352.tex", "nexttext": " \n\nThe set now of produced versions \nin the history ${H_{{\\EX}}}$ is defined by:\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\n\n\\title{\n\nCoVer-ability: \\textbf{Co}nsistent \\textbf{Ver}sioning for Concurrent Objects \n}\n\n\n\n\n\n\n\n\n\n\\author{\nNicolas Nicolaou$^{~*}$ \\and Antonio Fern\\'andez Anta\n\\thanks{IMDEA Networks Institute, \n\tMadrid, Spain, \n\t\\texttt{nicolas.nicolaou@imdea.org},\\texttt{antonio.fernandez@imdea.org}}\n\n\n\t\n\\and Chryssis Georgiou\n\\thanks{Dept. of Computer Science, University of Cyprus,\n  Nicosia, Cyprus, \n \\texttt{chryssis@cs.ucy.ac.cy}\n }\n}\n\n\n\n\\maketitle \n\n\\begin{abstract}\n\n\n\n\n\n\n\n\nAn \\textit{object type} characterizes the domain space and the operations\nthat can be invoked on an object of that type. In this paper we introduce a new\nproperty for concurrent objects, we call \\emph{coverability}, that aims to \nprovide precise guarantees on the consistent evolution of an object.   \n\n\n\n\n\nThis new property is suitable for a variety of distributed objects\nincluding \\emph{concurrent file objects} that demand operations \nto manipulate the latest version of the object. \nWe propose two levels of coverability: (i) strong coverability and \n(ii) weak coverability. Strong coverability requires that only\na \\emph{single operation} can modify {{the latest}} version of the object, i.e. \\textit{``covers\"}\nthe latest version with a new version, imposing \na total order on object modifications.  \nWeak coverability relaxes the strong \nrequirements of strong coverability and allows \\emph{multiple operations} \nto modify the same version of an object, where each modification leads to a different version. \nWeak coverability preserves consistent evolution of the object, by demanding any subsequent operation\nto only modify one of the newly introduced versions. {{Coverability combined with atomic guarantees  yield to \\emph{coverable atomic read/write registers}.}}\nWe also show that \n\nstrongly coverable atomic registers are equivalent in power to consensus. \nThus, we focus on {\\em weakly} coverable registers, and we demonstrate \ntheir importance by showing that they cannot be implemented using similar types of registers,\nlike ranked-registers.\nFurthermore we show that  \n\nweakly coverable registers may be used to \n\nimplement basic (weak) read-modify-write and file objects. \n\n\n\nFinally, we \nimplement weakly coverable registers by modifying an existing MWMR atomic register\nimplementation.\\vspace{2em}\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\noindent{\\bf Submission Type:} Regular paper.\n\n\\end{abstract}\n\n\n\n\n\n\n\n\n\n\n\n\n\\thispagestyle{empty}\n\\setcounter{page}{0}\n\\newpage\n\n\\section{Introduction}\n\\label{sec:intro}\n\n\n\\noindent{\\textbf{Motivation and Prior Work.}} A concurrent system allows multiple processes to interact with a single object \nat the same time. A long string of research work \\cite{Lamport79, Lamport86, HW90, GD05, AH07}  \nhas been dedicated to explain the behavior of concurrent objects,\ndefining the order and the outcomes of operations when those are invoked concurrently on the object. Lamport in \\cite{Lamport79, Lamport86} presented three different incremental semantics, \\emph{safety}, \\emph{regularity}, and \\emph{atomicity} that characterize the behavior of read/write objects (registers) when those are modified or read concurrently by multiple processes. The strongest, and most difficult to provide \nin a distributed system, is \\emph{atomicity} which provides the illusion\nthat the register is accessed sequentially. Herlihy and Wing presented \\emph{linearizability} in \\cite{HW90}, an extension\nof atomicity to general concurrent objects. More recent developments \nhave proposed abortable operations in the event of concurrency \\cite{AH07}, and ranked registers \\cite{GD05} that allow operations to \nabort in case a higher ``ranked'' operation  was previously\nor concurrently executed in the system. \n\nWith the advent of cloud computing, emerging families of more \ncomplex concurrent objects, like files, distributed databases, and bulleting boards, demand precise\nguarantees on the consistent evolution of the object.\n\n\n{{For example, in \\emph{concurrent file objects} one would expect  that if a write operation ${\\omega}_2$ is invoked after a write operation ${\\omega}_1$  is completed, then ${\\omega}_2$ modifies either the version of the file written by ${\\omega}_1$ or a  version of the file newer than the one written by ${\\omega}_1$.}}\n\n\n\n\n\n\\emph{So is it possible to provide such guarantees using simpler \nobjects as building blocks?}\n\nIn existing atomic read/write \ndistributed shared register implementations,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwrite operations \nare usually {{allowed to modify the value of the register, even when they are unaware of the value written by the latest preceding write operation.}} \n\n\n\nIn systems that assume \na single writer \\cite{ABD96, CDGL04, GNS09, GNS08}, the problem may be diminished by having \nthe sole writer compute the next value to be written \nin relation to the previous values it wrote. \nThe problem becomes more apparent when multiple writers may alter the value of a single register concurrently \\cite{LS97, EGMNS09}.\nIn such cases, atomic read/write register implementations \nappear unsuitable to directly implement objects that \ndemand evolution guarantees.  \n\n\n\n\n\n\n\nCloser candidates to build such objects are the bounded \\cite{BDFG03}\nand ranked \\cite{GD05} registers. These objects take into account the \n``rank\" or sequence number of previous operations to decide whether\nto allow a read/write operation to commit or abort. \n{{These approaches do not prevent, however, the use of an arbitrarily  higher rank, and thus an arbitrarily higher version, than the previous operations.  This affects the consistent evolution of the object, as intermediate versions  of the object maybe ignored.}}\\vspace{.4em} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\noindent{\\bf Contributions.}\nIn this paper we propose a formalism to extend a concurrent object in such a way that the evolution of its state satisfies certain guarantees. To this end, we\nextend an object state with a \\emph{version,} and introduce the concept of \\emph{coverability,} that defines how the versions of an object can evolve (Section~\\ref{sec:atomic}). \n\n\n\n\n\n\n\n\n{{In particular, we first introduce  a new class of a concurrent read/write register type, which we call \\emph{versioned register}. A concurrent register is of a \\textit{versioned} type, if the state of the register and any operation (read or write)  that attempts to modify the state of the register, are associated with a \\emph{version}. An operation may modify the state and the version of the  register, or it may just retrieve its state-version pair.}}\n\n\n\n\n\n\\textit{Coverability} defines the exact guarantees that a versioned register \nprovides when it is accessed concurrently by multiple processes with respect to the evolution of its versions.\n\n\n\n\n\n\n\n\n{{We define two levels of coverability: \\emph{strong} and \\emph{weak} coverability.  Strong coverability ensures that only a \\emph{single operation} may change a given version (and thus the state) of the register,  resulting in a lineal evolution of the versions (and the states) of the register.  Weak coverability relaxes this rule and allows \\textit{multiple operations} to change a version,  generating in this way a \\emph{tree} with possibly multiple version branches that can grow in parallel.  This shares similarities with \\emph{fork linearizability} presented in \\cite{MS02}. However, in contrast to \\cite{MS02}, weak coverability allows processes, that change the same version of the object, to see the changes of each other in subsequent operations. In particular, by weak coverability, when all the operations that extend a particular version of the object terminate, there is one version $ver$ that was generated by one of those operations, which is the ancestor of  any version extended by any subsequent operation.  Thus, only a single branch in the tree is extended and   that branch denotes the evolution of the register.  }}\n{{Combining strong/weak coverability with atomic guarantees we obtain {\\em strongly/weakly coverable atomic read/write registers}. }} \n\n\n\nWhile strongly coverable atomic registers are very desirable objects, we show that they are in fact very strong. In particular, \nwe argue that these object types are as powerful as consensus objects (the details are given in Appendix \\ref{appx:consensus}). \n\nHence, it is challenging to implement these objects in some distributed systems, and impossible in an asynchronous system prone to failures (from the FLP \nresult~\\cite{FLP85}).\n\nThe good news is that even {\\em weakly} coverable atomic registers have very interesting features. \nOn the one hand, they can be implemented in message passing asynchronous distributed systems where processes can fail. \nTo show this, we describe how algorithms that implement atomic R/W registers can easily be modified to implement these objects (Section \\ref{sec:algorithms}). \nOn the other hand, we show that weakly coverable atomic registers cannot be implemented using other previously defined register types such as \n\nranked registers (Section~\\ref{ssec:tr-vs-rr}). \n\n\nOne of the main motivation for introducing coverable registers are {\\em file objects}, which can be seen as a special case \nof register objects in which each new value is a revision of the previous value. In essence, each modification of a file can be seen as an atomic read-modify-write (RMW) operation. Strongly coverable atomic registers provide the desired strong guarantees for files, since they are powerful enough to support atomic RMW operations. \nHowever, we show that even {\\em weakly} coverable atomic registers can be used to provide interesting weak RMW guarantees that can be used to implement files with a good level of consistency \n\n\n\n (Section~\\ref{sec:applications}).\n\n\n\\remove{\nIn particular we introduce \na new atomic operation we call \\emph{update}. An update replaces the write operation\nand acts according to the status of the value of the atomic object as this is\nwitnessed during a query round. If the operation that performs the update \nknows about the latest value of the object then during a second round the \nupdate propagates the new value to the object (acts as a write). In case \nhowever the update is not aware of the latest value then it just propagates \nthe latest value discovered during its query phase (acts as a read). In order \nto write its changes a process needs to obtain the latest value apply its local \nchanges on this value and then invoke an update operation. Observe that this approach\ndoes not prevent the hidden writes but it enhances the service with a mechanism \nthat proactively informs the writer of a potentially hidden write. This scheme however\nincreases the chance where a writer will collide with writes with higher priorities \nand thus failing to complete a write. This is what we call \\emph{write starvation}. \nTo prevent write starvation we incorporate a new way to tag values that rotates \nthe priorities of the writers depending on the number of updates they successfully \ncompleted. \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Model}\n\\label{sec:model}\n\n\nWe consider a distributed system composed of $n$ \\emph{asynchronous} processes,\nwith identifiers from a set ${\\mathcal{I}}=\\{p_1,\\ldots,p_n\\}$, \neach of which represents a sequential thread of control. Processes\nmay interact with a set of shared objects ${\\mathcal{O}}$. \nEach object in ${\\mathcal{O}}$ represents a \\emph{data structure}\nshared among the processes, and has a \\emph{type} which defines the\npossible set of \\emph{object states} and the set of \\emph{operations} \nthat provide the means to manipulate the object. \n\nA subset of processes may fail by \\emph{crashing}. \n\n\n\nProcesses can be modeled in terms of I/O Automata \\cite{LT89}.\nAn automaton $A$  (which combines the automata $A_i$ for each process ${p}_i\\in{\\mathcal{I}}$) is defined over a set of \\emph{states}\n\nand a set of \\emph{actions}. \n\n\n\n\n\n\nAn \\emph{execution} $\\EX$ of $A$ is an alternating sequence\n\nof \\emph{states} and \\emph{actions} of $A$.\n\n\nAn \\emph{execution fragment} is a finite prefix of an execution.\n\n\nWe say that an execution fragment\n$\\EX'$ \\emph{extends} an execution fragment $\\EX$,\n\nif $\\EX$ is a prefix of $\\EX'$.\n\n\n\n\n\n\n\n\nA \\emph{history} of an automaton $A$, denoted by ${H_{{\\EX}}}$, is the subsequence \nof actions occurring in some execution fragment $\\EX$. \n\n\n\n\\remove{\nAn automaton $A$ can be constructed from the composition of \ncompatible automata ${A_{{i}}}$, one for each process ${p}_i\\in{\\mathcal{I}}$.\nEach state ${\\sigma}\\in{states({A})}$ is a vector of the states of the \ncomponent automata ${A_{{i}}}$. Let ${\\sigma}[i]$ denote the state of automaton\n${A_{{i}}}$ in ${\\sigma}$. For a step $\\tup{{\\sigma},{\\alpha},{\\sigma}'}\\in{trans({A})}$, the \nstate of an automaton ${A_{{i}}}$ moves from ${\\sigma}[i]$ to ${\\sigma}'[i]$ if \n$\\tup{{\\sigma}[i],{\\alpha},{\\sigma}'[i]}\\in{trans({{A_{{i}}}})}$; otherwise ${\\sigma}[i]={\\sigma}'[i]$.\nTherefore, we can extract the execution of an automaton ${A_{{i}}}$ from\nan execution $\\EX$ of $A$, denoted by ${{\\EX}|{{A_{{i}}}}}$, by: (i) deleting\nany steps $\\tup{{\\sigma}_k,{\\alpha}_k,{\\sigma}_{k+1}}$ s.t. $\\tup{{\\sigma}_k[i],{\\alpha}_k,{\\sigma}_{k+1}[i]}\\notin{trans({{A_{{i}}}})}$,\nand (ii) by replacing the remaining ${\\sigma}_z$, for $z\\neq k$, with ${\\sigma}_z[i]$ in $\\EX$.\nSimilarly if ${H_{{\\EX}}}$ is the history of events for an execution $\\EX$ of $A$,\nthen ${{{H_{{\\EX}}}}|{{A_{{i}}}}}$ (or ${H_{{\\EX}}}^i$ for short), is the \nhistory of actions of ${A_{{i}}}$ in $\\EX$, and contains the subsequence \nof actions occurring in ${{\\EX}|{{A_{{i}}}}}$. \n}\n\nAn automaton ${A_{{}}}$ \n\\emph{invokes} an operation when an \\emph{invocation\naction} occurs in an execution $\\EX$, and receives a \\emph{response}\nto an action when a \\emph{response action} occurs.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn operation ${\\pi}$ \nis \\emph{complete} in an execution $\\EX$, if ${H_{{\\EX}}}$ contains \nboth the invocation and the matching response actions for ${\\pi}$; otherwise \n${\\pi}$ is \\emph{incomplete}. \n\n\nA history ${H_{{\\EX}}}$ of the automaton $A_i$ of a process ${p}_i$ is \\emph{well formed} if it begins with an invocation \nevent \n\nand alternates between matching invocation and response events. (This demonstrates the assumption that each process is a single thread of control.)\n\n\n\nEach history ${H_{{\\EX}}}$ includes a {{precedence relation}} $\\rightarrow_{{H_{{\\EX}}}}$ on its operations.\nAn operation ${\\pi}_1$ \\emph{precedes} an operation ${\\pi}_2$ (or \n${\\pi}_2$ \\emph{succeeds} ${\\pi}_1$) in ${H_{{\\EX}}}$ if the response of \n${\\pi}_1$ appears before the invocation of ${\\pi}_2$ in ${H_{{\\EX}}}$. This is \ndenoted by ${\\pi}_1\\rightarrow_{{H_{{\\EX}}}}{\\pi}_2$. If ${\\pi}_1\\not\\rightarrow_{{H_{{\\EX}}}}{\\pi}_2$ and\n${\\pi}_2\\not\\rightarrow_{{H_{{\\EX}}}}{\\pi}_1$ in ${H_{{\\EX}}}$, then ${\\pi}_1$ and \n${\\pi}_2$ are \\emph{concurrent}. \n\n\n\n\n\n\n\nA process ${p}_i$ \\emph{crashes} in an execution $\\EX$ if the event $\\act{fail}_{{p}_i}$ \nappears and is the last action of ${p}_i$ in ${H_{{\\EX}}}$; otherwise ${p}_i$ is \\emph{correct}.\n\n\n\n\n\n\n\n\n\n\n\n\\section{Coverable Atomic Read/Write Registers}\n\\label{sec:atomic}\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this section we define a new type of R/W register, the \\emph{versioned register}.\nNext we provide new consistency properties for concurrent versioned registers \ncalled \\emph{(strong/weak) coverability}.  We show how coverability can be combined \nwith atomic guarantees to yield a coverable atomic register.\\vspace{-0.5em}\n\n\n\n\n\n\n\n\n\n\n\n\\paragraph{Versioned register.} \nLet ${\\mathit{Versions}}$ be a \\textit{totally ordered} set of \\textit{versions}.\nA \\emph{versioned register} is a type of read/write register where each value written \nis assigned with a version from the set ${\\mathit{Versions}}$. \n\nMoreover, each write operation ${\\pi}$ that attempts to change the value of the \nregister is also associated with a version, say $ver_{\\pi}$, denoting that it intends\nto overwrite the value of the register associated with the version $ver_{\\pi}$. \nMore precisely, an implementation of a R/W register \n\n\n\n\n\n\noffers two operations: \\emph{read} and \\emph{write}. \nA process ${p}_i\\in{\\mathcal{I}}$ \\emph{invokes} a \\emph{write} (resp. \\emph{read}) operation when it issues \na $\\act{write}({val_{{}}})_{{p}_i}$ (resp. $\\act{read}_{{p}_i}$) request. \nThe \\emph{versioned} variant of a R/W register also offers two operations:\n (i) $\\act{cvr-write}({val_{{}}}, ver)_{{p}_i}$, and (ii) $\\act{cvr-read}()_{{p}_i}$. \nA process ${p}_i$ invokes a $\\act{cvr-write}({val_{{}}}, ver)_{{p}_i}$ operation \nwhen it performs a write operation that attempts to change the value \nof the object. \n\nThe operation returns\nthe value of the object and its associated version, along with a flag informing\nwhether the operation has successfully changed the value of the object or failed.\nWe say that a write is \\emph{successful} if it changes the value of the \nregister; otherwise the write is \\emph{unsuccessful}.\nThe read operation $\\act{cvr-read}()_{{p}_i}$ involves a request to \nretrieve the value of the object. The response of this operation is the \nvalue of the register together with the version of the object that this value is \nassociated with. \n\n\n\n\n\n\n\n\nRead operations do not incur any change on the value \nof the register, whereas write operations attempt to modify the value of the register.\nMore formally, let ${\\Delta_{{T}}}$ be the set of transitions for the versioned register. \nThen, each $\\delta\\in{\\Delta_{{T}}}$ is a tuple \n $\\tup{{\\sigma}, {\\pi}, {p}_i, {\\sigma}', res}$, denoting\n that the register moves from state ${\\sigma}$ to state ${\\sigma}'$, \n \n  and responds with $res$, as a result of operation  \n ${\\pi}$ invoked by process ${p}_i\\in{\\mathcal{I}}$.\n The state of a versioned register is essentially its \\emph{value}, drawn from a set ${V}$,\n and its \\emph{version}, drawn from the set ${\\mathit{Versions}}$.\n We assume that ${\\Delta_{{T}}}$ is \\emph{total}, that is,\n for every ${\\pi}\\in\\{\\act{cvr-write}({val_{{}}}, ver)_{{p}_i}, \\act{cvr-read}()_{{p}_i}\\}$, ${p}_i\\in{\\mathcal{I}}$, and \n ${\\sigma} = ({val_{{}}},ver) \\in{V} \\times {\\mathit{Versions}}$, there exists ${\\sigma}' = ({val_{'}},ver') \\in{V} \\times {\\mathit{Versions}}$\n and $res$ such that $\\tup{{\\sigma}, {\\pi}, {p}_i, {\\sigma}', res}\\in{\\Delta_{{T}}}$. \nAs such, the transitions of the versioned register type \n\ncan be written as follows:\\vspace{-.5em} \n\\begin{enumerate}[leftmargin=5mm]\\itemsep2pt\t\t\n\t\t\\item $\\tup{({val_{{}}},ver), \\act{cvr-write}({val_{{}}}',ver_{\\omega}), {p}_i, ({val_{{}}}',ver'), ({val_{{}}}',ver', chg)}$, for $ver_{\\omega} = ver$,\n\t\t\n\t\t\\item $\\tup{({val_{{}}},ver), \\act{cvr-write}({val_{{}}}',ver_{\\omega}), {p}_i, ({val_{{}}},ver), ({val_{{}}},ver, unchg)}$, for $ver_{\\omega} \\neq ver$\n\t\t\\item $\\tup{({val_{{}}},ver), \\act{cvr-read}(), {p}_i, ({val_{{}}},ver), ({val_{{}}},ver)}$.\n\t\\end{enumerate}\nNotice that write operations may or may not modify the value/version \nof the register.\nIn the transitions above, $ver_{\\omega}$ denotes the version of the register which the write operation tries\nto modify. \nThe relationship of $ver$ with $ver'$ may vary depending on the application that uses this register (but seems\nnatural to assume that $ver' > ver$).\n\n\n\n\nA read operation \ndoes not make any changes on the value or the version of the object. \n\nTo simplify notation, \nin the rest of the paper \nwe avoid any reference \nto the value of the register. Additionally we only use the flag when its value is $unchg$.\n\nThus, $\\act{cvr-write}(v, ver)(v, ver', chg)_{{p}_i}$ is denoted as ${cvr\\mhyphen{\\omega}({ver})[{ver'}]}_{{p}_i}$,\nand $\\act{cvr-write}(v, ver)(v', ver', unchg)_{{p}_i}$ is denoted as ${cvr\\mhyphen{\\omega}({ver})[{ver', unchg}]}_{{p}_i}$. \n\n\n\n\n\n\n\n\nWe say that, a write operation\n\n \\emph{revises} a version $ver$ of \nthe versioned register to a version $ver'$ (or \\emph{produces} $ver'$) in an execution $\\EX$, \nif ${cvr\\mhyphen{\\omega}({ver})[{ver'}]}_{{p}_i}$ completes in ${H_{{\\EX}}}$.\n\n\n\nLet the set of \\emph{successful write} operations on a \n\nhistory ${H_{{\\EX}}}$ \n\nbe defined as: \n\n\n\n\n", "index": 1, "text": "\n\\[\n{\\mathcal{W}}_{\\EX,succ} = \\{{\\pi}: {\\pi}={cvr\\mhyphen{\\omega}({ver})[{ver'}]}_{{p}_i}\\text{ completes in }   {H_{{\\EX}}}\\}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{W}}_{\\EX,succ}=\\{{\\pi}:{\\pi}={cvr\\mhyphen{\\omega}({ver})[{ver^{%&#10;\\prime}}]}_{{p}_{i}}\\text{ completes in }{H_{{\\EX}}}\\}\" display=\"block\"><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb2</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\EX</mtext></merror><mo>,</mo><mrow><mi>s</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>c</mi></mrow></mrow></msub><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>\u03c0</mi><mo>:</mo><mrow><mi>\u03c0</mi><mo>=</mo><mrow><mi>c</mi><mo>\u2062</mo><mi>v</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mhyphen</mtext></merror><mo>\u2062</mo><mi>\u03c9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>r</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mrow><mo stretchy=\"false\">[</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><msup><mi>r</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">]</mo></mrow><msub><mi>p</mi><mi>i</mi></msub></msub><mo>\u2062</mo><mtext>\u00a0completes in\u00a0</mtext><mo>\u2062</mo><msub><mi>H</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\EX</mtext></merror></msub></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07352.tex", "nexttext": "\nwhere $ver_0$ is the initial version of the object.\nObserve that the elements of ${\\mathit{Versions}}_{\\EX}$ are totally ordered.\n\nIn the rest of the text we use `$*$' in the place of some parameter\nto denote that any legal value for that parameter can be used.\n\nNow we present the {\\em validity} property which defines explicitly the \nset of executions that are considered to be valid executions.\n\n\\begin{definition} [Validity]\n\\label{def:validity} \nAn execution $\\EX$ (resp. its history ${H_{{\\EX}}}$) is a \\emph{valid execution} (resp. history)\n\non a versioned object, if  ${\\mathcal{W}}_{\\EX}$ \n\nand for any ${p}_i,{p}_j\\in{\\mathcal{I}}$:\\vspace{-0.2em}\n\\begin{itemize}[leftmargin=5mm]\\itemsep2pt\n\t\\item $\\forall {cvr\\mhyphen{\\omega}({ver})[{ver'}]}_{{p}_i} \\in {\\mathcal{W}}_{\\EX,succ}, ver < ver'$,\n\t\n\t\\item for any operations ${cvr\\mhyphen{\\omega}({*})[{ver'}]}_{{p}_i}$ and ${cvr\\mhyphen{\\omega}({*})[{ver''}]}_{{p}_j}$ in ${\\mathcal{W}}_{\\EX,succ}$, $ver'\\neq ver''$,  and\n\n\n\n\t\\item  for each $ver_k\\in Versions_{\\EX}$ there is a sequence of versions $ver_0, ver_1,\\ldots, ver_k$, such that \n\t${cvr\\mhyphen{\\omega}({ver_i})[{ver_{i+1}}]}$ $\\in{\\mathcal{W}}_{\\EX,succ}$, for $0\\leq i<k$.\n\n\n\n\n\n\n\t\n\\end{itemize}\n\\end{definition}\n\nValidity makes it clear that an operation changes the \nversion of the object to a larger version, according to the total ordering of the versions.\n\nAlso validity specifies that versions are \\emph{unique}, \ni.e. no two operations associate two states with the same version. This can be easily \nachieved by, for example, recording a counter and the id of the invoking \nprocess in the version of the object. Finally, validity requires that each \nversion we reach in an execution is \\textit{derived} (through a chain of operations) \nfrom the initial version of the register $ver_0$.\n\nFrom this point onward we fix $\\EX$ to be a valid \nexecution and ${H_{{\\EX}}}$ to be its valid history.\n\n\\vspace{-.5em}\n\n\\paragraph{Coverability.} \n\n\\sloppypar{\nWe can now \ndefine the \\emph{strong} and \\emph{weak coverability} properties \nover a valid execution $\\EX$ of versioned registers with respect to some \ntotal order $>_\\EX$ on the operations of $\\EX$. \n\n\n\n\n\n\n\n} \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\vspace{-.2em}\n\n\n\n\n\n\\begin{definition}[Strong Coverability]\n\\label{def:strong}\nLet $ver_0 < ver_1 < \\ldots < ver_{|{\\mathcal{W}}_{\\EX,succ}|}$ be the versions in ${\\mathit{Versions}}_{\\EX}$.\n\nA valid execution $\\EX$ is \\textbf{strongly coverable} with respect to a total order $<_{\\EX}$ \non operations in ${\\mathcal{W}}_{\\EX,succ}$ if:\n\\begin{itemize}[leftmargin=5mm]\\itemsep2pt\n\n\n\t\\item ${cvr\\mhyphen{\\omega}({ver_{i-1}})[{ver_i}]}\\in{\\mathcal{W}}_{\\EX,succ}$, for $1\\leq i \\leq |{\\mathcal{W}}_{\\EX,succ}|$, \n\t\\item  \n\t${cvr\\mhyphen{\\omega}({ver_{i-1}})[{ver_i}]}<_{\\EX}{cvr\\mhyphen{\\omega}({ver_i})[{ver_{i+1}}]}$, for $1\\leq i < |{\\mathcal{W}}_{\\EX,succ}|$ , and \n\t\\item  \n\tif ${\\pi}_1, {\\pi}_2\\in{\\mathcal{W}}_{\\EX,succ}$, and ${\\pi}_1\\rightarrow_{{H_{{\\EX}}}}{\\pi}_2$ then ${\\pi}_1<_{\\EX}{\\pi}_2$. \n\\end{itemize}\\vspace{-.3em} \n\\end{definition}\n\nBy Definition \\ref{def:strong}, all successful write operations are totally ordered \nwith respect to the versions they modify. Notice than only a single write \noperation modifies each version $ver_{i-1}$ to the next version $ver_i$.\nThus, strong coverability defines an object type which is \ndifficult to provide in an asynchronous distributed setting. \n\nIn fact it can be shown that strongly coverable\nregisters can be used to solve consensus among asynchronous \nfail-prone processes (see Appendix \\ref{appx:consensus}). \n\nHowever, as shown by Fischer, Lynch and Paterson \\cite{FLP85}, \nsolving consensus in such a system is impossible in the existence of a single crash failure, unless\nsome powerful object is used.\n\n\n\nHence the interest in defining a {\\em weaker} version of coverability.\n\n\\begin{definition}[Weak Coverability]\n\\label{def:weak}\nA valid execution $\\EX$ is \\textbf{weakly coverable} with respect to a total order $<_{\\EX}$ \non operations in ${\\mathcal{W}}_{\\EX,succ}$ if:\n\\begin{itemize}[leftmargin=5mm]\\itemsep2pt\n\t\n\t\n\t\n\t\n\n\n\t\\item ({\\bf Consolidation}) If ${\\pi}_1={cvr\\mhyphen{\\omega}({*})[{ver_i}]}, {\\pi}_2={cvr\\mhyphen{\\omega}({ver_j})[{*}]} \\in {\\mathcal{W}}_{\\EX,succ}$, \n\tand ${\\pi}_1\\rightarrow_{{H_{{\\EX}}}} {\\pi}_2$ in ${H_{{\\EX}}}$, then $ver_i \\leq ver_j$ and ${\\pi}_1<_{\\EX}{\\pi}_2$.\n\t\\item ({\\bf Continuity})  if ${\\pi}_2={cvr\\mhyphen{\\omega}({ver})[{ver_i}]}\\in{\\mathcal{W}}_{\\EX, succ}$, then \n\tthere exists ${\\pi}_1\\in{\\mathcal{W}}_{\\EX,succ}$ s.t. \n\t\n\t${\\pi}_1={cvr\\mhyphen{\\omega}({*})[{ver}]}$ and ${\\pi}_1<_\\EX {\\pi}_2$, or $ver=ver_0$.\n\t\n\t\n\t\\item ({\\bf Evolution})\n\tlet $ver, ver', ver''\\in Versions_{\\EX}$. If there are sequences of versions $ver'_1, ver'_2,\\ldots, ver'_{k}$\n\tand $ver''_1, ver''_2,\\ldots, ver''_{\\ell}$, where $ver=ver'_1=ver''_1$, $ver'_{k}=ver'$, and $ver''_{\\ell}=ver''$\n\tsuch that\n\t${cvr\\mhyphen{\\omega}({ver'_i})[{ver'_{i+1}}]}$ $\\in{\\mathcal{W}}_{\\EX,succ}$, for $1\\leq i<k$, and ${cvr\\mhyphen{\\omega}({ver''_i})[{ver''_{i+1}}]}$ $\\in{\\mathcal{W}}_{\\EX,succ}$, for $1\\leq i<\\ell$,\n\tand $k < \\ell$, then $ver' < ver''$.\n\\end{itemize}\n\\end{definition}\nBy Definition \\ref{def:weak}, weak coverability allows multiple write operations to revise the same version $ver_i$\nof the register, each to a \\emph{unique} version $ver_j$. \n\n\n\n\n\nGiven the set of successful operations ${\\mathcal{W}}_{\\EX,succ}$\nand the set of versions ${\\mathit{Versions}}_{\\EX}$, Definitions \\ref{def:validity} and \\ref{def:weak} define a connected rooted tree $\\mathcal{T}$ s.t.:\n\\begin{itemize}[leftmargin=5mm]\\itemsep2pt\n\t\\item The set of nodes of $\\mathcal{T}$ is ${\\mathit{Versions}}_{\\EX}$,\n\t\\item {{The initial version $ver_0$ of the object}} is the root of $\\mathcal{T}$,\n\t\\item A node $ver_i$ is the parent of a node $ver_j$ in $\\mathcal{T}$ iff $\\exists{{\\pi}({ver_i})[{ver_j}]}\\in{\\mathcal{W}}_{\\EX,succ}$, \n\t\n\n\n\n\t\\item If ${\\pi}_1={cvr\\mhyphen{\\omega}({*})[{ver_i}]}\\in {\\mathcal{W}}_{\\EX,succ}$, \n\t\ts.t. ${\\pi}_1$ is not concurrent with any other operation, then \n\t\t$\\forall {\\pi}_2\\in{\\mathcal{W}}_{\\EX,succ}$,\n\t\ts.t. ${\\pi}_1\\rightarrow_{\\EX} {\\pi}_2$ and ${\\pi}_2={{\\pi}({ver_z})[{*}]}$, then $ver_i$ is an ancestor of $ver_z$ in $\\mathcal{T}$,\n\t\t{{or $ver_i=ver_z$ (by Consolidation, Continuity, and Validity)}}\n\t\\item if $ver_i$ is an ancestor of $ver_j$ in $\\mathcal{T}$, then ${cvr\\mhyphen{\\omega}({*})[{ver_i}]}<_\\EX{cvr\\mhyphen{\\omega}({*})[{ver_j}]}$ (by Continuity).\n\t\\item if $ver_i$ is at level $k$ of $\\mathcal{T}$ and $ver_j$ is at level $\\ell$ of $\\mathcal{T}$ s.t. $k<\\ell$, then\n\t$ver_i<ver_j$ (by Evolution).\n\\end{itemize}\nObserve that without the properties imposed by weak coverability, \nvalidity allows the creation of a tree of versions and \ndoes not prevent operations from being applied on an old version of the register. \n\n\n\n\\emph{Continuity}, \\emph{Consolidation}, and \\emph{Evolution} explicitly specify the conditions that reduce the \nbranching of the generated tree, and in the case of not concurrency lead the \noperations to a single path on this tree. \n\n\n\n\n\n\n\n\n\n\\emph{Consolidation} specifies that write operations\nmay revise the register with a version larger than any version modified\n by a preceding write operation, and may lead to a version newer than\n any version introduced by a preceding write operation. \n \n \n\\emph{Continuity} defines that a write operation may revise a version that was introduced\nby a preceding write operation according to the given total order.\nFinally, \\emph{Evolution} limits the relative increment on the version of a register that can be\nintroduced by any operation.\n\n\n\n\n\n\n\n\n\n\nFigure \\ref{fig:tree} provides an illustration of a tree \ncreated from a coverable execution $\\EX$. We box \n\nsample instances of the execution and we indicate the coverability properties they satisfy.\n\n\n\\vspace{-.5em}\n\n\\paragraph{Atomic coverability.} \nWe now combine coverability with atomic guarantees to obtain coverable atomic read/write registers. \nA register is linearizable \\cite{HW90}, or equivalently \\emph{atomic} (as \ndefined specifically for registers by \\cite{Lynch1996, Lamport86}) if the following conditions are \nsatisfied by any execution $\\EX$ of an implementation of the object.\\vspace{-.2em}  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{definition}[Atomicity]\n\\label{def:atomic}\n{\\rm  \\cite[Section 13.4]{Lynch1996} An execution $\\EX$ of an automaton $A$ is \\emph{atomic} if every \n\\emph{read} and \\emph{write} operation in $\\EX$ is \\emph{complete}\nand there is a partial ordering $\\prec_{{H_{{\\EX}}}}$ on all operations \n$\\Pi$ in ${H_{{\\EX}}}$ such that: \n{\\bf A1.} For any pair of operations ${\\pi}_1,{\\pi}_2\\in\\Pi$, \nif ${\\pi}_1\\rightarrow_{{H_{{\\EX}}}}{\\pi}_2$ then it cannot hold that ${\\pi}_2\\prec_{{H_{{\\EX}}}}{\\pi}_1$, \n{\\bf A2.} If ${\\pi}\\in\\Pi$ is a \\emph{write} operation and ${\\pi}'$ any operation in $\\Pi$,\nthen either ${\\pi}\\prec_{{H_{{\\EX}}}}{\\pi}'$ or ${\\pi}'\\prec_{{H_{{\\EX}}}}{\\pi}$, and \n{\\bf A3.} If $v$ is the value returned by a \\emph{read} ${\\rho}$ then $v$ is the \nvalue written by the last preceding \\emph{write} according to $\\prec_{{H_{{\\EX}}}}$\n(or the initial value $v_0$ if there is no such a write).}\\vspace{-.2em}\n\\end{definition}\n\n\\remove{\nIn the case of a versioned R/W register not all write operations may modify the \nvalue of the register. Thus a \\emph{write} (and the property {\\bf A2}) refers to a \n${cvr\\mhyphen{\\omega}({*})[{*,chg}]}$ write operation that modifies the value (and the version) of the register. \nA \\emph{read} (and {\\bf A3}) refers to a $\\act{cvr-read}$ or a ${cvr\\mhyphen{\\omega}({*})[{*,unchg}]}$ operation\nthat does not modify the value (nor the version) of the register.\n\nWe say that, a write operation\n\n \\emph{revises} a version $ver$ of \nthe versioned register to a version $ver'$ (or \\emph{produces} $ver'$) in an execution $\\EX$, \nif ${cvr\\mhyphen{\\omega}({ver})[{ver', chg}]}_{{p}_i}$ completes in ${H_{{\\EX}}}$.\n\n\n\n\n}\n\n\n\\begin{figure}[!t]\n\t\\begin{center}\t\n\t\t\\includegraphics[width=0.60\\textwidth]{figures/cvr_tree_v1.png}\n\t\\end{center}\\vspace{-1.5em}\n\t \\caption{Tree Illustration from Weak Coverable Execution\n\t }\n\t \\label{fig:tree}\\vspace{-1em}\n\\end{figure} \n\n\n\n\nIn the context of versioned registers, in Definition \\ref{def:atomic}, a \\emph{write} refers to \na successful write (${cvr\\mhyphen{\\omega}({*})[{*,chg}]}$) operation on the versioned register. Therefore, all \nthe write operations in an execution $\\EX$ are the ones that appear in ${\\mathcal{W}}_{\\EX,succ}$.\nA \\emph{read} refers to a versioned read (${cvr\\mhyphen{\\rho}({})[{*}]}$) or an unsuccessful write (${cvr\\mhyphen{\\omega}({*})[{*,unchg}]}$) operation\nthat does not modify the value (nor the version) of the register.\n\n\\begin{definition}[Coverable atomic register]\n A versioned register is \\textbf{(strongly/weakly) coverable} and \\textbf{atomic}, referred as \n\\emph{(strongly/weakly) coverable atomic register}, if any execution $\\EX$ on the register satisfies:\n(i) atomicity, and  (ii) strong/weak coverability (Definition \\ref{def:strong}/\\ref{def:weak}) with \nrespect to the total order imposed by {\\bf A2} on ${\\mathcal{W}}_{\\EX,succ}$. \n\\end{definition}\n\nNote that in a coverable atomic register, the ordering of read operations follows the ordering\nfrom atomicity.\n\nFrom this point onward, when clear from context, we refer to a coverable atomic register, as simply \\emph{coverable register}. \n\\vspace{-.2em}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Weakly Coverable Atomic Registers vs Ranked Registers.}\n\\label{ssec:tr-vs-rr}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \nA type of registers that at first might resemble coverable registers are {\\em ranked-registers}~\\cite{GD05}.\nAs we show here, ranked-registers are weaker than {\\em weakly} coverable registers. In particular, we show\nthat it is impossible to implement weakly coverable registers using ranked-registers; we begin by providing\na formal definition of ranked-registers.\\vspace{-.2em}\n\n\n\n\n\\begin{definition}[Ranked-Registers~\\cite{GD05}]\n\\label{def:rr}\nLet $Ranks$ be \na totally ordered set of ranks with $r_0$ the initial rank.\nA ranked register is a MWMR shared object that offers the \nfollowing operations: (i) $\\act{rr-read}(r)$, with $r\\in Ranks$ and returns $(r,v)\\in Ranks\\times Values$, and \n(ii) $\\act{rr-write}(\\tup{r,v})$, with \n$(r,v)\\in Ranks\\times Values$ and returns \n$commit$ or $abort$. A ranked register satisfies the \nfollowing properties: \n\n\t\n\t(i) {{\\bf Safety.}} Every $\\act{rr-read}$ operation returns a value and a rank that was written in some $\\act{rr-write}$ invocation \n\tor $(r_0, v_0)$. Additionally, if $W = \\act{rr-write}(\\tup{r_1, v})$ a write operation which commits \n\tand $R = \\act{rr-read}(r_2)$ such that $r_2 > r_1$, then $R$ returns $(r,v)$ where $r\\geq r_1$.\n\t\n\t\n\t(ii) {{\\bf Non-Triviality.}} If a $\\act{rr-write}$ operation $W$\n\tinvoked with a rank $r_1$ aborts, then there exists an operation with rank $r_2 > r_1$ which returns before $W$ is invoked, or is concurrent with $W$ \n\t\n\t\n\t(iii) {{\\bf Liveness.}} if an operation is invoked by a correct process then eventually it returns. \\vspace{-.3em}\n\n\n\\end{definition}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe want to use rank-registers to implement the operations of\na weakly coverable register. As in Section \\ref{sec:model}, \nwe denote by ${cvr\\mhyphen{\\omega}({ver})[{ver', flag}]}$ the \ncoverable write operation that tries to revise version $ver$, \n\nand returns version $ver'$ with \na $flag\\in\\{chg, unchg\\}$. Similarly we denote by \n${rr\\mhyphen{\\omega}({r})[{r_h, res}]}$ a write operation on a ranked-register that \nuses rank $r$ and tries to modify the value of the register. The rank \n$r_h$ is the highest rank observed by an operation and $res\\in\\{abort, commit\\}$.\n\n\n\n\n\n\n\n\n\n\n\nIn the following results we assume that a weakly coverable register is \nimplemented using a set of ranked-registers. \nWe begin with a lemma that shows that a coverable write operation \nrevises the coverable register only if it invokes a write operation \non some rank register and that write operation commits. {\\em Omitted proofs\ncan be found in Appendix~\\ref{appx:rr}.}\n\n\\begin{lemma}\n\\label{lem:commit}\nSuppose there exists an algorithm $A$ that implements a weakly coverable register\nusing ranked-registers. In any execution $\\EX$ of $A$, if\na process ${p}_i$ invokes a coverable write operation ${cvr\\mhyphen{\\omega}({ver})[{ver',chg}]}_{{p}_i}$, \n\nthen ${p}_i$ performs a write ${rr\\mhyphen{\\omega}({r})[{r_h, commit}]}_{{p}_i,j}$ \non some shared ranked-register $j$.\n\\end{lemma}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext we show that if ${\\pi}_1, {\\pi}_2$ are two non-concurrent write operations  \n\non the weakly coverable register, then ${\\pi}_2$ \nperforms a ranked write (that commits or aborts) on at least a single \nranked register on which ${\\pi}_1$ performed a committed ranked write operation.\n\n\n\nFor the sake of the lemma $R_i$ is the set of ranked registers on which \n${\\pi}_i$ writes, and $cR_i$ a subset of them on which the write commits.\n\n\\begin{lemma}\n\\label{lem:rrcommon}\nLet ${\\pi}_1 = {cvr\\mhyphen{\\omega}({ver})[{ver_1,chg}]}_{{p}_i}$ and \n${\\pi}_2 = {cvr\\mhyphen{\\omega}({ver_1})[{ver_2,*}]}_{{p}_z}, i\\neq z$, be\ntwo write operations that appear in an execution $\\EX$ s.t. \n${\\pi}_1\\rightarrow_{\\EX}{\\pi}_2$.\n\n\n\n\nThere exists some shared register $j\\in R_2\\cap cR_1$ with \na highest rank $r_j$ before the invocation of ${\\pi}_1$, such that \n${p}_i$ performs an ${rr\\mhyphen{\\omega}({r})[{*,commit}]}_{{p}_i,j}$ during ${\\pi}_1$, \nand ${p}_z$ performs an ${rr\\mhyphen{\\omega}({r'})[{*,*}]}_{{p}_z,j}$ during ${\\pi}_2$.\n\\end{lemma}\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThus far we showed that a successful coverable write operation\nneeds to commit on at least a single ranked register (Lemma \\ref{lem:commit}),\nand two non-concurrent coverable write operations need to invoke a \nranked write operation on a common rank register (Lemma \\ref{lem:rrcommon}).   \nUsing now Lemma \n\\ref{lem:rrcommon}\nwe can show that a coverable write operation that changes the version of \nthe coverable register must use a rank higher than any previously\nsuccessful coverable write operation.\n\n\\begin{lemma}\n\\label{lem:rrorder}\nIn any execution $\\EX$ if ${\\pi}_1 = {cvr\\mhyphen{\\omega}({ver})[{ver_1,chg}]}_{{p}_i}$ and \n${\\pi}_2 = {cvr\\mhyphen{\\omega}({ver_1})[{ver_2,chg}]}_{{p}_z}$, $\\!z\\neq\\! i$, s.t. \n${\\pi}_1\\rightarrow_{\\EX}{\\pi}_2$, then there exists some shared register $j$ such that \n${p}_i$ performs an ${rr\\mhyphen{\\omega}({r})[{*,commit}]}_{{p}_i,j}$ during ${\\pi}_1$, \nand ${p}_z$ performs an ${rr\\mhyphen{\\omega}({r'})[{*,commit}]}_{{p}_z,j}$ during ${\\pi}_2$, and $r' > r$.\n\\end{lemma}\n\n\\remove{\n\\begin{lemma}\n\\label{lem:rrorder}\nIn any execution $\\EX$ if ${\\pi}_1 = {cvr\\mhyphen{\\omega}({ver})[{ver_1,chg}]}_{{p}_i}$ and \n${\\pi}_2 = {cvr\\mhyphen{\\omega}({ver_1})[{ver_2,chg}]}_{{p}_z}$, $\\!z\\neq\\! i$, s.t. \n${\\pi}_1\\rightarrow_{\\EX}{\\pi}_2$, then there exists some shared register $j$ such that \n${p}_i$ performs an ${rr\\mhyphen{\\omega}({r})[{*,commit}]}_{{p}_i,j}$ during ${\\pi}_1$, \nand ${p}_z$ performs an ${rr\\mhyphen{\\omega}({r'})[{*,commit}]}_{{p}_z,j}$ during ${\\pi}_2$, and $r' > r$.\n\\end{lemma}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow we prove our main result stating that a weakly coverable \nregister cannot be implemented with ranked registers as those\nwere defined in~\\cite{GD05}.\n \n\n\n\\begin{theorem}\nThere is no algorithm that implements a weakly coverable register \nusing a set of ranked registers. \n\\end{theorem} \n\n\\begin{proof}\nThe theorem follows from Lemmas \\ref{lem:commit}, \\ref{lem:rrcommon}, and \\ref{lem:rrorder}, and the fact \nthat a ranked register allows a write operation to commit even if it uses a rank smaller than the highest\nrank of the register. As by Lemma \\ref{lem:commit} a successful write must commit, then by ranked \nregisters it can commit with a rank smaller than the highest rank of the accessed register. This, \nhowever, by Lemma \\ref{lem:rrorder} may lead to violation of the consolidation and continuity \nproperties and thus violation of weak coverability. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\end{proof}\n \n\nObserve that the key fact that makes ranked registers weaker than weakly coverable registers is that the former\nallow write operations to commit even if their ranks are out of order. \n\nIn particular, note that the Non-Triviality property \\emph{does not force} a write operation \ninvoked with a rank $r_1$ to abort, even if there exists a completed prior \noperation with rank $r_2 > r_1$. As shown in \\cite{GD05} \\emph{non-fault-tolerant} \nranked registers may preserve the total order of the ranks, and thus be used to \nimplement consensus. As we show in Appendix~\\ref{appx:consensus} \n\nsuch ranked registers (i.e., that implement consensus) could be used to implement strongly coverable registers.\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\remove{\n\\subsection{Strong coverable Register vs Consensus}\n\\label{ssec:consensus}\nConsensus \\cite{Lynch1996} is defined as the problem where a set of fail-prone processes\ntry to agree on a single value for an object. A consensus protocol\nmust specify two operations: (i) $propose(v)_{{p}_i}$, used by the process ${p}_i$ to propose\na value $v$ for the object, and (ii) $decide()_{{p}_i}$, used by the process ${p}_i$ to decide \nthe value of the object. Any implementation \nof consensus must satisfy the following three properties: \n\n\n{\\bf (1) CTermination:} Every correct process decides a value;\n\n\n\n\t\n\t{\\bf (2) CValidity:} Every correct process decides at most \n\tone value, and if it decides some value $v$, then $v$ must have\n\tbeen proposed by some process;  \n\t\n\t{\\bf (3) CAgreement:} All correct process must decide the same value.\n\n\nIt is not difficult to show that strong coverable objects are equivalent to \nconsensus objects. For this, one needs to develop \n\nan implementation of a consensus object using \na strong coverable read/write register, and an\nimplementation of a strong coverable \nread/write register assuming the existence of a consensus object. \nFor completeness we provide the complete discussion and proof of equivalence \nin Appendix \\ref{sec:consensus}. \n}\n\n\n\n\n\n\\section{Applications of Weakly Coverable Atomic Read/Write Registers}\n\\label{sec:applications}\n\n\n\n\n\\paragraph{Weak RMW registers.}\n\n\nA shared object satisfies atomic \\emph{read-modify-write} (RMW) semantics if \na process can atomically \\emph{read} and \\emph{modify} \nthe value of the object using some \nfunction $\\mathcal{F}$, and then \\emph{write} the new value on \nthe object. \n\n\n\n\nWeakly coverable atomic R/W registers \ncan be used to implement a weak version of RMW semantics. \nIn a weak RMW object not all operations may successfully \nmodify the value of the object. In case that a RMW operation\nis not concurrent with any other operation then this operation\nsatisfies the RMW semantics. In case where two or more operations\ninvoke RMW concurrently, at least one of them will satisfy the \nRMW semantics. Finally, weak RMW allow multiple \nRMW operations to modify successfully the same value.  \n\n\n\n\n\n\nFigure~\\ref{fig:rmw} presents an implementation of a weak RMW object \nusing weakly coverable atomic R/W registers. We assume that the object \noffers a $\\act{rmw}(\\mathcal{F})$ action that accepts a function \nand tries to apply that function on the value of the object.  \nThe object returns the initial value of the object and a flag \nindicating whether the value of the object was modified successfully.\n\n\\begin{figure}[!h]\n\t\n\t\\hrule\\vspace{0.15cm}\n\t\\begin{footnotesize}\n\tAt each process $i\\in{\\mathcal{I}}$\\\\\n\tLocal Variables: $lcver\\in Versions, oldval, lcval, newv \\in Values, flag\\in\\{chg, unchg\\}$\\\\\n\t\n\t{\\bf function} {\\sc Rmw}($\\mathcal{F}$)\n\t\\begin{algorithmic}\n\t\t\\State $\\tup{oldval, lcver}\\gets \\act{cvr-read}()$ \n\t\t\\State $newv \\gets \\mathcal{F}(oldval)$\n\t\t\\State $\\tup{lcval,lcver, flag} \\gets \\act{cvr-write}(lcver, newv)$\n\t\t\\If { $flag == chg$ } return $\\tup{lcval, success}$\t\t\n\t\t\\Else {} return $\\tup{lcval, fail}$\t\n\t\t\\EndIf\n\t\\end{algorithmic}\n\t\\end{footnotesize}\n\t\\hrule\\vspace{.4em}\n\t\\caption{Weak RMW using Weakly Coverable Atomic R/W Registers}\\vspace{-1.2em}\n\t\\label{fig:rmw}\n\\end{figure}\n\n\\begin{theorem}\n\\label{thm:wrmw}\nThe construction in Figure \\ref{fig:rmw} implements \na weak RMW object.\n\\end{theorem}\n\n\\begin{proof}\nConsider an execution $\\EX$ of the algorithm. \nWe begin the proof by studying the case where an operation\n$\\act{rmw}(\\mathcal{F})$ is not concurrent with any other operation\nin $\\EX$.\n\nThe atomic nature of the register ensures that $\\act{cvr-read}$\nreturns the latest value and version, say $\\tup{ver,val}$, written on the register. \nWhen the $\\act{cvr-write}$ operation is invoked, the write operation\ntries to modify the value associated with version $ver$. As there is \nno concurrent operation, the version of the register remains $ver$ \nand thus according to \\emph{consolidation and continuity}, \nthe write operation successfully writes the new value completing the \n\nRMW operation.\n\nConsider now the case of two operations, ${\\pi}_1$ and ${\\pi}_2$, \ninvoking $\\act{rmw}$ concurrently. \nEach of these operations involve a $\\act{cvr-read}$ \nfollowed by a $\\act{cvr-write}$ operation. Let ${\\rho}_{{\\pi}_i}$ (resp. ${\\omega}_{{\\pi}_i}$)\ndenote the read (resp. write) operation invoked during ${\\pi}_i$, for $i\\in[1,2]$. We have the \nfollowing cases wrt the order of these operations:\n$(i)$ ${\\omega}_{{\\pi}_1} \\rightarrow {\\rho}_{{\\pi}_2}$,\n$(ii)$ ${\\omega}_{{\\pi}_2} \\rightarrow {\\rho}_{{\\pi}_1}$,\n$(iii)$ ${\\rho}_{{\\pi}_2}\\rightarrow{\\omega}_{{\\pi}_1} \\rightarrow {\\omega}_{{\\pi}_2}$,\n$(iv)$ ${\\rho}_{{\\pi}_1}\\rightarrow{\\omega}_{{\\pi}_2} \\rightarrow {\\omega}_{{\\pi}_1}$, or\n$(v)$ ${\\omega}_{{\\pi}_1}$ is concurrent with ${\\omega}_{{\\pi}_2}$.\nIn case $(i)$, both read and write operations of\n${\\pi}_1$ complete before the read and write operations\nof ${\\pi}_2$ are invoked. In this case notice that \nthe version of the object remains the same from the read\nto the write operation of both operations. Thus, \naccording to \\emph{consolidation and continuity}, both write operations\nwill successfully change the value of the register. \nThe same holds for case $(ii)$, where ${\\pi}_2$'s ops \ncomplete before the invocation of ${\\pi}_1$'s ops. \n\nIn case $(iii)$ the write operation of ${\\pi}_1$ completes \nbefore the write operation of ${\\pi}_2$. Let ${\\rho}_{{\\pi}_2}$\nin this case complete before ${\\omega}_{{\\pi}_1}$. Both read \noperations ${\\rho}_{{\\pi}_1}$ and ${\\rho}_{{\\pi}_2}$ discover by \\emph{atomicity} \nthe same version, say $ver$. So both write operations will \nbe invoked as $\\act{cvr-write}(ver, v)$. Since no operation \nchanges the version of the register before ${\\omega}_{{\\pi}_1}$ is \ninvoked, then by \\emph{consolidation and continuity}, ${\\omega}_{{\\pi}_1}$ changes the version \nof the object to, say, $ver_{{\\pi}_1}$. Notice that \nby \\emph{validity}, $ver_{{\\pi}_1}>ver$. When ${\\omega}_{{\\pi}_2}$ is\ninvoked it fails by \\emph{consolidation} to change the value of\nthe object as ${\\omega}_{{\\pi}_1} \\rightarrow {\\omega}_{{\\pi}_2}$ and it tries \nto change the version $ver < ver_{{\\pi}_1}$ (the version of ${\\omega}_{{\\pi}_1}$). Hence,\nonly ${\\pi}_1$ will manage to preserve RMW semantics. Similarly,\nwe can show that only ${\\pi}_2$ will preserve RMW semantics in \ncase $(iv)$. \n\nFinally, in case $(v)$ if both writes try to change the version \n$ver$,  both may succeed and preserve \nRMW semantics. Since, however, their versions are unique and \ncomparable, then by \\emph{consolidation} any subsequent operation will RMW the \nhighest of the two versions. \n\n\n\n\n\n\n\n\nSo in all cases at least a single \noperation satisfies the RMW semantics, as desired.\n\\end{proof}\n\nFrom the proof we can extract that weakly coverable registers \nmay allow multiple writes to change the same version\nof the register, but\n\n\\emph{consolidation} ensures that at least one write satisfies \nRMW semantics for each version. \n\nFinally,  \\emph{consolidation and continuity} ensure that eventually RMW operations \ndiverge in a single path in the constructed tree.\n\\vspace{-.5em}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\paragraph{Concurrent File Objects}\n\n\nA file object can be implemented directly using RMW semantics since one can retrieve, revise, and write back the new version of the file. As RMW semantics can be used to solve consensus \\cite{H91}, \nthey are impossible to be implemented in an asynchronous\nsystem with a single crash failure. \nTherefore, we consider file objects that comply to the weak\nRMW semantics as those were given in the paragraph above. \nIn particular,  \nwe consider \\emph{concurrent file objects} that allow two fundamental operations, \\emph{revise} and \n\\emph{get} to be invoked concurrently by multiple processes. The $\\act{revise}$ operation is used to change the contents of the file object,\nwhereas the $\\act{get}$ action is analogous to a read operation and facilitates the retrieval\nof the contents of the file. Semantically, a file object requires that a revise operation is \napplied on the latest version of the file and a get operation returns the file associated\nwith the latest written version.  \n\nDepending on the implementation, the values written and returned\nby these operations can be the complete file object, a fragment of the file object, or just \nthe journal containing the operations to be applied on a file (similar to a journaled file system).\n\n\n\nFigure \\ref{fig:file} presets the algorithm that implements the two operations. The \\emph{revise} \noperation specifies the version of the file to be revised along with the new \nvalue of the shared object. \n\n\n\n\nThe $\\act{cvr-write}$ operation attempts to perform the write with the given  version and \nreturns the value and version of the register, and whether the write succeeded or not. \nIf the write succeeded then the operation informs the application \nfor the proper completion of the revise operation; otherwise the latest discovered\nvalue-version pair is returned. From Theorem~\\ref{thm:wrmw} and Figure~\\ref{fig:file}\nwe may conclude the following theorem.\\vspace{-.3em}\n \n\n\\begin{figure}[t]\n\t\n\t\\hrule\\vspace{0.15cm}\n\t\\begin{footnotesize}\n\t\\begin{multicols}{2}\n\tAt each process $i\\in{\\mathcal{I}}$\\\\\n\tLocal Variables: \n\t$lcver \\in Versions$, initially $ver_0$\n\t$lcval, newv \\in Values$, initially $\\bot$\n\t$flag\\in\\{chg, unchg\\}$, initially $chg$\\\\\n\t\n\t{\\bf function} {\\sc Revise}($v,ver$)\n\t\\begin{algorithmic}\n\t\t\n\t\t\n\t\t\n\t\t\t\\State $\\tup{lcval,lcver, flag} \\gets \\act{cvr-write}(ver, v)$\n\t\t\t\\If {$flag == chg$}\n\t\t\t\t\\State return OK\n\t\t\t\\EndIf\t\t\n\t\t\n\t\t\\State return $\\tup{lcval, lcver}$\\\\\n\t\\end{algorithmic}\n\t\n\t{\\bf function} {\\sc Get}()\n\t\\begin{algorithmic}\n\t\t\\State $\\tup{lcval, lcver}\\gets \\act{cvr-read}()$ \n\t\t\\State return $\\tup{lcval, lcver}$\n\t\\end{algorithmic}\n\t\\end{multicols}\n\t\\end{footnotesize}\n\t\\hrule\\vspace{.4em}\n\t\\caption{File Object using Weakly Coverable Atomic R/W Registers}\\vspace{-2em}\n\t\\label{fig:file}\n\\end{figure}\n\n\\begin{theorem}\n{{The construction in Figure \\ref{fig:file} implements  a file object.}}\n\\end{theorem}\n\n\n\n\n\n\n\n\\section{Implementing Weakly Coverable Atomic Read/Write Registers\\vspace{-.5em}}\n\\label{sec:algorithms}\n\n\n\n\n{{We now show how we can implement weak coverable atomic registers. We do so by  enhancing the Multi-Writer version of algorithm ABD~\\cite{ABD96,LS97} (referred as {\\sc mw}{\\sc ABD}{}) to preserve the properties of weak coverability.}} \nThe presented technique can be applied to implementations\nof atomic R/W objects that utilize a $\\tup{tag,value}$ pair \n\nto order the \nwrite operations and where each write performs \ntwo phases before completing: a \\emph{query phase} to obtain \nthe latest value of the atomic object and a \\emph{propagation \nphase} to write the new value on the object. \n\nWe could also adopt implementations of \nstronger objects like the ones presented  \nin \\cite{BDFG03, GD05, CDS13-BA, DVV14} but we \npreferred to show the simplest modification in\na fundamental algorithm. \n\n\n\n\n\n\n\\remove{\nOur algorithm aims for the\nstrategy ``hope for the best\" and allows write operations to propagate values that can be hidden\nto succeeding \\emph{reads} or \\emph{writes}. Our technique, however, always \nprovides \\emph{provable} guarantees on the state of the object as it \ndoes not compromise atomicity.\n\nIn the next section we provide an enhancement on the basic ABD algorithm\n\\cite{ABD96} and in the following section we show how our technique can\nbe used to enhance atomic implementations designed for large objects\n\\cite{FL03}. We show how coverability helps implementations of large \ndata objects to support the management and maintenance of \\emph{file objects}.\n} \n\n\n\n\n\n\n\n\nTo capture the semantics of a coverable atomic register we modify the operations \nof algorithm {\\sc mw}{\\sc ABD}{}{} \nto comply with the versioned variant of the R/W register. \nWe use $\\act{cvr-write}(ver, v)$ and $\\act{cvr-read}()$ as the\nwrite and read operations respectively. \n\nA  $\\act{cvr-write}(ver, v)$ operation {{may impact differently the state of the object,}}\n\ndepending on the version of the shared object: \nit may appear as a \\emph{read} not modifying the value nor the version of the \nregister or as a \\emph{write} changing both the value and the \nversion of the register. \n\nIn brief, the original {\\sc mw}{\\sc ABD}{}{} replicates an object to a set of hosts \n${\\mathcal{S}}\\subset {\\mathcal{I}}$ and it uses $\\tup{tag, value}$ pairs to order the \n\\emph{read} and \\emph{write} operations. \nA $tag$ consists of a \\emph{non-negative integer} number and a \\emph{writer identifier} which is used to break the \nties among concurrent write operations. \nBoth the read and write protocols have two phases: a \\emph{query} and a \\emph{propagation} phase.  \nDuring the \\emph{query} phase the invoking process \nbroadcasts a query message to all the replica hosts (replicas)  and \nwaits for a majority of them to reply with their \ntag-value pairs. Once those replies are received the \nprocess discovers the largest tag-value pair among the replies.\n\n\n\n\nIn the second phase, a read operation \npropagates the discovered tag-value pair to the majority of the replicas. \nA write operation increments the largest tag, associates the \nnew tag with the value to be written, and propagates the new \ntag-value pair to the majority of the replicas.\n\n\n\n\n\nIn the \\emph{versioned {\\sc mw}{\\sc ABD}{}}, {{v{\\sc mw}{\\sc ABD}{}\\ for short}}, we use the tags associated with \neach value to denote the version of the register. The pseudocode \nof each operation of v{\\sc mw}{\\sc ABD}{}\\ is described in Figure~\\ref{fig:abd}.\nThe $\\act{cvr-read}$ operation is similar to the read\noperation of {\\sc mw}{\\sc ABD}{}{} with the difference that it \nreturns both the value and the version of the register.  \nA $\\act{cvr-write}$ operation differs from the original write\nby utilizing a condition before its \\emph{propagation} phase\n{{and depending whether the condition holds it changes the state of the register (value and version) or not,   as detailed in Figure~\\ref{fig:abd}.}} Note that \nthe version parameter of the write operation is equal to\nthe maximum tag that the invoking process witnessed.\\vspace{-.3em}\n\n\n\\remove{\nIn particular,\na $\\act{cvr-write}$ is executed in two phases. During the\nfirst phase it collects the value of the object from a majority of replicas\nand discovers the maximum tag among the replies. Before \nmoving to a second phase the $\\act{cvr-write}$ checks whether \nits local tag is equal to the maximum tag discovered in\nthe first phase. If this is the case then the $\\act{cvr-write}$\nacts as the original {\\sc mw}{\\sc ABD}{}{} write operation, \nby incrementing the tag and sending the new tag along with the value to be written to a majority of \nreplicas. If the condition does not hold then the $\\act{cvr-write}$ acts as\nthe second phase of a read operation in the original {\\sc mw}{\\sc ABD}{}{} and propagates the \nmaximum tag together with its associated value to the majority of replicas. \nIn the first case the write operation returns the value and version written \nalong with the flag $chg$ to indicate the modification of the register. \nIn the latter case the operation returns the maximum tag-value pair discovered \nin its query-phase along with the flag $unchg$ to indicate that the \nregister was not modified. \n}\n\n\\begin{figure}[t]\n\\hrule\\vspace{0.15cm}\n\\begin{footnotesize}\n\n\t\t\n\t\t\t\n\t\t\t\n\t\t$\\act{cvr-write}(val, ver = maxtag)$\n\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\\item[] \\act{query-phase}: Send query request to \\emph{all} the replicas and wait to \n\t\t\t\treceive $(tag,value)$ responses from a majority of them. Select the \n\t\t\t\t$(tag,value)$ among the collected replies with the largest tag; \n\t\t\t\tlet the $\\tup{\\tau,v}$ be this pair and the integer component of $\\tau$ be $z$. Then: \\vspace{-0.5em}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\t\\item If $ver == \\tau$\tthen: \n\t\t\t\t\tCreate a new tag $\\tau_{new} = \\tup{z+1, wid}$ \n\t\t\t\t\twhere $wid$ is the unique identifier of the writer\n\t\t\t\t\tand set $val_{new} = val$. \n\t\t\t\t\t\n\t\t\t\t\t\\item If $ver \\neq \\tau$ then: Set $\\tup{\\tau_{new}, val_{new}} = \\tup{\\tau,v}$. \\vspace{-0.5em}\n\t\t\t\t\t\n\t\t\t\t\\end{itemize}\n\t\t\t\t\n\t\t\t\t\\item[] \\act{propagation-phase}: \n\t\t\t\t\tSend $\\tup{\\tau_{new}, val_{new}}$ to all the replicas and wait to \n\t\t\t\t\treceive responses from a majority of them. \n\t\t\t\t\tif $ver == \\tau$ then respond with $\\tup{val_{new}, \\tau_{new}, chg}$,\n\t\t\t\t\totherwise respond with $\\tup{val_{new}, \\tau_{new}, unchg}$ to the process. \n\t\t\t\\end{itemize}\n\t\t\t\n\t\t\t\n\t\t\t$\\act{cvr-read}()$\n\t\t\t\\begin{itemize} [leftmargin=5mm]\n\t\t\t\t\\item[] \\act{query-phase}: Send query request to \\emph{all} the replicas and wait to \n\t\t\t\treceive $(tag,value)$ responses from a majority of them. Select the \n\t\t\t\t$(tag,value)$ among the collected replies with the largest tag; \n\t\t\t\tlet the $\\tup{\\tau,v}$ be this pair and the integer component of $\\tau$ be $z$.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\\item[] \\act{propagation-phase}: \n\t\t\t\t\tSend $\\tup{\\tau, v}$ to all replicas and wait for responses from a majority of them. \n\t\t\t\t\tRespond with $\\tup{v, \\tau}$ to the process. \n\t\t\t\t\\end{itemize}\n\t\t\t\t\n\t\t\t\n\t\t\t\\act{at-replica}\n\t\t\t\\begin{itemize} [leftmargin=5mm]\n\t\t\t\t\\item[] On receipt of \\act{query} message: Send the tag-value \n\t\t\t\tpair $\\tup{\\tau_{r},v_r}$ stored locally.\n\t\t\t\t\n\t\t\t\t\\item[] On receipt of \\act{propagation} message: Let $\\tup{\\tau_m,v_m}$ be the tag-value\n\t\t\t\tpair enclosed in the received message and $\\tup{\\tau_r,v_r}$ the local pair on the replica. \n\t\t\t\tCompare the tags $\\tau_m$ and $\\tau_{r}$. If $\\tau_{m} > \\tau_{r}$ then \n\t\t\t\tstore $\\tup{\\tau_m,v_m}$ locally. Reply with ``ack\".\n\t\t\t\t\n\t\t\t\\end{itemize}\n\t\t\n\t\t\\end{footnotesize}\n\t\t\\hrule\\vspace{.2em}\n\n\\caption{The operations of algorithm v{\\sc mw}{\\sc ABD}{}.}\n\\label{fig:abd}\\vspace{-1em}\n\\end{figure}\n\n\n\\begin{theorem}\nAlgorithm \\rm{v}{\\sc mw}{\\sc ABD}{}{} implements weak coverable atomic registers.\n\\end{theorem} \n\n\n\n\\begin{proof}\nIt is clear that \\rm{v}{\\sc mw}{\\sc ABD}{}{} still satisfies properties {\\bf A1-A3}. Any write operation \nthat is not successful can be mapped to a read operation that performs two phases and propagates the latest\nvalue/version of the register to a majority of replicas \nbefore completing.  \nIt remains to show that \n\n\\rm{v}{\\sc mw}{\\sc ABD}{}{} also satisfies \nthe properties of validity and weak coverability. \n\n\\emph{Validity} is satisfied since each tag is unique, as it is composed by \nan integer and the id of a process. The tag is monotonically incrementing\nat each replica, as according to the algorithm a replica updates its local \ncopy only if a higher tag is received. A writer process discovers the maximum \ntag $maxtag$ among the replicas and in the second phase it generates a tag $\\tup{maxtag+1,wid}$. \nAs the tag at each replica is monotonically incrementing then each writer never \ngenerates the same tag twice. Also, for every write \n${cvr\\mhyphen{\\omega}({{tag_{{}}}})[{{tag_{{}}}',chg}]}$, ${tag_{{}}}'=\\tup{{tag_{{}}}.ts+1, wid} \\Rightarrow {tag_{{}}}'>{tag_{{}}}$. \nFinally, since every tag is generated by extending the initial tag and each \nwrite operation extends a tag that obtains during its query phase then \nthere is a sequence of tags leading from the initial tag to the tag used\nby the write operation.\n\n\nFor \\emph{consolidation} we need to show that for two write \noperations ${\\omega}_1={cvr\\mhyphen{\\omega}({*})[{{tag_{{1}}},chg}]}$ and ${\\omega}_2={cvr\\mhyphen{\\omega}({{tag_{{2}}}})[{*,chg}]}$,\nif ${\\omega}_1\\rightarrow_{\\EX}{\\omega}_2$ then ${tag_{{1}}} \\leq {tag_{{2}}}$.  \nAccording to the algorithm ${\\omega}_1$ propagates ${tag_{{1}}}$ to the \nmajority of replicas before completing. \n \n\n\n\nIn the query phase, ${\\omega}_2$ receives messages from the \nmajority of replicas. So there is one replica $s$ that received\n${tag_{{1}}}$ from ${\\omega}_1$ before replying to ${\\omega}_2$. Since \nthe ${tag_{{}}}$ in $s$ is monotonically incrementing, then $s$ \nreplies to ${\\omega}_2$ with a tag ${tag_{{s}}}\\geq{tag_{{1}}}$.\nSo ${\\omega}_2$ receives a $maxtag\\geq {tag_{{1}}}$.\nSince ${\\omega}_2$ also changes the value and version of the \nregister it means that its local tag ${tag_{{2}}}$ is equal to $maxtag$. \nThis shows immediately that ${tag_{{2}}} \\geq {tag_{{1}}}$, completing the proof.\n\n\\emph{Continuity} is preserved as a write operation first queries the \nreplicas for the latest tag before proceeding to the propagation phase \nto write a new value. Since the tags are generated and propagated only \nby write operations then if a write changes the value of the system then \nit appends a tag already written, or the initial tag of the register.\n\nFinally, to show that \\emph{evolution} is preserved, we observe that the version of a register is given by\nits tag, where tags are compared lexicographically (first the number ${tag_{{}}}.ts$ and then the writer identifier to break ties).\nA successful write ${\\pi}_1={cvr\\mhyphen{\\omega}({{tag_{{}}}})[{{tag_{{}}}'}]}$ generates a new tag ${tag_{{}}}'$ from ${tag_{{}}}$ such\nthat ${tag_{{}}}'.ts = {tag_{{}}}.ts + 1$. Consider sequences of tags ${tag_{{1}}}, {tag_{{2}}},\\ldots, {tag_{{k}}}$\nand ${tag_{{1}}}', {tag_{{2}}}',\\ldots, {tag_{{\\ell}}}'$ such that ${tag_{{1}}}={tag_{{1}}}'$.\nAssume that ${cvr\\mhyphen{\\omega}({{tag_{{i}}}})[{{tag_{{i+1}}}}]}$, for $1\\leq i<k$, and ${cvr\\mhyphen{\\omega}({{tag_{{i}}}'})[{{tag_{{i+1}}}'}]}$, for $1\\leq i<\\ell$,\nare successful write operations.\nIf ${tag_{{1}}}.ts={tag_{{1}}}'.ts=z$, then ${tag_{{k}}}.ts=z+k$ and ${tag_{{\\ell}}}'.ts=z+\\ell$, and if $k < \\ell$ then ${tag_{{k}}} < {tag_{{\\ell}}}'$.\\vspace{.3em}\n\\end{proof}\n\n\n\n\n\n\n\n\n\n\n\n\n\\remove{\nFor \\emph{continuity} we need to show that for two write \noperations ${\\omega}_1={cvr\\mhyphen{\\omega}({{tag_{{1}}}})[{*,chg}]}$ and ${\\omega}_2={cvr\\mhyphen{\\omega}({{tag_{{2}}}})[{*,chg}]}$,\nif ${\\omega}_1\\rightarrow_{\\EX}{\\omega}_2$ then ${tag_{{1}}} < {tag_{{2}}}$.  \nSince ${\\omega}_1$ completes before ${\\omega}_2$ then there exists \na majority of replicas that have a tag at least as large as ${tag_{{1}}}$.\nSince, however, ${\\omega}_1$ is successful then in its second phase \nit propagates a tag ${tag_{{1}}}+1> {tag_{{1}}}$. \nSo ${\\omega}_2$ receives a $maxtag\\geq {tag_{{1}}}+1 > {tag_{{1}}}$.\nSince ${\\omega}_2$ also changes the value and version of the \nregister it means that its local tag ${tag_{{2}}}$ is equal to maxtag. \nThis shows immediately that ${tag_{{2}}} > {tag_{{1}}}$, completing the proof.\n\n\\emph{Evolution}\nrequires that if two writers $w_i$ and $w_j$ invoke ${\\omega}_1={cvr\\mhyphen{\\omega}({{tag_{{1}}}})[{*,chg}]}$ and ${\\omega}_2={cvr\\mhyphen{\\omega}({{tag_{{2}}}})[{*,chg}]}$,\nand ${tag_{{1}}}<{tag_{{2}}}$, then ${\\omega}_1$ appears before ${\\omega}_2$ in the total order.\nAccording to the algorithm, if ${tag_{{1}}}=\\tup{z,*}$, then ${\\omega}_1={cvr\\mhyphen{\\omega}({\\tup{z,*}})[{\\tup{z+1,w_i},chg}]}$.\nWe have two cases to consider: (i) either ${tag_{{2}}}=\\tup{z+1,w_i}$, or (ii)   ${tag_{{2}}}>\\tup{z+1,w_i}$.\n}\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\remove{\n\\emph{Consolidation} is\nsatisfied if write operations either extent th . \nLet a write ${\\omega}_1 = {cvr\\mhyphen{\\omega}({v_1, ver})[{v_1, {tag_{{1}}},chg}]}$ be\na successful write operation that writes $v_1$ \nwith a version ${tag_{{1}}}$ and is not \nconcurrent with any other operation. \nDuring its second phase ${\\omega}_1$ communicates with a majority of replicas. \n\n\n\nSince the tag of the replicas increments monotonically, then the tag of any replica that received a \nwrite message from ${\\omega}_1$ is equal to ${tag_{{1}}}$ when ${\\omega}_1$ completes. \nSo any succeeding \\emph{write} ${\\omega}_2$ discovers a maximum tag greater or equal than ${tag_{{1}}}$ during its query phase as it communicates with a majority of replicas.  \nIf the maximum tag is greater \nthan ${tag_{{1}}}$ it follows that some \\emph{write} that succeeded ${\\omega}_1$ revised $v_1$ and the version ${tag_{{1}}}$.\nIf the maximum tag is equal to ${tag_{{1}}}$ then \nthere are two cases for \nthe local tag ${tag_{{2}}}$ of ${\\omega}_2$: \n(a) ${tag_{{2}}} = {tag_{{1}}}$ , or (b) ${tag_{{2}}} < {tag_{{1}}}$. If (a) \nis true then the process invoking ${\\omega}_2$ already read ${tag_{{1}}}$ and wants to associate $v_2$ with version ${tag_{{2}}}+1={tag_{{1}}}+1$.\n\nIf (b) holds then ${\\omega}_2$ has an outdated\nversion and acts as a read.\\vspace{.2em}\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\noindent{\\bf Supporting Large Versioned Objects.}\nFan and Lynch~\\cite{FL03}, using algorithm {\\sc mw}{\\sc ABD}{}\\ as a building block, \nshowed how large atomic R/W objects can be efficiently replicated. The main idea \nof their algorithm, called LDR, is to have\ntwo distinguished sets of servers: Replicas and Directories. Replica servers\nare the ones that actually store the object's data (value), while Directories keep track\nof the tags of the object and the associated Replicas that store the data of\nthe object. A reader or writer first runs algorithm {\\sc mw}{\\sc ABD}{}\\ on the Directories to\nobtain the highest tag of the object, and the identity of the Replicas that have the associated\nvalue (aka, the most recent value of the object). A read operation, then\ncontacts a subset of the Replicas to obtain the value of the object. \nA write sends the new value to a majority of the Replicas, while ensuring\nthat Directories are updated (see~\\cite{FL03} for details). \nBy replacing algorithm {\\sc mw}{\\sc ABD}{}\\ with algorithm v{\\sc mw}{\\sc ABD}{}\\ and performing a few modifications\nto the Replicas, we can turn algorithm LDR into an algorithm that can handle\n{\\em large versioned R/W objects}, such as large files. \nSee Appendix~\\ref{appx:files} for the modified LDR. \\vspace{-.5em}\n\n\n\\remove{\n\\paragraph{Avoiding starvation.} Notice that \ntwo concurrent write operations ${\\omega}_1$ and ${\\omega}_2$ may witness the same \nmaximum tag if they invoke their \\emph{query} \nphase at the same time. Notice that at the end\nof their \\emph{query} phases they both generate\na new tag $\\tup{t,{w}_1}$ and $\\tup{t,{w}_2}$\nfor ${\\omega}_1$ and ${\\omega}_2$ respectively. As the integer part of the tag is the same, these write \noperations will be ordered in terms of their identifier: for instance the write operations coming \nfrom the writer with the highest identifier wins. \nIn the case of updates the above scenario may lead two write operations to obtain the same version \nof the file. If both try to write their own version \nin a second phase then only the writer with the \nhighest tag will succeed. This however may lead to \nthe \\emph{starvation} of a process with a lower identifier.\n\nTo solve the problem we propose an enhancement on the\ntags used in the system. In particular we add a new \nfield in the tag that is a counter on how many times \na writer succeeded to write on the shared object. \nThus the tag becomes a triplet of the form $\\tup{t,wid,sc}\\in{\\N}\\times{\\mathcal{W}}\\times{\\N}$. We say\nthat a tag $\\tau_1$ is greater than a tag $\\tau_2$\nif: (i) $\\tau_1.t > \\tau_2.t$, or (ii) $\\tau_1.t= \\tau_2.t$ and $\\tau_1.sc < \\tau_2.sc$, or (iii) \n$\\tau_1.t = \\tau_2.t$, $\\tau_1.sc = \\tau_2.sc$ and\n$\\tau_1.wid > \\tau_2.wid$. Using this tagging scheme\nthe algorithm gives priority to the write operations\nwith the less write successes in case of a write \ncollision. So a writer with a small identifier \nwill eventually be able to escape starvation and \nchange the value of the shared object.\n}\n\n\n\n\n\\section{Conclusion}\n\\label{sec:conclude}\n\nIn this paper we have introduced {\\em versioned registers} and a new property \nfor concurrent versioned registers, we call \\emph{coverability}. \nA versioned register associates a version with its value, and with each operation that wants to modify its value.\nAn operation may modify the value and the version of the register, or it may just retrieve its value-version pair.  \nCoverability defines the exact guarantees that a versioned register \nprovides when it is accessed concurrently by multiple processes with respect to the evolution of its versions,\nover a total order of its operations.\nWe introduce two levels of coverability: \\emph{strong} and \\emph{weak}. Strong coverability \nrequires that only a single operation modifies each version of the register, whereas weak coverability\nis more relaxed allowing multiple concurrent operations to modify the same version.\n\nWe combine coverability with atomicity to obtain (strongly/weakly) coverable atomic registers. \nThe successful writes on the register follow the total order of atomicity, while preserving the\nproperties required by coverability. We note that a different total ordering could be used with\ncoverability to obtain other types of ``coverable objects\". In fact, we believe it would be interesting \nto investigate further the use of coverable objects for the introduction of distributed algorithms \nfor various applications. The fact that each operation is enhanced by the version of the object provides \nthe flexibility to manipulate the effect of an operation under some conditions on \nthe version of the object with respect to the version of the operation.\n\n\\newpage\n\n\n\\remove{\nIn this paper we define a new register object type we call \\emph{versioned register} \nand a new property for concurrent versioned registers, we call \\emph{coverability}. \nA versioned register associates a version with its value, and with each operation that wants to modify its value.\nAn operation may modify the value and the version of the \nregister, or it may just retrieve its value-version pair.  \nCoverability defines the exact guarantees that a versioned register \nprovides when it is accessed concurrently by multiple processes with respect to the evolution of its versions.\nWe introduce two levels of coverability: \\emph{strong} and \\emph{weak}. Strong coverability \nrequires that only a single operation modifies each version of the register, whereas weak coverability\nis more relaxed allowing multiple concurrent operations to modify the same version.\n\nWe have shown that strong coverability is equivalent with \nconsensus. Hence, for the most of the paper we focused on the uses of weakly coverable atomic R/W registers.  \n\n\nWeakly coverable atomic R/W registers \nare interesting in their own right, as they differ from atomic R/W\nregisters, as well as from specialized register types like \\emph{ranked-registers}. \nAlso, they can be  used to implement weak RMW objects \nand concurrent file objects. \nWeak RMW objects are of interest to applications that require read-modify-write \nsemantics, demand fault-tolerance, and have lower operation contention. Concurrent file objects\nmight be used from applications to allow high degree of collaboration, providing at the \nsame time provable consistency guarantees on the values of the file. \nFurther to their applicability, we demonstrate that it is relatively simple to enhance \nexisting regular distributed atomic R/W registers to provide coverability guarantees.\nAs an example, we show how one can obtain MWMR weakly coverable atomic registers by modifying \nthe multi-writer variant of ABD~\\cite{ABD96}. \nWe prove that the modified algorithm satisfies both the coverability and linearizability \nproperties, while at the same time tolerates-crash failures, and operates in an\nasynchronous, message-passing environment.\n\nIt would be interesting to investigate further the use of coverable objects \nfor the introduction of distributed algorithms for various applications. \nThe fact that each operation is enhanced by the version of the object provides \nthe flexibility to manipulate the effect of an operation under some conditions on \nthe version of the object with respect to the version of the operation.\n}\n\n\n\n\n\n\\bibliographystyle{acm}\n\n\\bibliography{biblio}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\newpage\n\n\\appendix\n\\section*{Appendix}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Impossibility of Implementing Weakly CoVerable \nRegisters using Ranked Registers}\n\\label{appx:rr}\n\\input{appendixproofs_v2.tex}\n\n\n\n\\section{Strong Coverability vs Consensus}\n\\label{appx:consensus}\n\\input{consensus.tex}\n\n\\newpage\n\n\\section{Supporting Large Files}\n\\label{appx:files}\n\nFigure \\ref{fig:ldr} depicts a modified version of the LDR algorithm\n\\cite{FL03}, that implements versioned large objects. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!h]\n\\hrule\\vspace{0.15cm}\n\t\\begin{footnotesize}\t\t\n\t\t\n\t\t\t\n\t\t\n\t\t$\\act{tr-write}(val, ver=maxtag)$\n\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\\item[] \\act{get-metadata}: Send query request to \\emph{directory servers} and wait for\n\t\t\t\t $(tag,location)$ responses from a majority of them. Select the \n\t\t\t\t$(tag,location)$ among the collected replies with the largest tag; \n\t\t\t\tlet $\\tup{\\tau,{\\mathcal{S}}}$ be this pair and the integer component of $\\tau$ be $z$. Then:\n\t\t\n\t\t\t\t\n\t\t\t\t\\item[] If $\\tau \\neq ver$\tthen do the following: \n\t\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\t\\item[] \\act{put-metadata}: Send $\\tup{\\tau,{\\mathcal{S}}}$ to the \n\t\t\t\t\t\\emph{directory servers} and wait for a majority of them to reply. Once those\n\t\t\t\t\treplies are received set $\\tup{\\tau_{new},{\\mathcal{S}}_{new}} = \\tup{\\tau, {\\mathcal{S}}}$.\n\t\t\t\t\t\n\t\t\t\t\t\\item[] \\act{get}: Send \\emph{get object} request to $f+1$ \\emph{replica servers}\n\t\t\t\t\tin ${\\mathcal{S}}$ for the $\\tau$ version of the object and wait for a single server \n\t\t\t\t\tto reply with $x$. Return $\\tup{x, \\tau, unchg}$. \n\t\t\t\t\\end{itemize}\n\t\t\t\t\n\t\t\t\t\\item[] If $\\tau = ver$ then do the following: \n\t\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\t\\item[] \\act{put}: \n\t\t\t\t\t\n\t\t\t\t\tCreate a new tag $\\tau_{new} = \\tup{z+1, wid}$ where $wid$ is the unique \n\t\t\t\t\tidentifier of the writer. Send $\\tup{\\tau_{new}, val}$ to $2f+1$ \\emph{replica servers} \n\t\t\t\t\tand wait for $f+1$ replies. Collect the identifiers of the servers that replied in \n\t\t\t\t\ta set ${\\mathcal{S}}_{new}$.\n\t\t\t\t\t\\item[] \\act{put-metadata}: Send $\\tup{\\tau_{new},{\\mathcal{S}}_{new}}$ to all the \\emph{directory servers}\n\t\t\t\t\tand wait for the majority of them to reply. Return $\\tup{val, \\tau_{new}, chg}$. \n\t\t\t\t\\end{itemize}\t\t\t\t\n\n\t\t\t\\end{itemize}\n\t\t\t\n\n\t\t\t$\\act{tr-read}()$\n\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\\item[] \\act{get-metadata}: Send query request to \\emph{directory servers} and wait for\n\t\t\t\t$(tag,location)$ responses from a majority of them. Select the \n\t\t\t\t$(tag,location)$ among the collected replies with the largest tag; \n\t\t\t\tlet $\\tup{\\tau,{\\mathcal{S}}}$ be this pair and the integer component of $\\tau$ be $z$.\n\t\t\t\t\n\t\t\t\t\\item[] \\act{put-metadata}: Send $\\tup{\\tau,{\\mathcal{S}}}$ to the \n\t\t\t\t\\emph{directory servers} and wait for a majority of them to reply\n\t\t\t\t\t\n\t\t\t\t\\item[] \\act{get}: Send \\emph{get object} request to $f+1$ \\emph{replica servers}\n\t\t\t\tin ${\\mathcal{S}}$ for the $\\tau$ version of the object and wait for a single server \n\t\t\t\tto reply with $x$. Return $\\tup{x, \\tau}$. \t\t\t\t\t\n\t\t\t\\end{itemize}\n\t\t\t\n\t\t\n\t\t\\act{directory-server}\n\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\\item[] On receipt of \\act{get-metadata} message: Send the tag-locations \n\t\t\t\tpair $\\tup{\\tau_{s},{\\mathcal{S}}}$ stored locally.\n\t\t\t\t\n\t\t\t\t\\item[] On receipt of \\act{put-metadata} message: Let $\\tup{\\tau_m,{\\mathcal{S}}_m}$ be the tag-location\n\t\t\t\tpair enclosed in the received message and $\\tup{\\tau_s,{\\mathcal{S}}}$ the local pair on the server. \n\t\t\t\tCompare the tags $\\tau_m$ and $\\tau_{s}$. If $\\tau_{m} > \\tau_{s}$ and $|{\\mathcal{S}}_m|\\geq f+1$ then \n\t\t\t\tstore $\\tup{\\tau_m,{\\mathcal{S}}_m}$ locally.\n\t\t\t\\end{itemize}\n\t\t\t\n\n\t\t\\act{replica-server}\n\t\t\t\\begin{itemize}[leftmargin=5mm]\n\t\t\t\t\\item[] On receipt of \\act{put} message: Add the $\\tup{\\tau_m,value}$ pair enclosed in the message to \n\t\t\t\tthe local set of available pairs and send an acknowledgement. \n\t\t\t\t\n\t\t\t\t\\item[] On receipt of \\act{get} message: If the value associated with the requested tag is in the \n\t\t\t\tset of pairs stored locally, respond with the value. Otherwise ignore the message.\n\t\t\t\\end{itemize}\n\t\t\t\n\t\t\n\t\t\\end{footnotesize}\n\t\t\\hrule\\vspace{.4em}\n\\caption{Operations of the modified LDR algorithm}\n\\label{fig:ldr}\n\\end{figure}\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 20237, "prevtext": " \n\nThe set now of produced versions \nin the history ${H_{{\\EX}}}$ is defined by:\n", "index": 3, "text": "\n\\[\n{\\mathit{Versions}}_{\\EX} = \\{ver_i : {cvr\\mhyphen{\\omega}({ver})[{ver_i}]}_{{p}_i}\\in {\\mathcal{W}}_{\\EX, succ}\\}\\cup\\{ver_0\\}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"{\\mathit{Versions}}_{\\EX}=\\{ver_{i}:{cvr\\mhyphen{\\omega}({ver})[{ver_{i}}]}_{{%&#10;p}_{i}}\\in{\\mathcal{W}}_{\\EX,succ}\\}\\cup\\{ver_{0}\\}\" display=\"block\"><mrow><msub><mi>\ud835\udc49\ud835\udc52\ud835\udc5f\ud835\udc60\ud835\udc56\ud835\udc5c\ud835\udc5b\ud835\udc60</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\EX</mtext></merror></msub><mo>=</mo><mrow><mrow><mo stretchy=\"false\">{</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><mo>:</mo><mrow><mrow><mi>c</mi><mo>\u2062</mo><mi>v</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mhyphen</mtext></merror><mo>\u2062</mo><mi>\u03c9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>r</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mrow><mo stretchy=\"false\">[</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">]</mo></mrow><msub><mi>p</mi><mi>i</mi></msub></msub></mrow><mo>\u2208</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb2</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\EX</mtext></merror><mo>,</mo><mrow><mi>s</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>c</mi></mrow></mrow></msub></mrow><mo stretchy=\"false\">}</mo></mrow><mo>\u222a</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>v</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><msub><mi>r</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}]