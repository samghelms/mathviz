[{"file": "1601.07363.tex", "nexttext": " where ${\\mathbb{F}_2}^n\\rightarrow{\\mathbb{F}_2}$ is the space of all $n$-bit linear Boolean functions. It was left as an open question as to whether there exist other such identities, and whether such identities can be used to further reduce instances of $T$ gates.\n\nIn this paper we prove that the identities on $n$ qubits that are useful for reducing $T$-count is exactly the length $2^n-1$ punctured Reed-Muller code of order $n-4$. In doing so, we derive a new $T$-count optimization algorithm based on Reed-Muller decoding which is optimal for ${\\text{CNOT}}$ and $T$ gate circuits when a minimum distance decoder is used. We implemented this optimization algorithm as a module in the quantum circuit optimizer $T$-par \\cite{tpar} and tested it on general Clifford+$T$ circuits with different Reed-Muller decoders. The results show modest savings in $T$-count while still remaining tractable for circuits of non-trivial size. As a consequence of this equivalence, we also obtain a new upper bound on the number of $T$ gates required to implement a circuit over $\\{{\\text{CNOT}}, T\\}$, as well as evidence to the intractability of exact $T$-count minimization through a polynomial-time equivalence to the minimum distance decoding problem for the length $2^n-1$ punctured Reed-Muller code of order $n-4$.\n\nOur proof naturally generalizes to the case when the $T$ gate is replaced with a $Z$ rotation by any angle of the form $\\pi/2^k$. These gate sets are closely related to the Clifford-cyclotomic gate sets studied in \\cite{fgkm15}, and are widely used in quantum algorithms including Shor's algorithm \\cite{s94}. We show that the number of $\\pi/2^k$ rotation gates for each value of $k$ can be minimized by decoding Reed-Muller codes of different orders, opening up the possibility of optimizing such circuits at the high level, before decomposing them into a lower level gate set such as Clifford+$T$. Further generalization to rotation angles that are arbitrary roots of unity is also possible, with any composite order $2^x3^y5^z\\cdots$ reducing to the case for a root of order $2^x$.\n\n\\subsection{Related work}\nMuch work has gone into $T$-count and depth reduction in recent years.\nAmy {\\it et al. } \\cite{ammr13} identified the $T$-count and $T$-depth as important quantities in the efficiency of a logical quantum circuit, and gave new implementations of 2--4 bit quantum operations reducing $T$-count and depth from the previously best known. Their search-based algorithm was later optimized and extended by Gosset {\\it et al. } \\cite{gkmr14} to directly optimize $T$-depth, leading to proofs of $T$-depth minimality for various 2--4 bit circuits. Selinger \\cite{s13} showed that the Toffoli gate, as well as a general class of Clifford+$T$ circuits, can be parallelized to $T$-depth 1 with sufficiently many ancillas. Constructions for adding controls to quantum gates were also given which lowered the $T$-count and depth compared to best known practices using Toffoli gates. Amy, Maslov and Mosca later used similar ideas to create an automated, polynomial-time tool for reducing and parallelizing $T$ gates called $T$-par, which uses matroid partitioning to parallelize the $T$ gates. More recently, Abdessaied, Soeken and Drechsler \\cite{asd14} studied the effect of Hadamard gates on $T$-count and depth reductions, developing a tool that reduces Hadamard gates in quantum circuits leading to further $T$ gate optimizations. Maslov \\cite{m15} examined Toffoli gate implementations up to relative phase and used them to develop new designs for multiple control Toffolis using fewer ancillas, ${\\text{CNOT}}$, and in some cases $T$ gates, than standard designs. \n\nA great deal of work optimizing $T$-count and depth in single qubit circuits has also been done recently, with series of works on exact \\cite{kmm12} and approximate \\cite{kmm13, s15, rs14} minimal synthesis, as well as repeat-until-success circuits \\cite{ps14, brs15}. \n\n\\subsection{Overview}\nThe rest of the paper is organized as follows. Section~\\ref{sec:prelim} gives definitions and notation that will be used throughout the paper. Section~\\ref{sec:phase} defines the linear phase operators, details their representation as weighted sums of linear Boolean functions and synthesis. Section~\\ref{sec:topt} defines an additive subgroup of ${\\mathbb{Z}}_8^{2^n-1}$ whose cosets correspond to the unique linear phase operators, then characterizes its binary residue as a Reed-Muller code and gives applications. Section~\\ref{sec:proofmain} formally proves the equivalence of this (binary residue) subgroup with the length $2^n-1$ punctured Reed-Muller code of order $n-4$. Finally Section~\\ref{sec:generalization} generalizes the result to circuits over ${\\text{CNOT}}$ gates and phase rotations with angles of the form $\\pi/2^k$, and Section~\\ref{sec:experiments} details the experimental evaluation of our technique.\n\n\\section{Preliminaries}\\label{sec:prelim}\n\nWe assume basic knowledge of quantum computing, but no knowledge of coding theory. For background on quantum computing, the reader is referred to \\cite{nc00}.\n\n\\subsection{Quantum gates}\n\nIn this paper we will primarily be interested in two gates: the controlled-NOT (${\\text{CNOT}}:{|{x}\\rangle}{|{y}\\rangle}\\mapsto{|{x}\\rangle}{|{x\\oplus y}\\rangle}$) and the $T$-gate ($T:{|{x}\\rangle}\\mapsto e^{i\\frac\\pi4x}{|{x}\\rangle}$). These two gates, together with $P:=T^2$ and $Z:=T^4$ gates, comprise what we refer to for brevity as the $\\{{\\text{CNOT}}, T\\}$ gate set. We include the $P$ and $Z$ gates in this set to distinguish them from sequences of $T$ gates which are generally much more expensive to implement in most fault-tolerance schemes. Given any power $k\\in{\\mathbb{Z}}_8$ of the $T$ gate, we define a minimal $T$-gate expansion by \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\title{T-count optimization and Reed-Muller codes}\n\n\\author{Matthew Amy}\n\\email{meamy@uwaterloo.ca}\n\\affiliation{Institute for Quantum Computing, University of Waterloo, Waterloo, ON, Canada}\n\\affiliation{David R. Cheriton School of Computer Science, University of Waterloo, Waterloo, ON, Canada}\n\n\\author{Michele Mosca}\n\\email{michele.mosca@uwaterloo.ca}\n\\affiliation{Institute for Quantum Computing, University of Waterloo, Waterloo, ON, Canada}\n\\affiliation{Department of Combinatorics \\& Optimization, University of Waterloo, Waterloo, ON, Canada}\n\\affiliation{Perimeter Institute for Theoretical Physics, Waterloo, ON, Canada}\n\\affiliation{Canadian Institute for Advanced Research, Toronto, ON, Canada}\n\n\\begin{abstract}\nWe prove an equivalence between exactly minimizing the number of $T$ gates in $n$-qubit quantum circuits over ${\\text{CNOT}}$ and $T$ gates, together with the Clifford group powers of $T$, and minimum distance decoding in the length $2^n-1$ punctured Reed-Muller code of order $n-4$. The equivalence arises from an analysis of the particular form of phase polynomials generated by ${\\text{CNOT}}$ and $T$ gates. As a consequence, we derive an algorithm for the optimization of $T$-count in $\\{{\\text{CNOT}}, T\\}$ quantum circuits based on Reed-Muller decoders, along with a new upper bound of $O(n^2)$ on the number of $T$ gates required to implement an $n$-qubit unitary over ${\\text{CNOT}}$ and $T$ gates. We further generalize this result to show that minimizing finer angle $Z$-rotations corresponds to decoding lower order binary Reed-Muller codes. In particular, we show that minimizing the number of $R_z(\\pi/2^k)$ gates in circuits over $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$ corresponds to minimum distance decoding in the length $2^n-1$ punctured Reed-Muller code of order $(n-k-2)$.\n\\end{abstract}\n\\maketitle\n\n\n\\section{Introduction}\n\nThe synthesis and optimization of quantum circuits has generated a great deal of interest in recent years. As qubit technologies become more stable and experimentalists increase the size of their systems, actually running algorithms on these machines becomes a practical concern. Moreover, we want to know how to \\emph{efficiently} run these algorithms on the given systems, or conversely how big and stable of a system we need to run a particular algorithm. Given the prevalence of the circuit model within quantum computing, quantum circuit optimization is an important tool in answering these questions.\n\nDue to the great affect of noise on quantum computations in the standard circuit model, much research has shifted its focus from optimizing physical circuits to logical ones with respect to a fault-tolerance schemes meant to mitigate the errors due to this noise. These schemes usually have striking differences from physical gates in terms of resource costs. In particular, most of the common schemes implement Clifford group gates \\emph{transversally} -- that is, by performing one physical gate on each physical qubit or group of qubits. This allows the logical operation to be performed precisely and with time proportional to the physical gate time. The additional operation needed to make a universal gate set is then typically implemented probabilistically with state distillation and gate teleportation, a less accurate procedure which requires both additional time and space compared to a single physical gate. The two qubit controlled-NOT (${\\text{CNOT}}$) gate, as an element of the Clifford group, is thus a relatively cheap operation in this paradigm, compared to the $T={\\text{diag}}(1, e^{i\\frac\\pi4})$ gate which is commonly chosen as the canonical non-Clifford gate. This is a reversal of the computational costs inherent in most physical implementations, where entangling gates are typically more difficult to implement than single qubit rotations, and hence requires different circuit optimizations.While alternative fault-tolerance methods such as Paetznick and Reichardt's completely transversal Clifford+$T$ scheme \\cite{pr13} and anyonic quantum computing \\cite{k03} are gaining in popularity, minimization of the number of $T$ gates -- called the $T$-count -- in quantum circuits is an important and widely studied goal.\n\nWe build on previous work by Amy, Maslov and Mosca on the reduction of $T$ gates in quantum circuits. In \\cite{ammr13} it was shown that unitaries implementable over ${\\text{CNOT}}$ and $T$ gates may be described in the computational basis as a bit-wise (linear) permutation together with a phase rotation that is an $8$th root of unity to a power given by a pseudo-Boolean function of the input bits. This function, called the circuit's \\emph{phase polynomial}, was shown to be expressible as a sum of linear Boolean functions, the multiplicity of each function giving the power of the $T$ gate required to produce the term. This idea was later used in \\cite{amm14} to optimize both $T$-count and $T$-depth -- the number of stages of parallel $T$-gates in a circuit -- by computing a circuit's phase polynomial, simplifying it, then synthesizing a new circuit from the polynomial with maximally parallelized $T$ gates. While their benchmarks showed significant reduction of $T$ gates, it was noted that this approach was not optimal, as it was shown that there exist distinct phase polynomials that give rise to the same unitary. In particular, it was observed that for all $x_1,x_2,x_3,x_4\\in{\\mathbb{F}_2}$,\n", "index": 1, "text": "\n\\[e^{i\\frac\\pi4\\sum_{f\\in{\\mathbb{F}_2}^4\\rightarrow{\\mathbb{F}_2}}f(x_1,x_2,x_3,x_4)}=1=e^0,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"e^{i\\frac{\\pi}{4}\\sum_{f\\in{\\mathbb{F}_{2}}^{4}\\rightarrow{\\mathbb{F}_{2}}}f(x%&#10;_{1},x_{2},x_{3},x_{4})}=1=e^{0},\" display=\"block\"><mrow><mrow><msup><mi>e</mi><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><mn>4</mn></mfrac><mo>\u2062</mo><mrow><mstyle displaystyle=\"false\"><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>f</mi><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mn>4</mn></mmultiscripts><mo>\u2192</mo><msub><mi>\ud835\udd3d</mi><mn>2</mn></msub></mrow></msub></mstyle><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>x</mi><mn>3</mn></msub><mo>,</mo><msub><mi>x</mi><mn>4</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></msup><mo>=</mo><mn>1</mn><mo>=</mo><msup><mi>e</mi><mn>0</mn></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " where $k_2k_1k_0$ is the binary expansion of $k$. Note that $T^8=I$ so $T^k=T^{k\\mod 8}$ for all integers $k$.\n\nBy a circuit over a particular set of gates we mean a sequential list of gates taken from the set, each with a list of qubits the gate is to be applied to. In this way, two distinct circuits may correspond to the same unitary matrix -- we call such circuits \\emph{equivalent} in this case. The problem of optimizing quantum circuits is then to find, given a circuit, an equivalent circuit minimizing some cost function. In this work we consider optimizing strictly the $T$-count of quantum circuits, defined as the number of $T$ gates appearing in a circuit. In particular, we define the problem of $T$-gate minimization as follows:\n\n\\begin{problem}[$T$-gate minimization]\nGiven a circuit over a gate set containing the $T$ gate, find an equivalent circuit over the same gate set with a minimal number of $T$ gates.\n\\end{problem}\n\nFor completeness we also define the Hadamard gate in sum-over-paths style, \n", "itemtype": "equation", "pos": -1, "prevtext": " where ${\\mathbb{F}_2}^n\\rightarrow{\\mathbb{F}_2}$ is the space of all $n$-bit linear Boolean functions. It was left as an open question as to whether there exist other such identities, and whether such identities can be used to further reduce instances of $T$ gates.\n\nIn this paper we prove that the identities on $n$ qubits that are useful for reducing $T$-count is exactly the length $2^n-1$ punctured Reed-Muller code of order $n-4$. In doing so, we derive a new $T$-count optimization algorithm based on Reed-Muller decoding which is optimal for ${\\text{CNOT}}$ and $T$ gate circuits when a minimum distance decoder is used. We implemented this optimization algorithm as a module in the quantum circuit optimizer $T$-par \\cite{tpar} and tested it on general Clifford+$T$ circuits with different Reed-Muller decoders. The results show modest savings in $T$-count while still remaining tractable for circuits of non-trivial size. As a consequence of this equivalence, we also obtain a new upper bound on the number of $T$ gates required to implement a circuit over $\\{{\\text{CNOT}}, T\\}$, as well as evidence to the intractability of exact $T$-count minimization through a polynomial-time equivalence to the minimum distance decoding problem for the length $2^n-1$ punctured Reed-Muller code of order $n-4$.\n\nOur proof naturally generalizes to the case when the $T$ gate is replaced with a $Z$ rotation by any angle of the form $\\pi/2^k$. These gate sets are closely related to the Clifford-cyclotomic gate sets studied in \\cite{fgkm15}, and are widely used in quantum algorithms including Shor's algorithm \\cite{s94}. We show that the number of $\\pi/2^k$ rotation gates for each value of $k$ can be minimized by decoding Reed-Muller codes of different orders, opening up the possibility of optimizing such circuits at the high level, before decomposing them into a lower level gate set such as Clifford+$T$. Further generalization to rotation angles that are arbitrary roots of unity is also possible, with any composite order $2^x3^y5^z\\cdots$ reducing to the case for a root of order $2^x$.\n\n\\subsection{Related work}\nMuch work has gone into $T$-count and depth reduction in recent years.\nAmy {\\it et al. } \\cite{ammr13} identified the $T$-count and $T$-depth as important quantities in the efficiency of a logical quantum circuit, and gave new implementations of 2--4 bit quantum operations reducing $T$-count and depth from the previously best known. Their search-based algorithm was later optimized and extended by Gosset {\\it et al. } \\cite{gkmr14} to directly optimize $T$-depth, leading to proofs of $T$-depth minimality for various 2--4 bit circuits. Selinger \\cite{s13} showed that the Toffoli gate, as well as a general class of Clifford+$T$ circuits, can be parallelized to $T$-depth 1 with sufficiently many ancillas. Constructions for adding controls to quantum gates were also given which lowered the $T$-count and depth compared to best known practices using Toffoli gates. Amy, Maslov and Mosca later used similar ideas to create an automated, polynomial-time tool for reducing and parallelizing $T$ gates called $T$-par, which uses matroid partitioning to parallelize the $T$ gates. More recently, Abdessaied, Soeken and Drechsler \\cite{asd14} studied the effect of Hadamard gates on $T$-count and depth reductions, developing a tool that reduces Hadamard gates in quantum circuits leading to further $T$ gate optimizations. Maslov \\cite{m15} examined Toffoli gate implementations up to relative phase and used them to develop new designs for multiple control Toffolis using fewer ancillas, ${\\text{CNOT}}$, and in some cases $T$ gates, than standard designs. \n\nA great deal of work optimizing $T$-count and depth in single qubit circuits has also been done recently, with series of works on exact \\cite{kmm12} and approximate \\cite{kmm13, s15, rs14} minimal synthesis, as well as repeat-until-success circuits \\cite{ps14, brs15}. \n\n\\subsection{Overview}\nThe rest of the paper is organized as follows. Section~\\ref{sec:prelim} gives definitions and notation that will be used throughout the paper. Section~\\ref{sec:phase} defines the linear phase operators, details their representation as weighted sums of linear Boolean functions and synthesis. Section~\\ref{sec:topt} defines an additive subgroup of ${\\mathbb{Z}}_8^{2^n-1}$ whose cosets correspond to the unique linear phase operators, then characterizes its binary residue as a Reed-Muller code and gives applications. Section~\\ref{sec:proofmain} formally proves the equivalence of this (binary residue) subgroup with the length $2^n-1$ punctured Reed-Muller code of order $n-4$. Finally Section~\\ref{sec:generalization} generalizes the result to circuits over ${\\text{CNOT}}$ gates and phase rotations with angles of the form $\\pi/2^k$, and Section~\\ref{sec:experiments} details the experimental evaluation of our technique.\n\n\\section{Preliminaries}\\label{sec:prelim}\n\nWe assume basic knowledge of quantum computing, but no knowledge of coding theory. For background on quantum computing, the reader is referred to \\cite{nc00}.\n\n\\subsection{Quantum gates}\n\nIn this paper we will primarily be interested in two gates: the controlled-NOT (${\\text{CNOT}}:{|{x}\\rangle}{|{y}\\rangle}\\mapsto{|{x}\\rangle}{|{x\\oplus y}\\rangle}$) and the $T$-gate ($T:{|{x}\\rangle}\\mapsto e^{i\\frac\\pi4x}{|{x}\\rangle}$). These two gates, together with $P:=T^2$ and $Z:=T^4$ gates, comprise what we refer to for brevity as the $\\{{\\text{CNOT}}, T\\}$ gate set. We include the $P$ and $Z$ gates in this set to distinguish them from sequences of $T$ gates which are generally much more expensive to implement in most fault-tolerance schemes. Given any power $k\\in{\\mathbb{Z}}_8$ of the $T$ gate, we define a minimal $T$-gate expansion by \n", "index": 3, "text": "$$T^k:=Z^{k_2}P^{k_1}T^{k_0}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"T^{k}:=Z^{k_{2}}P^{k_{1}}T^{k_{0}}\" display=\"block\"><mrow><msup><mi>T</mi><mi>k</mi></msup><mo>:=</mo><mrow><msup><mi>Z</mi><msub><mi>k</mi><mn>2</mn></msub></msup><mo>\u2062</mo><msup><mi>P</mi><msub><mi>k</mi><mn>1</mn></msub></msup><mo>\u2062</mo><msup><mi>T</mi><msub><mi>k</mi><mn>0</mn></msub></msup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " The addition of the Hadamard gate to the $\\{{\\text{CNOT}}, T\\}$ gate set gives a universal set, in the sense that any unitary operator may be approximated efficiently with gates in this set. These gates form a set of generators of the \\emph{Clifford+$T$} gate set commonly used in fault-tolerant quantum computing.\n\n\\subsection{Coding theory}\n\nWe provide only the necessary definitions from coding theory -- for a more complete introduction, see MacWilliams \\& Sloane \\cite{ms78}.\n\nA length $n$ \\emph{binary linear code} is a subspace $C$ of ${\\mathbb{F}_2}^n$, where ${\\mathbb{F}_2}$ is the unique $2$-element field $(\\{0,1\\},\\oplus, \\cdot)$ with addition ($\\oplus$) and multiplication ($\\cdot$) modulo $2$. The vectors of $C$ are called the \\emph{codewords} of $C$. Note that ${\\mathbb{F}_2}$ is the set of Boolean values with addition corresponding to exclusive-OR and multiplication corresponding to AND. We also define Boolean negation in ${\\mathbb{F}_2}$ as $\\overline{x}:=1\\oplus x$. Addition, multiplication and negation are extended to vectors component-wise -- that is, ${\\textbf{x}}{\\textbf{y}}$ is the component-wise multiple of vectors ${\\textbf{x}}$ and ${\\textbf{y}}$, as opposed to vector space multiplication.\n\nWe denote binary vectors by boldface letters e.g., ${\\textbf{x}}=x_1x_2\\cdots x_n\\in{\\mathbb{F}_2}^n$, and use them interchangeably as bit strings. In particular, we denote the $n$-qubit computational basis vectors by ${|{{\\textbf{x}}}\\rangle}$ where ${\\textbf{x}}$ is a binary vector/bit string. The \\emph{(Hamming) weight} of a binary vector, denoted ${\\text{wt}}({\\textbf{x}}), {\\textbf{x}}\\in{\\mathbb{F}_2}^n$, is defined as the number of non-zero entries it contains, and the \\emph{(Hamming) distance} between two binary vectors ${\\textbf{x}},{\\textbf{y}}\\in{\\mathbb{F}_2}^n$ is the weight of their sum: \n", "itemtype": "equation", "pos": -1, "prevtext": " where $k_2k_1k_0$ is the binary expansion of $k$. Note that $T^8=I$ so $T^k=T^{k\\mod 8}$ for all integers $k$.\n\nBy a circuit over a particular set of gates we mean a sequential list of gates taken from the set, each with a list of qubits the gate is to be applied to. In this way, two distinct circuits may correspond to the same unitary matrix -- we call such circuits \\emph{equivalent} in this case. The problem of optimizing quantum circuits is then to find, given a circuit, an equivalent circuit minimizing some cost function. In this work we consider optimizing strictly the $T$-count of quantum circuits, defined as the number of $T$ gates appearing in a circuit. In particular, we define the problem of $T$-gate minimization as follows:\n\n\\begin{problem}[$T$-gate minimization]\nGiven a circuit over a gate set containing the $T$ gate, find an equivalent circuit over the same gate set with a minimal number of $T$ gates.\n\\end{problem}\n\nFor completeness we also define the Hadamard gate in sum-over-paths style, \n", "index": 5, "text": "$$H:{|{x}\\rangle}\\mapsto\\frac1{\\sqrt{2}}\\sum_{x'\\in\\{0,1\\}}(-1)^{x'}{|{x'}\\rangle}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"H:{|{x}\\rangle}\\mapsto\\frac{1}{\\sqrt{2}}\\sum_{x^{\\prime}\\in\\{0,1\\}}(-1)^{x^{%&#10;\\prime}}{|{x^{\\prime}}\\rangle}.\" display=\"block\"><mrow><mrow><mi>H</mi><mo>:</mo><mrow><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u21a6</mo><mrow><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>\u2208</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow></mrow></munder><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><msup><mi>x</mi><mo>\u2032</mo></msup></msup><mo>\u2062</mo><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nGiven a received vector ${\\textbf{x}}\\oplus\\boldsymbol{e}$ where ${\\textbf{x}}\\in C$ and $\\boldsymbol{e}\\in{\\mathbb{F}_2}^n$ is some error vector, we wish to find ${\\textbf{x}}$ -- this process is known as \\emph{decoding}. In this work, we are only concerned with \\emph{minimum distance decoding}, as it relates directly to $T$-count optimization.\n\\begin{problem}(Minimum distance decoding for a binary linear code $C$)\nGiven a received vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, find a codeword ${\\textbf{y}}\\in C$ such that for all ${\\textbf{z}}\\in C$, $d({\\textbf{x}}, {\\textbf{y}})\\leq d({\\textbf{x}},{\\textbf{z}})$.\n\\end{problem}\n\nThis problem is closely related to the more general \\emph{closest vector problem} (CVP) over a lattice, and in fact coincides with the CVP problem over the lattice $C$ with the Hamming weight as the norm. Minimum distance decoding is commonly studied as it reasonably approximates maximum likelihood decoding when bit flip errors are independent of one another.\n\nWe give one more definition from coding theory which will be relevant to our work: the maximum distance of any vector from a codeword, called the \\emph{covering radius}.\n\n\\begin{definition}\nThe \\emph{covering radius} of a length $n$ binary code $C$ is \n", "itemtype": "equation", "pos": 14287, "prevtext": " The addition of the Hadamard gate to the $\\{{\\text{CNOT}}, T\\}$ gate set gives a universal set, in the sense that any unitary operator may be approximated efficiently with gates in this set. These gates form a set of generators of the \\emph{Clifford+$T$} gate set commonly used in fault-tolerant quantum computing.\n\n\\subsection{Coding theory}\n\nWe provide only the necessary definitions from coding theory -- for a more complete introduction, see MacWilliams \\& Sloane \\cite{ms78}.\n\nA length $n$ \\emph{binary linear code} is a subspace $C$ of ${\\mathbb{F}_2}^n$, where ${\\mathbb{F}_2}$ is the unique $2$-element field $(\\{0,1\\},\\oplus, \\cdot)$ with addition ($\\oplus$) and multiplication ($\\cdot$) modulo $2$. The vectors of $C$ are called the \\emph{codewords} of $C$. Note that ${\\mathbb{F}_2}$ is the set of Boolean values with addition corresponding to exclusive-OR and multiplication corresponding to AND. We also define Boolean negation in ${\\mathbb{F}_2}$ as $\\overline{x}:=1\\oplus x$. Addition, multiplication and negation are extended to vectors component-wise -- that is, ${\\textbf{x}}{\\textbf{y}}$ is the component-wise multiple of vectors ${\\textbf{x}}$ and ${\\textbf{y}}$, as opposed to vector space multiplication.\n\nWe denote binary vectors by boldface letters e.g., ${\\textbf{x}}=x_1x_2\\cdots x_n\\in{\\mathbb{F}_2}^n$, and use them interchangeably as bit strings. In particular, we denote the $n$-qubit computational basis vectors by ${|{{\\textbf{x}}}\\rangle}$ where ${\\textbf{x}}$ is a binary vector/bit string. The \\emph{(Hamming) weight} of a binary vector, denoted ${\\text{wt}}({\\textbf{x}}), {\\textbf{x}}\\in{\\mathbb{F}_2}^n$, is defined as the number of non-zero entries it contains, and the \\emph{(Hamming) distance} between two binary vectors ${\\textbf{x}},{\\textbf{y}}\\in{\\mathbb{F}_2}^n$ is the weight of their sum: \n", "index": 7, "text": "$$d({\\textbf{x}}, {\\textbf{y}}):={\\text{wt}}({\\textbf{x}}\\oplus{\\textbf{y}}).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"d({\\textbf{x}},{\\textbf{y}}):={\\text{wt}}({\\textbf{x}}\\oplus{\\textbf{y}}).\" display=\"block\"><mrow><mrow><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo>,</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc31</mtext><mo>\u2295</mo><mtext>\ud835\udc32</mtext></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\\end{definition}\n\n\\subsection{Reed-Muller codes}\n\nMany different presentations of the binary Reed-Muller codes (\\cite{m54, r54}) are known; we use a presentation based on multivariate polynomials as it will provide a convenient setting for our proofs. For more details the reader is referred to \\cite{ms78}.\n\nLet ${\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ be the ring of polynomials in $n$ variables over ${\\mathbb{F}_2}$. We use the symbols $v_1,v_2,\\dots, v_n$ to denote Boolean variables so as to differentiate them from elements of binary vectors. Given $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ we define the \\emph{evaluation vector} of $f$, when viewed as an $n$-ary function, to be the length $2^n-1$ vector of evaluations of $f$ for inputs of non-zero Hamming weight -- i.e. \n", "itemtype": "equation", "pos": 15618, "prevtext": "\n\nGiven a received vector ${\\textbf{x}}\\oplus\\boldsymbol{e}$ where ${\\textbf{x}}\\in C$ and $\\boldsymbol{e}\\in{\\mathbb{F}_2}^n$ is some error vector, we wish to find ${\\textbf{x}}$ -- this process is known as \\emph{decoding}. In this work, we are only concerned with \\emph{minimum distance decoding}, as it relates directly to $T$-count optimization.\n\\begin{problem}(Minimum distance decoding for a binary linear code $C$)\nGiven a received vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, find a codeword ${\\textbf{y}}\\in C$ such that for all ${\\textbf{z}}\\in C$, $d({\\textbf{x}}, {\\textbf{y}})\\leq d({\\textbf{x}},{\\textbf{z}})$.\n\\end{problem}\n\nThis problem is closely related to the more general \\emph{closest vector problem} (CVP) over a lattice, and in fact coincides with the CVP problem over the lattice $C$ with the Hamming weight as the norm. Minimum distance decoding is commonly studied as it reasonably approximates maximum likelihood decoding when bit flip errors are independent of one another.\n\nWe give one more definition from coding theory which will be relevant to our work: the maximum distance of any vector from a codeword, called the \\emph{covering radius}.\n\n\\begin{definition}\nThe \\emph{covering radius} of a length $n$ binary code $C$ is \n", "index": 9, "text": "$$\\rho(C)=\\max_{{\\textbf{x}}\\in{\\mathbb{F}_2}^n}\\min_{{\\textbf{y}}\\in C}d({\\textbf{x}},{\\textbf{y}}).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\rho(C)=\\max_{{\\textbf{x}}\\in{\\mathbb{F}_{2}}^{n}}\\min_{{\\textbf{y}}\\in C}d({%&#10;\\textbf{x}},{\\textbf{y}}).\" display=\"block\"><mrow><mrow><mrow><mi>\u03c1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mi>max</mi><mrow><mtext>\ud835\udc31</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder><mo>\u2061</mo><mrow><munder><mi>min</mi><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mi>C</mi></mrow></munder><mo>\u2061</mo><mi>d</mi></mrow></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo>,</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " We denote the evaluation vector of a polynomial function $f$ by ${\\boldsymbol{f}}$. Since $v^2=v$ for all $v\\in{\\mathbb{F}_2}$, without loss of generality we only consider polynomials $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ that contain binary exponents $0$ or $1$ on variables. Identifying the variable $v_i$ with the Boolean function $f(v_1,v_2,\\dots, v_n)=v_i$, we denote the evaluation vector of $v_i$ by ${\\boldsymbol{v}}_i$. It can be easily verified that for any Boolean polynomial $f=\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}v_1^{y_1}v_2^{y_2}\\cdots v_n^{y_n}$, the evaluation vector of $f$ is equal to $\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{\\boldsymbol{v}}_1^{y_1}{\\boldsymbol{v}}_2^{y_2}\\cdots {\\boldsymbol{v}}_n^{y_n}$ -- again, exponentiation of a Boolean vector is defined as component-wise exponentiation.\n\nWe define the \\emph{total degree} of a monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be the sum of its exponents: \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\end{definition}\n\n\\subsection{Reed-Muller codes}\n\nMany different presentations of the binary Reed-Muller codes (\\cite{m54, r54}) are known; we use a presentation based on multivariate polynomials as it will provide a convenient setting for our proofs. For more details the reader is referred to \\cite{ms78}.\n\nLet ${\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ be the ring of polynomials in $n$ variables over ${\\mathbb{F}_2}$. We use the symbols $v_1,v_2,\\dots, v_n$ to denote Boolean variables so as to differentiate them from elements of binary vectors. Given $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ we define the \\emph{evaluation vector} of $f$, when viewed as an $n$-ary function, to be the length $2^n-1$ vector of evaluations of $f$ for inputs of non-zero Hamming weight -- i.e. \n", "index": 11, "text": "$$(f(1,0,\\dots, 0), f(0,1,\\dots, 0), \\dots, f(1,1,\\dots, 1)).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"(f(1,0,\\dots,0),f(0,1,\\dots,0),\\dots,f(1,1,\\dots,1)).\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " The degree of a polynomial function $f\\in{\\mathbb{F}_2}[v_1,v_2,\\cdots v_n]$, denoted ${\\text{deg}}(f)$, is defined as the maximum total degree of each monomial. Table~\\ref{tab:evals} illustrates the evaluation vectors of the $2^n$ monomials on $n$ variables. Note that the set of non-constant monomial evaluation vectors forms a basis for the space ${\\mathbb{F}_2}^{2^n-1}$.\n\n\\begin{table}\n\\centering\n\\begin{tabular}{c|c c c c c c}\n &  $(1,0,0,\\dots, 0)$ & $(0,1,0,\\dots, 0)$ & $(1,1,0,\\dots, 0)$ & $(0,0,1,\\dots, 0)$ & $\\cdots$ & $(1,1,1,\\dots, 1)$ \\\\ \\hline\n $1$ & 1 & 1 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_1$ & 1 & 0 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_2$ & 0 & 1 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_1v_2$ & 0 & 0 & 1 & 0 & $\\cdots$ & 1 \\\\\n  $v_3$ & 0 & 0 & 0 & 1 & $\\cdots$ & 1 \\\\\n $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\ddots$ & $\\vdots$ \\\\\n $v_1v_2\\cdots v_n$ & 0 & 0 & 0 & 0 & $\\cdots$ & 1\n\\end{tabular}\n\\caption{Evaluation vectors for monomials over $n$ Boolean variables.}\\label{tab:evals}\n\\end{table}\n\n\\begin{definition}\\label{def:rm}\nThe \\emph{punctured Reed-Muller code} of order $r$ and length $2^n-1$, denoted ${\\mathcal{RM}}(r, n)^*$, is the set of evaluation vectors for all polynomials $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ of degree at most $r$.\n\\end{definition}\n\nThe non-punctured, length $2^n$ Reed-Muller code or order $r$ is defined in a similar fashion, using evaluation vectors consisting of all $2^n$ distinct evaluations for a given polynomial function instead.\n\n\\subsection{Statement of main result}\n\nWe now state the main result.\n\n\\begin{theorem}\\label{thm:equiv}\nThe $T$-count minimization problem over $n$-qubit, $\\{{\\text{CNOT}}, T\\}$ circuits is polynomial-time (in $2^n$) equivalent to minimum distance decoding for ${\\mathcal{RM}}(n-4, n)^*$.\n\\end{theorem}\n\nWe prove Theorem~\\ref{thm:equiv} by showing that the number of $T$ gates in a $\\{{\\text{CNOT}}, T\\}$ circuit corresponds directly to the number of odd-weight elements of a tuple in ${\\mathbb{Z}}_8^{2^n-1}$. Moreover, this tuple can be computed from a circuit or vice versa in polynomial-time. An equivalence relation is then defined between tuples that implement the same unitary, which we show is in direct correspondence with cosets of the ${\\mathcal{RM}}(n-4, n)^*$ code. We then use this equivalence to utilize the wealth of research performed on Reed-Muller decoding for quantum circuit optimization.\n\n\\section{Linear phase operators}\\label{sec:phase}\nIn this section we introduce linear phase operators as the sub class of unitaries implementable by $\\{{\\text{CNOT}}, T\\}$ which require $T$ gates. We review their representation as pseudo-Boolean polynomial functions and define the canonical $T$-count for a particular polynomial. Finally we show that a minimal $T$-count implementation of a linear phase operator corresponds to a minimal weight vector of a vector space coset.\n\nWe define ${\\mathcal{P}}_4(n)$ to be the set of diagonal $2^n\\times 2^n$ unitaries implementable over $\\{{\\text{CNOT}}, T\\}$ -- we restrict our attention to this subset as any circuit over $\\{{\\text{CNOT}}, T\\}$ may be decomposed into a diagonal unitary followed by a permutation implementable using only ${\\text{CNOT}}$ gates. Amy {\\it et al. } \\cite[Lemma 2]{ammr13} showed that each such unitary $U\\in{\\mathcal{P}}_4(n)$ has the effect of applying a pseudo-Boolean function ${P}$ to a computational basis state ${|{{\\textbf{x}}}\\rangle}$, viewed as a vector ${\\textbf{x}}=x_1x_2\\cdots x_n\\in{\\mathbb{F}_2}^n$, and kicking the result into the phase: \n", "itemtype": "equation", "pos": -1, "prevtext": " We denote the evaluation vector of a polynomial function $f$ by ${\\boldsymbol{f}}$. Since $v^2=v$ for all $v\\in{\\mathbb{F}_2}$, without loss of generality we only consider polynomials $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ that contain binary exponents $0$ or $1$ on variables. Identifying the variable $v_i$ with the Boolean function $f(v_1,v_2,\\dots, v_n)=v_i$, we denote the evaluation vector of $v_i$ by ${\\boldsymbol{v}}_i$. It can be easily verified that for any Boolean polynomial $f=\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}v_1^{y_1}v_2^{y_2}\\cdots v_n^{y_n}$, the evaluation vector of $f$ is equal to $\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{\\boldsymbol{v}}_1^{y_1}{\\boldsymbol{v}}_2^{y_2}\\cdots {\\boldsymbol{v}}_n^{y_n}$ -- again, exponentiation of a Boolean vector is defined as component-wise exponentiation.\n\nWe define the \\emph{total degree} of a monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be the sum of its exponents: \n", "index": 13, "text": "$${\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})=\\sum_{i=1}^ny_i={\\text{wt}}({\\textbf{y}}).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"{\\text{deg}}({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})=\\sum%&#10;_{i=1}^{n}y_{i}={\\text{wt}}({\\textbf{y}}).\" display=\"block\"><mrow><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>y</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " Moreover, it was shown that the \\emph{phase polynomial} $P:{\\mathbb{F}_2}^n\\rightarrow{\\mathbb{Z}}_8$ necessarily has a presentation as a weighted sum of (non-zero) linear Boolean functions:\n", "itemtype": "equation", "pos": -1, "prevtext": " The degree of a polynomial function $f\\in{\\mathbb{F}_2}[v_1,v_2,\\cdots v_n]$, denoted ${\\text{deg}}(f)$, is defined as the maximum total degree of each monomial. Table~\\ref{tab:evals} illustrates the evaluation vectors of the $2^n$ monomials on $n$ variables. Note that the set of non-constant monomial evaluation vectors forms a basis for the space ${\\mathbb{F}_2}^{2^n-1}$.\n\n\\begin{table}\n\\centering\n\\begin{tabular}{c|c c c c c c}\n &  $(1,0,0,\\dots, 0)$ & $(0,1,0,\\dots, 0)$ & $(1,1,0,\\dots, 0)$ & $(0,0,1,\\dots, 0)$ & $\\cdots$ & $(1,1,1,\\dots, 1)$ \\\\ \\hline\n $1$ & 1 & 1 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_1$ & 1 & 0 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_2$ & 0 & 1 & 1 & 0 & $\\cdots$ & 1 \\\\\n $v_1v_2$ & 0 & 0 & 1 & 0 & $\\cdots$ & 1 \\\\\n  $v_3$ & 0 & 0 & 0 & 1 & $\\cdots$ & 1 \\\\\n $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\vdots$ & $\\ddots$ & $\\vdots$ \\\\\n $v_1v_2\\cdots v_n$ & 0 & 0 & 0 & 0 & $\\cdots$ & 1\n\\end{tabular}\n\\caption{Evaluation vectors for monomials over $n$ Boolean variables.}\\label{tab:evals}\n\\end{table}\n\n\\begin{definition}\\label{def:rm}\nThe \\emph{punctured Reed-Muller code} of order $r$ and length $2^n-1$, denoted ${\\mathcal{RM}}(r, n)^*$, is the set of evaluation vectors for all polynomials $f\\in{\\mathbb{F}_2}[v_1,v_2,\\dots, v_n]$ of degree at most $r$.\n\\end{definition}\n\nThe non-punctured, length $2^n$ Reed-Muller code or order $r$ is defined in a similar fashion, using evaluation vectors consisting of all $2^n$ distinct evaluations for a given polynomial function instead.\n\n\\subsection{Statement of main result}\n\nWe now state the main result.\n\n\\begin{theorem}\\label{thm:equiv}\nThe $T$-count minimization problem over $n$-qubit, $\\{{\\text{CNOT}}, T\\}$ circuits is polynomial-time (in $2^n$) equivalent to minimum distance decoding for ${\\mathcal{RM}}(n-4, n)^*$.\n\\end{theorem}\n\nWe prove Theorem~\\ref{thm:equiv} by showing that the number of $T$ gates in a $\\{{\\text{CNOT}}, T\\}$ circuit corresponds directly to the number of odd-weight elements of a tuple in ${\\mathbb{Z}}_8^{2^n-1}$. Moreover, this tuple can be computed from a circuit or vice versa in polynomial-time. An equivalence relation is then defined between tuples that implement the same unitary, which we show is in direct correspondence with cosets of the ${\\mathcal{RM}}(n-4, n)^*$ code. We then use this equivalence to utilize the wealth of research performed on Reed-Muller decoding for quantum circuit optimization.\n\n\\section{Linear phase operators}\\label{sec:phase}\nIn this section we introduce linear phase operators as the sub class of unitaries implementable by $\\{{\\text{CNOT}}, T\\}$ which require $T$ gates. We review their representation as pseudo-Boolean polynomial functions and define the canonical $T$-count for a particular polynomial. Finally we show that a minimal $T$-count implementation of a linear phase operator corresponds to a minimal weight vector of a vector space coset.\n\nWe define ${\\mathcal{P}}_4(n)$ to be the set of diagonal $2^n\\times 2^n$ unitaries implementable over $\\{{\\text{CNOT}}, T\\}$ -- we restrict our attention to this subset as any circuit over $\\{{\\text{CNOT}}, T\\}$ may be decomposed into a diagonal unitary followed by a permutation implementable using only ${\\text{CNOT}}$ gates. Amy {\\it et al. } \\cite[Lemma 2]{ammr13} showed that each such unitary $U\\in{\\mathcal{P}}_4(n)$ has the effect of applying a pseudo-Boolean function ${P}$ to a computational basis state ${|{{\\textbf{x}}}\\rangle}$, viewed as a vector ${\\textbf{x}}=x_1x_2\\cdots x_n\\in{\\mathbb{F}_2}^n$, and kicking the result into the phase: \n", "index": 15, "text": "$$U:{|{{\\textbf{x}}}\\rangle}\\mapsto e^{i\\frac{\\pi}{4}{P}({\\textbf{x}})}{|{{\\textbf{x}}}\\rangle}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"U:{|{{\\textbf{x}}}\\rangle}\\mapsto e^{i\\frac{\\pi}{4}{P}({\\textbf{x}})}{|{{%&#10;\\textbf{x}}}\\rangle}.\" display=\"block\"><mrow><mrow><mi>U</mi><mo>:</mo><mrow><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u21a6</mo><mrow><msup><mi>e</mi><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><mn>4</mn></mfrac><mo>\u2062</mo><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></msup><mo>\u2062</mo><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " where the coefficients $a_{\\textbf{y}}$ are integers modulo $8$. We call the $(2^n-1)$-tuple ${\\textbf{a}}=(a_1,a_2,\\dots, a_{2^n-1})\\in{\\mathbb{Z}}_8^{2^n-1}$ an \\emph{implementation} of ${P}$, and conversely denote the phase polynomial defined by a set of coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ by ${P}_{\\textbf{a}}$. As the function ${P}$ involves both ${\\mathbb{F}_2}$ and ${\\mathbb{Z}}_8$ arithmetic, we use the natural inclusion $\\iota$ of ${\\mathbb{F}_2}$ in ${\\mathbb{Z}}_8$ to coerce the binary valued result of ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ into an integer -- we leave the inclusion implicit whenever no confusion is likely to arise. \n\nWe call unitaries in ${\\mathcal{P}}_4(n)$ $\\pi/4$ \\emph{linear phase operators}, as they may be expressed as a sequence of $(\\pi/4)$ phase rotations conditioned on linear Boolean functions of the input basis state. We drop the $\\pi/4$ until Section~\\ref{sec:generalization} when we generalize the result to $\\pi/{2^k}$ linear phase operators. Given a particular phase polynomial ${P}$, we denote the linear phase operator with phase polynomial ${P}$ by $U_{P}$.\n\n\\begin{example}\nThe doubly-controlled $Z$ gate is a $\\pi/4$ linear phase operator with phase function ${P}(x_1, x_2, x_3) = 4\\cdot x_1x_2x_3$. Using the identity $2\\cdot xy = x + y + 7(x\\oplus y)\\mod 8$ \\cite{s13}, the phase function may be presented as the following weighted sum of linear Boolean functions: \n", "itemtype": "equation", "pos": -1, "prevtext": " Moreover, it was shown that the \\emph{phase polynomial} $P:{\\mathbb{F}_2}^n\\rightarrow{\\mathbb{Z}}_8$ necessarily has a presentation as a weighted sum of (non-zero) linear Boolean functions:\n", "index": 17, "text": "\n\\[{P}({\\textbf{x}}) = \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}} a_{\\textbf{y}}\\cdot \\iota({{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"{P}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{%&#10;\\textbf{0}}\\}}a_{\\textbf{y}}\\cdot\\iota({{y}_{1}{x}_{1}\\oplus{y}_{2}{x}_{2}%&#10;\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}),\" display=\"block\"><mrow><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext/><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u22c5</mo><mi>\u03b9</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>y</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " Writing the coefficients above as a $7$-tuple over ${\\mathbb{Z}}_8$ we get $(1, 1, 7, 1, 7, 7, 1)$. Note that this implementation corresponds to the following circuit, taken from \\cite{amm14}. The state of each qubit after an update is shown to illustrate the relation between the state of a qubit as a Boolean function of the inputs and the application of phase gates.\\vspace{0.5em}\n\n\\centerline{\n\\Qcircuit @C=1em @R=.7em {\n\\lstick{x_1} & \\gate{T} & \\targ & \n\\ustick{\\:x_1\\oplus x_3}\\qw & \\push{\\rule{0em}{1em}}\\qw & \n\\gate{T^\\dagger} & \\targ & \n\\ustick{\\;\\;\\;\\;\\;\\;x_1\\oplus x_2\\oplus x_3} \\qw & \n\\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw &\n\\gate{T} & \\targ & \n\\ustick{\\;\\;\\;x_1\\oplus x_2} \\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw &\n\\gate{T^\\dagger} &\n\\targ & \\ustick{\\!\\!\\!\\!\\!\\!\\!x_1}\\qw & \\rstick{\\!\\!\\!\\!x_1} \\\\\n\\lstick{x_2} & \\gate{T} & \\qw & \n\\ctrl{1} & \\push{\\rule{0em}{1em}}\\qw & \n\\qw & \\ctrl{-1} & \n\\ctrl{1} & \\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw &\n\\qw & \\qw & \n\\qw & \\push{\\rule{0em}{1em}}\\qw &\\push{\\rule{0em}{1em}}\\qw & \\qw &\n\\ctrl{-1} & \\qw & \\rstick{\\!\\!\\!\\!x_2} \\\\\n\\lstick{x_3} & \\qw & \\ctrl{-2} & \n\\targ & \\ustick{\\:\\:\\:\\:\\:x_2\\oplus x_3}\\qw & \n\\push{\\rule{0em}{1em}}\\qw & \\gate{T^\\dagger} & \n\\targ & \\ustick{\\!\\!\\!\\!\\!\\!x_3}\\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw & \\push{\\rule{0em}{1em}}\\qw &\n\\qw & \\ctrl{-2} & \\qw & \\push{\\rule{0em}{1em}}\\qw &  \\push{\\rule{0em}{1em}}\\qw &\n\\gate{T} & \\qw & \\qw & \\rstick{\\!\\!\\!\\!x_3}\n}\n}\n\\end{example}\n\nAmy, Maslov and Mosca \\cite{amm14} showed that a linear phase operator $U_{P}$ can be synthesized over $\\{{\\text{CNOT}}, T\\}$ given an implementation ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ of ${P}$ in time polynomial in the number of non-zero entries of ${\\textbf{a}}$ -- moreover, this number is linear in the size of the circuit. Their procedure applies each (non-trivial) phase shift $e^{i\\frac\\pi4 a_{\\textbf{y}}\\cdot \\iota({{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}})}$ by first computing ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$, then applying $T^{a_{\\textbf{y}}}$ and uncomputing ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$. Recall that \n", "itemtype": "equation", "pos": -1, "prevtext": " where the coefficients $a_{\\textbf{y}}$ are integers modulo $8$. We call the $(2^n-1)$-tuple ${\\textbf{a}}=(a_1,a_2,\\dots, a_{2^n-1})\\in{\\mathbb{Z}}_8^{2^n-1}$ an \\emph{implementation} of ${P}$, and conversely denote the phase polynomial defined by a set of coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ by ${P}_{\\textbf{a}}$. As the function ${P}$ involves both ${\\mathbb{F}_2}$ and ${\\mathbb{Z}}_8$ arithmetic, we use the natural inclusion $\\iota$ of ${\\mathbb{F}_2}$ in ${\\mathbb{Z}}_8$ to coerce the binary valued result of ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ into an integer -- we leave the inclusion implicit whenever no confusion is likely to arise. \n\nWe call unitaries in ${\\mathcal{P}}_4(n)$ $\\pi/4$ \\emph{linear phase operators}, as they may be expressed as a sequence of $(\\pi/4)$ phase rotations conditioned on linear Boolean functions of the input basis state. We drop the $\\pi/4$ until Section~\\ref{sec:generalization} when we generalize the result to $\\pi/{2^k}$ linear phase operators. Given a particular phase polynomial ${P}$, we denote the linear phase operator with phase polynomial ${P}$ by $U_{P}$.\n\n\\begin{example}\nThe doubly-controlled $Z$ gate is a $\\pi/4$ linear phase operator with phase function ${P}(x_1, x_2, x_3) = 4\\cdot x_1x_2x_3$. Using the identity $2\\cdot xy = x + y + 7(x\\oplus y)\\mod 8$ \\cite{s13}, the phase function may be presented as the following weighted sum of linear Boolean functions: \n", "index": 19, "text": "$${P}(x_1, x_2, x_3) = x_1 + x_2 + 7(x_1\\oplus x_2) + x_3 + 7(x_1\\oplus x_3) + 7(x_2\\oplus x_3) + (x_1\\oplus x_2\\oplus x_3).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"{P}(x_{1},x_{2},x_{3})=x_{1}+x_{2}+7(x_{1}\\oplus x_{2})+x_{3}+7(x_{1}\\oplus x_%&#10;{3})+7(x_{2}\\oplus x_{3})+(x_{1}\\oplus x_{2}\\oplus x_{3}).\" display=\"block\"><mrow><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " where $k_2k_1k_0$ is the binary expansion of $k$. Note that $T^8=I$ so $T^k=T^{k\\mod 8}$ for all integers $k$.\n\nBy a circuit over a particular set of gates we mean a sequential list of gates taken from the set, each with a list of qubits the gate is to be applied to. In this way, two distinct circuits may correspond to the same unitary matrix -- we call such circuits \\emph{equivalent} in this case. The problem of optimizing quantum circuits is then to find, given a circuit, an equivalent circuit minimizing some cost function. In this work we consider optimizing strictly the $T$-count of quantum circuits, defined as the number of $T$ gates appearing in a circuit. In particular, we define the problem of $T$-gate minimization as follows:\n\n\\begin{problem}[$T$-gate minimization]\nGiven a circuit over a gate set containing the $T$ gate, find an equivalent circuit over the same gate set with a minimal number of $T$ gates.\n\\end{problem}\n\nFor completeness we also define the Hadamard gate in sum-over-paths style, \n", "itemtype": "equation", "pos": -1, "prevtext": " where ${\\mathbb{F}_2}^n\\rightarrow{\\mathbb{F}_2}$ is the space of all $n$-bit linear Boolean functions. It was left as an open question as to whether there exist other such identities, and whether such identities can be used to further reduce instances of $T$ gates.\n\nIn this paper we prove that the identities on $n$ qubits that are useful for reducing $T$-count is exactly the length $2^n-1$ punctured Reed-Muller code of order $n-4$. In doing so, we derive a new $T$-count optimization algorithm based on Reed-Muller decoding which is optimal for ${\\text{CNOT}}$ and $T$ gate circuits when a minimum distance decoder is used. We implemented this optimization algorithm as a module in the quantum circuit optimizer $T$-par \\cite{tpar} and tested it on general Clifford+$T$ circuits with different Reed-Muller decoders. The results show modest savings in $T$-count while still remaining tractable for circuits of non-trivial size. As a consequence of this equivalence, we also obtain a new upper bound on the number of $T$ gates required to implement a circuit over $\\{{\\text{CNOT}}, T\\}$, as well as evidence to the intractability of exact $T$-count minimization through a polynomial-time equivalence to the minimum distance decoding problem for the length $2^n-1$ punctured Reed-Muller code of order $n-4$.\n\nOur proof naturally generalizes to the case when the $T$ gate is replaced with a $Z$ rotation by any angle of the form $\\pi/2^k$. These gate sets are closely related to the Clifford-cyclotomic gate sets studied in \\cite{fgkm15}, and are widely used in quantum algorithms including Shor's algorithm \\cite{s94}. We show that the number of $\\pi/2^k$ rotation gates for each value of $k$ can be minimized by decoding Reed-Muller codes of different orders, opening up the possibility of optimizing such circuits at the high level, before decomposing them into a lower level gate set such as Clifford+$T$. Further generalization to rotation angles that are arbitrary roots of unity is also possible, with any composite order $2^x3^y5^z\\cdots$ reducing to the case for a root of order $2^x$.\n\n\\subsection{Related work}\nMuch work has gone into $T$-count and depth reduction in recent years.\nAmy {\\it et al. } \\cite{ammr13} identified the $T$-count and $T$-depth as important quantities in the efficiency of a logical quantum circuit, and gave new implementations of 2--4 bit quantum operations reducing $T$-count and depth from the previously best known. Their search-based algorithm was later optimized and extended by Gosset {\\it et al. } \\cite{gkmr14} to directly optimize $T$-depth, leading to proofs of $T$-depth minimality for various 2--4 bit circuits. Selinger \\cite{s13} showed that the Toffoli gate, as well as a general class of Clifford+$T$ circuits, can be parallelized to $T$-depth 1 with sufficiently many ancillas. Constructions for adding controls to quantum gates were also given which lowered the $T$-count and depth compared to best known practices using Toffoli gates. Amy, Maslov and Mosca later used similar ideas to create an automated, polynomial-time tool for reducing and parallelizing $T$ gates called $T$-par, which uses matroid partitioning to parallelize the $T$ gates. More recently, Abdessaied, Soeken and Drechsler \\cite{asd14} studied the effect of Hadamard gates on $T$-count and depth reductions, developing a tool that reduces Hadamard gates in quantum circuits leading to further $T$ gate optimizations. Maslov \\cite{m15} examined Toffoli gate implementations up to relative phase and used them to develop new designs for multiple control Toffolis using fewer ancillas, ${\\text{CNOT}}$, and in some cases $T$ gates, than standard designs. \n\nA great deal of work optimizing $T$-count and depth in single qubit circuits has also been done recently, with series of works on exact \\cite{kmm12} and approximate \\cite{kmm13, s15, rs14} minimal synthesis, as well as repeat-until-success circuits \\cite{ps14, brs15}. \n\n\\subsection{Overview}\nThe rest of the paper is organized as follows. Section~\\ref{sec:prelim} gives definitions and notation that will be used throughout the paper. Section~\\ref{sec:phase} defines the linear phase operators, details their representation as weighted sums of linear Boolean functions and synthesis. Section~\\ref{sec:topt} defines an additive subgroup of ${\\mathbb{Z}}_8^{2^n-1}$ whose cosets correspond to the unique linear phase operators, then characterizes its binary residue as a Reed-Muller code and gives applications. Section~\\ref{sec:proofmain} formally proves the equivalence of this (binary residue) subgroup with the length $2^n-1$ punctured Reed-Muller code of order $n-4$. Finally Section~\\ref{sec:generalization} generalizes the result to circuits over ${\\text{CNOT}}$ gates and phase rotations with angles of the form $\\pi/2^k$, and Section~\\ref{sec:experiments} details the experimental evaluation of our technique.\n\n\\section{Preliminaries}\\label{sec:prelim}\n\nWe assume basic knowledge of quantum computing, but no knowledge of coding theory. For background on quantum computing, the reader is referred to \\cite{nc00}.\n\n\\subsection{Quantum gates}\n\nIn this paper we will primarily be interested in two gates: the controlled-NOT (${\\text{CNOT}}:{|{x}\\rangle}{|{y}\\rangle}\\mapsto{|{x}\\rangle}{|{x\\oplus y}\\rangle}$) and the $T$-gate ($T:{|{x}\\rangle}\\mapsto e^{i\\frac\\pi4x}{|{x}\\rangle}$). These two gates, together with $P:=T^2$ and $Z:=T^4$ gates, comprise what we refer to for brevity as the $\\{{\\text{CNOT}}, T\\}$ gate set. We include the $P$ and $Z$ gates in this set to distinguish them from sequences of $T$ gates which are generally much more expensive to implement in most fault-tolerance schemes. Given any power $k\\in{\\mathbb{Z}}_8$ of the $T$ gate, we define a minimal $T$-gate expansion by \n", "index": 3, "text": "$$T^k:=Z^{k_2}P^{k_1}T^{k_0}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"T^{k}:=Z^{k_{2}}P^{k_{1}}T^{k_{0}}\" display=\"block\"><mrow><msup><mi>T</mi><mi>k</mi></msup><mo>:=</mo><mrow><msup><mi>Z</mi><msub><mi>k</mi><mn>2</mn></msub></msup><mo>\u2062</mo><msup><mi>P</mi><msub><mi>k</mi><mn>1</mn></msub></msup><mo>\u2062</mo><msup><mi>T</mi><msub><mi>k</mi><mn>0</mn></msub></msup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for all values of $x_1,x_2\\in{\\mathbb{F}_2}$, so ${P}(x_1,x_2)=4\\cdot x_1 + 4\\cdot x_2+4\\cdot(x_1\\oplus x_2)$ is an alternative presentation of the zero-everywhere ($\\pi/4$) phase polynomial. This opens up the possibility of further $T$-count optimization by first finding an implementation of the target phase polynomial with a minimal number of odd coefficients, then synthesizing a circuit. By Lemma~\\ref{lem:imp}, this in fact finds a minimal $T$-count circuit. In this section we reduce this problem to a minimum-distance decoding problem and give a $T$-count optimization algorithm based on this decoding.\n\nGiven a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$, we define $[{\\textbf{a}}]$ to be the equivalence class of implementations of ${P}_{\\textbf{a}}$ -- i.e., ${\\textbf{b}}\\in[{\\textbf{a}}]$ if and only if ${P}_{\\textbf{a}}({\\textbf{x}})={P}_{\\textbf{b}}({\\textbf{x}})$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ (hence $U_{{P}_{\\textbf{a}}}=U_{{P}_{\\textbf{b}}}$). Moreover, we define ${\\mathcal{C}_n}$ to be the set of implementations of the zero-everywhere phase polynomial. Clearly for any ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$, $[{\\textbf{a}}]={\\textbf{a}}+{\\mathcal{C}_n}$, since by we have ${P}_{\\textbf{a}}({\\textbf{x}})+{P}_{\\textbf{b}}({\\textbf{x}})={P}_{{\\textbf{a}}+{\\textbf{b}}}({\\textbf{x}})$ for any ${\\textbf{a}},{\\textbf{b}}\\in{\\mathbb{Z}}_8^{2^n-1}$, ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. As a result we see that the problem of finding an implementation of ${P}_{\\textbf{a}}$ minimizing $T$ count is equivalent to finding an element ${\\textbf{c}}\\in{\\mathcal{C}_n}$ minimizing the number of odd coefficients in ${\\textbf{a}}+{\\textbf{c}}$.\n\nWhile this optimization could be performed directly over ${\\mathcal{C}_n}$, we can do better by reducing the optimization problem to a decoding problem over a \\emph{binary} code where minimum-distance decoding corresponds exactly to $T$-count optimization. In particular, recall that the $T$-count of an implementation is given by the number of odd coefficients. Defining ${\\text{Res}}_2:{\\mathbb{Z}}\\rightarrow{\\mathbb{F}_2}$ as the function taking the binary residue of an integer and extending this component-wise to tuples, we see that the $T$-count of a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ is equal to the weight of the binary residue vector, i.e. ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}})).$ \n\nSince ${\\text{Res}}_2$ is a ring homomorphism, we further see that \n", "itemtype": "equation", "pos": -1, "prevtext": " where $k_2k_1k_0$ is the binary expansion of $k$. Since each ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ is a linear function of the basis state $x_1x_2\\cdots x_n$, each value ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ may be computed solely with ${\\text{CNOT}}$ gates, giving a total $T$-count equal to the number of odd elements of ${\\textbf{a}}$ -- we call this the $T$-count of an implementation. While in this work we are only concerned with the $T$-count of the synthesized circuit, $T$-depth can be minimized while keeping $T$-count the same by parallelizing this process through matroid partitioning \\cite{amm14}.\n\nThe authors used this synthesis algorithm to optimize $T$-count in $\\{{\\text{CNOT}}, T\\}$ circuits by first computing an implementation (set of coefficients) for the associated linear phase operator $U_{P}$ from the circuit in polynomial time, then synthesizing an equivalent circuit. The remaining linear permutation is also computed and synthesized separately in polynomial time. This procedure has the crucial property that the set of coefficients computed have $T$-count at most the $T$-count of the original circuit -- often much lower due to coefficients in the phase polynomial adding and cancelling -- hence the resulting circuit has equal or lesser $T$-count. In particular, we have the following lemma, which relates the $T$-count of a $\\{{\\text{CNOT}}, T\\}$ circuit to the $T$-count of an implementation of the associated phase operator.\n\n\\begin{lemma}\\label{lem:imp}\nLet $U_{P}$ be a linear phase operator in ${\\mathcal{P}}_4(n)$. There exists a circuit over $\\{{\\text{CNOT}}, T\\}$ implementing $U_{P}$ with $T$-count $k$ if and only if there exists ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ such that ${P}({\\textbf{x}})= {P}_{\\textbf{a}}({\\textbf{x}})$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, and ${\\textbf{a}}$ has $T$-count at most $k$.\n\\end{lemma}\n\n\\section{Decoding-based $T$-count optimization}\\label{sec:topt}\n\nWhile effective at reducing $T$-count, it was noted that the procedure in \\cite{amm14} does not always find the minimal $T$-count, as the phase polynomial ${P}$ in question may have many different representations as a weighted sum of linear Boolean functions. For instance, \n", "index": 23, "text": "$$4\\cdot x_1 + 4\\cdot x_2+4\\cdot(x_1\\oplus x_2)=0\\mod 8$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"4\\cdot x_{1}+4\\cdot x_{2}+4\\cdot(x_{1}\\oplus x_{2})=0\\mod 8\" display=\"block\"><mrow><mrow><mrow><mn>4</mn><mo>\u22c5</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>+</mo><mrow><mn>4</mn><mo>\u22c5</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>+</mo><mrow><mn>4</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mn>0</mn><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mn>8</mn></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " that, is the $T$-count of a tuple ${\\textbf{a}}+{\\textbf{c}}$ is the Hamming distance from ${\\text{Res}}_2({\\textbf{a}})$ to ${\\text{Res}}_2({\\textbf{c}})$. As a result, optimizing ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}+{\\textbf{c}}))$ over all ${\\textbf{c}}\\in{\\mathcal{C}_n}$ is exactly the problem of minimum distance decoding ${\\text{Res}}_2({\\textbf{a}})$ over ${\\text{Res}}_2({\\mathcal{C}_n})$, the set of binary residue vectors of ${\\mathcal{C}_n}$. Moreover, we note that ${\\text{Res}}_2({\\mathcal{C}_n})$ is a binary linear code, since ${\\text{Res}}_2({\\textbf{a}})\\oplus{\\text{Res}}_2({\\textbf{b}})={\\text{Res}}_2({\\textbf{a}}+{\\textbf{b}})\\in{\\text{Res}}_2({\\mathcal{C}_n})$ for any ${\\textbf{a}},{\\textbf{b}}\\in{\\mathcal{C}_n}$. In particular, this code turns out to be the ($n-4$)th order, length $2^n-1$ punctured Reed-Muller code:\n\n\\begin{theorem}\\label{thm:main}\n${\\text{Res}}_2({\\mathcal{C}_n})={\\mathcal{RM}}(n-4, n)^*$\n\\end{theorem}\n\nWe defer the proof of Theorem~\\ref{thm:main} until Section~\\ref{sec:proofmain} and discuss some consequences of this equivalence in the following.\n\n\\subsection{Upper bounds}\n\nAs a result of Lemma~\\ref{lem:imp} and Theorem~\\ref{thm:main}, the covering radius of ${\\text{Res}}_2({\\mathcal{C}_n})={\\mathcal{RM}}(n-4,n)^*$ gives a tight upper bound on the number of $T$ gates required to implement a linear phase operator over $\\{{\\text{CNOT}}, T\\}$. Here we mean tight in the sense that there exists a linear phase operator which requires a minimum of $\\rho({\\mathcal{RM}}(n-4, n)^*)$ $T$ gates to implement over $\\{{\\text{CNOT}}, T\\}$. While no analytic formula has yet been found for the covering radius of higher-order Reed-Muller codes, some asymptotic upper bounds are known. The best upper bound, to the authors' knowledge, is due to Cohen and Litsyn \\cite{cl92}. In particular, Cohen and Litsyn showed that for large $n$ and orders $r$ where $n-r\\geq 3$,\n\n", "itemtype": "equation", "pos": -1, "prevtext": " for all values of $x_1,x_2\\in{\\mathbb{F}_2}$, so ${P}(x_1,x_2)=4\\cdot x_1 + 4\\cdot x_2+4\\cdot(x_1\\oplus x_2)$ is an alternative presentation of the zero-everywhere ($\\pi/4$) phase polynomial. This opens up the possibility of further $T$-count optimization by first finding an implementation of the target phase polynomial with a minimal number of odd coefficients, then synthesizing a circuit. By Lemma~\\ref{lem:imp}, this in fact finds a minimal $T$-count circuit. In this section we reduce this problem to a minimum-distance decoding problem and give a $T$-count optimization algorithm based on this decoding.\n\nGiven a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$, we define $[{\\textbf{a}}]$ to be the equivalence class of implementations of ${P}_{\\textbf{a}}$ -- i.e., ${\\textbf{b}}\\in[{\\textbf{a}}]$ if and only if ${P}_{\\textbf{a}}({\\textbf{x}})={P}_{\\textbf{b}}({\\textbf{x}})$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ (hence $U_{{P}_{\\textbf{a}}}=U_{{P}_{\\textbf{b}}}$). Moreover, we define ${\\mathcal{C}_n}$ to be the set of implementations of the zero-everywhere phase polynomial. Clearly for any ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$, $[{\\textbf{a}}]={\\textbf{a}}+{\\mathcal{C}_n}$, since by we have ${P}_{\\textbf{a}}({\\textbf{x}})+{P}_{\\textbf{b}}({\\textbf{x}})={P}_{{\\textbf{a}}+{\\textbf{b}}}({\\textbf{x}})$ for any ${\\textbf{a}},{\\textbf{b}}\\in{\\mathbb{Z}}_8^{2^n-1}$, ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. As a result we see that the problem of finding an implementation of ${P}_{\\textbf{a}}$ minimizing $T$ count is equivalent to finding an element ${\\textbf{c}}\\in{\\mathcal{C}_n}$ minimizing the number of odd coefficients in ${\\textbf{a}}+{\\textbf{c}}$.\n\nWhile this optimization could be performed directly over ${\\mathcal{C}_n}$, we can do better by reducing the optimization problem to a decoding problem over a \\emph{binary} code where minimum-distance decoding corresponds exactly to $T$-count optimization. In particular, recall that the $T$-count of an implementation is given by the number of odd coefficients. Defining ${\\text{Res}}_2:{\\mathbb{Z}}\\rightarrow{\\mathbb{F}_2}$ as the function taking the binary residue of an integer and extending this component-wise to tuples, we see that the $T$-count of a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ is equal to the weight of the binary residue vector, i.e. ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}})).$ \n\nSince ${\\text{Res}}_2$ is a ring homomorphism, we further see that \n", "index": 25, "text": "$${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}+{\\textbf{c}}))={\\text{wt}}({\\text{Res}}_2({\\textbf{a}})\\oplus{\\text{Res}}_2({\\textbf{c}}))=d({\\text{Res}}_2({\\textbf{a}}),{\\text{Res}}_2({\\textbf{c}})),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"{\\text{wt}}({\\text{Res}}_{2}({\\textbf{a}}+{\\textbf{c}}))={\\text{wt}}({\\text{%&#10;Res}}_{2}({\\textbf{a}})\\oplus{\\text{Res}}_{2}({\\textbf{c}}))=d({\\text{Res}}_{2%&#10;}({\\textbf{a}}),{\\text{Res}}_{2}({\\textbf{c}})),\" display=\"block\"><mrow><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>\ud835\udc1a</mtext><mo>+</mo><mtext>\ud835\udc1c</mtext></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1a</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2295</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1a</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nSince the covering radius of ${\\mathcal{RM}}(r, n)^*$ is trivially bounded above by $\\rho({\\mathcal{RM}}(r, n))$, we see that for sufficiently large $n$, $\\rho({\\mathcal{RM}}(n-4, n)^*)\\leq \\frac{n^2}{2}-1$. As a result we obtain a new asymptotic bound on the number of $T$ gates required to implement a circuit over $\\{{\\text{CNOT}}, T\\}$.\n\n\\begin{theorem}\nAny linear phase operator $U_p\\in{\\mathcal{P}}_4(n)$ can be implemented with $O(n^2)$ $T$-gates.\n\\end{theorem}\n\n\\subsection{$T$-count optimization}\n\nCompleting a $T$-count optimization procedure based on Reed-Muller decoding is not as immediate. In particular, decoding the binary residue ${\\text{Res}}_2({\\textbf{a}})$ of a target tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ over ${\\mathcal{RM}}(n-4, n)^*$ produces a minimal \\emph{residue} ${\\textbf{c}}'={\\text{Res}}_2({\\textbf{c}})$ of a codeword ${\\textbf{c}}$ in ${\\mathcal{C}_n}$. To actually produce a minimal $T$-count implementation of ${P}_{\\textbf{a}}$ we need to compute ${\\textbf{c}}\\in{\\mathcal{C}_n}$ from ${\\text{Res}}_2({\\textbf{c}})$ and then synthesize ${\\textbf{a}}+{\\textbf{c}}$. Fortunately, there is an easy way to do this, given the following lemma.\n\n\\begin{lemma}\\label{lem:codebasis}\nFor all ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ with ${\\text{wt}}({\\textbf{y}})\\leq n-4$ we have ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\in{\\mathcal{C}_n}$.\n\\end{lemma}\n\nUsing Lemma~\\ref{lem:codebasis}, which we prove in Section~\\ref{sec:proofmain}, and the fact that the set of all monomial evaluation vectors with degree at most $n-4$, \n", "itemtype": "equation", "pos": 32470, "prevtext": " that, is the $T$-count of a tuple ${\\textbf{a}}+{\\textbf{c}}$ is the Hamming distance from ${\\text{Res}}_2({\\textbf{a}})$ to ${\\text{Res}}_2({\\textbf{c}})$. As a result, optimizing ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}+{\\textbf{c}}))$ over all ${\\textbf{c}}\\in{\\mathcal{C}_n}$ is exactly the problem of minimum distance decoding ${\\text{Res}}_2({\\textbf{a}})$ over ${\\text{Res}}_2({\\mathcal{C}_n})$, the set of binary residue vectors of ${\\mathcal{C}_n}$. Moreover, we note that ${\\text{Res}}_2({\\mathcal{C}_n})$ is a binary linear code, since ${\\text{Res}}_2({\\textbf{a}})\\oplus{\\text{Res}}_2({\\textbf{b}})={\\text{Res}}_2({\\textbf{a}}+{\\textbf{b}})\\in{\\text{Res}}_2({\\mathcal{C}_n})$ for any ${\\textbf{a}},{\\textbf{b}}\\in{\\mathcal{C}_n}$. In particular, this code turns out to be the ($n-4$)th order, length $2^n-1$ punctured Reed-Muller code:\n\n\\begin{theorem}\\label{thm:main}\n${\\text{Res}}_2({\\mathcal{C}_n})={\\mathcal{RM}}(n-4, n)^*$\n\\end{theorem}\n\nWe defer the proof of Theorem~\\ref{thm:main} until Section~\\ref{sec:proofmain} and discuss some consequences of this equivalence in the following.\n\n\\subsection{Upper bounds}\n\nAs a result of Lemma~\\ref{lem:imp} and Theorem~\\ref{thm:main}, the covering radius of ${\\text{Res}}_2({\\mathcal{C}_n})={\\mathcal{RM}}(n-4,n)^*$ gives a tight upper bound on the number of $T$ gates required to implement a linear phase operator over $\\{{\\text{CNOT}}, T\\}$. Here we mean tight in the sense that there exists a linear phase operator which requires a minimum of $\\rho({\\mathcal{RM}}(n-4, n)^*)$ $T$ gates to implement over $\\{{\\text{CNOT}}, T\\}$. While no analytic formula has yet been found for the covering radius of higher-order Reed-Muller codes, some asymptotic upper bounds are known. The best upper bound, to the authors' knowledge, is due to Cohen and Litsyn \\cite{cl92}. In particular, Cohen and Litsyn showed that for large $n$ and orders $r$ where $n-r\\geq 3$,\n\n", "index": 27, "text": "$$\\rho({\\mathcal{RM}}(r, n))\\leq \\frac{n^{n-r-2}}{(n-r-2)!}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\rho({\\mathcal{RM}}(r,n))\\leq\\frac{n^{n-r-2}}{(n-r-2)!}.\" display=\"block\"><mrow><mrow><mrow><mi>\u03c1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>\u2062</mo><mi class=\"ltx_font_mathcaligraphic\">\u2133</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mfrac><msup><mi>n</mi><mrow><mi>n</mi><mo>-</mo><mi>r</mi><mo>-</mo><mn>2</mn></mrow></msup><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo lspace=\"0pt\" rspace=\"3.5pt\">!</mo></mrow></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " forms a basis for ${\\mathcal{RM}}(n-4, n)^*$, we can write a decoded word ${\\textbf{c}}'$ over this basis then \\emph{reinterpret} the sum over ${\\mathbb{Z}}_8$. In particular, if\n${\\textbf{c}}'={\\textbf{b}}_1\\oplus {\\textbf{b}}_2\\oplus\\cdots\\oplus {\\textbf{b}}_k$ for some ${\\textbf{b}}_1,{\\textbf{b}}_2,\\dots, {\\textbf{b}}_k\\in\\mathcal{B}$, then ${\\textbf{c}}={\\textbf{b}}_1+ {\\textbf{b}}_2+\\cdots+ {\\textbf{b}}_k\\in{\\mathcal{C}_n}$, and \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nSince the covering radius of ${\\mathcal{RM}}(r, n)^*$ is trivially bounded above by $\\rho({\\mathcal{RM}}(r, n))$, we see that for sufficiently large $n$, $\\rho({\\mathcal{RM}}(n-4, n)^*)\\leq \\frac{n^2}{2}-1$. As a result we obtain a new asymptotic bound on the number of $T$ gates required to implement a circuit over $\\{{\\text{CNOT}}, T\\}$.\n\n\\begin{theorem}\nAny linear phase operator $U_p\\in{\\mathcal{P}}_4(n)$ can be implemented with $O(n^2)$ $T$-gates.\n\\end{theorem}\n\n\\subsection{$T$-count optimization}\n\nCompleting a $T$-count optimization procedure based on Reed-Muller decoding is not as immediate. In particular, decoding the binary residue ${\\text{Res}}_2({\\textbf{a}})$ of a target tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ over ${\\mathcal{RM}}(n-4, n)^*$ produces a minimal \\emph{residue} ${\\textbf{c}}'={\\text{Res}}_2({\\textbf{c}})$ of a codeword ${\\textbf{c}}$ in ${\\mathcal{C}_n}$. To actually produce a minimal $T$-count implementation of ${P}_{\\textbf{a}}$ we need to compute ${\\textbf{c}}\\in{\\mathcal{C}_n}$ from ${\\text{Res}}_2({\\textbf{c}})$ and then synthesize ${\\textbf{a}}+{\\textbf{c}}$. Fortunately, there is an easy way to do this, given the following lemma.\n\n\\begin{lemma}\\label{lem:codebasis}\nFor all ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ with ${\\text{wt}}({\\textbf{y}})\\leq n-4$ we have ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\in{\\mathcal{C}_n}$.\n\\end{lemma}\n\nUsing Lemma~\\ref{lem:codebasis}, which we prove in Section~\\ref{sec:proofmain}, and the fact that the set of all monomial evaluation vectors with degree at most $n-4$, \n", "index": 29, "text": "$${\\mathcal{B}}=\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^n, {\\text{wt}}({\\textbf{y}})\\leq n-4\\},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{B}}=\\{{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{%&#10;2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_{2}}^%&#10;{n},{\\text{wt}}({\\textbf{y}})\\leq n-4\\},\" display=\"block\"><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo>\u2223</mo><mrow><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow><mo>,</mo><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>n</mi><mo>-</mo><mn>4</mn></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\n\\begin{algorithm}[H]\n\\caption{$T$-optimize($C$)}\n\\label{alg:cnott}\n\\begin{algorithmic}[1]\n\t\\STATE Compute coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ from $C$\n\t\\STATE ${\\textbf{c}}'\\gets$RM-DECODE($n-4$, $n$, ${\\text{Res}}_2({\\textbf{a}})$)\n\t\\STATE Write ${\\textbf{c}}'$ over basis $\\mathcal{B}$: ${\\textbf{c}}'={\\textbf{b}}_1\\oplus {\\textbf{b}}_2\\oplus\\cdots\\oplus {\\textbf{b}}_k$\n\t\\STATE ${\\textbf{c}}\\gets {\\textbf{b}}_1+ {\\textbf{b}}_2+\\cdots+ {\\textbf{b}}_k$ (mod $8$)\n\t\\STATE SYNTHESIZE(${\\textbf{a}}+{\\textbf{c}}$)\n\\end{algorithmic}\n\\end{algorithm}\n\nAlgorithm~\\ref{alg:cnott} summarizes our algorithm for $T$-count optimization in $\\{{\\text{CNOT}}, T\\}$ circuits. For simplicity the algorithm assumes the input circuit implements a linear phase operator -- for more general $\\{{\\text{CNOT}}, T\\}$ circuits the extra linear permutation is synthesized and appended to the end. The algorithm works by computing a set of coefficients implementing the linear phase operator $U_{P}$ computed by the circuit. The vector of residues modulo $2$ is then decoded as ${\\textbf{c}}'$ in ${\\mathcal{RM}}(n-4, n)^*$ using the procedure RM-DECODE($n-4$, $n$, ${\\text{Res}}_2({\\textbf{a}})$). Any variable order Reed-Muller decoder may then be used in RM-DECODE. In particular, using a minimum distance decoder gives a minimal $T$-count synthesis procedure.\n\nA vector ${\\textbf{c}}\\in{\\mathcal{C}_n}$ with binary residue equal to ${\\textbf{c}}'$ is then computed and added to the original set of coefficients, and a circuit is synthesized for the new implementation of ${P}$. In particular, the procedure SYNTHESIZE takes a set of coefficients ${\\textbf{a}}$ and synthesizes a circuit over $\\{{\\text{CNOT}}, T\\}$ implementing $U_{{P}_{\\textbf{a}}}$. The $T$-par algorithm \\cite{amm14}, for instance, may be used to implement SYNTHESIZE.\n\n\\begin{example}\\label{ex:opt}\nConsider the circuit below:\n\n\\vspace{0.5em}\n\\centerline{\n\\Qcircuit @C=0.3em @R=.9em {\n\t\\lstick{x_1} & \\ctrl{2}  & \\qw          & \\ctrl{3}  & \\qw         & \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\ctrl{1}  & \\gate{Z} & \\ctrl{2}   & \\qw         & \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\ctrl{-2} & \\qw          & \\qw         & \\qw         & \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw         & \\qw          & \\ctrl{-3} & \\gate{P} & \\rstick{x_4} \\qw\n}\\qquad\n\\raisebox{-2.8em}{\\!$=$\\!}\\qquad\n\\Qcircuit @C=0.3em @R=.3em {\n\t\\lstick{x_1} & \\gate{T} & \\targ & \\qw & \\ctrl{2} & \\gate{T^\\dagger} & \\ctrl{1} & \\qw & \\qw & \\ctrl{2} & \\targ \n\t\t& \\qw          \n\t\t& \\gate{T} & \\targ & \\qw & \\ctrl{3} & \\gate{T^\\dagger} & \\ctrl{1} & \\qw & \\qw & \\ctrl{3} & \\targ \n\t\t& \\qw         & \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\gate{T} & \\ctrl{-1} & \\targ & \\qw & \\gate{T^\\dagger} & \\targ & \\gate{T^\\dagger} & \\targ & \\qw & \\ctrl{-1}\n\t\t& \\gate{Z} \n\t\t& \\gate{T} & \\ctrl{-1} & \\targ & \\qw & \\gate{T^\\dagger} & \\targ & \\gate{T^\\dagger} & \\targ & \\qw & \\ctrl{-1}  \n\t\t& \\qw         & \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\gate{T} & \\qw & \\ctrl{-1} & \\targ & \\gate{T} & \\qw & \\qw & \\ctrl{-1} & \\targ & \\qw\n\t\t& \\qw          \n\t\t& \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw         \n\t\t& \\qw         & \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw         \n\t\t& \\qw          \n\t\t& \\gate{T} & \\qw & \\ctrl{-2} & \\targ & \\gate{T} & \\qw & \\qw & \\ctrl{-2} & \\targ & \\qw\n\t\t& \\gate{P} & \\rstick{x_4} \\qw\n}\n}\\vspace{1em}\nBy iterating through the circuit and tracking the qubit states (see, e.g., \\cite{amm14}), we compute the phase polynomial for this operator as\n\n", "itemtype": "equation", "pos": 34774, "prevtext": " forms a basis for ${\\mathcal{RM}}(n-4, n)^*$, we can write a decoded word ${\\textbf{c}}'$ over this basis then \\emph{reinterpret} the sum over ${\\mathbb{Z}}_8$. In particular, if\n${\\textbf{c}}'={\\textbf{b}}_1\\oplus {\\textbf{b}}_2\\oplus\\cdots\\oplus {\\textbf{b}}_k$ for some ${\\textbf{b}}_1,{\\textbf{b}}_2,\\dots, {\\textbf{b}}_k\\in\\mathcal{B}$, then ${\\textbf{c}}={\\textbf{b}}_1+ {\\textbf{b}}_2+\\cdots+ {\\textbf{b}}_k\\in{\\mathcal{C}_n}$, and \n", "index": 31, "text": "$${\\text{Res}}_2({\\textbf{c}})={\\text{Res}}_2({\\textbf{b}}_1+ {\\textbf{b}}_2+\\cdots+ {\\textbf{b}}_k)={\\text{Res}}_2({\\textbf{b}}_1)\\oplus{\\text{Res}}_2({\\textbf{b}}_2)\\oplus\\cdots\\oplus{\\text{Res}}_2({\\textbf{b}}_k)={\\textbf{c}}'.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"{\\text{Res}}_{2}({\\textbf{c}})={\\text{Res}}_{2}({\\textbf{b}}_{1}+{\\textbf{b}}_%&#10;{2}+\\cdots+{\\textbf{b}}_{k})={\\text{Res}}_{2}({\\textbf{b}}_{1})\\oplus{\\text{%&#10;Res}}_{2}({\\textbf{b}}_{2})\\oplus\\cdots\\oplus{\\text{Res}}_{2}({\\textbf{b}}_{k}%&#10;)={\\textbf{c}}^{\\prime}.\" display=\"block\"><mrow><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mtext>\ud835\udc1b</mtext><mn>1</mn></msub><mo>+</mo><msub><mtext>\ud835\udc1b</mtext><mn>2</mn></msub><mo>+</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>+</mo><msub><mtext>\ud835\udc1b</mtext><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mtext>\ud835\udc1b</mtext><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2295</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mtext>\ud835\udc1b</mtext><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mtext>\ud835\udc1b</mtext><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><msup><mtext>\ud835\udc1c</mtext><mo>\u2032</mo></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nWriting the coefficients of ${P}$ as a $2^n-1$-tuple ${\\textbf{a}}$ we get \n", "itemtype": "equation", "pos": 38545, "prevtext": "\n\n\\begin{algorithm}[H]\n\\caption{$T$-optimize($C$)}\n\\label{alg:cnott}\n\\begin{algorithmic}[1]\n\t\\STATE Compute coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ from $C$\n\t\\STATE ${\\textbf{c}}'\\gets$RM-DECODE($n-4$, $n$, ${\\text{Res}}_2({\\textbf{a}})$)\n\t\\STATE Write ${\\textbf{c}}'$ over basis $\\mathcal{B}$: ${\\textbf{c}}'={\\textbf{b}}_1\\oplus {\\textbf{b}}_2\\oplus\\cdots\\oplus {\\textbf{b}}_k$\n\t\\STATE ${\\textbf{c}}\\gets {\\textbf{b}}_1+ {\\textbf{b}}_2+\\cdots+ {\\textbf{b}}_k$ (mod $8$)\n\t\\STATE SYNTHESIZE(${\\textbf{a}}+{\\textbf{c}}$)\n\\end{algorithmic}\n\\end{algorithm}\n\nAlgorithm~\\ref{alg:cnott} summarizes our algorithm for $T$-count optimization in $\\{{\\text{CNOT}}, T\\}$ circuits. For simplicity the algorithm assumes the input circuit implements a linear phase operator -- for more general $\\{{\\text{CNOT}}, T\\}$ circuits the extra linear permutation is synthesized and appended to the end. The algorithm works by computing a set of coefficients implementing the linear phase operator $U_{P}$ computed by the circuit. The vector of residues modulo $2$ is then decoded as ${\\textbf{c}}'$ in ${\\mathcal{RM}}(n-4, n)^*$ using the procedure RM-DECODE($n-4$, $n$, ${\\text{Res}}_2({\\textbf{a}})$). Any variable order Reed-Muller decoder may then be used in RM-DECODE. In particular, using a minimum distance decoder gives a minimal $T$-count synthesis procedure.\n\nA vector ${\\textbf{c}}\\in{\\mathcal{C}_n}$ with binary residue equal to ${\\textbf{c}}'$ is then computed and added to the original set of coefficients, and a circuit is synthesized for the new implementation of ${P}$. In particular, the procedure SYNTHESIZE takes a set of coefficients ${\\textbf{a}}$ and synthesizes a circuit over $\\{{\\text{CNOT}}, T\\}$ implementing $U_{{P}_{\\textbf{a}}}$. The $T$-par algorithm \\cite{amm14}, for instance, may be used to implement SYNTHESIZE.\n\n\\begin{example}\\label{ex:opt}\nConsider the circuit below:\n\n\\vspace{0.5em}\n\\centerline{\n\\Qcircuit @C=0.3em @R=.9em {\n\t\\lstick{x_1} & \\ctrl{2}  & \\qw          & \\ctrl{3}  & \\qw         & \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\ctrl{1}  & \\gate{Z} & \\ctrl{2}   & \\qw         & \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\ctrl{-2} & \\qw          & \\qw         & \\qw         & \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw         & \\qw          & \\ctrl{-3} & \\gate{P} & \\rstick{x_4} \\qw\n}\\qquad\n\\raisebox{-2.8em}{\\!$=$\\!}\\qquad\n\\Qcircuit @C=0.3em @R=.3em {\n\t\\lstick{x_1} & \\gate{T} & \\targ & \\qw & \\ctrl{2} & \\gate{T^\\dagger} & \\ctrl{1} & \\qw & \\qw & \\ctrl{2} & \\targ \n\t\t& \\qw          \n\t\t& \\gate{T} & \\targ & \\qw & \\ctrl{3} & \\gate{T^\\dagger} & \\ctrl{1} & \\qw & \\qw & \\ctrl{3} & \\targ \n\t\t& \\qw         & \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\gate{T} & \\ctrl{-1} & \\targ & \\qw & \\gate{T^\\dagger} & \\targ & \\gate{T^\\dagger} & \\targ & \\qw & \\ctrl{-1}\n\t\t& \\gate{Z} \n\t\t& \\gate{T} & \\ctrl{-1} & \\targ & \\qw & \\gate{T^\\dagger} & \\targ & \\gate{T^\\dagger} & \\targ & \\qw & \\ctrl{-1}  \n\t\t& \\qw         & \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\gate{T} & \\qw & \\ctrl{-1} & \\targ & \\gate{T} & \\qw & \\qw & \\ctrl{-1} & \\targ & \\qw\n\t\t& \\qw          \n\t\t& \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw         \n\t\t& \\qw         & \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw & \\qw         \n\t\t& \\qw          \n\t\t& \\gate{T} & \\qw & \\ctrl{-2} & \\targ & \\gate{T} & \\qw & \\qw & \\ctrl{-2} & \\targ & \\qw\n\t\t& \\gate{P} & \\rstick{x_4} \\qw\n}\n}\\vspace{1em}\nBy iterating through the circuit and tracking the qubit states (see, e.g., \\cite{amm14}), we compute the phase polynomial for this operator as\n\n", "index": 33, "text": "\\begin{align*}\n\t{P}({\\textbf{x}}) = 2x_1 &+ 6x_2 + 6(x_1\\oplus x_2) + x_3 + 7(x_1\\oplus x_3) + 7(x_2\\oplus x_3) + (x_1\\oplus x_2\\oplus x_3) \\\\\n  \t\t&+ 3x_4 + 7(x_1\\oplus x_4) + 7(x_2\\oplus x_4) + (x_1\\oplus x_2\\oplus x_4).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{P}({\\textbf{x}})=2x_{1}\" display=\"inline\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+6x_{2}+6(x_{1}\\oplus x_{2})+x_{3}+7(x_{1}\\oplus x_{3})+7(x_{2}%&#10;\\oplus x_{3})+(x_{1}\\oplus x_{2}\\oplus x_{3})\" display=\"inline\"><mrow><mrow><mo>+</mo><mrow><mn>6</mn><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>6</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+3x_{4}+7(x_{1}\\oplus x_{4})+7(x_{2}\\oplus x_{4})+(x_{1}\\oplus x_%&#10;{2}\\oplus x_{4}).\" display=\"inline\"><mrow><mrow><mrow><mo>+</mo><mrow><mn>3</mn><mo>\u2062</mo><msub><mi>x</mi><mn>4</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " which has a canonical $T$-count of $8$ -- a reduction of $6$ $T$ gates.\n\nNow we optimize the implementation of ${P}$ further by decoding \n", "itemtype": "equation", "pos": -1, "prevtext": "\nWriting the coefficients of ${P}$ as a $2^n-1$-tuple ${\\textbf{a}}$ we get \n", "index": 35, "text": "$${\\textbf{a}}=(2, 6, 6, 1, 7, 7, 1, 3, 7, 7, 1, 0, 0, 0, 0),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"{\\textbf{a}}=(2,6,6,1,7,7,1,3,7,7,1,0,0,0,0),\" display=\"block\"><mrow><mrow><mtext>\ud835\udc1a</mtext><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " in the code ${\\mathcal{RM}}(0, 4)^*$. As ${\\mathcal{RM}}(0, 4)^*$ is the set of evaluation vectors for degree 0 binary polynomials, there are exactly two vectors to choose from, corresponding to the zero (zero-everywhere) and constant (one-everywhere) functions. Since the all $1$ vector achieves the minimum distance of $7$ from ${\\text{Res}}_2({\\textbf{a}})$, we choose ${\\textbf{c}}'$ to be the all $1$ vector. By Lemma~\\ref{lem:codebasis}, ${\\textbf{c}}'={\\textbf{1}}$ (mod 2) is already in the space of zero-everywhere polynomials ${\\mathcal{C}_n}$, so steps 3 \\& 4 are trivial and we set ${\\textbf{c}}=1$ (mod 8). Finally we synthesize a circuit for the tuple ${\\textbf{a}}+{\\textbf{c}} = (3, 7, 7, 2, 0, 0, 2, 4, 0, 0, 2, 1, 1, 1, 1),$ corresponding to the phase polynomial \n\n", "itemtype": "equation", "pos": -1, "prevtext": " which has a canonical $T$-count of $8$ -- a reduction of $6$ $T$ gates.\n\nNow we optimize the implementation of ${P}$ further by decoding \n", "index": 37, "text": "$${\\text{Res}}_2({\\textbf{a}})=(0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"{\\text{Res}}_{2}({\\textbf{a}})=(0,0,0,1,1,1,1,1,1,1,1,0,0,0,0)\" display=\"block\"><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1a</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nA possible circuit implementing ${P}'$ is shown below:\n\n\\vspace{0.5em}\n\\centerline{\n\\Qcircuit @C=0.5em @R=.3em {\n\t\\lstick{x_1} & \\gate{T} & \\gate{P}        & \\ctrl{1} & \\qw       & \\targ & \\gate{T}                & \\targ       & \\qw       & \\gate{T}\n\t\t& \\targ & \\qw & \\qw & \\qw & \\qw & \\qw & \\ctrl{1} &  \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\gate{T^\\dagger} & \\qw & \\targ      & \\ctrl{1} & \\qw   & \\gate{T^\\dagger} & \\ctrl{-1} & \\ctrl{2} & \\qw\n\t\t& \\qw & \\qw & \\ctrl{2} & \\qw & \\ctrl{2} & \\ctrl{1} & \\targ &  \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\qw & \\gate{P}                & \\ctrl{1} & \\targ      & \\qw   & \\gate{P}                & \\qw        & \\qw        & \\qw\n\t\t& \\qw & \\ctrl{1} & \\qw & \\qw & \\qw & \\targ & \\qw &  \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw & \\gate{Z}                & \\targ      & \\qw       & \\ctrl{-3} & \\gate{T}          & \\qw         & \\targ     & \\gate{T} \n\t\t& \\ctrl{-3} & \\targ & \\targ & \\gate{P} & \\targ & \\qw & \\qw &  \\rstick{x_4} \\qw\n}\n}\\vspace{1em}\n\nNote that this decoding reduces the $T$-count from $14$ (or $8$, as $T$-par would obtain) to $7$. Moreover, the number of $T$ gates is equal to the distance from ${\\text{Res}}_2({\\textbf{a}})$ to the decoded word ${\\textbf{c}}'$.\n\n\\end{example}\n\n\\subsection{Complexity}\n\nIt may be noted that Algorithm~\\ref{alg:cnott} gives a polynomial-time (in $2^n$) reduction from $T$-count optimization over $\\{{\\text{CNOT}}, T\\}$ to minimum-distance decoding in ${\\mathcal{RM}}(n-4, n)^*$. We may likewise reduce the minimum-distance decoding problem for ${\\mathcal{RM}}(n-4, n)^*$ to $T$-count optimization: given a binary vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^{2^n-1}$, synthesize $U_{{P}_{{\\textbf{x}}}}$ over $\\{{\\text{CNOT}}, T\\}$ then optimize the circuit and compute the coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ for the optimized circuit. As a consequence of Theorem~\\ref{thm:main}, the vector ${\\textbf{x}}\\oplus{\\text{Res}}_2({\\textbf{a}})$ is a minimum distance decoding of ${\\textbf{x}}$. Assuming the optimized circuit does not have exponentially more gates than a canonical circuit,\\footnote{The canonical circuit for any linear phase operator uses $O(n2^{n-1})$ gates.} this reduction is also polynomial in the word length $2^n$, so we see that the problems are in this sense \\emph{equivalent}.\n\nThis equivalence lends evidence to the difficulty of $T$-count optimization, even in the restricted setting of circuits over ${\\text{CNOT}}$ and $T$ gates. In particular, any sub-exponential algorithm for exact optimization of $T$-count over $n$-qubit $\\{{\\text{CNOT}}, T\\}$ circuits induces a polynomial-time minimum-distance decoding algorithm for ${\\mathcal{RM}}(n-4, n)$. This can be further reduced to a \\emph{linear-time} algorithm by noting that the unitary $U_{{P}_{\\textbf{x}}}$ above can be implemented with $O(2^n)$ gates using one ancilla and the Gray code to cycle through each of the $2^n$ binary sums of $n$ variables with one ${\\text{CNOT}}$ gate each.\n\nIn either case it appears very unlikely that an efficient algorithm for minimum-distance decoding the order $n-4$ punctured Reed-Muller code exists. No minimum distance decoding algorithms in time polynomial in $2^n$ \\emph{or} the Hamming weight of the received word are currently known for arbitrary order length $2^n$ binary Reed-Muller codes. While some particular orders of Reed-Muller codes have efficient decoders, e.g., order 1, it was shown in \\cite{sl83} that minimum-distance decoding for ${\\mathcal{RM}}(n-4, n)^*$  is equivalent to the problem of finding a minimal decomposition of a symmetric 3-tensor into symmetric tryads (rank 1 3-tensors), a known hard problem.\n\n\\section{Proof of Theorem~\\ref{thm:main}}\\label{sec:proofmain}\n\nIn this section we prove Theorem~\\ref{thm:main}, and as a corollary Lemma~\\ref{lem:codebasis}.\n\n\\subsection{The monomial basis}\n\nOur proof relies on a connection between the binary evaluations of polynomials over ${\\mathbb{Z}}_8$ and the module ${\\mathbb{Z}}_8^{2^n-1}$. In particular, consider the set of degree at most $n-1$ monomial (Boolean) evaluation vectors \n", "itemtype": "equation", "pos": 39917, "prevtext": " in the code ${\\mathcal{RM}}(0, 4)^*$. As ${\\mathcal{RM}}(0, 4)^*$ is the set of evaluation vectors for degree 0 binary polynomials, there are exactly two vectors to choose from, corresponding to the zero (zero-everywhere) and constant (one-everywhere) functions. Since the all $1$ vector achieves the minimum distance of $7$ from ${\\text{Res}}_2({\\textbf{a}})$, we choose ${\\textbf{c}}'$ to be the all $1$ vector. By Lemma~\\ref{lem:codebasis}, ${\\textbf{c}}'={\\textbf{1}}$ (mod 2) is already in the space of zero-everywhere polynomials ${\\mathcal{C}_n}$, so steps 3 \\& 4 are trivial and we set ${\\textbf{c}}=1$ (mod 8). Finally we synthesize a circuit for the tuple ${\\textbf{a}}+{\\textbf{c}} = (3, 7, 7, 2, 0, 0, 2, 4, 0, 0, 2, 1, 1, 1, 1),$ corresponding to the phase polynomial \n\n", "index": 39, "text": "\\begin{align*}\n\t{P}'({\\textbf{x}}) = 3x_1 &+ 7x_2 + 7(x_1\\oplus x_2) + 2x_3 + 2(x_1\\oplus x_2\\oplus x_3) + 4x_4 + 2(x_1\\oplus x_2\\oplus x_4) \\\\\n  \t\t& +  (x_3\\oplus x_4) + (x_1\\oplus x_3\\oplus x_4) + (x_2\\oplus x_3\\oplus x_4) + (x_1\\oplus x_2\\oplus x_3 \\oplus x_4).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{P}^{\\prime}({\\textbf{x}})=3x_{1}\" display=\"inline\"><mrow><mrow><msup><mi>P</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>3</mn><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+7x_{2}+7(x_{1}\\oplus x_{2})+2x_{3}+2(x_{1}\\oplus x_{2}\\oplus x_{%&#10;3})+4x_{4}+2(x_{1}\\oplus x_{2}\\oplus x_{4})\" display=\"inline\"><mrow><mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>4</mn><mo>\u2062</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+(x_{3}\\oplus x_{4})+(x_{1}\\oplus x_{3}\\oplus x_{4})+(x_{2}\\oplus&#10;x%&#10;_{3}\\oplus x_{4})+(x_{1}\\oplus x_{2}\\oplus x_{3}\\oplus x_{4}).\" display=\"inline\"><mrow><mrow><mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>3</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>2</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>3</mn></msub><mo>\u2295</mo><msub><mi>x</mi><mn>4</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " We show that this set of vectors, under the natural inclusion of ${\\mathbb{F}_2}$ in ${\\mathbb{Z}}_8$, forms a generating set for ${\\mathbb{Z}}_8^{2^n-1}$ -- moreover, since each such vector is linearly independent over ${\\mathbb{F}_2}^{2^n-1}$ and hence also linearly independent over ${\\mathbb{Z}}_8^{2^n-1}$, this set is in fact a basis. We call this basis the \\emph{monomial basis} and give a proof.\n\n\\begin{lemma}\\label{lem:basis}\n$\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}\\}$ is a basis of ${\\mathbb{Z}}_8^{2^n-1}$\n\\end{lemma}\n\\begin{proof}\n\nWe first note that the set of all non-constant monomial evaluation vectors, $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}$, is a basis for the module ${\\mathbb{Z}}_8^{2^n-1}$. In particular, for any ${\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}$ the vector ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ contains a leading $1$ at the ${\\textbf{y}}$th index (e.g., Table~\\ref{tab:evals}), and hence any tuple of ${\\mathbb{Z}}_8^{2^n-1}$ may be written as a linear combination over this set. It therefore suffices to prove that ${\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n$ is in the span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}\\}$.\n\nIt may be observed that over ${\\mathbb{F}_2}$, the set of \\emph{all} monomial evaluation vectors is linearly dependent, and in particular that \n", "itemtype": "equation", "pos": -1, "prevtext": "\nA possible circuit implementing ${P}'$ is shown below:\n\n\\vspace{0.5em}\n\\centerline{\n\\Qcircuit @C=0.5em @R=.3em {\n\t\\lstick{x_1} & \\gate{T} & \\gate{P}        & \\ctrl{1} & \\qw       & \\targ & \\gate{T}                & \\targ       & \\qw       & \\gate{T}\n\t\t& \\targ & \\qw & \\qw & \\qw & \\qw & \\qw & \\ctrl{1} &  \\rstick{x_1} \\qw \\\\\n\t\\lstick{x_2} & \\gate{T^\\dagger} & \\qw & \\targ      & \\ctrl{1} & \\qw   & \\gate{T^\\dagger} & \\ctrl{-1} & \\ctrl{2} & \\qw\n\t\t& \\qw & \\qw & \\ctrl{2} & \\qw & \\ctrl{2} & \\ctrl{1} & \\targ &  \\rstick{x_2} \\qw \\\\\n\t\\lstick{x_3} & \\qw & \\gate{P}                & \\ctrl{1} & \\targ      & \\qw   & \\gate{P}                & \\qw        & \\qw        & \\qw\n\t\t& \\qw & \\ctrl{1} & \\qw & \\qw & \\qw & \\targ & \\qw &  \\rstick{x_3} \\qw \\\\\n\t\\lstick{x_4} & \\qw & \\gate{Z}                & \\targ      & \\qw       & \\ctrl{-3} & \\gate{T}          & \\qw         & \\targ     & \\gate{T} \n\t\t& \\ctrl{-3} & \\targ & \\targ & \\gate{P} & \\targ & \\qw & \\qw &  \\rstick{x_4} \\qw\n}\n}\\vspace{1em}\n\nNote that this decoding reduces the $T$-count from $14$ (or $8$, as $T$-par would obtain) to $7$. Moreover, the number of $T$ gates is equal to the distance from ${\\text{Res}}_2({\\textbf{a}})$ to the decoded word ${\\textbf{c}}'$.\n\n\\end{example}\n\n\\subsection{Complexity}\n\nIt may be noted that Algorithm~\\ref{alg:cnott} gives a polynomial-time (in $2^n$) reduction from $T$-count optimization over $\\{{\\text{CNOT}}, T\\}$ to minimum-distance decoding in ${\\mathcal{RM}}(n-4, n)^*$. We may likewise reduce the minimum-distance decoding problem for ${\\mathcal{RM}}(n-4, n)^*$ to $T$-count optimization: given a binary vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^{2^n-1}$, synthesize $U_{{P}_{{\\textbf{x}}}}$ over $\\{{\\text{CNOT}}, T\\}$ then optimize the circuit and compute the coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ for the optimized circuit. As a consequence of Theorem~\\ref{thm:main}, the vector ${\\textbf{x}}\\oplus{\\text{Res}}_2({\\textbf{a}})$ is a minimum distance decoding of ${\\textbf{x}}$. Assuming the optimized circuit does not have exponentially more gates than a canonical circuit,\\footnote{The canonical circuit for any linear phase operator uses $O(n2^{n-1})$ gates.} this reduction is also polynomial in the word length $2^n$, so we see that the problems are in this sense \\emph{equivalent}.\n\nThis equivalence lends evidence to the difficulty of $T$-count optimization, even in the restricted setting of circuits over ${\\text{CNOT}}$ and $T$ gates. In particular, any sub-exponential algorithm for exact optimization of $T$-count over $n$-qubit $\\{{\\text{CNOT}}, T\\}$ circuits induces a polynomial-time minimum-distance decoding algorithm for ${\\mathcal{RM}}(n-4, n)$. This can be further reduced to a \\emph{linear-time} algorithm by noting that the unitary $U_{{P}_{\\textbf{x}}}$ above can be implemented with $O(2^n)$ gates using one ancilla and the Gray code to cycle through each of the $2^n$ binary sums of $n$ variables with one ${\\text{CNOT}}$ gate each.\n\nIn either case it appears very unlikely that an efficient algorithm for minimum-distance decoding the order $n-4$ punctured Reed-Muller code exists. No minimum distance decoding algorithms in time polynomial in $2^n$ \\emph{or} the Hamming weight of the received word are currently known for arbitrary order length $2^n$ binary Reed-Muller codes. While some particular orders of Reed-Muller codes have efficient decoders, e.g., order 1, it was shown in \\cite{sl83} that minimum-distance decoding for ${\\mathcal{RM}}(n-4, n)^*$  is equivalent to the problem of finding a minimal decomposition of a symmetric 3-tensor into symmetric tryads (rank 1 3-tensors), a known hard problem.\n\n\\section{Proof of Theorem~\\ref{thm:main}}\\label{sec:proofmain}\n\nIn this section we prove Theorem~\\ref{thm:main}, and as a corollary Lemma~\\ref{lem:codebasis}.\n\n\\subsection{The monomial basis}\n\nOur proof relies on a connection between the binary evaluations of polynomials over ${\\mathbb{Z}}_8$ and the module ${\\mathbb{Z}}_8^{2^n-1}$. In particular, consider the set of degree at most $n-1$ monomial (Boolean) evaluation vectors \n", "index": 41, "text": "$$\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}\\}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"\\{{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{%&#10;\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{1}}\\}\\}.\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">{</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo>\u2223</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " since every input evaluates to $1$ for an even number of monomials. Further, as ${\\text{Res}}_2$ is homomorphic we have \n", "itemtype": "equation", "pos": -1, "prevtext": " We show that this set of vectors, under the natural inclusion of ${\\mathbb{F}_2}$ in ${\\mathbb{Z}}_8$, forms a generating set for ${\\mathbb{Z}}_8^{2^n-1}$ -- moreover, since each such vector is linearly independent over ${\\mathbb{F}_2}^{2^n-1}$ and hence also linearly independent over ${\\mathbb{Z}}_8^{2^n-1}$, this set is in fact a basis. We call this basis the \\emph{monomial basis} and give a proof.\n\n\\begin{lemma}\\label{lem:basis}\n$\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}\\}$ is a basis of ${\\mathbb{Z}}_8^{2^n-1}$\n\\end{lemma}\n\\begin{proof}\n\nWe first note that the set of all non-constant monomial evaluation vectors, $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}$, is a basis for the module ${\\mathbb{Z}}_8^{2^n-1}$. In particular, for any ${\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}$ the vector ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ contains a leading $1$ at the ${\\textbf{y}}$th index (e.g., Table~\\ref{tab:evals}), and hence any tuple of ${\\mathbb{Z}}_8^{2^n-1}$ may be written as a linear combination over this set. It therefore suffices to prove that ${\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n$ is in the span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}\\}$.\n\nIt may be observed that over ${\\mathbb{F}_2}$, the set of \\emph{all} monomial evaluation vectors is linearly dependent, and in particular that \n", "index": 43, "text": "$$\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={\\textbf{0}}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{n}}{{{\\boldsymbol{v}}}_{1}^{{y}_{1%&#10;}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={%&#10;\\textbf{0}}\" display=\"block\"><mrow><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow><mo>=</mo><mtext/></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " and so $\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={\\textbf{a}}$ for some ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ such that ${\\text{Res}}_2({\\textbf{a}})=0$. If we write ${\\textbf{a}}$ over the basis $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}$ and move all instances of ${\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n$ to the left we see \n", "itemtype": "equation", "pos": -1, "prevtext": " since every input evaluates to $1$ for an even number of monomials. Further, as ${\\text{Res}}_2$ is homomorphic we have \n", "index": 45, "text": "$$\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={\\text{Res}}_2\\left(\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\right)={\\textbf{0}}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{n}}{{{\\boldsymbol{v}}}_{1}^{{y}_{1%&#10;}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={%&#10;\\text{Res}}_{2}\\left(\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{n}}{{{\\boldsymbol{%&#10;v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}%&#10;^{{y}_{n}}}\\right)={\\textbf{0}}\" display=\"block\"><mrow><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow><mo>=</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mtext/></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " where ${\\textbf{a}}'$ is in the span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^n\\setminus\\{{\\textbf{0}},{\\textbf{1}}\\}\\}$ and $b\\in{\\mathbb{Z}}_8$. \n\nNow suppose $b$ is even. Then\n\n", "itemtype": "equation", "pos": -1, "prevtext": " and so $\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}={\\textbf{a}}$ for some ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ such that ${\\text{Res}}_2({\\textbf{a}})=0$. If we write ${\\textbf{a}}$ over the basis $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}$ and move all instances of ${\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n$ to the left we see \n", "index": 47, "text": "$$b\\cdot{\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n={\\textbf{a}}' - \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"b\\cdot{\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{\\boldsymbol{v}}_{n}={%&#10;\\textbf{a}}^{\\prime}-\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{%&#10;\\textbf{1}}\\}}{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}%&#10;}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\" display=\"block\"><mrow><mrow><mrow><mi>b</mi><mo>\u22c5</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><msup><mtext>\ud835\udc1a</mtext><mo>\u2032</mo></msup><mo>-</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nSince ${\\textbf{a}}'$ is in the ${\\mathbb{Z}}_8$-span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^n\\setminus\\{{\\textbf{0}},{\\textbf{1}}\\}\\}$ (i.e. the span using addition in ${\\mathbb{Z}}_8$), ${\\text{Res}}_2({\\textbf{a}}')$ is in its ${\\mathbb{F}_2}$-span and may be written over this basis. However, the set of all monomial evaluation vectors of degree at least 1 is linearly independent over ${\\mathbb{F}_2}$, so we arrive at a contradiction. Thus $b$ is odd and as such has a multiplicative inverse in ${\\mathbb{Z}}_8$ and hence \n", "itemtype": "equation", "pos": 47895, "prevtext": " where ${\\textbf{a}}'$ is in the span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^n\\setminus\\{{\\textbf{0}},{\\textbf{1}}\\}\\}$ and $b\\in{\\mathbb{Z}}_8$. \n\nNow suppose $b$ is even. Then\n\n", "index": 49, "text": "\\begin{align*}\n(b-1)\\cdot {\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n &= {\\textbf{a}}' - \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}} \\\\\n{\\text{Res}}_2({\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n) &= {\\text{Res}}_2({\\textbf{a}}') + {\\text{Res}}_2(\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}) \\\\\n{\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n &= {\\text{Res}}_2({\\textbf{a}}').\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(b-1)\\cdot{\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{%&#10;\\boldsymbol{v}}_{n}\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u22c5</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle={\\textbf{a}}^{\\prime}-\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{n}}%&#10;{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{%&#10;\\boldsymbol{v}}}_{n}^{{y}_{n}}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><msup><mtext>\ud835\udc1a</mtext><mo>\u2032</mo></msup><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder></mstyle><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\text{Res}}_{2}({\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{%&#10;\\boldsymbol{v}}_{n})\" display=\"inline\"><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\udc97</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle={\\text{Res}}_{2}({\\textbf{a}}^{\\prime})+{\\text{Res}}_{2}(\\sum_{{%&#10;\\textbf{y}}\\in{\\mathbb{F}_{2}}^{n}}{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{%&#10;\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mtext>\ud835\udc1a</mtext><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder></mstyle><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{\\boldsymbol{v}}_{n}\" display=\"inline\"><mrow><msub><mi>\ud835\udc97</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle={\\text{Res}}_{2}({\\textbf{a}}^{\\prime}).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mtext>\ud835\udc1a</mtext><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\n\\end{proof}\n\nLemma~\\ref{lem:basis} tells us that any tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ is the evaluation vector of some pseudo-Boolean polynomial function $f:{\\mathbb{F}_2}^n\\rightarrow{\\mathbb{Z}}_8$ where $f(v_1, v_2,\\dots, v_n)=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}},$ and hence ${\\boldsymbol{{f}}}={\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ in the monomial basis. Moreover, since \n", "itemtype": "equation", "pos": 49138, "prevtext": "\nSince ${\\textbf{a}}'$ is in the ${\\mathbb{Z}}_8$-span of $\\{{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\mid{\\textbf{y}}\\in{\\mathbb{F}_2}^n\\setminus\\{{\\textbf{0}},{\\textbf{1}}\\}\\}$ (i.e. the span using addition in ${\\mathbb{Z}}_8$), ${\\text{Res}}_2({\\textbf{a}}')$ is in its ${\\mathbb{F}_2}$-span and may be written over this basis. However, the set of all monomial evaluation vectors of degree at least 1 is linearly independent over ${\\mathbb{F}_2}$, so we arrive at a contradiction. Thus $b$ is odd and as such has a multiplicative inverse in ${\\mathbb{Z}}_8$ and hence \n", "index": 51, "text": "$${\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n=b\\cdot b^{-1}\\cdot{\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_n=b^{-1}\\cdot\\left({\\textbf{a}}' - \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\right).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{\\boldsymbol{v}}_{n}=b\\cdot b^{-%&#10;1}\\cdot{\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}\\cdots{\\boldsymbol{v}}_{n}=b^{-%&#10;1}\\cdot\\left({\\textbf{a}}^{\\prime}-\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{1}}\\}}{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_%&#10;{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\right).\" display=\"block\"><mrow><mrow><mrow><msub><mi>\ud835\udc97</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><mrow><mi>b</mi><mo>\u22c5</mo><msup><mi>b</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u22c5</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow><mo>=</mo><mrow><msup><mi>b</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u22c5</mo><mrow><mo>(</mo><mrow><msup><mtext>\ud835\udc1a</mtext><mo>\u2032</mo></msup><mo>-</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " ${\\text{Res}}_2({\\textbf{a}})$ is the evaluation vector of a Boolean polynomial function with degree at most ${\\text{deg}}(f)$.\n\n\\subsection{Evaluating ${P}_{\\textbf{a}}$}\\label{sec:eval}\n\nThe next step in our proof is to give an analytic formula for the value of a phase function ${P}_{\\textbf{a}}$ applied to a vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ as a function of the degree of the polynomial form of ${\\textbf{a}}$. Specifically, we show that ${P}_{\\textbf{a}}({\\textbf{x}})$ is equal to a linear combination of the Hamming weights -- numbers of solutions -- of certain Boolean polynomials arising from the multiplication of a monomial with a degree $1$ polynomial.\n\nConsider the value of a phase polynomial ${P}_{\\textbf{a}}$ at ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$: \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\end{proof}\n\nLemma~\\ref{lem:basis} tells us that any tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ is the evaluation vector of some pseudo-Boolean polynomial function $f:{\\mathbb{F}_2}^n\\rightarrow{\\mathbb{Z}}_8$ where $f(v_1, v_2,\\dots, v_n)=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}},$ and hence ${\\boldsymbol{{f}}}={\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ in the monomial basis. Moreover, since \n", "index": 53, "text": "$${\\text{Res}}_2({\\textbf{a}}) = \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}{\\text{Res}}_2(b_{\\textbf{y}}) {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m1\" class=\"ltx_Math\" alttext=\"{\\text{Res}}_{2}({\\textbf{a}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{1}}\\}}{\\text{Res}}_{2}(b_{\\textbf{y}}){{{\\boldsymbol{v}}}_%&#10;{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}%&#10;_{n}}},\" display=\"block\"><mrow><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1a</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " We can view the above formula as an inner product, since the value ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}={{x}_1{y}_1\\oplus{x}_2{y}_2\\oplus\\cdots\\oplus{x}_{n}{y}_{n}}$ is the ${\\textbf{y}}$th component of the evaluation vector ${{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}$. \n\nFormally, we define $\\langle {\\textbf{a}}, {\\textbf{b}}\\rangle$ for ${\\textbf{a}},{\\textbf{b}}\\in{\\mathbb{Z}}_8^{2^n-1}$ as $\\sum_{i=1}^{2^n-1}a_ib_i$. Note that \n", "itemtype": "equation", "pos": -1, "prevtext": " ${\\text{Res}}_2({\\textbf{a}})$ is the evaluation vector of a Boolean polynomial function with degree at most ${\\text{deg}}(f)$.\n\n\\subsection{Evaluating ${P}_{\\textbf{a}}$}\\label{sec:eval}\n\nThe next step in our proof is to give an analytic formula for the value of a phase function ${P}_{\\textbf{a}}$ applied to a vector ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ as a function of the degree of the polynomial form of ${\\textbf{a}}$. Specifically, we show that ${P}_{\\textbf{a}}({\\textbf{x}})$ is equal to a linear combination of the Hamming weights -- numbers of solutions -- of certain Boolean polynomials arising from the multiplication of a monomial with a degree $1$ polynomial.\n\nConsider the value of a phase polynomial ${P}_{\\textbf{a}}$ at ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$: \n", "index": 55, "text": "$${P}_{\\textbf{a}}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}} a_{\\textbf{y}}({{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m1\" class=\"ltx_Math\" alttext=\"{P}_{\\textbf{a}}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{0}}\\}}a_{\\textbf{y}}({{y}_{1}{x}_{1}\\oplus{y}_{2}{x}_{2}%&#10;\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}).\" display=\"block\"><mrow><mrow><mrow><msub><mi>P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext/><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>y</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for any ${\\textbf{a}},{\\textbf{b}},{\\textbf{c}}\\in{\\mathbb{Z}}_8^{2^n-1}$ since the inner product is linear in either argument over ${\\mathbb{Z}}$, and hence also ${\\mathbb{Z}}_8$. Using this observation, we give an explicit formula for ${P}_{\\textbf{a}}({\\textbf{x}})$ as a function of the monomial basis vectors appearing in ${\\textbf{a}}$:\n\n\\begin{lemma}\\label{lem:eval}\nLet $\\normalfont {\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n}$ and suppose $\\normalfont {\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ in the monomial basis. Then \n", "itemtype": "equation", "pos": -1, "prevtext": " We can view the above formula as an inner product, since the value ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}={{x}_1{y}_1\\oplus{x}_2{y}_2\\oplus\\cdots\\oplus{x}_{n}{y}_{n}}$ is the ${\\textbf{y}}$th component of the evaluation vector ${{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}$. \n\nFormally, we define $\\langle {\\textbf{a}}, {\\textbf{b}}\\rangle$ for ${\\textbf{a}},{\\textbf{b}}\\in{\\mathbb{Z}}_8^{2^n-1}$ as $\\sum_{i=1}^{2^n-1}a_ib_i$. Note that \n", "index": 57, "text": "$$\\langle{\\textbf{a}}+{\\textbf{b}}, {\\textbf{c}}\\rangle=\\langle{\\textbf{a}}, {\\textbf{c}}\\rangle+\\langle{\\textbf{b}},{\\textbf{c}}\\rangle$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m1\" class=\"ltx_Math\" alttext=\"\\langle{\\textbf{a}}+{\\textbf{b}},{\\textbf{c}}\\rangle=\\langle{\\textbf{a}},{%&#10;\\textbf{c}}\\rangle+\\langle{\\textbf{b}},{\\textbf{c}}\\rangle\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><mtext>\ud835\udc1a</mtext><mo>+</mo><mtext>\ud835\udc1b</mtext></mrow><mo>,</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mtext>\ud835\udc1a</mtext><mo>,</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mtext>\ud835\udc1b</mtext><mo>,</mo><mtext>\ud835\udc1c</mtext><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\\end{lemma}\n\\begin{proof}\n\n", "itemtype": "equation", "pos": 52650, "prevtext": " for any ${\\textbf{a}},{\\textbf{b}},{\\textbf{c}}\\in{\\mathbb{Z}}_8^{2^n-1}$ since the inner product is linear in either argument over ${\\mathbb{Z}}$, and hence also ${\\mathbb{Z}}_8$. Using this observation, we give an explicit formula for ${P}_{\\textbf{a}}({\\textbf{x}})$ as a function of the monomial basis vectors appearing in ${\\textbf{a}}$:\n\n\\begin{lemma}\\label{lem:eval}\nLet $\\normalfont {\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n}$ and suppose $\\normalfont {\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ in the monomial basis. Then \n", "index": 59, "text": "$$\\normalfont {P}_{\\textbf{a}}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})(x_1{\\boldsymbol{v}}_1\\oplus x_2{\\boldsymbol{v}}_2\\oplus\\cdots x_n{\\boldsymbol{v}}_n)).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m1\" class=\"ltx_Math\" alttext=\"{P}_{\\textbf{a}}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}}{\\text{wt}}(({{{\\boldsymbol{v}}}_{1}^{%&#10;{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}%&#10;})(x_{1}{\\boldsymbol{v}}_{1}\\oplus x_{2}{\\boldsymbol{v}}_{2}\\oplus\\cdots x_{n}%&#10;{\\boldsymbol{v}}_{n})).\" display=\"block\"><mrow><mrow><mrow><msub><mi mathvariant=\"normal\">P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi mathvariant=\"normal\">n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msub><mi mathvariant=\"normal\">b</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc2f</mi><mn>1</mn><msub><mi mathvariant=\"normal\">y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc2f</mi><mn>2</mn><msub><mi mathvariant=\"normal\">y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc2f</mi><mi mathvariant=\"normal\">n</mi><msub><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi mathvariant=\"normal\">x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc2f</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi mathvariant=\"normal\">x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc2f</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mrow><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi mathvariant=\"normal\">x</mi><mi mathvariant=\"normal\">n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2f</mi><mi mathvariant=\"normal\">n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\\end{proof}\n\nThe value of ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))$ in Lemma~\\ref{lem:eval} above may be restated as the number of solutions to the equation $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=1$. Fortunately, this number of a simple function of the degree of the polynomial, as the following Lemma shows.\n\n\\begin{lemma}\\label{lem:weight}\nFor any ${\\textbf{x}}, {\\textbf{y}}\\in{\\mathbb{F}_2}^n$, \n", "itemtype": "equation", "pos": 53003, "prevtext": "\n\\end{lemma}\n\\begin{proof}\n\n", "index": 61, "text": "\\begin{align*}\n{P}_{\\textbf{a}}({\\textbf{x}}) &= \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}} a_{\\textbf{y}}({{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}) \\\\\n\t&= \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}} a_{\\textbf{y}}({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})_{\\textbf{y}} \\\\\n\t&= \\langle{\\textbf{a}},  {{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}\\rangle \\\\\n\t&= \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} \\langle {{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}},  {{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}\\rangle \\\\\n\t&= \\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}} {\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{P}_{\\textbf{a}}({\\textbf{x}})\" display=\"inline\"><mrow><msub><mi>P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{0%&#10;}}\\}}a_{\\textbf{y}}({{y}_{1}{x}_{1}\\oplus{y}_{2}{x}_{2}\\oplus\\cdots\\oplus{y}_{%&#10;n}{x}_{n}})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext/><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder></mstyle><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>y</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{0%&#10;}}\\}}a_{\\textbf{y}}({{x}_{1}{{\\boldsymbol{v}}}_{1}\\oplus{x}_{2}{{\\boldsymbol{v%&#10;}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})_{\\textbf{y}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext/><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder></mstyle><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mtext>\ud835\udc32</mtext></msub></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\langle{\\textbf{a}},{{x}_{1}{{\\boldsymbol{v}}}_{1}\\oplus{x}_{2}{%&#10;{\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}\\rangle\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mtext>\ud835\udc1a</mtext><mo>,</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex38.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{1%&#10;}}\\}}b_{\\textbf{y}}\\langle{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_%&#10;{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}},{{x}_{1}{{\\boldsymbol{v}}%&#10;}_{1}\\oplus{x}_{2}{{\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol%&#10;{v}}}_{n}}\\rangle\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder></mstyle><mrow><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo>,</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex39.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{1%&#10;}}\\}}b_{\\textbf{y}}{\\text{wt}}(({{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol%&#10;{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_{1}{{%&#10;\\boldsymbol{v}}}_{1}\\oplus{x}_{2}{{\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{%&#10;n}{{\\boldsymbol{v}}}_{n}})).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder></mstyle><mrow><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nif $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$, or $0$ otherwise.\n\\end{lemma}\n\\begin{proof}\n\nClearly if $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}) = 0$, then ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 0$ as required, so suppose instead that $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$. Since ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ has a degree of $1$, \n", "itemtype": "equation", "pos": 54836, "prevtext": "\n\\end{proof}\n\nThe value of ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))$ in Lemma~\\ref{lem:eval} above may be restated as the number of solutions to the equation $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=1$. Fortunately, this number of a simple function of the degree of the polynomial, as the following Lemma shows.\n\n\\begin{lemma}\\label{lem:weight}\nFor any ${\\textbf{x}}, {\\textbf{y}}\\in{\\mathbb{F}_2}^n$, \n", "index": 63, "text": "$${\\normalfont {\\text{wt}}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 2^{n-{\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m1\" class=\"ltx_Math\" alttext=\"{{\\text{wt}}}(({{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2%&#10;}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_{1}{{\\boldsymbol{v}}}_{1}%&#10;\\oplus{x}_{2}{{\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}%&#10;_{n}}))=2^{n-{\\text{deg}}(({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{%&#10;y}_{n}}})({{x}_{1}{v}_{1}\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}%&#10;))}\" display=\"block\"><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nConsider the former case. Clearly ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ is a linear combination involving only variables present in ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Then by the equivalence $v_i^2=v_i$ for any $i$, \n", "itemtype": "equation", "pos": 56000, "prevtext": "\nif $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$, or $0$ otherwise.\n\\end{lemma}\n\\begin{proof}\n\nClearly if $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}) = 0$, then ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 0$ as required, so suppose instead that $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$. Since ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ has a degree of $1$, \n", "index": 65, "text": "$${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})\\text{, or }{\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})+1.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex41.m1\" class=\"ltx_Math\" alttext=\"{\\text{deg}}(({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})({{x%&#10;}_{1}{v}_{1}\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg%&#10;}}({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})\\text{, or }{%&#10;\\text{deg}}({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})+1.\" display=\"block\"><mrow><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mtext>, or deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mn>1</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " Since $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$, it must be the case that ${\\text{wt}}({\\textbf{x}})=1\\mod 2$. As $v_{i_1}v_{i_2}\\cdots v_{i_j}=1$ exactly when $v_{i_1}=v_{i_2}=\\cdots = v_{i_j}=1$, we see that ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}=1$ has $2^{n-{\\text{wt}}({\\textbf{y}})}$ solutions, and hence \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nConsider the former case. Clearly ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ is a linear combination involving only variables present in ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Then by the equivalence $v_i^2=v_i$ for any $i$, \n", "index": 67, "text": "$$({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=({\\text{wt}}({\\textbf{x}}) \\mod 2)\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex42.m1\" class=\"ltx_Math\" alttext=\"({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})({{x}_{1}{v}_{1}%&#10;\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=({\\text{wt}}({\\textbf{x%&#10;}})\\mod 2)\\cdot{{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}}.\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u22c5</mo><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup></mrow><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nNow consider the latter case, ${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})+1$. We know the linear combination ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ must contain some variable not in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Without loss of generality assume ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ and ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ have no variables in common, as otherwise we may write \n", "itemtype": "equation", "pos": 57152, "prevtext": " Since $({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})\\neq 0$, it must be the case that ${\\text{wt}}({\\textbf{x}})=1\\mod 2$. As $v_{i_1}v_{i_2}\\cdots v_{i_j}=1$ exactly when $v_{i_1}=v_{i_2}=\\cdots = v_{i_j}=1$, we see that ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}=1$ has $2^{n-{\\text{wt}}({\\textbf{y}})}$ solutions, and hence \n", "index": 69, "text": "$${\\text{wt}}({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})=2^{n-{\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m1\" class=\"ltx_Math\" alttext=\"{\\text{wt}}({{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}%&#10;\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})=2^{n-{\\text{deg}}({{v}_{1}^{{y}_{1}}{%&#10;v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})}.\" display=\"block\"><mrow><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for some $c\\in{\\mathbb{F}_2}$ such that ${{x'}_1{v}_1\\oplus{x'}_2{v}_2\\oplus\\cdots\\oplus{x'}_{n}{v}_{n}}$ involves none of the variables in ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Since $c\\oplus{{x'}_1{v}_1\\oplus{x'}_2{v}_2\\oplus\\cdots\\oplus{x'}_{n}{v}_{n}}=1$ for exactly half of the $2^{n-{\\text{wt}}({\\textbf{y}})}$ valuations where ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}=1$, we see that there are $2^{n-{\\text{wt}}({\\textbf{y}})-1}$ solutions, hence \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nNow consider the latter case, ${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})+1$. We know the linear combination ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ must contain some variable not in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Without loss of generality assume ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ and ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ have no variables in common, as otherwise we may write \n", "index": 71, "text": "$$({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})(c\\oplus{{x'}_1{v}_1\\oplus{x'}_2{v}_2\\oplus\\cdots\\oplus{x'}_{n}{v}_{n}})$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex44.m1\" class=\"ltx_Math\" alttext=\"({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})({{x}_{1}{v}_{1}%&#10;\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}})=({{v}_{1}^{{y}_{1}}{v}_%&#10;{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})(c\\oplus{{x^{\\prime}}_{1}{v}_{1}\\oplus{x%&#10;^{\\prime}}_{2}{v}_{2}\\oplus\\cdots\\oplus{x^{\\prime}}_{n}{v}_{n}})\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>c</mi><mo>\u2295</mo><mrow><mmultiscripts><mi>x</mi><none/><mo>\u2032</mo><mn>1</mn><none/></mmultiscripts><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><mmultiscripts><mi>x</mi><none/><mo>\u2032</mo><mn>2</mn><none/></mmultiscripts><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><mmultiscripts><mi>x</mi><none/><mo>\u2032</mo><mi>n</mi><none/></mmultiscripts><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " as required.\n\\end{proof}\n\nIn general, it is not the case that ${\\text{wt}}({\\boldsymbol{{f}}})=2^{n-{\\text{deg}}(f)}$ for an $n$-variate Boolean polynomial function $f$. In particular, consider $f(v_1, v_2,\\dots, v_n)=1\\oplus v_1v_2\\cdots v_i$. Since $v_1v_2\\cdots v_i=1$ has $2^{n-i}$ solutions, \n", "itemtype": "equation", "pos": -1, "prevtext": " for some $c\\in{\\mathbb{F}_2}$ such that ${{x'}_1{v}_1\\oplus{x'}_2{v}_2\\oplus\\cdots\\oplus{x'}_{n}{v}_{n}}$ involves none of the variables in ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Since $c\\oplus{{x'}_1{v}_1\\oplus{x'}_2{v}_2\\oplus\\cdots\\oplus{x'}_{n}{v}_{n}}=1$ for exactly half of the $2^{n-{\\text{wt}}({\\textbf{y}})}$ valuations where ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}=1$, we see that there are $2^{n-{\\text{wt}}({\\textbf{y}})-1}$ solutions, hence \n", "index": 73, "text": "$${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 2^{n-{\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}) - 1}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex45.m1\" class=\"ltx_Math\" alttext=\"{\\text{wt}}(({{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}%&#10;\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_{1}{{\\boldsymbol{v}}}_{1}\\oplus{%&#10;x}_{2}{{\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))%&#10;=2^{n-{\\text{deg}}({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}}%&#10;)-1}\" display=\"block\"><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nAs a corollary to Lemmas~\\ref{lem:eval} and \\ref{lem:weight} we obtain a proof of Lemma~\\ref{lem:codebasis}.\n\n\\begin{corollary}[Lemma~\\ref{lem:codebasis}]\nFor all ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ with ${\\text{wt}}({\\textbf{y}})\\leq n-4$ we have ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\in{\\mathcal{C}_n}$.\n\\end{corollary}\n\\begin{proof}\nLet ${\\textbf{a}}={{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ for some ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ of Hamming weight at most $n-4$ and let ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. By Lemma~\\ref{lem:eval}, \n", "itemtype": "equation", "pos": 59304, "prevtext": " as required.\n\\end{proof}\n\nIn general, it is not the case that ${\\text{wt}}({\\boldsymbol{{f}}})=2^{n-{\\text{deg}}(f)}$ for an $n$-variate Boolean polynomial function $f$. In particular, consider $f(v_1, v_2,\\dots, v_n)=1\\oplus v_1v_2\\cdots v_i$. Since $v_1v_2\\cdots v_i=1$ has $2^{n-i}$ solutions, \n", "index": 75, "text": "$${\\text{wt}}({\\boldsymbol{{f}}})=2^n-2^{n-i}\\neq 2^{n-{\\text{deg}}(f)}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex46.m1\" class=\"ltx_Math\" alttext=\"{\\text{wt}}({\\boldsymbol{{f}}})=2^{n}-2^{n-i}\\neq 2^{n-{\\text{deg}}(f)}.\" display=\"block\"><mrow><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc87</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mi>i</mi></mrow></msup></mrow><mo>\u2260</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nSince ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))=0$ or $2^{n-{\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))}$ by Lemma~\\ref{lem:weight} and ${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))\\leq n-3$ we have ${P}_{{\\textbf{a}}}({\\textbf{x}}) = 0\\mod 8$ as required.\n\\end{proof}\n\n\\subsection{Proof of Theorem~\\ref{thm:main}}\\label{sec:slice}\n\nFrom Lemma~\\ref{lem:weight} it's immediate that if a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ may be written over the monomial basis with degree at most $n-4$, then ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 8$ for any ${\\textbf{x}}$ and so ${\\textbf{a}}\\in{\\mathcal{C}_n}$. However, it may be the case that ${\\textbf{a}}$ contains monomials with degree greater than $n-4$ and yet are still in the codespace ${\\mathcal{C}_n}$. For instance, consider ${\\textbf{a}} = 2\\cdot{\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_{n-3}$. For any ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, \n\n", "itemtype": "equation", "pos": 60033, "prevtext": "\n\nAs a corollary to Lemmas~\\ref{lem:eval} and \\ref{lem:weight} we obtain a proof of Lemma~\\ref{lem:codebasis}.\n\n\\begin{corollary}[Lemma~\\ref{lem:codebasis}]\nFor all ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ with ${\\text{wt}}({\\textbf{y}})\\leq n-4$ we have ${{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}\\in{\\mathcal{C}_n}$.\n\\end{corollary}\n\\begin{proof}\nLet ${\\textbf{a}}={{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ for some ${\\textbf{y}}\\in{\\mathbb{F}_2}^n$ of Hamming weight at most $n-4$ and let ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. By Lemma~\\ref{lem:eval}, \n", "index": 77, "text": "$${P}_{{\\textbf{a}}}({\\textbf{x}}) = {\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex47.m1\" class=\"ltx_Math\" alttext=\"{P}_{{\\textbf{a}}}({\\textbf{x}})={\\text{wt}}(({{{\\boldsymbol{v}}}_{1}^{{y}_{1}%&#10;}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}%&#10;_{1}{{\\boldsymbol{v}}}_{1}\\oplus{x}_{2}{{\\boldsymbol{v}}}_{2}\\oplus\\cdots%&#10;\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))\" display=\"block\"><mrow><mrow><msub><mi>P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\nIn this case we have ${\\textbf{a}}\\in{\\mathcal{C}_n}$ and ${\\text{Res}}_2({\\textbf{a}}) = {\\textbf{0}}\\in{\\mathcal{RM}}(n-4, n)^*$ for $n\\geq 4$ even though as a polynomial over ${\\mathbb{Z}}_8$, ${\\textbf{a}}$ has degree greater than $n-4$. On the other hand, in some sense, with regard to Lemma~\\ref{lem:weight}, the term $2\\cdot v_1v_2\\cdots v_{n-3}=2^1\\cdot v_1v_2\\cdots v_{n-3}$ has an \\emph{effective} degree of ${\\text{deg}}(v_1v_2\\cdots v_{n-3})-1=n-4$, since $2\\cdot{\\text{wt}}(({\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_{n-3})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 0$, $2^{n-(n - 4)}=2^4$ or $2^{n-(n-3)}=2^3$. \n\nWe define the effective degree of a term of the form $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be ${\\text{wt}}({\\textbf{y}}) - i$. Moreover, we let the effective degree of a polynomial sum $\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}}{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be the highest effective degree of any term obtained by expanding each coefficient $b_{\\textbf{y}}$ to its binary representation, \n", "itemtype": "equation", "pos": 61558, "prevtext": "\nSince ${\\text{wt}}(({{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))=0$ or $2^{n-{\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))}$ by Lemma~\\ref{lem:weight} and ${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))\\leq n-3$ we have ${P}_{{\\textbf{a}}}({\\textbf{x}}) = 0\\mod 8$ as required.\n\\end{proof}\n\n\\subsection{Proof of Theorem~\\ref{thm:main}}\\label{sec:slice}\n\nFrom Lemma~\\ref{lem:weight} it's immediate that if a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ may be written over the monomial basis with degree at most $n-4$, then ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 8$ for any ${\\textbf{x}}$ and so ${\\textbf{a}}\\in{\\mathcal{C}_n}$. However, it may be the case that ${\\textbf{a}}$ contains monomials with degree greater than $n-4$ and yet are still in the codespace ${\\mathcal{C}_n}$. For instance, consider ${\\textbf{a}} = 2\\cdot{\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_{n-3}$. For any ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, \n\n", "index": 79, "text": "\\begin{align*}\n{P}_{\\textbf{a}}({\\textbf{x}}) \n\t&= 2\\cdot{\\text{wt}}(({\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_{n-3})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) \\\\\n\t&= 2\\cdot 2^{n-{\\text{deg}}((v_1v_2\\cdots v_{n-3})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))} \\\\\n\t&=0\\mod 8.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex48.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{P}_{\\textbf{a}}({\\textbf{x}})\" display=\"inline\"><mrow><msub><mi>P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex48.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=2\\cdot{\\text{wt}}(({\\boldsymbol{v}}_{1}{\\boldsymbol{v}}_{2}%&#10;\\cdots{\\boldsymbol{v}}_{n-3})({{x}_{1}{{\\boldsymbol{v}}}_{1}\\oplus{x}_{2}{{%&#10;\\boldsymbol{v}}}_{2}\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}}))\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u22c5</mo><mtext>wt</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\udc97</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mrow><mi>n</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex49.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=2\\cdot 2^{n-{\\text{deg}}((v_{1}v_{2}\\cdots v_{n-3})({{x}_{1}{v}_%&#10;{1}\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mn>2</mn><mo>\u22c5</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>-</mo><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>v</mi><mrow><mi>n</mi><mo>-</mo><mn>3</mn></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex50.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=0\\mod 8.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mn>0</mn><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mn>8</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " As we prove below, the phase polynomial associated with a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ necessarily evaluates to a non-zero value mod $2^k$ for some input if ${\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}}{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ has effective degree $n-k$.\n\n\\begin{lemma}\\label{lem:idk}\nLet ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ have effective degree $n-k$ in the monomial basis. There exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that \n", "itemtype": "equation", "pos": -1, "prevtext": "\nIn this case we have ${\\textbf{a}}\\in{\\mathcal{C}_n}$ and ${\\text{Res}}_2({\\textbf{a}}) = {\\textbf{0}}\\in{\\mathcal{RM}}(n-4, n)^*$ for $n\\geq 4$ even though as a polynomial over ${\\mathbb{Z}}_8$, ${\\textbf{a}}$ has degree greater than $n-4$. On the other hand, in some sense, with regard to Lemma~\\ref{lem:weight}, the term $2\\cdot v_1v_2\\cdots v_{n-3}=2^1\\cdot v_1v_2\\cdots v_{n-3}$ has an \\emph{effective} degree of ${\\text{deg}}(v_1v_2\\cdots v_{n-3})-1=n-4$, since $2\\cdot{\\text{wt}}(({\\boldsymbol{v}}_1{\\boldsymbol{v}}_2\\cdots{\\boldsymbol{v}}_{n-3})({{x}_1{{\\boldsymbol{v}}}_1\\oplus{x}_2{{\\boldsymbol{v}}}_2\\oplus\\cdots\\oplus{x}_{n}{{\\boldsymbol{v}}}_{n}})) = 0$, $2^{n-(n - 4)}=2^4$ or $2^{n-(n-3)}=2^3$. \n\nWe define the effective degree of a term of the form $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be ${\\text{wt}}({\\textbf{y}}) - i$. Moreover, we let the effective degree of a polynomial sum $\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}}{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ to be the highest effective degree of any term obtained by expanding each coefficient $b_{\\textbf{y}}$ to its binary representation, \n", "index": 81, "text": "$$b_{\\textbf{y}}=(b_{\\textbf{y}})_02^0 + (b_{\\textbf{y}})_12^1 + (b_{\\textbf{y}})_22^2.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex51.m1\" class=\"ltx_Math\" alttext=\"b_{\\textbf{y}}=(b_{\\textbf{y}})_{0}2^{0}+(b_{\\textbf{y}})_{1}2^{1}+(b_{\\textbf%&#10;{y}})_{2}2^{2}.\" display=\"block\"><mrow><mrow><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo>=</mo><mrow><mrow><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo stretchy=\"false\">)</mo></mrow><mn>0</mn></msub><mo>\u2062</mo><msup><mn>2</mn><mn>0</mn></msup></mrow><mo>+</mo><mrow><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo stretchy=\"false\">)</mo></mrow><mn>1</mn></msub><mo>\u2062</mo><msup><mn>2</mn><mn>1</mn></msup></mrow><mo>+</mo><mrow><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mtext>\ud835\udc32</mtext></msub><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo>\u2062</mo><msup><mn>2</mn><mn>2</mn></msup></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\\end{lemma}\n\\begin{proof}\nSuppose to the contrary that ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 2^{k}$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. Consider a term $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ having effective degree $n-l$ for some $l$ greater than or equal to $k$, hence the effective degree is at most $n-k$. By Lemmas \\ref{lem:eval} and \\ref{lem:weight}, \n", "itemtype": "equation", "pos": 63763, "prevtext": " As we prove below, the phase polynomial associated with a tuple ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ necessarily evaluates to a non-zero value mod $2^k$ for some input if ${\\textbf{a}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}}b_{\\textbf{y}}{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ has effective degree $n-k$.\n\n\\begin{lemma}\\label{lem:idk}\nLet ${\\textbf{a}}\\in{\\mathbb{Z}}_8^{2^n-1}$ have effective degree $n-k$ in the monomial basis. There exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that \n", "index": 83, "text": "$${P}_{\\textbf{a}}({\\textbf{x}}) \\neq 0 \\mod 2^k.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex52.m1\" class=\"ltx_Math\" alttext=\"{P}_{\\textbf{a}}({\\textbf{x}})\\neq 0\\mod 2^{k}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>P</mi><mtext>\ud835\udc1a</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2260</mo><mrow><mn>0</mn><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><msup><mn>2</mn><mi>k</mi></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " and since $l\\geq k$, the result is non-zero mod $2^k$ if and only if $l=k$ (i.e., the effective degree is $n-k$) and ${P}_{2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}}({\\textbf{x}})=2^{l - 1}$. From Lemma \\ref{lem:weight} we know that this is the case exactly if \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\end{lemma}\n\\begin{proof}\nSuppose to the contrary that ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 2^{k}$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. Consider a term $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ having effective degree $n-l$ for some $l$ greater than or equal to $k$, hence the effective degree is at most $n-k$. By Lemmas \\ref{lem:eval} and \\ref{lem:weight}, \n", "index": 85, "text": "$${P}_{2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}}({\\textbf{x}})=2^{l}\\text{ or } 2^{l - 1},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex53.m1\" class=\"ltx_Math\" alttext=\"{P}_{2^{i}\\cdot{{{\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2%&#10;}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}}({\\textbf{x}})=2^{l}\\text{ or }2^{l-%&#10;1},\" display=\"block\"><mrow><mrow><mrow><msub><mi>P</mi><mrow><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>\u22c5</mo><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup></mrow><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mn>2</mn><mi>l</mi></msup><mo>\u2062</mo><mtext>\u00a0or\u00a0</mtext><mo>\u2062</mo><msup><mn>2</mn><mrow><mi>l</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " or equivalently the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ contains a non-zero multiple of some variable \\emph{not} present in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. It can then be observed that for any input ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, if ${P}_{\\textbf{a}}({\\textbf{x}})=0\\mod 2^k$, there must be an even number of terms with effective degree $n-k$ that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$. We show that this is impossible for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ by an inclusion--exclusion argument.\n\nWe define $S_i$ to be the set of all effective degree $n-k$ terms of ${\\textbf{a}}$ that do not contain the variable $v_i$. Clearly $\\cup_{i|x_i=1} S_i$ gives the set of all such terms that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$. Moreover, $|\\cup_{i|x_i=1} S_i|$ gives the number of such terms. By the assumption and the observation above that ${P}_{\\textbf{a}}({\\textbf{x}})=0\\mod 2^k$ if and only if there are an even number of terms in ${\\textbf{a}}$ with effective degree $n-k$ that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$, it follows that for any ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, \n", "itemtype": "equation", "pos": -1, "prevtext": " and since $l\\geq k$, the result is non-zero mod $2^k$ if and only if $l=k$ (i.e., the effective degree is $n-k$) and ${P}_{2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}}({\\textbf{x}})=2^{l - 1}$. From Lemma \\ref{lem:weight} we know that this is the case exactly if \n", "index": 87, "text": "$${\\text{deg}}(({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})({{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg}}({{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}})+1,$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex54.m1\" class=\"ltx_Math\" alttext=\"{\\text{deg}}(({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})({{x%&#10;}_{1}{v}_{1}\\oplus{x}_{2}{v}_{2}\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}))={\\text{deg%&#10;}}({{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}_{n}^{{y}_{n}}})+1,\" display=\"block\"><mrow><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>v</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mn>1</mn></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\nNow take some term $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ of effective degree $n-k$ in ${\\textbf{a}}$ but with minimal \\emph{actual} degree -- that is, the degree of the monomial part, ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Since ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ has minimal degree, every other term of effective degree $n-k$ must contain some variable $v_i$ for which $y_i=0$. Hence, the intersection of $S_i$ over all indexes for which $v_i$ is not in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ contains exactly one term, \n", "itemtype": "equation", "pos": 66236, "prevtext": " or equivalently the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$ contains a non-zero multiple of some variable \\emph{not} present in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. It can then be observed that for any input ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, if ${P}_{\\textbf{a}}({\\textbf{x}})=0\\mod 2^k$, there must be an even number of terms with effective degree $n-k$ that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$. We show that this is impossible for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ by an inclusion--exclusion argument.\n\nWe define $S_i$ to be the set of all effective degree $n-k$ terms of ${\\textbf{a}}$ that do not contain the variable $v_i$. Clearly $\\cup_{i|x_i=1} S_i$ gives the set of all such terms that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$. Moreover, $|\\cup_{i|x_i=1} S_i|$ gives the number of such terms. By the assumption and the observation above that ${P}_{\\textbf{a}}({\\textbf{x}})=0\\mod 2^k$ if and only if there are an even number of terms in ${\\textbf{a}}$ with effective degree $n-k$ that do not contain some variable in the sum ${{x}_1{v}_1\\oplus{x}_2{v}_2\\oplus\\cdots\\oplus{x}_{n}{v}_{n}}$, it follows that for any ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$, \n", "index": 89, "text": "$$|\\cup_{v_i\\in A} S_i| = 0\\mod 2.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex55.m1\" class=\"ltx_Math\" alttext=\"|\\cup_{v_{i}\\in A}S_{i}|=0\\mod 2.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mo>\u222a</mo><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>\u2208</mo><mi>A</mi></mrow></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mn>0</mn><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mn>2</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " Now, $|\\cap_{y_i=0} S_i|$ can be written as a sum of cardinalities of unions of the sets $S_i$: \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nNow take some term $2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ of effective degree $n-k$ in ${\\textbf{a}}$ but with minimal \\emph{actual} degree -- that is, the degree of the monomial part, ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$. Since ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ has minimal degree, every other term of effective degree $n-k$ must contain some variable $v_i$ for which $y_i=0$. Hence, the intersection of $S_i$ over all indexes for which $v_i$ is not in the monomial ${{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}$ contains exactly one term, \n", "index": 91, "text": "$$\\cap_{i|y_i=0} S_i = \\{2^i\\cdot{{v}_1^{{y}_1}{v}_2^{{y}_2}\\cdots{v}_{n}^{{y}_{n}}}\\}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex56.m1\" class=\"ltx_Math\" alttext=\"\\cap_{i|y_{i}=0}S_{i}=\\{2^{i}\\cdot{{v}_{1}^{{y}_{1}}{v}_{2}^{{y}_{2}}\\cdots{v}%&#10;_{n}^{{y}_{n}}}\\}.\" display=\"block\"><mrow><mrow><mrow><msub><mo>\u2229</mo><mrow><mi>i</mi><mo stretchy=\"false\">|</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>\u22c5</mo><msubsup><mi>v</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup></mrow><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>v</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for some integers $s_{\\textbf{x}}$. For instance, $|S_1\\cap S_2| = |S_1| + |S_2| - |S_1\\cup S_2|$. However, since $|\\cup_{i|x_i=1} S_i| = 0\\mod 2$ for any ${\\textbf{x}}$, we have $|\\cap_{i|y_i=0} S_i|=0\\mod 2$, a contradiction. Thus there exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that ${P}_{\\textbf{a}}({\\textbf{x}}) \\neq 0 \\mod 2^k$, as required.\n\n\\end{proof}\n\nWith Lemma~\\ref{lem:idk} we have everything we need to prove Theorem~\\ref{thm:main} below.\n\n\\begin{proof}[Proof of Theorem~\\ref{thm:main}] \\mbox{}\\\\\n\n\\hangindent=0.7cm\n\\noindent ${\\mathcal{RM}}(n-4, n)^*\\subseteq{\\text{Res}}_2({\\mathcal{C}_n})$: \\\\\n\\hspace*{\\parindent} Let ${\\textbf{c}}'$ be in ${\\mathcal{RM}}(n-4,n)^*$. Then \n", "itemtype": "equation", "pos": -1, "prevtext": " Now, $|\\cap_{y_i=0} S_i|$ can be written as a sum of cardinalities of unions of the sets $S_i$: \n", "index": 93, "text": "$$|\\cap_{i|y_i=0} S_i|=\\sum_{{\\textbf{x}}\\in{\\mathbb{F}_2}^n} s_{\\textbf{x}}|\\cup_{i|x_i=1} S_i|$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex57.m1\" class=\"ltx_Math\" alttext=\"|\\cap_{i|y_{i}=0}S_{i}|=\\sum_{{\\textbf{x}}\\in{\\mathbb{F}_{2}}^{n}}s_{\\textbf{x%&#10;}}|\\cup_{i|x_{i}=1}S_{i}|\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mo>\u2229</mo><mrow><mi>i</mi><mo stretchy=\"false\">|</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc31</mtext><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts></mrow></munder><mrow><msub><mi>s</mi><mtext>\ud835\udc31</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mo>\u222a</mo><mrow><mi>i</mi><mo stretchy=\"false\">|</mo><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for some coefficients $a_{\\textbf{y}}\\in{\\mathbb{F}_2}$. If we let \n", "itemtype": "equation", "pos": -1, "prevtext": " for some integers $s_{\\textbf{x}}$. For instance, $|S_1\\cap S_2| = |S_1| + |S_2| - |S_1\\cup S_2|$. However, since $|\\cup_{i|x_i=1} S_i| = 0\\mod 2$ for any ${\\textbf{x}}$, we have $|\\cap_{i|y_i=0} S_i|=0\\mod 2$, a contradiction. Thus there exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that ${P}_{\\textbf{a}}({\\textbf{x}}) \\neq 0 \\mod 2^k$, as required.\n\n\\end{proof}\n\nWith Lemma~\\ref{lem:idk} we have everything we need to prove Theorem~\\ref{thm:main} below.\n\n\\begin{proof}[Proof of Theorem~\\ref{thm:main}] \\mbox{}\\\\\n\n\\hangindent=0.7cm\n\\noindent ${\\mathcal{RM}}(n-4, n)^*\\subseteq{\\text{Res}}_2({\\mathcal{C}_n})$: \\\\\n\\hspace*{\\parindent} Let ${\\textbf{c}}'$ be in ${\\mathcal{RM}}(n-4,n)^*$. Then \n", "index": 95, "text": "$${\\textbf{c}}'=\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}, {\\text{wt}}({\\textbf{y}})\\leq n-4}a_{\\textbf{y}}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex58.m1\" class=\"ltx_Math\" alttext=\"{\\textbf{c}}^{\\prime}=\\bigoplus_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}%&#10;\\setminus\\{{\\textbf{1}}\\},{\\text{wt}}({\\textbf{y}})\\leq n-4}a_{\\textbf{y}}{{{%&#10;\\boldsymbol{v}}}_{1}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{%&#10;\\boldsymbol{v}}}_{n}^{{y}_{n}}}\" display=\"block\"><mrow><msup><mtext>\ud835\udc1c</mtext><mo>\u2032</mo></msup><mo>=</mo><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>n</mi><mo>-</mo><mn>4</mn></mrow></mrow></mrow></munder><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " then by Lemma~\\ref{lem:codebasis}, ${\\textbf{c}}$ is in ${\\mathcal{C}_n}$. Moreover, ${\\textbf{c}}'={\\text{Res}}_2({\\textbf{c}})$, hence ${\\textbf{c}}'\\in{\\text{Res}}_2({\\mathcal{C}_n})$.\n\\mbox{}\\\\\n\n\\hangindent=0.7cm\n\\noindent ${\\text{Res}}_2({\\mathcal{C}_n})\\subseteq{\\mathcal{RM}}(n-4, n)^*$: \\\\\n\\hspace*{\\parindent} Let ${\\textbf{a}}$ be an element of ${\\mathcal{C}_n}$. By definition of ${\\mathcal{C}_n}$, ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 2^3$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. However, by Lemma~\\ref{lem:idk}, we know there exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that ${P}_{\\textbf{a}}({\\textbf{x}}) \\neq 0\\mod 2^k$ if ${\\textbf{a}}$ has effective degree $n-k$ in the monomial basis -- hence, ${\\textbf{a}}$ can have effective degree at most $n-4$. \\\\\n\\hspace*{\\parindent} Now, suppose ${\\textbf{a}}$ may be written as some sum $\\sum 2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ of effective degree at most $n-4$ -- that is, ${\\text{wt}}({\\textbf{y}})-i \\leq n-4$ for every pair of values ${\\textbf{y}}$ and $i$ in the summation. Then \n", "itemtype": "equation", "pos": -1, "prevtext": " for some coefficients $a_{\\textbf{y}}\\in{\\mathbb{F}_2}$. If we let \n", "index": 97, "text": "$${\\textbf{c}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{1}}\\}, {\\text{wt}}({\\textbf{y}})\\leq n-4}a_{\\textbf{y}}{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex59.m1\" class=\"ltx_Math\" alttext=\"{\\textbf{c}}=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{1}%&#10;}\\},{\\text{wt}}({\\textbf{y}})\\leq n-4}a_{\\textbf{y}}{{{\\boldsymbol{v}}}_{1}^{{%&#10;y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}},\" display=\"block\"><mrow><mrow><mtext>\ud835\udc1c</mtext><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udfcf</mtext><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mtext>wt</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc32</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>n</mi><mo>-</mo><mn>4</mn></mrow></mrow></mrow></munder><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " which has degree at most $n-4$. Hence ${\\text{Res}}_2({\\textbf{a}})\\in{\\mathcal{RM}}(n-4, n)^*$.\n\\end{proof}\n\\section{Generalization}\\label{sec:generalization}\nIn this section we discuss the generalization of Theorem~\\ref{thm:main} to linear phase circuits with smaller angle $Z$ rotations. Specifically, the gate $R_z(\\pi/2^k)$ for any non-negative integer $k$ is defined as \n", "itemtype": "equation", "pos": -1, "prevtext": " then by Lemma~\\ref{lem:codebasis}, ${\\textbf{c}}$ is in ${\\mathcal{C}_n}$. Moreover, ${\\textbf{c}}'={\\text{Res}}_2({\\textbf{c}})$, hence ${\\textbf{c}}'\\in{\\text{Res}}_2({\\mathcal{C}_n})$.\n\\mbox{}\\\\\n\n\\hangindent=0.7cm\n\\noindent ${\\text{Res}}_2({\\mathcal{C}_n})\\subseteq{\\mathcal{RM}}(n-4, n)^*$: \\\\\n\\hspace*{\\parindent} Let ${\\textbf{a}}$ be an element of ${\\mathcal{C}_n}$. By definition of ${\\mathcal{C}_n}$, ${P}_{\\textbf{a}}({\\textbf{x}}) = 0\\mod 2^3$ for all ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$. However, by Lemma~\\ref{lem:idk}, we know there exists ${\\textbf{x}}\\in{\\mathbb{F}_2}^n$ such that ${P}_{\\textbf{a}}({\\textbf{x}}) \\neq 0\\mod 2^k$ if ${\\textbf{a}}$ has effective degree $n-k$ in the monomial basis -- hence, ${\\textbf{a}}$ can have effective degree at most $n-4$. \\\\\n\\hspace*{\\parindent} Now, suppose ${\\textbf{a}}$ may be written as some sum $\\sum 2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$ of effective degree at most $n-4$ -- that is, ${\\text{wt}}({\\textbf{y}})-i \\leq n-4$ for every pair of values ${\\textbf{y}}$ and $i$ in the summation. Then \n", "index": 99, "text": "$${\\text{Res}}_2({\\textbf{a}}) = \\bigoplus_{i=0} 2^i\\cdot{{{\\boldsymbol{v}}}_1^{{y}_1}{{\\boldsymbol{v}}}_2^{{y}_2}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{n}}}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex60.m1\" class=\"ltx_Math\" alttext=\"{\\text{Res}}_{2}({\\textbf{a}})=\\bigoplus_{i=0}2^{i}\\cdot{{{\\boldsymbol{v}}}_{1%&#10;}^{{y}_{1}}{{\\boldsymbol{v}}}_{2}^{{y}_{2}}\\cdots{{\\boldsymbol{v}}}_{n}^{{y}_{%&#10;n}}}\" display=\"block\"><mrow><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc1a</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow></munder><mrow><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>\u22c5</mo><msubsup><mi>\ud835\udc97</mi><mn>1</mn><msub><mi>y</mi><mn>1</mn></msub></msubsup></mrow><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>2</mn><msub><mi>y</mi><mn>2</mn></msub></msubsup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>n</mi><msub><mi>y</mi><mi>n</mi></msub></msubsup></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " We show that the minimal number of $R_z(\\pi/2^k)$ gates required to implement a unitary over $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$ corresponds to a minimum distance decoding in ${\\mathcal{RM}}(n-k-2, n)^*$. Such gates arise, e.g., in Shor's algorithm \\cite{s94} and the Clifford hierarchy \\cite{gc99}. Moreover, researchers have recently developed state distillation techniques for these gates, allowing them to be performed fault tolerantly without approximating them over another gate set \\cite{lc13, dp15}.\n\nWe define ${\\mathcal{P}}_{2^k}(n)$ to be the set of $n$-qubit $\\pi/2^k$ linear phase operators -- that is, $n$-qubit diagonal unitary matrices implementable over $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$. As in the case of $\\pi/4$ linear phase operators, such an operator applies to each basis vector a phase rotation that is a $2^k$th root of unity determined by a linear combination of linear functions of its bits. In particular, for any $U\\in{\\mathcal{P}}_{2^k}$, $U$ has the following affect: \n", "itemtype": "equation", "pos": -1, "prevtext": " which has degree at most $n-4$. Hence ${\\text{Res}}_2({\\textbf{a}})\\in{\\mathcal{RM}}(n-4, n)^*$.\n\\end{proof}\n\\section{Generalization}\\label{sec:generalization}\nIn this section we discuss the generalization of Theorem~\\ref{thm:main} to linear phase circuits with smaller angle $Z$ rotations. Specifically, the gate $R_z(\\pi/2^k)$ for any non-negative integer $k$ is defined as \n", "index": 101, "text": "$$R_z(\\pi/2^k):{|{x}\\rangle}\\mapsto e^{i\\frac\\pi{2^k}x}{|{x}\\rangle}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex61.m1\" class=\"ltx_Math\" alttext=\"R_{z}(\\pi/2^{k}):{|{x}\\rangle}\\mapsto e^{i\\frac{\\pi}{2^{k}}x}{|{x}\\rangle}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>R</mi><mi>z</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>/</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:</mo><mrow><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u21a6</mo><mrow><msup><mi>e</mi><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo>\u2062</mo><mi>x</mi></mrow></msup><mo>\u2062</mo><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " for some coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_{2^k}^{2^n-1}$. As before we call the tuple ${\\textbf{a}}$ an implementation of ${P}$.\n\nIn Section~\\ref{sec:phase}, the canonical circuit for an implementation of a $\\pi/4$ linear phase operator was defined by computing ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ for each nonzero $a_{\\textbf{y}}$, then applying a sequence of $T$, $P$ and $Z$ gates to achieve the correct power of $e^{i\\frac\\pi4}$. We may define the canonical circuit for an implementation of any $\\pi/2^k$ linear phase operator in the same way: compute ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ then apply $R_z(\\pi/2^k)^l$ to achieve the correct power of $e^{i\\frac\\pi{2^k}}$. Under the reasonable assumption that $R(\\pi/2^k)$ gates are more expensive than $R(\\pi/2^{k'})$ gates whenever $k> k'$, we define \n", "itemtype": "equation", "pos": -1, "prevtext": " We show that the minimal number of $R_z(\\pi/2^k)$ gates required to implement a unitary over $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$ corresponds to a minimum distance decoding in ${\\mathcal{RM}}(n-k-2, n)^*$. Such gates arise, e.g., in Shor's algorithm \\cite{s94} and the Clifford hierarchy \\cite{gc99}. Moreover, researchers have recently developed state distillation techniques for these gates, allowing them to be performed fault tolerantly without approximating them over another gate set \\cite{lc13, dp15}.\n\nWe define ${\\mathcal{P}}_{2^k}(n)$ to be the set of $n$-qubit $\\pi/2^k$ linear phase operators -- that is, $n$-qubit diagonal unitary matrices implementable over $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$. As in the case of $\\pi/4$ linear phase operators, such an operator applies to each basis vector a phase rotation that is a $2^k$th root of unity determined by a linear combination of linear functions of its bits. In particular, for any $U\\in{\\mathcal{P}}_{2^k}$, $U$ has the following affect: \n", "index": 103, "text": "$$U:{|{{\\textbf{x}}}\\rangle}\\mapsto e^{i\\frac\\pi{2^k}{P}({\\textbf{x}})}{|{{\\textbf{x}}}\\rangle},\\qquad {P}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_2}^n\\setminus\\{0\\}}a_{\\textbf{y}}\\cdot({{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}})$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex62.m1\" class=\"ltx_Math\" alttext=\"U:{|{{\\textbf{x}}}\\rangle}\\mapsto e^{i\\frac{\\pi}{2^{k}}{P}({\\textbf{x}})}{|{{%&#10;\\textbf{x}}}\\rangle},\\qquad{P}({\\textbf{x}})=\\sum_{{\\textbf{y}}\\in{\\mathbb{F}_%&#10;{2}}^{n}\\setminus\\{0\\}}a_{\\textbf{y}}\\cdot({{y}_{1}{x}_{1}\\oplus{y}_{2}{x}_{2}%&#10;\\oplus\\cdots\\oplus{y}_{n}{x}_{n}})\" display=\"block\"><mrow><mi>U</mi><mo>:</mo><mrow><mrow><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u21a6</mo><mrow><msup><mi>e</mi><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><msup><mn>2</mn><mi>k</mi></msup></mfrac><mo>\u2062</mo><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></msup><mo>\u2062</mo><mrow><mo fence=\"true\" stretchy=\"false\">|</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></mrow><mo rspace=\"22.5pt\">,</mo><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mtext>\ud835\udc32</mtext><mo>\u2208</mo><mrow><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></munder><mrow><msub><mi>a</mi><mtext>\ud835\udc32</mtext></msub><mo>\u22c5</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>\u2295</mo><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>\u2295</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2295</mo><mrow><msub><mi>y</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>x</mi><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " where $l_k\\cdots l_1l_0$ is the binary expansion of $l$. Denoting by ${\\textbf{a}}>\\!\\!\\!>\\!\\!\\!>i$ the component-wise quotient of ${\\textbf{a}}$ divided by $2^i$, we find that the number of $R_z(\\pi/2^l)$ gates in the canonical circuit is ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}>\\!\\!\\!>\\!\\!\\!>(k-l)))$ -- the number of components $a_{\\textbf{y}}$ that have a $1$ in the ($k-l$)th digit of their binary expansion. In particular, the number of $R_z(\\pi/2^k)$ gates is just ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}))$, which as in the case of $\\{{\\text{CNOT}}, T\\}$ circuits may be optimized by finding a minimum distance codeword in the space of all zero-mod-$2^{k+1}$ polynomials,\n\n", "itemtype": "equation", "pos": -1, "prevtext": " for some coefficients ${\\textbf{a}}\\in{\\mathbb{Z}}_{2^k}^{2^n-1}$. As before we call the tuple ${\\textbf{a}}$ an implementation of ${P}$.\n\nIn Section~\\ref{sec:phase}, the canonical circuit for an implementation of a $\\pi/4$ linear phase operator was defined by computing ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ for each nonzero $a_{\\textbf{y}}$, then applying a sequence of $T$, $P$ and $Z$ gates to achieve the correct power of $e^{i\\frac\\pi4}$. We may define the canonical circuit for an implementation of any $\\pi/2^k$ linear phase operator in the same way: compute ${{y}_1{x}_1\\oplus{y}_2{x}_2\\oplus\\cdots\\oplus{y}_{n}{x}_{n}}$ then apply $R_z(\\pi/2^k)^l$ to achieve the correct power of $e^{i\\frac\\pi{2^k}}$. Under the reasonable assumption that $R(\\pi/2^k)$ gates are more expensive than $R(\\pi/2^{k'})$ gates whenever $k> k'$, we define \n", "index": 105, "text": "$$R_z(\\pi/2^k)^l:=R_z(\\pi)^{l_k}\\cdots R_z(\\pi/2^{l-1})^{l_1}R_z(\\pi/2^k)^{l_0}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex63.m1\" class=\"ltx_Math\" alttext=\"R_{z}(\\pi/2^{k})^{l}:=R_{z}(\\pi)^{l_{k}}\\cdots R_{z}(\\pi/2^{l-1})^{l_{1}}R_{z}%&#10;(\\pi/2^{k})^{l_{0}}\" display=\"block\"><mrow><mrow><msub><mi>R</mi><mi>z</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>/</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow><mi>l</mi></msup></mrow><mo>:=</mo><mrow><msub><mi>R</mi><mi>z</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mi>\u03c0</mi><mo stretchy=\"false\">)</mo></mrow><msub><mi>l</mi><mi>k</mi></msub></msup><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>R</mi><mi>z</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>/</mo><msup><mn>2</mn><mrow><mi>l</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow><msub><mi>l</mi><mn>1</mn></msub></msup><mo>\u2062</mo><msub><mi>R</mi><mi>z</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>/</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow><msub><mi>l</mi><mn>0</mn></msub></msup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": " It turns out that this residue is in fact the order $n-k-2$, length $2^n-1$ punctured Reed-Muller code\\footnote{Note that using Definition~\\ref{def:rm}, the Reed-Muller code ${\\mathcal{RM}}(r, n)$ is well defined for $r<0$. In particular, the code is the trivial code $\\{{\\textbf{0}}\\}$, corresponding to the fact that no non-trivial zero phase polynomials exist mod $2^k$ when $k<n-1$.}, ${\\mathcal{RM}}(n-k-2, n)^*$.\n\n\\begin{theorem}\\label{thm:main2}\n\n", "itemtype": "equation", "pos": -1, "prevtext": " where $l_k\\cdots l_1l_0$ is the binary expansion of $l$. Denoting by ${\\textbf{a}}>\\!\\!\\!>\\!\\!\\!>i$ the component-wise quotient of ${\\textbf{a}}$ divided by $2^i$, we find that the number of $R_z(\\pi/2^l)$ gates in the canonical circuit is ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}>\\!\\!\\!>\\!\\!\\!>(k-l)))$ -- the number of components $a_{\\textbf{y}}$ that have a $1$ in the ($k-l$)th digit of their binary expansion. In particular, the number of $R_z(\\pi/2^k)$ gates is just ${\\text{wt}}({\\text{Res}}_2({\\textbf{a}}))$, which as in the case of $\\{{\\text{CNOT}}, T\\}$ circuits may be optimized by finding a minimum distance codeword in the space of all zero-mod-$2^{k+1}$ polynomials,\n\n", "index": 107, "text": "$${\\mathcal{C}_n}^k=\\{{\\textbf{c}}\\in{\\mathbb{Z}}_{2^{k+1}}^{2^n-1}|{P}_{\\textbf{c}}({\\textbf{x}}) = 0\\mod 2^{k+1}\\}\\text{ for all }{\\textbf{x}}\\in{\\mathbb{F}_2}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex64.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{C}_{n}}^{k}=\\{{\\textbf{c}}\\in{\\mathbb{Z}}_{2^{k+1}}^{2^{n}-1}|{P}_{%&#10;\\textbf{c}}({\\textbf{x}})=0\\mod 2^{k+1}\\}\\text{ for all }{\\textbf{x}}\\in{%&#10;\\mathbb{F}_{2}}^{{n}}\\setminus\\{{\\textbf{0}}\\}\\}.\" display=\"block\"><mrow><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>n</mi><none/><none/><mi>k</mi></mmultiscripts><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mtext>\ud835\udc1c</mtext><mo>\u2208</mo><msubsup><mi>\u2124</mi><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">|</mo><msub><mi>P</mi><mtext>\ud835\udc1c</mtext></msub><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mn>0</mn><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">}</mo></mrow><mrow><mtext>\u00a0for all\u00a0</mtext><mtext>\ud835\udc31</mtext></mrow><mo>\u2208</mo><mmultiscripts><mi>\ud835\udd3d</mi><mn>2</mn><none/><none/><mi>n</mi></mmultiscripts><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mtext/><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07363.tex", "nexttext": "\n\\end{theorem}\n\nWe do not give a formal proof of Theorem~\\ref{thm:main2}, but note that the proof of Theorem~\\ref{thm:main} suffices with a few simple modifications. In particular, rather than a vector over ${\\mathbb{Z}}_8$ we have a vector over ${\\mathbb{Z}}_{2^{k+1}}$ and the phase polynomial ${P}_{\\textbf{a}}$ is evaluated over ${\\mathbb{Z}}_{2^{k+1}}$.\n\nAs a natural consequence of Theorem~\\ref{thm:main2}, the number of rotation gates of any angle $\\pi/2^l$ for $l\\leq k$ may be reduced by decoding ${\\text{Res}}_2({\\textbf{a}}>\\!\\!\\!>\\!\\!\\!> (k-l))$ in the code ${\\text{Res}}_2({\\mathcal{C}_n}^l)={\\mathcal{RM}}(n-l-2, n)$ and adding the decoded tuple back into ${\\textbf{a}}$ (multiplied by the appropriate power of $2$). Such procedures may be a valuable tool for quantum circuits utilizing progressively finer grain $Z$ rotations, such as Shor's algorithm \\cite{s94}, either to be later approximated by Clifford+$T$ gates or to be performed directly using state distillation. One potential issue with this method is reducing the number of $R_z(\\pi/2^l)$ may increase the number of $R_z(\\pi/2^{l'})$ gates for any $l'<l$, as seen in Example~\\ref{ex:opt}. In most cases smaller angles of rotation are more costly so this is a reasonable trade off, but we leave it as an open question to find a general algorithm for optimizing the total cost of all rotation gates in a $\\{{\\text{CNOT}}, R_z(\\pi/2^k)\\}$ circuit.\n\n\\section{Experiments}\\label{sec:experiments}\n\nWe implemented Algorithm~\\ref{alg:cnott} in $T$-par \\cite{tpar} as an optimization pass in the resynthesis procedure. $T$-par optimizes circuits over the Clifford+$T$ gate set by computing a representation using exponential sums, then resynthesizing. As our algorithm presently applies to ${\\text{CNOT}}$ and phase gates, we break up the input circuit into $\\{{\\text{CNOT}}, T\\}$ subcircuits, each of which is then optimized individually.\n\nWe implemented and tested the algorithm with two Reed-Muller decoders -- the original majority logic decoder ~\\cite{r54} due to Reed, and a modern recursive decoder ~\\cite{d04} due to Dumer. The former has complexity in $O(2^{2n})$ for an $n$-qubit circuit while the latter has a significantly lower complexity of $O(2^n)$. While both of these algorithms are exponential in the number of qubits $n$, we nonetheless obtain reasonable performance for large circuits by storing and operating directly on compressed vector representations. In order to optimize these large circuits we chose relatively fast decoders over minimum-distance decoders.\n\n\\subsection{Evaluation}\n\nAlgorithm~\\ref{alg:cnott} was evaluated on a suite of benchmark quantum circuits, drawn from the literature and the Reversible Logic Benchmarks page \\cite{m11}. The majority of circuits tested are reversible circuits, though some specifically quantum circuits were also examined. Toffoli gates were replaced with a Clifford+$T$ implementation using $7$ $T$-gates \\cite{ammr13}, and multiple control Toffolis were expanded into two-control Toffoli gates using one zero initialized ancilla (see, e.g., \\cite{nc00}).\n\n\\begin{table}\n\\scriptsize\n\\begin{tabular}{|l||c||cccc|} \\hline\nBenchmark & $n$ & $T$-count (original) & $T$-count ($T$-par) & $T$-count (majority) & $T$-count (recursive) \\\\ \\hline\\hline\nGrover$_5$ \\cite{g96}\\footnotemark & 9 & 140 & 52 & 52 & 52 \\\\ \\hline\nMod 5$_{4}$ \\cite{m11} & 5 & 28 & 16 & 16 & 16 \\\\ \\hline\nVBE-Adder$_{3}$ \\cite{vbe96} & 10 & 70 & 24 & 24 & 24 \\\\ \\hline\nCSLA-MUX$_{3}$ \\cite{vi05} & 15 & 70 & 62 & 62 & 58 \\\\\nCSUM-MUX$_{9}$ \\cite{vi05} & 30 & 196 & 140 & 84 & 76 \\\\ \\hline\nQCLA-Com$_{7}$ \\cite{dkrs06} & 24 & 203 & 95 & 94 & 153 \\\\\nQCLA-Mod$_{7}$ \\cite{dkrs06} & 26 & 413 & 249 & 238 & 299 \\\\\nQCLA-Adder$_{10}$ \\cite{dkrs06} & 36 & 238 & 162 & -- & 188 \\\\ \\hline\nAdder$_{8}$ \\cite{ttk10}& 24 & 399 & 215 & 213 & 249 \\\\ \\hline\nRC-Adder$_{6}$ \\cite{cdkp04}& 14 & 77 & 63 & 47 & 47 \\\\ \\hline\nMod-Red$_{21}$ \\cite{ms12}& 11 & 119 & 73 & 73 & 73 \\\\\nMod-Mult$_{55}$ \\cite{ms12} & 9 & 49 & 37 & 35 & 35 \\\\ \\hline\nMod-Adder$_{1024}$ \\cite{m11} & 28 & 1995 & 1011 & 1011 & 1011 \\\\ \\hline\nBCSD$_2$ \\cite{f13} & 9 & 14 & 14 & 2 & 2 \\\\\nBCSD$_4$ \\cite{f13} & 14 & 20 & 20 & 4 & 4 \\\\\nBCSD$_8$ \\cite{f13} & 21 & 32 & 32 & 8 & 8 \\\\ \\hline\nCycle $17\\_3$ \\cite{m11}& 35 & 4739 & 1945 & 1944 & 1982 \\\\ \\hline\nGF($2^4$)-Mult \\cite{mmcp09} & 12 & 112 & 68 & 68 & 68 \\\\\nGF($2^5$)-Mult \\cite{mmcp09} & 15 & 175 & 111 & 111 & 101 \\\\\nGF($2^6$)-Mult \\cite{mmcp09} & 18 & 252 & 150 & 150 & 144 \\\\\nGF($2^7$)-Mult \\cite{mmcp09} & 21 & 343 & 217 & 217 & 208 \\\\\nGF($2^8$)-Mult \\cite{mmcp09} & 24 & 448 & 264 & 264 & 237 \\\\\nGF($2^9$)-Mult \\cite{mmcp09} & 27 & 567 & 351 & -- & 301 \\\\\nGF($2^{10}$)-Mult \\cite{mmcp09} & 30 & 700 & 410 & -- & 410 \\\\\nGF($2^{16}$)-Mult \\cite{mmcp09} & 48 & 1792 & 1040 & -- & --  \\\\ \nGF($2^{32}$)-Mult \\cite{mmcp09} & 96 & 7168 & 4128 & -- & --  \\\\ \\hline\nHamming$_{15}$ (low)  \\cite{m11} & 17 & 161 & 97 & 97 & 97 \\\\\nHamming$_{15}$ (med)  \\cite{m11} & 17 & 574 & 230 & 230 & 230 \\\\\nHamming$_{15}$ (high)  \\cite{m11} & 20 & 2457 & 1019 & 1019 & 1019 \\\\ \\hline\nHWB$_6$  \\cite{m11} & 7 & 105 & 71 & 75 & 75 \\\\\nHWB$_8$  \\cite{m11} & 12 & 5887 & 3551 & 3531 & 3531 \\\\ \\hline\n$n$th-prime$_6$ \\cite{m11} & 9 & 812 & 402 & 400 & 400 \\\\\n$n$th-prime$_8$ \\cite{m11} & 12 & 6671 & 4047 & 4045 & 4045 \\\\ \\hline\nQFT$_4$ \\cite{nc00} & 5 & 69 & 67 & 67 & 67 \\\\ \\hline\n$\\Lambda_3(X)$ -- \\cite{bbcdmsssw95} & 5 & 28 & 16 & 16 & 16 \\\\\n\\hspace{3.05em} -- \\cite{nc00} & 5 & 21 & 15 & 15 & 15 \\\\\n$\\Lambda_4(X)$ -- \\cite{bbcdmsssw95} & 7 & 56 & 28 & 28 & 28 \\\\\n\\hspace{3.05em} -- \\cite{nc00} & 7 & 35 & 23 & 23 & 23 \\\\\n$\\Lambda_5(X)$ -- \\cite{bbcdmsssw95} & 9 & 84 & 40 & 40 & 40 \\\\\n\\hspace{3.05em} -- \\cite{nc00} & 9 & 49 & 31 & 31 & 31 \\\\\n$\\Lambda_{10}(X)$ -- \\cite{bbcdmsssw95} & 19 & 224 & 100 & 100 & 100 \\\\\n\\hspace{3.05em} -- \\cite{nc00} & 19 & 119 & 71 & 71 & 71 \\\\ \\hline\n\\end{tabular}\n\\caption{$T$-count optimization results. $n$ reports the number of qubits in the circuit. $T$-counts are recorded for the original circuit, after optimization by $T$-par, and after optimization by Algorithm~\\ref{alg:cnott} with either the majority logic or recursive decoder.}\\label{tab:results}\n\\end{table}\\footnotetext{Grover's search is performed with 4 iterations using the oracle $f(\\vec{x})=\\neg x_1\\land \\neg x_2\\land x_3\\land x_4\\land\\neg x_5$.}\n\nTable~\\ref{tab:results} reports the $T$-count of circuits optimized with both $T$-par alone, and with Algorithm~\\ref{alg:cnott} using either the majority logic or recursive decoder applied to $\\{{\\text{CNOT}}, T\\}$ subcircuits. All experiments were run on with a 2.4GHz quad-core Intel Core i7 processor running Linux and 8GB of RAM. Each benchmark had a timeout of 30 minutes -- instances where the algorithm failed to report a result within the timeout are identified with a dash.\n\nOn average, Algorithm~\\ref{alg:cnott} reduced $T$-count by 6\\% for both the majority logic decoder and the recursive decoder compared to $T$-par. While the recursive decoder produced the best results in some cases, notably the GF multipliers, and failed less often, for many benchmarks it reported significantly \\emph{increased} $T$-counts compared to $T$-par. Majority logic decoding by comparison typically produced less $T$-reduction, though it consistently resulted in circuits with equal or lesser $T$-count than that reported by $T$-par. Counter-intuitively this appears to result from the recursive decoder actually doing a \\emph{better} job optimizing $T$-count -- after the recursive decoder performs significant rewrites on individual $\\{{\\text{CNOT}}, T\\}$ subcircuits, $T$-par has less opportunity to optimize $T$-gates across subcircuit boundaries. A natural direction of future research is to extend decoding-based optimization to $\\{H, {\\text{CNOT}}, T\\}$ circuits in order to make use of the additional $T$-count reductions possible across subcircuit boundaries.\n\nWhile the $T$-count reductions over $T$-par are minor compared to the initial jump from the original $T$-count, the results clearly demonstrate that further $T$-count optimization beyond the $T$-par algorithm is possible. In the most significant case, a $T$-count reduction of 75\\% was reported for the benchmark BCSD$_8$ with both decoders. Note that it may be possible to achieve better $T$-count with other Reed-Muller decoders as well. We leave exploration of effective Reed-Muller decoders as an avenue for future work.\n\nAs an additional note, while we don't consider $T$-depth optimization in this paper, reductions to $T$-count in some benchmarks allow further reductions to $T$-depth using matroid partitioning. In the extreme case, $T$-depth in CSUM-MUX$_9$ was reduced from 11 to 6 using the recursive decoder, providing strong evidence that reducing $T$-count is an effective means of optimizing $T$-depth.\n\n\\section*{Acknowledgments}\n\nMatthew Amy is supported in part by the Natural Sciences and Engineering Research\nCouncil of Canada. Michele Mosca is supported by Canada's NSERC, MPrime, CIFAR, and CFI. IQC and Perimeter Institute are supported in part by the Government of Canada and the Province of Ontario.\n\n\\vspace{-0.5em}\n\n\n\n\n\n\\bibliography{paper}\n\n\n", "itemtype": "equation", "pos": 73660, "prevtext": " It turns out that this residue is in fact the order $n-k-2$, length $2^n-1$ punctured Reed-Muller code\\footnote{Note that using Definition~\\ref{def:rm}, the Reed-Muller code ${\\mathcal{RM}}(r, n)$ is well defined for $r<0$. In particular, the code is the trivial code $\\{{\\textbf{0}}\\}$, corresponding to the fact that no non-trivial zero phase polynomials exist mod $2^k$ when $k<n-1$.}, ${\\mathcal{RM}}(n-k-2, n)^*$.\n\n\\begin{theorem}\\label{thm:main2}\n\n", "index": 109, "text": "$${\\mathcal{RM}}(n-k-2, n)^*={\\text{Res}}_2({\\mathcal{C}_n}^k)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex65.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{RM}}(n-k-2,n)^{*}={\\text{Res}}_{2}({\\mathcal{C}_{n}}^{k})\" display=\"block\"><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>\u2062</mo><mi class=\"ltx_font_mathcaligraphic\">\u2133</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mi>k</mi><mo>-</mo><mn>2</mn></mrow><mo>,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>*</mo></msup></mrow><mo>=</mo><mrow><msub><mtext>Res</mtext><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>n</mi><none/><none/><mi>k</mi></mmultiscripts><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}]