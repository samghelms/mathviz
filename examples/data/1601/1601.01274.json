[{"file": "1601.01274.tex", "nexttext": "\nwhere ${\\wedge}$ is the regular exclusive or operation (xor).\n\n\nLet $(a_1a_2 \\cdots a_k)_{d}$ represent a number system, where $ 0 \\le\na_i < d (1 \\le i \\le k)$, and $k$ can be any positive integer.\nThe number is binary number for $d=2$, and decimal number for\n$d=10$. For any non-negative integer $j$, where $j = (a_1a_2\\cdots a_k)_2$,\n$Re_k$ is defined as\n\n", "itemtype": "equation", "pos": 5804, "prevtext": "\n\\title{Encoding and Decoding Algorithms for Arbitrary Dimensional Hilbert Order}\n\\author{Hui Liu, Tao Cui, Wei Leng and Linbo Zhang}\n\\date{}\n\\maketitle\n\n\\begin{abstract}\nHilbert order is widely applied in many areas. However, most of the algorithms are confined to low\ndimensional cases. In this paper, algorithms for encoding and decoding arbitrary dimensional\nHilbert order are presented. Eight algorithms are proposed. Four algorithms are based on arithmetic operations\nand the other four algorithms are based on bit operations. For the algorithms complexities, four of them are\nlinear and the other four are constant for given inputs. In the end of the paper, algorithms for two\ndimensional Hilbert order are presented to demonstrate the usage of the algorithms introduced.\\bigskip\n\\end{abstract}\n\n\\section{Introduction}\n\nSpace-filling curves were proposed by Peano in 1890 and popularized\nby Hilbert later. These curves introduce maps between one dimensional domain and multiple dimensional domain,\nwhich also introduce order when considering in one dimensional space.\nHilbert space-filling curve is one famous space-filling curve, which is also called Hilbert\ncurve. This kind of curve has many important characteristics, such as locality,\nclustering and self-similarity. Hilbert curve (order) has been applied in many areas,\nincluding image storing, database indexing, data compression and dynamic load balancing.\nFor parallel computing, Hilbert order method is one of the most important\ngeometry-based partitioning methods, which was implemented by the Zoltan \\cite{Zoltan}, one of the most\nwell-known dynamic load balancing package developed by Sandia National Laboratories. It was also implemented\nby PHG (Parallel Hierarchical Grid) \\cite{phg}, and it serves as the default dynamic load balancing strategy.\nThe Hilbert order now are widely applied by many parallel applications \\cite{sfc-tr-03, hliu}.\nDetails of space-filling curves can be found in \\cite{Hans}.\n\nA $n$-dimensional Hilbert curve introduces a one-to-one mapping between $n$-dimensional space and one-dimensional space.\nThe mapping from $n$-dimensional space to one-dimensional space is called encoding, while the inverse mapping is called decoding, which maps an integer to a coordinate in $n$-dimensional space.\nAlgorithms for computing Hilbert curve/order in two and three dimensional spaces have been proposed in\nmany literatures, which can be classified into recursive algorithms\n\\cite{butz, gold, witten, cole} and iterative algorithms \\cite{griff, sfc-tr-03, xliu2, xliu, fisher, ningtao}.\nIterative algorithms, especially the table-driven algorithms \\cite{griff,\nsfc-tr-03}, are usually much faster than recursive algorithms. In general, the complexities of these algorithms are $O(m)$, where $m$ is\nthe level of the Hilbert curve. For two dimensional space, Chen \\emph{et al} \\cite{ningtao} proposed an algorithm of $O(r)$ complexity,\nwhere $r$ is defined as $r=\\log_2(\\max(x,y))+1$, $r \\le m$ and is independent of the level $m$.\nThe algorithm is faster when $m$ is much larger than $r$. The same idea was also applied to three dimensional space \\cite{hliu}.\nFor higher dimensional spaces, relative little work has been done due to the complexity of\nHilbert curve. Recently, Kamata \\textit{et al} presented a representative $n$-dimensional Hilbert mapping algorithm\n\\cite{kamata} and Li \\textit{et al} introduced algorithms for analyzing the properties of\n$n$-dimensional Hilbert curve \\cite{chenyang}.\n\nIn this paper, we present our work on developing algorithms for encoding and decoding arbitrary high dimensional\nHilbert order bases on \\cite{chenyang}, and the authors introduced novel algorithms for\nanalyzing evolutive rules for high dimensional Hilbert curve. However, the decoding and encoding algorithms\nfor high dimensional spaces are still open problems.\nHere the rules are studied firstly and some properties are deduced. Then the encoding and decoding algorithms\nare proposed based on the properties deduced.\nFor the encoding problems, four algorithms are presented. Two algorithms are based on arithmetic operations,\nwhich can be translated to bit operations naturally. Then two bit operation based algorithms are obtained.\nThe decoding processes are reverse processes of encoding, thus decoding algorithms are obtained similarly.\nFour of our eight algorithms have linear complexity, O(m), where $m$ is the level of Hilbert order. The other\nfour algorithms have constant complexity for given inputs. In the end of the paper, the algorithms\nare demonstrated in two dimensional space, and the results are discussed.\n\nThe layout of the paper is as follows. In \\S \\ref{sec-pre}, background and some notations are\nintroduced firstly and then algorithms proposed in \\cite{chenyang} are analyzed in detail.\nIn \\S \\ref{sec-alg}, encoding and decoding algorithms are proposed.\nIn \\S \\ref{sec-dis}, a two dimensional case is employed to\nillustrate our algorithms, and numerical experiments are performed to show the difference between\nlinear complexity algorithm and constant complexity algorithm.\n\n\n\\section{Preliminary}\n\\label{sec-pre}\n\nNotations are introduced and then the algorithms proposed in \\cite{chenyang} are studied in detail.\nWe should mention that all operations in this paper are performed on non-negative integers.\n\n\\subsection{Notations}\nLet $n \\ (n \\ge 2)$ be the dimension of Hilbert curve\nand $m$ be the level of Hilbert curve. Let $D_m$ be the coordinate set of the $m$-th level Hilbert curve, which\nis defined as $D_{m}= \\{(x_n,\\cdots, x_2, x_1)| 0 \\le x_i < 2^{m}, 1\n\\le i \\le n\\}$. $(x_n, \\cdots, x_1) (\\in D_m)$ is a coordinate of the Hilbert curve, and $x_i ( 1 \\le i \\le n)$ is\ncalled the $i$-th component of the coordinate. Logical operation $\\wedge$ for two coordinates is defined as\n\n", "index": 1, "text": "\\begin{equation}\n(x_n, \\cdots, x_2, x_1)\\wedge (y_n, \\cdots, y_2, y_1) = (x_n\\wedge\ny_n, \\cdots, x_2\\wedge y_2, x_1\\wedge y_1),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"(x_{n},\\cdots,x_{2},x_{1})\\wedge(y_{n},\\cdots,y_{2},y_{1})=(x_{n}\\wedge y_{n},%&#10;\\cdots,x_{2}\\wedge y_{2},x_{1}\\wedge y_{1}),\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mi>n</mi></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2227</mo><msub><mi>y</mi><mi>n</mi></msub></mrow><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><mo>,</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\nThe and, right and left shift operators are also introduced for\nthe case that $d$ equals to two, denoted by $\\&$, $\\gg$ and $\\ll$, respectively.\nLet us define,\n\n", "itemtype": "equation", "pos": 6304, "prevtext": "\nwhere ${\\wedge}$ is the regular exclusive or operation (xor).\n\n\nLet $(a_1a_2 \\cdots a_k)_{d}$ represent a number system, where $ 0 \\le\na_i < d (1 \\le i \\le k)$, and $k$ can be any positive integer.\nThe number is binary number for $d=2$, and decimal number for\n$d=10$. For any non-negative integer $j$, where $j = (a_1a_2\\cdots a_k)_2$,\n$Re_k$ is defined as\n\n", "index": 3, "text": "\\begin{equation}\nRe_k(j) = Re_k((a_1a_2\\cdots a_k)_2) = (b_1b_2\\cdots b_k)_2, b_i = 1\n- a_i, 1 \\le i \\le k.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"Re_{k}(j)=Re_{k}((a_{1}a_{2}\\cdots a_{k})_{2})=(b_{1}b_{2}\\cdots b_{k})_{2},b_%&#10;{i}=1-a_{i},1\\leq i\\leq k.\" display=\"block\"><mrow><mrow><mrow><mrow><mi>R</mi><mo>\u2062</mo><msub><mi>e</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>R</mi><mo>\u2062</mo><msub><mi>e</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>a</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>b</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub></mrow><mo>,</mo><mrow><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>-</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></mrow><mo>,</mo><mrow><mn>1</mn><mo>\u2264</mo><mi>i</mi><mo>\u2264</mo><mi>k</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\nwhere $ a_i$ equals to 0 or 1$(1 \\le i \\le n)$. The $p_n^{i}(a_1,a_2, \\cdots, a_n)$ equals to 1 or 0.\nWith the help of $p_i$, the function $f_n$ is defined as\n\n", "itemtype": "equation", "pos": 6587, "prevtext": "\nThe and, right and left shift operators are also introduced for\nthe case that $d$ equals to two, denoted by $\\&$, $\\gg$ and $\\ll$, respectively.\nLet us define,\n\n", "index": 5, "text": "\\begin{equation}\np_n^{i}(a_1,a_2, \\cdots, a_n) = (\\sum\\limits_{j = 1}^i {a_i}) ~mod~ 2 = (\\sum\\limits_{j = 1}^i {a_i}) ~\\%~ 2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"p_{n}^{i}(a_{1},a_{2},\\cdots,a_{n})=(\\sum\\limits_{j=1}^{i}{a_{i}})~{}mod~{}2=(%&#10;\\sum\\limits_{j=1}^{i}{a_{i}})~{}\\%~{}2,\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>p</mi><mi>n</mi><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mi>d</mi></mpadded><mo>\u2062</mo><mn>2</mn></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><msub><mi>a</mi><mi>i</mi></msub></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow><mo lspace=\"0pt\" rspace=\"3.5pt\">%</mo></mrow><mo>\u2062</mo><mn>2</mn></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\nwhere $a_i$ equals to 0 or 1 and $j$ is a decimal number. The\nfunction $f_n$ maps a vector $(a_1, a_2, \\cdots, a_n)$ to a decimal number $j$.\nIts inverse function $b_n$ is defined as\n\n", "itemtype": "equation", "pos": 6888, "prevtext": "\nwhere $ a_i$ equals to 0 or 1$(1 \\le i \\le n)$. The $p_n^{i}(a_1,a_2, \\cdots, a_n)$ equals to 1 or 0.\nWith the help of $p_i$, the function $f_n$ is defined as\n\n", "index": 7, "text": "\\begin{equation}\n\\label{forward} f_n(a_1,a_2, \\cdots ,a_n) = (b_1b_2\\cdots b_n)_2 =\nj, b_1 = a_1, b_i =\\left\\{\\begin{array}{rl}\na_i, ~if ~p_n^{i-1} = 0  \\\\\n1 - a_i,~if ~p_n^{i - 1} = 1\n\\end{array}\\right. ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"f_{n}(a_{1},a_{2},\\cdots,a_{n})=(b_{1}b_{2}\\cdots b_{n})_{2}=j,b_{1}=a_{1},b_{%&#10;i}=\\left\\{\\begin{array}[]{rl}a_{i},~{}if~{}p_{n}^{i-1}=0\\\\&#10;1-a_{i},~{}if~{}p_{n}^{i-1}=1\\end{array}\\right.,\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>b</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo>=</mo><mi>j</mi></mrow><mo>,</mo><mrow><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mrow><msub><mi>a</mi><mi>i</mi></msub><mo rspace=\"5.8pt\">,</mo><mrow><mi>i</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mi>f</mi></mpadded><mo>\u2062</mo><msubsup><mi>p</mi><mi>n</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></mrow><mo>=</mo><mn>0</mn></mrow></mtd><mtd/></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mn>1</mn><mo>-</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo rspace=\"5.8pt\">,</mo><mrow><mi>i</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mi>f</mi></mpadded><mo>\u2062</mo><msubsup><mi>p</mi><mi>n</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></mrow><mo>=</mo><mn>1</mn></mrow></mtd><mtd/></mtr></mtable><mi/></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\nwhere $j (0 \\le j < 2^n)$ is a decimal number and $j = (a_1a_2 \\cdots a_n)_2$.\nThe function maps a decimal number (scalar) to a vector.\n\n\\textbf{\\emph{Remarks.}} In practice, for a fixed value $n$, $b_n$ and\n$f_n$ can be calculated aforehand and saved in tables, and this\ntechnique would speed up programs. $b_n$ can also be calculated in the\nfollowing way\n\n", "itemtype": "equation", "pos": 7292, "prevtext": "\nwhere $a_i$ equals to 0 or 1 and $j$ is a decimal number. The\nfunction $f_n$ maps a vector $(a_1, a_2, \\cdots, a_n)$ to a decimal number $j$.\nIts inverse function $b_n$ is defined as\n\n", "index": 9, "text": "\\begin{equation}\n\\label{backward} b_n(j) = b_n((a_1a_2 \\cdots a_n)_2) =\n(b_1,b_2,\\cdots,b_n), b_1 = a_1, b_i =\\left\\{\\begin{array}{rl}\na_i, ~if ~a_{i-1} = 0  \\\\\n1 - a_i,~if ~a_{i - 1} = 1\n\\end{array}\\right. ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"b_{n}(j)=b_{n}((a_{1}a_{2}\\cdots a_{n})_{2})=(b_{1},b_{2},\\cdots,b_{n}),b_{1}=%&#10;a_{1},b_{i}=\\left\\{\\begin{array}[]{rl}a_{i},~{}if~{}a_{i-1}=0\\\\&#10;1-a_{i},~{}if~{}a_{i-1}=1\\end{array}\\right.,\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>a</mi><mn>2</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mrow><msub><mi>a</mi><mi>i</mi></msub><mo rspace=\"5.8pt\">,</mo><mrow><mi>i</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mi>f</mi></mpadded><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mrow><mo>=</mo><mn>0</mn></mrow></mtd><mtd/></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mn>1</mn><mo>-</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo rspace=\"5.8pt\">,</mo><mrow><mi>i</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mi>f</mi></mpadded><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mrow><mo>=</mo><mn>1</mn></mrow></mtd><mtd/></mtr></mtable><mi/></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\n\nFor the sake of completeness, concepts introduced in~\\cite{chenyang} are borrowed here. An\n$n$-dimensional Hilbert cell is a $1$-th level $n$-dimensional Hilbert curve. The $n$-dimensional Hilbert gene is a list of\ncoordinate transformation commands, which direct the generation of the $m$-th level Hilbert curve from $(m-1)$-th level Hilbert curve. The\ncoordinate transformation commands include two types: exchange\ncommand and reverse command. These commands can be interpreted as reflection from some hyperplane, which\nwill be presented in the next section.\nThe Hilbert curve has direction, which has an entry and an exit. When the transformation commands are performed, the\ncoordinates of entry and exit may be changed. In \\cite{chenyang}, $H_n^{i,0}$ and $H_n^{i, 1}$, where $ 0 \\le i < 2^n$, were introduced\nto represent the entry and exit for quadrant $i$. Algorithms were also\nproposed to generate entry, exit and Hilbert gene list. Details can be found in \\cite{chenyang}.\n\n\\subsection{Study of Evolutive Rules}\nNow we analyze the properties of algorithms developed in \\cite{chenyang}.\nHilbert cell was generated in recursively in \\cite{chenyang}, in which if we wanted to\ngenerate $n$ dimensional Hilbert cell,\nthe $n-1$ dimensional Hilbert cell should be generated aforehand.\nBy using the function $b_n$ instead, the $n$ dimensional Hilbert cell can be generated directly.\n\nThe Hilbert gene list \\cite{chenyang} includes two types of commands: exchange command\nand reverse command. Using mathematical techniques developed in this paper, each command can be\ninterpreted as reflection from some hyperplane. For exchange command, if the command is\nperformed between $x_i$ and $x_j$ $(i \\ne j)$, the\nhyperplane is $x_i - x_j = 0$, which means, for a point $P$, $(x_n, \\cdots, x_i, \\cdots, x_j,\\cdots, x_1)$,\nthe coordinate of the new point $P'$ is $(x_n, \\cdots, x_j, \\cdots, x_i,\\cdots, x_1)$.\nThis command just swaps $x_i$ and $x_j$. For reverse command, if the command is performed on\nthe $i$-th position, and if\nthe current level of Hilbert curve is $m$, the hyperplane is $x_i = \\frac{2^m - 1}{2}$,\nwhich means for any point $P$, $(x_n, \\cdots, x_i, \\cdots,\nx_1)$, the coordinate of the new point $P'$ is $(x_n, \\cdots, 2^m - 1 - x_i, \\cdots, x_1)$. Here $(2^m - 1 - x_i)$ equals to $Re_m(x_i)$.\nThe reverse command changes $x_i$ only.\n\nThe algorithms which generateed gene list \\cite{chenyang} can be rewritten as\n\n", "itemtype": "equation", "pos": 7873, "prevtext": "\nwhere $j (0 \\le j < 2^n)$ is a decimal number and $j = (a_1a_2 \\cdots a_n)_2$.\nThe function maps a decimal number (scalar) to a vector.\n\n\\textbf{\\emph{Remarks.}} In practice, for a fixed value $n$, $b_n$ and\n$f_n$ can be calculated aforehand and saved in tables, and this\ntechnique would speed up programs. $b_n$ can also be calculated in the\nfollowing way\n\n", "index": 11, "text": "\\begin{equation}\nb_n((a_1\\cdots a_n)_2) = (a_1,\\cdots, a_n) \\wedge  (0,a_1,\\cdots,\na_{n-1}).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"b_{n}((a_{1}\\cdots a_{n})_{2})=(a_{1},\\cdots,a_{n})\\wedge(0,a_{1},\\cdots,a_{n-%&#10;1}).\" display=\"block\"><mrow><mrow><mrow><msub><mi>b</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 10409, "prevtext": "\n\nFor the sake of completeness, concepts introduced in~\\cite{chenyang} are borrowed here. An\n$n$-dimensional Hilbert cell is a $1$-th level $n$-dimensional Hilbert curve. The $n$-dimensional Hilbert gene is a list of\ncoordinate transformation commands, which direct the generation of the $m$-th level Hilbert curve from $(m-1)$-th level Hilbert curve. The\ncoordinate transformation commands include two types: exchange\ncommand and reverse command. These commands can be interpreted as reflection from some hyperplane, which\nwill be presented in the next section.\nThe Hilbert curve has direction, which has an entry and an exit. When the transformation commands are performed, the\ncoordinates of entry and exit may be changed. In \\cite{chenyang}, $H_n^{i,0}$ and $H_n^{i, 1}$, where $ 0 \\le i < 2^n$, were introduced\nto represent the entry and exit for quadrant $i$. Algorithms were also\nproposed to generate entry, exit and Hilbert gene list. Details can be found in \\cite{chenyang}.\n\n\\subsection{Study of Evolutive Rules}\nNow we analyze the properties of algorithms developed in \\cite{chenyang}.\nHilbert cell was generated in recursively in \\cite{chenyang}, in which if we wanted to\ngenerate $n$ dimensional Hilbert cell,\nthe $n-1$ dimensional Hilbert cell should be generated aforehand.\nBy using the function $b_n$ instead, the $n$ dimensional Hilbert cell can be generated directly.\n\nThe Hilbert gene list \\cite{chenyang} includes two types of commands: exchange command\nand reverse command. Using mathematical techniques developed in this paper, each command can be\ninterpreted as reflection from some hyperplane. For exchange command, if the command is\nperformed between $x_i$ and $x_j$ $(i \\ne j)$, the\nhyperplane is $x_i - x_j = 0$, which means, for a point $P$, $(x_n, \\cdots, x_i, \\cdots, x_j,\\cdots, x_1)$,\nthe coordinate of the new point $P'$ is $(x_n, \\cdots, x_j, \\cdots, x_i,\\cdots, x_1)$.\nThis command just swaps $x_i$ and $x_j$. For reverse command, if the command is performed on\nthe $i$-th position, and if\nthe current level of Hilbert curve is $m$, the hyperplane is $x_i = \\frac{2^m - 1}{2}$,\nwhich means for any point $P$, $(x_n, \\cdots, x_i, \\cdots,\nx_1)$, the coordinate of the new point $P'$ is $(x_n, \\cdots, 2^m - 1 - x_i, \\cdots, x_1)$. Here $(2^m - 1 - x_i)$ equals to $Re_m(x_i)$.\nThe reverse command changes $x_i$ only.\n\nThe algorithms which generateed gene list \\cite{chenyang} can be rewritten as\n\n", "index": 13, "text": "\\begin{equation}\n\\label{exchange} G_n^{i,0} = (b_n(0) \\wedge b_n(2^n -\n1))\\wedge(H_n^{i,0} \\wedge H_n^{i,1}),\n (0 \\le i < 2^n)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"G_{n}^{i,0}=(b_{n}(0)\\wedge b_{n}(2^{n}-1))\\wedge(H_{n}^{i,0}\\wedge H_{n}^{i,1%&#10;}),(0\\leq i&lt;2^{n})\" display=\"block\"><mrow><msubsup><mi>G</mi><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mn>0</mn></mrow></msubsup><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>b</mi><mi>n</mi></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><msub><mi>b</mi><mi>n</mi></msub><mrow><mo stretchy=\"false\">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>-</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>H</mi><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mn>0</mn></mrow></msubsup><mo>\u2227</mo><msubsup><mi>H</mi><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msubsup><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>\u2264</mo><mi>i</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01274.tex", "nexttext": "\nwhere $G_n^{i,0}$ and $G_n^{i,1}$ represent the exchange command and the reverse\ncommand respectively. According to the definition of $b_n$, $b_n(0)$ and $b_n(2^n -1)$ can be written as $(0,\\cdots,0)$ and $(1,0, 0,\n\\cdots, 0)$. In this case, $b_n(0) \\wedge b_n(2^n - 1)$ equals to $(1,0, 0, \\cdots, 0)$. All the components of entry $H_n^{i,0}$\nand exit $H_n^{i, 1}$ are the same except one, which means $G_n^{i,0}$ has no or only two components that\nequal to 1. If the $i$-th and $j$-th components of $G_n^{i,0}$ are\n1, then exchange command should be performed between $x_i$ and\n$x_j$. The exchange command isn't performed if all components of $G_n^{i, 0}$ are 0. For $G_n^{i,1}$, if the $i$-th component is 1,\nthe reverse command should be performed in the $i$-th position. The executed order of reverse\ncommands doesn't affect the final result.\n\nFor quadrant $0$, $b_n(0)$, $b_n(1)$, $H_n^{0, 0}$ and $H_n^{0, 1}$ are $(0, \\cdots, 0)$, $(0, \\cdots, 0, 1)$, $(0, \\cdots, 0)$ and $(0,\n\\cdots, 0, 1)$, respectively. According to \\eqref{exchange} and \\eqref{reverse}, $G_n^{0,0}$ equals to $(1,\n0,\\cdots, 0, 1)$ and $G_n^{0,1}$ equals to $(0, \\cdots, 0)$, which\nmean only exchange command is performed. This simple property guides us design algorithms with lower complexities.\n\n\n\\section{Encoding and Decoding Algorithms}\n\\label{sec-alg}\n\nThe encoding problems are studied first and four encoding algorithms are proposed. Two of them are based on\narithmetic operations and the other two bases on bit operations. Then decoding algorithms are obtained similarly.\nThe algorithms either have linear complexity or have constant complexity.\n\n\\subsection{Encoding Algorithms}\nLet the level of Hilbert order be $m$. For any point, $(x_n, \\cdots, x_1) (\\in D_m)$,\neach component $x_i (1 \\le i \\le n)$\nis written as $x_i = (x_i^mx_i^{m-1}\\cdots x_i^1)_2$. The calculated Hilbert order is\nstored as $(r_mr_{m-1}\\cdots r_1)_{2^n}$.\n\nWhen calculating the Hilbert order, the reverse command is performed first, followed by\nexchange command. The first encoding algorithm is described in\nAlgorithm \\ref{alg-encoding1}. We assume $G_n^{i,0}$ and $G_n^{i,1}$ are known, which can be calculated\nby algorithms in \\cite{chenyang} and be stored.\n\n\\begin{algorithm}\n\\caption{Encoding algorithm}\n\\label{alg-encoding1}\n\\begin{algorithmic}\n\\State (1) If $m = 0$, terminate the procedure. Or we have $r_m =\nf_n(x_n^m, x_{n-1}^m, \\cdots, x_1^m)$.\n\n\\State (2) For each integer $i (1 \\le i \\le n)$, if $x_i^m$ equals to 1, then $x_i = x_i - 2^{m-1}$.\n\n\\State (3)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$, if the $i$-th component of $G_n^{{r_m},1}$ is 1, then $x_i = 2^{m-1}\n- 1 - x_i$.\n\n\\State (4)\\textit{Exchange}. If $G_n^{{r_m},0}$ has two components equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (5) $m = m - 1$, goto (1).\n\\end{algorithmic}\n\\end{algorithm}\n\nThe Algorithm \\ref{alg-encoding1} is an iterative algorithm, which loops from $m$ to $0$.\nIt's evident that for $n$ dimensional Hilbert order, the complexity of Algorithm \\ref{alg-encoding1} is $O(nm)$. For\none specific dimension, such as two and three dimensional spaces, the complexity is $O(m)$, which is linear.\n\nNow, let us analyze Algorithm \\ref{alg-encoding1}. In step (2), the $i$-th component\n$x_i$, $(x_i^m\\cdots x_i^1)_2$, is replaced by\n$(x_i^{m-1}\\cdots x_i^1)_2$. This can be achieved by a simple $\\&$ operation. And in\nstep (3), the reverse operation is equivalent to $Re_{m-1}$ operation.\nThen algorithm \\ref{alg-encoding1} can be rewritten with bit operations, which is described in Algorithm \\ref{alg-encoding2}.\n\n\\begin{algorithm}\n\\caption{Encoding algorithm}\n\\label{alg-encoding2}\n\\begin{algorithmic}\n\\State (1) If $m = 0$, terminate the procedure. Or we have $r_m =\nf_n(x_n^m, x_{n-1}^m, \\cdots, x_1^m)$.\n\n\\State (2) For each integer $i (1 \\le i \\le n)$, $x_i =\n(x_i^{m-1}\\cdots x_i^1)_2 = (x_i^m\\cdots x_i^1)_2 ~\\&~ (011\\cdots\n1)_2$.\n\n\\State (3)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_m},1}$ is 1, then $x_i =\nRe_{m-1}(x_i)$.\n\n\\State (4)\\textit{Exchange}. If $G_n^{{r_m},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (5) $m = m - 1$, goto (1).\n\n\\end{algorithmic}\n\\end{algorithm}\n\nAlgorithm \\ref{alg-encoding2} has the same complexity as Algorithm \\ref{alg-encoding1}. The only difference\nis that it uses bit operations other than arithmetic operations. The algorithm should be more efficient.\n\n\\subsection{Encoding Algorithms with Lower Complexities}\nNow we develop encoding algorithms with lower complexities. According to our analysis above,\n$G_n^{0,0}$ has two nonzero components,\nwhich indicates where exchange command would be performed, and all components of $G_n^{0,1}$ are zero,\nwhich means that no inverse\ncommand would be performed. From our encoding algorithms above,\nwe can see that only exchange command between $x_n$ and $x_1$ is performed until value of $f_n$ isn't zero.\nThe $r_m$ is zero all the time. Therefore we can skip part of the loop.\nThis property shows us opportunity to reduce the number of iterations. Assume $log_2(0)$ equals to 0, we define $k =\nfloor(log_2(max\\{x_n, \\cdots, x_1\\})) + 1$. Then the two encoding algorithms\nabove are rewritten to Algorithm \\ref{alg-encoding3} and Algorithm \\ref{alg-encoding4} respectively.\n\n\\begin{algorithm}[htb]\n\\caption{Encoding algorithm}\n\\label{alg-encoding3}\n\\begin{algorithmic}\n\\State (1) Set $(r_m\\cdots r_1)_{2^n}$ to 0. If $m$ and $k$ have\ndifferent parities, then swap $x_1$ and $x_n$. $m = k$.\n\n\\State (2) If $m = 0$, terminate the procedure. Or we have $r_m =\nf_n(x_n^m, x_{n-1}^m, \\cdots, x_1^m)$.\n\n\\State (3) For each integer $i (1 \\le i \\le n)$, if $x_i^m$\nequals to 1, then $x_i = x_i - 2^{m-1}$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_m},1}$ is 1, then $x_i = 2^{m-1}\n- 1 - x_i$.\n\n\\State (5)\\textit{Exchange}. If $G_n^{{r_m},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (6) $m = m - 1$, goto (2).\n\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{algorithm}[htb]\n\\caption{Encoding algorithm}\n\\label{alg-encoding4}\n\\begin{algorithmic}\n\\State (1) Set $(r_m\\cdots r_1)_{2^n}$ to 0. If $m$ and $k$ have\ndifferent parities, then swap $x_1$ and $x_n$. $m = k$.\n\n\\State (2) If $m = 0$, terminate the procedure. Or we have $r_m =\nf_n(x_n^m, x_{n-1}^m, \\cdots, x_1^m)$.\n\n\\State (3) For each integer $i (1 \\le i \\le n)$, $x_i =\n(x_i^{m-1}\\cdots x_i^1)_2 = (x_i^m\\cdots x_i^1)_2 ~\\&~ (011\\cdots\n1)_2$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_m},1}$ is 1, then $x_i =\nRe_{m-1}(x_i)$.\n\n\\State (5)\\textit{Exchange}. If $G_n^{{r_m},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (6) $m = m - 1$, goto (2).\n\\end{algorithmic}\n\\end{algorithm}\n\nAgain algorithm \\ref{alg-encoding3} is based on arithmetic operations and Algorithm \\ref{alg-encoding4} is\nbased on bit operations, which terminate in $k$ steps, thus the complexities\nof them are $O(nk)$. For any given point $P$, the $k$ is fixed, therefore, the number of iterations\nof the latter two algorithms are independent of the level\nof Hilbert curve. For any specific dimension, the complexity is constant.\nWe can see that they are more efficient than the former two when level $m$ is much larger than $k$.\n\n\\subsection{Decoding Algorithms}\n\nLet the level of Hilbert curve be $m$. For any integer $z \\in [0, 2^{nm})$, it can be written as $(r_mr_{m-1}\\cdots\nr_1)_{2^n}$. Final result is a coordinate, $(x_n, \\cdots, x_2, x_1) (\\in D_m)$. Decoding procedure is the\nreverse process of encoding procedure. In the decoding procedure, the exchange command is performed first,\nthen the reverse command. The first decoding algorithms is described in\nAlgorithm \\ref{alg-decoding1}. Again, each arithmetic operation in Algorithm \\ref{alg-decoding1}\nis equivalent to a bit operation, and a decoding algorithm based on bit operations is proposed by the\nAlgorithm \\ref{alg-decoding2}.\n\n\\begin{algorithm}\n\\caption{Decoding algorithm}\n\\label{alg-decoding1}\n\\begin{algorithmic}\n\\State (1) Let $(x_n, \\cdots, x_2, x_1) = b_n(r_1)$ and $v = 2$.\n\n\\State (2) If $v > m$, terminate the procedure. Or we have\n$b_n(r_v) = (s_n, \\cdots, s_2, s_1)$.\n\n\\State (3)\\textit{Exchange}. If $G_n^{{r_v},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_v},1}$ is 1, then $x_i = 2^{v-1}\n- 1 - x_i$.\n\n\\State (5) For each integer $i (1 \\le i \\le n)$, if $s_i$ equals\nto 1, then $x_i = x_i + 2^{v-1}$.\n\n\\State (6) $v = v + 1$, goto (2).\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{algorithm}\n\\caption{Decoding algorithm}\n\\label{alg-decoding2}\n\\begin{algorithmic}\n\\State (1) Let $(x_n, \\cdots, x_2, x_1) = b_n(r_1)$ and $v = 2$.\n\n\\State (2) If $v > m$, terminate the procedure. Or we have\n$b_n(r_v) = (s_n, \\cdots, s_2, s_1)$.\n\n\\State (3)\\textit{Exchange}. If $G_n^{{r_v},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_v},1}$ is 1, then $x_i =\nRe_{v-1}(x_i)$.\n\n\\State (5) For each integer $i (1 \\le i \\le n)$, if $s_i$ equals\nto 1, then $x_i = (x_i) \\wedge (1 \\ll (v-1))$.\n\n\\State (6) $v = v + 1$, goto (2).\n\\end{algorithmic}\n\\end{algorithm}\n\nAlgorithm \\ref{alg-decoding1} and Algorithm \\ref{alg-decoding2} terminate in $m$ steps\nand it's evident that their complexities are $O(nm)$. For any specific dimension $n$, the complexity\nis linear.\n\n\\subsection{Decoding Algorithms with Lower Complexities}\nWe introduce the definition of $k$ here, which means $r_k > 0$ and $r_i = 0 (i > k)$. It is the location that\nthe first $r_i$ is not zero. We also assume $k$ equals to 1 if $z$ equals to 0.\nIt's equivalent to $k = floor(log_{2^n}((r_m\\cdots r_1)_{2^n})) + 1$ if we assume $log_{2^n}(0)$ equals to 0. $k$ isn't greater\nthan $m$ and is independent of $m$. Now we can rewrite Algorithm \\ref{alg-decoding1} and Algorithm \\ref{alg-decoding2}\nwith lower complexities.\n\n\\begin{algorithm}\n\\caption{Decoding algorithm}\n\\label{alg-decoding3}\n\\begin{algorithmic}\n\\State (1) Let $(x_n, \\cdots, x_2, x_1) = b_n(r_1)$ and $v = 2$.\n\n\\State (2) If $v > k$, terminate the procedure. Or we have\n$b_n(r_v) = (s_n, \\cdots, s_2, s_1)$.\n\n\\State (3)\\textit{Exchange}. If $G_n^{{r_v},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_v},1}$ is 1, then $x_i = 2^{v-1}\n- 1 - x_i$.\n\n\\State (5) For each integer $i (1 \\le i \\le n)$, if $s_i$ equals\nto 1, then $x_i = x_i + 2^{v-1}$.\n\n\\State (6) $v = v + 1$, goto (2).\n\n\\State (7) If $m$ and $k$ have different parities, then swap $x_n$ and $x_1$.\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\n\\begin{algorithm}\n\\caption{Decoding algorithm}\n\\label{alg-decoding4}\n\\begin{algorithmic}\n\\State (1) Let $(x_n, \\cdots, x_2, x_1) = b_n(r_1)$ and $v = 2$.\n\n\\State (2) If $v > k$, terminate the procedure. Or we have\n$b_n(r_v) = (s_n, \\cdots, s_2, s_1)$.\n\n\\State (3)\\textit{Exchange}. If $G_n^{{r_v},0}$ has two components,\nwhich equal to 1 in $i$-th and $j$-th position, then swap $x_i$ and\n$x_j$.\n\n\\State (4)\\textit{Reverse}. For each integer $i (1 \\le i \\le n)$,\nif the $i$-th component of $G_n^{{r_v},1}$ is 1, then $x_i =\nRe_{v-1}(x_i)$.\n\n\\State (5) For each integer $i (1 \\le i \\le n)$, if $s_i$ equals\nto 1, then $x_i = (x_i) \\wedge (1 \\ll (v-1))$.\n\n\\State (6) $v = v + 1$, goto (2).\n\n\\State (7) If $m$ and $k$ have different parities, then swap\n$x_n$ and $x_1$.\n\\end{algorithmic}\n\\end{algorithm}\n\nAlgorithm \\ref{alg-decoding3} and Algorithm \\ref{alg-decoding4} terminate in $k$ steps and\ntherefore the complexities are $O(nk)$. For any fixed input and any specific dimension, the complexity\nis constant.\n\n\\section{Discussion}\n\\label{sec-dis}\nEncoding and decoding algorithms above are concise and easy to implement.\nIn this section, a two dimensional example is\nemployed to illustrate how to use these algorithms. For the sake of simpleness, only\nAlgorithm \\ref{alg-encoding1} is studied.\n\nWhen $n$ equals to two, the functions $b_2$ and $f_2$ are calculated and stored in\nTable~\\ref{map}. Exchange command $G_2^{i, 0}$ and reverse command $G_2^{i, 1}$ are listed in Table~\\ref{gene},\nhich are obtained using algorithms introduced in \\cite{chenyang}.\n\n\\begin{table}\n\\centering\n\\caption{Function $f_2$ and $b_2$.}\n{\n  \\begin{tabular}{|c|c|c|c|} \\hline\n   $f_2(0, 0)$& 0 &  $b_2(0)$& (0, 0)\\\\\n   $f_2(0, 1)$& 1 &  $b_2(1)$& (0, 1)\\\\\n   $f_2(1, 1)$& 2 &  $b_2(2)$& (1, 1)\\\\\n   $f_2(1, 0)$& 3 &  $b_2(3)$& (1, 0)\\\\ \\hline\n  \\end{tabular}\n}\n\\label{map}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\caption{Exchange commands and reverse commands.}\n{\n  \\begin{tabular}{|c|c|c|c|} \\hline\n   $G_2^{0,0}$& (1, 1) &  $G_2^{0,1}$& (0, 0)\\\\\n   $G_2^{1,0}$& (0, 0) &  $G_2^{1,1}$& (0, 0)\\\\\n   $G_2^{2,0}$& (0, 0) &  $G_2^{2,1}$& (0, 0)\\\\\n   $G_2^{3,0}$& (1, 1) &  $G_2^{3,1}$& (1, 1)\\\\ \\hline\n  \\end{tabular}\n}\n\\label{gene}\n\\end{table}\n\nChecking Algorithm \\ref{alg-encoding1}, we can see what steps (2) $\\sim$ (4) do is to update coordinate $(x_n,\\cdots, x_1)$ only.\nThe reason we describe the process by using three steps is to make the process clear. In practice, these three steps can be combined\ntogether and we use one step to update directly. The updating rules for encoding procedure are shown in Table~\\ref{encoding}, where $(x_2,\nx_1)$ is replaced by $(x, y)$.\n\nThe updating rules can be obtained easily using our algorithm. Take $i$\nequals to 3 as an example. In this case, $G_2^{3,0}$ is $(1,1)$, and $G_2^{3,1}$ is (1, 1). According to our analysis,\nan exchange operation and two reverse operations should be performed. The new coordinate $(x_{new}, y_{new})$ is\n$(x - 2^{m-1}, y)$ after step (2). It is $(2^m -1 -x, 2^{m-1}-1-y)$ after reverse operation. Then we perform the exchange command, the final coordinate is $(2^{m-1}-1-y, 2^m -1 -x)$, which is the same as shown in Table~\\ref{encoding}. Updating rules for decoding algorithm\ncan be obtained similarly.\n\n\\begin{table}\n\\centering\n\\caption{Updating rules  of encoding procedure.}\n{\n\\begin{tabular}{|c|c|c|} \\hline\n   Quadrant &  $x_{new}$ & $y_{new}$ \\\\ \\hline\n   $0$& $y$ & $x$ \\\\\n   $1$& $x$ & $y - 2^{m-1}$ \\\\\n   $2$& $x - 2^{m-1}$& $y - 2^{m-1}$\\\\\n   $3$& $2^{m-1} - 1 - y$ & $2^m - 1 - x$ \\\\ \\hline\n\\end{tabular}\n}\n\\label{encoding}\n\\end{table}\n\nIn \\cite{ningtao}, Chen et al. developed a reduced complexity algorithm for two dimensional case\nand numerical results were also presented. We implement the three dimensional case in PHG \\cite{phg,hliu},\nwhich is an essential module for dynamic load balancing. The Hilbert order algorithms were also implemented\nin Zoltan \\cite{Zoltan}. The performance data is collected in Table \\ref{en-perf}.\nThe first row represents the level of Hilbert order, and others represent running time.\n>From this table, we can see that for a fixed coordinate (1, 1, 1), the computational time increases linearly for\nalgorithm with the $O(m)$ complexity while it's fixed for algorithm with $O(k)$ complexity.\n\n\n\\begin{table}\n\\centering\n\\caption{Performance of encoding algorithm for (1,1,1)}\n{\n\\begin{tabular}{|c|c|c|c|c|} \\hline\n   Algorithm & 8 (s)    & 32 (s)  & 128 (s) & 256 (s)   \\\\ \\hline\n   O(m)      & 1.60E-7  & 4.69E-7 & 1.67E-6 & 3.25E-6   \\\\\n   O(k)      & 8.38E-8  & 8.39E-8 & 8.39E-8 & 8.38E-8   \\\\ \\hline\n\\end{tabular}\n}\n\\label{en-perf}\n\\end{table}\n\n\\section{CONCLUSION}\n\nEncoding and decoding of arbitrary dimension Hilbert order are studied. And the open problem is solved by\nthis paper. Four encoding algorithms and four decoding algorithms are proposed. Four of them have linear\ncomputation complexities and the other four have lower complexities.\nThe properties of evolutive rules introduced by \\cite{chenyang} are also studied and some results are deduced,\nwhich are applied to develop encoding and decoding algorithms.\nA two dimensional case is studied and updating rules are presented.\nBy using algorithms developed\nin this paper, algorithms for any specific dimensional spaces can be obtained.\nIn the end of the paper,\nnumerical experiments are performed, which demonstrate the difference between algorithms with difference\ncomplexities.\n\n\\section*{Acknowledgments}\nThis work is supported by the 973 Program under the grant\n 2011CB309703, by China NSF under the grants 11021101 and 11171334, by the 973 Program under\n the grant 2011CB309701, the China NSF under the grants 11101417\nand by the National Magnetic Confinement Fusion Science Program under the grants 2011GB105003.\n\n\\begin{thebibliography}{000}\n\n\\bibitem{Hans}\nH. Sagan, Space-Filling Curves. \\textit{Springer-Verlag}; 1994.\n\n\\bibitem{kamata}\nS. Kamata, R. O. Eason, Y. Bandou, A new algorithm for N-dimensional\nHilbert scanning. \\textit{IEEE Trans on Image Processing} 1999;\n\\textbf{8}(7): 964--973.\n\n\\bibitem{chenyang}\nC. Li, Y. Feng, {Algorithm for analyzing n-dimensional Hilbert\ncurve} , vol. 3739. \\textit{Springer Berlin/Heidelberg}, 2005; 657--662.\n\n\\bibitem{butz}\nA. R. Butz,\nAltrnative algorithm for Hilbert's space-filling curve.\n\\textit{IEEE Transactions on Computers} 1971;\n\\textbf{20}: 424--426.\n\n\\bibitem{gold}\nL. M. Goldschlager,\nShort algorithms for space-filling curves.\n\\textit{Software---Practice and Experience} 1981;\n\\textbf{11}: 99--100.\n\n\\bibitem{witten}\nI. H. Witten, B. Wyvill,\nOn the generation and use of space-filling curves.\n\\textit{Software---Practice and Experience} 1983;\n\\textbf{13}: 519--525.\n\n\\bibitem{cole}\nA. J. Cole,\nA note on space filling curves.\n\\textit{Software---Practice and Experience} 1983;\n\\textbf{13}: 1181--1189.\n\n\\bibitem{griff}\nJ. G. Griffiths,\nTable-driven algorithms for generating space-filling curves.\n\\textit{Computer-Aided Design} 1985;\n\\textbf{17}(1): 37--41.\n\n\\bibitem{sfc-tr-03}\nP. C. Campbell, K. D. Devine, J. E. Flaherty, L. G. Gervasio, J. D. Teresco,\nDynamic octree load balancing using space-filling curves.\nTechnical Report CS-03-01 2003.\n\n\\bibitem{xliu2}\nX. Liu, G. F. Schrack,\nEncoding and decoding the Hilbert order.\n\\textit{Software---Practice and Experience} 1996;\n\\textbf{26}(12): 1335--1346.\n\n\\bibitem{xliu}\nX. Liu, G. F. Schrack, An algorithm for encoding and decoding the 3-D\nHilbert order. \\textit{IEEE transactions on image processing} 1997;\n\\textbf{6}: 1333--1337.\n\n\\bibitem{fisher}\nA. J. Fisher,\nA new algorithm for generation hilbert curves.\n\\textit{Software: Practice and Experience} 1986;\n\\textbf{16}: 5--12.\n\n\\bibitem{ningtao}\nN. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the\nHilbert order. \\textit{Software---Practice and Experience} 2007;\n\\textbf{37}(8): 897--908.\n\n\\bibitem{hliu}\nH. Liu,\nDynamic load balancing on adaptive unstructured meshes.\n\\textit{High Performance Computing and Communications, 10th IEEE International Conference on} 2008;\n\\textbf{0}: 870--875.\n\n\\bibitem{phg}\nL. Zhang,\n{A Parallel Algorithm for Adaptive Local Refinement of Tetrahedral\nMeshes Using Bisection}, \\textit{Numer. Math.: Theory, Methods and\nApplications} 2009, 2: 65--89.\n\n\\bibitem{Zoltan}\n{K. Devine, E. Boman, R. Heaphy, B. Hendrickson, and C. Vaughan}\n{{Zoltan} Data Management Services for Parallel Dynamic Applications},\n\\textit{Computing in Science and Engineering}, {2002},{4},{2}: {90--97}.\n\n\\end{thebibliography}\n\n", "itemtype": "equation", "pos": 10552, "prevtext": "\n\n\n", "index": 15, "text": "\\begin{equation}\n\\label{reverse} G_n^{i,1} = b_n(0)\\wedge H_n^{i,0}, ( 0 \\le i <\n2^n),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"G_{n}^{i,1}=b_{n}(0)\\wedge H_{n}^{i,0},(0\\leq i&lt;2^{n}),\" display=\"block\"><mrow><msubsup><mi>G</mi><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msub><mi>b</mi><mi>n</mi></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><msubsup><mi>H</mi><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mn>0</mn></mrow></msubsup><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>\u2264</mo><mi>i</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}]