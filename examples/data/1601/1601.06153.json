[{"file": "1601.06153.tex", "nexttext": "\nThey also demonstrated that the Pyramid code construction in~\\cite{Huang:07} achieves this bound.\nSince then, a series of results have extended the code distance bound for a given locality for various types of codes along with corresponding {\\it optimal} code constructions achieving the distance bound. We give a brief (far from complete) overview of some of these results below.\n\n{\\bf Related work:} \nThe distance bound was generalized for codes with multiple local parities in~\\cite{Prakash:12}, universal (scalar/vector linear, nonlinear) codes in~\\cite{Papailiopoulos:14}, universal codes with multiple parities in~\\cite{Rawat:14,Kamath:14}. An integer programming based bound was established in~\\cite{Wang:15}. Almost all of these works also presented optimal code constructions. Furthermore, a large number of other optimal code constructions have been presented, see {\\it e.g.},~\\cite{Silberstein:13,Tamo:LRC13,Ernvall:14,TamoB:14,Goparaju:14,Song:14,Kuijper:14,Huang:15,ZehY:15,SilbersteinZ:15}. The notion of locality was extended to multiple recovery groups (also known as, availability) in~\\cite{Rawat:Availability14,Tamo:Availability14}, and for the case of multiple failures, to sequential repair in~\\cite{Prakash:14} and hierarchical repair in~\\cite{Sasidharan:15}. The Singleton-like bound was extended to accommodate the alphabet size in~\\cite{CadambeM:15}.\n\n{\\bf Our contributions:} \nIn previous works, the locality of a code is characterized by a single parameter $r$. Inspired from the notion of {\\it unequal error protection}, we are interested in investigating linear codes, in which, different subsets of symbols possess different localities. We refer to such codes as {\\it codes with unequal locality}. For example, consider a $(15,11)$ code whose 4 information symbols have locality 2, 3 information symbols have locality 3, and 4 information symbols have locality 4 (with no constraint on the locality of parity symbols). Under the classical terminology, such a code would be characterized as a code with information locality 4. However, it is not clear if the distance bound given in~\\eqref{eq:Gopalan} is tight for the case of unequal localities. Our main goal is to compute a tight upper bound on the minimum distance of such codes with unequal locality. \n\nCodes with unequal locality are practically appealing in scenarios when important information symbols, {\\it e.g.}, symbols of {\\it hot data}, need to be repaired quickly; whereas, recovering less important symbols can involve more overhead. Moreover, these types of codes can be useful in reducing download latency for hot data. For instance, references~\\cite{Joshi:14,KSS:15} study storage codes from queueing theoretic perspective to analyze download latency. \n\nOur key contributions are summarized as follows.  To characterize a code with unequal information locality, we define a notion of {\\it information locality profile} of a code. We say that a code has an information locality profile \\mbox{${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$} if it contains ${k_{{j}}}$ information symbols of locality $j$ for $1\\leq j\\leq r$. For example, a code having 5 information symbols of locality 2, and 6 information symbols of locality 4 would have an information locality profile $\\{0,5,0,6\\}$. \nFor scalar linear codes, we establish an upper bound on the minimum distance as a function of  information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$ as follows (Theorem~\\ref{thm:dist-bound-info-loc}).\n\n", "itemtype": "equation", "pos": 3707, "prevtext": "\n\\maketitle\n\n\\begin{abstract}\nFor a code ${\\mathcal{C}}$, its $i$-th symbol is said to have locality $r$ if its value can be recovered by accessing some other $r$ symbols of ${\\mathcal{C}}$. Locally repairable codes (LRCs) are the family of codes such that every symbol has locality $r$.  \n\nIn this paper, we focus on (linear) codes whose individual symbols can be partitioned into subsets such that symbols in one subset have different locality than the ones in other. We call such codes as \\emph{codes with unequal locality}. For codes with \\emph{unequal information locality}, we compute a tight upper bound on the minimum distance as a function of number of information symbols of each locality. We demonstrate that the construction of Pyramid codes can be adapted to design codes with unequal information locality that achieve the minimum distance bound. This result generalizes the classical result of Gopalan {\\it et al.}~for codes with unequal locality.\nNext, we consider codes with \\emph{unequal all symbol locality}, and establish an upper bound on the minimum distance as a function of number of symbols of each locality. We show that the construction based on rank-metric codes by Silberstein {\\it et al.}~can be adapted to obtain codes with unequal all symbol locality that achieve the minimum distance bound. Finally, we introduce the concept of \\emph{locality requirement} on a code, which can be viewed as a recoverability requirement on symbols. Information locality requirement on a code essentially specifies the minimum number of information symbols of different localities that must be present in the code. We present a greedy algorithm that assigns localities to information symbols so as to maximize the minimum distance among all codes that satisfy a given locality requirement.\n\\end{abstract}\n\n\\section{Introduction}\n\\label{sec:intro}\nCoding for distributed storage has recently attracted significant research attention with a focus on the problem of recovery from storage node failures. The thrust has been on characterizing fundamental limits and designing associated coding schemes for one or more of the following metrics that are crucial in the node repair process: (a) {\\it repair bandwidth} -- the amount of data downloaded during failed node repair~\\cite{Dimakis:10, Dimakis:11}; (b) disk I/O -- the number of bits read from the nodes participating in the repair process~\\cite{Tamo:Zigzag13,Khan:11}; and (c) {\\it repair locality} -- the number of nodes participating in the repair process~\\cite{Gopalan:12,Oggier:11}. \n\nIn this paper, we focus on the metric of repair locality and a class of codes designed in the context of this metric, known as {\\it locally repairable codes} (LRCs). Consider a block code of length $n$ that encodes $k$ information symbols. A symbol $i$ is said to have {\\it locality} ${r_i}$ if it can be recovered by accessing ${r_i}$ other symbols in the code. We say that a code has {\\it information locality} $r$ if each of its $k$ information symbols has locality at most $r$. Similarly, we say that a code has {\\it all-symbol locality} $r$ if each of its $n$ symbols has locality at most $r$. \n\nCodes with small locality were introduced in~\\cite{Huang:07, Han:07} (see also~\\cite{Oggier:11}). The study of the locality property was galvanized with the pioneering work of Gopalan {\\it et al.}~\\cite{Gopalan:12}. One of their key contributions was to establish a trade-off between the minimum distance of a code and its information locality analogous to the classical Singleton bound. In particular, the authors showed that for a (scalar) linear $(n,k)$ code having information locality $r$, the minimum distance $d$ of the code is upper bounded as\n\n", "index": 1, "text": "\\begin{equation}\n\\label{eq:Gopalan}\nd \\leq n - k - \\left\\lceil{\\frac{k}{r}}\\right\\rceil + 2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"d\\leq n-k-\\left\\lceil{\\frac{k}{r}}\\right\\rceil+2.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2264</mo><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi><mo>-</mo><mrow><mo>\u2308</mo><mfrac><mi>k</mi><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>+</mo><mn>2</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \nWe demonstrate that the Pyramid code construction in~\\cite{Huang:07} can be adapted to design unequal locality codes that are distance-wise optimal according to the bound above. \n\nWhen parity symbols also have locality constraints, we can analogously define an {\\it all symbol locality profile} of a code. W say that a code has an all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{r}}}\\}$ if it contains ${k_{{j}}}$ information symbols of locality $j$ for $1\\leq j\\leq r$. For instance, consider a $(15,11)$ code that has 6 symbols of locality 2, 4 symbols of locality 3, and 5 symbols of locality 4. Its all symbol locality profile would be $\\{0,6,4,5\\}$. We compute an upper bound on the minimum distance for scalar linear codes as a function of all symbol locality profile, which has the following form (Theorem~\\ref{thm:all-symbol-loc-bound}).\\footnote{In an parallel and independent work, Zeh and Yaakobi~\\cite{ZehY:16} also consider the problem of computing a bound on minimum distance of codes with unequal all symbol locality, referred in their work as multiple locality codes. Their bound~\\cite[Theorem 8]{ZehY:16} has a similar form as we get. In addition,~\\cite{ZehY:16} extends Cadambe-Mazumdar bound in~\\cite{CadambeM:15} for codes with multiple localities, and present several optimal code constructions.}\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nThey also demonstrated that the Pyramid code construction in~\\cite{Huang:07} achieves this bound.\nSince then, a series of results have extended the code distance bound for a given locality for various types of codes along with corresponding {\\it optimal} code constructions achieving the distance bound. We give a brief (far from complete) overview of some of these results below.\n\n{\\bf Related work:} \nThe distance bound was generalized for codes with multiple local parities in~\\cite{Prakash:12}, universal (scalar/vector linear, nonlinear) codes in~\\cite{Papailiopoulos:14}, universal codes with multiple parities in~\\cite{Rawat:14,Kamath:14}. An integer programming based bound was established in~\\cite{Wang:15}. Almost all of these works also presented optimal code constructions. Furthermore, a large number of other optimal code constructions have been presented, see {\\it e.g.},~\\cite{Silberstein:13,Tamo:LRC13,Ernvall:14,TamoB:14,Goparaju:14,Song:14,Kuijper:14,Huang:15,ZehY:15,SilbersteinZ:15}. The notion of locality was extended to multiple recovery groups (also known as, availability) in~\\cite{Rawat:Availability14,Tamo:Availability14}, and for the case of multiple failures, to sequential repair in~\\cite{Prakash:14} and hierarchical repair in~\\cite{Sasidharan:15}. The Singleton-like bound was extended to accommodate the alphabet size in~\\cite{CadambeM:15}.\n\n{\\bf Our contributions:} \nIn previous works, the locality of a code is characterized by a single parameter $r$. Inspired from the notion of {\\it unequal error protection}, we are interested in investigating linear codes, in which, different subsets of symbols possess different localities. We refer to such codes as {\\it codes with unequal locality}. For example, consider a $(15,11)$ code whose 4 information symbols have locality 2, 3 information symbols have locality 3, and 4 information symbols have locality 4 (with no constraint on the locality of parity symbols). Under the classical terminology, such a code would be characterized as a code with information locality 4. However, it is not clear if the distance bound given in~\\eqref{eq:Gopalan} is tight for the case of unequal localities. Our main goal is to compute a tight upper bound on the minimum distance of such codes with unequal locality. \n\nCodes with unequal locality are practically appealing in scenarios when important information symbols, {\\it e.g.}, symbols of {\\it hot data}, need to be repaired quickly; whereas, recovering less important symbols can involve more overhead. Moreover, these types of codes can be useful in reducing download latency for hot data. For instance, references~\\cite{Joshi:14,KSS:15} study storage codes from queueing theoretic perspective to analyze download latency. \n\nOur key contributions are summarized as follows.  To characterize a code with unequal information locality, we define a notion of {\\it information locality profile} of a code. We say that a code has an information locality profile \\mbox{${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$} if it contains ${k_{{j}}}$ information symbols of locality $j$ for $1\\leq j\\leq r$. For example, a code having 5 information symbols of locality 2, and 6 information symbols of locality 4 would have an information locality profile $\\{0,5,0,6\\}$. \nFor scalar linear codes, we establish an upper bound on the minimum distance as a function of  information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$ as follows (Theorem~\\ref{thm:dist-bound-info-loc}).\n\n", "index": 3, "text": "\\begin{equation}\n\\label{eq:bound-1}\nd \\leq n - k - \\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + 2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"d\\leq n-k-\\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil+2.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2264</mo><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi><mo>-</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>k</mi><mi>j</mi></msub><mi>j</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>+</mo><mn>2</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nWe adapt the construction in~\\cite{Silberstein:13}, which uses a maximum rank distance (MRD) code as an outer code and a maximum distance separable (MDS) code as inner code, to construct codes with unequal all symbol locality that are optimal with respect to the above bound.\n\n\nFinally, we introduce a concept of {\\it information locality requirement}. To motivate this, consider a scenario where we need to design a linear code of dimension $k=11$ such that ${\\tilde{k}_{{3}}} = 5$ information symbols must have locality at most $3$, and the remaining ${\\tilde{k}_{{4}}} = 6$ information symbols must have locality at most $4$. Collectively, we can specify this as a locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{0,0,5,6\\}$. Notice that this is equivalent to a requirement as a code must contain at least 5 symbols of locality up to 3, and at least 11 symbols of locality up to 4. In general, a locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{{\\tilde{k}_{{1}}},\\ldots,{\\tilde{k}_{{r}}}\\}$ means that a code should contain at least $\\sum_{i=1}^{i}{\\tilde{k}_{{j}}}$ symbols of locality up to $i$ for each $1\\leq i\\leq r$, or, in other words, ${\\tilde{k}_{{j}}}$ information symbols should have locality at most $j$. \n\nOne can design codes with various information locality profiles that would satisfy this requirement. For examples, the locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{0,0,5,6\\}$ is satisfied by locality profiles $\\{5,6\\}$, $\\{0,0,5,6\\}$, $\\{0,2,9\\}$, $\\{1,0,6,4\\}$, etc. The question what is the maximum value of minimum distance any code with this locality requirement would attain, and can we find an {\\it optimal} locality profile which achieves this distance? Note that locality requirement can be viewed as a recoverability requirement for code design. We give a simple greedy algorithm which computes an information locality profile given an information locality requirement.\n\n\\section{Preliminaries}\n\\label{sec:basics}\n\n\\subsection{Notation}\n\\label{sec:notation}\nWe use the following notation.\n\\begin{enumerate}\n\\item For an integer $l$, $[l] = \\{1,2,\\ldots,l\\}$;\n\\item For a vector ${\\mathbf{{x}}}$ and an integer $i$, ${\\mathbf{{x}}}(i)$ denotes the $i$-th coordinate of ${\\mathbf{{x}}}$, for a matrix $H$ and integers $i, j$, $H(i,j)$ denotes the element in row $i$ and column $j$;\n\\item For a vector ${\\mathbf{{x}}}$, $\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right)$ denotes its support, {\\it i.e.}, $\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right) = \\{i : {\\mathbf{{x}}}(i) \\neq 0\\}$;\n\\item For a vector ${\\mathbf{{x}}}$, $\\textsf{wt}\\left({{\\mathbf{{x}}}}\\right)$ denotes its Hamming weight, {\\it i.e.}, $\\textsf{wt}\\left({x}\\right) = |\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right)|$;\n\\item For vectors ${\\mathbf{{x}}}$ and ${\\mathbf{{y}}}$, ${\\mathbf{{x}}}\\cdot{\\mathbf{{y}}}$ denotes their dot product;\n\\item For a set of vectors ${\\mathbf{{x}}}_1, \\ldots, {\\mathbf{{x}}}_m$, ${\\langle {{\\mathbf{{x}}}_1, \\ldots, {\\mathbf{{x}}}_m} \\rangle}$ denotes their span, whereas for a matrix $H$, ${\\langle {H} \\rangle}$ denotes its row space;\n\\item For a  vector space $\\mathcal{A}$, $\\textsf{dim}\\left({\\mathcal{A}}\\right)$ denotes its dimension;\n\\item For a matrix $H$, $\\textsf{rank}\\left({H}\\right)$ denotes the rank of $H$.\n\\end{enumerate}\n\n\\subsection{Codes with Locality}\n\\label{sec:basics}\nLet ${\\mathcal{C}}$ denote a linear ${[n,k,d]_q}$ code over ${\\mathbb{F}_{{q}}}$ with block-length $n$, dimension $k$, and minimum distance $d$. Let ${\\mathbf{c}}$ denote a codeword in ${\\mathcal{C}}$. The code can be represented by a set of $n$ (column) vectors ${C} = \\left\\{{\\mathbf{{c}}}_1,\\ldots,{\\mathbf{{c}}}_n\\right\\} \\in {\\mathbb{F}_{{q}}}^k$. The set of vectors must have rank $k$ for ${\\mathcal{C}}$ to have dimension $k$. The $i$-th vector ${{\\mathbf{{c}}}_i}$ is referred to as the $i$-th coordinate of ${\\mathcal{C}}$. For any codeword ${\\mathbf{c}}\\in{\\mathcal{C}}$, ${\\mathbf{c}}(i)$ is said to be the $i$-th symbol of the codeword ${\\mathbf{c}}$. In the context of locality, we use the terms symbol or coordinate interchangeably. Our main focus is on systematic codes, and we assume that the first $k$ coordinates correspond to the information symbols.\n\nWe say that the $i$-th coordinate of a code ${\\mathcal{C}}$ has locality ${r_i}$ if its value can be recovered from some other ${r_i}$ coordinates of ${\\mathcal{C}}$. The formal definition of locality is as follows.\n\n\\begin{definition}\n\\label{def:locality}\n[Locality] For ${{\\mathbf{{c}}}_i}\\in{\\mathcal{C}}$, we define $\\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$ to be the smallest integer ${r_i}$ such that there exists a subset ${R}_{{}}\\left({i}\\right)\\subset[n]\\setminus\\{i\\}$, $|{R}_{{}}\\left({i}\\right)|\\leq {r_i}$, such that ${{\\mathbf{{c}}}_i} = \\sum_{l\\in{R}_{{}}\\left({i}\\right)}\\lambda_{l}{{\\mathbf{{c}}}_l}$, where $\\lambda_l \\in{\\mathbb{F}_{{q}}}$ $\\forall\\: l\\in{R}_{{}}\\left({i}\\right)$. \n\\end{definition}\nNote that, if the minimum distance of the code is more than two, then every coordinate has locality at most $k$. \n\nWe say that an $(n,k)$ code has {\\it information locality} $r$ if each of its $k$ information symbols has locality at most $r$. Similarly, we say that an $(n,k)$ code has {\\it all symbol locality} $r$ if each of its $n$  symbols has locality at most $r$.\n\n\n\\section{Codes with Unequal Information Locality}\n\\label{sec:info-loc}\nIn this section, we are interested in systematic codes, whose information symbols can be partitioned into disjoint subsets in such a way that the symbols in one subset have different locality than the symbols in other subset. We say that such codes possess unequal information locality. We can characterize the locality of such codes by listing the locality values of each information symbol. Alternatively, we can consider the list of cardinalities of subset of each locality. We call such a list as the {\\it information locality profile} of the code. Formally, the definition is as follows. \n\n\\begin{definition}\n\\label{def:info-loc-prof}\n[Information Locality Profile] Given a systematic ${[n,k,d]_q}$ code ${\\mathcal{C}}$, the information locality profile of ${\\mathcal{C}}$ is defined as a length-$k$ vector ${\\mathbf{{r}}}({\\mathcal{C}}) = \\{r_1,\\ldots,r_k\\}$, where $r_i$ is the locality of the $i$-th information coordinate of ${\\mathcal{C}}$. Note that $1\\leq {r_i} \\leq k$ for each $i\\in[k]$, assuming $d\\geq2$. \n\nAlternatively, we can specify the locality profile of ${\\mathcal{C}}$ as a length-$r$ vector ${\\mathbf{{k}}}({\\mathcal{C}}) = \\{{k_{{1}}}, \\ldots, {k_{{r}}}\\}$, where $r = \\max\\{r_1, \\ldots, r_k\\}$ and ${k_{{j}}}$ is the number of information coordinates of locality $j$ for $j\\in[r]$. Note that $\\forall j\\in[r]$, $0\\leq k_j\\leq k$, ${k_{{r}}} \\geq 1$ and $\\sum_{j=1}^{r} {k_{{j}}} = k$. \n\\end{definition}\n\n\\begin{remark}\n\\label{rem:info-loc-prof}\nFor a code ${\\mathcal{C}}$ with representation ${C}$, we can choose any subset of $k$ full-rank coordinates of ${C}$ to represent information symbols. Without loss of generality, we can always choose the coordinates having smallest overall locality as information coordinates. More specifically, for $1\\leq j\\leq r$, let ${C_{{j}}}\\subset{C}$ be the subset of coordinates having locality $j$. Set ${C_{{0}}} = \\emptyset$. Let \n\n", "itemtype": "equation", "pos": 8797, "prevtext": " \nWe demonstrate that the Pyramid code construction in~\\cite{Huang:07} can be adapted to design unequal locality codes that are distance-wise optimal according to the bound above. \n\nWhen parity symbols also have locality constraints, we can analogously define an {\\it all symbol locality profile} of a code. W say that a code has an all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{r}}}\\}$ if it contains ${k_{{j}}}$ information symbols of locality $j$ for $1\\leq j\\leq r$. For instance, consider a $(15,11)$ code that has 6 symbols of locality 2, 4 symbols of locality 3, and 5 symbols of locality 4. Its all symbol locality profile would be $\\{0,6,4,5\\}$. We compute an upper bound on the minimum distance for scalar linear codes as a function of all symbol locality profile, which has the following form (Theorem~\\ref{thm:all-symbol-loc-bound}).\\footnote{In an parallel and independent work, Zeh and Yaakobi~\\cite{ZehY:16} also consider the problem of computing a bound on minimum distance of codes with unequal all symbol locality, referred in their work as multiple locality codes. Their bound~\\cite[Theorem 8]{ZehY:16} has a similar form as we get. In addition,~\\cite{ZehY:16} extends Cadambe-Mazumdar bound in~\\cite{CadambeM:15} for codes with multiple localities, and present several optimal code constructions.}\n\n", "index": 5, "text": "\\begin{equation}\n\\label{eq:bound-2}\nd \\leq n - k + 2 - \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil - \\left\\lceil{\\frac{k - \\sum_{i=1}^{r-1}\\left({n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"d\\leq n-k+2-\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil-%&#10;\\left\\lceil{\\frac{k-\\sum_{i=1}^{r-1}\\left({n_{{j}}}-\\left\\lceil{\\frac{{n_{{j}}%&#10;}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2264</mo><mrow><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow><mo>+</mo><mn>2</mn></mrow><mo>-</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>-</mo><mrow><mo>\u2308</mo><mfrac><mrow><mi>k</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mrow><mo>(</mo><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>-</mo><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nIn other words, $\\sum_{i=1}^{j}{k_{{i}}}$ is the rank of the sub-matrix formed by the coordinates having locality up to $j$. Starting with $j=1$, we choose a subset ${I_{j}} \\subset {C_{{j}}}$ of ${k_{{j}}}$ linearly independent coordinates to represent ${k_{{j}}}$ information symbols, and continue incrementing $j$ till the total rank is $k$. \n\\end{remark}\n\n\\begin{remark}\n\\label{rem:loc-prof-classical}\n\nIn the classical notion of locality defined by Gopalan {\\it et al.}~\\cite{Gopalan:12}, technically, every symbol can have different locality. However, the (information) locality of a code is parameterized by a single value $r$, which is the largest locality of an (information) symbol. On the other hand, we parameterize the information locality using a length-$k$ vector that specifies the locality of each individual information symbol. We are interested in characterizing a trade-off between the minimum distance of a code and its locality profile vector.\n\\end{remark}\n\n\\subsection{Bound on the Minimum Distance}\n\\label{sec:dist-bound}\nConsider a class of systematic linear codes having an information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$. We are interested in finding an upper bound on the minimum distance as a function of the code length, dimension, and information locality profile. This would be a generalization of the result in~\\cite{Gopalan:12} for codes with unequal localities for information symbols.\n\n\\begin{theorem}\n\\label{thm:dist-bound-info-loc}\nFor any linear code with block-length $n$, dimension $k$, and information locality profile ${\\mathbf{{k}}} = \\{k_1,\\ldots,k_r\\}$, we have\n\n", "itemtype": "equation", "pos": 16329, "prevtext": "\nWe adapt the construction in~\\cite{Silberstein:13}, which uses a maximum rank distance (MRD) code as an outer code and a maximum distance separable (MDS) code as inner code, to construct codes with unequal all symbol locality that are optimal with respect to the above bound.\n\n\nFinally, we introduce a concept of {\\it information locality requirement}. To motivate this, consider a scenario where we need to design a linear code of dimension $k=11$ such that ${\\tilde{k}_{{3}}} = 5$ information symbols must have locality at most $3$, and the remaining ${\\tilde{k}_{{4}}} = 6$ information symbols must have locality at most $4$. Collectively, we can specify this as a locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{0,0,5,6\\}$. Notice that this is equivalent to a requirement as a code must contain at least 5 symbols of locality up to 3, and at least 11 symbols of locality up to 4. In general, a locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{{\\tilde{k}_{{1}}},\\ldots,{\\tilde{k}_{{r}}}\\}$ means that a code should contain at least $\\sum_{i=1}^{i}{\\tilde{k}_{{j}}}$ symbols of locality up to $i$ for each $1\\leq i\\leq r$, or, in other words, ${\\tilde{k}_{{j}}}$ information symbols should have locality at most $j$. \n\nOne can design codes with various information locality profiles that would satisfy this requirement. For examples, the locality requirement of ${\\tilde{{\\mathbf{{k}}}}} = \\{0,0,5,6\\}$ is satisfied by locality profiles $\\{5,6\\}$, $\\{0,0,5,6\\}$, $\\{0,2,9\\}$, $\\{1,0,6,4\\}$, etc. The question what is the maximum value of minimum distance any code with this locality requirement would attain, and can we find an {\\it optimal} locality profile which achieves this distance? Note that locality requirement can be viewed as a recoverability requirement for code design. We give a simple greedy algorithm which computes an information locality profile given an information locality requirement.\n\n\\section{Preliminaries}\n\\label{sec:basics}\n\n\\subsection{Notation}\n\\label{sec:notation}\nWe use the following notation.\n\\begin{enumerate}\n\\item For an integer $l$, $[l] = \\{1,2,\\ldots,l\\}$;\n\\item For a vector ${\\mathbf{{x}}}$ and an integer $i$, ${\\mathbf{{x}}}(i)$ denotes the $i$-th coordinate of ${\\mathbf{{x}}}$, for a matrix $H$ and integers $i, j$, $H(i,j)$ denotes the element in row $i$ and column $j$;\n\\item For a vector ${\\mathbf{{x}}}$, $\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right)$ denotes its support, {\\it i.e.}, $\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right) = \\{i : {\\mathbf{{x}}}(i) \\neq 0\\}$;\n\\item For a vector ${\\mathbf{{x}}}$, $\\textsf{wt}\\left({{\\mathbf{{x}}}}\\right)$ denotes its Hamming weight, {\\it i.e.}, $\\textsf{wt}\\left({x}\\right) = |\\textsf{Supp}\\left({{\\mathbf{{x}}}}\\right)|$;\n\\item For vectors ${\\mathbf{{x}}}$ and ${\\mathbf{{y}}}$, ${\\mathbf{{x}}}\\cdot{\\mathbf{{y}}}$ denotes their dot product;\n\\item For a set of vectors ${\\mathbf{{x}}}_1, \\ldots, {\\mathbf{{x}}}_m$, ${\\langle {{\\mathbf{{x}}}_1, \\ldots, {\\mathbf{{x}}}_m} \\rangle}$ denotes their span, whereas for a matrix $H$, ${\\langle {H} \\rangle}$ denotes its row space;\n\\item For a  vector space $\\mathcal{A}$, $\\textsf{dim}\\left({\\mathcal{A}}\\right)$ denotes its dimension;\n\\item For a matrix $H$, $\\textsf{rank}\\left({H}\\right)$ denotes the rank of $H$.\n\\end{enumerate}\n\n\\subsection{Codes with Locality}\n\\label{sec:basics}\nLet ${\\mathcal{C}}$ denote a linear ${[n,k,d]_q}$ code over ${\\mathbb{F}_{{q}}}$ with block-length $n$, dimension $k$, and minimum distance $d$. Let ${\\mathbf{c}}$ denote a codeword in ${\\mathcal{C}}$. The code can be represented by a set of $n$ (column) vectors ${C} = \\left\\{{\\mathbf{{c}}}_1,\\ldots,{\\mathbf{{c}}}_n\\right\\} \\in {\\mathbb{F}_{{q}}}^k$. The set of vectors must have rank $k$ for ${\\mathcal{C}}$ to have dimension $k$. The $i$-th vector ${{\\mathbf{{c}}}_i}$ is referred to as the $i$-th coordinate of ${\\mathcal{C}}$. For any codeword ${\\mathbf{c}}\\in{\\mathcal{C}}$, ${\\mathbf{c}}(i)$ is said to be the $i$-th symbol of the codeword ${\\mathbf{c}}$. In the context of locality, we use the terms symbol or coordinate interchangeably. Our main focus is on systematic codes, and we assume that the first $k$ coordinates correspond to the information symbols.\n\nWe say that the $i$-th coordinate of a code ${\\mathcal{C}}$ has locality ${r_i}$ if its value can be recovered from some other ${r_i}$ coordinates of ${\\mathcal{C}}$. The formal definition of locality is as follows.\n\n\\begin{definition}\n\\label{def:locality}\n[Locality] For ${{\\mathbf{{c}}}_i}\\in{\\mathcal{C}}$, we define $\\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$ to be the smallest integer ${r_i}$ such that there exists a subset ${R}_{{}}\\left({i}\\right)\\subset[n]\\setminus\\{i\\}$, $|{R}_{{}}\\left({i}\\right)|\\leq {r_i}$, such that ${{\\mathbf{{c}}}_i} = \\sum_{l\\in{R}_{{}}\\left({i}\\right)}\\lambda_{l}{{\\mathbf{{c}}}_l}$, where $\\lambda_l \\in{\\mathbb{F}_{{q}}}$ $\\forall\\: l\\in{R}_{{}}\\left({i}\\right)$. \n\\end{definition}\nNote that, if the minimum distance of the code is more than two, then every coordinate has locality at most $k$. \n\nWe say that an $(n,k)$ code has {\\it information locality} $r$ if each of its $k$ information symbols has locality at most $r$. Similarly, we say that an $(n,k)$ code has {\\it all symbol locality} $r$ if each of its $n$  symbols has locality at most $r$.\n\n\n\\section{Codes with Unequal Information Locality}\n\\label{sec:info-loc}\nIn this section, we are interested in systematic codes, whose information symbols can be partitioned into disjoint subsets in such a way that the symbols in one subset have different locality than the symbols in other subset. We say that such codes possess unequal information locality. We can characterize the locality of such codes by listing the locality values of each information symbol. Alternatively, we can consider the list of cardinalities of subset of each locality. We call such a list as the {\\it information locality profile} of the code. Formally, the definition is as follows. \n\n\\begin{definition}\n\\label{def:info-loc-prof}\n[Information Locality Profile] Given a systematic ${[n,k,d]_q}$ code ${\\mathcal{C}}$, the information locality profile of ${\\mathcal{C}}$ is defined as a length-$k$ vector ${\\mathbf{{r}}}({\\mathcal{C}}) = \\{r_1,\\ldots,r_k\\}$, where $r_i$ is the locality of the $i$-th information coordinate of ${\\mathcal{C}}$. Note that $1\\leq {r_i} \\leq k$ for each $i\\in[k]$, assuming $d\\geq2$. \n\nAlternatively, we can specify the locality profile of ${\\mathcal{C}}$ as a length-$r$ vector ${\\mathbf{{k}}}({\\mathcal{C}}) = \\{{k_{{1}}}, \\ldots, {k_{{r}}}\\}$, where $r = \\max\\{r_1, \\ldots, r_k\\}$ and ${k_{{j}}}$ is the number of information coordinates of locality $j$ for $j\\in[r]$. Note that $\\forall j\\in[r]$, $0\\leq k_j\\leq k$, ${k_{{r}}} \\geq 1$ and $\\sum_{j=1}^{r} {k_{{j}}} = k$. \n\\end{definition}\n\n\\begin{remark}\n\\label{rem:info-loc-prof}\nFor a code ${\\mathcal{C}}$ with representation ${C}$, we can choose any subset of $k$ full-rank coordinates of ${C}$ to represent information symbols. Without loss of generality, we can always choose the coordinates having smallest overall locality as information coordinates. More specifically, for $1\\leq j\\leq r$, let ${C_{{j}}}\\subset{C}$ be the subset of coordinates having locality $j$. Set ${C_{{0}}} = \\emptyset$. Let \n\n", "index": 7, "text": "\\begin{equation}\n\\label{eq:k-j}\n{k_{{j}}} =  \\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right). \n\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"{k_{{j}}}=\\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right)-\\textsf{rank}%&#10;\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right).\\par&#10;\" display=\"block\"><mrow><mrow><msub><mi>k</mi><mi>j</mi></msub><mo>=</mo><mrow><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mo>\u222a</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>j</mi></msubsup><msub><mi>C</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow><mo>-</mo><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mo>\u222a</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msub><mi>C</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\\end{theorem}\n\n\\begin{proof}\nWe build on the proof technique proposed in~\\cite{Gopalan:12}. The idea is to construct a large set ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$, and then use the following fact.\n\\begin{fact}\n\\label{fact}\n(\\cite{Gopalan:12}) The code ${\\mathcal{C}}$ has minimum distance $d$ if and only if for every ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$, we have\n\n", "itemtype": "equation", "pos": 18139, "prevtext": "\nIn other words, $\\sum_{i=1}^{j}{k_{{i}}}$ is the rank of the sub-matrix formed by the coordinates having locality up to $j$. Starting with $j=1$, we choose a subset ${I_{j}} \\subset {C_{{j}}}$ of ${k_{{j}}}$ linearly independent coordinates to represent ${k_{{j}}}$ information symbols, and continue incrementing $j$ till the total rank is $k$. \n\\end{remark}\n\n\\begin{remark}\n\\label{rem:loc-prof-classical}\n\nIn the classical notion of locality defined by Gopalan {\\it et al.}~\\cite{Gopalan:12}, technically, every symbol can have different locality. However, the (information) locality of a code is parameterized by a single value $r$, which is the largest locality of an (information) symbol. On the other hand, we parameterize the information locality using a length-$k$ vector that specifies the locality of each individual information symbol. We are interested in characterizing a trade-off between the minimum distance of a code and its locality profile vector.\n\\end{remark}\n\n\\subsection{Bound on the Minimum Distance}\n\\label{sec:dist-bound}\nConsider a class of systematic linear codes having an information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$. We are interested in finding an upper bound on the minimum distance as a function of the code length, dimension, and information locality profile. This would be a generalization of the result in~\\cite{Gopalan:12} for codes with unequal localities for information symbols.\n\n\\begin{theorem}\n\\label{thm:dist-bound-info-loc}\nFor any linear code with block-length $n$, dimension $k$, and information locality profile ${\\mathbf{{k}}} = \\{k_1,\\ldots,k_r\\}$, we have\n\n", "index": 9, "text": "\\begin{equation}\n\\label{eq:dist-bound-info-loc}\nd \\leq n - k - \\sum_{j = 1}^{r} \\left\\lceil{\\frac{k_j}{j}}\\right\\rceil + 2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"d\\leq n-k-\\sum_{j=1}^{r}\\left\\lceil{\\frac{k_{j}}{j}}\\right\\rceil+2.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2264</mo><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi><mo>-</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>k</mi><mi>j</mi></msub><mi>j</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>+</mo><mn>2</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\\end{fact}\n\nRecall that ${R}_{{}}\\left({i}\\right)$ denotes a repair group of ${{\\mathbf{{c}}}_i}$, and we have $|{R}_{{}}\\left({i}\\right)| = \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. Define $\\Gamma\\left({i}\\right) := \\{i \\cup {R}_{{}}\\left({i}\\right)\\}$. Further, for any subset ${T}\\subseteq[n]$, define ${\\mathbf{{c}}}_{{{T}}} = \\{{{\\mathbf{{c}}}_i}\\in{C} : i\\in{T}\\}$. \n\n\n\\begin{algorithm}[!t]\n\\caption{Construct set ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$}\n\\label{alg:find-S}\n\\begin{algorithmic}[1]\n\\STATE Let ${S}_{{0}} = \\emptyset$, $i = 1$\n\\WHILE{$\\textsf{rank}\\left({{S}_{{i-1}}}\\right)\\leq k - 2$}\n\t\\STATE{Pick a coordinate ${{\\mathbf{{c}}}_i}\\in{C}\\setminus{S}_{{i}}$ having smallest locality} \n\t\\label{pick-ci}\n\t\\IF{$\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) < k$}\t\\label{condition}\n\t\t\\STATE{Set ${S}_{{i}} = {S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$}\n\t\\ELSE\n\t\t\\STATE{Pick $\\Gamma\\left({i}\\right)' \\subset \\Gamma\\left({i}\\right)$ such that $\\textsf{rank}\\left({{S}_{{i-1}}\\cup{\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)'}}}\\right) = \t\t\t\t      k -1$}\t\n\t\t\\STATE{Set ${S}_{{i}} = {S}_{{i-1}}\\cup{\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)'}}$}\n\t\\ENDIF\n\\STATE{Increment $i$}\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\n\nWe use Algorithm~\\ref{alg:find-S} to construct a set ${S}$ such that $\\textsf{rank}\\left({{S}}\\right) < k$. First, note that in line~\\ref{pick-ci}, as $\\textsf{rank}\\left({{S}_{{i-1}}}\\right) \\leq k - 2$, and there are $k$ (linearly independent) information symbols, there exists a coordinate ${{\\mathbf{{c}}}_i}\\notin{S}_{{i-1}}$. \n\nOur goal is to find a lower bound on $|{S}|$. Let $l$ be the total number of iterations of Algorithm~\\ref{alg:find-S}. Observe that $|{S}| = |{S}_{{l}}|$. Further, the final set ${S}_{{l}}$ has $\\textsf{rank}\\left({{S}_{{l}}}\\right) = k-1$. We define the increment in the size and rank of set ${S}_{{i}}$ in the $i$-th iteration as follows.\n\n", "itemtype": "equation", "pos": 18717, "prevtext": "\n\\end{theorem}\n\n\\begin{proof}\nWe build on the proof technique proposed in~\\cite{Gopalan:12}. The idea is to construct a large set ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$, and then use the following fact.\n\\begin{fact}\n\\label{fact}\n(\\cite{Gopalan:12}) The code ${\\mathcal{C}}$ has minimum distance $d$ if and only if for every ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$, we have\n\n", "index": 11, "text": "\\begin{equation}\n\\label{eq:fact}\n|{S}| \\leq n - d.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"|{S}|\\leq n-d.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mrow><mi>n</mi><mo>-</mo><mi>d</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nNote that\n\n", "itemtype": "equation", "pos": 20780, "prevtext": "\n\\end{fact}\n\nRecall that ${R}_{{}}\\left({i}\\right)$ denotes a repair group of ${{\\mathbf{{c}}}_i}$, and we have $|{R}_{{}}\\left({i}\\right)| = \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. Define $\\Gamma\\left({i}\\right) := \\{i \\cup {R}_{{}}\\left({i}\\right)\\}$. Further, for any subset ${T}\\subseteq[n]$, define ${\\mathbf{{c}}}_{{{T}}} = \\{{{\\mathbf{{c}}}_i}\\in{C} : i\\in{T}\\}$. \n\n\n\\begin{algorithm}[!t]\n\\caption{Construct set ${S}\\subseteq{C}$ such that $\\textsf{rank}\\left({{S}}\\right) \\leq k - 1$}\n\\label{alg:find-S}\n\\begin{algorithmic}[1]\n\\STATE Let ${S}_{{0}} = \\emptyset$, $i = 1$\n\\WHILE{$\\textsf{rank}\\left({{S}_{{i-1}}}\\right)\\leq k - 2$}\n\t\\STATE{Pick a coordinate ${{\\mathbf{{c}}}_i}\\in{C}\\setminus{S}_{{i}}$ having smallest locality} \n\t\\label{pick-ci}\n\t\\IF{$\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) < k$}\t\\label{condition}\n\t\t\\STATE{Set ${S}_{{i}} = {S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$}\n\t\\ELSE\n\t\t\\STATE{Pick $\\Gamma\\left({i}\\right)' \\subset \\Gamma\\left({i}\\right)$ such that $\\textsf{rank}\\left({{S}_{{i-1}}\\cup{\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)'}}}\\right) = \t\t\t\t      k -1$}\t\n\t\t\\STATE{Set ${S}_{{i}} = {S}_{{i-1}}\\cup{\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)'}}$}\n\t\\ENDIF\n\\STATE{Increment $i$}\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\n\nWe use Algorithm~\\ref{alg:find-S} to construct a set ${S}$ such that $\\textsf{rank}\\left({{S}}\\right) < k$. First, note that in line~\\ref{pick-ci}, as $\\textsf{rank}\\left({{S}_{{i-1}}}\\right) \\leq k - 2$, and there are $k$ (linearly independent) information symbols, there exists a coordinate ${{\\mathbf{{c}}}_i}\\notin{S}_{{i-1}}$. \n\nOur goal is to find a lower bound on $|{S}|$. Let $l$ be the total number of iterations of Algorithm~\\ref{alg:find-S}. Observe that $|{S}| = |{S}_{{l}}|$. Further, the final set ${S}_{{l}}$ has $\\textsf{rank}\\left({{S}_{{l}}}\\right) = k-1$. We define the increment in the size and rank of set ${S}_{{i}}$ in the $i$-th iteration as follows.\n\n", "index": 13, "text": "\\begin{equation}\n\\label{eq:si-ti}\n{s_i} = |{S}_{{i}}| - |{S}_{{i-1}}|, \\quad  {t_i} = \\textsf{rank}\\left({{S}_{{i}}}\\right) - \\textsf{rank}\\left({{S}_{{i-1}}}\\right).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"{s_{i}}=|{S}_{{i}}|-|{S}_{{i-1}}|,\\quad{t_{i}}=\\textsf{rank}\\left({{S}_{{i}}}%&#10;\\right)-\\textsf{rank}\\left({{S}_{{i-1}}}\\right).\" display=\"block\"><mrow><mrow><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo>)</mo></mrow></mrow><mo>-</mo><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><msub><mi>S</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\nWe consider two cases depending on whether Algorithm~\\ref{alg:find-S} reaches the condition in line~\\ref{condition}, {\\it i.e.}, $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) = k$. We note that the condition can be reached only in the last iteration. \n\n{\\bf Case 1:} Suppose we have $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) \\leq k-1$ throughout. Now, in the $i$-th iteration, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$ to ${S}$. Thus, ${s_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right) + 1$. Further, vectors in ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}\\setminus{S}_{{i-1}}$ are such that they yield a (possibly zero) vector in ${\\langle {{S}_{{i-1}}} \\rangle}$. Therefore, \n\n", "itemtype": "equation", "pos": 20972, "prevtext": "\nNote that\n\n", "index": 15, "text": "\\begin{equation}\n\\label{eq:S-l-total-rank}\n|{S}_{{l}}| = \\sum_{i = 1}^{l}{s_i}, \\quad \\textsf{rank}\\left({{S}_{{l}}}\\right) = \\sum_{i=1}^{l}{t_i} = k - 1.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"|{S}_{{l}}|=\\sum_{i=1}^{l}{s_{i}},\\quad\\textsf{rank}\\left({{S}_{{l}}}\\right)=%&#10;\\sum_{i=1}^{l}{t_{i}}=k-1.\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>S</mi><mi>l</mi></msub><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>s</mi><mi>i</mi></msub></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><msub><mi>S</mi><mi>l</mi></msub><mo>)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>t</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \nUsing this, we can write\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nWe consider two cases depending on whether Algorithm~\\ref{alg:find-S} reaches the condition in line~\\ref{condition}, {\\it i.e.}, $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) = k$. We note that the condition can be reached only in the last iteration. \n\n{\\bf Case 1:} Suppose we have $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) \\leq k-1$ throughout. Now, in the $i$-th iteration, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$ to ${S}$. Thus, ${s_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right) + 1$. Further, vectors in ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}\\setminus{S}_{{i-1}}$ are such that they yield a (possibly zero) vector in ${\\langle {{S}_{{i-1}}} \\rangle}$. Therefore, \n\n", "index": 17, "text": "\\begin{equation}\n\\label{eq:ti-bound}\n{t_i} \\leq {s_i} - 1 \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"{t_{i}}\\leq{s_{i}}-1\\leq\\textsf{Loc}\\left({{{\\mathbf{{c}}}_{i}}}\\right).\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>\u2264</mo><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>-</mo><mn>1</mn></mrow><mo>\u2264</mo><mrow><mtext>\ud835\uddab\ud835\uddc8\ud835\uddbc</mtext><mo>\u2062</mo><mrow><mo>(</mo><msub><mi>\ud835\udc1c</mi><mi>i</mi></msub><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nwhere the last equality follows from~\\eqref{eq:S-l-total-rank}. \n\n{\\it Lower bounding the number of iterations.} Now, to find a lower bound on $|{S}|$, we find a lower bound on $l$. Let $m$ be the locality of the last symbol collected by Algorithm~\\ref{alg:find-S}, where $m\\in[r]$.\nFor $1\\leq j\\leq m$, let ${l_{{j}}}$ be the number of iterations in which Algorithm~\\ref{alg:find-S} picks  coordinates of locality $j$. Note that, if ${\\mathcal{C}}$ does not contain any symbol of a particular locality $j$, we set ${l_{{j}}} = 0$. Thus, for each $j$, $0\\leq {l_{{j}}}\\leq l$, and $l = \\sum_{j=1}^{m} {l_{{j}}}$. \n\nRecall that ${C_{{j}}}\\subset{C}$ is the set of coordinates of locality $j$ (see Remark~\\ref{rem:info-loc-prof}). Since the algorithm collects all coordinates of locality up to $j$ before collecting any coordinate of locality $j+1$ for $1\\leq j\\leq m-1$, we have ${S}_{{\\sum_{p=1}^{j}l_p}} = \\cup_{p=1}^j{C_{{p}}}$. Therefore, from~\\eqref{eq:k-j}, $\\textsf{rank}\\left({{S}_{{l_1}}}\\right) = {k_{{1}}}$ and for $2\\leq j\\leq m-1$, $\\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j}l_p}}}\\right) - \\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j-1}l_p}}}\\right) = {k_{{j}}}$. This results in \n\n", "itemtype": "equation", "pos": 22074, "prevtext": " \nUsing this, we can write\n\n", "index": 19, "text": "\\begin{equation}\n\\label{eq:S-case-1}\n|{S}| = \\sum_{i=1}^{l}{s_i} \\geq \\sum_{i=1}^{l}({t_i}+1) = k - 1 + l,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"|{S}|=\\sum_{i=1}^{l}{s_{i}}\\geq\\sum_{i=1}^{l}({t_{i}}+1)=k-1+l,\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>s</mi><mi>i</mi></msub></mrow><mo>\u2265</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo>+</mo><mi>l</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \nThe above two results can be interpreted as follows. The increment in the rank of ${S}$ by collecting all the coordinates of locality $j$ is ${k_{{j}}}$ for $1\\leq j\\leq m-1$. The rank of ${S}$, when it contains all the coordinates of locality up to $j$, is $\\sum_{p=1}^{j}{k_{{p}}}$.\n\nWhen the algorithm terminates, it may not have collected all the coordinates of locality $m$. Let ${k_{{m}}}'$ be the increment in the rank of ${S}$ by the coordinates of locality $m$ that are collected by the algorithm. Note that $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$. \n\nNote that $\\textsf{rank}\\left({{S}_{{l}}}\\right) = \\textsf{rank}\\left({{S}_{{\\sum_{j=1}^{m-1}{l_{{j}}}}}}\\right) + {k_{{m}}}'$. Using the fact that $\\textsf{rank}\\left({{S}_{{l}}}\\right) = k-1$ and~\\eqref{eq:rank-S-lj}, we get $k-1 = \\sum_{j=1}^{m-1}{k_{{j}}} + {k_{{m}}}'$. On the other hand, by definition of locality profile vector, we have $\\sum_{j=1}^{r}{k_{{j}}} = k$. We consider two cases.\n\nCase (1a): ${k_{{r}}} \\geq 2 1$. Then, it must be that $m=r$ and ${k_{{m}}}' = {k_{{r}}} - 1$ since $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$. \n\nCase (1b): ${k_{{r}}} = 1$. Then, it follows that $m=r-1$, and ${k_{{m}}}' = {k_{{r-1}}}$ since $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$.\n\nIn summary, for $1\\leq j\\leq r-1$, the increment in the rank of ${S}$ by collecting the coordinates of locality $j$ is ${k_{{j}}}$. The increment in the rank of ${S}$ by locality $r$ coordinates is ${k_{{r}}}-1$. (Note that this holds for Case (b) as well.) Moreover, for each $1\\leq j \\leq r$, when the algorithm is collecting the coordinates of locality $j$, the rank can increase by at most $j$ in each step (see~\\eqref{eq:ti-bound}). Therefore, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil$ for $1\\leq j\\leq r-1$ and $l_r \\geq \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil$.\n\n\n\nCombining this with $l = \\sum_{j=1}^r{l_{{j}}}$ gives,\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere the last equality follows from~\\eqref{eq:S-l-total-rank}. \n\n{\\it Lower bounding the number of iterations.} Now, to find a lower bound on $|{S}|$, we find a lower bound on $l$. Let $m$ be the locality of the last symbol collected by Algorithm~\\ref{alg:find-S}, where $m\\in[r]$.\nFor $1\\leq j\\leq m$, let ${l_{{j}}}$ be the number of iterations in which Algorithm~\\ref{alg:find-S} picks  coordinates of locality $j$. Note that, if ${\\mathcal{C}}$ does not contain any symbol of a particular locality $j$, we set ${l_{{j}}} = 0$. Thus, for each $j$, $0\\leq {l_{{j}}}\\leq l$, and $l = \\sum_{j=1}^{m} {l_{{j}}}$. \n\nRecall that ${C_{{j}}}\\subset{C}$ is the set of coordinates of locality $j$ (see Remark~\\ref{rem:info-loc-prof}). Since the algorithm collects all coordinates of locality up to $j$ before collecting any coordinate of locality $j+1$ for $1\\leq j\\leq m-1$, we have ${S}_{{\\sum_{p=1}^{j}l_p}} = \\cup_{p=1}^j{C_{{p}}}$. Therefore, from~\\eqref{eq:k-j}, $\\textsf{rank}\\left({{S}_{{l_1}}}\\right) = {k_{{1}}}$ and for $2\\leq j\\leq m-1$, $\\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j}l_p}}}\\right) - \\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j-1}l_p}}}\\right) = {k_{{j}}}$. This results in \n\n", "index": 21, "text": "\\begin{equation}\n\\label{eq:rank-S-lj}\n\\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j}l_p}}}\\right) = \\sum_{p=1}^{j}{k_{{p}}}, \\quad \\textrm{for}\\:\\:1\\leq j\\leq m-1.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\textsf{rank}\\left({{S}_{{\\sum_{p=1}^{j}l_{p}}}}\\right)=\\sum_{p=1}^{j}{k_{{p}}%&#10;},\\quad\\textrm{for}\\&gt;\\&gt;1\\leq j\\leq m-1.\" display=\"block\"><mrow><mrow><mrow><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><msub><mi>S</mi><mrow><mstyle displaystyle=\"false\"><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></msubsup></mstyle><msub><mi>l</mi><mi>p</mi></msub></mrow></msub><mo>)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></munderover><msub><mi>k</mi><mi>p</mi></msub></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mtext>for</mtext><mo>\u2062</mo><mn>\u2005\u20051</mn></mrow><mo>\u2264</mo><mi>j</mi><mo>\u2264</mo><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\nSubstituting this into~\\eqref{eq:S-case-1}, we get\n\\begin{IEEEeqnarray}{rCl}\n|{S}| & \\geq & k - 1 + \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil\\\\\n\\label{eq:S-case-1-final}\n& \\geq & k - 2 + \\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil.\n\\end{IEEEeqnarray}\n\n\n\n\n{\\bf Case 2:} In the last step, we get $\\textsf{rank}\\left({{S}_{{l-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}}\\right) = k$.\nFor $1\\leq i\\leq l-1$, in the $i$-th iteration, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$. Thus, ${s_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right) + 1$. Further, vectors in ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}\\setminus{S}_{{i-1}}$ are such that they yield a (possibly zero) vector in ${\\langle {{S}_{{i-1}}} \\rangle}$. Therefore, for $1\\leq i\\leq l-1$, we get ${t_i} \\leq {s_i} - 1 \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. \nIn the last step $l$, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)'}} \\subset {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}$. This increments $\\textsf{rank}\\left({{S}}\\right)$ by $t_l \\geq 1$ (since $\\textsf{rank}\\left({{S}_{{l-1}}}\\right)\\leq k - 2$), and $|{S}|$ by $s_l \\geq t_l$. Therefore, we have\n\n", "itemtype": "equation", "pos": 25436, "prevtext": " \nThe above two results can be interpreted as follows. The increment in the rank of ${S}$ by collecting all the coordinates of locality $j$ is ${k_{{j}}}$ for $1\\leq j\\leq m-1$. The rank of ${S}$, when it contains all the coordinates of locality up to $j$, is $\\sum_{p=1}^{j}{k_{{p}}}$.\n\nWhen the algorithm terminates, it may not have collected all the coordinates of locality $m$. Let ${k_{{m}}}'$ be the increment in the rank of ${S}$ by the coordinates of locality $m$ that are collected by the algorithm. Note that $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$. \n\nNote that $\\textsf{rank}\\left({{S}_{{l}}}\\right) = \\textsf{rank}\\left({{S}_{{\\sum_{j=1}^{m-1}{l_{{j}}}}}}\\right) + {k_{{m}}}'$. Using the fact that $\\textsf{rank}\\left({{S}_{{l}}}\\right) = k-1$ and~\\eqref{eq:rank-S-lj}, we get $k-1 = \\sum_{j=1}^{m-1}{k_{{j}}} + {k_{{m}}}'$. On the other hand, by definition of locality profile vector, we have $\\sum_{j=1}^{r}{k_{{j}}} = k$. We consider two cases.\n\nCase (1a): ${k_{{r}}} \\geq 2 1$. Then, it must be that $m=r$ and ${k_{{m}}}' = {k_{{r}}} - 1$ since $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$. \n\nCase (1b): ${k_{{r}}} = 1$. Then, it follows that $m=r-1$, and ${k_{{m}}}' = {k_{{r-1}}}$ since $1\\leq {k_{{m}}}' \\leq {k_{{m}}}$.\n\nIn summary, for $1\\leq j\\leq r-1$, the increment in the rank of ${S}$ by collecting the coordinates of locality $j$ is ${k_{{j}}}$. The increment in the rank of ${S}$ by locality $r$ coordinates is ${k_{{r}}}-1$. (Note that this holds for Case (b) as well.) Moreover, for each $1\\leq j \\leq r$, when the algorithm is collecting the coordinates of locality $j$, the rank can increase by at most $j$ in each step (see~\\eqref{eq:ti-bound}). Therefore, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil$ for $1\\leq j\\leq r-1$ and $l_r \\geq \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil$.\n\n\n\nCombining this with $l = \\sum_{j=1}^r{l_{{j}}}$ gives,\n\n", "index": 23, "text": "\\begin{equation}\n\\label{eq:l-LB-case-1}\nl \\geq \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"l\\geq\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil+\\left\\lceil{%&#10;\\frac{{k_{{r}}}-1}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mi>l</mi><mo>\u2265</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>k</mi><mi>j</mi></msub><mi>j</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>+</mo><mrow><mo>\u2308</mo><mfrac><mrow><msub><mi>k</mi><mi>r</mi></msub><mo>-</mo><mn>1</mn></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nthe last equality follows from~\\eqref{eq:S-l-total-rank}.  \n\n{\\it Lower bounding the number of iterations.} Similar to Case 1, in each iteration $i$ (including the last one), we have ${t_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. The only difference from Case 1 is that ${S}$ accumulates total rank of $k$ instead of $k-1$. Therefore, to lower bound $l$, we can use the same arguments as in Case 1 along with $\\textsf{rank}\\left({{S}_{{l}}}\\right)=k$ to obtain $l \\geq \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + \\left\\lceil{\\frac{{k_{{r}}}}{r}}\\right\\rceil$ in place of~\\eqref{eq:l-LB-case-1}. Substituting this into~\\eqref{eq:S-case-2} yields $|{S}| \\geq k - 2 + \\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ (which is same as~\\eqref{eq:S-case-1-final}).\n\nFinally, noting that  $|{S}| \\leq n - d$ from Fact~\\ref{fact} and using this lower bound on $|{S}|$ gives~\\eqref{eq:dist-bound-info-loc}.\n\\end{proof}\n\n\\subsection{Code Construction: Pyramid Codes}\n\\label{sec:pyramid-codes}\nWe show that the {\\it parity splitting} construction of the Pyramid codes~\\cite{Huang:07} can be adapted to obtain codes with unequal information locality, that are optimal with respect to~\\eqref{eq:dist-bound-info-loc}. Consider an information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$. Let $\\{{j_{{1}}},\\ldots,{j_{{m}}}\\}$ with ${j_{{1}}} < \\cdots < {j_{{m}}}$ be the $m (\\leq r)$ localities such that ${k_{{{j_{{p}}}}}} > 0$. We begin with a $(k+d-1,k,d)$ systematic maximum distance separable (MDS) code ${\\mathcal{C}^{'}}$. Let the representing coordinates be ${C^{'}} = \\{{\\mathbf{{e}}}_{{1}},\\ldots,{\\mathbf{{e}}}_{{k}},{\\mathbf{{p}}}_{{0}},\\ldots,{\\mathbf{{p}}}_{{d-2}}\\}$, where ${\\mathbf{{e}}}_{{j}}$ is the $j$-th column of a $k\\times k$ identity matrix, and ${\\mathbf{{p}}}_{{j}}$ for $0\\leq j\\leq d-2$ are the columns representing the parity coordinates. \n\nWe partition the set $[k]$ into $m$ disjoint subsets ${S}_{{1}}, \\ldots, {S}_{{m}}$ such that $|{S}_{{p}}| = {k_{{{j_{{p}}}}}}$ for each $p\\in[m]$. Next, partition each subset ${S}_{{p}}$ into ${l_{{p}}} = \\left\\lceil{\\frac{{k_{{{j_{{p}}}}}}}{{j_{{p}}}}}\\right\\rceil$ disjoint subsets each of size at most ${j_{{p}}}$. That is, ${S}_{{p}} = \\cup_{i=1}^{{l_{{p}}}}{S}_{{p,i}}$. For a vector ${\\mathbf{{x}}}$ of dimension $k$, and a set ${S}\\subseteq[k]$, let ${{{\\mathbf{{x}}}}|_{{{S}}}}$ denote the $|{S}|$-dimensional restriction of ${\\mathbf{{x}}}$ to the coordinates  in set ${S}$. Then, we define the systematic code ${\\mathcal{C}}$ with the following representation.\n\n", "itemtype": "equation", "pos": 26842, "prevtext": "\n\nSubstituting this into~\\eqref{eq:S-case-1}, we get\n\\begin{IEEEeqnarray}{rCl}\n|{S}| & \\geq & k - 1 + \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + \\left\\lceil{\\frac{{k_{{r}}}-1}{r}}\\right\\rceil\\\\\n\\label{eq:S-case-1-final}\n& \\geq & k - 2 + \\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil.\n\\end{IEEEeqnarray}\n\n\n\n\n{\\bf Case 2:} In the last step, we get $\\textsf{rank}\\left({{S}_{{l-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}}\\right) = k$.\nFor $1\\leq i\\leq l-1$, in the $i$-th iteration, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}$. Thus, ${s_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right) + 1$. Further, vectors in ${\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}\\setminus{S}_{{i-1}}$ are such that they yield a (possibly zero) vector in ${\\langle {{S}_{{i-1}}} \\rangle}$. Therefore, for $1\\leq i\\leq l-1$, we get ${t_i} \\leq {s_i} - 1 \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. \nIn the last step $l$, we add ${\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)'}} \\subset {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}$. This increments $\\textsf{rank}\\left({{S}}\\right)$ by $t_l \\geq 1$ (since $\\textsf{rank}\\left({{S}_{{l-1}}}\\right)\\leq k - 2$), and $|{S}|$ by $s_l \\geq t_l$. Therefore, we have\n\n", "index": 25, "text": "\\begin{equation}\n\\label{eq:S-case-2}\n|{S}| = \\sum_{i = 1}^{l}{s_i} \\geq \\sum_{i = 1}^{l-1}({t_i} +1) + t_l = k - 1 + l - 1,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"|{S}|=\\sum_{i=1}^{l}{s_{i}}\\geq\\sum_{i=1}^{l-1}({t_{i}}+1)+t_{l}=k-1+l-1,\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>s</mi><mi>i</mi></msub></mrow><mo>\u2265</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>l</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msub><mi>t</mi><mi>l</mi></msub></mrow><mo>=</mo><mrow><mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo>+</mo><mi>l</mi></mrow><mo>-</mo><mn>1</mn></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\nNote that we have {\\it split} the parity ${\\mathbf{{p}}}_{{0}}$ into $\\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ parities. Therefore, $n = k+d-2+\\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$. It is easy to verify that parity splitting does not affect the distance, and hence, the code ${\\mathcal{C}}$ has distance $d$. Since ${\\mathcal{C}^{'}}$ is an MDS code, we have $\\textsf{wt}\\left({{\\mathbf{{p}}}_{{0}}}\\right) = k$. Therefore, a set of ${k_{{{j_{{p}}}}}}$ information coordinates and $\\left\\lceil{\\frac{{k_{{{j_{{p}}}}}}}{{j_{{p}}}}}\\right\\rceil$ parity coordinates  have locality at most ${j_{{p}}}$ for each $p\\in[m]$. Similar to the classical Pyramid codes in~\\cite{Huang:07}, the last $d-2$ parity symbols may have locality as large as $k$. \n\n\\section{Codes with Unequal All Symbol Locality}\n\\label{sec:all-symbol}\nIn this section, we extend the notion of information locality to profile to accommodate the codes whose parity symbols also have locality constraints. In this case, code symbols can be partitioned into disjoint subsets according to their locality, with maximum locality ${r_a} < k$. We define {\\it all symbol locality profile} of a code as follows.\n\n\\begin{definition}\n\\label{def:loc-prof}\n[All Symbol Locality Profile] Given an ${[n,k,d]_q}$ code ${\\mathcal{C}}$, the all symbol locality profile of ${\\mathcal{C}}$ is defined as a length-$n$ vector ${\\mathbf{{r}}}({\\mathcal{C}}) = \\{r_1,\\ldots,r_n\\}$, where $r_i$ is the locality of the $i$-th  coordinate of ${\\mathcal{C}}$. Note that $1\\leq {r_i} \\leq k$ for each $i\\in[n]$, assuming $d\\geq 2$. \n\nAlternatively, we can specify the locality profile of ${\\mathcal{C}}$ as a length-${r_a}$ vector ${\\mathbf{{n}}}({\\mathcal{C}}) = \\{{n_{{1}}}, \\ldots, {n_{{{r_a}}}}\\}$, where ${r_a} = \\max\\{r_1, \\ldots, r_n\\}$ and ${n_{{j}}}$ is the number of information coordinates of locality $j$ for $j\\in[{r_a}]$. Note that $\\forall j\\in[{r_a}]$, $0\\leq {n_{{j}}}\\leq n$, ${n_{{{r_a}}}} \\geq 1$ and $\\sum_{j=1}^{{r_a}} {n_{{j}}} = n$. \n\\end{definition}\n\n\\begin{remark}\n\\label{rem:loc-prof}\nFor a code ${\\mathcal{C}}$ with representation ${C}$, let ${C_{{j}}}\\subset{C}$ be the subset of coordinates having locality $j$ for $1\\leq j\\leq {r_a}$. If ${n_{{j}}} = 0$ for some $j$, then we set ${C_{{j}}} = \\emptyset$. For $1\\leq j\\leq {r_a}$, we define \n\n", "itemtype": "equation", "pos": 29575, "prevtext": "\nthe last equality follows from~\\eqref{eq:S-l-total-rank}.  \n\n{\\it Lower bounding the number of iterations.} Similar to Case 1, in each iteration $i$ (including the last one), we have ${t_i} \\leq \\textsf{Loc}\\left({{{\\mathbf{{c}}}_i}}\\right)$. The only difference from Case 1 is that ${S}$ accumulates total rank of $k$ instead of $k-1$. Therefore, to lower bound $l$, we can use the same arguments as in Case 1 along with $\\textsf{rank}\\left({{S}_{{l}}}\\right)=k$ to obtain $l \\geq \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil + \\left\\lceil{\\frac{{k_{{r}}}}{r}}\\right\\rceil$ in place of~\\eqref{eq:l-LB-case-1}. Substituting this into~\\eqref{eq:S-case-2} yields $|{S}| \\geq k - 2 + \\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ (which is same as~\\eqref{eq:S-case-1-final}).\n\nFinally, noting that  $|{S}| \\leq n - d$ from Fact~\\ref{fact} and using this lower bound on $|{S}|$ gives~\\eqref{eq:dist-bound-info-loc}.\n\\end{proof}\n\n\\subsection{Code Construction: Pyramid Codes}\n\\label{sec:pyramid-codes}\nWe show that the {\\it parity splitting} construction of the Pyramid codes~\\cite{Huang:07} can be adapted to obtain codes with unequal information locality, that are optimal with respect to~\\eqref{eq:dist-bound-info-loc}. Consider an information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}},\\ldots,{k_{{r}}}\\}$. Let $\\{{j_{{1}}},\\ldots,{j_{{m}}}\\}$ with ${j_{{1}}} < \\cdots < {j_{{m}}}$ be the $m (\\leq r)$ localities such that ${k_{{{j_{{p}}}}}} > 0$. We begin with a $(k+d-1,k,d)$ systematic maximum distance separable (MDS) code ${\\mathcal{C}^{'}}$. Let the representing coordinates be ${C^{'}} = \\{{\\mathbf{{e}}}_{{1}},\\ldots,{\\mathbf{{e}}}_{{k}},{\\mathbf{{p}}}_{{0}},\\ldots,{\\mathbf{{p}}}_{{d-2}}\\}$, where ${\\mathbf{{e}}}_{{j}}$ is the $j$-th column of a $k\\times k$ identity matrix, and ${\\mathbf{{p}}}_{{j}}$ for $0\\leq j\\leq d-2$ are the columns representing the parity coordinates. \n\nWe partition the set $[k]$ into $m$ disjoint subsets ${S}_{{1}}, \\ldots, {S}_{{m}}$ such that $|{S}_{{p}}| = {k_{{{j_{{p}}}}}}$ for each $p\\in[m]$. Next, partition each subset ${S}_{{p}}$ into ${l_{{p}}} = \\left\\lceil{\\frac{{k_{{{j_{{p}}}}}}}{{j_{{p}}}}}\\right\\rceil$ disjoint subsets each of size at most ${j_{{p}}}$. That is, ${S}_{{p}} = \\cup_{i=1}^{{l_{{p}}}}{S}_{{p,i}}$. For a vector ${\\mathbf{{x}}}$ of dimension $k$, and a set ${S}\\subseteq[k]$, let ${{{\\mathbf{{x}}}}|_{{{S}}}}$ denote the $|{S}|$-dimensional restriction of ${\\mathbf{{x}}}$ to the coordinates  in set ${S}$. Then, we define the systematic code ${\\mathcal{C}}$ with the following representation.\n\n", "index": 27, "text": "\\begin{equation}\n\\label{eq:pyramid-code}\n{C} = \\left\\{{\\mathbf{{e}}}_{{1}}, \\ldots, {\\mathbf{{e}}}_{{k}}, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{1,1}}}}}, \\ldots, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{1,{l_{{1}}}}}}}}, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{2,1}}}}}, \\ldots, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{2,{l_{{2}}}}}}}}, \\ldots, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{m,1}}}}}, \\ldots, {{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{m,{l_{{m}}}}}}}},{\\mathbf{{p}}}_{{1}},\\ldots,{\\mathbf{{p}}}_{{d-2}}\\right\\}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"{C}=\\left\\{{\\mathbf{{e}}}_{{1}},\\ldots,{\\mathbf{{e}}}_{{k}},{{{\\mathbf{{p}}}_{%&#10;{0}}}|_{{{S}_{{1,1}}}}},\\ldots,{{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{1,{l_{{1}}}}}}%&#10;}},{{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{2,1}}}}},\\ldots,{{{\\mathbf{{p}}}_{{0}}}|_{%&#10;{{S}_{{2,{l_{{2}}}}}}}},\\ldots,{{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{m,1}}}}},%&#10;\\ldots,{{{\\mathbf{{p}}}_{{0}}}|_{{{S}_{{m,{l_{{m}}}}}}}},{\\mathbf{{p}}}_{{1}},%&#10;\\ldots,{\\mathbf{{p}}}_{{d-2}}\\right\\}.\" display=\"block\"><mrow><mrow><mi>C</mi><mo>=</mo><mrow><mo>{</mo><msub><mi>\ud835\udc1e</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>k</mi></msub><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mn>1</mn><mo>,</mo><msub><mi>l</mi><mn>1</mn></msub></mrow></msub></msub><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mn>2</mn><mo>,</mo><msub><mi>l</mi><mn>2</mn></msub></mrow></msub></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mi>m</mi><mo>,</mo><mn>1</mn></mrow></msub></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mrow><msub><mi>\ud835\udc29</mi><mn>0</mn></msub><mo fence=\"true\" stretchy=\"false\">|</mo></mrow><msub><mi>S</mi><mrow><mi>m</mi><mo>,</mo><msub><mi>l</mi><mi>m</mi></msub></mrow></msub></msub><mo>,</mo><msub><mi>\ud835\udc29</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>\ud835\udc29</mi><mrow><mi>d</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nwhere we set ${C_{{0}}} = \\emptyset$. Define $r = \\max\\{j : {k_{{j}}} > 0\\}$. Then, $\\{{k_{{1}}}, \\ldots, {k_{{r}}}\\}$ can be considered as the information locality profile of ${\\mathcal{C}}$. Codes with the same all symbol locality profile can have different information locality profiles. \n\\end{remark}\n\n\\subsection{Bound on the Minimum Distance}\n\\label{sec:all-sym- dist-bound}\n\nNote that codes with unequal localities for all symbols are a special class of codes with unequal information localities. Therefore, the minimum distance upper bound in~\\eqref{eq:dist-bound-info-loc} holds for an all symbol locality code having information locality profile ${\\mathbf{{k}}}$. As noted in Remark~\\ref{rem:loc-prof}, it is possible for a code to have different information locality profiles for a given all symbol locality profile. The upper bound in~\\eqref{eq:dist-bound-info-loc} obtained using only information locality profile may not be tight for certain information localities. Our goal is to compute an upper bound on the minimum distance as a function of all symbol locality profile. \n\n\\begin{theorem}\n\\label{thm:all-symbol-loc-bound}\nConsider a code ${\\mathcal{C}}$ with all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$. Define ${k}^{'}_{{j}} = {n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$. Let $r' = \\max\\{1\\leq i \\leq {r_a} : \\sum_{j=1}^{i}{k}^{'}_{{j}} < k\\}$. Let $r = \\min\\{r'+1\\leq j\\leq {r_a} : {n_{{j}}}\\geq 2\\}$. Then, we have\n\n", "itemtype": "equation", "pos": 32416, "prevtext": "\n\nNote that we have {\\it split} the parity ${\\mathbf{{p}}}_{{0}}$ into $\\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ parities. Therefore, $n = k+d-2+\\sum_{j=1}^{r}\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$. It is easy to verify that parity splitting does not affect the distance, and hence, the code ${\\mathcal{C}}$ has distance $d$. Since ${\\mathcal{C}^{'}}$ is an MDS code, we have $\\textsf{wt}\\left({{\\mathbf{{p}}}_{{0}}}\\right) = k$. Therefore, a set of ${k_{{{j_{{p}}}}}}$ information coordinates and $\\left\\lceil{\\frac{{k_{{{j_{{p}}}}}}}{{j_{{p}}}}}\\right\\rceil$ parity coordinates  have locality at most ${j_{{p}}}$ for each $p\\in[m]$. Similar to the classical Pyramid codes in~\\cite{Huang:07}, the last $d-2$ parity symbols may have locality as large as $k$. \n\n\\section{Codes with Unequal All Symbol Locality}\n\\label{sec:all-symbol}\nIn this section, we extend the notion of information locality to profile to accommodate the codes whose parity symbols also have locality constraints. In this case, code symbols can be partitioned into disjoint subsets according to their locality, with maximum locality ${r_a} < k$. We define {\\it all symbol locality profile} of a code as follows.\n\n\\begin{definition}\n\\label{def:loc-prof}\n[All Symbol Locality Profile] Given an ${[n,k,d]_q}$ code ${\\mathcal{C}}$, the all symbol locality profile of ${\\mathcal{C}}$ is defined as a length-$n$ vector ${\\mathbf{{r}}}({\\mathcal{C}}) = \\{r_1,\\ldots,r_n\\}$, where $r_i$ is the locality of the $i$-th  coordinate of ${\\mathcal{C}}$. Note that $1\\leq {r_i} \\leq k$ for each $i\\in[n]$, assuming $d\\geq 2$. \n\nAlternatively, we can specify the locality profile of ${\\mathcal{C}}$ as a length-${r_a}$ vector ${\\mathbf{{n}}}({\\mathcal{C}}) = \\{{n_{{1}}}, \\ldots, {n_{{{r_a}}}}\\}$, where ${r_a} = \\max\\{r_1, \\ldots, r_n\\}$ and ${n_{{j}}}$ is the number of information coordinates of locality $j$ for $j\\in[{r_a}]$. Note that $\\forall j\\in[{r_a}]$, $0\\leq {n_{{j}}}\\leq n$, ${n_{{{r_a}}}} \\geq 1$ and $\\sum_{j=1}^{{r_a}} {n_{{j}}} = n$. \n\\end{definition}\n\n\\begin{remark}\n\\label{rem:loc-prof}\nFor a code ${\\mathcal{C}}$ with representation ${C}$, let ${C_{{j}}}\\subset{C}$ be the subset of coordinates having locality $j$ for $1\\leq j\\leq {r_a}$. If ${n_{{j}}} = 0$ for some $j$, then we set ${C_{{j}}} = \\emptyset$. For $1\\leq j\\leq {r_a}$, we define \n\n", "index": 29, "text": "\\begin{equation}\n\\label{eq:k-j}\n{k_{{j}}} =  \\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"{k_{{j}}}=\\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right)-\\textsf{rank}%&#10;\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right),\" display=\"block\"><mrow><mrow><msub><mi>k</mi><mi>j</mi></msub><mo>=</mo><mrow><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mo>\u222a</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>j</mi></msubsup><msub><mi>C</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow><mo>-</mo><mrow><mtext>\ud835\uddcb\ud835\uddba\ud835\uddc7\ud835\uddc4</mtext><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mo>\u222a</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msub><mi>C</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\\end{theorem}\n\\begin{proof}\nSimilar to information locality case, we consider Algorithm~\\ref{alg:find-S} to find a set ${S}\\subset{C}$ such that $\\textsf{rank}\\left({{S}}\\right)\\leq k-1$. \n\nRecall that ${C_{{j}}}\\subset{C}$ is a subset of coordinates of locality $j$. Let ${k_{{j}}} = \\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right)$, where we define ${C_{{0}}} = \\emptyset$. \n\nIt is easy to show that ${k_{{j}}} \\leq {k}^{'}_{{j}}$ for each $1\\leq j\\leq r$. In particular, consider the following greedy algorithm. Beginning with ${T}_{{0}}=\\emptyset$ until ${T}_{{p}} = {C}{j}$, in each iteration $p$, extend ${T}_{{p-1}}$ as by adding a coordinate ${\\mathbf{{c}}}_p\\in{C_{{j}}}\\setminus{T}_{{p-1}}$ and all its repair group coordinates ${\\mathbf{{c}}}_{{{R}_{{}}\\left({p}\\right)}}$ to ${T}_{{p-1}}$. Specifically, ${T}_{{p}} = {T}_{{p-1}}\\cup({\\mathbf{{c}}}_{{\\Gamma\\left({p}\\right)}}\\setminus{T}_{{p-1}})$. Now, in each iteration there must be at least one linear dependency between ${T}_{{p-1}}$ and ${\\mathbf{{c}}}_{{\\Gamma\\left({p}\\right)}}\\setminus{T}_{{p-1}}$. Further, in each iteration, we extend the size of ${T}$ by at most $j$,  and thus, the number of iterations are at least $\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$. Therefore, the number of linear dependencies among the coordinates in ${C_{{j}}}$ must be at least $\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$.\n\n{\\it Case 1:} Suppose we have $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) \\leq k-1$ throughout. Let $m$ be the locality of the last symbol picked by the algorithm. For $1\\leq j\\leq m-1$, the algorithm collects all the coordinates of locality $j$. Let ${\\hat{n}_{{m}}}\\leq{n_{{m}}}$ be the number of coordinates of locality $m$ that are collected by the algorithm. Then, we have\n\n", "itemtype": "equation", "pos": 34074, "prevtext": "\nwhere we set ${C_{{0}}} = \\emptyset$. Define $r = \\max\\{j : {k_{{j}}} > 0\\}$. Then, $\\{{k_{{1}}}, \\ldots, {k_{{r}}}\\}$ can be considered as the information locality profile of ${\\mathcal{C}}$. Codes with the same all symbol locality profile can have different information locality profiles. \n\\end{remark}\n\n\\subsection{Bound on the Minimum Distance}\n\\label{sec:all-sym- dist-bound}\n\nNote that codes with unequal localities for all symbols are a special class of codes with unequal information localities. Therefore, the minimum distance upper bound in~\\eqref{eq:dist-bound-info-loc} holds for an all symbol locality code having information locality profile ${\\mathbf{{k}}}$. As noted in Remark~\\ref{rem:loc-prof}, it is possible for a code to have different information locality profiles for a given all symbol locality profile. The upper bound in~\\eqref{eq:dist-bound-info-loc} obtained using only information locality profile may not be tight for certain information localities. Our goal is to compute an upper bound on the minimum distance as a function of all symbol locality profile. \n\n\\begin{theorem}\n\\label{thm:all-symbol-loc-bound}\nConsider a code ${\\mathcal{C}}$ with all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$. Define ${k}^{'}_{{j}} = {n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$. Let $r' = \\max\\{1\\leq i \\leq {r_a} : \\sum_{j=1}^{i}{k}^{'}_{{j}} < k\\}$. Let $r = \\min\\{r'+1\\leq j\\leq {r_a} : {n_{{j}}}\\geq 2\\}$. Then, we have\n\n", "index": 31, "text": "\\begin{equation}\n\\label{eq:all-symbol-loc-bound}\nd \\leq n - k + 2 - \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil - \\left\\lceil{\\frac{k - \\sum_{i=1}^{r-1}\\left({n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"d\\leq n-k+2-\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil-%&#10;\\left\\lceil{\\frac{k-\\sum_{i=1}^{r-1}\\left({n_{{j}}}-\\left\\lceil{\\frac{{n_{{j}}%&#10;}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2264</mo><mrow><mrow><mrow><mi>n</mi><mo>-</mo><mi>k</mi></mrow><mo>+</mo><mn>2</mn></mrow><mo>-</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>-</mo><mrow><mo>\u2308</mo><mfrac><mrow><mi>k</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mrow><mo>(</mo><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>-</mo><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \nNote that $\\textsf{rank}\\left({{S}}\\right)$ when ${S}$ has accumulated all the coordinates of locality up to $m-1$ is $\\textsf{rank}\\left({\\cup_{j=1}^{m-1}{C_{{j}}}}\\right) = \\sum_{j=1}^{m-1}{k_{{j}}}$. Therefore, the rank accumulated from locality $m$ coordinates is $(k-1)-\\sum_{j=1}^{m-1}{k_{{j}}} :={\\hat{k}_{{m}}}$. Now, using standard arguments similar to the proof of Theorem~\\ref{thm:dist-bound-info-loc}, it is easy to show that ${\\hat{n}_{{m}}} \\geq {\\hat{k}_{{m}}} + \\left\\lceil{\\frac{{\\hat{k}_{{m}}}}{m}}\\right\\rceil$. Therefore,\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\end{theorem}\n\\begin{proof}\nSimilar to information locality case, we consider Algorithm~\\ref{alg:find-S} to find a set ${S}\\subset{C}$ such that $\\textsf{rank}\\left({{S}}\\right)\\leq k-1$. \n\nRecall that ${C_{{j}}}\\subset{C}$ is a subset of coordinates of locality $j$. Let ${k_{{j}}} = \\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right)$, where we define ${C_{{0}}} = \\emptyset$. \n\nIt is easy to show that ${k_{{j}}} \\leq {k}^{'}_{{j}}$ for each $1\\leq j\\leq r$. In particular, consider the following greedy algorithm. Beginning with ${T}_{{0}}=\\emptyset$ until ${T}_{{p}} = {C}{j}$, in each iteration $p$, extend ${T}_{{p-1}}$ as by adding a coordinate ${\\mathbf{{c}}}_p\\in{C_{{j}}}\\setminus{T}_{{p-1}}$ and all its repair group coordinates ${\\mathbf{{c}}}_{{{R}_{{}}\\left({p}\\right)}}$ to ${T}_{{p-1}}$. Specifically, ${T}_{{p}} = {T}_{{p-1}}\\cup({\\mathbf{{c}}}_{{\\Gamma\\left({p}\\right)}}\\setminus{T}_{{p-1}})$. Now, in each iteration there must be at least one linear dependency between ${T}_{{p-1}}$ and ${\\mathbf{{c}}}_{{\\Gamma\\left({p}\\right)}}\\setminus{T}_{{p-1}}$. Further, in each iteration, we extend the size of ${T}$ by at most $j$,  and thus, the number of iterations are at least $\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$. Therefore, the number of linear dependencies among the coordinates in ${C_{{j}}}$ must be at least $\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$.\n\n{\\it Case 1:} Suppose we have $\\textsf{rank}\\left({{S}_{{i-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({i}\\right)}}}\\right) \\leq k-1$ throughout. Let $m$ be the locality of the last symbol picked by the algorithm. For $1\\leq j\\leq m-1$, the algorithm collects all the coordinates of locality $j$. Let ${\\hat{n}_{{m}}}\\leq{n_{{m}}}$ be the number of coordinates of locality $m$ that are collected by the algorithm. Then, we have\n\n", "index": 33, "text": "$$ |{S}| = {n_{{1}}} + \\cdots + {n_{{m-1}}} + {\\hat{n}_{{m}}}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"|{S}|={n_{{1}}}+\\cdots+{n_{{m-1}}}+{\\hat{n}_{{m}}}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>+</mo><msub><mi>n</mi><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">^</mo></mover><mi>m</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\nNext, we show that $|{S}|_{LB}$ is minimized when ${k_{{j}}} = {k}^{'}_{{j}}$. Let ${S^{'}}$ be the set collected if $\\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right) = {k}^{'}_{{j}}$. In this case the locality of the last coordinate must be $r$ provided $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} < k-1$. Let ${\\hat{n}'_{{r}}}$ be the number of coordinates of locality $r$ that are collected by the algorithm. (If $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} = k-1$, then ${\\hat{n}'_{{r}}}=0$ and the following analysis still holds.) Then, we have\n\n", "itemtype": "equation", "pos": 36830, "prevtext": " \nNote that $\\textsf{rank}\\left({{S}}\\right)$ when ${S}$ has accumulated all the coordinates of locality up to $m-1$ is $\\textsf{rank}\\left({\\cup_{j=1}^{m-1}{C_{{j}}}}\\right) = \\sum_{j=1}^{m-1}{k_{{j}}}$. Therefore, the rank accumulated from locality $m$ coordinates is $(k-1)-\\sum_{j=1}^{m-1}{k_{{j}}} :={\\hat{k}_{{m}}}$. Now, using standard arguments similar to the proof of Theorem~\\ref{thm:dist-bound-info-loc}, it is easy to show that ${\\hat{n}_{{m}}} \\geq {\\hat{k}_{{m}}} + \\left\\lceil{\\frac{{\\hat{k}_{{m}}}}{m}}\\right\\rceil$. Therefore,\n\n", "index": 35, "text": "\\begin{equation}\n\\label{eq:S-LB-1}\n|{S}| \\geq \\sum_{j=1}^{m-1} {n_{{j}}}+ {\\hat{k}_{{m}}} + \\left\\lceil{\\frac{{\\hat{k}_{{m}}}}{m}}\\right\\rceil := |{S}|_{LB}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"|{S}|\\geq\\sum_{j=1}^{m-1}{n_{{j}}}+{\\hat{k}_{{m}}}+\\left\\lceil{\\frac{{\\hat{k}_%&#10;{{m}}}}{m}}\\right\\rceil:=|{S}|_{LB}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>\u2265</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>m</mi></msub><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>m</mi></msub><mi>m</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>:=</mo><msub><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mrow><mi>L</mi><mo>\u2062</mo><mi>B</mi></mrow></msub></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nThe rank accumulated in locality $r$ coordinates is $(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}} :={\\hat{k}'_{{r}}}$. Again, using standard arguments similar to the proof of Theorem~\\ref{thm:dist-bound-info-loc}, it is easy to show that ${\\hat{n}'_{{r}}} \\geq {\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil$. Therefore,\n\n", "itemtype": "equation", "pos": 37586, "prevtext": "\n\nNext, we show that $|{S}|_{LB}$ is minimized when ${k_{{j}}} = {k}^{'}_{{j}}$. Let ${S^{'}}$ be the set collected if $\\textsf{rank}\\left({\\cup_{i=0}^{j}{C_{{i}}}}\\right) - \\textsf{rank}\\left({\\cup_{i=0}^{j-1}{C_{{i}}}}\\right) = {k}^{'}_{{j}}$. In this case the locality of the last coordinate must be $r$ provided $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} < k-1$. Let ${\\hat{n}'_{{r}}}$ be the number of coordinates of locality $r$ that are collected by the algorithm. (If $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} = k-1$, then ${\\hat{n}'_{{r}}}=0$ and the following analysis still holds.) Then, we have\n\n", "index": 37, "text": "$$|{S^{'}}| = {n_{{1}}} + \\ldots + {n_{{r-1}}} + {\\hat{n}_{{r}}}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"|{S^{{}^{\\prime}}}|={n_{{1}}}+\\ldots+{n_{{r-1}}}+{\\hat{n}_{{r}}}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>S</mi><msup><mi/><mo>\u2032</mo></msup></msup><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mi mathvariant=\"normal\">\u2026</mi><mo>+</mo><msub><mi>n</mi><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\nNext, we show that $|{S^{'}}|_{LB} \\leq |{S}|_{LB}$. Suppose, for contradiction, $|{S^{'}}|_{LB} > |{S}|_{LB}$. First, note that since ${k}^{'}_{{j}} \\geq kj{j}$ for $1\\leq j\\leq r$, we have $r\\leq m$. \n\nCase (1a): $m = r$. Then, we have\n\n", "itemtype": "equation", "pos": 37990, "prevtext": "\nThe rank accumulated in locality $r$ coordinates is $(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}} :={\\hat{k}'_{{r}}}$. Again, using standard arguments similar to the proof of Theorem~\\ref{thm:dist-bound-info-loc}, it is easy to show that ${\\hat{n}'_{{r}}} \\geq {\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil$. Therefore,\n\n", "index": 39, "text": "\\begin{equation}\n\\label{eq:S-LB-2}\n|{S^{'}}| \\geq \\sum_{j=1}^{r-1} {n_{{j}}}+ {\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil := |{S^{'}}|_{LB}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"|{S^{{}^{\\prime}}}|\\geq\\sum_{j=1}^{r-1}{n_{{j}}}+{\\hat{k}^{\\prime}_{{r}}}+%&#10;\\left\\lceil{\\frac{{\\hat{k}^{\\prime}_{{r}}}}{r}}\\right\\rceil:=|{S^{{}^{\\prime}}%&#10;}|_{LB}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>S</mi><msup><mi/><mo>\u2032</mo></msup></msup><mo stretchy=\"false\">|</mo></mrow><mo>\u2265</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>:=</mo><msub><mrow><mo stretchy=\"false\">|</mo><msup><mi>S</mi><msup><mi/><mo>\u2032</mo></msup></msup><mo stretchy=\"false\">|</mo></mrow><mrow><mi>L</mi><mo>\u2062</mo><mi>B</mi></mrow></msub></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nHowever, this essentially implies $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} < \\sum_{j=1}^{r-1}{k_{{j}}}$, which is a contradiction.\n\nCase (1b): $m < r$. Then, we have\n\n", "itemtype": "equation", "pos": 38412, "prevtext": "\n\nNext, we show that $|{S^{'}}|_{LB} \\leq |{S}|_{LB}$. Suppose, for contradiction, $|{S^{'}}|_{LB} > |{S}|_{LB}$. First, note that since ${k}^{'}_{{j}} \\geq kj{j}$ for $1\\leq j\\leq r$, we have $r\\leq m$. \n\nCase (1a): $m = r$. Then, we have\n\n", "index": 41, "text": "$$\\sum_{j=1}^{r-1} {n_{{j}}}+ {\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil > \\sum_{j=1}^{r-1} {n_{{j}}}+ {\\hat{k}_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\sum_{j=1}^{r-1}{n_{{j}}}+{\\hat{k}^{\\prime}_{{r}}}+\\left\\lceil{\\frac{{\\hat{k}^%&#10;{\\prime}_{{r}}}}{r}}\\right\\rceil&gt;\\sum_{j=1}^{r-1}{n_{{j}}}+{\\hat{k}_{{r}}}+%&#10;\\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>&gt;</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi></msub><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi></msub><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nHowever, this implies ${\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil > {n_{{r}}} + \\cdots + {\\hat{k}_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil$, which is a contradiction as ${\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil \\leq {\\hat{n}'_{{r}}} \\leq {n_{{r}}}$.\n\nHence, to get smallest lower bound on $|{S}|$, one can assign maximum incremental rank ${k}^{'}_{{j}}$ to each locality $j$. Let ${l_{{j}}}$ be the number of iterations during which Algorithm~\\ref{alg:find-S} collects coordinates of locality $j$. Then, using the same arguments as in the proof of Theorem~\\ref{thm:dist-bound-info-loc}, we have $|{S}| \\geq k - 1 + \\sum_{j=1}^{r}{l_{{j}}}$ (see~\\eqref{eq:S-case-1}). For $1\\leq j\\leq r-1$, the algorithm collects all the ${n_{{j}}}$ coordinates of locality $j$. When a coordinate of locality $j$ is picked, the size of ${S}$ can be increased by at most $j+1$ in that iteration. Thus, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$ for $1\\leq j \\leq r-1$. For locality $r$, we increment the rank of ${S}$ by $(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}$. At each step, tank is increased by at most $r$, thus ${l_{{r}}} \\geq \\left\\lceil{\\frac{(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil$. Hence,\n\n", "itemtype": "equation", "pos": 38771, "prevtext": "\nHowever, this essentially implies $\\sum_{j=1}^{r-1}{k}^{'}_{{j}} < \\sum_{j=1}^{r-1}{k_{{j}}}$, which is a contradiction.\n\nCase (1b): $m < r$. Then, we have\n\n", "index": 43, "text": "$$\\sum_{j=1}^{r-1} {n_{{j}}}+ {\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil > \\sum_{j=1}^{r-1} {n_{{j}}}+ {n_{{r}}} + \\cdots + {\\hat{k}_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\sum_{j=1}^{r-1}{n_{{j}}}+{\\hat{k}^{\\prime}_{{r}}}+\\left\\lceil{\\frac{{\\hat{k}^%&#10;{\\prime}_{{r}}}}{r}}\\right\\rceil&gt;\\sum_{j=1}^{r-1}{n_{{j}}}+{n_{{r}}}+\\cdots+{%&#10;\\hat{k}_{{r}}}+\\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msubsup><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi><mo>\u2032</mo></msubsup><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>&gt;</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>n</mi><mi>j</mi></msub></mrow><mo>+</mo><msub><mi>n</mi><mi>r</mi></msub><mo>+</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>+</mo><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi></msub><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msub><mover accent=\"true\"><mi>k</mi><mo stretchy=\"false\">^</mo></mover><mi>r</mi></msub><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\n\n{\\it Case 2:} In the last step, we get $\\textsf{rank}\\left({{S}_{{l-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}}\\right) = k$. Analysis to show that the smallest lower bound on $|{S}|$ is obtained assigning maximum incremental rank ${k}^{'}_{{j}}$ to each locality $j$is similar to Case 1. \n\nUsing the same arguments as in the proof of Theorem~\\ref{thm:dist-bound-info-loc}, we have $|{S}| \\geq k - 2 + \\sum_{j=1}^{r}{l_{{j}}}$ (see~\\eqref{eq:S-case-2}). Following the same argument as Case 1, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$ for $1\\leq j \\leq r-1$. For locality $r$, we increment the rank of ${S}$ by $k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}$. At each step, tank is increased by at most $r$, thus ${l_{{r}}} \\geq \\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil$. Hence,\n\n", "itemtype": "equation", "pos": 40284, "prevtext": "\nHowever, this implies ${\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil > {n_{{r}}} + \\cdots + {\\hat{k}_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}_{{r}}}}{r}}\\right\\rceil$, which is a contradiction as ${\\hat{k}'_{{r}}} + \\left\\lceil{\\frac{{\\hat{k}'_{{r}}}}{r}}\\right\\rceil \\leq {\\hat{n}'_{{r}}} \\leq {n_{{r}}}$.\n\nHence, to get smallest lower bound on $|{S}|$, one can assign maximum incremental rank ${k}^{'}_{{j}}$ to each locality $j$. Let ${l_{{j}}}$ be the number of iterations during which Algorithm~\\ref{alg:find-S} collects coordinates of locality $j$. Then, using the same arguments as in the proof of Theorem~\\ref{thm:dist-bound-info-loc}, we have $|{S}| \\geq k - 1 + \\sum_{j=1}^{r}{l_{{j}}}$ (see~\\eqref{eq:S-case-1}). For $1\\leq j\\leq r-1$, the algorithm collects all the ${n_{{j}}}$ coordinates of locality $j$. When a coordinate of locality $j$ is picked, the size of ${S}$ can be increased by at most $j+1$ in that iteration. Thus, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$ for $1\\leq j \\leq r-1$. For locality $r$, we increment the rank of ${S}$ by $(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}$. At each step, tank is increased by at most $r$, thus ${l_{{r}}} \\geq \\left\\lceil{\\frac{(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil$. Hence,\n\n", "index": 45, "text": "$$|{S}| \\geq k - 1 + \\sum_{j=1}^{r-1} \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil + \\left\\lceil{\\frac{(k-1)-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil \\geq k - 2 + \\sum_{j=1}^{r-1} \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil + \\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"|{S}|\\geq k-1+\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil+%&#10;\\left\\lceil{\\frac{(k-1)-\\sum_{j=1}^{r-1}{k}^{{}^{\\prime}}_{{j}}}{r}}\\right%&#10;\\rceil\\geq k-2+\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil+%&#10;\\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{{}^{\\prime}}_{{j}}}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>\u2265</mo><mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>+</mo><mrow><mo>\u2308</mo><mfrac><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msubsup><mi>k</mi><mi>j</mi><msup><mi/><mo>\u2032</mo></msup></msubsup></mrow></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>\u2265</mo><mrow><mrow><mi>k</mi><mo>-</mo><mn>2</mn></mrow><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>+</mo><mrow><mo>\u2308</mo><mfrac><mrow><mi>k</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msubsup><mi>k</mi><mi>j</mi><msup><mi/><mo>\u2032</mo></msup></msubsup></mrow></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": "\nFinally, the result follows from using the Fact~\\ref{fact}.\n\\end{proof}\n\n\\subsection{Code Construction}\n\\label{sec:codes-all-symbol}\nWe adapt the rank-metric codes based LRC construction in~\\cite{Silberstein:13} for the unequal all symbol locality scenario. The idea is to first precode the information symbols with a rank-metric code (in particular, with Gabidulin codes), and then use maximum distance separable (MDS) codes to obtain local parities. We begin with a brief review of rank-metric codes.\n\n\\subsection{Rank-Metric Codes}\n\\label{sec:rank-metric}\nLet ${\\mathbb{F}_{{q}}^{N\\times m}}$ be the set of all $N\\times m$ matrices over ${\\mathbb{F}_{{q}}}$. The {\\it rank distance} is a distance measure between elements $A$ and $B$ of ${\\mathbb{F}_{{q}}^{N\\times m}}$ defined as $d_R\\left({A},{B}\\right) = \\textsf{rank}\\left({A-B}\\right)$. It can be shown that the rank distance is indeed a metric~\\cite{Gabidulin:85}. A rank-metric code is a non-empty subset of ${\\mathbb{F}_{{q}}^{N\\times m}}$ under the context of the rank metric. \n\nTypically, the rank-metric codes are considered by leveraging the correspondence between ${\\mathbb{F}_{{q}}}^{1\\times m}$ and an extension field ${\\mathbb{F}_{{{q}}^m}}$. By fixing a basis for ${\\mathbb{F}_{{{q}}^m}}$ as an $m$-dimensional vector space over ${\\mathbb{F}_{{q}}}$, any element of ${\\mathbb{F}_{{{q}}^m}}$ can be represented as an $m$-length vector over ${\\mathbb{F}_{{q}}}$. Similarly, any $N$-length vector over ${\\mathbb{F}_{{{q}}^m}}$ can be represented as an $N\\times m$ matrix over ${\\mathbb{F}_{{q}}}$. The rank of a vector $A\\in{\\mathbb{F}_{{{q}}^m}}^N$ is the rank of $A$ as an $N\\times m$ matrix over ${\\mathbb{F}_{{q}}}$, which also works for the rank distance. This correspondence allows us to view a rank-metric code in ${\\mathbb{F}_{{q}}^{N\\times m}}$ as a block code of length $N$ over ${\\mathbb{F}_{{{q}}^m}}$. \n\nFocussing on linear codes, an $(N,K,D)$ rank-metric code ${\\mathcal{C}}\\subseteq{\\mathbb{F}_{{{q}}^m}}^N$ is a linear block code over ${\\mathbb{F}_{{{q}}^m}}$ of length $N$, dimension $K$, and minimum rank distance $D$. For such codes, the Singleton bound becomes $d\\leq \\min\\left\\{1,\\frac{m}{N}\\right\\}(N-K)+1$ (see~\\cite{Gabidulin:85}). Codes that achieve this bound are called as maximum-rank distance (MRD) codes. Note that, for $m\\geq N$, the Singleton bound for rank metric coincides with the classical Singleton bound for the Hamming metric. Indeed, when $m\\geq N$, every MRD code is also MDS,  and hence can correct any $d-1$ {\\it rank erasures}. \n\n{\\bf Gabidulin Codes:} For $N\\geq m$, a class of MRD codes was presented in~\\cite{Gabidulin:85} by Gabidulin (see also~\\cite{Delsarte:78}). \nA Gabidulin code can be obtained by evaluation of {\\it linearized polynomials} defined as follows. A linearized polynomial $f(x)$ over ${\\mathbb{F}_{{{q}}^m}}$ of $q$-degree $K$ has the form $f(x) = \\sum_{i=0}^{K} a_i x^{q^i}$, where $a_i\\in{\\mathbb{F}_{{{q}}^m}}$ such that $a_K \\neq 0$. Evaluation of a linearized polynomial is an ${\\mathbb{F}_{{q}}}$-linear transform from ${\\mathbb{F}_{{{q}}^m}}$ to itself. In other words, for any $a,b \\in {\\mathbb{F}_{{q}}}$ and $x,y\\in{\\mathbb{F}_{{{q}}^m}}$, we have $f(ax+by) = af(x)+bf(y)$. \n\nA codeword in an $(N,K,N-K+1)$ Gabidulin code ${\\mathcal{C}}_{Gab}$ over ${\\mathbb{F}_{{{q}}^m}}$ for $m\\geq N$ is defined as ${\\mathbf{c}} = \\left(f(g_1),\\ldots,f(g_N)\\right) \\in {\\mathbb{F}_{{{q}}^m}}^N$, where $f(x)$ is a linearized polynomial over $GFm{q}$ of $q$-degree $K-1$ whose coefficients are information symbols, and evaluation points $g_1,\\ldots,g_N\\in{\\mathbb{F}_{{{q}}^m}}$ are linearly  independent over ${\\mathbb{F}_{{q}}}$. Note that since Gabidulin code is also an MDS code, it can correct any $N-K$ erasures.\n\n\\subsection{Code Construction}\n\\label{sec:construction}\nIn the following, we give a construction of an ${(n,k,d)}$ LRC with all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$ which attains the distance bound in~\\eqref{eq:all-symbol-loc-bound}. For the simplicity of presentation, we assume that $j+1\\mid{n_{{j}}}$ for each $j$. One can generalize the construction for the case when this is not the case.\n\n{\\bf Construction 1.} Consider a length-$k$ vector of information symbols ${\\mathbf{{m}}} \\in {\\mathbb{F}_{{{q}}^m}}^k$.  First, we precode ${\\mathbf{{m}}}$ using a Gabidulin code. Then, the codeword of the Gabidulin code is partitioned into local groups, and the local parities are computed for each group using MDS codes over ${\\mathbb{F}_{{q}}}$. The details are as follows.\n\nDefine ${N_{{j}}} = {n_{{j}}}\\left(\\frac{j}{j+1}\\right)$ for each $j\\in[{r_a}]$. Let $N = \\sum_{j=1}^{{r_a}}{N_{{j}}}$. Encode ${\\mathbf{{m}}}$ using an $(N,k,N-k+1)$ Gabidulin code to obtain ${\\mathbf{c}_{\\textrm{Gab}}}\\in{\\mathbb{F}_{{{q}}^m}}^N$. Partition ${\\mathbf{c}_{\\textrm{Gab}}}$ into ${r_a}$ disjoint groups ${\\mathbf{c}_{\\textrm{Gab}}} = \\cup_{j=1}^{{r_a}}{\\mathbf{c}_{\\textrm{Gab}}^{{j}}}$ such that $|{\\mathbf{c}_{\\textrm{Gab}}^{{j}}}| = {N_{{j}}}$ for $j\\in[{r_a}]$ with ${\\mathbf{c}_{\\textrm{Gab}}^{{j}}} = \\emptyset$ for each $j$ such that ${N_{{j}}} = 0$. For each $1\\leq j\\leq {r_a}$ such that ${N_{{j}}} > 0$, further partition ${\\mathbf{c}_{\\textrm{Gab}}^{{j}}}$ symbols into $\\frac{{N_{{j}}}}{j}$ disjoint local groups each of size $j$, {\\it i.e.}, ${\\mathbf{c}_{\\textrm{Gab}}}{j} = \\cup_{i=1}{\\frac{{N_{{j}}}}{j}}{\\mathbf{c}_{\\textrm{Gab}}^{{j,i}}}$. For each group ${\\mathbf{c}_{\\textrm{Gab}}^{{j,i}}}$ of $j$ symbols, generate a local parity using a $(j+1,j,2)$ MDS code over ${\\mathbb{F}_{{q}}}$. Denote the resulting code as ${\\mathcal{C}}_{\\textrm{LRC}}$. Note that the total number of symbols are $\\sum_{j=1}^{{r_a}}\\frac{{N_{{j}}}}{j}(j+1) = \\sum_{j=1}^{{r_a}}{n_{{j}}} = n$. Note that, we generate the local parities in such a way that ${\\mathcal{C}}_{\\textrm{LRC}}$ possesses all symbol locality profile $\\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$.\n\nNext, we show that the above construction achieves the distance bound mentioned in Theorem~\\ref{thm:all-symbol-loc-bound}.\n\\begin{theorem}\n\\label{thm:gabidulin-codes-based-LRC}\nLet ${\\mathcal{C}}_{\\textrm{LRC}}$ be an $(n,k,d)$ LRC with all symbol locality profile $\\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$ obtained by Construction 1. If $j+1\\mid{n_{{j}}}$ for each $j\\in[{r_a}]$, then ${\\mathcal{C}}_{\\textrm{LRC}}$ over ${\\mathbb{F}_{{{q}}^m}}$ for $m\\geq \\sum_{j=1}^{{r_a}}{n_{{j}}}\\left(\\frac{j}{j+1}\\right)$ and $q\\geq {r_a} + 1$, achieves the bound in~\\eqref{eq:all-symbol-loc-bound}.\n\\end{theorem}\n\\begin{proof}\nSimilar to~\\cite{Silberstein:13}, the idea is show that any $e : = n - k + 1 - \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil - \\left\\lceil{\\frac{k - \\sum_{i=1}^{r-1}\\left({n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil$ symbol erasures correspond to $N-K$ rank erasures, which can be corrected by the Gabidulin code. \n\nThe ${\\mathbb{F}_{{q}}}$-linearity of the linearized polynomials plays a crucial role. In particular, since the local parities are obtained using an MDS code over ${\\mathbb{F}_{{q}}}$, any symbol ${{\\mathbf{{c}}}_i}$ of locality $j$ can be written as ${{\\mathbf{{c}}}_i} = \\sum_{p=1}^{j} a_p{\\mathbf{c}}_{i_p} =  \\sum_{p=1}^{j} a_p f(g_{i_p}) = f\\left(\\sum_{p=1}^{j} a_p g_{i_p}\\right)$. Hence, for each $j\\in[{r_a}]$, in a local group of size $j$, any $m\\leq j$ symbols are evaluations of $f(x)$ in $m$ points that are linearly independent over ${\\mathbb{F}_{{q}}}$. Therefore, for each $j\\in[{r_a}]$, in a local group of size $j+1$, any $i+1 (\\leq j+1)$ symbol erasures correspond to $i$ rank erasures. Moreover, taking any $j$ points from all local groups of size $j+1$ for each $j\\in[{r_a}]$, we obtain the Gabidulin codeword, which has obtained by precoding ${\\mathbf{{m}}}$.\n\nWith above observation, the worst case erasure pattern is when the erasures occur in the smallest possible number of local groups (of possibly different localities), and the number of erasures in each local group are maximal.\n\nNote that we can write $n$ as $n = \\sum_{j=1}^{{r_a}}{N_{{j}}} + \\frac{{N_{{j}}}}{j}$. Let $k = \\sum_{j=1}^{r-1} {N_{{j}}} + {N^{'}_{{r}}}$ for some ${N^{'}_{{r}}} < {N_{{r}}}$. Then, we can write \n\n", "itemtype": "equation", "pos": 41412, "prevtext": "\n\n{\\it Case 2:} In the last step, we get $\\textsf{rank}\\left({{S}_{{l-1}} \\cup {\\mathbf{{c}}}_{{\\Gamma\\left({l}\\right)}}}\\right) = k$. Analysis to show that the smallest lower bound on $|{S}|$ is obtained assigning maximum incremental rank ${k}^{'}_{{j}}$ to each locality $j$is similar to Case 1. \n\nUsing the same arguments as in the proof of Theorem~\\ref{thm:dist-bound-info-loc}, we have $|{S}| \\geq k - 2 + \\sum_{j=1}^{r}{l_{{j}}}$ (see~\\eqref{eq:S-case-2}). Following the same argument as Case 1, ${l_{{j}}} \\geq \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil$ for $1\\leq j \\leq r-1$. For locality $r$, we increment the rank of ${S}$ by $k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}$. At each step, tank is increased by at most $r$, thus ${l_{{r}}} \\geq \\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil$. Hence,\n\n", "index": 47, "text": "$$|{S}| \\geq k - 2 + \\sum_{j=1}^{r-1} \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil + \\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{'}_{{j}}}{r}}\\right\\rceil.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"|{S}|\\geq k-2+\\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil+%&#10;\\left\\lceil{\\frac{k-\\sum_{j=1}^{r-1}{k}^{{}^{\\prime}}_{{j}}}{r}}\\right\\rceil.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>\u2265</mo><mrow><mrow><mi>k</mi><mo>-</mo><mn>2</mn></mrow><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo>\u2308</mo><mfrac><msub><mi>n</mi><mi>j</mi></msub><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2309</mo></mrow></mrow><mo>+</mo><mrow><mo>\u2308</mo><mfrac><mrow><mi>k</mi><mo>-</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow></msubsup><msubsup><mi>k</mi><mi>j</mi><msup><mi/><mo>\u2032</mo></msup></msubsup></mrow></mrow><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \n\nOn the other hand, for the outer Gabidulin code, we have \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nFinally, the result follows from using the Fact~\\ref{fact}.\n\\end{proof}\n\n\\subsection{Code Construction}\n\\label{sec:codes-all-symbol}\nWe adapt the rank-metric codes based LRC construction in~\\cite{Silberstein:13} for the unequal all symbol locality scenario. The idea is to first precode the information symbols with a rank-metric code (in particular, with Gabidulin codes), and then use maximum distance separable (MDS) codes to obtain local parities. We begin with a brief review of rank-metric codes.\n\n\\subsection{Rank-Metric Codes}\n\\label{sec:rank-metric}\nLet ${\\mathbb{F}_{{q}}^{N\\times m}}$ be the set of all $N\\times m$ matrices over ${\\mathbb{F}_{{q}}}$. The {\\it rank distance} is a distance measure between elements $A$ and $B$ of ${\\mathbb{F}_{{q}}^{N\\times m}}$ defined as $d_R\\left({A},{B}\\right) = \\textsf{rank}\\left({A-B}\\right)$. It can be shown that the rank distance is indeed a metric~\\cite{Gabidulin:85}. A rank-metric code is a non-empty subset of ${\\mathbb{F}_{{q}}^{N\\times m}}$ under the context of the rank metric. \n\nTypically, the rank-metric codes are considered by leveraging the correspondence between ${\\mathbb{F}_{{q}}}^{1\\times m}$ and an extension field ${\\mathbb{F}_{{{q}}^m}}$. By fixing a basis for ${\\mathbb{F}_{{{q}}^m}}$ as an $m$-dimensional vector space over ${\\mathbb{F}_{{q}}}$, any element of ${\\mathbb{F}_{{{q}}^m}}$ can be represented as an $m$-length vector over ${\\mathbb{F}_{{q}}}$. Similarly, any $N$-length vector over ${\\mathbb{F}_{{{q}}^m}}$ can be represented as an $N\\times m$ matrix over ${\\mathbb{F}_{{q}}}$. The rank of a vector $A\\in{\\mathbb{F}_{{{q}}^m}}^N$ is the rank of $A$ as an $N\\times m$ matrix over ${\\mathbb{F}_{{q}}}$, which also works for the rank distance. This correspondence allows us to view a rank-metric code in ${\\mathbb{F}_{{q}}^{N\\times m}}$ as a block code of length $N$ over ${\\mathbb{F}_{{{q}}^m}}$. \n\nFocussing on linear codes, an $(N,K,D)$ rank-metric code ${\\mathcal{C}}\\subseteq{\\mathbb{F}_{{{q}}^m}}^N$ is a linear block code over ${\\mathbb{F}_{{{q}}^m}}$ of length $N$, dimension $K$, and minimum rank distance $D$. For such codes, the Singleton bound becomes $d\\leq \\min\\left\\{1,\\frac{m}{N}\\right\\}(N-K)+1$ (see~\\cite{Gabidulin:85}). Codes that achieve this bound are called as maximum-rank distance (MRD) codes. Note that, for $m\\geq N$, the Singleton bound for rank metric coincides with the classical Singleton bound for the Hamming metric. Indeed, when $m\\geq N$, every MRD code is also MDS,  and hence can correct any $d-1$ {\\it rank erasures}. \n\n{\\bf Gabidulin Codes:} For $N\\geq m$, a class of MRD codes was presented in~\\cite{Gabidulin:85} by Gabidulin (see also~\\cite{Delsarte:78}). \nA Gabidulin code can be obtained by evaluation of {\\it linearized polynomials} defined as follows. A linearized polynomial $f(x)$ over ${\\mathbb{F}_{{{q}}^m}}$ of $q$-degree $K$ has the form $f(x) = \\sum_{i=0}^{K} a_i x^{q^i}$, where $a_i\\in{\\mathbb{F}_{{{q}}^m}}$ such that $a_K \\neq 0$. Evaluation of a linearized polynomial is an ${\\mathbb{F}_{{q}}}$-linear transform from ${\\mathbb{F}_{{{q}}^m}}$ to itself. In other words, for any $a,b \\in {\\mathbb{F}_{{q}}}$ and $x,y\\in{\\mathbb{F}_{{{q}}^m}}$, we have $f(ax+by) = af(x)+bf(y)$. \n\nA codeword in an $(N,K,N-K+1)$ Gabidulin code ${\\mathcal{C}}_{Gab}$ over ${\\mathbb{F}_{{{q}}^m}}$ for $m\\geq N$ is defined as ${\\mathbf{c}} = \\left(f(g_1),\\ldots,f(g_N)\\right) \\in {\\mathbb{F}_{{{q}}^m}}^N$, where $f(x)$ is a linearized polynomial over $GFm{q}$ of $q$-degree $K-1$ whose coefficients are information symbols, and evaluation points $g_1,\\ldots,g_N\\in{\\mathbb{F}_{{{q}}^m}}$ are linearly  independent over ${\\mathbb{F}_{{q}}}$. Note that since Gabidulin code is also an MDS code, it can correct any $N-K$ erasures.\n\n\\subsection{Code Construction}\n\\label{sec:construction}\nIn the following, we give a construction of an ${(n,k,d)}$ LRC with all symbol locality profile ${\\mathbf{{n}}} = \\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$ which attains the distance bound in~\\eqref{eq:all-symbol-loc-bound}. For the simplicity of presentation, we assume that $j+1\\mid{n_{{j}}}$ for each $j$. One can generalize the construction for the case when this is not the case.\n\n{\\bf Construction 1.} Consider a length-$k$ vector of information symbols ${\\mathbf{{m}}} \\in {\\mathbb{F}_{{{q}}^m}}^k$.  First, we precode ${\\mathbf{{m}}}$ using a Gabidulin code. Then, the codeword of the Gabidulin code is partitioned into local groups, and the local parities are computed for each group using MDS codes over ${\\mathbb{F}_{{q}}}$. The details are as follows.\n\nDefine ${N_{{j}}} = {n_{{j}}}\\left(\\frac{j}{j+1}\\right)$ for each $j\\in[{r_a}]$. Let $N = \\sum_{j=1}^{{r_a}}{N_{{j}}}$. Encode ${\\mathbf{{m}}}$ using an $(N,k,N-k+1)$ Gabidulin code to obtain ${\\mathbf{c}_{\\textrm{Gab}}}\\in{\\mathbb{F}_{{{q}}^m}}^N$. Partition ${\\mathbf{c}_{\\textrm{Gab}}}$ into ${r_a}$ disjoint groups ${\\mathbf{c}_{\\textrm{Gab}}} = \\cup_{j=1}^{{r_a}}{\\mathbf{c}_{\\textrm{Gab}}^{{j}}}$ such that $|{\\mathbf{c}_{\\textrm{Gab}}^{{j}}}| = {N_{{j}}}$ for $j\\in[{r_a}]$ with ${\\mathbf{c}_{\\textrm{Gab}}^{{j}}} = \\emptyset$ for each $j$ such that ${N_{{j}}} = 0$. For each $1\\leq j\\leq {r_a}$ such that ${N_{{j}}} > 0$, further partition ${\\mathbf{c}_{\\textrm{Gab}}^{{j}}}$ symbols into $\\frac{{N_{{j}}}}{j}$ disjoint local groups each of size $j$, {\\it i.e.}, ${\\mathbf{c}_{\\textrm{Gab}}}{j} = \\cup_{i=1}{\\frac{{N_{{j}}}}{j}}{\\mathbf{c}_{\\textrm{Gab}}^{{j,i}}}$. For each group ${\\mathbf{c}_{\\textrm{Gab}}^{{j,i}}}$ of $j$ symbols, generate a local parity using a $(j+1,j,2)$ MDS code over ${\\mathbb{F}_{{q}}}$. Denote the resulting code as ${\\mathcal{C}}_{\\textrm{LRC}}$. Note that the total number of symbols are $\\sum_{j=1}^{{r_a}}\\frac{{N_{{j}}}}{j}(j+1) = \\sum_{j=1}^{{r_a}}{n_{{j}}} = n$. Note that, we generate the local parities in such a way that ${\\mathcal{C}}_{\\textrm{LRC}}$ possesses all symbol locality profile $\\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$.\n\nNext, we show that the above construction achieves the distance bound mentioned in Theorem~\\ref{thm:all-symbol-loc-bound}.\n\\begin{theorem}\n\\label{thm:gabidulin-codes-based-LRC}\nLet ${\\mathcal{C}}_{\\textrm{LRC}}$ be an $(n,k,d)$ LRC with all symbol locality profile $\\{{n_{{1}}},\\ldots,{n_{{{r_a}}}}\\}$ obtained by Construction 1. If $j+1\\mid{n_{{j}}}$ for each $j\\in[{r_a}]$, then ${\\mathcal{C}}_{\\textrm{LRC}}$ over ${\\mathbb{F}_{{{q}}^m}}$ for $m\\geq \\sum_{j=1}^{{r_a}}{n_{{j}}}\\left(\\frac{j}{j+1}\\right)$ and $q\\geq {r_a} + 1$, achieves the bound in~\\eqref{eq:all-symbol-loc-bound}.\n\\end{theorem}\n\\begin{proof}\nSimilar to~\\cite{Silberstein:13}, the idea is show that any $e : = n - k + 1 - \\sum_{j=1}^{r-1}\\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil - \\left\\lceil{\\frac{k - \\sum_{i=1}^{r-1}\\left({n_{{j}}} - \\left\\lceil{\\frac{{n_{{j}}}}{j+1}}\\right\\rceil\\right)}{r}}\\right\\rceil$ symbol erasures correspond to $N-K$ rank erasures, which can be corrected by the Gabidulin code. \n\nThe ${\\mathbb{F}_{{q}}}$-linearity of the linearized polynomials plays a crucial role. In particular, since the local parities are obtained using an MDS code over ${\\mathbb{F}_{{q}}}$, any symbol ${{\\mathbf{{c}}}_i}$ of locality $j$ can be written as ${{\\mathbf{{c}}}_i} = \\sum_{p=1}^{j} a_p{\\mathbf{c}}_{i_p} =  \\sum_{p=1}^{j} a_p f(g_{i_p}) = f\\left(\\sum_{p=1}^{j} a_p g_{i_p}\\right)$. Hence, for each $j\\in[{r_a}]$, in a local group of size $j$, any $m\\leq j$ symbols are evaluations of $f(x)$ in $m$ points that are linearly independent over ${\\mathbb{F}_{{q}}}$. Therefore, for each $j\\in[{r_a}]$, in a local group of size $j+1$, any $i+1 (\\leq j+1)$ symbol erasures correspond to $i$ rank erasures. Moreover, taking any $j$ points from all local groups of size $j+1$ for each $j\\in[{r_a}]$, we obtain the Gabidulin codeword, which has obtained by precoding ${\\mathbf{{m}}}$.\n\nWith above observation, the worst case erasure pattern is when the erasures occur in the smallest possible number of local groups (of possibly different localities), and the number of erasures in each local group are maximal.\n\nNote that we can write $n$ as $n = \\sum_{j=1}^{{r_a}}{N_{{j}}} + \\frac{{N_{{j}}}}{j}$. Let $k = \\sum_{j=1}^{r-1} {N_{{j}}} + {N^{'}_{{r}}}$ for some ${N^{'}_{{r}}} < {N_{{r}}}$. Then, we can write \n\n", "index": 49, "text": "\\begin{equation}\n\\label{eq:erasures}\ne = 1 + \\sum_{j=r}^{{r_a}}\\left({N_{{j}}} + \\frac{{N_{{j}}}}{j}\\right) -  \\left({N^{'}_{{r}}}  + \\left\\lceil{\\frac{{N^{'}_{{r}}}}{r}}\\right\\rceil\\right).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"e=1+\\sum_{j=r}^{{r_{a}}}\\left({N_{{j}}}+\\frac{{N_{{j}}}}{j}\\right)-\\left({N^{{%&#10;}^{\\prime}}_{{r}}}+\\left\\lceil{\\frac{{N^{{}^{\\prime}}_{{r}}}}{r}}\\right\\rceil%&#10;\\right).\" display=\"block\"><mrow><mrow><mi>e</mi><mo>=</mo><mrow><mrow><mn>1</mn><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mi>r</mi></mrow><msub><mi>r</mi><mi>a</mi></msub></munderover><mrow><mo>(</mo><mrow><msub><mi>N</mi><mi>j</mi></msub><mo>+</mo><mfrac><msub><mi>N</mi><mi>j</mi></msub><mi>j</mi></mfrac></mrow><mo>)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mo>(</mo><mrow><msubsup><mi>N</mi><mi>r</mi><msup><mi/><mo>\u2032</mo></msup></msubsup><mo>+</mo><mrow><mo>\u2308</mo><mfrac><msubsup><mi>N</mi><mi>r</mi><msup><mi/><mo>\u2032</mo></msup></msubsup><mi>r</mi></mfrac><mo>\u2309</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06153.tex", "nexttext": " \n\n\n\n\n{\\it Case 1:} $r\\mid{N^{'}_{{r}}}$. Let ${N^{'}_{{r}}} = r\\beta$. Then, from~\\eqref{eq:erasures}, we have $e = 1 + \\sum_{j=r+1}^{{r_a}}(j+1)\\left(\\frac{{n_{{j}}}}{j+1}\\right) + (r+1)\\left(\\frac{{n_{{r}}}}{r+1} - \\beta\\right)$. Thus, in the worst case, the number of local groups that are completely erased are $\\sum_{j=r+1}^{{r_a}}\\left(\\frac{{n_{{j}}}}{j+1}\\right) + \\left(\\frac{{n_{{r}}}}{r+1} - \\beta\\right)$ with one erasure in an additional group. Recall that, due to the ${\\mathbb{F}_{{q}}}$-linearity, any $i+1$ erasures in a local group of size $j+1$, the number of rank erasures corresponding to the Gabidulin codeword are only $j$. Thus, total number of rank erasures are $\\sum_{j=r+1}^{{r_a}}j\\left(\\frac{{n_{{j}}}}{j+1}\\right) + r\\left(\\frac{{n_{{r}}}}{r+1} - \\beta\\right)$.\n\nHowever, from~\\eqref{eq:rank-distance}, we get $N-k = \\sum_{j=r+1}^{{r_a}}j\\left(\\frac{{n_{{j}}}}{j+1}\\right) + r\\left(\\frac{{n_{{r}}}}{r+1} - \\beta\\right)$. Therefore, all the rank erasures can be corrected by the outer Gabidulin code.\n\n{\\it Case 2:} $r\\nmid{N^{'}_{{r}}}$. Let ${N^{'}_{{r}}} = r\\beta + \\gamma$, where $1\\leq\\gamma\\leq r-1$. Then, from~\\eqref{eq:erasures}, we have $e = 1 + \\sum_{j=r+1}^{{r_a}}(j+1)\\left(\\frac{{n_{{j}}}}{j+1}\\right) + (r+1)\\left(\\frac{{n_{{r}}}}{r+1} - \\beta - 1\\right) + (r-\\gamma+1)$. In other words, in the in the worst case, the number of local groups that are completely erased are $\\sum_{j=r+1}^{{r_a}}\\left(\\frac{{n_{{j}}}}{j+1}\\right) + \\left(\\frac{{n_{{r}}}}{r+1} - \\beta - 1\\right)$ with $(r-\\gamma+1)$ erasures in an additional group. This corresponds to $\\sum_{j=r+1}^{{r_a}}j\\left(\\frac{{n_{{j}}}}{j+1}\\right) + r\\left(\\frac{{n_{{r}}}}{r+1} - \\beta - 1\\right) + (r - \\gamma)$ rank erasures. \n\nFrom~\\eqref{eq:rank-distance}, we get $N-k = \\sum_{j=r+1}^{{r_a}}j\\left(\\frac{{n_{{j}}}}{j+1}\\right) + r\\left(\\frac{{n_{{r}}}}{r+1} - \\beta - 1\\right) + (r - \\gamma)$. Hence, all the rank erasures can be corrected by the outer Gabidulin code.\n\\end{proof}\n\n\n\\section{Information Locality Requirement}\n\\label{sec:loc-req}\n\nIn general, one can design codes for different locality profiles, which gives rise to the following natural question: how to choose a locality profile that gives largest minimum distance. Towards this, we define a notion of {\\it locality requirement} as follows.\n\n\\begin{definition}\n\\label{def:loc-req}\nLet ${\\tilde{{\\mathbf{{k}}}}} = \\{{\\tilde{k}_{{1}}}, \\ldots, {\\tilde{k}_{{r}}}\\}$ be a length-$r$ vector for some $r < k$ such that for each $1\\leq j\\leq r$, we have $0\\leq {\\tilde{k}_{{j}}}\\leq k$ and $\\sum_{j = 1}^r {\\tilde{k}_{{j}}} = k$. Consider a code ${\\mathcal{C}}$ with information locality profile ${\\mathbf{{k}}} = \\{{k_{{1}}}, \\ldots, {k_{{r'}}}\\}$ for some $r' \\leq r$. We say that ${\\mathcal{C}}$ satisfies information locality requirement ${\\tilde{{\\mathbf{{k}}}}}$ if, for each $1\\leq i\\leq r$, we have $\\sum_{j=1}^{i}{k_{{j}}} \\geq \\sum_{j=1}^{i}{\\tilde{k}_{{j}}}$, where we set ${k_{{j}}} = 0$ for $r'+1\\leq j \\leq r$ if $r' < r$. Further, in this case, we say that locality profile ${\\mathbf{{k}}}$ respects locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, and denote this as ${\\mathbf{{k}}} \\succeq {\\tilde{{\\mathbf{{k}}}}}$.\n\\end{definition}\n\n\n\nDifferent locality profiles can respect a locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, and one can ask which locality profile would give larger minimum distance. For example, let ${\\tilde{{\\mathbf{{k}}}}} = \\{0, 3, 3\\}$. Then, one can find a number of locality profiles that respect ${\\tilde{{\\mathbf{{k}}}}}$, such as ${\\mathbf{{k}}}_1 = \\{2,4,0\\}$, ${\\mathbf{{k}}}_2 = \\{3,0,3\\}$, ${\\mathbf{{k}}}_3 = \\{0, 6, 0\\}$, ${\\mathbf{{k}}}_4 = \\{1,2,3\\}$. Among these, the last two locality profiles would give the largest minimum distance.  However, in general, since a large number of locality profiles can respect a locality requirement, it is not clear how to find an optimal locality profile with respect to minimum distance. \n\n \nGive a locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, we are interested in finding a locality profile ${\\mathbf{{k}}} \\succeq {\\tilde{{\\mathbf{{k}}}}}$ which results in largest upper bound on the minimum distance for fixed $n$. More formally, we can define the problem as follows.\n\n\\begin{IEEEeqnarray}{lCr}\n\n\\label{eq:sum-of-ceils}\n\\min_{{\\mathbf{{k}}}\\in\\mathbb{Z}_{+}^{r}} & \\sum_{j=1}^r \\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil & {(P1)}\\\\\n{\\textrm{s.t.}} & \\sum_{j=1}^{i}{k_{{j}}} \\geq \\sum_{j=1}^{i}{\\tilde{k}_{{j}}}, & \\:\\:{\\textrm{for}}\\:\\: 1\\leq i\\leq r,\\\\\n{\\textrm{and}} & \\sum_{j=1}^{r} {k_{{j}}} = \\sum_{j=1}^{r}{\\tilde{k}_{{j}}} & {}.\n\\end{IEEEeqnarray} \n \nA solution of the above optimization problem is said to be an {\\it optimal} locality profile. In the following we give a greedy algorithm which finds an optimal ${\\mathbf{{k}}}^{*}$. From $\\sum_{j=1}^{r-1}{k_{{j}}}\\geq\\sum_{j=1}^{r-1}{\\tilde{k}_{{j}}}$ and $\\sum_{j=1}^{r}{k_{{j}}} = \\sum_{j=1}^{r}{\\tilde{k}_{{j}}}$, we get that ${k_{{r}}}\\leq{\\tilde{k}_{{r}}}$. In similar way, we can see that the inequality constraints above can be replaced by $\\sum_{j=i}^{r}{k_{{j}}} \\geq \\sum_{j=i}^{r}{\\tilde{k}_{{j}}}$ and $\\sum_{j=1}^{r}{k_{{j}}} = \\sum_{j=1}^{r}{\\tilde{k}_{{j}}}$. The idea of the algorithm is to start with the largest locality $r$ and set ${k}^{*}_{{r}}$ as the largest multiple of $r$ such that ${k}^{*}_{{r}} \\leq {\\tilde{k}_{{r}}}$. Move the residue ${\\tilde{k}_{{r}}} - {k}^{*}_{{r}}$ to the next locality $r-1$, and set ${k}^{*}_{{r-1}}$ as the largest multiple of $r$ such that ${k}^{*}_{{r-1}} \\leq {\\tilde{k}_{{r-1}}}+{\\tilde{k}_{{r}}}-{k}^{*}_{{r}}$. We continue this until we reach locality 1.\n\n\n\\begin{algorithm}[!t]\n\\caption{Find an optimal locality profile ${\\mathbf{{k}}}^{*}$ for a given locality requirement ${\\tilde{{\\mathbf{{k}}}}}$}\n\\label{alg:find-k-opt}\n\\begin{algorithmic}[1]\n\\STATE{Set ${\\gamma_{{r+1}}} = 0$, $j = r$} \n\\WHILE{$j\\geq 1$}\n\t\\STATE{Chose integers ${\\beta_{{j}}}$ and ${\\gamma_{{j}}}$ such that ${\\tilde{k}_{{j}}} + {\\gamma_{{j+1}}} = j{\\beta_{{j}}} + {\\gamma_{{j}}}$}\n        \\STATE{Set ${k}^{*}_{{j}} = j{\\beta_{{j}}}$}\n\t\\STATE{Decrement $j$}\t\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\\begin{remark}\n\\label{rem:greedy-ksj}\nNote that Algorithm~\\ref{alg:find-k-opt} assigns ${k}^{*}_{{j}} = {\\tilde{k}_{{j}}} + {\\gamma_{{j+1}}} - {\\gamma_{{j}}}$ for each locality $j$. This gives $\\sum_{j=i}^{r}{k}^{*}_{{j}} = \\sum_{j=i}^{r}{\\tilde{k}_{{j}}} - {\\gamma_{{i}}}$ for each $r\\geq i\\geq 1$.\n\\end{remark}\n\n\\begin{theorem}\n\\label{thm:ks-is-opt}\nGiven an information locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, the information locality profile ${\\mathbf{{k}}}^{*}$ given by Algorithm~\\ref{alg:find-k-opt} results in the largest upper bound on the minimum distance among all the information locality profiles that respect the given information locality requirement. \n\\end{theorem} \n\\begin{proof}\nThe idea is to show that any optimal information locality profile can be transformed into a form of ${\\mathbf{{k}}}^{*}$ without loosing optimality. We first prove that it is always possible to obtain an optimal information locality profile ${\\mathbf{{k}}}^{''}$ such that $j\\mid{k}^{''}_{{j}}$ for each $j\\in[r]$.\n\n\\begin{lemma}\n\\label{lem:k'-to-k''}\nGiven a locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, any optimal information locality profile ${\\mathbf{{k}}}^{'}$ can be converted into another optimal information locality profile ${\\mathbf{{k}}}^{''}$ such that $j \\mid {k}^{''}_{{j}}$ $\\forall j\\in[r]$.\n\\end{lemma}\n\\begin{proof}\nBy induction on the number of localities $j$ such that $j \\nmid {k}^{'}_{{j}}$. Let $|\\{j : j\\nmid{k}^{'}_{{j}}\\}| = m$.\n\nBasis step: $m = 1$. Let ${j_{{m}}}\\in[r]$ be the only locality such that ${j_{{m}}}\\nmid{k}^{'}_{{{j_{{m}}}}}$. We can write ${k}^{'}_{{{j_{{m}}}}} = {j_{{m}}}{\\beta_{{{j_{{m}}}}}} + {\\gamma_{{{j_{{m}}}}}}$ such that $1\\leq{\\beta_{{{j_{{m}}}}}}\\leq{j_{{m}}}-1$. Set ${k}^{''}_{{{j_{{m}}}}} = {k}^{'}_{{{j_{{m}}}}} - {\\gamma_{{{j_{{m}}}}}}$, ${k}^{''}_{{{\\gamma_{{{j_{{m}}}}}}}} = {k}^{'}_{{{\\gamma_{{{j_{{m}}}}}}}} + {\\gamma_{{{j_{{m}}}}}}$, and ${k}^{''}_{{j}} = {k}^{'}_{{j}}$ for all $j\\in[r]$ such that $j\\neq{j_{{m}}}$, $j\\neq{\\gamma_{{{j_{{m}}}}}}$.\n\nFirst, observe that ${\\mathbf{{k}}}^{''}$ is such that $j\\mid{k_{{j}}}$ for each $j\\in[r]$, since ${\\gamma_{{{j_{{m}}}}}}\\mid{k}^{'}_{{{\\gamma_{{{j_{{m}}}}}}}}$. \n\nSecond, note that ${\\mathbf{{k}}}^{''}$ is a feasible solution for (P1). This is because, for $1\\leq i\\leq {j_{{m}}}-1$, we have $\\sum_{j=1}^{i}{k}^{''}_{{j}}  = \\sum_{j=1}^{i}{k}^{'}_{{j}} + {\\gamma_{{{j_{{m}}}}}} \\geq \\sum_{j=1}^{i}{\\tilde{k}_{{j}}}$, and for ${j_{{m}}}\\leq i\\leq r$, we have $\\sum_{j=1}^{i}{k}^{''}_{{j}}  = \\sum_{j=1}^{i}{k}^{'}_{{j}} \\geq \\sum_{j=1}^{i}{\\tilde{k}_{{j}}}$. For both these cases, the inequality follows since ${\\mathbf{{k}}}^{'}$ satisfies the constraints of (P1).\n\nFinally, it is easy to see that ${\\mathbf{{k}}}^{''}$ is also optimal, since $\\left\\lceil{\\frac{{k}^{''}_{{{j_{{m}}}}}}{{j_{{m}}}}}\\right\\rceil = \\left\\lceil{\\frac{{k}^{'}_{{{j_{{m}}}}}}{{j_{{m}}}}}\\right\\rceil - 1$, $\\left\\lceil{\\frac{{k}^{''}_{{{\\gamma_{{{j_{{m}}}}}}}}}{{\\gamma_{{{j_{{m}}}}}}}}\\right\\rceil = \\left\\lceil{\\frac{{k}^{'}_{{{\\gamma_{{{j_{{m}}}}}}}}}{{\\gamma_{{{j_{{m}}}}}}}}\\right\\rceil + 1$, and $\\left\\lceil{\\frac{{k}^{''}_{{j}}}{j}}\\right\\rceil = \\left\\lceil{\\frac{{k}^{'}_{{j}}}{j}}\\right\\rceil$ for the rest of the localities.\n\nInduction step: $m \\geq 2$. Suppose the hypothesis holds whenever $|\\{j : j\\nmid{k}^{'}_{{j}}\\}| \\leq m-1$. Consider the case when $|\\{j : j\\nmid{k}^{'}_{{j}}\\}| = m$. Denote such a set of localities as $\\{{j_{{1}}},\\ldots,{j_{{m}}}\\}$, where ${j_{{1}}} < \\cdots < {j_{{m}}}$. Now, we can write ${k}^{'}_{{{j_{{m}}}}} = {j_{{m}}}{\\beta_{{{j_{{m}}}}}} + {\\gamma_{{{j_{{m}}}}}}$ such that $1\\leq{\\beta_{{{j_{{m}}}}}}\\leq{j_{{m}}}-1$. Set ${k}^{'}_{{{j_{{m}}}}} = {k}^{'}_{{{j_{{m}}}}} - {\\gamma_{{{j_{{m}}}}}}$, and ${k}^{'}_{{{\\gamma_{{{j_{{m}}}}}}}} = {k}^{'}_{{{\\gamma_{{{j_{{m}}}}}}}} + {\\gamma_{{{j_{{m}}}}}}$.\n\nSimilar to $m=1$ case, we can verify that ${\\mathbf{{k}}}^{'}$ remains to be an optimal solution to (P1) after the  transformation. Further, since ${j_{{m}}}\\mid{k}^{'}_{{{j_{{m}}}}}$, we get $|\\{j : j\\nmid{k}^{'}_{{j}}\\}| = m-1$. Then, the proof follows by the induction hypothesis.\n\\end{proof}\n\nLet $|\\{j : {k}^{''}_{{j}}\\neq{k}^{*}_{{j}}\\}| = m$. Denote such a set of localities as $\\{{j_{{1}}},\\ldots,{j_{{m}}}\\}$, where ${j_{{1}}} < \\cdots < {j_{{m}}}$. We first prove some properties for the localities where the coordinate values differ. \n\n\\begin{proposition}\n\\label{prop:last-index}\n${k}^{''}_{{{j_{{m}}}}} < {k}^{*}_{{{j_{{m}}}}}$\n\\end{proposition}\n\\begin{proof}\nSuppose, for contradiction, ${k}^{''}_{{{j_{{m}}}}} > {k}^{*}_{{{j_{{m}}}}}$. We can write ${k}^{''}_{{{j_{{m}}}}} = {k}^{*}_{{{j_{{m}}}}} + p{j_{{m}}}$ for some integer $p\\geq 1$, since both ${k}^{''}_{{{j_{{m}}}}}$ and ${k}^{*}_{{{j_{{m}}}}}$ are multiples of ${j_{{m}}}$. Consider\n\\begin{IEEEeqnarray}{rCl}\n\\sum_{i={j_{{m}}}}^{r} {k}^{''}_{{i}} & = & {k}^{*}_{{{j_{{m}}}}} + p{j_{{m}}} + \\sum_{i={j_{{m}}}+1}^{r} {k}^{*}_{{i}}\\\\\n& = & \\sum_{i={j_{{m}}}}^{r} {\\tilde{k}_{{i}}} - {\\gamma_{{{j_{{m}}}}}} + p{j_{{m}}}\\\\\n& \\geq & \\sum_{i={j_{{m}}}}^{r} {\\tilde{k}_{{i}}} - ({j_{{m}}} - 1) + p{j_{{m}}}\\\\ \n& \\geq & \\sum_{i={j_{{m}}}}^{r} {\\tilde{k}_{{i}}} + (p - 1){j_{{m}}} + 1\\\\\n& \\geq & \\sum_{i={j_{{m}}}}^{r} {\\tilde{k}_{{i}}}.\n\\end{IEEEeqnarray}\nHowever, this contradicts the feasibility of ${\\mathbf{{k}}}^{''}$ as it should satisfy $\\sum_{{j_{{m}}}}^{r} {k}^{''}_{{i}}\\leq \\sum_{{j_{{m}}}}^{r} {\\tilde{k}_{{i}}}$ (due to $\\sum_{i=1}^{{j_{{m}}}} {k}^{''}_{{i}}\\geq \\sum_{i=1}^{{j_{{m}}}} {\\tilde{k}_{{i}}}$ and $\\sum_{i=1}^{r} {k}^{''}_{{i}}  = \\sum_{i=1}^{r} {\\tilde{k}_{{i}}}$).\n\\end{proof}\n\nNext, we show that for any information locality profile, moving the coordinates to the higher locality does not increase the minimum distance bound. \n\\begin{proposition}\n\\label{prop:move-to-right}\nConsider an information locality profile ${\\mathbf{{k}}}$. For any locality pair $i$ and $j$ such that $i<j$ and ${k_{{j}}}>0$. Set ${k_{{i}}} = {k_{{i}}} - \\delta$ and ${k_{{j}}} = {k_{{j}}} + \\delta$ for an integer $\\delta$ such that either $i\\mid\\delta$ or $j\\mid\\delta$ (or both). Then, such a transformation does not increase the value of the minimum distance bound. \n\\end{proposition}\n\\begin{proof}\nCase 1: $i\\mid\\delta$. Let $\\delta = ia$ for some integer $a$. After moving the coordinates of locality $i$ to locality $j$, the term $\\left\\lceil{\\frac{{k_{{i}}}}{i}}\\right\\rceil$ reduces by $a$. Whereas, the term $\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ increases by at most $\\left\\lceil{\\frac{\\delta}{j}}\\right\\rceil$, which itself is at most $a$. \n\nCase 2: $j\\mid\\delta$. Let $\\delta = jb$ for some integer $b$. In this case, the term $\\left\\lceil{\\frac{{k_{{j}}}}{j}}\\right\\rceil$ increases by $b$. Whereas, the term $\\left\\lceil{\\frac{{k_{{i}}}}{i}}\\right\\rceil$ reduces by at least $\\left\\lfloor{\\frac{\\delta}{i}}\\right\\rfloor$, which itself is at least $b$.\n\nTherefore, in both the above case, the value of~\\eqref{eq:sum-of-ceils} does not increase.\n\\end{proof}\n\nFinally, we show that for any information locality profile, moving the coordinates to the lower locality to obtain divisibility does not change the minimum distance bound.\n\\begin{proposition}\n\\label{prop:move-to-left}\nConsider an information locality profile ${\\mathbf{{k}}}$. Let $j$ be a locality such that $j\\nmid{k_{{j}}}$, and let ${k_{{j}}} = j{\\beta_{{j}}} + {\\gamma_{{j}}}$ for some integers ${\\beta_{{j}}}$ and $1\\leq{\\gamma_{{j}}}\\leq j-1$. Then, setting ${k_{{j}}} = {k_{{i}}} - {\\gamma_{{j}}}$ and ${k_{{{\\gamma_{{j}}}}}} = {k_{{{\\gamma_{{j}}}}}} + {\\gamma_{{j}}}$ does not change the value of the minimum distance bound. \n\\end{proposition}\n\\begin{proof}\nThe argument is the same as for the basis step in the proof of Lemma~\\ref{lem:k'-to-k''}.\n\\end{proof}\n\nFinally, we show that we can transform an optimal information locality profile where divisibility holds for each locality into ${\\mathbf{{k}}}^{*}$. \n\\begin{lemma}\n\\label{lem:k''-to-ks}\nGiven a locality requirement ${\\tilde{{\\mathbf{{k}}}}}$, any optimal information locality profile ${\\mathbf{{k}}}^{'}$, where $j\\mid{k}^{''}_{{j}}$ for each $j$, can be converted into ${\\mathbf{{k}}}^{*}$ without loosing optimality, where ${\\mathbf{{k}}}^{*}$ is the output of Algorithm~\\ref{alg:find-k-opt}.\n\\end{lemma}\n\\begin{proof}\nWe give an iterative algorithm (Algorithm~\\ref{alg:k''-to-ks}) to transform an optimal information locality profile ${\\mathbf{{k}}}^{''}$ to ${\\mathbf{{k}}}^{*}$. First note that, by Proposition~\\ref{prop:last-index}, it must be that ${k}^{''}_{{{j_{{m}}}}} < {k}^{*}_{{{j_{{m}}}}}$ in the first iteration of the outer while-loop. Moreover, at line~\\ref{inner-loop}, ${\\mathbf{{k}}}^{''}$ is such that $j\\mid{k}^{''}_{{j}}$ for each $j\\in[r]$, hence we can invoke Proposition~\\ref{prop:last-index} for the every iteration of outer while-loop. Next, the optimality of ${\\mathbf{{k}}}^{''}$ is maintained at line~\\ref{move-right} due to Proposition~\\ref{prop:move-to-right}, and also at line~\\ref{move-left} due to Proposition~\\ref{prop:move-to-left}. Finally, Algorithm~\\ref{alg:k''-to-ks} must terminate in finite time as $m$ decreases by at least 1 at line~\\ref{inner-loop}. \n\\end{proof}\n\n\n\n\\begin{algorithm}[!t]\n\\caption{Transform an optimal locality profile ${\\mathbf{{k}}}^{''}$ to ${\\mathbf{{k}}}^{*}$}\n\\label{alg:k''-to-ks}\n\\begin{algorithmic}[1]\n\\STATE{Let $|\\{j : {k}^{''}_{{j}}\\neq{k}^{*}_{{j}}\\}| = m$} \n\\WHILE{$m > 0$}\n\t\\STATE{Let ${j_{{m}}} = \\max\\{j : {k}^{''}_{{j}}\\neq{k}^{*}_{{j}}\\}$}\n\t\\WHILE{${k}^{''}_{{{j_{{m}}}}} < {k}^{*}_{{{j_{{m}}}}}$}\n\t\t\\STATE{Let ${j_{{p}}} = \\max\\{j : {k}^{''}_{{j}} > {k}^{*}_{{j}}\\}$}\n\t\t\\STATE{Let $\\delta_{{j_{{m}}}} = {k}^{*}_{{{j_{{m}}}}} - {k}^{''}_{{{j_{{m}}}}}$, \n\t\t\t\t   $\\delta_{{j_{{p}}}} = {k}^{''}_{{{j_{{p}}}}} - {k}^{*}_{{{j_{{p}}}}}$}\n\t\t\\label{move-right}\n\t\t\\STATE{Set ${k}^{''}_{{{j_{{m}}}}} = {k}^{''}_{{{j_{{m}}}}} + \\min\\{\\delta_{{j_{{m}}}}, \\delta_{{j_{{p}}}}\\}$, \n\t\t                    ${k}^{''}_{{{j_{{p}}}}} = {k}^{''}_{{{j_{{p}}}}} - \\min\\{\\delta_{{j_{{m}}}}, \\delta_{{j_{{p}}}}\\}$}\n        \t\t\\IF{$\\delta_{{j_{{m}}}} < \\delta_{{j_{{p}}}}$}\n\t\t\t\\STATE{Let ${k}^{''}_{{{j_{{p}}}}} = {j_{{p}}}{\\beta_{{{j_{{p}}}}}} + {\\gamma_{{{j_{{p}}}}}}$}\n\t\t\t\\IF{${\\gamma_{{{j_{{p}}}}}}>0$}\n\t\t\t\t\\label{move-left}\n\t\t\t\t\\STATE{Set ${k}^{''}_{{{j_{{p}}}}} = {k}^{''}_{{{j_{{p}}}}} - {\\gamma_{{{j_{{p}}}}}}$, \n\t\t\t\t                    ${k}^{''}_{{{\\gamma_{{{j_{{p}}}}}}}} = {k}^{''}_{{{\\gamma_{{{j_{{p}}}}}}}} + {\\gamma_{{{j_{{p}}}}}}$}\n\t\t\t\\ENDIF\n\t\t\\ENDIF\n\t\\label{inner-loop}\t\n\t\\ENDWHILE\n\t\\STATE{Set $m = |\\{j : {k}^{''}_{{j}}\\neq{k}^{*}_{{j}}\\}|$}\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\n\nThe proof of Theorem~\\ref{thm:ks-is-opt} follows from Lemma~\\ref{lem:k'-to-k''} and Lemma~\\ref{lem:k''-to-ks}\n\n\\end{proof}\n\n\\section*{Acknowledgment}\nSwanand Kadhe would like to thank Ankit Singh Rawat for helpful discussions and for pointing out LRC constructions based on rank-metric codes; and also thank Anoosheh Heidarzadeh for helpful discussions, especially on locality requirement.\n\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{Bib_unequal_LRC_v1,IEEEabrv}\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": " \n\nOn the other hand, for the outer Gabidulin code, we have \n\n", "index": 51, "text": "\\begin{equation}\n\\label{eq:rank-distance}\nN-k = \\sum_{j=r}^{{r_a}}{N_{{j}}} - {N^{'}_{{r}}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"N-k=\\sum_{j=r}^{{r_{a}}}{N_{{j}}}-{N^{{}^{\\prime}}_{{r}}}.\" display=\"block\"><mrow><mrow><mrow><mi>N</mi><mo>-</mo><mi>k</mi></mrow><mo>=</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mi>r</mi></mrow><msub><mi>r</mi><mi>a</mi></msub></munderover><msub><mi>N</mi><mi>j</mi></msub></mrow><mo>-</mo><msubsup><mi>N</mi><mi>r</mi><msup><mi/><mo>\u2032</mo></msup></msubsup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}]