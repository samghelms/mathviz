[{"file": "1601.04980.tex", "nexttext": "\nsuch that $k,c_i\\in\\mathfrak I$, $s$ is an ordinary or a relational knowledge base element\nof $L_k$ and $p_1,\\ldots,p_m$ are ordinary or relational beliefs of $L_{c_i}$.\n\\end{definition}\nThe notation $(c:p)$ indicates that $p$ is evaluated in context $c$.\nThese rules intuitively generalize logic programming rules, and as\nusual in that context we impose a \\emph{safety condition}: all\nvariables occurring in $p_{q+1},\\ldots,p_m$ must also occur at least\nonce in $p_1,\\ldots,p_q$.\n\n\\begin{definition}\nA \\emph{relational multi-context system} is a collection\n$M=\\left\\{C_i\\right\\}_{i\\in\\mathfrak I}$ of contexts\n$C_i=\\langle L_i,{\\mathsf{kb}}_i,{\\mathsf{br}}_i,D_i\\rangle$, where $L_i$ is a relational logic, ${\\mathsf{kb}}_i$ is a\nknowledge base, ${\\mathsf{br}}_i$ is a set of relational $i$-bridge rules, and $D_i$ is a set of\nimport domains $D_{i,j}$, with $j\\in\\mathfrak I$, such that $D_{i,j}\\subseteq U_j$.\n\\end{definition}\nImport domains define which constants are exported from one context to another: as\nthe underlying logic languages can be different, these sets are essential to allow one\ncontext to reason about individuals introduced in another.\nWe will assume that $D_{i,j}$ is the finite domain consisting of the object constants\nappearing in ${\\mathsf{kb}}_j$ or in the head of a relational bridge rule in ${\\mathsf{br}}_j$, unless\notherwise stated.\n\n\\begin{example}\n  \\label{ex:mcs}\n  Let $C_1$ and $C_2$ be contexts over the first-order logic ${\\ensuremath{\\mathsf{FOL}}}$\n  with $\\mathsf{R}$ and $\\mathsf{Rt}$ binary predicates in\n  $\\Sigma_{\\ensuremath{\\mathsf{FOL}}}$, and let ${\\mathsf{kb}}_1={\\mathsf{kb}}_2=\\emptyset$.\n  We can use the following bridge rules in ${\\mathsf{br}}_2$ to define $\\mathsf{Rt}$ in\n  $C_2$ as the transitive closure of $\\mathsf{R}$ in $C_1$.\n \n", "itemtype": "equation", "pos": 13038, "prevtext": "\n\n\\title{Integrity Constraints for General-Purpose Knowledge Bases}\n\\author{Lu\\'\\i s Cruz-Filipe\\inst{1}\n  \\and Isabel Nunes\\inst{2}\n  \\and Peter Schneider-Kamp\\inst{1}}\n\\institute{\n  Dept.\\ of Mathematics and Computer Science,\n  University of Southern Denmark\n  \\and Faculdade de Ci\\^encias da Universidade de Lisboa, Portugal}\n\n\\maketitle\n\n\\begin{abstract}\n  Integrity constraints in databases have been studied extensively\n  since the 1980s, and they are considered essential to guarantee\n  database integrity.\n  In recent years, several authors have studied how the same notion\n  can be adapted to reasoning frameworks, in such a way that they\n  achieve the purpose of guaranteeing a system's consistency, but are\n  kept separate from the reasoning mechanisms.\n\n  In this paper we focus on multi-context systems, a general-purpose\n  framework for combining heterogeneous reasoning systems,\n  enhancing them with a notion of integrity constraints that\n  generalizes the corresponding concept in the database world.\n\\end{abstract}\n\n\n\\section{Introduction}\n\\label{sec:intro}\n\nIntegrity constraints in databases have now been around for decades, and are universally\nacknowledged as one of the essential tools to ensure database\nconsistency~\\cite{Abiteboul1995}.\nThe associated problem of finding out how to repair an inconsistent database -- i.e.,\nchange it so that it again satisfies the integrity constraints -- was soon recognized as\nan important and difficult one~\\cite{Abiteboul1988}, which would unlikely be solvable in a\ncompletely automatic way~\\cite{Eiter1992}.\n\nSince the turn of the century, much focus in research has moved from classical\ndatabases to more powerful reasoning systems, where information is not all explicitly\ndescribed, but may be inferred by logical means.\nIn this setting, an important topic of study is how to combine the reasoning\ncapabilities of different systems, preferrably preserving the properties that make them\nuseful in practice -- e.g.~consistency, decidability of reasoning, efficient computation.\nOne of the most general frameworks to combine reasoning systems abstractly is that of\nheterogeneous nonmonotonic multi-context systems~\\cite{Brewka2007b}.\nBesides being studied from a theoretical perspective, these have been implemented, and\nmany specialized versions have been introduced to deal with particular aspects deemed\nrelevant in practice~\\cite{Brewka2011,DaoTran2010,Goncalves2014,Tasharrofi2014}.\nIn this work, we will work with relational multi-context systems~\\cite{Fink2011}, a\nfirst-order generalization of the original, propositional-based systems, which we\nwill refer to simply as multi-context systems, or MCSs.\n\nAs a very simple kind of reasoning system, databases can naturally be viewed as particular\ncases of MCSs.\nIn this paper we propose to define integrity constraints in MCSs in a way\nthat naturally generalizes the usual definitions for relational databases.\nSome authors have previously discussed modelling integrity constraints in MCSs, but their\napproach differs substantially from the typical database perspective, as integrity\nconstraints are embedded \\emph{into} the system, thereby becoming part of the reasoning\nmechanism -- unlike the situation in databases, where they form an independent layer that\nsimply signals whether the database is in a consistent state.\nWe argue that integrity constraints for MCSs should also follow this principle, and show\nhow our approach is also in line with investigations on how to add integrity constraints\nto other reasoning frameworks, namely description logic knowledge\nbases~\\cite{Fang2011,Motik2009}.\nDue to the richer structure of MCSs, we can define two distinct notions of consistency\nwith respect to integrity constraints, which coincide for the case of databases.\n\nWe also address the problem of repairing an MCS that does not satisfy its integrity\nconstraints by moving to managed multi-context systems (mMCSs)~\\cite{Brewka2011}, which\noffer additional structure that helps defining the notion of repair.\n\n{\\medskip\\noindent\\emph{{Contributions.}}}\nOur main contribution is a uniform notion of integrity constraint over several\nformalisms.\nWe define integrity constraints over an MCS, together with notions of\nweak and strong satisfaction of these.\nWe show that the problem of deciding whether an MCS satisfies a set of integrity\nconstraints is polynomial-time reducible to the problem of deciding whether an MCS is\nlogically consistent (i.e., it has a model).\nWe show how our definition captures the traditional notion of integrity constraints over\nrelational databases, and how it naturally generalizes this concept to distributed\ndatabases and deductive databases.\nWe also compare our definition with existing proposals for integrity constraints over\nontology languages.\nFinally, we define repairs, and show how our definition again generalizes the traditional\nconcept in databases.\n\n{\\medskip\\noindent\\emph{{Outline.}}}\nIn Section~\\ref{sec:background} we introduce the framework of multi-context systems.\nIn Section~\\ref{sec:ic} we define integrity constraints over MCSs, together with the\nnotions of weak and strong satisfaction.\nWe show how we can encode an MCS with integrity constraints as a different MCS, and obtain\ndecidability and complexity results for satisfaction of integrity constraints by reducing\nto the problem of logical consistency.\nIn Section~\\ref{sec:apps} we justify our\n\ndefinition of\nintegrity constraint, by showing that it generalizes the usual concept in relational\ndatabases, as well as other authors' proposals for ontology languages~\\cite{Motik2009} and\npeer-to-peer systems~\\cite{Caroprese2007}.\nWe also show that it induces a natural concept of integrity constraint for distributed\ndatabases, as well as providing a similar notion for deductive databases that is more\nexpressive than the usual one; and provide complexity results for these concrete cases.\nIn Section~\\ref{sec:repair} we recall the notion of a database repair, and show how\nrepairs can be naturally defined in a simple extension of MCSs.\nWe conclude with an overview of our results and future directions in\nSection~\\ref{sec:conclusion}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Related work}\n\nThe topic of integrity constraints has been extensively studied in the literature.\nIn this section, we discuss the work that we feel to be more directly relevant to the\ntasks we carry out in this paper.\n\nIntegrity constraints and updates -- ways of repairing inconsistent databases -- were\nidentified as a seminal problem in database theory almost thirty years\nago~\\cite{Abiteboul1988}.\nThe case for viewing integrity constraints as a layer on top of the database, rather than\nas a component of it, has been made since the 1980s.\nThe idea is that the data inconsistencies captured by integrity constraints need to be\nresolved, but they should not interfere with the ability to continue using the database.\nIn this line, much work has been done e.g.~in query answering from inconsistent\ndatabases~\\cite{Chomicki1999,Chomicki2010}, by ensuring that the only answers generated\nare those that hold in minimally repaired versions of the database.\n\nThe first authors to consider deductive databases~\\cite{Asirelli1985,Gallaire1984} also\ndiscussed this issue.\nThey identify three ways to look at deductive databases: by viewing the whole system as a\nfirst-order theory; by viewing it as an extensional database together with integrity\nconstraints; and a mixed view, where some rules are considered part of the logic theory\nrepresented by the database, and others as integrity constraints identifying preferred\nmodels.\nIn~\\cite{Asirelli1985}, it is argued that this third approach is the correct one, as it\ncleanly separates rules that are meant to be used in logic inferencing from those that\nonly specify consistency requirements.\n\nMore recently, authors have considered adding integrity constraints to open-world systems\nsuch as ontologies.\nAlthough integrity constraints can be written in the syntax of terminological axioms,\nthe authors of~\\cite{Motik2009} discuss why they should still be kept separate from the\nlogical theory.\nTherefore, they separate the axioms in the T-Box (the deductive part of an ontology) into\ntwo groups: reasoning rules, which are used to infer new information, and integrity\nconstraints, which only verify the consistency of the knowledge state without changing it.\n\nThe setting of multiple ontologies was considered in~\\cite{Fang2011}, which considers the\nproblem of combining information from different knowledge sources while guaranteeing the\noverall consistency, and preserving this consistency when one of the individual ontologies\nis changed.\nThis is achieved by external integrity constraints, written in a Datalog-like syntax,\nwhich can refer to knowledge in different ontologies in order to express relationships\nbetween them.\nAgain, the purpose of these rules is uniquely to identify incompatibilities in the data,\nand not to infer new information.\n\n\nBy contrast, the authors who have discussed multi-context systems have not felt the need\nto take a similar approach.\nIntegrity constraints appear routinely in examples in\ne.g.~\\cite{Brewka2011b,Brewka2011,Eiter2014,Eiter2010}, but always encoded within the\nsystem, so that their violation leads to logical inconsistency of the global knowledge\nbase.\nTheir work focuses rather on the aspect of identifying the sources of inconsistencies --\nintegrity constraints being only one example, not given any special analysis -- and ways\nin which it can be repaired.\n\nAlthough we believe this last work to be of the utmost importance, and show how\nsatisfaction of integrity constraints can be reduced to consistency checking (which in\nturn implies that computing repairs can be reduced to restoring consistency), we strive\nfor the clean separation between integrity constraints and reasoning that is present in\nother formalisms, and believe our proposal to be an important complement to the analysis\nof inconsistency in MCSs.\n\n\\section{Background}\n\\label{sec:background}\n\nWe begin this section with a summary of the notion of relational multi-context\nsystem~\\cite{Fink2011}.\nIntuitively, these are a collection of logic knowledge bases -- the\n\\emph{contexts} -- connected by Datalog-style \\emph{bridge rules}.\nThe formal definition proceeds in several layers.\n\nThe first notion is that of \\emph{relational logic}, an abstract notion of a logic with a\nfirst-order sublanguage.\n\n\\begin{definition}\nFormally, a relational logic $L$ is a tuple\n$\\langle{\\mathsf{KB}}_L,{\\mathsf{BS}}_L,{\\mathsf{ACC}}_L,\\Sigma_L\\rangle$, where ${\\mathsf{KB}}_L$ is the set\nof well-formed knowledge bases of $L$ (sets of well-formed formulas), ${\\mathsf{BS}}_L$ is a set of\npossible belief sets (models), ${\\mathsf{ACC}}_L:{\\mathsf{KB}}_L\\to 2^{{\\mathsf{BS}}_L}$ is a function assigning to each\nknowledge base a set of acceptable sets of beliefs (i.e., its models), and $\\Sigma_L$ is a\nsignature consisting of sets $P^{\\mathsf{KB}}_L$ and $P^{\\mathsf{BS}}_L$ of predicate names (with associated\narity) and a universe $U_L$ of object constants, such that\n$U_L\\cap(P^{\\mathsf{KB}}_L\\cup P^{\\mathsf{BS}}_L)=\\emptyset$.\n\\end{definition}\nIf $p\\in P^{\\mathsf{KB}}_L$ has arity $k$ and $c_1,\\ldots,c_k\\in U_L$, then\n$p(c_1,\\ldots,c_k)$ must be an element of some knowledge base, and if\n$p\\in P^{\\mathsf{BS}}_L$, then $p(c_1,\\ldots,c_k)$ must be an element of some\nbelief set.\nTherefore, we can view $\\Sigma_L$ as a first-order signature\ngenerating a sublanguage of $L$.\nThe elements in this sublanguage are called \\emph{relational ground\n  elements}, while the remaining\nelements of knowledge bases or belief sets are called \\emph{ordinary}.\n\n\\begin{example}\n  \\label{ex:FOL}\n  We can see first-order logic over a first-order signature\n  $\\Sigma_{\\ensuremath{\\mathsf{FOL}}}$ as a logic\n  ${\\ensuremath{\\mathsf{FOL}}}=\\langle{\\mathsf{KB}}_{\\ensuremath{\\mathsf{FOL}}},{\\mathsf{BS}}_{\\ensuremath{\\mathsf{FOL}}},{\\mathsf{ACC}}_{\\ensuremath{\\mathsf{FOL}}},\\Sigma_{\\ensuremath{\\mathsf{FOL}}}\\rangle$, where\n  ${\\mathsf{KB}}_{\\ensuremath{\\mathsf{FOL}}}$ is the set of sets of well-formed formulas over\n  $\\Sigma_{\\ensuremath{\\mathsf{FOL}}}$, ${\\mathsf{BS}}_{\\ensuremath{\\mathsf{FOL}}}$ is the set of first-order interpretations\n  over $\\Sigma_{\\ensuremath{\\mathsf{FOL}}}$, and ${\\mathsf{ACC}}_{\\ensuremath{\\mathsf{FOL}}}$ maps each set of formulas to the\n  set of its models.\n  This logic only contains relational elements.\n\\end{example}\n\n\\begin{definition}\nLet $\\mathfrak I$ be a finite set of indices, $\\left\\{L_i\\right\\}_{i\\in\\mathfrak I}$ be a\nset of relational logics, and $V$ be a set of (first-order) variables distinct from\npredicate and constant names in any $L_i$.\nA \\emph{relational element} of $L_i$ has the form $p(t_1,\\ldots,t_k)$, where\n$p\\in P^{\\mathsf{KB}}_{L_i}\\cup P^{\\mathsf{BS}}_{L_i}$ has arity $k$ and each $t_j$ is a term from\n$V\\cup U_{L_i}$, for $1\\leq j\\leq k$.\nA \\emph{relational $k$-bridge rule} over $\\left\\{L_i\\right\\}_{i\\in\\mathfrak I}$ and $V$ is\na rule of the form\n\n", "index": 1, "text": "\\begin{equation}\n\\label{eq:bridge}\n(k:s) \\leftarrow (c_1:p_1),\\ldots,(c_q:p_q), {\\mathsf{not}\\ } (c_{q+1}:p_{q+1}),\\ldots,{\\mathsf{not}\\ }(c_m:p_m)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"(k:s)\\leftarrow(c_{1}:p_{1}),\\ldots,(c_{q}:p_{q}),{\\mathsf{not}\\ }(c_{q+1}:p_{%&#10;q+1}),\\ldots,{\\mathsf{not}\\ }(c_{m}:p_{m})\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo>:</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mn>1</mn></msub><mo>:</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mi>q</mi></msub><mo>:</mo><msub><mi>p</mi><mi>q</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><msub><mi>p</mi><mrow><mi>q</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><msub><mi>c</mi><mi>m</mi></msub><mo>:</mo><msub><mi>p</mi><mi>m</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\n  We will use the MCS $M=\\langle C_1,C_2\\rangle$ to exemplify the\n  concepts we introduce.\n\\end{example}\n\nThe semantics of relational MCSs is defined in terms of ground instances of bridge rules:\nthe instances obtained from each rule $r\\in{\\mathsf{br}}_i$ by uniform substitution of each variable\n$X$ in $r$ by a constant in $\\bigcap D_{i,j}$, with $j$ ranging over the indices of the\ncontexts to which queries containing $X$ are made in $r$.\n\\begin{definition}\nA \\emph{belief state} for $M$ is a collection $S=\\left\\{S_i\\right\\}_{i\\in\\mathfrak I}$\nwhere $S_i\\in{\\mathsf{BS}}_i$ for each $i\\in\\mathfrak I$ -- i.e., a tuple of models, one for each\ncontext.\nThe ground bridge rule~(\\ref{eq:bridge}) is \\emph{applicable} in a belief state $S$ if\n$p_i\\in S_{c_i}$ for $1\\leq i\\leq q$ and $p_i\\not\\in S_{c_i}$ for $q<i\\leq m$.\nThe set of the heads of all applicable ground instances of bridge\nrules of context $C_i$ w.r.t.\\ $S$ is denoted by ${\\mathsf{app}}_i(S)$.\nAn \\emph{equilibrium} is a belief state $S$ such that $S_i\\in{\\mathsf{ACC}}_i({\\mathsf{kb}}_i\\cup{\\mathsf{app}}_i(S))$.\n\\end{definition}\nParticular types of equilibria (minimal, grounded, well-founded)~\\cite{Brewka2007b} can be\ndefined for relational MCSs, but we will not discuss them here.\n\n\\begin{example}\n  \\label{ex:equilibria}\n  In the setting of the previous example, all equilibria of $M$ will have to\n  include the transitive closure of $\\mathsf{R}$ in $S_1$ in the\n  interpretation of $\\mathsf{Rt}$ in $S_2$.\n  For example, if we take $S=\\langle S_1,S_2\\rangle$ with\n  $S_1=\\{\\mathsf{R(a,b)},\\mathsf{R(b,c)}\\}$ and\n  $S_2=\\{\\mathsf{Rt(a,b)},\\mathsf{Rt(b,c)},\\mathsf{Rt(a,c)}\\}$, then $S$ is an\n  equilibrium.\n  However, $S'=\\langle S_1,S'_2\\rangle$ with\n  $S'_2=\\{\\mathsf{Rt(a,b)},\\mathsf{Rt(b,c)}\\}$ is not an equilibrium, as\n  it does not satisfy the second bridge rule.\n\\end{example}\n\nChecking whether an MCS has an equilibrium is known as the \\emph{consistency problem} in\nthe literature.\nWe will refer to this property as \\emph{logical consistency} (to distinguish from\nconsistency w.r.t.~integrity constraints, defined in the next section) throughout this\npaper.\nThis problem has been studied\nextensively~\\cite{Brewka2011b,Eiter2011,Eiter2014,Weinzierl2011}; its decidability depends\non decidability of reasoning in the underlying contexts.\nThe complexity of checking logical consistency of an MCS $M$ depends on the context\ncomplexity of $M$ -- the highest complexity of deciding consistency in one of the contexts\nin $M$ (cf.~\\cite{Eiter2014} for a formal definition and known results).\n\n\n\\section{Integrity constraints on multi-context systems}\n\\label{sec:ic}\n\nIn their full generality, integrity constraints in databases can be arbitrary first-order\nformulas, and reasoning with them is therefore undecidable.\nFor this reason, it is common practice to restrict their syntax in order to regain\ndecidability; our definition follows the standard approach of writing integrity constraints\nin denial clausal form.\n\n\\begin{definition}\n  Let $M=\\langle C_1,\\ldots,C_n\\rangle$ be an MCS.\n  An \\emph{integrity constraint} over an MCS $M$ (in denial form) is a formula\n  \n", "itemtype": "equation", "pos": 14993, "prevtext": "\nsuch that $k,c_i\\in\\mathfrak I$, $s$ is an ordinary or a relational knowledge base element\nof $L_k$ and $p_1,\\ldots,p_m$ are ordinary or relational beliefs of $L_{c_i}$.\n\\end{definition}\nThe notation $(c:p)$ indicates that $p$ is evaluated in context $c$.\nThese rules intuitively generalize logic programming rules, and as\nusual in that context we impose a \\emph{safety condition}: all\nvariables occurring in $p_{q+1},\\ldots,p_m$ must also occur at least\nonce in $p_1,\\ldots,p_q$.\n\n\\begin{definition}\nA \\emph{relational multi-context system} is a collection\n$M=\\left\\{C_i\\right\\}_{i\\in\\mathfrak I}$ of contexts\n$C_i=\\langle L_i,{\\mathsf{kb}}_i,{\\mathsf{br}}_i,D_i\\rangle$, where $L_i$ is a relational logic, ${\\mathsf{kb}}_i$ is a\nknowledge base, ${\\mathsf{br}}_i$ is a set of relational $i$-bridge rules, and $D_i$ is a set of\nimport domains $D_{i,j}$, with $j\\in\\mathfrak I$, such that $D_{i,j}\\subseteq U_j$.\n\\end{definition}\nImport domains define which constants are exported from one context to another: as\nthe underlying logic languages can be different, these sets are essential to allow one\ncontext to reason about individuals introduced in another.\nWe will assume that $D_{i,j}$ is the finite domain consisting of the object constants\nappearing in ${\\mathsf{kb}}_j$ or in the head of a relational bridge rule in ${\\mathsf{br}}_j$, unless\notherwise stated.\n\n\\begin{example}\n  \\label{ex:mcs}\n  Let $C_1$ and $C_2$ be contexts over the first-order logic ${\\ensuremath{\\mathsf{FOL}}}$\n  with $\\mathsf{R}$ and $\\mathsf{Rt}$ binary predicates in\n  $\\Sigma_{\\ensuremath{\\mathsf{FOL}}}$, and let ${\\mathsf{kb}}_1={\\mathsf{kb}}_2=\\emptyset$.\n  We can use the following bridge rules in ${\\mathsf{br}}_2$ to define $\\mathsf{Rt}$ in\n  $C_2$ as the transitive closure of $\\mathsf{R}$ in $C_1$.\n \n", "index": 3, "text": "\\[(2:\\mathsf{Rt}(x,y)) \\leftarrow (1:\\mathsf{R}(x,y))\n    \\qquad\n    (2:\\mathsf{Rt}(x,y)) \\leftarrow (1:\\mathsf{R}(x,z)),(2:\\mathsf{Rt}(z,y))\n  \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"(2:\\mathsf{Rt}(x,y))\\leftarrow(1:\\mathsf{R}(x,y))\\qquad(2:\\mathsf{Rt}(x,y))%&#10;\\leftarrow(1:\\mathsf{R}(x,z)),(2:\\mathsf{Rt}(z,y))\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo>:</mo><mi>\ud835\uddb1\ud835\uddcd</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><mi>\ud835\uddb1</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo>:</mo><mi>\ud835\uddb1\ud835\uddcd</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><mi>\ud835\uddb1</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo>:</mo><mi>\ud835\uddb1\ud835\uddcd</mi><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\n  where $M=\\langle C_1,\\ldots,C_n\\rangle$, $i_k\\in\\{1,\\ldots,n\\}$, each $P_k$ is a\n  relational element of $C_{i_k}$, and the variables in $P_{m+1},\\ldots,P_\\ell$ all occur\n  in $P_1,\\ldots,P_m$.\n\\end{definition}\n\nSyntactically, integrity constraints are similar to ``headless bridge rules''.\nHowever, we will treat them differently: while bridge rules influence the semantics of\nMCSs, being part of the notion of equilibrium, integrity constraints are meant to be\nchecked at the level of equilibria.\n\n\\begin{example}\n  Continuing the example from the previous section, we can write an\n  integrity constraint over $M$ stating that the relation $\\mathsf{R}$ (in\n  context $C_1$) is transitive.\n  \n", "itemtype": "equation", "pos": 18281, "prevtext": "\n  We will use the MCS $M=\\langle C_1,C_2\\rangle$ to exemplify the\n  concepts we introduce.\n\\end{example}\n\nThe semantics of relational MCSs is defined in terms of ground instances of bridge rules:\nthe instances obtained from each rule $r\\in{\\mathsf{br}}_i$ by uniform substitution of each variable\n$X$ in $r$ by a constant in $\\bigcap D_{i,j}$, with $j$ ranging over the indices of the\ncontexts to which queries containing $X$ are made in $r$.\n\\begin{definition}\nA \\emph{belief state} for $M$ is a collection $S=\\left\\{S_i\\right\\}_{i\\in\\mathfrak I}$\nwhere $S_i\\in{\\mathsf{BS}}_i$ for each $i\\in\\mathfrak I$ -- i.e., a tuple of models, one for each\ncontext.\nThe ground bridge rule~(\\ref{eq:bridge}) is \\emph{applicable} in a belief state $S$ if\n$p_i\\in S_{c_i}$ for $1\\leq i\\leq q$ and $p_i\\not\\in S_{c_i}$ for $q<i\\leq m$.\nThe set of the heads of all applicable ground instances of bridge\nrules of context $C_i$ w.r.t.\\ $S$ is denoted by ${\\mathsf{app}}_i(S)$.\nAn \\emph{equilibrium} is a belief state $S$ such that $S_i\\in{\\mathsf{ACC}}_i({\\mathsf{kb}}_i\\cup{\\mathsf{app}}_i(S))$.\n\\end{definition}\nParticular types of equilibria (minimal, grounded, well-founded)~\\cite{Brewka2007b} can be\ndefined for relational MCSs, but we will not discuss them here.\n\n\\begin{example}\n  \\label{ex:equilibria}\n  In the setting of the previous example, all equilibria of $M$ will have to\n  include the transitive closure of $\\mathsf{R}$ in $S_1$ in the\n  interpretation of $\\mathsf{Rt}$ in $S_2$.\n  For example, if we take $S=\\langle S_1,S_2\\rangle$ with\n  $S_1=\\{\\mathsf{R(a,b)},\\mathsf{R(b,c)}\\}$ and\n  $S_2=\\{\\mathsf{Rt(a,b)},\\mathsf{Rt(b,c)},\\mathsf{Rt(a,c)}\\}$, then $S$ is an\n  equilibrium.\n  However, $S'=\\langle S_1,S'_2\\rangle$ with\n  $S'_2=\\{\\mathsf{Rt(a,b)},\\mathsf{Rt(b,c)}\\}$ is not an equilibrium, as\n  it does not satisfy the second bridge rule.\n\\end{example}\n\nChecking whether an MCS has an equilibrium is known as the \\emph{consistency problem} in\nthe literature.\nWe will refer to this property as \\emph{logical consistency} (to distinguish from\nconsistency w.r.t.~integrity constraints, defined in the next section) throughout this\npaper.\nThis problem has been studied\nextensively~\\cite{Brewka2011b,Eiter2011,Eiter2014,Weinzierl2011}; its decidability depends\non decidability of reasoning in the underlying contexts.\nThe complexity of checking logical consistency of an MCS $M$ depends on the context\ncomplexity of $M$ -- the highest complexity of deciding consistency in one of the contexts\nin $M$ (cf.~\\cite{Eiter2014} for a formal definition and known results).\n\n\n\\section{Integrity constraints on multi-context systems}\n\\label{sec:ic}\n\nIn their full generality, integrity constraints in databases can be arbitrary first-order\nformulas, and reasoning with them is therefore undecidable.\nFor this reason, it is common practice to restrict their syntax in order to regain\ndecidability; our definition follows the standard approach of writing integrity constraints\nin denial clausal form.\n\n\\begin{definition}\n  Let $M=\\langle C_1,\\ldots,C_n\\rangle$ be an MCS.\n  An \\emph{integrity constraint} over an MCS $M$ (in denial form) is a formula\n  \n", "index": 5, "text": "\\begin{equation}\n    \\label{eq:ic}\n    \\leftarrow(i_1:P_1),\\ldots,(i_m:P_m),{\\mathsf{not}\\ }(i_{m+1}:P_{m+1}),\\ldots,{\\mathsf{not}\\ }(i_\\ell:P_\\ell)\n  \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\leftarrow(i_{1}:P_{1}),\\ldots,(i_{m}:P_{m}),{\\mathsf{not}\\ }(i_{m+1}:P_{m+1})%&#10;,\\ldots,{\\mathsf{not}\\ }(i_{\\ell}:P_{\\ell})\" display=\"block\"><mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><msub><mi>P</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mi>m</mi></msub><mo>:</mo><msub><mi>P</mi><mi>m</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><msub><mi>P</mi><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>:</mo><msub><mi>P</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\n\\end{example}\n\nThe restriction on variables again amounts to the usual Logic Programming requirement that\nbridge rules be safe.\nTo capture general tuple-generating dependencies we could relax this\nconstraint slightly, and allow $P_{m+1},\\ldots,P_\\ell$ to introduce\nnew variables, with the restriction that they can be used only once in\nthe whole rule.\nThis generalization poses no significant changes to the theory, but\nmakes the presentation heavier, and we will therefore assume safety.\n\n\\begin{definition}\n  Let $M=\\langle C_1,\\ldots,C_n\\rangle$ be an MCS and\n  $S=\\langle S_1,\\ldots,S_n\\rangle$ be a belief state for $M$.\n  Then $S$ satisfies the integrity constraint~\\eqref{eq:ic}\n  if, for every instantiation $\\theta$ of the variables in $P_1,\\ldots,P_m$,\n  either $P_k\\theta\\not\\in S_k$ for some $1\\leq k\\leq m$ or $P_k\\theta\\in S_k$ for\n  some $m<k\\leq\\ell$.\n\\end{definition}\n\nIn other words: equilibria must satisfy all bridge rules (if their body holds, then\nso must their heads), but they may or may not satisfy all integrity constraints.\nIn this sense, integrity constraints express preferences among\nequilibria.\n\n\\begin{example}\n  The equilibrium $S$ from Example~\\ref{ex:equilibria} does not\n  satisfy the integrity constraint~\\eqref{eq:ex-ic}, thus $M$ does not strongly\n  satisfy this formula.\n  However, $M$ weakly satisfies~\\eqref{eq:ex-ic}, as seen by the\n  equilibrium $S''=\\langle S'_1,S'_2\\rangle$ where $S'_2$ is as above and\n  $S'_1=\\{\\mathsf{R(a,b)},\\mathsf{R(b,c)},\\mathsf{R(a,c)}\\}$.\n\\end{example}\n\n\\begin{definition}\n  Let $M$ be an MCS and $\\eta$ be a set of integrity constraints.\n  \\begin{enumerate}\n  \\item $M$ \\emph{strongly satisfies} $\\eta$, $M\\models_s\\eta$, if:\n    (i)~$M$ is logically consistent and\n    (ii)~every equilibrium of $M$ satisfies all integrity constraints in $\\eta$.\n  \\item $M$ \\emph{weakly satisfies} $\\eta$, $M\\models_w\\eta$, if there is an equilibrium\n    of $M$ that satisfies all integrity constraints in $\\eta$.\n  \\end{enumerate}\n\\end{definition}\nWe say that $M$ is (strongly/weakly) \\emph{consistent} w.r.t.~a set of integrity\nconstraints $\\eta$ if $M$ (strongly/weakly) satisfies $\\eta$.\nThese two notions express different interpretations of integrity constraints.\nStrong satisfaction views them as necessary requirements, imposing that all models of the\nMCS to satisfy them.\nExamples of these are the usual integrity constraints over databases, which express\nsemantic connections between relations that must always hold.\nWeak satisfaction views integrity constraints as expressing preferences: the MCS may have\nseveral equilibria, and we see those that do satisfy the integrity constraints as\n``better''.\n\nThe distinction is also related to the use of brave (credulous) or cautious (skeptical)\nreasoning.\nIf $M$ strongly satisfies a set of integrity constraints $\\eta$, then any inferences we\ndraw from $M$ using brave reasoning are guaranteed to hold in some equilibrium that also\nsatisfies $\\eta$.\nIf, however, $M$ only weakly satisfies $\\eta$, then this no longer holds, and we can only\nuse cautious reasoning if we want to be certain that any inferences are still compatible\nwith $\\eta$.\n\nBoth strong and weak satisfaction require $M$ to be logically consistent, so\n$M\\models_s\\eta$ implies $M\\models_w\\eta$.\nThis implies that deciding whether $M\\models_s\\eta$ and $M\\models_w\\eta$ are both at least\nas hard as deciding whether $M$ has an equilibrium -- thus undecidable in the general\ncase.\\footnote{If consistency of one of $M$'s contexts is undecidable, then clearly the\n  question of whether $M$ has an equilibrium is also undecidable.}\nWhen logical consistency of $M$ is decidable and its set of equilibria is enumerable, weak\nsatisfaction is semi-decidable (if there is an equilibrium that satisfies $\\eta$, we\neventually encounter it), while strong satisfaction is co-semi-decidable (if there is an\nequilibrium that does not satisfy $\\eta$, we eventually encounter it).\nThe converse also holds.\n\n\\begin{theorem}\n  \\label{thm:wdec}\n  Weak satisfaction of integrity constraints is reducible to logical consistency.\n\\end{theorem}\n\\begin{proof}\n  To decide whether $M\\models_w\\eta$,\n  construct $M'$ by extending $M$ with a context $C_0$ where ${\\mathsf{KB}}_0=\\wp(\\{\\ast\\})$,\n  ${\\mathsf{kb}}_0=\\emptyset$, ${\\mathsf{ACC}}_0(\\emptyset)=\\{\\emptyset\\}$, ${\\mathsf{ACC}}_0(\\{\\ast\\})=\\emptyset$, and\n  the bridge rules obtained by adding $(0:\\ast)$ to the head of the rules in $\\eta$.\n  Then $M'$ has an equilibrium iff $M\\models_w\\eta$: any equilibrium\n  of $M$ not satisfying $\\eta$ corresponds to a belief state of\n  $M'$ where ${\\mathsf{app}}_0(S)=\\{\\ast\\}$, which is never an equilibrium\n  of $M'$; but equilibria of $M$ satisfying $\\eta$ give rise to\n  equilibria of $M'$ taking $S_0=\\emptyset$.\n  \\qed\n\\end{proof}\n\n\\begin{theorem}\n  \\label{thm:sdec}\n  Strong satisfaction of integrity constraints is reducible to logical inconsistency.\n\\end{theorem}\n\\begin{proof}\n  Construct $M'$ as before, but now defining ${\\mathsf{ACC}}_0(\\emptyset)=\\emptyset$,\n  ${\\mathsf{ACC}}_0(\\{\\ast\\})=\\{\\{\\ast\\}\\}$.\n  If $M$ is inconsistent, then $M\\not\\models_s\\eta$.\n  If $M$ is consistent, then any equilibrium of $M$ satisfying $\\eta$ corresponds to a\n  belief state of $M'$ where ${\\mathsf{app}}_0(S)=\\emptyset$, which can never be an\n  equilibrium of $M'$; in turn, equilibria of $M$ not satisfying $\\eta$\n  give rise to equilibria of $M'$ taking $S_0=\\{\\ast\\}$.\n  So if $M$ is consistent, then $M\\models_s\\eta$ iff $M'$ is inconsistent.\n  \\qed\n\\end{proof}\n\nCombining the two above results with the well-known complexity results for consistency checking (Table 1 in \\cite{Eiter2014}), we directly obtain the following results.\n\n\\begin{corollary}\nThe complexity of deciding whether $M \\models_w \\eta$ or $M \\models_s \\eta$, depending on the context complexity of $M$, $\\mathcal{CC}(M)$, is given in Table~\\ref{tab:complexity}.\n\\end{corollary}\n\n\\begin{table}[t]\n\\begin{center}\n\\begin{tabular}{r@{\\hskip1em}|@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c}\n$\\mathcal{CC}(M)$ & P & NP & $\\Sigma^p_i$ & PSPACE & EXPTIME\\\\\n\\hline\n$M \\models_w \\eta$ & NP & NP & $\\Sigma^p_i$ & PSPACE & EXPTIME\\\\\n$M \\models_s \\eta$ & $\\Delta^p_2$ & $\\Delta^p_2$ & $\\Delta^p_{i+1}$ & PSPACE & EXPTIME\\\\\n\\end{tabular}\n\\end{center}\n\\caption{Complexity of integrity checking of an MCS in terms of its context complexity.}\n\\label{tab:complexity}\n\\end{table}\n\nThese results suggest an alternative way of modelling integrity constraints in MCSs:\nadding them as bridge rules whose head is a special atom interpreted as\ninconsistency.\nThis approach was taken in e.g.~\\cite{Eiter2011}.\nHowever, we believe that integrity constraints should be kept separate from the data, and\nhaving them as a separate layer achieves this purpose.\nIn this way, we do not restrict the models of MCSs, and we avoid issues of logical\ninconsistency.\nFurthermore, violation of integrity constraints typically is indicative of some error in\nthe model or in the data, which should result in an alert and not in additional\ninferences.\n\nThese considerations are similar to those made in Section~2.7 of~\\cite{Motik2009} and in \\cite{Fang2011}, in the (more restricted) context of integrity constraints over description logic knowledge bases. Likewise, the approach taken for integrity constraints in databases is that inconsistencies should be brought to the users' attention, but not affect the semantics of the database \\cite{Abiteboul1988,Eiter1992}. In particular, it may be meaningful to work with reasoning systems not satisfying integrity constraints (see \\cite{Chomicki2010} for databases and \\cite{Eiter2010} for description logic knowledge bases). Our approach is also in line with \\cite{Brewka2011}, where it is argued that in MCSs it is important to ``distinguish data from additional operations on it''.\n\n\n\n\n\\section{Applications of ICs for MCSs}\n\\label{sec:apps}\n\nIn this section we look at particular cases of MCSs with integrity\nconstraints.\nWe begin by showing that our notion generalizes the usual one for\nstandard databases.\nThen we look into other types of databases and show how we obtain\ninteresting notions for these systems.\n\n\\subsection{Relational databases}\n\nIntegrity constraints in relational databases can be written as first-order\nformulas in denial clausal form~\\cite{Flesca2004} -- which are\nessentially equivalent in form to bridge rules with no head.\n\n\\begin{definition}\n  Let $DB$ be a database.\n  The context generated by $DB$, ${\\ensuremath{\\mathsf{Ctx}}}(DB)$, is defined as follows.\n  \\begin{itemize}\n  \\item The underlying logic is first-order logic.\n  \\item Belief sets are sets of ground literals.\n  \\item The knowledge base is $DB$.\n  \\item For all ${\\mathsf{kb}}$, the only belief set compatible with ${\\mathsf{kb}}$ is\n    ${\\mathsf{ACC}}({\\mathsf{kb}})={\\mathsf{kb}}^\\vdash={\\mathsf{kb}}\\cup\\{\\neg a\\mid a\\not\\in{\\mathsf{kb}}\\}$.\n  \\item The set of bridge rules is empty.\n  \\end{itemize}\n\\end{definition}\nWe can see any database $DB$ as a single-context MCS consisting of\nexactly the context ${\\ensuremath{\\mathsf{Ctx}}}(DB)$; we will also denote this MCS by\n${\\ensuremath{\\mathsf{Ctx}}}(DB)$, as this poses no ambiguity.\nThe only equilibrium for ${\\ensuremath{\\mathsf{Ctx}}}(DB)$ is $DB^\\vdash$ itself,\ncorresponding to the usual closed-world semantics of relational databases.\nPrevious work (cf.~\\cite{Brewka2011,Eiter2014}) implicitly treats\ndatabases in this way, although ${\\ensuremath{\\mathsf{Ctx}}}$ is not formally defined.\n\nLet $DB$ be a database and $r$ be an integrity constraint over $DB$ in\ndenial clausal form.\nWe can rewrite $r$ as an integrity constraint over ${\\ensuremath{\\mathsf{Ctx}}}(DB)$: if $r$\nis\n$\\forall(A_1\\wedge\\ldots\\wedge A_k\\wedge\\neg B_1\\wedge\\ldots\\wedge\\neg B_m\\to\\bot)$,\nthen ${\\mathsf{br}}(r)$ is\n", "itemtype": "equation", "pos": 19142, "prevtext": "\n  where $M=\\langle C_1,\\ldots,C_n\\rangle$, $i_k\\in\\{1,\\ldots,n\\}$, each $P_k$ is a\n  relational element of $C_{i_k}$, and the variables in $P_{m+1},\\ldots,P_\\ell$ all occur\n  in $P_1,\\ldots,P_m$.\n\\end{definition}\n\nSyntactically, integrity constraints are similar to ``headless bridge rules''.\nHowever, we will treat them differently: while bridge rules influence the semantics of\nMCSs, being part of the notion of equilibrium, integrity constraints are meant to be\nchecked at the level of equilibria.\n\n\\begin{example}\n  Continuing the example from the previous section, we can write an\n  integrity constraint over $M$ stating that the relation $\\mathsf{R}$ (in\n  context $C_1$) is transitive.\n  \n", "index": 7, "text": "\\begin{equation}\n    \\label{eq:ex-ic}\n    \\leftarrow(2:\\mathsf{Rt}(x,y)),{\\mathsf{not}\\ }(1:\\mathsf{R}(x,y))\n  \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\leftarrow(2:\\mathsf{Rt}(x,y)),{\\mathsf{not}\\ }(1:\\mathsf{R}(x,y))\" display=\"block\"><mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo>:</mo><mi>\ud835\uddb1\ud835\uddcd</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><mi>\ud835\uddb1</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\nNote that general tuple-generating dependencies require allowing singleton variables in\nthe $B_i$s, as discussed earlier.\nThe following result is straightforward to prove.\nIf we assume first-order logic with equality, we can also write equality-generating\nconstraints, thus obtaining the expressivity used in databases.\n\n\\begin{theorem}\n  \\label{thm:db}\n  Let $DB$ be a database and $\\eta$ be a set of ICs over $DB$.\n  Then $DB$ satisfies all ICs in $\\eta$ iff\n  ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models_s{\\mathsf{br}}(\\eta)$ iff ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models_w{\\mathsf{br}}(\\eta)$, where ${\\mathsf{br}}$ is\n  extended to sets in the standard way.\n\\end{theorem}\n\nIn this setting, weak and strong satisfaction of integrity constraints\ncoincide, as every database has exactly one equilibrium.\nFurthermore, deciding whether ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models{\\mathsf{br}}(\\eta)$ can be done\nin time $O(|DB|\\times|\\eta|)$, where $|DB|$ is the number of elements\nin $DB$ and $|\\eta|$ is the total number of literals in all integrity\nconstraints in $\\eta$. This means that the data complexity~\\cite{Vardi1982} of this\nproblem is linear, as we can query the database using the open bridge\nrules in $\\eta$, rather than considering the set of all ground instances of\nthose rules.\n\nTheorem~\\ref{thm:db} could be obtained by adding integrity constraints as bridge rules\nwith a special inconsistency atom, as discussed earlier, and done in~\\cite{Eiter2011}).\nThis would significantly blur the picture, though, as in principle nothing would\nprevent us from writing integrity constraints referencing the inconsistency atom\nin their body, potentially leading to circular reasoning. Our approach guarantees\nthat there is no such internalization of inconsistencies into the database.\n\nOur results show that the notion of integrity\nconstraint we propose directly generalizes the traditional notion of\nintegrity constraints over databases~\\cite{Abiteboul1988}.\n\n\\subsection{Distributed DBs}\n\\label{sec:distr-db}\n\nDistributed databases are databases that store their information at\ndifferent sites in a network, typically including information that is\nduplicated at different nodes~\\cite{Ullman1988} in order to promote\nresilience of the whole system.\n\nA distributed database consisting of individual databases\n$DB_1,\\ldots,DB_n$ can be modeled as an MCS with $n$ contexts\n${\\ensuremath{\\mathsf{Ctx}}}(DB_1),\\ldots,{\\ensuremath{\\mathsf{Ctx}}}(DB_n)$.\nThe internal consistency of the database, in the sense that tables\nthat occur in different $DB_i$s must have the same rows, can be\nspecified as integrity constraints over this MCS as follows.\nFor each relation $p$, let $\\gamma(p)$ be the number of columns of $p$\nand $\\delta(p)$ be the set of indices of the databases containing $p$.\nThen\n", "itemtype": "equation", "pos": 29064, "prevtext": "\n\\end{example}\n\nThe restriction on variables again amounts to the usual Logic Programming requirement that\nbridge rules be safe.\nTo capture general tuple-generating dependencies we could relax this\nconstraint slightly, and allow $P_{m+1},\\ldots,P_\\ell$ to introduce\nnew variables, with the restriction that they can be used only once in\nthe whole rule.\nThis generalization poses no significant changes to the theory, but\nmakes the presentation heavier, and we will therefore assume safety.\n\n\\begin{definition}\n  Let $M=\\langle C_1,\\ldots,C_n\\rangle$ be an MCS and\n  $S=\\langle S_1,\\ldots,S_n\\rangle$ be a belief state for $M$.\n  Then $S$ satisfies the integrity constraint~\\eqref{eq:ic}\n  if, for every instantiation $\\theta$ of the variables in $P_1,\\ldots,P_m$,\n  either $P_k\\theta\\not\\in S_k$ for some $1\\leq k\\leq m$ or $P_k\\theta\\in S_k$ for\n  some $m<k\\leq\\ell$.\n\\end{definition}\n\nIn other words: equilibria must satisfy all bridge rules (if their body holds, then\nso must their heads), but they may or may not satisfy all integrity constraints.\nIn this sense, integrity constraints express preferences among\nequilibria.\n\n\\begin{example}\n  The equilibrium $S$ from Example~\\ref{ex:equilibria} does not\n  satisfy the integrity constraint~\\eqref{eq:ex-ic}, thus $M$ does not strongly\n  satisfy this formula.\n  However, $M$ weakly satisfies~\\eqref{eq:ex-ic}, as seen by the\n  equilibrium $S''=\\langle S'_1,S'_2\\rangle$ where $S'_2$ is as above and\n  $S'_1=\\{\\mathsf{R(a,b)},\\mathsf{R(b,c)},\\mathsf{R(a,c)}\\}$.\n\\end{example}\n\n\\begin{definition}\n  Let $M$ be an MCS and $\\eta$ be a set of integrity constraints.\n  \\begin{enumerate}\n  \\item $M$ \\emph{strongly satisfies} $\\eta$, $M\\models_s\\eta$, if:\n    (i)~$M$ is logically consistent and\n    (ii)~every equilibrium of $M$ satisfies all integrity constraints in $\\eta$.\n  \\item $M$ \\emph{weakly satisfies} $\\eta$, $M\\models_w\\eta$, if there is an equilibrium\n    of $M$ that satisfies all integrity constraints in $\\eta$.\n  \\end{enumerate}\n\\end{definition}\nWe say that $M$ is (strongly/weakly) \\emph{consistent} w.r.t.~a set of integrity\nconstraints $\\eta$ if $M$ (strongly/weakly) satisfies $\\eta$.\nThese two notions express different interpretations of integrity constraints.\nStrong satisfaction views them as necessary requirements, imposing that all models of the\nMCS to satisfy them.\nExamples of these are the usual integrity constraints over databases, which express\nsemantic connections between relations that must always hold.\nWeak satisfaction views integrity constraints as expressing preferences: the MCS may have\nseveral equilibria, and we see those that do satisfy the integrity constraints as\n``better''.\n\nThe distinction is also related to the use of brave (credulous) or cautious (skeptical)\nreasoning.\nIf $M$ strongly satisfies a set of integrity constraints $\\eta$, then any inferences we\ndraw from $M$ using brave reasoning are guaranteed to hold in some equilibrium that also\nsatisfies $\\eta$.\nIf, however, $M$ only weakly satisfies $\\eta$, then this no longer holds, and we can only\nuse cautious reasoning if we want to be certain that any inferences are still compatible\nwith $\\eta$.\n\nBoth strong and weak satisfaction require $M$ to be logically consistent, so\n$M\\models_s\\eta$ implies $M\\models_w\\eta$.\nThis implies that deciding whether $M\\models_s\\eta$ and $M\\models_w\\eta$ are both at least\nas hard as deciding whether $M$ has an equilibrium -- thus undecidable in the general\ncase.\\footnote{If consistency of one of $M$'s contexts is undecidable, then clearly the\n  question of whether $M$ has an equilibrium is also undecidable.}\nWhen logical consistency of $M$ is decidable and its set of equilibria is enumerable, weak\nsatisfaction is semi-decidable (if there is an equilibrium that satisfies $\\eta$, we\neventually encounter it), while strong satisfaction is co-semi-decidable (if there is an\nequilibrium that does not satisfy $\\eta$, we eventually encounter it).\nThe converse also holds.\n\n\\begin{theorem}\n  \\label{thm:wdec}\n  Weak satisfaction of integrity constraints is reducible to logical consistency.\n\\end{theorem}\n\\begin{proof}\n  To decide whether $M\\models_w\\eta$,\n  construct $M'$ by extending $M$ with a context $C_0$ where ${\\mathsf{KB}}_0=\\wp(\\{\\ast\\})$,\n  ${\\mathsf{kb}}_0=\\emptyset$, ${\\mathsf{ACC}}_0(\\emptyset)=\\{\\emptyset\\}$, ${\\mathsf{ACC}}_0(\\{\\ast\\})=\\emptyset$, and\n  the bridge rules obtained by adding $(0:\\ast)$ to the head of the rules in $\\eta$.\n  Then $M'$ has an equilibrium iff $M\\models_w\\eta$: any equilibrium\n  of $M$ not satisfying $\\eta$ corresponds to a belief state of\n  $M'$ where ${\\mathsf{app}}_0(S)=\\{\\ast\\}$, which is never an equilibrium\n  of $M'$; but equilibria of $M$ satisfying $\\eta$ give rise to\n  equilibria of $M'$ taking $S_0=\\emptyset$.\n  \\qed\n\\end{proof}\n\n\\begin{theorem}\n  \\label{thm:sdec}\n  Strong satisfaction of integrity constraints is reducible to logical inconsistency.\n\\end{theorem}\n\\begin{proof}\n  Construct $M'$ as before, but now defining ${\\mathsf{ACC}}_0(\\emptyset)=\\emptyset$,\n  ${\\mathsf{ACC}}_0(\\{\\ast\\})=\\{\\{\\ast\\}\\}$.\n  If $M$ is inconsistent, then $M\\not\\models_s\\eta$.\n  If $M$ is consistent, then any equilibrium of $M$ satisfying $\\eta$ corresponds to a\n  belief state of $M'$ where ${\\mathsf{app}}_0(S)=\\emptyset$, which can never be an\n  equilibrium of $M'$; in turn, equilibria of $M$ not satisfying $\\eta$\n  give rise to equilibria of $M'$ taking $S_0=\\{\\ast\\}$.\n  So if $M$ is consistent, then $M\\models_s\\eta$ iff $M'$ is inconsistent.\n  \\qed\n\\end{proof}\n\nCombining the two above results with the well-known complexity results for consistency checking (Table 1 in \\cite{Eiter2014}), we directly obtain the following results.\n\n\\begin{corollary}\nThe complexity of deciding whether $M \\models_w \\eta$ or $M \\models_s \\eta$, depending on the context complexity of $M$, $\\mathcal{CC}(M)$, is given in Table~\\ref{tab:complexity}.\n\\end{corollary}\n\n\\begin{table}[t]\n\\begin{center}\n\\begin{tabular}{r@{\\hskip1em}|@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c@{\\hskip1em}c}\n$\\mathcal{CC}(M)$ & P & NP & $\\Sigma^p_i$ & PSPACE & EXPTIME\\\\\n\\hline\n$M \\models_w \\eta$ & NP & NP & $\\Sigma^p_i$ & PSPACE & EXPTIME\\\\\n$M \\models_s \\eta$ & $\\Delta^p_2$ & $\\Delta^p_2$ & $\\Delta^p_{i+1}$ & PSPACE & EXPTIME\\\\\n\\end{tabular}\n\\end{center}\n\\caption{Complexity of integrity checking of an MCS in terms of its context complexity.}\n\\label{tab:complexity}\n\\end{table}\n\nThese results suggest an alternative way of modelling integrity constraints in MCSs:\nadding them as bridge rules whose head is a special atom interpreted as\ninconsistency.\nThis approach was taken in e.g.~\\cite{Eiter2011}.\nHowever, we believe that integrity constraints should be kept separate from the data, and\nhaving them as a separate layer achieves this purpose.\nIn this way, we do not restrict the models of MCSs, and we avoid issues of logical\ninconsistency.\nFurthermore, violation of integrity constraints typically is indicative of some error in\nthe model or in the data, which should result in an alert and not in additional\ninferences.\n\nThese considerations are similar to those made in Section~2.7 of~\\cite{Motik2009} and in \\cite{Fang2011}, in the (more restricted) context of integrity constraints over description logic knowledge bases. Likewise, the approach taken for integrity constraints in databases is that inconsistencies should be brought to the users' attention, but not affect the semantics of the database \\cite{Abiteboul1988,Eiter1992}. In particular, it may be meaningful to work with reasoning systems not satisfying integrity constraints (see \\cite{Chomicki2010} for databases and \\cite{Eiter2010} for description logic knowledge bases). Our approach is also in line with \\cite{Brewka2011}, where it is argued that in MCSs it is important to ``distinguish data from additional operations on it''.\n\n\n\n\n\\section{Applications of ICs for MCSs}\n\\label{sec:apps}\n\nIn this section we look at particular cases of MCSs with integrity\nconstraints.\nWe begin by showing that our notion generalizes the usual one for\nstandard databases.\nThen we look into other types of databases and show how we obtain\ninteresting notions for these systems.\n\n\\subsection{Relational databases}\n\nIntegrity constraints in relational databases can be written as first-order\nformulas in denial clausal form~\\cite{Flesca2004} -- which are\nessentially equivalent in form to bridge rules with no head.\n\n\\begin{definition}\n  Let $DB$ be a database.\n  The context generated by $DB$, ${\\ensuremath{\\mathsf{Ctx}}}(DB)$, is defined as follows.\n  \\begin{itemize}\n  \\item The underlying logic is first-order logic.\n  \\item Belief sets are sets of ground literals.\n  \\item The knowledge base is $DB$.\n  \\item For all ${\\mathsf{kb}}$, the only belief set compatible with ${\\mathsf{kb}}$ is\n    ${\\mathsf{ACC}}({\\mathsf{kb}})={\\mathsf{kb}}^\\vdash={\\mathsf{kb}}\\cup\\{\\neg a\\mid a\\not\\in{\\mathsf{kb}}\\}$.\n  \\item The set of bridge rules is empty.\n  \\end{itemize}\n\\end{definition}\nWe can see any database $DB$ as a single-context MCS consisting of\nexactly the context ${\\ensuremath{\\mathsf{Ctx}}}(DB)$; we will also denote this MCS by\n${\\ensuremath{\\mathsf{Ctx}}}(DB)$, as this poses no ambiguity.\nThe only equilibrium for ${\\ensuremath{\\mathsf{Ctx}}}(DB)$ is $DB^\\vdash$ itself,\ncorresponding to the usual closed-world semantics of relational databases.\nPrevious work (cf.~\\cite{Brewka2011,Eiter2014}) implicitly treats\ndatabases in this way, although ${\\ensuremath{\\mathsf{Ctx}}}$ is not formally defined.\n\nLet $DB$ be a database and $r$ be an integrity constraint over $DB$ in\ndenial clausal form.\nWe can rewrite $r$ as an integrity constraint over ${\\ensuremath{\\mathsf{Ctx}}}(DB)$: if $r$\nis\n$\\forall(A_1\\wedge\\ldots\\wedge A_k\\wedge\\neg B_1\\wedge\\ldots\\wedge\\neg B_m\\to\\bot)$,\nthen ${\\mathsf{br}}(r)$ is\n", "index": 9, "text": "\n\\[\\leftarrow(1:A_1),\\ldots,(1:A_k),{\\mathsf{not}\\ }(1:B_1),\\ldots,{\\mathsf{not}\\ }(1:B_m)\\,.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\leftarrow(1:A_{1}),\\ldots,(1:A_{k}),{\\mathsf{not}\\ }(1:B_{1}),\\ldots,{\\mathsf%&#10;{not}\\ }(1:B_{m})\\,.\" display=\"block\"><mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><msub><mi>B</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>:</mo><msub><mi>B</mi><mi>m</mi></msub><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\nlogically specifies the integrity of the system.\nDifferent strategies for fixing inconsistencies in distributed\ndatabases (e.g.~majority vote or siding with the most recently updated\nnode) correspond to different preferences for choosing repairs in the\nsense of the next section.\n\nAgain, such integrity constraints can be written as bridge rules in the form\n", "itemtype": "equation", "pos": 31943, "prevtext": "\nNote that general tuple-generating dependencies require allowing singleton variables in\nthe $B_i$s, as discussed earlier.\nThe following result is straightforward to prove.\nIf we assume first-order logic with equality, we can also write equality-generating\nconstraints, thus obtaining the expressivity used in databases.\n\n\\begin{theorem}\n  \\label{thm:db}\n  Let $DB$ be a database and $\\eta$ be a set of ICs over $DB$.\n  Then $DB$ satisfies all ICs in $\\eta$ iff\n  ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models_s{\\mathsf{br}}(\\eta)$ iff ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models_w{\\mathsf{br}}(\\eta)$, where ${\\mathsf{br}}$ is\n  extended to sets in the standard way.\n\\end{theorem}\n\nIn this setting, weak and strong satisfaction of integrity constraints\ncoincide, as every database has exactly one equilibrium.\nFurthermore, deciding whether ${\\ensuremath{\\mathsf{Ctx}}}(DB)\\models{\\mathsf{br}}(\\eta)$ can be done\nin time $O(|DB|\\times|\\eta|)$, where $|DB|$ is the number of elements\nin $DB$ and $|\\eta|$ is the total number of literals in all integrity\nconstraints in $\\eta$. This means that the data complexity~\\cite{Vardi1982} of this\nproblem is linear, as we can query the database using the open bridge\nrules in $\\eta$, rather than considering the set of all ground instances of\nthose rules.\n\nTheorem~\\ref{thm:db} could be obtained by adding integrity constraints as bridge rules\nwith a special inconsistency atom, as discussed earlier, and done in~\\cite{Eiter2011}).\nThis would significantly blur the picture, though, as in principle nothing would\nprevent us from writing integrity constraints referencing the inconsistency atom\nin their body, potentially leading to circular reasoning. Our approach guarantees\nthat there is no such internalization of inconsistencies into the database.\n\nOur results show that the notion of integrity\nconstraint we propose directly generalizes the traditional notion of\nintegrity constraints over databases~\\cite{Abiteboul1988}.\n\n\\subsection{Distributed DBs}\n\\label{sec:distr-db}\n\nDistributed databases are databases that store their information at\ndifferent sites in a network, typically including information that is\nduplicated at different nodes~\\cite{Ullman1988} in order to promote\nresilience of the whole system.\n\nA distributed database consisting of individual databases\n$DB_1,\\ldots,DB_n$ can be modeled as an MCS with $n$ contexts\n${\\ensuremath{\\mathsf{Ctx}}}(DB_1),\\ldots,{\\ensuremath{\\mathsf{Ctx}}}(DB_n)$.\nThe internal consistency of the database, in the sense that tables\nthat occur in different $DB_i$s must have the same rows, can be\nspecified as integrity constraints over this MCS as follows.\nFor each relation $p$, let $\\gamma(p)$ be the number of columns of $p$\nand $\\delta(p)$ be the set of indices of the databases containing $p$.\nThen\n", "index": 11, "text": "\n\\[\\{\\leftarrow(i:p(x_1,\\ldots,x_{\\gamma(p)})), {\\mathsf{not}\\ }(j:p(x_1,\\ldots,x_{\\gamma(p)}))\\mid i,j\\in\\delta(p), \\mbox{$p$ is a relation}\\}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\{\\leftarrow(i:p(x_{1},\\ldots,x_{\\gamma(p)})),{\\mathsf{not}\\ }(j:p(x_{1},%&#10;\\ldots,x_{\\gamma(p)}))\\mid i,j\\in\\delta(p),\\mbox{$p$ is a relation}\\}\" display=\"block\"><mrow><mo stretchy=\"false\">{</mo><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>:</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mi>j</mi><mo>:</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2223</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>\u2208</mo><mi>\u03b4</mi><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mi>p</mi><mtext>\u00a0is a relation</mtext></mrow><mo stretchy=\"false\">}</mo></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\nbut these significantly change the semantics of the database: instead of\ndescribing preferred equilibria, they impose a flow of information between nodes. \n\n\n\n\n\\begin{example}\n\\label{ex:cpr}\nConsider a country with a central person register (CPR), mapping a unique identifying\nnumber to the name and current address of each citizen using a relation ${\\sf person}$,\ne.g.\\ ${\\sf person}(1111111118,{\\it old\\_lady},{\\it gjern})$.\nFurthermore, each electoral district keeps a local voter register using a relation\n${\\sf voter}$, e.g.\\ ${\\sf voter}(1111111118)$, and a list of addresses local to the given\nelectoral district using a relation ${\\sf address}$,\ne.g.~${\\sf address}({\\it gjern})$.\nThen the integrity constraints \n\n", "itemtype": "equation", "pos": 32446, "prevtext": "\nlogically specifies the integrity of the system.\nDifferent strategies for fixing inconsistencies in distributed\ndatabases (e.g.~majority vote or siding with the most recently updated\nnode) correspond to different preferences for choosing repairs in the\nsense of the next section.\n\nAgain, such integrity constraints can be written as bridge rules in the form\n", "index": 13, "text": "\n\\[(j:p(x_1,\\ldots,x_{\\gamma(p)})) \\leftarrow (i:p(x_1,\\ldots,x_{\\gamma(p)}))\\,.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"(j:p(x_{1},\\ldots,x_{\\gamma(p)}))\\leftarrow(i:p(x_{1},\\ldots,x_{\\gamma(p)}))\\,.\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">(</mo><mi>j</mi><mo>:</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>:</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\nensure that all voters registered in the Silkeborg electoral district are registered in\nthe central person register, and that they are registered with an address that is local to\nthe Silkeborg electoral district.\nHere, we are implicitly assuming that the database is closed under projection, and\noverload the {\\sf person} relation for the sake of simplicity.\nIn addition, the following set of integrity constaints models the fact that each person\nregistered in the Silkeborg electoral district is not registered in any other electoral\ndistricts from the set ${\\it ED}$.\n", "itemtype": "equation", "pos": 33250, "prevtext": "\nbut these significantly change the semantics of the database: instead of\ndescribing preferred equilibria, they impose a flow of information between nodes. \n\n\n\n\n\\begin{example}\n\\label{ex:cpr}\nConsider a country with a central person register (CPR), mapping a unique identifying\nnumber to the name and current address of each citizen using a relation ${\\sf person}$,\ne.g.\\ ${\\sf person}(1111111118,{\\it old\\_lady},{\\it gjern})$.\nFurthermore, each electoral district keeps a local voter register using a relation\n${\\sf voter}$, e.g.\\ ${\\sf voter}(1111111118)$, and a list of addresses local to the given\nelectoral district using a relation ${\\sf address}$,\ne.g.~${\\sf address}({\\it gjern})$.\nThen the integrity constraints \n\n", "index": 15, "text": "\\begin{align}\n&\\leftarrow {\\sf Skborg}: {\\sf voter}({\\it Id}), {\\mathsf{not}\\ }({\\sf CPR}: {\\sf person}({\\it Id}))\\\\\n&\\leftarrow {\\sf Skborg}: {\\sf voter}({\\it Id}), {\\sf CPR}: {\\sf person}({\\it Id},{\\it Add}), {\\mathsf{not}\\ }({\\sf Skborg} : {\\sf address}({\\it Add})) \\label{ic1}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leftarrow{\\sf Skborg}:{\\sf voter}({\\it Id}),{\\mathsf{not}\\ }({%&#10;\\sf CPR}:{\\sf person}({\\it Id}))\" display=\"inline\"><mrow><mo>\u2190</mo><mi>\ud835\uddb2\ud835\uddc4\ud835\uddbb\ud835\uddc8\ud835\uddcb\ud835\uddc0</mi><mo>:</mo><mi>\ud835\uddcf\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddcb</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udda2\ud835\uddaf\ud835\uddb1</mi><mo>:</mo><mi>\ud835\uddc9\ud835\uddbe\ud835\uddcb\ud835\uddcc\ud835\uddc8\ud835\uddc7</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leftarrow{\\sf Skborg}:{\\sf voter}({\\it Id}),{\\sf CPR}:{\\sf person%&#10;}({\\it Id},{\\it Add}),{\\mathsf{not}\\ }({\\sf Skborg}:{\\sf address}({\\it Add}))\" display=\"inline\"><mrow><mo>\u2190</mo><mi>\ud835\uddb2\ud835\uddc4\ud835\uddbb\ud835\uddc8\ud835\uddcb\ud835\uddc0</mi><mo>:</mo><mi>\ud835\uddcf\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddcb</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>\ud835\udda2\ud835\uddaf\ud835\uddb1</mi><mo>:</mo><mi>\ud835\uddc9\ud835\uddbe\ud835\uddcb\ud835\uddcc\ud835\uddc8\ud835\uddc7</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo>,</mo><mi>\ud835\udc34\ud835\udc51\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\uddb2\ud835\uddc4\ud835\uddbb\ud835\uddc8\ud835\uddcb\ud835\uddc0</mi><mo>:</mo><mi>\ud835\uddba\ud835\uddbd\ud835\uddbd\ud835\uddcb\ud835\uddbe\ud835\uddcc\ud835\uddcc</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc34\ud835\udc51\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\n\\end{example}\n\n\nThis assumption of closure under projection is meaningful from a\npractical point of view, and has been implemented e.g.\\ in~\\cite{KMIS2015}.\nAlternatively, we could define the projections as bridge rules of the MCSs, in line with\nthe idea of encoding views of deductive databases presented in the next section.\n\nThis section's treatment of distributed databases is equivalent to considering their\ndisjoint union as a database.\nConsequently, there is no need to use MCSs for distributed databases, but this mapping\nshows that our notion of integrity constraints abstracts the practice in this field.\nFurthermore, results in previous work~\\cite{LCF2014} indicate that the processing of\nintegrity constraints can be efficiently parallelized in this disjoint scenario, given\nsuitable assumptions.\n\n\\subsection{Deductive DBs}\n\nWe now address the case of deductive databases.\nThese consist of two different components: the (extensional) fact\ndatabase, containing only concrete instances of relations, and the\n(intensional) rule database, containing Datalog-style rules defining\nnew relations.\nEvery relation must be either intensional or extensional, unlike in\ne.g.~full-fledged logic programming.\n\nOne standard way to see the intensional component(s) of deductive\ndatabases is as \\emph{views} of the original database.\nThe instances of the new relations defined by rules are generated\nautomatically from the data in the database, and these\nrelations can thus be seen as content-free, having a purely\npresentational nature.\nFor simplicity of presentation, we consider the case where there\nis one single view.\n\n\\begin{definition}\n  Let $\\Sigma_E$ and $\\Sigma_I$ be two disjoint first-order signatures.\n  A \\emph{deductive database} over $\\Sigma_E$ and $\\Sigma_I$ is a pair\n  $\\langle DB,R\\rangle$, where $DB$ is a relational database over\n  $\\Sigma_E$ and $R$ is a set of rules of the form\n  $p\\leftarrow q_1,\\ldots,q_n$,\n  where $p$ is an atom of $\\Sigma_I$ and $q_1,\\ldots,q_n$ are atoms\n  over $\\Sigma_E\\cup\\Sigma_I$.\n\\end{definition}\nMore precisely, this definition corresponds to the definite deductive databases\nin~\\cite{Gallaire1984}; we do not consider the case of indefinite databases in this work.\n\nWe can view deductive databases as MCSs.\n\n\\begin{definition}\n  Let $\\langle DB,R\\rangle$ be a deductive database over $\\Sigma_E$\n  and $\\Sigma_I$.\n  The MCS induced by $\\langle DB,R\\rangle$ is\n  $M=\\langle C_E,C_I\\rangle$, where $C_E={\\ensuremath{\\mathsf{Ctx}}}(DB)$ defined as\n  above and $C_I={\\ensuremath{\\mathsf{Ctx}}}(R)$ is a similar context where:\n  \\begin{itemize}\n  \\item The knowledge base is $\\emptyset$.\n  \\item For each rule $p\\leftarrow q_1,\\ldots,q_n$ in $R$ there is a\n    bridge rule $(I:p)\\leftarrow (i_1:q_1),\\ldots,(i_n:q_n)$ in ${\\ensuremath{\\mathsf{Ctx}}}(R)$,\n    where $i_k=E$ if $q_k$ is an atom over $\\Sigma_E$ and $i_k=I$ otherwise.\n  \\end{itemize}\n\\end{definition}\n\nIntegrity constraints over such MCSs correspond precisely to the definition of integrity\nconstraints over deductive databases from~\\cite{Asirelli1985}.\nBy combining this with the adequate notion of repair, we capture the typical constraints\nof deductive databases -- that consistency can only be regained by changing extensional\npredicates -- in line with the traditional view-update problem.\nMore modern works~\\cite{Caroprese2012} restrict the syntax of integrity constraints,\nallowing them to use only extensional relations; in the induced MCS, this translates to\nthe additional requirement that only relational elements from $C_E$ appear in the body\nof integrity constraints.\n\n\\begin{example}\nConsider a deductive database for class diagrams, where information about direct\nsubclasses is stored in the extensional database using a relation ${\\sf isa}$,\ne.g.~${\\sf isa}({\\it list},{\\it collection})$ and ${\\sf isa}({\\it array},{\\it list})$.\nIntensionally, we model the transitive closure of the subclass relation using a view\ncreated by the two rules ${\\sf sub}(A,B) \\leftarrow {\\sf isa}(A,B)$ and\n${\\sf sub}(A,C) \\leftarrow {\\sf isa}(A,B), {\\sf sub}(B,C)$, thus allowing us to find out\nthat in our example ${\\sf sub}({\\it array},{\\it collection})$.\nThe integrity constraint\n", "itemtype": "equation", "pos": 34112, "prevtext": "\nensure that all voters registered in the Silkeborg electoral district are registered in\nthe central person register, and that they are registered with an address that is local to\nthe Silkeborg electoral district.\nHere, we are implicitly assuming that the database is closed under projection, and\noverload the {\\sf person} relation for the sake of simplicity.\nIn addition, the following set of integrity constaints models the fact that each person\nregistered in the Silkeborg electoral district is not registered in any other electoral\ndistricts from the set ${\\it ED}$.\n", "index": 17, "text": "\n\\[\\{\\leftarrow {\\sf Skborg}: {\\sf voter}({\\it Id}), C_i : {\\sf voter}({\\it Id}) \\mid C_i \\in{\\it ED} \\setminus \\{ {\\sf Skborg} \\} \\}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\{\\leftarrow{\\sf Skborg}:{\\sf voter}({\\it Id}),C_{i}:{\\sf voter}({\\it Id})\\mid&#10;C%&#10;_{i}\\in{\\it ED}\\setminus\\{{\\sf Skborg}\\}\\}\" display=\"block\"><mrow><mo stretchy=\"false\">{</mo><mo>\u2190</mo><mi>\ud835\uddb2\ud835\uddc4\ud835\uddbb\ud835\uddc8\ud835\uddcb\ud835\uddc0</mi><mo>:</mo><mi>\ud835\uddcf\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddcb</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><msub><mi>C</mi><mi>i</mi></msub><mo>:</mo><mi>\ud835\uddcf\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddcb</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc3c\ud835\udc51</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2223</mo><msub><mi>C</mi><mi>i</mi></msub><mo>\u2208</mo><mi>\ud835\udc38\ud835\udc37</mi><mo>\u2216</mo><mrow><mo stretchy=\"false\">{</mo><mi>\ud835\uddb2\ud835\uddc4\ud835\uddbb\ud835\uddc8\ud835\uddcb\ud835\uddc0</mi><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"false\">}</mo></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\ncan then be used to state the acyclicity of the subclass relation.\nIntegrity constraints restricted to the extensional database could not express\nthis, as there would be no way to define a fixpoint.\nThe only (incomplete) solution would be to add $n$ integrity constraints\ndisallowing cycles of length up to $n$.\nThis example illustrates our gain of expressive power compared to the approach\nin~\\cite{Caroprese2012}.\n\\end{example}\n\nWe can also consider databases with several, different views, each view generating a\ndifferent context.\nIntegrity constraints over the resulting MCS can then specify relationships between\nrelations in different views.\n\nYet again, the complexity of verifying whether an MCS induced by a deductive database\nsatisfies its integrity constraints is lower than the general case.\nIn particular, consistency checking is reducible to query answering (all integrity\nconstraints are satisfied iff there are no answers to the queries expressed in their\nbodies).\nIf we do not allow negation in the definition of the intensional relations, then there is\nonly one model of the database as before, and consistency checking w.r.t.\\ a fixed set of integrity constraints\nis PTIME-complete \\cite{Schlipf1995}.\nIn the general case, weak and strong consistency correspond, respectively, to brave and\ncautious reasoning for Datalog programs under answer set semantics, which are known to\nbe co-NP-complete and NP-complete, respectively.\n\n\\subsection{Peer-to-peer systems}\n\\label{sec:p2p}\n\nPeer-to-peer (P2P) networks are distributed systems where each node (the peer) has an identical status in the hierarchy, i.e., there is no\ncentralized control. Queries can be posed to each peer, and peers communicate amongst themselves in order to produce the desired answer. For a general overview see e.g.~\\cite{Pourebrahimi05asurvey}.\n\nA particularly interesting application are P2P systems, which integrate features of both\ndistributed and deductive databases.\nWe follow~\\cite{Caroprese2007}, which also addresses the issue of integrity constraints.\nIn this framework, P2P systems consist of several nodes (the peers), each of them a\ndeductive database of its own, connected via \\emph{mapping rules} that port\nrelations from one peer to another.\n\n\\begin{definition}\n  A peer-to-peer system $\\mathcal P$ is a set of peers\n  $\\mathcal P=\\{P_i\\}_{i=1}^n$.\n  Each peer is a tuple $\\langle \\Sigma^i,DB_i,R_i,M_i,IC_i\\rangle$, where:\n  \\begin{itemize}\n  \\item $\\Sigma^i$ is the disjoint union of three signatures\n    $\\Sigma^i_E$, $\\Sigma^i_I$ and $\\Sigma^i_M$;\n  \\item $\\langle DB_i,R_i\\rangle$ is a deductive database over signatures\n    $\\Sigma^i_E$ and $\\Sigma^i_I$, where the rules in $R_i$ may also\n    use relations from $\\Sigma^i_M$;\n  \\item $M_i$ is a set of mapping rules of the form\n    $p\\leftarrow_j q_1,\\ldots,q_m$ with $j\\neq i$, where $p$\n    is an atom over a signature $\\Sigma^i_M$ and each $q_k$ is an atom\n    over $\\Sigma^j$;\n  \\item $IC_i$ is a set of integrity constraints over $\\Sigma^i$.\n  \\end{itemize}\n\\end{definition}\nIntuitively, relations can be defined either extensionally (those in\n$\\Sigma_E$), intensionally (those in $\\Sigma_I$) or as mappings from\nanother peer (those in $\\Sigma_M$), and these definitions may not be\nmixed.\nObserve that, with these definitions, negations may only occur in the bodies of the\nintegrity constraints.\n\nWe can view a P2P system as a MCS with integrity constraints.\nTo simplify the construction, we adapt the definition from the case of deductive databases\nslightly, so that there is a one-to-one correspondence between peers and contexts.\n\n\\begin{definition}\n  Let $\\mathcal P=\\{P_i\\}_{i=1}^n$ be a P2P system.\n  The MCS induced by $\\mathcal P$ is defined as follows.\n  \\begin{itemize}\n  \\item There are $n$ contexts, where $C_i$ is constructed as\n    ${\\ensuremath{\\mathsf{Ctx}}}(DB_i)$ together with the following set of bridge rules:\n    \\begin{itemize}\n    \\item $(i:p)\\leftarrow(i:q_1),\\ldots,(i:q_m)$ for each rule\n      $p\\leftarrow q_1,\\ldots,q_m\\in R_i$;\n    \\item $(i:p)\\leftarrow(j:q_1),\\ldots,(j:q_m)$ for each rule\n      $p\\leftarrow_j q_1,\\ldots,q_m\\in M_i$.\n    \\end{itemize}\n  \\item Each integrity constraint $\\leftarrow q_1,\\ldots,q_m$ in\n    $IC_i$ is translated to the integrity constraint\n    $\\leftarrow(i:q_1),\\ldots,(i:q_m)$, where we take $(i:\\neg q)$ to\n    mean ${\\mathsf{not}\\ }(i:q)$.\n  \\end{itemize}\n\\end{definition}\nThe definition of the bridge rules from $R_i$ is identical to what one would\nobtain by constructing the context ${\\ensuremath{\\mathsf{Ctx}}}(R_i)$ described in the\nprevious section.\n\nThis interpretation does not preserve the semantics for\nP2P systems given in~\\cite{Caroprese2007,Caroprese2014}.\nTherein, mapping rules can only be applied if\nthey do not generate violations of the integrity constraints.\nThis is directly related to the real-life implementation of these systems, where this\noption represents a ``cheap'' strategy to ensure local enforcement of integrity\nconstraints; as discussed in~\\cite{Weinzierl2011}, the underlying philosophy of P2P\nsystems and MCSs is significantly different.\n\nWe now show that, while the semantics differ, there is a correspondence between\nP2P systems and their representation as an MCS, and the ``ideal'' models of both coincide.\nWhen no such models exist, the MCS formulation can be helpful in identifying the\nproblematic mapping rules.\n\nThe semantics of P2P systems implicitly sees them as logic programs.\n\\begin{definition}\n  Let $\\mathcal P=\\{P_i\\}_{i=1}^n$ be a P2P system and $I$ be a Herbrand interpretation\n  over $\\bigcup\\Sigma^i$.\n  The program $\\mathcal P^I$ is obtained from $\\mathcal P$ by (i)~grounding all rules and\n  (ii)~removing the mapping rules whose head is not in $I$.\n\n  Let $\\mathcal{MM}(P)$ denote the minimal model of a logic program.\n  A \\emph{weak model} for $\\mathcal P$ is an interpretation $I$ such that\n  $I=\\mathcal{MM}(\\mathcal P^I)$.\n\\end{definition}\nSince integrity constraints are rules with empty head, this definition implicitly requires\nweak models to satisfy them.\n\nInterpretations over a P2P system and equilibria over the induced MCS are trivially in\nbijection, as the latter simply assign each atom to the right context, and we implicitly\nidentify them hereafter.\nWe can relate the ``perfect'' models in both systems.\n\n\\begin{theorem}\n  Let $\\mathcal P$ be a P2P system, $I$ an interpretation for $\\mathcal P$, and\n  $M$ the induced MCS.\n  Then $I=\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$ iff $I$ is an equilibrium\n  for $M$ satisfying all the integrity constraints.\n\\end{theorem}\n\\begin{proof}\n  Since $\\mathcal P$ corresponds to a positive program, the only equilibrium of $M$ is\n  $\\mathcal{MM}(\\mathcal P)$ (see~\\cite{CHN2013b}).\n  Furthermore, for any $I$, $\\mathcal{MM}(\\mathcal P^I)$ includes the facts in all\n  extensional databases and satisfies all rules in $R_i$ and all integrity constraints.\n  Thus, it also corresponds to a belief state satisfying their counterparts in $M$.\n\n  Suppose that $\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$.\n  Since mapping rules are the only ones that can add information about relations in\n  $\\Sigma^i_M$ to $I$, the second equality implies that no mapping rules are removed in\n  $\\mathcal P^I$.\n  Therefore $I=\\mathcal{MM}(\\mathcal P)$ satisfies all bridge rules of $M$ obtained from\n  the mapping rules in $\\mathcal P$, whence $I$ is an equilibrium of $M$ satisfying all\n  integrity constraints.\n\n  Conversely, if $I$ is an equilibrium of $M$ and $r$ is a mapping rule, then either $I$\n  does not satisfy the body of $r$ or $I$ contains its head.\n  Since no other rules can infer instances of relations in $\\Sigma^i_M$, this implies that\n  $\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$, and being an equilibrium implies\n  that $I=\\mathcal{MM}(\\mathcal P)$.\n\\qed\n\\end{proof}\n\nThe MCS representation has an interesting connection with the notion of weak model in\ngeneral, though: if there are integrity constraints in $M$ that are not satisfied by\n$\\mathcal{MM}(\\mathcal P)$, then repairing $M$ by removing mapping rules is equivalent to\nfinding a weak model for $\\mathcal P$.\nThis is again reminescent of the view-update problem.\n\nThe MCS representation allows us to write seemingly more powerful integrity constraints\nover a P2P system, as we can use literals from different contexts in the same rule.\nHowever, this does not give us more expressive power: for example, the integrity constraint\n$\\leftarrow(1:a),(2:b)$\ncan be written as\n$\\leftarrow(1:a),(1:b_2)$\nadding the mapping rule $(1:b_2)\\leftarrow(2:b)$, where $b_2$ is a fresh relation in peer\n$1$.\n\n\n\n\n\n\n\\subsection{Description Logic Knowledge Bases}\n\nWe now discuss the connection between our work and results on adding\nintegrity constraints to description logic knowledge bases, namely OWL ontologies.\n\nDescription logics differ from databases in their rejection of the closed-world\nassumption, thereby contradicting the semantics of negation-by-failure.\nFor this reason, encoding ontologies as a context in an MCS is a bit different than the\nprevious examples.\nWe follow the approach from~\\cite{CGN2014}, refering the reader to the discussion therein\nof why the embeddding from e.g.~\\cite{Brewka2007b} is not satisfactory.\n\n\\begin{definition}\n  A description logic $\\mathcal L$ is represented as the relational logic\n  $L_{\\mathcal L}=\\langle{\\mathsf{KB}}_{\\mathcal L},{\\mathsf{BS}}_{\\mathcal L},{\\mathsf{ACC}}_{\\mathcal L},\\Sigma_{\\mathcal L}\\rangle$\n  defined as follows:\n  \\begin{itemize}\n  \\item ${\\mathsf{KB}}_{\\mathcal L}$ contains all well-formed knowledge bases\n    (including a T-Box and an A-Box) of~$\\mathcal L$;\n  \\item ${\\mathsf{BS}}_{\\mathcal L}$ is the set of all possible A-Boxes in the language of $\\mathcal L$;\n  \\item ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ is the singleton set containing the set of ${\\mathsf{kb}}$'s known\n    consequences (positive and negative);\n  \\item $\\Sigma_{\\mathcal L}$ is the signature underlying~$\\mathcal L$.\n  \\end{itemize}\n\\end{definition}\nRegarding the choice of acceptable belief sets (the elements of\n${\\mathsf{BS}}_{\\mathcal L}$), the possible A-Boxes\ncorrespond to (partial) models of $\\mathcal L$,\nseen as a first-order theory: they contain concepts and roles applied\nto particular known individuals, or negations thereof.\nHowever, they need not be categorical:\nthey may contain neither $C(a)$ nor $\\neg C(a)$ for particular $C$ and $a$.\nThis reflects the typical open-world semantics of ontologies.\nIn particular, the only element of ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ may not be a model of\n${\\mathsf{kb}}$ in the classical sense of first-order logic.\nThis is in contrast with~\\cite{Brewka2007b}, where ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ contains all\nmodels of ${\\mathsf{kb}}$; as discussed in~\\cite{CGN2014}, this is essential to model e.g.~default\nreasoning correctly.\n\n\\begin{definition}\n  An ontology $\\mathcal O$ based on description logic $\\mathcal L$ induces a context with\n  underlying logic $L_{\\mathcal L}$, knowledge base $\\mathcal O$, and an empty set of\n  bridge rules.\n\\end{definition}\n\nLike in the database scenario, ontologies viewed as MCSs always have one equilibrium, as\nlong as they are logically consistent.\nTherefore, the notions of weak and strong satisfaction of integrity constraints again\ncoincide, and we get the same notion of consistency w.r.t.~a set of integrity constraints\nas that defined in~\\cite{Motik2009}; however, our syntax is more restricted, as we do not\nallow general formulas as integrity constraints.\nObserve that, as in that work, our integrity constraints only apply to named individuals\n(explicitly mentioned in the ontology's A-Box), which is a desirable consequence that yet\nagain can only be gained from keeping integrity constraints separate from the knowledge\nbase.\n\n\\begin{example}\n  We illustrate the construction in this section with a classical\n  example.\n  We assume that we have an ontology $O$ including a concept\n  $\\mathsf{person}$ and a role $\\mathsf{hasCPR}$, which associates\n  individuals with their CPR number.\n  (So we are essentially resetting Example~\\ref{ex:cpr} to use an\n  ontology, rather than a distributed database.)\n  We can add the integrity constraint\n \n", "itemtype": "equation", "pos": 38436, "prevtext": "\n\\end{example}\n\n\nThis assumption of closure under projection is meaningful from a\npractical point of view, and has been implemented e.g.\\ in~\\cite{KMIS2015}.\nAlternatively, we could define the projections as bridge rules of the MCSs, in line with\nthe idea of encoding views of deductive databases presented in the next section.\n\nThis section's treatment of distributed databases is equivalent to considering their\ndisjoint union as a database.\nConsequently, there is no need to use MCSs for distributed databases, but this mapping\nshows that our notion of integrity constraints abstracts the practice in this field.\nFurthermore, results in previous work~\\cite{LCF2014} indicate that the processing of\nintegrity constraints can be efficiently parallelized in this disjoint scenario, given\nsuitable assumptions.\n\n\\subsection{Deductive DBs}\n\nWe now address the case of deductive databases.\nThese consist of two different components: the (extensional) fact\ndatabase, containing only concrete instances of relations, and the\n(intensional) rule database, containing Datalog-style rules defining\nnew relations.\nEvery relation must be either intensional or extensional, unlike in\ne.g.~full-fledged logic programming.\n\nOne standard way to see the intensional component(s) of deductive\ndatabases is as \\emph{views} of the original database.\nThe instances of the new relations defined by rules are generated\nautomatically from the data in the database, and these\nrelations can thus be seen as content-free, having a purely\npresentational nature.\nFor simplicity of presentation, we consider the case where there\nis one single view.\n\n\\begin{definition}\n  Let $\\Sigma_E$ and $\\Sigma_I$ be two disjoint first-order signatures.\n  A \\emph{deductive database} over $\\Sigma_E$ and $\\Sigma_I$ is a pair\n  $\\langle DB,R\\rangle$, where $DB$ is a relational database over\n  $\\Sigma_E$ and $R$ is a set of rules of the form\n  $p\\leftarrow q_1,\\ldots,q_n$,\n  where $p$ is an atom of $\\Sigma_I$ and $q_1,\\ldots,q_n$ are atoms\n  over $\\Sigma_E\\cup\\Sigma_I$.\n\\end{definition}\nMore precisely, this definition corresponds to the definite deductive databases\nin~\\cite{Gallaire1984}; we do not consider the case of indefinite databases in this work.\n\nWe can view deductive databases as MCSs.\n\n\\begin{definition}\n  Let $\\langle DB,R\\rangle$ be a deductive database over $\\Sigma_E$\n  and $\\Sigma_I$.\n  The MCS induced by $\\langle DB,R\\rangle$ is\n  $M=\\langle C_E,C_I\\rangle$, where $C_E={\\ensuremath{\\mathsf{Ctx}}}(DB)$ defined as\n  above and $C_I={\\ensuremath{\\mathsf{Ctx}}}(R)$ is a similar context where:\n  \\begin{itemize}\n  \\item The knowledge base is $\\emptyset$.\n  \\item For each rule $p\\leftarrow q_1,\\ldots,q_n$ in $R$ there is a\n    bridge rule $(I:p)\\leftarrow (i_1:q_1),\\ldots,(i_n:q_n)$ in ${\\ensuremath{\\mathsf{Ctx}}}(R)$,\n    where $i_k=E$ if $q_k$ is an atom over $\\Sigma_E$ and $i_k=I$ otherwise.\n  \\end{itemize}\n\\end{definition}\n\nIntegrity constraints over such MCSs correspond precisely to the definition of integrity\nconstraints over deductive databases from~\\cite{Asirelli1985}.\nBy combining this with the adequate notion of repair, we capture the typical constraints\nof deductive databases -- that consistency can only be regained by changing extensional\npredicates -- in line with the traditional view-update problem.\nMore modern works~\\cite{Caroprese2012} restrict the syntax of integrity constraints,\nallowing them to use only extensional relations; in the induced MCS, this translates to\nthe additional requirement that only relational elements from $C_E$ appear in the body\nof integrity constraints.\n\n\\begin{example}\nConsider a deductive database for class diagrams, where information about direct\nsubclasses is stored in the extensional database using a relation ${\\sf isa}$,\ne.g.~${\\sf isa}({\\it list},{\\it collection})$ and ${\\sf isa}({\\it array},{\\it list})$.\nIntensionally, we model the transitive closure of the subclass relation using a view\ncreated by the two rules ${\\sf sub}(A,B) \\leftarrow {\\sf isa}(A,B)$ and\n${\\sf sub}(A,C) \\leftarrow {\\sf isa}(A,B), {\\sf sub}(B,C)$, thus allowing us to find out\nthat in our example ${\\sf sub}({\\it array},{\\it collection})$.\nThe integrity constraint\n", "index": 19, "text": "\n\\[\\leftarrow{\\sf sub}(A,A)\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\leftarrow{\\sf sub}(A,A)\" display=\"block\"><mrow><mi/><mo>\u2190</mo><mrow><mi>\ud835\uddcc\ud835\uddce\ud835\uddbb</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo>,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04980.tex", "nexttext": "\n  requiring each person to have a CPR number.\n  Due to the semantics of ontologies, this actually requires each\n  person's CPR number to be explicitly present in the ontology: the\n  presence of an axiom such as\n  $\\mathsf{person}\\sqsubseteq(\\exists\\mathsf{person.hasCPR})$ does not\n  yield any instance $\\mathsf{hasCPR}(x,y)$ in the set of the\n  ontology's known consequences.\n  This also justifies our definition of ${\\mathsf{ACC}}_{\\mathcal L}$: if we\n  take the model-based approach of~\\cite{Brewka2007b}, then this\n  integrity constraint no longer demands the actual presence of such a\n  fact in the A-Box.\n\n  This integrity constraint is an example of one that does not satisfy\n  the safety condition (the variable $y$ occurs only in a negated\n  literal), but as discussed in Section~\\ref{sec:ic} our theory is\n  easily extended to cover this case, as $y$ only occurs once in the formula.\n\\end{example}\n\nOur scenario is also expressive enough to model the distributed ontology scenario\nof~\\cite{Fang2011}, which defines integrity constraints as logic\nprogramming-style rules with empty head whose body can include atoms from different\nontologies: we can simply consider the MCS obtained from viewing each ontology as a\nseparate context, and the integrity constraints as ranging over the\njoint system.\n\n\n\\section{Repairs and managed multi-context systems}\n\\label{sec:repair}\n\nThe definitions in the previous section allow us to distinguish between acceptable and\nnon-acceptable equilibria w.r.t.\\ a set of integrity constraints, but they do not help\nwith the analog of the problem of database repair~\\cite{Abiteboul1988} -- namely, given an\ninconsistent equilibrium for a given MCS, how do we change it into a consistent one.\nIn order to address this issue, we turn our attention to\n\\emph{managed} multi-context systems (mMCS)~\\cite{Brewka2011}.\n\n\\begin{definition}\n  A \\emph{managed multi-context system} is a collection of managed contexts\n  $\\{C_i\\}_{i\\in\\mathcal J}$, with each\n  $C_i=\\langle L_i,{\\mathsf{kb}}_i,{\\mathsf{br}}_i,D_i,OP_i,{\\mathsf{mng}}_i\\rangle$ as follows.\n  \\begin{itemize}\n  \\item $L_i$ is a relational logic, ${\\mathsf{kb}}_i$ is a knowledge base, and\n    $D_i$ is a set of import domains, as in standard MCSs.\n  \\item $OP_i$ is a set of operation names.\n  \\item ${\\mathsf{br}}_i$ is a set of managed bridge rules, with the form of\n    Equation~\\eqref{eq:bridge}, but where $s$ is of the form $o(p)$\n    with $o\\in OP_i$ and $p\\in\\bigcup{\\mathsf{KB}}_i$.\n  \\item ${\\mathsf{mng}}_i:\\wp(OP_i\\times\\bigcup{\\mathsf{KB}}_i)\\times{\\mathsf{KB}}_i\\to{\\mathsf{KB}}_i$ is a\n    \\emph{management function}.\n  \\end{itemize}\n\\end{definition}\n\nThe intuition is as follows: the heads of bridge rules can now contain\narbitrary actions (identified by the labels in $OP_i$, and the\nmanagement function specifies the semantics of these labels --\nsee~\\cite{Brewka2011} for a more detailed discussion.\nOur definition is simplified from those authors', as they allow the\nmanagement function to change the semantics of the contexts and return\nseveral possible effects for each action.\nThis simplification results in a less flexible concept of mMCS, which is however more useful for the\npurposes of defining repairs.\n\n\\begin{example}\n  The management function can perform several\n  manipulations of the knowledge base in one update action.\n  For example, considering the setting of Example~\\ref{ex:cpr}, we could include\n  an operation ${\\sf replace}\\in OP_{\\sf CPR}$ such that\n  ${\\mathsf{mng}}(\\{\\langle{\\sf replace},{\\sf person}({\\it Id},{\\it Name},{\\it Add})\\rangle\\},{\\mathsf{kb}})$\n  inserts the tuple $({\\it Id},{\\it Name},{\\it Add})$ into the ${\\sf person}$ table and\n  removes any other tuple $({\\it Id},{\\it Name}',{\\it Add}')$ from that table.\n\\end{example}\n\nEvery MCS (in the sense of the previous section) can be seen as an\nmMCS by taking every context to have exactly one operation\n${\\sf add}$ with the natural semantics of adding its argument (the\nhead of the rule) to the belief set associated with the context in\nquestion.\nWe will therefore discuss integrity constraints over mMCS in the\nremainder of this section.\nThe motivation of generalizing database tradition also suggests that\nwe include another operation ${\\sf remove}$ that removes an element\nfrom the specified context.\n\n\\begin{definition}\n  Let $M=\\{C_i\\}_{i\\in\\mathcal I}$ be an mMCS.\n  An \\emph{update action} for $M$ is of the form\n  $(i:o(p))$, with $i\\in\\mathcal J$, $o\\in OP_i$ and $p\\in\\bigcup{\\mathsf{KB}}_i$.\n\n  Given a set of update actions ${\\mathcal U}$ and an mMCS $M$, the\n  result of applying ${\\mathcal U}$ to $M$, denoted ${\\mathcal U}(M)$,\n  is computed by replacing each ${\\mathsf{kb}}_i$ (in context $C_i$) by\n  ${\\mathsf{mng}}_i({\\mathcal U}_i,{\\mathsf{kb}}_i)$, where ${\\mathcal U}_i$ is the set of update actions of\n  the form $(i:o(p))$.\n\\end{definition}\n\nUpdates differ from applying (managed) bridge rules, as they actually change one or more\nknowledge bases in $M$'s contexts \\emph{before} any evaluation of bridge rules\ntakes place.\nThis is similar to database updates, which change the database before and independent of\nthe query processing.\nBased on this notion of update, we can define (weak) repairs as follows.\n\n\\begin{definition}\n  Let $M$ be an mMCS, $\\eta$ be a set of ICs over $M$, and assume that $M$ is inconsistent\n  w.r.t.~$\\eta$.\n  A set of update actions ${\\mathcal U}$ is a \\emph{weak repair} for $M$ and $\\eta$ if ${\\mathcal U}(M)$ is\n  consistent w.r.t.~$\\eta$.\n  If there is no subset ${\\mathcal U}'$ of ${\\mathcal U}$ that is also a weak repair for $M$ and $\\eta$, then\n  ${\\mathcal U}$ is a \\emph{repair}.\n\\end{definition}\n\n\\begin{example}\n  Again in the setting of Example~\\ref{ex:cpr}, suppose that the CPR database contains the record\n  ${\\sf person}(1111111118,{\\it old\\_lady},{\\it odense})$ and the Silkeborg electoral\n  database contains the records ${\\sf voter}(1111111118)$ and\n  ${\\sf address}({\\it gjern})$, but not the record ${\\sf address}({\\it odense})$ as Odense\n  is not in Silkeborg.\n  The induced mMCS is inconsistent w.r.t.~the integrity constraint~\\eqref{ic1},\n  and a possible repair is\n  $\\{({\\sf CPR}:{\\sf add}({\\sf person}(1111111118,{\\it old\\_lady},{\\it gjern})))\\}$.\n  The semantics of the management function guarantee that only the new record will persist\n  in the mMCS.\n\\end{example}\n\nAs is the case in databases, it can happen that a set of integrity constraints is\ninconsistent, in the sense that no MCS can satisfy it.\nHowever, this inconsistency can also arise from incompatibility between integrity\nconstraints and bridge rules -- consider the very simple case where there is a bridge rule\n$(B:{\\sf b}) \\leftarrow (A:{\\sf a})$ and an integrity constraint\n$\\leftarrow(A:{\\sf a}),{\\mathsf{not}\\ }(B:{\\sf b})$).\nSince our notion of update does not allow one to change bridge rules, this inconsistency\nis unsurmountable.\n\nIn general, this interaction between integrity constraints and bridge rules makes the\nproblem of finding repairs for inconsistent MCSs more complex than in the database world.\nHowever, Theorems~\\ref{thm:wdec} and~\\ref{thm:sdec} show that the problem of finding a\nrepair for an MCS that is inconsistent w.r.t.~a set of integrity constraints can be\nreduced to finding a set of update actions that will make a logically inconsistent MCS\nhave equilibria.\nThe results on diagnosing and repairing logical inconsistency in multi-context\nsystems~\\cite{Eiter2011,Eiter2014} can therefore be used to tackle this problem.\n\nBy considering deductive databases as MCSs, we also see the problem of repairing an\ninconsistent MCS as a generalization of the view-update\nproblem~\\cite{Kakas1990,Mayol2003,Teniente1995}.\n\nAnother issue is how to choose between different repairs: as in the database case, some\nrepairs are preferable to others.\nConsider the following toy example.\n\\begin{example}\n  Let $M$ be the MCS induced by a deductive database with one extensional relation $\\sf p$\n  and one intensional relation $\\sf q$, both $0$-ary, connected by the rule\n  $\\sf q\\leftarrow\\sf p$, and consider the integrity constraint $(I:\\sf q)$.\n\n  Assume the usual operations ${\\sf add}$ and ${\\sf remove}$.\n  There are two repairs for $M$, namely $\\{(E:\\sf add(\\sf p))\\}$ and\n  $\\{(I:\\sf add(\\sf q))\\}$, but only the former is valid from the perspective of deductive\n  databases.\n\\end{example}\n\nThe usual consensus in databases is that, in general, deciding which repair to apply is a\ntask that needs human intervention~\\cite{Eiter1992}.\nHowever, several formalisms also include criteria to help automate such preferences.\nIn our setting, a simple way to restrict the set of possible repairs would be to restrict\nthe update actions to use only a subset of the $OP_i$s -- in the case of deductive databases,\nwe could simply restrict them to the operations over $C_E$.\nAn alternative that offers more fine-tuning capabilities would be to go in the direction\nof active integrity constraints~\\cite{Flesca2004}, which require the user to be explicit\nabout which update actions can be used to repair the integrity constraints that are not\nsatisfied.\nWe plan to pursue the study of such formalisms to discuss repairs of MCSs with integrity\nconstraints in future work.\nWe also intend to study generalizations of repairs to include the possibility of changing\nbridge rules.\n\n\\section{Conclusions and Future Work}\n\\label{sec:conclusion}\n\nIn this paper, we proposed a notion of integrity constraint for multi-context systems, a\ngeneral framework for combining reasoning systems.\nWe showed that our notion generalizes the well-studied concept of integrity constraint\nover databases, and studied its relation to similar notions in other formalisms.\nSatisfaction of integrity constraints comes in two variants, weak and strong, related to\nthe usual concepts of brave and cautious reasoning.\n\nBy showing how to encode integrity constraints within the syntax of MCSs,\nwe obtained decidability and complexity results for the problem of whether a particular\nMCS weakly or strongly satisfies a set of integrity constraints, and of repairing it in\nthe negative case.\nWe argued however that by keeping integrity constraints as an added layer on top of an MCS we\nare able to separate intrinsic logical inconsistency from inconsistencies that may arise\ne.g.~from improper changes to an individual context, which we want to detect and fix,\nrather than propagate to other contexts.\nOur examples show that we indeed capture the usual behaviour of integrity constraints in\nseveral existing formalisms.\n\nWe also defined a notion of repair, consistent with the tradition in databases, and identified\nnew research problems related to which repairs should be preferred that arise in the MCS\nscenario.\nWe intend to pursue this study further by developing a theory of active integrity\nconstraints, in the style of~\\cite{Flesca2004}.\n\n\\paragraph{Acknowledgements.}\nWe would like to thank Gra\\c ca Gaspar for introducing us to\nthe exciting topic of integrity constraints and for many fruitful\ndiscussions.\nWe also thank the anonymous referees for many valuable suggestions\nthat improved the overall quality of this paper.\nThis work was supported by the Danish Council for Independent\nResearch, Natural Sciences, and by FCT/MCTES/PIDDAC under centre grant\nto BioISI (Centre Reference: UID/MULTI/04046/2013).\n\n\\bibliographystyle{plain}\n\\bibliography{bibl}\n\n\n", "itemtype": "equation", "pos": 50709, "prevtext": "\ncan then be used to state the acyclicity of the subclass relation.\nIntegrity constraints restricted to the extensional database could not express\nthis, as there would be no way to define a fixpoint.\nThe only (incomplete) solution would be to add $n$ integrity constraints\ndisallowing cycles of length up to $n$.\nThis example illustrates our gain of expressive power compared to the approach\nin~\\cite{Caroprese2012}.\n\\end{example}\n\nWe can also consider databases with several, different views, each view generating a\ndifferent context.\nIntegrity constraints over the resulting MCS can then specify relationships between\nrelations in different views.\n\nYet again, the complexity of verifying whether an MCS induced by a deductive database\nsatisfies its integrity constraints is lower than the general case.\nIn particular, consistency checking is reducible to query answering (all integrity\nconstraints are satisfied iff there are no answers to the queries expressed in their\nbodies).\nIf we do not allow negation in the definition of the intensional relations, then there is\nonly one model of the database as before, and consistency checking w.r.t.\\ a fixed set of integrity constraints\nis PTIME-complete \\cite{Schlipf1995}.\nIn the general case, weak and strong consistency correspond, respectively, to brave and\ncautious reasoning for Datalog programs under answer set semantics, which are known to\nbe co-NP-complete and NP-complete, respectively.\n\n\\subsection{Peer-to-peer systems}\n\\label{sec:p2p}\n\nPeer-to-peer (P2P) networks are distributed systems where each node (the peer) has an identical status in the hierarchy, i.e., there is no\ncentralized control. Queries can be posed to each peer, and peers communicate amongst themselves in order to produce the desired answer. For a general overview see e.g.~\\cite{Pourebrahimi05asurvey}.\n\nA particularly interesting application are P2P systems, which integrate features of both\ndistributed and deductive databases.\nWe follow~\\cite{Caroprese2007}, which also addresses the issue of integrity constraints.\nIn this framework, P2P systems consist of several nodes (the peers), each of them a\ndeductive database of its own, connected via \\emph{mapping rules} that port\nrelations from one peer to another.\n\n\\begin{definition}\n  A peer-to-peer system $\\mathcal P$ is a set of peers\n  $\\mathcal P=\\{P_i\\}_{i=1}^n$.\n  Each peer is a tuple $\\langle \\Sigma^i,DB_i,R_i,M_i,IC_i\\rangle$, where:\n  \\begin{itemize}\n  \\item $\\Sigma^i$ is the disjoint union of three signatures\n    $\\Sigma^i_E$, $\\Sigma^i_I$ and $\\Sigma^i_M$;\n  \\item $\\langle DB_i,R_i\\rangle$ is a deductive database over signatures\n    $\\Sigma^i_E$ and $\\Sigma^i_I$, where the rules in $R_i$ may also\n    use relations from $\\Sigma^i_M$;\n  \\item $M_i$ is a set of mapping rules of the form\n    $p\\leftarrow_j q_1,\\ldots,q_m$ with $j\\neq i$, where $p$\n    is an atom over a signature $\\Sigma^i_M$ and each $q_k$ is an atom\n    over $\\Sigma^j$;\n  \\item $IC_i$ is a set of integrity constraints over $\\Sigma^i$.\n  \\end{itemize}\n\\end{definition}\nIntuitively, relations can be defined either extensionally (those in\n$\\Sigma_E$), intensionally (those in $\\Sigma_I$) or as mappings from\nanother peer (those in $\\Sigma_M$), and these definitions may not be\nmixed.\nObserve that, with these definitions, negations may only occur in the bodies of the\nintegrity constraints.\n\nWe can view a P2P system as a MCS with integrity constraints.\nTo simplify the construction, we adapt the definition from the case of deductive databases\nslightly, so that there is a one-to-one correspondence between peers and contexts.\n\n\\begin{definition}\n  Let $\\mathcal P=\\{P_i\\}_{i=1}^n$ be a P2P system.\n  The MCS induced by $\\mathcal P$ is defined as follows.\n  \\begin{itemize}\n  \\item There are $n$ contexts, where $C_i$ is constructed as\n    ${\\ensuremath{\\mathsf{Ctx}}}(DB_i)$ together with the following set of bridge rules:\n    \\begin{itemize}\n    \\item $(i:p)\\leftarrow(i:q_1),\\ldots,(i:q_m)$ for each rule\n      $p\\leftarrow q_1,\\ldots,q_m\\in R_i$;\n    \\item $(i:p)\\leftarrow(j:q_1),\\ldots,(j:q_m)$ for each rule\n      $p\\leftarrow_j q_1,\\ldots,q_m\\in M_i$.\n    \\end{itemize}\n  \\item Each integrity constraint $\\leftarrow q_1,\\ldots,q_m$ in\n    $IC_i$ is translated to the integrity constraint\n    $\\leftarrow(i:q_1),\\ldots,(i:q_m)$, where we take $(i:\\neg q)$ to\n    mean ${\\mathsf{not}\\ }(i:q)$.\n  \\end{itemize}\n\\end{definition}\nThe definition of the bridge rules from $R_i$ is identical to what one would\nobtain by constructing the context ${\\ensuremath{\\mathsf{Ctx}}}(R_i)$ described in the\nprevious section.\n\nThis interpretation does not preserve the semantics for\nP2P systems given in~\\cite{Caroprese2007,Caroprese2014}.\nTherein, mapping rules can only be applied if\nthey do not generate violations of the integrity constraints.\nThis is directly related to the real-life implementation of these systems, where this\noption represents a ``cheap'' strategy to ensure local enforcement of integrity\nconstraints; as discussed in~\\cite{Weinzierl2011}, the underlying philosophy of P2P\nsystems and MCSs is significantly different.\n\nWe now show that, while the semantics differ, there is a correspondence between\nP2P systems and their representation as an MCS, and the ``ideal'' models of both coincide.\nWhen no such models exist, the MCS formulation can be helpful in identifying the\nproblematic mapping rules.\n\nThe semantics of P2P systems implicitly sees them as logic programs.\n\\begin{definition}\n  Let $\\mathcal P=\\{P_i\\}_{i=1}^n$ be a P2P system and $I$ be a Herbrand interpretation\n  over $\\bigcup\\Sigma^i$.\n  The program $\\mathcal P^I$ is obtained from $\\mathcal P$ by (i)~grounding all rules and\n  (ii)~removing the mapping rules whose head is not in $I$.\n\n  Let $\\mathcal{MM}(P)$ denote the minimal model of a logic program.\n  A \\emph{weak model} for $\\mathcal P$ is an interpretation $I$ such that\n  $I=\\mathcal{MM}(\\mathcal P^I)$.\n\\end{definition}\nSince integrity constraints are rules with empty head, this definition implicitly requires\nweak models to satisfy them.\n\nInterpretations over a P2P system and equilibria over the induced MCS are trivially in\nbijection, as the latter simply assign each atom to the right context, and we implicitly\nidentify them hereafter.\nWe can relate the ``perfect'' models in both systems.\n\n\\begin{theorem}\n  Let $\\mathcal P$ be a P2P system, $I$ an interpretation for $\\mathcal P$, and\n  $M$ the induced MCS.\n  Then $I=\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$ iff $I$ is an equilibrium\n  for $M$ satisfying all the integrity constraints.\n\\end{theorem}\n\\begin{proof}\n  Since $\\mathcal P$ corresponds to a positive program, the only equilibrium of $M$ is\n  $\\mathcal{MM}(\\mathcal P)$ (see~\\cite{CHN2013b}).\n  Furthermore, for any $I$, $\\mathcal{MM}(\\mathcal P^I)$ includes the facts in all\n  extensional databases and satisfies all rules in $R_i$ and all integrity constraints.\n  Thus, it also corresponds to a belief state satisfying their counterparts in $M$.\n\n  Suppose that $\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$.\n  Since mapping rules are the only ones that can add information about relations in\n  $\\Sigma^i_M$ to $I$, the second equality implies that no mapping rules are removed in\n  $\\mathcal P^I$.\n  Therefore $I=\\mathcal{MM}(\\mathcal P)$ satisfies all bridge rules of $M$ obtained from\n  the mapping rules in $\\mathcal P$, whence $I$ is an equilibrium of $M$ satisfying all\n  integrity constraints.\n\n  Conversely, if $I$ is an equilibrium of $M$ and $r$ is a mapping rule, then either $I$\n  does not satisfy the body of $r$ or $I$ contains its head.\n  Since no other rules can infer instances of relations in $\\Sigma^i_M$, this implies that\n  $\\mathcal{MM}(\\mathcal P)=\\mathcal{MM}(\\mathcal P^I)$, and being an equilibrium implies\n  that $I=\\mathcal{MM}(\\mathcal P)$.\n\\qed\n\\end{proof}\n\nThe MCS representation has an interesting connection with the notion of weak model in\ngeneral, though: if there are integrity constraints in $M$ that are not satisfied by\n$\\mathcal{MM}(\\mathcal P)$, then repairing $M$ by removing mapping rules is equivalent to\nfinding a weak model for $\\mathcal P$.\nThis is again reminescent of the view-update problem.\n\nThe MCS representation allows us to write seemingly more powerful integrity constraints\nover a P2P system, as we can use literals from different contexts in the same rule.\nHowever, this does not give us more expressive power: for example, the integrity constraint\n$\\leftarrow(1:a),(2:b)$\ncan be written as\n$\\leftarrow(1:a),(1:b_2)$\nadding the mapping rule $(1:b_2)\\leftarrow(2:b)$, where $b_2$ is a fresh relation in peer\n$1$.\n\n\n\n\n\n\n\\subsection{Description Logic Knowledge Bases}\n\nWe now discuss the connection between our work and results on adding\nintegrity constraints to description logic knowledge bases, namely OWL ontologies.\n\nDescription logics differ from databases in their rejection of the closed-world\nassumption, thereby contradicting the semantics of negation-by-failure.\nFor this reason, encoding ontologies as a context in an MCS is a bit different than the\nprevious examples.\nWe follow the approach from~\\cite{CGN2014}, refering the reader to the discussion therein\nof why the embeddding from e.g.~\\cite{Brewka2007b} is not satisfactory.\n\n\\begin{definition}\n  A description logic $\\mathcal L$ is represented as the relational logic\n  $L_{\\mathcal L}=\\langle{\\mathsf{KB}}_{\\mathcal L},{\\mathsf{BS}}_{\\mathcal L},{\\mathsf{ACC}}_{\\mathcal L},\\Sigma_{\\mathcal L}\\rangle$\n  defined as follows:\n  \\begin{itemize}\n  \\item ${\\mathsf{KB}}_{\\mathcal L}$ contains all well-formed knowledge bases\n    (including a T-Box and an A-Box) of~$\\mathcal L$;\n  \\item ${\\mathsf{BS}}_{\\mathcal L}$ is the set of all possible A-Boxes in the language of $\\mathcal L$;\n  \\item ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ is the singleton set containing the set of ${\\mathsf{kb}}$'s known\n    consequences (positive and negative);\n  \\item $\\Sigma_{\\mathcal L}$ is the signature underlying~$\\mathcal L$.\n  \\end{itemize}\n\\end{definition}\nRegarding the choice of acceptable belief sets (the elements of\n${\\mathsf{BS}}_{\\mathcal L}$), the possible A-Boxes\ncorrespond to (partial) models of $\\mathcal L$,\nseen as a first-order theory: they contain concepts and roles applied\nto particular known individuals, or negations thereof.\nHowever, they need not be categorical:\nthey may contain neither $C(a)$ nor $\\neg C(a)$ for particular $C$ and $a$.\nThis reflects the typical open-world semantics of ontologies.\nIn particular, the only element of ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ may not be a model of\n${\\mathsf{kb}}$ in the classical sense of first-order logic.\nThis is in contrast with~\\cite{Brewka2007b}, where ${\\mathsf{ACC}}_{\\mathcal L}({\\mathsf{kb}})$ contains all\nmodels of ${\\mathsf{kb}}$; as discussed in~\\cite{CGN2014}, this is essential to model e.g.~default\nreasoning correctly.\n\n\\begin{definition}\n  An ontology $\\mathcal O$ based on description logic $\\mathcal L$ induces a context with\n  underlying logic $L_{\\mathcal L}$, knowledge base $\\mathcal O$, and an empty set of\n  bridge rules.\n\\end{definition}\n\nLike in the database scenario, ontologies viewed as MCSs always have one equilibrium, as\nlong as they are logically consistent.\nTherefore, the notions of weak and strong satisfaction of integrity constraints again\ncoincide, and we get the same notion of consistency w.r.t.~a set of integrity constraints\nas that defined in~\\cite{Motik2009}; however, our syntax is more restricted, as we do not\nallow general formulas as integrity constraints.\nObserve that, as in that work, our integrity constraints only apply to named individuals\n(explicitly mentioned in the ontology's A-Box), which is a desirable consequence that yet\nagain can only be gained from keeping integrity constraints separate from the knowledge\nbase.\n\n\\begin{example}\n  We illustrate the construction in this section with a classical\n  example.\n  We assume that we have an ontology $O$ including a concept\n  $\\mathsf{person}$ and a role $\\mathsf{hasCPR}$, which associates\n  individuals with their CPR number.\n  (So we are essentially resetting Example~\\ref{ex:cpr} to use an\n  ontology, rather than a distributed database.)\n  We can add the integrity constraint\n \n", "index": 21, "text": "\\[\\leftarrow(O:\\mathsf{person}(x)),{\\mathsf{not}\\ }(O:\\mathsf{hasCPR}(x,y))\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\leftarrow(O:\\mathsf{person}(x)),{\\mathsf{not}\\ }(O:\\mathsf{hasCPR}(x,y))\" display=\"block\"><mrow><mo>\u2190</mo><mrow><mo stretchy=\"false\">(</mo><mi>O</mi><mo>:</mo><mi>\ud835\uddc9\ud835\uddbe\ud835\uddcb\ud835\uddcc\ud835\uddc8\ud835\uddc7</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mpadded width=\"+5pt\"><mi>\ud835\uddc7\ud835\uddc8\ud835\uddcd</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mi>O</mi><mo>:</mo><mi>\ud835\uddc1\ud835\uddba\ud835\uddcc\ud835\udda2\ud835\uddaf\ud835\uddb1</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}]