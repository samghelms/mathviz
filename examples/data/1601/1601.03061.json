[{"file": "1601.03061.tex", "nexttext": " \nwhere $\\mu$ is the service rate per unit packet size and ${s_{\\text{pu}}}^i$ and ${s_{\\text{ed}}}^i$ is the average size of PU and ED packets from the $i^{\\text{th}}$ sensor. The sojourn time for a packet in the system, $T$ is given by,\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\title{An Online Delay Efficient Multi-Class Packet Scheduler for Heterogeneous M2M Uplink Traffic}\n\n\\author{\\IEEEauthorblockN{Akshay Kumar, Ahmed Abdelhadi and Charles Clancy}\n\\IEEEauthorblockA{Hume Center, Virginia Tech\\\\\nEmail:\\{akshay2, aabdelhadi, tcc\\}@vt.edu}\n\\thanks{This research is based upon work supported by the National Science Foundation under Grant No. 1134843. \n}\n}\n\n\\maketitle \n\n\n\\begin{abstract}\nThe Machine-to-Machine (M2M) traffic exhibit heterogeneity in several dimensions such as packet arrival rate, delay tolerance requirements etc. Therefore, motivated by this, we study the delay-performance of a heterogeneous M2M uplink channel from the sensors to the Programmable Logic Controller (PLC) in an industrial automation scenario. Besides the heterogeneity across the sensors, the data from each sensor is also heterogeneous and can be classified as either Event Driven (ED) or Periodic Update (PU) data. While the ED arrivals are random and do not have hard service deadlines, the periodic PU data needs to be processed before a predetermined deadline. We map these contrasting delay requirements of PU and ED packets using step and sigmoidal functions of service delay respectively, with different parameters for different sensors. The aggregated traffic at PLC forms multiple queues/classes based on the delay requirements, which are then served so as to maximize a proportionally-fair system utility. Specifically the proposed multi-class scheduler gives priority to ED data from different sensors as long as the deadline is met for the PU data. We also provide PU-PU and ED-ED scheduling heuristics by appropriately choosing the priority order among PU and among ED classes respectively. We minimize successive PU failures using a novel exponential penalty function and clear the failed PU packets so as to reduce network congestion. Using extensive simulations, we compare the performance of our scheme with various state-of-the art packet schedulers and show that it outperforms other schedulers when network congestion increases. We show that this performance gap increases with heterogeneity in delay requirements and increasing penalization for successive PU failures.\n\\end{abstract}\n\n\\begin{IEEEkeywords}\nM2M, Latency, Quality-of-Service, Multi-Class Scheduler, Industrial Automation\n\\end{IEEEkeywords}\n\n\\section{Introduction}\nMachine-to-Machine (M2M) networks for automation of industrial monitoring and control processes is becoming increasingly popular. It typically consists of a multiple-access \\lq uplink channel\\rq~ from various industrial sensors to a Programmable Logic Controller (PLC) which then aggregates, processes the sensory information and then feeds back control information to ensure normal system operation. The industrial M2M traffic can be broadly categorized as either \\emph{non real-time} (for delay-tolerant traffic) or \\emph{soft real-time} (reduced utility after the service deadline) or \\emph{firm} (no utility after service deadline) or \\emph{hard} (catastrophic failure if deadline not met). For instance, periodic maintenance applications have \\emph{non real-time} service requirements whereas the messages from a safeguarding system needs to be processed in \\emph{hard} real-time. With increasing size of M2M network, the system resources are shared among a large number of sensors and thus makes it increasingly difficult to provide real-time service \\cite{3GPPreport}. This problem is exacerbated due to the heterogeneity in delay requirements of sensor traffic.\nTherefore, it is imperative to design practical delay-aware packet schedulers that scale well with increasing network size and with increasing heterogeneity in M2M uplink traffic. \n\nIn this paper, we first classify the data from each sensor into Event Driven (ED) and Periodic Update (PU) packets using the source M2M traffic model presented in \\cite{Navid13}. While the ED arrivals are random and do not have \\emph{hard} service deadlines, the periodic PU data have a \\emph{firm}\\footnote{Here we assume the data in consecutive PU packets does not vary significantly, especially if the period is small. So in the event a PU packet fails to meet deadline (hereafter termed as \\lq PU failure\\rq~), the PLC can estimate the data based on last received PU packet, thus ensuring normal system operation. Hence, we assume a \\emph{firm} service deadline instead of \\emph{hard} deadline. However, we do penalize consecutive PU failures to limit them.} deadline. Besides this, the M2M uplink traffic also exhibits heterogeneity in delay requirements across the sensors.\n\nWe use step and sigmoidal functions to map the delay requirements of PU and ED packets respectively, with different parameters for different sensors. The aggregated traffic at PLC forms multiple queues/classes based on the delay requirements, which are then served so as to maximize a proportionally-fair system utility defined as the product of (time) averaged utilities of all PU and ED classes. However, due to the randomness in arrival and service times, there exists no delay-optimal online algorithms \\cite{TiaLiuShankar}.\n\nTherefore, we propose an online delay-efficient multi-class heuristic scheduler for the uplink traffic at the PLC. The proposed scheduler aims to maximize system utility by giving priority to ED data from different sensors as long as the deadline is met for the PU data, thus relatively increasing the utility of the ED data. However as the M2M network scales up or PU deadlines become tighter, an increasing number of PU packets fail to meet their deadlines. Since the failed PU packets have no utility, we clear such packets to reduce the queue sizes at PLC and thus improve overall system utility by reducing the service delay for enqueued packets. Furthermore, successive PU failures are worse than isolated PU failures, because the PU message can change appreciably over the course of multiple packets and it becomes difficult for PLC to estimate the failed PU message. Therefore, we incorporate a novel exponential penalty function as part of PU utility function to reduce successive PU failures. Using extensive simulations, we show that the proposed scheduler has higher system utility as compared to various state-of-the-art scheduling policies such as First-Come-First-Serve (FCFS), Earliest Due Date (EDD), priority scheduling etc. We show that this performance gap increases with heterogeneity in delay requirements and increasing penalization for successive PU failures. Furthermore, the proposed scheduler is agnostic to the wireless technology being used for the M2M uplink and is also independent of the hardware-software architecture used in practical real-time embedded systems. Lastly, it can easily adapt to accommodate time-varying arrival and service rates for the PU and ED packets. \n\n\\emph{Paper Outline}: The rest of the paper is organized as follows. Section~\\ref{related} details the related work. Section~\\ref{sysModel} introduces the system model and defines the utility (and penalty) functions for PU and ED data. Then in Section~\\ref{probForm}, we formulate the utility maximization problem and in Section \\ref{propSch} describe the proposed scheduling scheme at PLC. Section~\\ref{Results} presents simulation results. Finally Section~\\ref{concl} draws some conclusions.\n\n\\section{Related Work}\n\\label{related}\nThe advent of new  M2M communication paradigms such as Zigbee, Low-power Wi-Fi etc. in industrial automation has increased its flexibility and efficiency but this comes at cost of increased complexity due to sharing of physical resources for various applications. This makes it harder to guarantee real-time services and just merely increasing computational resources is not very useful without appropriate scheduling strategies \\cite{Buttazzo04}. There have been numerous studies in literature on the design of real-time scheduling schemes that can be integrated with middle-ware based architectures. Tommaso et. al. in \\cite{Tommaso09} presented a real-time service oriented architecture for industrial automation. However, these works are tangential to our line of work in the sense that our proposed scheduler is agnostic to the hardware-middleware-software architecture and is designed to ensure proportionally-fair service utility to various delay-tolerant and delay-sensitive M2M traffic classes.\n\nRecently, a substantial work has been done on the design on delay-aware packet scheduler for M2M traffic in Long Term Evolution (LTE) network (see \\cite{Gotsis12} and references therein). Most of these works use an algorithm \\lq AGTI\\rq~to allocate access grants  to M2M devices in a fixed or dynamic manner over a periodic time-interval. Lioumpas and Alexiou in \\cite{Lioumpas11} proposed a dynamic channel-, queue-, and QoS-aware heuristic scheduler for uplink LTE traffic. Although this scheduler had a very high average delay performance, it suffered from high signaling complexity. Unlike our work, these packet schedulers are designed for a particular wireless technology (LTE in this case) and are thus heavily influenced by its Medium Access Control architecture. Furthermore, unlike our work, they don't explicitly consider the heterogeneity in packet rate and service delay requirements of traffic from different sensors. \n\nLastly, another line of work focuses on designing schedulers for real-time embedded systems (see \\cite{Buttazzo11} and references therein). These schedulers are generic enough to be applied to any application scenario using any wireless communication paradigm. The work-load to the system is assumed to consist of \\emph{soft real-time} aperiodic requests and \\emph{hard} periodic requests. These schemes are designed to ensure that the periodic requests are served before their deadline while providing the best effort service for aperiodic requests. The main limitation of these schedulers is that they assume the scheduler has complete \\emph{apriori} information about the service times for all the tasks. Hence these schedulers are not online in their present form making it difficult to adopt them for practical M2M systems.\n\nRecently Kumar et. al. in \\cite{sysCon16} proposed a delay-efficient heuristic packet scheduler for M2M uplink. Unlike \\cite{sysCon16}, our proposed scheduler is designed for a more general and practical scenario with multiple M2M traffic classes with different packet arrival rate and service delay requirements. Also, unlike \\cite{sysCon16}, we penalize successive PU failures so as to limit their occurrence.\n\n\\section{System Model}\n\\label{sysModel}\nThe system model for an industrial M2M uplink is shown in Fig~\\ref{systemModel}. The M2M traffic from all the sensors is aggregated at the PLC and enters one of the several queues based on the packet arrival rate and service delay requirements. Further the traffic from each of the $N$ sensors is heterogeneous and is categorized into delay-sensitive periodic updates (PU) or delay-tolerant event-driven (ED) packets triggered when the sensor measurement exceeds its threshold. In the most general sense, the arrival rate and latency requirements of uplink traffic is different for each sensor. Let $T_{\\text{pu}}^i$ denote the PU arrival period from the $i^{\\text{th}}$ sensor and thus its rate is ${\\lambda_{\\text{pu}}}^i = 1/T_{\\text{pu}}^i$. We model the random ED arrivals as a Poisson process with rate ${\\lambda_{\\text{ed}}}^i$. \n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{sysModel.eps}\n\\vspace{0pt}\n\\caption{System model for an industrial M2M uplink. We show only four M2M traffic classes for clarity of illustration.}\n\\label{systemModel}\n\\end{figure}\n\nThe packet processing time at PLC is random and is typically modeled as an exponential random variable. Let ${\\mu_{\\text{pu}}}^i$ and ${\\mu_{\\text{ed}}}^i$ denote the service rate for PU and ED packets from the $i^{\\text{th}}$ sensor, given by\n\n", "index": 1, "text": "\\begin{equation}\n{\\mu_{\\text{pu}}}^i = \\mu/{s_{\\text{pu}}}^i~\\text{and}~{\\mu_{\\text{ed}}}^i = \\mu/{s_{\\text{ed}}}^i,\n\\label{serviceRate}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"{\\mu_{\\text{pu}}}^{i}=\\mu/{s_{\\text{pu}}}^{i}~{}\\text{and}~{}{\\mu_{\\text{ed}}}%&#10;^{i}=\\mu/{s_{\\text{ed}}}^{i},\" display=\"block\"><mrow><mrow><mmultiscripts><mi>\u03bc</mi><mtext>pu</mtext><none/><none/><mi>i</mi></mmultiscripts><mo>=</mo><mrow><mrow><mi>\u03bc</mi><mo>/</mo><mpadded width=\"+3.3pt\"><mmultiscripts><mi>s</mi><mtext>pu</mtext><none/><none/><mi>i</mi></mmultiscripts></mpadded></mrow><mo>\u2062</mo><mpadded width=\"+3.3pt\"><mtext>and</mtext></mpadded><mo>\u2062</mo><mmultiscripts><mi>\u03bc</mi><mtext>ed</mtext><none/><none/><mi>i</mi></mmultiscripts></mrow><mo>=</mo><mrow><mi>\u03bc</mi><mo>/</mo><mmultiscripts><mi>s</mi><mtext>ed</mtext><none/><none/><mi>i</mi></mmultiscripts></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere we have,\n\\begin{itemize}\n\t\\item $T_{\\text{t}}$ is the packet transmission time at a sensor,\n\t\\item $T_{\\text{p}}$ is the propagation delay from the sensor to PLC,\n\t\\item $T_{\\text{c}}$ is the congestion delay due to the multiple-access nature of M2M uplink,\n\t\\item $T_{\\text{q}}$ is the delay experienced by packet waiting for service at the PLC, and\n\t\\item $T_{\\text{s}}$ is the packet processing time at the PLC.\n\\end{itemize}\nIn this work, we focus only on the queuing delay $T_{\\text{q}}$ and PLC service delay $T_{\\text{s}}$ and ignore other delay components. The transmission rate is typically much larger than the packet size to safely ignore the delay $T_{\\text{t}}$. The propagation delay $T_{\\text{p}}$ is also quite small because of relatively small distances between various wireless links in a shop floor of an industrial plant. Lastly, we assume that the available wireless spectrum is sufficient to avoid contention for uplink channel; so there is no congestion delay $T_{\\text{c}}$.\n\nIn the most general case, the PU and ED packets from $N$ sensors form a total of $2N$ queues/traffic-classes at the PLC. We need to design the packet scheduler at PLC so as to maximally satisfy the delay constraints for all traffic classes. \n\n\\section{Problem Formulation} \n\\label{probForm}\nIn this section, we first map the delay requirements onto the utility functions for the PU and ED traffic classes for each sensor.\n\\subsection{Utility Functions}\n\n\\subsubsection{PU utility} The PU traffic is delay-sensitive and the packets need to be served before a predetermined deadline beyond which the utility drops to zero as shown in Fig.~\\ref{puUtility} for $i^{\\text{th}}$ sensor. For a PU packet from $i^{\\text{th}}$ sensor with latency $l_{pu}^i$, we define the utility function as,\n\n", "itemtype": "equation", "pos": 12308, "prevtext": " \nwhere $\\mu$ is the service rate per unit packet size and ${s_{\\text{pu}}}^i$ and ${s_{\\text{ed}}}^i$ is the average size of PU and ED packets from the $i^{\\text{th}}$ sensor. The sojourn time for a packet in the system, $T$ is given by,\n\n", "index": 3, "text": "\\begin{equation}\nT = T_{\\text{t}}+T_{\\text{p}}+T_{\\text{c}}+T_{\\text{q}}+T_{\\text{s}},\n\\label{sojTime}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"T=T_{\\text{t}}+T_{\\text{p}}+T_{\\text{c}}+T_{\\text{q}}+T_{\\text{s}},\" display=\"block\"><mrow><mrow><mi>T</mi><mo>=</mo><mrow><msub><mi>T</mi><mtext>t</mtext></msub><mo>+</mo><msub><mi>T</mi><mtext>p</mtext></msub><mo>+</mo><msub><mi>T</mi><mtext>c</mtext></msub><mo>+</mo><msub><mi>T</mi><mtext>q</mtext></msub><mo>+</mo><msub><mi>T</mi><mtext>s</mtext></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere $l_d^i$ is the latency deadline at which utility drops to 0. We now define a novel exponential penalty function to limit the number of successive PU drops. Let $r_i$ denote the run-length\\footnote{A run is a maximal length sequence of consecutive identical outcomes within a larger sequence. For example, let $[S S {\\color{red}D D} S {\\color{red} D} S {\\color{red}D D D} S]$ denote a sequence of PU success ($S$) and drops (${\\color{red}D}$). Then we have three runs of PU drops of lengths $1$, $2$ and $3$.} of PU drops for $i^{\\text{th}}$ sensor, then the corresponding penalty is,\n\n", "itemtype": "equation", "pos": 14217, "prevtext": "\nwhere we have,\n\\begin{itemize}\n\t\\item $T_{\\text{t}}$ is the packet transmission time at a sensor,\n\t\\item $T_{\\text{p}}$ is the propagation delay from the sensor to PLC,\n\t\\item $T_{\\text{c}}$ is the congestion delay due to the multiple-access nature of M2M uplink,\n\t\\item $T_{\\text{q}}$ is the delay experienced by packet waiting for service at the PLC, and\n\t\\item $T_{\\text{s}}$ is the packet processing time at the PLC.\n\\end{itemize}\nIn this work, we focus only on the queuing delay $T_{\\text{q}}$ and PLC service delay $T_{\\text{s}}$ and ignore other delay components. The transmission rate is typically much larger than the packet size to safely ignore the delay $T_{\\text{t}}$. The propagation delay $T_{\\text{p}}$ is also quite small because of relatively small distances between various wireless links in a shop floor of an industrial plant. Lastly, we assume that the available wireless spectrum is sufficient to avoid contention for uplink channel; so there is no congestion delay $T_{\\text{c}}$.\n\nIn the most general case, the PU and ED packets from $N$ sensors form a total of $2N$ queues/traffic-classes at the PLC. We need to design the packet scheduler at PLC so as to maximally satisfy the delay constraints for all traffic classes. \n\n\\section{Problem Formulation} \n\\label{probForm}\nIn this section, we first map the delay requirements onto the utility functions for the PU and ED traffic classes for each sensor.\n\\subsection{Utility Functions}\n\n\\subsubsection{PU utility} The PU traffic is delay-sensitive and the packets need to be served before a predetermined deadline beyond which the utility drops to zero as shown in Fig.~\\ref{puUtility} for $i^{\\text{th}}$ sensor. For a PU packet from $i^{\\text{th}}$ sensor with latency $l_{pu}^i$, we define the utility function as,\n\n", "index": 5, "text": "\\begin{equation}\n{U_{\\text{pu}}}^i(l_{pu}^i) = \\begin{cases} 1 & \\text{if } l_{pu}^i < l_d^i \\\\\n 0 & \\text{if } l_{pu}^i \\geq l_d^i, \\end{cases}\n\\label{puUtila}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"{U_{\\text{pu}}}^{i}(l_{pu}^{i})=\\begin{cases}1&amp;\\text{if }l_{pu}^{i}&lt;l_{d}^{i}%&#10;\\\\&#10;0&amp;\\text{if }l_{pu}^{i}\\geq l_{d}^{i},\\end{cases}\" display=\"block\"><mrow><mrow><mmultiscripts><mi>U</mi><mtext>pu</mtext><none/><none/><mi>i</mi></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>u</mi></mrow><mi>i</mi></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msubsup><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>u</mi></mrow><mi>i</mi></msubsup></mrow><mo>&lt;</mo><msubsup><mi>l</mi><mi>d</mi><mi>i</mi></msubsup></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msubsup><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>u</mi></mrow><mi>i</mi></msubsup></mrow><mo>\u2265</mo><msubsup><mi>l</mi><mi>d</mi><mi>i</mi></msubsup></mrow><mo>,</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere $\\gamma_i \\geq 1$ is a penalty function parameter denoting the degree of penalty for $i^{\\text{th}}$ sensor. $\\gamma_i = 1$ implies that we do not penalize consecutive PU drops.\n\n\\subsubsection{ED utility} The ED traffic, in contrast to the PU traffic, is delay-tolerant and the service utility gradually decreases with increase in service delay. However, the rate of decrease in utility with delay depends on the type of sensor. Therefore, we define the ED utility for $i^{\\text{th}}$ sensor as a sigmoidal function, as in \\cite{AbdelhadiCNC2014, AbdelhadiPIMRC2013}, given by,\n\n", "itemtype": "equation", "pos": 14983, "prevtext": "\nwhere $l_d^i$ is the latency deadline at which utility drops to 0. We now define a novel exponential penalty function to limit the number of successive PU drops. Let $r_i$ denote the run-length\\footnote{A run is a maximal length sequence of consecutive identical outcomes within a larger sequence. For example, let $[S S {\\color{red}D D} S {\\color{red} D} S {\\color{red}D D D} S]$ denote a sequence of PU success ($S$) and drops (${\\color{red}D}$). Then we have three runs of PU drops of lengths $1$, $2$ and $3$.} of PU drops for $i^{\\text{th}}$ sensor, then the corresponding penalty is,\n\n", "index": 7, "text": "\\begin{equation}\nP_{\\text{pu}}^i(r_i) = r_i - {r_i}^{\\gamma_i},~r_i \\geq 1\n\\label{puUtilb}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"P_{\\text{pu}}^{i}(r_{i})=r_{i}-{r_{i}}^{\\gamma_{i}},~{}r_{i}\\geq 1\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>P</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>-</mo><mmultiscripts><mi>r</mi><mi>i</mi><none/><none/><msub><mi>\u03b3</mi><mi>i</mi></msub></mmultiscripts></mrow></mrow><mo rspace=\"5.8pt\">,</mo><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>\u2265</mo><mn>1</mn></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere, $c_i=\\frac{1+{\\text{e}}^{a_ib_i}}{{\\text{e}^{a_ib_i}}}$ and $d_i = \\frac{1}{1+{\\text{e}^{a_ib_i}}}$. Note that ${U_{\\text{ed}}}^i(0)=1$ and ${U_{\\text{ed}}}^i(\\infty) = 0$. The parameter $a_i$ is the roll-off factor that depends on the nature of criticality of the application. \n\n\\subsection{System utility function} We now define a proportionally fair system utility metric, for a given scheduling policy $\\mathcal{P}$, as follows,\n\n", "itemtype": "equation", "pos": 15674, "prevtext": "\nwhere $\\gamma_i \\geq 1$ is a penalty function parameter denoting the degree of penalty for $i^{\\text{th}}$ sensor. $\\gamma_i = 1$ implies that we do not penalize consecutive PU drops.\n\n\\subsubsection{ED utility} The ED traffic, in contrast to the PU traffic, is delay-tolerant and the service utility gradually decreases with increase in service delay. However, the rate of decrease in utility with delay depends on the type of sensor. Therefore, we define the ED utility for $i^{\\text{th}}$ sensor as a sigmoidal function, as in \\cite{AbdelhadiCNC2014, AbdelhadiPIMRC2013}, given by,\n\n", "index": 9, "text": "\\begin{equation}\n{U_{\\text{ed}}}^i(l_{ed}^i) = 1-c_i\\left(\\frac{1}{1+{\\text{e}}^{-a_i(l_{ed}^i-b_i)}}-d_i\\right),\n\\label{edUtil}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"{U_{\\text{ed}}}^{i}(l_{ed}^{i})=1-c_{i}\\left(\\frac{1}{1+{\\text{e}}^{-a_{i}(l_{%&#10;ed}^{i}-b_{i})}}-d_{i}\\right),\" display=\"block\"><mrow><mrow><mrow><mmultiscripts><mi>U</mi><mtext>ed</mtext><none/><none/><mi>i</mi></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>l</mi><mrow><mi>e</mi><mo>\u2062</mo><mi>d</mi></mrow><mi>i</mi></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>-</mo><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mtext>e</mtext><mrow><mo>-</mo><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>l</mi><mrow><mi>e</mi><mo>\u2062</mo><mi>d</mi></mrow><mi>i</mi></msubsup><mo>-</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow></mfrac><mo>-</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere ${\\mathcal{U}_{\\text{pu}}^i}(\\mathcal{P})$ and ${\\mathcal{U}_{\\text{ed}}^i}(\\mathcal{P})$ are the average utility of PU and ED packets in the steady state given as,\n\n", "itemtype": "equation", "pos": 16258, "prevtext": "\nwhere, $c_i=\\frac{1+{\\text{e}}^{a_ib_i}}{{\\text{e}^{a_ib_i}}}$ and $d_i = \\frac{1}{1+{\\text{e}^{a_ib_i}}}$. Note that ${U_{\\text{ed}}}^i(0)=1$ and ${U_{\\text{ed}}}^i(\\infty) = 0$. The parameter $a_i$ is the roll-off factor that depends on the nature of criticality of the application. \n\n\\subsection{System utility function} We now define a proportionally fair system utility metric, for a given scheduling policy $\\mathcal{P}$, as follows,\n\n", "index": 11, "text": "\\begin{equation}\n\\mathcal{V}(\\mathcal{P}) = \\prod_{i=1}^N{{\\mathcal{U}_{\\text{pu}}^i}}^{{\\beta_{\\text{pu}}^i}}(\\mathcal{P})*{{\\mathcal{U}_{\\text{ed}}^i}}^{{\\beta_{\\text{ed}}^i}}(\\mathcal{P}),\n\\label{sysUtil}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\mathcal{V}(\\mathcal{P})=\\prod_{i=1}^{N}{{\\mathcal{U}_{\\text{pu}}^{i}}}^{{%&#10;\\beta_{\\text{pu}}^{i}}}(\\mathcal{P})*{{\\mathcal{U}_{\\text{ed}}^{i}}}^{{\\beta_{%&#10;\\text{ed}}^{i}}}(\\mathcal{P}),\" display=\"block\"><mrow><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mrow><mrow><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>pu</mtext><mi>i</mi><none/><msubsup><mi>\u03b2</mi><mtext>pu</mtext><mi>i</mi></msubsup></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>*</mo><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>ed</mtext><mi>i</mi><none/><msubsup><mi>\u03b2</mi><mtext>ed</mtext><mi>i</mi></msubsup></mmultiscripts></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nwhere $M_{\\text{pu}}^i(T_{\\text{s}})$ and $M_{\\text{ed}}^i(T_{\\text{s}})$ are the number of PU and ED packets from $i^{\\text{th}}$ sensor served in time $T_{\\text{s}}$. $R_{i}(T_{\\text{s}})$  denotes the number of runs of PU drops in time $T_{\\text{s}}$ and $r_{i,j}$ denotes the run-length of $j^{\\text{th}}$ PU drop for sensor $i$. $l_{\\text{pu}}^{i,j}$ and $l_{\\text{ed}}^{i,j}$ denote the latency of the $j^{\\text{th}}$ packet from $i^{\\text{th}}$ sensor of type PU and ED respectively. The parameters ${\\beta_{\\text{pu}}^i}$ and ${\\beta_{\\text{ed}}^i}$ denote the priority given to average PU and ED utility for $i^{\\text{th}}$ sensor. \n\n\\begin{figure}\n\\centering\n   \\includegraphics[width=\\columnwidth]{utilPUplot.eps}   \n\\caption{Utility function for PU packet.}\n\\label{puUtility} \n\\end{figure}\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{utilEDplot.eps}\n\\caption{Utility function for ED packet.}\n \\label{edUtility} \n\\end{figure}\n\n\\subsection{Optimal scheduler} In the context of our problem, the optimal scheduler at PLC is the one that maximizes the proportionally fair utility metric, $\\mathcal{V}(\\mathcal{P})$. Mathematically this can be expressed as,\n\n", "itemtype": "equation", "pos": 16652, "prevtext": "\nwhere ${\\mathcal{U}_{\\text{pu}}^i}(\\mathcal{P})$ and ${\\mathcal{U}_{\\text{ed}}^i}(\\mathcal{P})$ are the average utility of PU and ED packets in the steady state given as,\n\n", "index": 13, "text": "\\begin{align}\n{\\mathcal{U}_{\\text{pu}}^i}(\\mathcal{P}) &= \\lim_{{T_{\\text{s}}} \\rightarrow \\infty} \\frac{\\sum_{j=1}^{M_{\\text{pu}}^i(T_{\\text{s}})} {\\mathcal{U}_{\\text{pu}}^i}(l_{\\text{pu}}^{i,j}(\\mathcal{P})) + \\sum_{j=1}^{R_i(T_{\\text{s}})} P_{\\text{pu}}^i(r_{i,j}(\\mathcal{P}))}{M_{\\text{pu}}^i(T_{\\text{s}})}, \\\\\n{\\mathcal{U}_{\\text{ed}}^i}(\\mathcal{P}) &= \\lim_{{T_{\\text{s}}} \\rightarrow \\infty} \\frac{\\sum_{j=1}^{M_{\\text{ed}}(T_{\\text{s}})} {\\mathcal{U}_{\\text{ed}}^i}(l_{\\text{ed}}^{i,j}(\\mathcal{P}))}{M_{\\text{ed}}(T_{\\text{s}})},\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathcal{U}_{\\text{pu}}^{i}}(\\mathcal{P})\" display=\"inline\"><mrow><msubsup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\lim_{{T_{\\text{s}}}\\rightarrow\\infty}\\frac{\\sum_{j=1}^{M_{\\text%&#10;{pu}}^{i}(T_{\\text{s}})}{\\mathcal{U}_{\\text{pu}}^{i}}(l_{\\text{pu}}^{i,j}(%&#10;\\mathcal{P}))+\\sum_{j=1}^{R_{i}(T_{\\text{s}})}P_{\\text{pu}}^{i}(r_{i,j}(%&#10;\\mathcal{P}))}{M_{\\text{pu}}^{i}(T_{\\text{s}})},\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><msub><mi>T</mi><mtext>s</mtext></msub><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><msubsup><mi>M</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mtext>s</mtext></msub><mo stretchy=\"false\">)</mo></mrow></mrow></msubsup><mrow><msubsup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>l</mi><mtext>pu</mtext><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mtext>s</mtext></msub><mo stretchy=\"false\">)</mo></mrow></mrow></msubsup><mrow><msubsup><mi>P</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mrow><msubsup><mi>M</mi><mtext>pu</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mtext>s</mtext></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mstyle></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathcal{U}_{\\text{ed}}^{i}}(\\mathcal{P})\" display=\"inline\"><mrow><msubsup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>ed</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\lim_{{T_{\\text{s}}}\\rightarrow\\infty}\\frac{\\sum_{j=1}^{M_{\\text%&#10;{ed}}(T_{\\text{s}})}{\\mathcal{U}_{\\text{ed}}^{i}}(l_{\\text{ed}}^{i,j}(\\mathcal%&#10;{P}))}{M_{\\text{ed}}(T_{\\text{s}})},\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><msub><mi>T</mi><mtext>s</mtext></msub><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><msub><mi>M</mi><mtext>ed</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mtext>s</mtext></msub><mo stretchy=\"false\">)</mo></mrow></mrow></msubsup><mrow><msubsup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>ed</mtext><mi>i</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>l</mi><mtext>ed</mtext><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mrow><msub><mi>M</mi><mtext>ed</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>T</mi><mtext>s</mtext></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mstyle></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03061.tex", "nexttext": "\nDue to the step utility function for PU, the optimal scheduling policy is to process PU jobs from $i^{\\text{th}}$ class so that they are completed exactly at the deadline $l_d^i$. However, this requires the PLC to know the service times of all the packets \\emph{apriori}, which is not realistic. In fact, Tia et. al. in \\cite{TiaLiuShankar} showed that there exists no optimal scheduler if packet service times are random. Therefore, we propose an online multi-class heuristic that seeks to maximize the system utility as described in the next section.\n\n\\section{Proposed Scheduler}\n\\label{propSch}\n\\subsection{Scheduling heuristic between PU and ED classes}\nDue to the step PU utility function, the system utility is maximized if service to ED packets is prioritized while ensuring that the delay for PU packets does not exceed its deadline. But due to the randomness in packet service times, it is not possible to implement the optimal scheduler at PLC. Therefore, our proposed heuristic scheduler gives priority to ED packets as long as the delay of PU packet of $i^{\\text{th}}$ class is less than a preset delay threshold $l_{t}^i, (0<l_{t}^i<l_d^i),~\\forall~i = 1, 2, \\cdots, N$. If the delay for PU packet exceeds its delay threshold while PLC is processing a ED packet, then the ED packet is readily preempted to serve the PU packet. This reduces the delay of ED packets while ensuring that the delay for most of the PU packets does not exceed their deadline. \n\n\\subsection{Scheduling heuristic among PU classes}\nWe now present the scheduling rule for breaking the service contention between packets of different PU classes. Now the data in successive PU packets is less correlated if the transmission period is higher and thus it is more important to meet its service deadline compared to a PU class with smaller transmission period. We account for this in our framework by penalizing the PU failures more (i.e., larger $\\gamma_i$), if arrival period is high. So in order to maximize system utility, the proposed scheduler gives higher (preemptive) priority to PU class with higher period. However, similar to previous section, the priority order between PU classes comes into effect only when the packet delay exceeds the delay threshold $l_t^i$.\n\n\\subsection{Scheduling heuristic among ED classes}\nWe now present the scheduling rule for breaking the service contention between packets of different ED classes. We assign higher priority to ED classes that require lower delay (lower $b_i$) or have stringent deadlines (high $a_i$). The priority order among ED classes comes into effect immediately after the packet enters the queue at PLC. However, if the total delay (queuing plus processing time at PLC) of $i^{\\text{th}}$ ED class exceeds a threshold $\\delta_i$ while there are ED packets in queue, then its gets preempted by the ED packet with next highest priority. By definition, the threshold $\\delta_i = \\infty$ for ED class with lowest priority. This preemption ensures that ED packets that experience long service delays do not increase delay of subsequent ED packets. Also this preemption has negligible impact of utility of preempted ED packet because its (sigmoidal) utility is quite small at high values of service delay. Thus, the proposed scheduler reduces the delay of delay-sensitive ED class without incurring very large delay for delay-tolerant ED classes. \n\n\\begin{exmp}\nWe now illustrate the operation of our proposed scheduler using a simple example with $4$ M2M traffic classes - PU1, PU2, ED1 and ED2, as shown in Fig.~\\ref{example_scheduler}. We arbitrarily assume that the packets of PU1 and PU2 class arrive every $10$~ms and $20$~ms respectively. Therefore PU2 has higher priority than PU1. Let the delay thresholds for PU1 and PU2 be $l_t^1=2$~ms and $l_t^2=1$~ms respectively. Assume ED1 has higher priority than ED2 and set the thresholds $\\delta_1=8$~ms and $\\delta_1=\\infty$. Further, assume the (random) service time at PLC for the packet of PU1, PU2, ED1, ED2 considered in Fig.~\\ref{example_scheduler} be $2$~ms, $1$~ms, $9$~ms and $4$~ms respectively. We now describe the sequence of actions taken by scheduler as packets of different classes arrive at PLC.\n\\begin{itemize}\n\t\\item $t=0$: ED1 packet arrives and immediately enters the idle PLC.\n\t\\item $t=1$: PU1 packet arrives and enters the queue.\n\t\\item $t=2$: ED2 packet arrives and enters the queue.\n\t\\item $t=3$: Delay for PU1 equals $l_t^1 = 2$~ms, it preempts the ED1 packet from the PLC. Also a PU2 packet enters the queue at same time.\n\t\\item $t=4$: Delay for PU2 equals $l_t^2 = 1$~ms and preempts PU1 packet due to its higher priority.\n\t\\item $t=5$: PLC completes processing of PU2 packet and preempted PU1 packet renters service.\n\t\\item $t=6$: PLC completes processing of PU1 packet and preempted ED1 packet enters service.\n\t\\item $t=8$: Delay for ED1 packet equals $\\delta_1=8$~ms, so it is preempted again by ED2 packet.\n\\end{itemize} \n\\end{exmp}\n\nNow, in order to maximize the system utility for a given set of system parameters, we need to determine the jointly optimal value of PU and ED thresholds, $l_t^i$ and $\\delta_i~\\forall~i=\\{1,2,\\cdots,N\\}$. Using simulations, the optimal thresholds can be stored in a Look-Up-Table (LUT) prior to the deployment of proposed scheduler. Then the proposed scheme can adapt on-the-fly if any system parameter change, by looking up and using the optimal $l_t^i$ and $\\delta_i$.\n \nAnother novel feature of our scheduler is that we drop PU packets from the queue that exceed their latency deadline $l_d^i$ as there is no resultant utility from serving such packets. However, dropping them from service reduce congestion and thus reduce latency for all packets in the queue. The proposed scheduler is described in detail in Algorithm~\\ref{propScheduler}.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{example_scheduler.eps}\n\\caption{Example illustrating the proposed scheduler.}\n\\label{example_scheduler}\n\\end{figure}\n\n\n\\vspace{-5pt}\n\\section{Simulation Results}\n\\label{Results}\nWe now use Monte-Carlo simulations to compare the (system utility) performance of our scheme with various state-of-the-art packet schedulers such as EDD, Preemptive priority and FCFS policy. To ensure a steady-state queuing behavior at PLC, we set the simulation time $T_{\\text{sim}} = 40$~s. The number of sensors $N$ is set to $200$. Although the proposed scheduler is designed for $2N$ PU and ED classes for any value of $N$, the simulations becomes computationally intractable as $N$ increases. This is because we need to determine $2N-1$ jointly optimal latency thresholds\\footnote{The number of threshold variables is $2N-1$ rather than $2N$ because the optimal $\\delta_i$ for least priority ED class in $\\infty$.} using the simulations. Therefore for computational tractability, we assume that half of sensory traffic (i.e., 100 sensors) can be classified into one set of PU and ED class (i.e., PU1 and ED1), while the other half is classified into PU2 and ED2 class. So we consider a total of 4 traffic classes. We assume the arrival period per sensor for PU1 to be $T_{\\text{pu}}^1 = 600$~ms, while for PU2 to be $T_{\\text{pu}}^2 = 250$~ms. The arrival rate per sensor for ED2 is set to $\\lambda_{\\text{ed}}^2=0.001$/ms and for ED1 $\\lambda_{\\text{ed}}^1$ is varied from $0.001$--$0.0025$/ms. PLC service rate is $\\mu=100$~bits/ms. The relative importance of all classes is set equal, i.e. ${\\beta_{\\text{pu}}^1}={\\beta_{\\text{pu}}^2}={\\beta_{\\text{ed}}^1}={\\beta_{\\text{ed}}^2}=1$, unless mentioned otherwise. The size of packets for all classes are set equal to $1$. The latency deadline for PU1 is, $l_d^1 = 4$~ms and for PU2 is $l_d^2=8$~ms. The utility function parameters for ED1 are set to, $[a_1, b_1] = [1, 10, 1]$ and for ED2 are $[a_2, b_2] = [0.7, 20, 1]$ unless mentioned otherwise. The latency threshold for ED1 is, $\\delta_1 = b_1+(4/a_1)$ and for ED2 is $\\delta_2 = \\infty$. For each simulation scenario, the latency threshold for PU1 and PU2 class are determined by jointly maximizing system utility over $0\\leq l_t^1 \\leq l_d^1$ and $0\\leq l_t^2 \\leq l_d^2$. \n\n\\subsection{Impact of latency-heterogeneity across sensors}\nIn this section, we study the impact of increasing heterogeneity in delay requirements of M2M traffic classes on the performance of different schedulers. Fig.~\\ref{vary_ed1_homo} shows plot of system utility for a nearly homogeneous system with $T_{\\text{pu}}^1 = T_{\\text{pu}}^2 = 88$~ms, $[l_d^1, l_d^2] = [7.8, 8]$~ms, $[a_1, a_2] = [0.65, 7]$/ms and $[b_1, b_2] = [19, 20]$~ms. Then, we increase the heterogeneity in system by using the default system parameters; the resulting system utility is shown in Fig.~\\ref{vary_ed1_noPenalty}. We note that, at high $\\lambda_{\\text{ed}}^1$,  the performance gap between the proposed scheduler (without PU drop) and the best state-of-the-art scheduler, $\\Delta V$, is much larger for heterogeneous system ($\\Delta V=0.33$) compared to homogeneous system ($\\Delta V=0.19$). This is because in a heterogeneous system, the impact of PU-PU, PU-ED and ED-ED scheduling heuristics in Section~\\ref{propSch} on the system utility becomes more prominent. Furthermore as expected, the performance gap further increases if we begin to clear the failed PU packets from the system. \n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{vary_ed1_homo.eps}\n\\caption{System utility with roughly similar latency requirements of sensors.}\n\\label{vary_ed1_homo}\n\\end{figure}\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{vary_ed1_noPenalty.eps}\n\\caption{System utility with diverse latency requirements of sensors.}\n\\label{vary_ed1_noPenalty}\n\\end{figure}\n\n\\subsection{Impact of choice of ED threshold, $\\delta_i$}\nFig.~\\ref{vary_ed1_optDelta} shows the impact of selecting optimal ED1 threshold $\\delta_1$ on the system utility $V$. We note that at high $\\lambda_{\\text{ed}1}$, the performance of proposed scheduler is significantly improved ($\\Delta V=0.60$) compared to Fig.~\\ref{vary_ed1_noPenalty} ($\\Delta V=0.33$) where $\\delta_1$ was arbitrarily set to $b_1 + (4/a_1)$. This is because selecting optimal $\\delta_1$ for ED1 prevents very large delays for ED2 especially when arrival rate of ED1 ($\\lambda_{\\text{ed1}}$), is very large relative to that of ED2 ($\\lambda_{\\text{ed2}}$).\n\\begin{figure}[!ht]\n\\centering\n\\includegraphics[width=\\columnwidth]{vary_ed1_optDelta_noPenalty.eps}\n\\caption{System utility with optimal selection of threshold $\\delta_1$.}\n\\label{vary_ed1_optDelta}\n\\end{figure}\n\n\\subsection{Impact of penalizing successive PU failures}\nSo far, we have assumed there is no penalty for successive PU failures, i.e., $\\gamma_1 = \\gamma_2 = 1$. We now study the impact of penalizing successive PU failures ($\\gamma_i > 1$) on the performance of different schedulers. Fig.~\\ref{vary_ed1_moderate} shows the plot of system utility when the penalty for PU failures is small and equal for PU1 and PU2 $(\\gamma_1=\\gamma_2=1.2)$. We observe that while the performance degradation (due to PU failure penalty) is marginal for proposed schedulers, the performance of other schedulers decrease sharply and is nearly $0$ at $\\lambda_{\\text{ed}_1}=0.25$. Again this is because the proposed scheduler easily adapts to higher PU penalty by reducing the latency thresholds accordingly. But the other schedulers do not possess that flexibility and thus their performance suffers. We note that the degradation in performance is much more pronounced when the PU failure penalty for higher priority class PU1 is increased from $\\gamma_1 = 1.2$ to $2$ as illustrated in Fig.~\\ref{vary_ed1_extremePenalty}.\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[width=\\columnwidth]{vary_ed1_moderate.eps}\n\\caption{System utility with small, equal PU drop penalty ($\\gamma_1=\\gamma_2 = 1.2$).}\n\\label{vary_ed1_moderate}\n\\end{figure}\n\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[width=\\columnwidth]{vary_ed1_extremePenalty.eps}\n\\caption{System utility with unequal PU drop penalty ($[\\gamma_1, \\gamma_2] = [2, 1.2]$).}\n\\label{vary_ed1_extremePenalty}\n\\end{figure}\n\n\\section{Conclusions}\n\\label{concl}\nIn this paper, we presented an online delay-efficient packet scheduler for uplink M2M traffic while accounting for the heterogeneity in delay requirements both within and across the sensors. The data from each sensor is classified as either PU or ED packets. The diverse latency requirements of PU and ED class for different sensors are accommodated by varying the parameters of step and sigmoidal utility functions respectively. We then proposed a novel proportionally-fair multi-class packet scheduler that gives priority to ED data while ensuring the latency deadline is met for the PU data. We also provide PU-PU and ED-ED scheduling heuristics by appropriately choosing the priority order among PU and among ED classes respectively. As the size of M2M network increases, the PU packets increasingly fail to meet their deadlines. We remove the failed PU packets from the system to reduce congestion and thus improve overall system utility. We also incorporated a novel exponential penalty function as part of PU utility so as to limit successive PU failures. Using extensive simulations, we did a comparative performance analysis of the proposed scheme with various state-of-the art scheduling policies such as FCFS, EDD, Preemptive priority etc. We note that as the uplink traffic increases, the proposed scheduler outperforms other schedulers for various simulation scenarios. The performance gap further increases with increasing heterogeneity in latency requirements and increase in penalty for successive PU drops.\n\n\\bibliographystyle{ieeetr}\t\n\n\\bibliography{wiOptMultiClass}\t\n\\clearpage\n\n\\begin{algorithm*}\n\\caption{Proposed Online Packet Scheduler}\n\\label{propScheduler}\n\n \\textbf{Inputs} \\\\\n  \\text{$l_d^i,~ l_t^i~\\forall~i=\\{1,2,\\cdots, N\\}$ are latency deadlines and thresholds for $N$ PU classes.}\\\\\n  \\text{$\\delta_i~\\forall~i=\\{1,2,\\cdots, N\\}$ are the latency threshold for $N$ ED classes.}\\\\\n  \\text{$T_{\\text{sim}}$ is the duration of simulation and $\\Delta T$ is the time resolution at which the algorithm operates}.\\\\\n  \n  \\textbf{Local} \\\\\n   \\text{$T_c$ stores current system time.}\\\\\n   \\text{$\\mathcal{A}$ and $\\mathcal{B}$ denotes the set of PU and ED classes with non-zero packets in queue or in service.}\\\\\n   \\text{$\\mathcal{A}^e$ and $\\mathcal{B}^e$ denotes the set of all PU and ED classes that exceed their corresponding threshold $l_t^i$ and $\\delta_i$ respectively.}\\\\\n   \\text{$\\bar{\\mathcal{B}}$ denotes the set $\\mathcal{B}-\\mathcal{B}^e$.}\\\\\n   \\text{$\\mathcal{A}^d$ denotes the set of all PU  classes that fail to meet their deadlines $l_d^i$.}\\\\\n   \\text{$A_h, A_h^e, B_h, \\bar{B}_h$ denote the class with highest priority in sets $\\mathcal{A}, \\mathcal{A}^e, \\mathcal{B}, \\bar{\\mathcal{B}}$ respectively.}\\\\\n   \\text{$z$ denote class of current packet being served.}\\\\\n\n\t\\textbf{Initialization} \\\\\n\t\\text{Advance current time $T_c$ to be the arrival time of next packet in system.}\\\\\n\t\\text{Set $\\mathcal{A}^d = \\varnothing$. Set $A_h, B_h$ from given set of PU and ED classes.}\\\\\n\t\n\t\\textbf{Begin Algorithm:}\n\t\t\\begin{algorithmic}[1] \n\t\t\\label{algoProp}\n\t\t\\While{$T_c \\leq T_{\\text{sim}}$} \\label{marker1}\n\t\t\n\t\t   \\State Determine $z$ and the set $\\mathcal{A}^d$.\t\n\t\t    \\If{$\\mathcal{A}^d \\neq \\varnothing$} \\Comment{Clear failed PU packets}\n        \t\t\\State Remove the Head-of-Line (HoL) packet from all PU queues in set $\\mathcal{A}^d$. \\Goto{marker}. \n\n\n\n\n\n        \t\\EndIf\n        \t\\State Determine the set $\\mathcal{A}^e, \\mathcal{B}^e, \\bar{\\mathcal{B}}$ and the classes $A_{h}^e, B_h, \\bar{B}_{h}$. \n\n\n\t\t\t\\If{$\\mathcal{A}^e \\neq \\varnothing$ \\& $(z \\notin \\mathcal{A}^e ~|~ (z \\in \\mathcal{A}^e~ \\&~ z \\neq A_h^e))$} \\Comment{Use PU-PU or PU-ED scheduling heuristic based on current packet in PLC}\n\t\t\t\t\\State Preempt the current packet with HoL of class $A_{h}^e$. \t\t\t\n        \t\\ElsIf{$\\mathcal{A}^e = \\varnothing$  \\& $\\mathcal{B}^e = \\varnothing$ \\& $z \\neq B_{h}$} \\Comment{Use ED-ED scheduling heuristic; no ED class exceeds threshold}\n        \t\t\\State Preempt the current packet with HoL packet of class $B_{h}$. \n        \t\\ElsIf{$\\mathcal{A}^e = \\varnothing$ \\& $\\mathcal{B}^e \\neq \\varnothing$ \\& $z \\neq \\bar{B}_h$} \\Comment{Use ED-ED scheduling heuristic; some ED class exceeds threshold}\n\t\t\t\t\\State Preempt the current packet with HoL of class $\\bar{B}_{h}$.         \t\n            \\Else  \\Comment{No preemption occurs; wait till current packet is processed.}\n            \t\\State Advance current time $T_c$ to the service completion event. \n            \t\\State Recalculate the sets $\\mathcal{A}^e, \\mathcal{B}^e, \\bar{\\mathcal{B}}$ and the classes $A_{h}^e, \\bar{B}_{h}$. \\label{marker} \n\t\n            \t\\If{$\\mathcal{A}^e=\\varnothing$ \\& $\\mathcal{B}^e=\\varnothing$ } \\Comment{None of the PU or ED class exceed latency threshold}\n            \t \t\\State Serve the HoL packet from class $B_h$.\n            \t\\ElsIf{$\\mathcal{A}^e=\\varnothing$ \\& $\\mathcal{B}^e \\neq \\varnothing$ } \\Comment{None of the PU class exceed latency threshold}\n            \t\t\\State Serve the HoL packet from class $\\bar{B}_h$.\n            \t\\Else \\Comment{Some of the PU class exceed latency threshold}\n            \t\t\\State Serve the HoL packet from class $\\mathcal{A}_h^e$.                \n        \t\t   \n        \t   \\EndIf\n        \t                   \t\\State \\Goto{marker1}.\n        \t       \\EndIf\n        \t       \\State $T_c = T_c+\\Delta T$.\n\n\t\t\\EndWhile\n\n\t\\end{algorithmic}\t\n\\end{algorithm*}\n\\clearpage\n\n\n\n\n\n \n  \n  \n  \n  \n  \n  \n  \n   \n\n\n\n\n\n\n\n\t\n\t\n\t\n\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t    \n        \t\t\n        \t\n        \t\t\n        \t\n\t\t    \n\t\t    \t\n\t\t\t\n\t\t\t\t\n        \t\n        \t\t\n        \t\n        \t\t\n        \t\n        \t\t\n            \n            \t\n                \n\t\t    \t\t\n        \t\t\n        \t\t\t\n        \t\t\n        \t\t\t\n        \t\t\n        \t\t\t\n        \t\t\n        \t\t\t\n        \t\t\n        \t\t\t\n            \t\n        \t\t\t\n        \t\t\n        \t\t\t\n        \t\t\n        \t\t\n        \t\n        \t        \t\n\n\t\t\n\n\t\n\n\n\n\n\n", "itemtype": "equation", "pos": 18390, "prevtext": "\nwhere $M_{\\text{pu}}^i(T_{\\text{s}})$ and $M_{\\text{ed}}^i(T_{\\text{s}})$ are the number of PU and ED packets from $i^{\\text{th}}$ sensor served in time $T_{\\text{s}}$. $R_{i}(T_{\\text{s}})$  denotes the number of runs of PU drops in time $T_{\\text{s}}$ and $r_{i,j}$ denotes the run-length of $j^{\\text{th}}$ PU drop for sensor $i$. $l_{\\text{pu}}^{i,j}$ and $l_{\\text{ed}}^{i,j}$ denote the latency of the $j^{\\text{th}}$ packet from $i^{\\text{th}}$ sensor of type PU and ED respectively. The parameters ${\\beta_{\\text{pu}}^i}$ and ${\\beta_{\\text{ed}}^i}$ denote the priority given to average PU and ED utility for $i^{\\text{th}}$ sensor. \n\n\\begin{figure}\n\\centering\n   \\includegraphics[width=\\columnwidth]{utilPUplot.eps}   \n\\caption{Utility function for PU packet.}\n\\label{puUtility} \n\\end{figure}\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\columnwidth]{utilEDplot.eps}\n\\caption{Utility function for ED packet.}\n \\label{edUtility} \n\\end{figure}\n\n\\subsection{Optimal scheduler} In the context of our problem, the optimal scheduler at PLC is the one that maximizes the proportionally fair utility metric, $\\mathcal{V}(\\mathcal{P})$. Mathematically this can be expressed as,\n\n", "index": 15, "text": "\\begin{align}\n\\operatorname*{max}_{\\mathcal{P}}~\\mathcal{V}(\\mathcal{P}) = \\prod_{i=1}^N{{\\mathcal{U}_{\\text{pu}}^i}}^{{\\beta_{\\text{pu}}^i}}(\\mathcal{P})*{{\\mathcal{U}_{\\text{ed}}^i}}^{{\\beta_{\\text{ed}}^i}}(\\mathcal{P}). \n\\label{optimProb}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\operatorname*{max}_{\\mathcal{P}}~{}\\mathcal{V}(\\mathcal{P})=%&#10;\\prod_{i=1}^{N}{{\\mathcal{U}_{\\text{pu}}^{i}}}^{{\\beta_{\\text{pu}}^{i}}}(%&#10;\\mathcal{P})*{{\\mathcal{U}_{\\text{ed}}^{i}}}^{{\\beta_{\\text{ed}}^{i}}}(%&#10;\\mathcal{P}).\" display=\"inline\"><mrow><mrow><mrow><mrow><mpadded width=\"+3.3pt\"><munder><mo movablelimits=\"false\">max</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi></munder></mpadded><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb1</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><mrow><mrow><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>pu</mtext><mi>i</mi><none/><msubsup><mi>\u03b2</mi><mtext>pu</mtext><mi>i</mi></msubsup></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>*</mo><mmultiscripts><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb0</mi><mtext>ed</mtext><mi>i</mi><none/><msubsup><mi>\u03b2</mi><mtext>ed</mtext><mi>i</mi></msubsup></mmultiscripts></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}]