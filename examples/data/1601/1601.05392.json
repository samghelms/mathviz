[{"file": "1601.05392.tex", "nexttext": "\nwhere $\\mathcal V\\in\\mathcal D$ is an arbitrary volume, $\\partial \\mathcal V$ is its boundary, and $d\\mathbf S$ is the differential area vector pointing out of the volume.\n\nIn the pure advection problem with a predetermined velocity field the specific values of the fluid densities, $\\rho_A$ and $\\rho_B$ are immaterial, that is, the solution does not depend on them. To remove these insignificant parameters from the problem, we define the indicator field,\n\n", "itemtype": "equation", "pos": 8410, "prevtext": "\n\n\n\n\n\\title{A Computational Method for Sharp Interface Advection}\n\n\\author{\nJohan Roenby$^{1}$, Henrik Bredmose$^{2}$ and Hrvoje Jasak$^{3,4}$}\n\n\n\\address{$^{1}$DHI, Department of Ports \\& Offshore Technology, Agern\nAll\\'{e} 5, 2970 H\\o rsholm, Denmark\\\\\n$^{2}$Department of Wind Energy, Technical University of Denmark, 2800 Kgs. Lynbgy, Denmark\\\\\n$^{3}$University of Zagreb, Faculty of Mechanical Engineering and Naval Architecture, Ivana Lu\\v{c}i\\'{c}a 5, Zagreb, Croatia\\\\\n$^{4}$Wikki Ltd, 459 Southbank House, SE1 7SJ, London, United Kingdom}\n\n\n\\subject{Computational Fluid Dynamics, Multiphase flows, Numerical methods, Two phase flows, Free surface flows}\n\n\n\\keywords{Interfacial flows, Volume of Fluid Method, Unstructured meshes, IsoAdvector, OpenFOAM\\textregistered}\n\n\n\\corres{Johan Roenby\\\\\n\\email{jro@dhigroup.com}}\n\n\n\\begin{abstract}\nWe devise a numerical method for passive advection of a surface, such as the interface between two incompressible fluids, across a computational mesh. The method is called isoAdvector, and is developed for general meshes consisting of arbitrary polyhedral cells. The algorithm is based on the volume of fluid (VOF) idea of calculating the volume of one of the fluids transported across the mesh faces during a time step. The novelty of the isoAdvector concept consists in two parts: First, we exploit an isosurface concept for modelling the interface inside cells in a geometric surface reconstruction step. Second, from the reconstructed surface, we model the motion of the face-interface intersection line for a general polygonal face to obtain the time evolution \\emph{within} a time step of the submerged face area. Integrating this submerged area over the time step leads to an accurate estimate for the total volume of fluid transported across the face. The method was tested on simple 2D and 3D interface advection problems both on structured and unstructured meshes. The results are very satisfactory both in terms of volume conservation, boundedness, surface sharpness, and efficiency. The isoAdvector method was implemented as an OpenFOAM\\textregistered{} extension and is published as open source.\n\\end{abstract}\n\n\n\n\\begin{fmtext}\n{}\n\\end{fmtext}\n\n\n\n\\maketitle\n\n\n\n\\section{Introduction}\nIn this paper we address the numerical challenge of advancing a surface moving in a prescribed velocity field. We will refer to this as the interface advection problem, since the surface often constitutes an interface e.g. between two fluids. Simple as the problem may appear, there is a large variety of problems in science, engineering, and industry where its solutions are far from trivial. Our motivation for addressing this problem is rooted in our usage of Computational Fluid Dynamics (CFD) as a practical engineering tool for calculating wave loads on coastal and marine structures. Whether it is an offshore wind turbine foundation, or an oil \\& gas platform, accurate estimation of the peak loads from violent breaking waves is paramount for the correct dimensioning of the structure. In our view, CFD has a large unexploited potential to improve wave load estimates, and to reduce both cost and risks in the design phase of coastal and offshore structures. \n\nDue to the omnipresence of interfacial flows, the list of areas that may benefit from improved solution methods to the interface advection problem is almost endless. Some examples are bubble column reactors, oil-gas mixtures in pipelines, inkjet printing, automotive aquaplaning, ship manoeuvring, tank sloshing, dam breaks, metal casting processes, and hydraulic jumps.\n\nDuring the past 40-50 years both Lagrangian and Eulerian strategies have been employed to develop a wide range of methods for advecting a sharp interface\\cite{tryggvason_direct_2011}. We have been unable to find a recent review article dedicated to this vibrant research field. Today most CFD codes for practical engineering calculations use variants of the \\emph{Volume-of-Fluid (VOF)} method for the interface advection step in their interfacial flow solvers. This includes current versions of ANSYS Fluent\\textregistered, STAR-CCM+\\textregistered, Gerris\\cite{popinet_gerris:_2003}, OpenFOAM\\textregistered \\cite{OpenFoam,weller_tensorial_1998} and many others. In the VOF methodology the interface is implicitly represented via the \\emph{volume fractions} of one of the fluids in computational cells. The advection is done by redistributing the content of this fluid between adjacent cells by moving it across the mesh faces. Since the first VOF methods appeared in literature\\cite{hirt_volume_1981} a large variety of VOF schemes have been developed. They may be divided into two categories: \\emph{Geometric} methods involving an explicit reconstruction of the interface from the volume fraction data, and \\emph{algebraic} methods making no such attempt. Algebraic VOF schemes are typically much simpler to implement, more efficient, and are not restricted to structured meshes. They are, however, founded on much more heuristic considerations and are not as accurate as the geometric VOF schemes\\cite{deshpande_evaluating_2012}. Geometric VOF schemes, on the other hand, involve complex geometric operations making their implementation cumbersome and their execution slow. Geometric VOF methods for unstructured meshes is an active area of research\\cite{ahn_multi-material_2007, hernandez_new_2008, lopez_new_2008, ivey_conservative_2012, maric_vofoam_2013, xie_efficient_2014}. \n\nOur ambition in the development of the isoAdvector algorithm is to develop a VOF based interface advection method that works on general meshes, retains the accuracy of the geometric schemes by explicitly approximating the interface, and yet keeps the geometric operations at a minimum in order to obtain acceptable calculation times. An efficient VOF scheme yielding accurate results even on automatically generated unstructured meshes of  complex geometries has a huge potential for speeding up the simulation process and making CFD an integrated part of design processes involving interfacial flows.\n\nIn the remainder of this section we give an introduction to the interface advection problem and its formulation in the VOF framework. In Section \\ref{sec:advMeth} we present the new ideas and concepts of the isoAdvector method and give an overview of the steps involved in the numerical procedure. The implementation details and considerations involved in each step are described at length in Section~\\ref{sec:implementation}. In Section~\\ref{sec:results} we demonstrate the performance of the new method with a series of simple test cases. Finally, in Section~\\ref{sec:conclusion} we summarize our findings.\n\n\n\n\\subsection{VOF formulation of the interface advection problem}\nWe consider a computational domain $\\mathcal D\\in \\mathbb{R}^3$ in which a surface $\\mathcal S$ is embedded. The surface may consist of any number of closed surfaces and may also extend to the boundaries of the domain. We will think of the surface as the interface between two incompressible, immiscible fluids denoted by A and B occupying the two closed regions $\\mathcal A$ and $\\mathcal B$, separated by $\\mathcal S$.\n\nThe fluid particles are assumed to be passively advected in a continuous, solenoidal velocity field, $\\mathbf u(\\mathbf x,t)$, which is defined in the whole domain. In practical engineering applications involving incompressible two-phase flows the time evolution of the velocity field is governed by the Navier-Stokes equations for $\\mathbf u$ coupled with a Poisson equation for the pressure, $p$. This system of equations must be solved simultaneously with the interface advection problem. In this work, we focus entirely on the interface advection problem, thus assuming $\\mathbf u$ to be known in advance. \n\nWe will now represent the surface $\\mathcal S(t)$ in terms of a density field, $\\rho(\\mathbf x,t)$, which takes one constant value, $\\rho_A$, everywhere in $\\mathcal A$ and another constant value, $\\rho_B$, everywhere in $\\mathcal B$. The density field thus has a discontinuity at the interface $\\mathcal S$.\\footnote{On the surface $\\mathcal S$ one could set $\\rho = \\frac12(\\rho_A+\\rho_B)$ for $\\rho$ to be defined everywhere. However, since $\\mathcal S$ has zero volume, the value of $\\rho$ on $\\mathcal S$ is immaterial.} The evolution of the surface is then determined by the integral form of the continuity equation,\n\n", "index": 1, "text": "\\begin{equation}\\label{eq:intgralContEqn}\n\t\\frac{d \\ }{dt}\\int_{\\mathcal V} \\rho(\\mathbf x,t) dV + \\int_{\\partial V} \\rho(\\mathbf x,t) \\mathbf u(\\mathbf x,t)\\cdot d\\mathbf S = 0,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\frac{d\\ }{dt}\\int_{\\mathcal{V}}\\rho(\\mathbf{x},t)dV+\\int_{\\partial V}\\rho(%&#10;\\mathbf{x},t)\\mathbf{u}(\\mathbf{x},t)\\cdot d\\mathbf{S}=0,\" display=\"block\"><mrow><mrow><mrow><mrow><mfrac><mpadded width=\"+5pt\"><mi>d</mi></mpadded><mrow><mi>d</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac><mo>\u2062</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcb1</mi></msub><mrow><mi>\u03c1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>V</mi></mrow></mrow></mrow></mrow><mo>+</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>V</mi></mrow></msub><mrow><mrow><mi>\u03c1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow></mrow></mrow><mo>=</mo><mn>0</mn></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhich is $1$ if $\\mathbf x\\in\\mathcal A$ and $0$ if $\\mathbf x\\in\\mathcal B$. \n\nWe now discretise the computational domain by conceptually dividing it into a large number of control volumes, or \\emph{cells}, $\\mathcal C_i$, for $i=1,...,N_C$. The shared surface of two adjacent cells is called an \\emph{internal face}, while the surface a boundary cell shares with the domain boundary is called a \\emph{boundary face}. All faces are labelled with integers $j = 1,...,N_F$, and the surface of face $j$ is denoted $\\mathcal F_j$. Thus the boundary of the cell $i$, may be represented by a list, $B_i$, of all the labels of faces belonging to $\\partial \\mathcal C_i$. \n\nWith these definitions in place, we can now substitute \\eqref{eq:indicatorField} into \\eqref{eq:intgralContEqn} with cell $i$ as the volume of integration,\n\n", "itemtype": "equation", "pos": 9062, "prevtext": "\nwhere $\\mathcal V\\in\\mathcal D$ is an arbitrary volume, $\\partial \\mathcal V$ is its boundary, and $d\\mathbf S$ is the differential area vector pointing out of the volume.\n\nIn the pure advection problem with a predetermined velocity field the specific values of the fluid densities, $\\rho_A$ and $\\rho_B$ are immaterial, that is, the solution does not depend on them. To remove these insignificant parameters from the problem, we define the indicator field,\n\n", "index": 3, "text": "\\begin{equation}\\label{eq:indicatorField}\n\t\\hat\\rho(\\mathbf x,t) \\equiv \\frac{\\rho(\\mathbf x,t)-\\rho_B}{\\rho_A-\\rho_B},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\hat{\\rho}(\\mathbf{x},t)\\equiv\\frac{\\rho(\\mathbf{x},t)-\\rho_{B}}{\\rho_{A}-\\rho%&#10;_{B}},\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mfrac><mrow><mrow><mi>\u03c1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msub><mi>\u03c1</mi><mi>B</mi></msub></mrow><mrow><msub><mi>\u03c1</mi><mi>A</mi></msub><mo>-</mo><msub><mi>\u03c1</mi><mi>B</mi></msub></mrow></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nBecause face $j$ has its own orientation determining the direction of $d\\mathbf S$, we have introduced the auxiliary factor $\\sigma_{ij} = +1$ or $-1$ such that $\\sigma_{ij} d\\mathbf S$ points out of cell $i$ for face $j$.\n\nThe natural next step is to define the volume fraction of fluid A in cell $i$, \n\n", "itemtype": "equation", "pos": 10020, "prevtext": "\nwhich is $1$ if $\\mathbf x\\in\\mathcal A$ and $0$ if $\\mathbf x\\in\\mathcal B$. \n\nWe now discretise the computational domain by conceptually dividing it into a large number of control volumes, or \\emph{cells}, $\\mathcal C_i$, for $i=1,...,N_C$. The shared surface of two adjacent cells is called an \\emph{internal face}, while the surface a boundary cell shares with the domain boundary is called a \\emph{boundary face}. All faces are labelled with integers $j = 1,...,N_F$, and the surface of face $j$ is denoted $\\mathcal F_j$. Thus the boundary of the cell $i$, may be represented by a list, $B_i$, of all the labels of faces belonging to $\\partial \\mathcal C_i$. \n\nWith these definitions in place, we can now substitute \\eqref{eq:indicatorField} into \\eqref{eq:intgralContEqn} with cell $i$ as the volume of integration,\n\n", "index": 5, "text": "\\begin{equation}\\label{eq:CVintgratedContEqn}\n\t\\frac{d \\ }{dt}\\int_{\\mathcal C_i} \\hat\\rho(\\mathbf x,t) dV + \\sum_{j\\in B_i}\\sigma_{ij}\\int_{\\mathcal F_j} \\hat\\rho(\\mathbf x,t) \\mathbf u(\\mathbf x,t)\\cdot d\\mathbf S = 0.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\frac{d\\ }{dt}\\int_{\\mathcal{C}_{i}}\\hat{\\rho}(\\mathbf{x},t)dV+\\sum_{j\\in B_{i%&#10;}}\\sigma_{ij}\\int_{\\mathcal{F}_{j}}\\hat{\\rho}(\\mathbf{x},t)\\mathbf{u}(\\mathbf{%&#10;x},t)\\cdot d\\mathbf{S}=0.\" display=\"block\"><mrow><mrow><mrow><mrow><mfrac><mpadded width=\"+5pt\"><mi>d</mi></mpadded><mrow><mi>d</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac><mo>\u2062</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>i</mi></msub></msub><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>V</mi></mrow></mrow></mrow></mrow><mo>+</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>\u2208</mo><msub><mi>B</mi><mi>i</mi></msub></mrow></munder><mrow><msub><mi>\u03c3</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow></mrow></mrow></mrow></mrow><mo>=</mo><mn>0</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhere $V_i$ is the volume of cell $i$. Substituting \\eqref{eq:volFracDef} into \\eqref{eq:CVintgratedContEqn}, and formally integrating \\eqref{eq:CVintgratedContEqn} from time $t$ to time $t+\\Delta t$, we obtain the following equation for the updated volume fraction of cell $i$,\n\n", "itemtype": "equation", "pos": 10560, "prevtext": "\nBecause face $j$ has its own orientation determining the direction of $d\\mathbf S$, we have introduced the auxiliary factor $\\sigma_{ij} = +1$ or $-1$ such that $\\sigma_{ij} d\\mathbf S$ points out of cell $i$ for face $j$.\n\nThe natural next step is to define the volume fraction of fluid A in cell $i$, \n\n", "index": 7, "text": "\\begin{equation}\\label{eq:volFracDef}\n\t\\alpha_i(t) \\equiv \\frac1{V_i}\\int_{\\mathcal C_i} \\hat \\rho(\\mathbf x,t) dV,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\alpha_{i}(t)\\equiv\\frac{1}{V_{i}}\\int_{\\mathcal{C}_{i}}\\hat{\\rho}(\\mathbf{x},%&#10;t)dV,\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><mfrac><mn>1</mn><msub><mi>V</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>i</mi></msub></msub><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>V</mi></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nWe stress that this equation is exact with no numerical approximations introduced yet. It is the fundamental equation from which we will derive our new interface advection method. The time integral on the right hand side is the total volume of fluid A transported across face $j$ during the time interval from time $t$ to $t+\\Delta t$. It is the fundamental quantity that we must estimate in order to advance $\\alpha_i$, and hence implicitly the surface $\\mathcal S$, in time. We will denote this quantity\n\n", "itemtype": "equation", "pos": 10970, "prevtext": "\nwhere $V_i$ is the volume of cell $i$. Substituting \\eqref{eq:volFracDef} into \\eqref{eq:CVintgratedContEqn}, and formally integrating \\eqref{eq:CVintgratedContEqn} from time $t$ to time $t+\\Delta t$, we obtain the following equation for the updated volume fraction of cell $i$,\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:newAlpha}\n\t\\alpha_i(t+\\Delta t) = \\alpha_i(t) - \\frac1{V_i}\\sum_{j\\in B_i}\\sigma_{ij}\\int_{t}^{t+\\Delta t}\\int_{\\mathcal F_j} \\hat\\rho(\\mathbf x,\\tau) \\mathbf u(\\mathbf x,\\tau)\\cdot d\\mathbf S d\\tau.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\alpha_{i}(t+\\Delta t)=\\alpha_{i}(t)-\\frac{1}{V_{i}}\\sum_{j\\in B_{i}}\\sigma_{%&#10;ij}\\int_{t}^{t+\\Delta t}\\int_{\\mathcal{F}_{j}}\\hat{\\rho}(\\mathbf{x},\\tau)%&#10;\\mathbf{u}(\\mathbf{x},\\tau)\\cdot d\\mathbf{S}d\\tau.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mfrac><mn>1</mn><msub><mi>V</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>\u2208</mo><msub><mi>B</mi><mi>i</mi></msub></mrow></munder><mrow><msub><mi>\u03c3</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></msubsup><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mrow><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nOur fundamental equation \\eqref{eq:newAlpha} can then be formulated as\n\n", "itemtype": "equation", "pos": 11717, "prevtext": "\nWe stress that this equation is exact with no numerical approximations introduced yet. It is the fundamental equation from which we will derive our new interface advection method. The time integral on the right hand side is the total volume of fluid A transported across face $j$ during the time interval from time $t$ to $t+\\Delta t$. It is the fundamental quantity that we must estimate in order to advance $\\alpha_i$, and hence implicitly the surface $\\mathcal S$, in time. We will denote this quantity\n\n", "index": 11, "text": "\\begin{equation}\\label{eq:DeltaVDef}\n\t\\Delta V_j(t,\\Delta t) \\equiv \\int_{t}^{t+\\Delta t}\\int_{\\mathcal F_j} \\hat\\rho(\\mathbf x,\\tau) \\mathbf u(\\mathbf x,\\tau)\\cdot d\\mathbf S d\\tau.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\Delta V_{j}(t,\\Delta t)\\equiv\\int_{t}^{t+\\Delta t}\\int_{\\mathcal{F}_{j}}\\hat{%&#10;\\rho}(\\mathbf{x},\\tau)\\mathbf{u}(\\mathbf{x},\\tau)\\cdot d\\mathbf{S}d\\tau.\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>V</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></msubsup><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mrow><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\n\nBefore we move on to present the basic ideas of the isoAdvector method we will need to consider how the velocity field is represented. In the finite volume treatment of the fluid equations of motion the natural representation of the velocity field is in terms of cell averaged values\n\n", "itemtype": "equation", "pos": 11986, "prevtext": "\nOur fundamental equation \\eqref{eq:newAlpha} can then be formulated as\n\n", "index": 13, "text": "\\begin{equation}\\label{eq:finalAlpha}\n\t\\alpha_i(t+\\Delta t) = \\alpha_i(t) - \\frac1{V_i}\\sum_{j\\in B_i}\\sigma_{ij}\\Delta V_j(t,\\Delta t).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\alpha_{i}(t+\\Delta t)=\\alpha_{i}(t)-\\frac{1}{V_{i}}\\sum_{j\\in B_{i}}\\sigma_{%&#10;ij}\\Delta V_{j}(t,\\Delta t).\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mfrac><mn>1</mn><msub><mi>V</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>\u2208</mo><msub><mi>B</mi><mi>i</mi></msub></mrow></munder><mrow><msub><mi>\u03c3</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>V</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nSince the convective terms in the governing fluid equations give the transport of mass, momentum, etc. across cell faces, another important velocity field representation are the volumetric fluxes across mesh faces,\n\n", "itemtype": "equation", "pos": 12423, "prevtext": "\n\nBefore we move on to present the basic ideas of the isoAdvector method we will need to consider how the velocity field is represented. In the finite volume treatment of the fluid equations of motion the natural representation of the velocity field is in terms of cell averaged values\n\n", "index": 15, "text": "\\begin{equation}\n\t\\mathbf u_i(t) \\equiv \\int_{\\mathcal C_i} \\mathbf u(\\mathbf x, t) dV.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{u}_{i}(t)\\equiv\\int_{\\mathcal{C}_{i}}\\mathbf{u}(\\mathbf{x},t)dV.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\ud835\udc2e</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>i</mi></msub></msub><mrow><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>V</mi></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nThe question we will try to answer in the following can now be formulated as follows:\n\n\\emph{How do we most accurately and efficiently exploit the available information at time $t$, i.e. the volume fractions, $\\alpha_i$, and the velocity data, $\\mathbf u_i$ and $\\phi_j$, to estimate the fluid A volume transport, $\\Delta V_j(t,\\Delta t)$, across all faces during $[t,t+\\Delta t]$?}\n\n\n\n\\section{The isoAdvector concept}\\label{sec:advMeth}\nWe will now present the general ideas behind the isoAdvector method starting with the interface representation using isosurfaces, then introducing the concept of a face-interface intersection line moving across a face, and finally giving an overview of the steps involved in the numerical procedure. For the sake of clarity we focus on ideas in this section and postpone the detailed description of the implementation to Section \\ref{sec:implementation}.\n\n\\subsection{The interface reconstruction step}\\label{ssec:IntRecon}\nThe integral in \\eqref{eq:DeltaVDef} is highly dependent on the local distribution of fluid A and B inside cell $i$ and inside its neighbour cells from which it receives fluid during the time step. However, the volume fractions hold no information about the distribution of the two fluids inside the cells. We must therefore come up with a subgrid model for this ``intracellular'' distribution from the given volume fraction data. If the volume fraction data is ``sharp'' only cells very close to the interface will have volume fractions significantly different from $0$ and $1$. Then if cell $i$ is on the interface, its neighbours on one side will contain (almost) only fluid A, while the neighbour cells on the other side will contain (almost) only fluid B. In words, we want our subgrid model to ``detect'' this and place the fluid A content of cell $i$ close to the neighbours containing fluid A (which is equivalent to its fluid B content being placed near the neighbours containing fluid B). The implicit assumption made in this model is that the interface is sufficiently well resolved by the mesh such that the two fluids occur in lumps somewhat larger than the cell size. Whenever this is satisfied an isosurface calculation will provide exactly the required ``lump'' information. \n\nThe idea of using an isosurface numerically calculated from the volume fractions to represent the interface is inspired by our use of visualisation software, such as ParaView\\textregistered\\cite{ParaView}, for visualising surfaces. Numerically calculated isosurfaces are topologically consistent continuous surfaces and straightforward to calculate on arbitrary polyhedral meshes. The numerical representation of an isosurface in a polyhedral cell is a list of the points where the isosurface cuts the cell edges. See red points in Fig.~\\ref{fig:isoface} for an illustration. This point list represents a face which cuts the cell into two polyhedral subcells with one completely immersed in fluid A and the other completely immersed in fluid B. We will call such a face an \\emph{isoface}. See the green patch in Fig.~\\ref{fig:isoface} for an example.\n\nWhen calculating an isosurface from the volume fraction data, we have the freedom of choosing an isovalue between 0 and 1. Which isovalue should we choose? For surface visualisation from volume fraction data we usually plot the 0.5-isosurface. This, however, is not a good choice for the surface reconstruction step in an interface advection algorithm because the isoface in cell $i$ with isovalue 0.5 does not in general cut it into two subcells of the volumetric proportions dictated by the volume fraction, $\\alpha_i$. It may for instance occur that the cell has $\\alpha_i = 0.8$, and yet is not even cut by the $0.5$-isosurface. Thus, a surface reconstruction model based on the $0.5$-isosurface does not say anything about how the $80\\%$ fluid A and $20\\%$ fluid B is distributed inside cell $i$. There will, however, exist an isoface with another isovalue, which will cut cell $i$ into subcells of the right volumetric proportions. An important component of our proposed scheme is an efficient method for finding this isovalue for a surface cell (see Section \\ref{sec:implementation} for details). \n\nWe note that with the use of different isovalues in different surface cells the union of isofaces is no longer a continuous surface as it would be if the same isovalue was used in adjacent cells.\n\n\\subsection{The advection step}\nMost Navier-Stokes solvers for interface flows use a segregated solution approach in which the coupled system of equations governing the flow are solved in sequence within a time step. This means that at the point where the interface is to be advected from time $t$ to time $t+\\Delta t$, we only have information about the velocity field up to time $t$. But as seen in the integrand in \\eqref{eq:newAlpha}, calculation of the updated $\\alpha_i$ requires information about the velocity field on the interval $[t,t+\\Delta t]$. We must therefore estimate the evolution of the velocity field during the time step. The simplest such estimate is to regard the velocity field as constant (in time) during the whole time step. With this assumption we write $\\mathbf u(\\mathbf x,\\tau) \\approx \\mathbf u(\\mathbf x,t)$ in \\eqref{eq:DeltaVDef}. Another assumption we will make in \\eqref{eq:DeltaVDef} is that $\\mathbf u$ on the face $\\mathcal F_j$ dotted with the differential face normal vector, $d\\mathbf S$, can be approximated in terms of the volumetric face flux, $\\phi_j$ (defined in \\eqref{eq:fluxdef}), as follows,\n\n", "itemtype": "equation", "pos": 12741, "prevtext": "\nSince the convective terms in the governing fluid equations give the transport of mass, momentum, etc. across cell faces, another important velocity field representation are the volumetric fluxes across mesh faces,\n\n", "index": 17, "text": "\\begin{equation}\\label{eq:fluxdef}\n\t\\phi_j(t) \\equiv \\int_{\\mathcal F_j} \\mathbf u(\\mathbf x,t)\\cdot d\\mathbf S.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\phi_{j}(t)\\equiv\\int_{\\mathcal{F}_{j}}\\mathbf{u}(\\mathbf{x},t)\\cdot d\\mathbf{%&#10;S}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mrow><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhere the face normal\n\n", "itemtype": "equation", "pos": 18423, "prevtext": "\nThe question we will try to answer in the following can now be formulated as follows:\n\n\\emph{How do we most accurately and efficiently exploit the available information at time $t$, i.e. the volume fractions, $\\alpha_i$, and the velocity data, $\\mathbf u_i$ and $\\phi_j$, to estimate the fluid A volume transport, $\\Delta V_j(t,\\Delta t)$, across all faces during $[t,t+\\Delta t]$?}\n\n\n\n\\section{The isoAdvector concept}\\label{sec:advMeth}\nWe will now present the general ideas behind the isoAdvector method starting with the interface representation using isosurfaces, then introducing the concept of a face-interface intersection line moving across a face, and finally giving an overview of the steps involved in the numerical procedure. For the sake of clarity we focus on ideas in this section and postpone the detailed description of the implementation to Section \\ref{sec:implementation}.\n\n\\subsection{The interface reconstruction step}\\label{ssec:IntRecon}\nThe integral in \\eqref{eq:DeltaVDef} is highly dependent on the local distribution of fluid A and B inside cell $i$ and inside its neighbour cells from which it receives fluid during the time step. However, the volume fractions hold no information about the distribution of the two fluids inside the cells. We must therefore come up with a subgrid model for this ``intracellular'' distribution from the given volume fraction data. If the volume fraction data is ``sharp'' only cells very close to the interface will have volume fractions significantly different from $0$ and $1$. Then if cell $i$ is on the interface, its neighbours on one side will contain (almost) only fluid A, while the neighbour cells on the other side will contain (almost) only fluid B. In words, we want our subgrid model to ``detect'' this and place the fluid A content of cell $i$ close to the neighbours containing fluid A (which is equivalent to its fluid B content being placed near the neighbours containing fluid B). The implicit assumption made in this model is that the interface is sufficiently well resolved by the mesh such that the two fluids occur in lumps somewhat larger than the cell size. Whenever this is satisfied an isosurface calculation will provide exactly the required ``lump'' information. \n\nThe idea of using an isosurface numerically calculated from the volume fractions to represent the interface is inspired by our use of visualisation software, such as ParaView\\textregistered\\cite{ParaView}, for visualising surfaces. Numerically calculated isosurfaces are topologically consistent continuous surfaces and straightforward to calculate on arbitrary polyhedral meshes. The numerical representation of an isosurface in a polyhedral cell is a list of the points where the isosurface cuts the cell edges. See red points in Fig.~\\ref{fig:isoface} for an illustration. This point list represents a face which cuts the cell into two polyhedral subcells with one completely immersed in fluid A and the other completely immersed in fluid B. We will call such a face an \\emph{isoface}. See the green patch in Fig.~\\ref{fig:isoface} for an example.\n\nWhen calculating an isosurface from the volume fraction data, we have the freedom of choosing an isovalue between 0 and 1. Which isovalue should we choose? For surface visualisation from volume fraction data we usually plot the 0.5-isosurface. This, however, is not a good choice for the surface reconstruction step in an interface advection algorithm because the isoface in cell $i$ with isovalue 0.5 does not in general cut it into two subcells of the volumetric proportions dictated by the volume fraction, $\\alpha_i$. It may for instance occur that the cell has $\\alpha_i = 0.8$, and yet is not even cut by the $0.5$-isosurface. Thus, a surface reconstruction model based on the $0.5$-isosurface does not say anything about how the $80\\%$ fluid A and $20\\%$ fluid B is distributed inside cell $i$. There will, however, exist an isoface with another isovalue, which will cut cell $i$ into subcells of the right volumetric proportions. An important component of our proposed scheme is an efficient method for finding this isovalue for a surface cell (see Section \\ref{sec:implementation} for details). \n\nWe note that with the use of different isovalues in different surface cells the union of isofaces is no longer a continuous surface as it would be if the same isovalue was used in adjacent cells.\n\n\\subsection{The advection step}\nMost Navier-Stokes solvers for interface flows use a segregated solution approach in which the coupled system of equations governing the flow are solved in sequence within a time step. This means that at the point where the interface is to be advected from time $t$ to time $t+\\Delta t$, we only have information about the velocity field up to time $t$. But as seen in the integrand in \\eqref{eq:newAlpha}, calculation of the updated $\\alpha_i$ requires information about the velocity field on the interval $[t,t+\\Delta t]$. We must therefore estimate the evolution of the velocity field during the time step. The simplest such estimate is to regard the velocity field as constant (in time) during the whole time step. With this assumption we write $\\mathbf u(\\mathbf x,\\tau) \\approx \\mathbf u(\\mathbf x,t)$ in \\eqref{eq:DeltaVDef}. Another assumption we will make in \\eqref{eq:DeltaVDef} is that $\\mathbf u$ on the face $\\mathcal F_j$ dotted with the differential face normal vector, $d\\mathbf S$, can be approximated in terms of the volumetric face flux, $\\phi_j$ (defined in \\eqref{eq:fluxdef}), as follows,\n\n", "index": 19, "text": "\\begin{equation}\n\t\\mathbf u(\\mathbf x,t)\\cdot d \\mathbf S \\approx \\frac{\\phi_j(t)}{|\\mathbf S_j|} dS \\textrm{ for } \\mathbf x\\in\\mathcal F_j, \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{u}(\\mathbf{x},t)\\cdot d\\mathbf{S}\\approx\\frac{\\phi_{j}(t)}{|\\mathbf{S}%&#10;_{j}|}dS\\textrm{ for }\\mathbf{x}\\in\\mathcal{F}_{j},\" display=\"block\"><mrow><mrow><mrow><mrow><mrow><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mi>d</mi></mrow><mo>\u2062</mo><mi>\ud835\udc12</mi></mrow><mo>\u2248</mo><mrow><mfrac><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>\ud835\udc12</mi><mi>j</mi></msub><mo stretchy=\"false\">|</mo></mrow></mfrac><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mi>S</mi><mo>\u2062</mo><mtext>\u00a0for\u00a0</mtext><mo>\u2062</mo><mi>\ud835\udc31</mi></mrow><mo>\u2208</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nSubstituting this into \\eqref{eq:DeltaVDef}, we obtain\n\n", "itemtype": "equation", "pos": 18603, "prevtext": "\nwhere the face normal\n\n", "index": 21, "text": "\\begin{equation}\n\t\\mathbf S_j \\equiv \\int_{\\mathcal F_j} d\\mathbf S.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{S}_{j}\\equiv\\int_{\\mathcal{F}_{j}}d\\mathbf{S}.\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc12</mi><mi>j</mi></msub><mo>\u2261</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mo>\ud835\udc51</mo><mi>\ud835\udc12</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nThe remaining surface integral in \\eqref{eq:DeltaVApprox1} is then simply the instantaneous area of face $j$ submerged in fluid A, which will be denoted\n\n", "itemtype": "equation", "pos": 18742, "prevtext": "\nSubstituting this into \\eqref{eq:DeltaVDef}, we obtain\n\n", "index": 23, "text": "\\begin{equation}\\label{eq:DeltaVApprox1}\n\t\\Delta V_j(t,\\Delta t) \\approx \\frac{\\phi_j(t)}{|\\mathbf S_j|}\\int_{t}^{t+\\Delta t}\\int_{\\mathcal F_j} \\hat\\rho(\\mathbf x,\\tau) dS d\\tau.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\Delta V_{j}(t,\\Delta t)\\approx\\frac{\\phi_{j}(t)}{|\\mathbf{S}_{j}|}\\int_{t}^{t%&#10;+\\Delta t}\\int_{\\mathcal{F}_{j}}\\hat{\\rho}(\\mathbf{x},\\tau)dSd\\tau.\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>V</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2248</mo><mrow><mfrac><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>\ud835\udc12</mi><mi>j</mi></msub><mo stretchy=\"false\">|</mo></mrow></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></msubsup><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>S</mi></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nUsing this definition, we may now write \\eqref{eq:DeltaVApprox1} as\n\n", "itemtype": "equation", "pos": 19090, "prevtext": "\nThe remaining surface integral in \\eqref{eq:DeltaVApprox1} is then simply the instantaneous area of face $j$ submerged in fluid A, which will be denoted\n\n", "index": 25, "text": "\\begin{equation}\\label{eq:A_j(t)Def}\n\tA_j(t) \\equiv \\int_{\\mathcal F_j} \\hat\\rho(\\mathbf x,\\tau) dS = \\int_{\\mathcal F_j \\cap \\mathcal A(t)}  dS.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"A_{j}(t)\\equiv\\int_{\\mathcal{F}_{j}}\\hat{\\rho}(\\mathbf{x},\\tau)dS=\\int_{%&#10;\\mathcal{F}_{j}\\cap\\mathcal{A}(t)}dS.\" display=\"block\"><mrow><mrow><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub></msub><mrow><mover accent=\"true\"><mi>\u03c1</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>S</mi></mrow></mrow></mrow><mo>=</mo><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u2131</mi><mi>j</mi></msub><mo>\u2229</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msub><mrow><mo>\ud835\udc51</mo><mi>S</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nAn important point is that in the special case where the velocity field is constant both in space and time \\eqref{eq:DeltaVApprox2} is exact. Thus, if the cells become sufficiently small compared to the gradients of the velocity field, and the time steps become sufficiently small compared to the temporal variations in the velocity field, the error committed in the above approximation becomes negligible.\n\nAs is seen from \\eqref{eq:DeltaVApprox2} the challenge in constructing a VOF scheme is to estimate the  time evolution \\emph{within} a time step of the submerged (in fluid A) area of a face, and then integrate this area in time. The time scale on which $A_j(\\tau)$ changes is not dictated by the time scales of the flow, but by a complicated combination of the relative orientations of the face and interface, the direction of motion of the interface, and the shape of the face. As an example, consider an interface approaching a face to which it is parallel. In this case $A_j(\\tau)$ will be a discontinuous function of $\\tau$. This in turn makes $\\Delta V_j(t,\\Delta t)$ non-differentiable with respect to $\\Delta t$. The discontinuous and non-differentiable nature of these quantities is what makes the interface advection problem so difficult to attack with the traditional weaponry of numerical analysis, which assumes the existence of a Taylor expansion of the sought solution.\n\nIn the isoAdvector advection step, when we calculate $A_j(\\tau)$ for face $j$, our starting point is the isoface in the cell \\emph{upwind} of face $j$ at time $t$. The motion of this isoface \\emph{within} the time step $[t,t+\\Delta t]$ may be approximated by using the velocity data in the surrounding cells. Fig.~\\ref{fig:isofaceMotion} shows an example of how the isoface may appear at three times during the time step.\n\nKnowing the isoface position and orientation inside cell $i$ at any time within $[t,t+\\Delta t]$, we also know for its downwind face $j$ the \\emph{face-interface intersection line} (see blue lines in Fig.~\\ref{fig:isoface}) at any time during the interval. With this information, the time integral in \\eqref{eq:DeltaVApprox2} can be calculated to finally obtain our estimate of the total volume of fluid A transported across face $j$ during the time interval $[t,t+\\Delta t]$. \n\nWe stress that the fluid A transport across a face is only calculated once for each face and that for internal faces this value is used to update the volume fractions of both of the two cells sharing the face. This is what guarantees local conservation of each of the two fluids A and B.\n\n\\subsection{Algorithm overview}\\label{ssec:algorithm}\nWe here give an overview of the steps taken in the isoAdvector algorithm to advance the volume fractions from time $t$ to time $t+\\Delta t$:\n\n\\begin{description}\n   \\item[Step 1] For each face $j$ initialise with $\\Delta V_j = \\alpha_{\\textrm{upwind}(j)}\\phi_j\\Delta t$, where $\\alpha_{\\textrm{upwind}(j)}$ is the volume fraction of the cell upwind of face $j$.\n   \\item[Step 2] Find all \\emph{surface cells}, i.e. cells with $\\epsilon < \\alpha_i(t) < 1-\\epsilon$, where $\\epsilon$ is a user specified tolerance (we typically use $10^{-8}$).\n   \\item[Step 3] For each surface cell $i$ do the following:\n\n   \\begin{description}\n   \t\t\\item[3.1] Find its isoface, i.e. the isosurface inside the cell with isovalue such that it cuts the cell into the correct volumetric fractions, $\\alpha_i(t)$ and $1-\\alpha_i(t)$ (Details in \\ref{ssec:calcIsoface}).\\label{item:findIsoface}\n   \t\t\\item[3.2] Use the velocity field data to estimate the isoface motion during the time interval $[t,t+\\Delta t]$ (Details in \\ref{ssec:EstIsofaceMotion}).\\label{item:findIsofaceMotion}\n   \t\t\\item[3.3] For each \\emph{downwind} face $j$ of surface cell $i$, use the isoface and its motion to calculate the face-interface intersection line during the time interval $\\tau\\in[t,t+\\Delta t]$ (Details in \\ref{ssec:EvoOfFiil}).\\label{item:findFaceIsofaceIntersection}\n   \t\t\\item[3.4] For each \\emph{downwind} face $j$ of surface cell $i$, use the motion of its face-interface intersection line to calculate $\\Delta V_j(t,\\Delta t)$ from the time integral in \\eqref{eq:DeltaVApprox2}(Details in Section \\ref{ssec:timeIntSubArea}).\\label{item:integrateFaceIsofaceIntersection}\n\t\\end{description}\n\n\t\\item[Step 4] For each cell calculate $\\alpha_i(t+\\Delta t)$ by inserting the $\\Delta V_j$'s of its faces in \\eqref{eq:finalAlpha}.\\label{item:updateVOF}\n\t\\item[Step 5] For cells with $\\alpha_i(t+\\Delta t) < 0$ or $\\alpha_i(t+\\Delta t) > 1$ adjust the $\\Delta V_j$'s of its faces using a redistribution procedure and recalculate $\\alpha_i(t+\\Delta t)$ by inserting corrected $\\Delta V_j$'s in \\eqref{eq:finalAlpha}. This step also includes an optional clipping of any $\\alpha_i < 0$ or $\\alpha_i > 1$ to ensure strict boundedness before proceeding to next time step (Details in Section \\ref{ssec:bounding}).\\label{item:boundVOF}\n\\end{description}\n\n\n\n\n\\section{Implementation details}\\label{sec:implementation}\n\nIn this section we provide the implementation details of the procedure outlined in Section \\ref{ssec:algorithm}. We first note that the time step size may vary between time steps. The user can specify a target interface Courant number, Co, based on which the time step size is calculated at the beginning of each time step to ensure that Co is not exceeded in any surface cells.\n\nStep 1 in Section \\ref{ssec:algorithm}, where we initialise $\\Delta V_j$ with upwind values, and Step 2, where we find all surface cells with $\\epsilon < \\alpha_i < 1-\\epsilon$, need no further explanation. We will therefore jump to step 3, which contains the actual calculation of the volume transport across faces.\n\n\n\\subsection{Calculating the initial isoface in a surface cell}\\label{ssec:calcIsoface}\n\nThe first step in calculating the isosurface is to interpolate the volume fractions to the mesh points. The value in a mesh point will in general be a linear combination of the volume fractions in the cells sharing the mesh point. We have chosen to use inverse point-to-cell-centre interpolation but other options, such as cell volume weighting, are also possible. \n\nLet us denote the $N$ vertices of cell $i$ by $\\mathbf X_1,...,\\mathbf X_N$ and the corresponding interpolated volume fractions by $f_1,...,f_N$. The cell edges are straight lines between pairs of points in the vertex list. To construct the $f$-isoface for cell $i$ we go through all cell edges and cut them by linear interpolation of the edge vertex values: If the edge $(\\mathbf X_k, \\mathbf X_l)$ has values $f_k < f$ and $f < f_l$, the edge is cut at the point\n\n", "itemtype": "equation", "pos": 19319, "prevtext": "\nUsing this definition, we may now write \\eqref{eq:DeltaVApprox1} as\n\n", "index": 27, "text": "\\begin{equation}\\label{eq:DeltaVApprox2}\n\t\\Delta V_j(t,\\Delta t) \\approx \\frac{\\phi_j(t)}{|\\mathbf S_j|}\\int_{t}^{t+\\Delta t}A_j(\\tau)d\\tau.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"\\Delta V_{j}(t,\\Delta t)\\approx\\frac{\\phi_{j}(t)}{|\\mathbf{S}_{j}|}\\int_{t}^{t%&#10;+\\Delta t}A_{j}(\\tau)d\\tau.\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>V</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2248</mo><mrow><mfrac><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>\ud835\udc12</mi><mi>j</mi></msub><mo stretchy=\"false\">|</mo></mrow></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></msubsup><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nOnce all such edge cutting points have been found for cell $i$, they can be connected across faces to form the face-interface intersection lines, which can again be connected to form the isoface inside the cell. The isoface splits cell $i$ into a polyhedral cell, $\\mathcal A_i(f)$, entirely in fluid A, and another cell, $\\mathcal B_i(f)$, entirely in fluid B. We can calculate the volume of $\\mathcal A_i(f)$ relative to the cell volume,\n\n", "itemtype": "equation", "pos": 26108, "prevtext": "\nAn important point is that in the special case where the velocity field is constant both in space and time \\eqref{eq:DeltaVApprox2} is exact. Thus, if the cells become sufficiently small compared to the gradients of the velocity field, and the time steps become sufficiently small compared to the temporal variations in the velocity field, the error committed in the above approximation becomes negligible.\n\nAs is seen from \\eqref{eq:DeltaVApprox2} the challenge in constructing a VOF scheme is to estimate the  time evolution \\emph{within} a time step of the submerged (in fluid A) area of a face, and then integrate this area in time. The time scale on which $A_j(\\tau)$ changes is not dictated by the time scales of the flow, but by a complicated combination of the relative orientations of the face and interface, the direction of motion of the interface, and the shape of the face. As an example, consider an interface approaching a face to which it is parallel. In this case $A_j(\\tau)$ will be a discontinuous function of $\\tau$. This in turn makes $\\Delta V_j(t,\\Delta t)$ non-differentiable with respect to $\\Delta t$. The discontinuous and non-differentiable nature of these quantities is what makes the interface advection problem so difficult to attack with the traditional weaponry of numerical analysis, which assumes the existence of a Taylor expansion of the sought solution.\n\nIn the isoAdvector advection step, when we calculate $A_j(\\tau)$ for face $j$, our starting point is the isoface in the cell \\emph{upwind} of face $j$ at time $t$. The motion of this isoface \\emph{within} the time step $[t,t+\\Delta t]$ may be approximated by using the velocity data in the surrounding cells. Fig.~\\ref{fig:isofaceMotion} shows an example of how the isoface may appear at three times during the time step.\n\nKnowing the isoface position and orientation inside cell $i$ at any time within $[t,t+\\Delta t]$, we also know for its downwind face $j$ the \\emph{face-interface intersection line} (see blue lines in Fig.~\\ref{fig:isoface}) at any time during the interval. With this information, the time integral in \\eqref{eq:DeltaVApprox2} can be calculated to finally obtain our estimate of the total volume of fluid A transported across face $j$ during the time interval $[t,t+\\Delta t]$. \n\nWe stress that the fluid A transport across a face is only calculated once for each face and that for internal faces this value is used to update the volume fractions of both of the two cells sharing the face. This is what guarantees local conservation of each of the two fluids A and B.\n\n\\subsection{Algorithm overview}\\label{ssec:algorithm}\nWe here give an overview of the steps taken in the isoAdvector algorithm to advance the volume fractions from time $t$ to time $t+\\Delta t$:\n\n\\begin{description}\n   \\item[Step 1] For each face $j$ initialise with $\\Delta V_j = \\alpha_{\\textrm{upwind}(j)}\\phi_j\\Delta t$, where $\\alpha_{\\textrm{upwind}(j)}$ is the volume fraction of the cell upwind of face $j$.\n   \\item[Step 2] Find all \\emph{surface cells}, i.e. cells with $\\epsilon < \\alpha_i(t) < 1-\\epsilon$, where $\\epsilon$ is a user specified tolerance (we typically use $10^{-8}$).\n   \\item[Step 3] For each surface cell $i$ do the following:\n\n   \\begin{description}\n   \t\t\\item[3.1] Find its isoface, i.e. the isosurface inside the cell with isovalue such that it cuts the cell into the correct volumetric fractions, $\\alpha_i(t)$ and $1-\\alpha_i(t)$ (Details in \\ref{ssec:calcIsoface}).\\label{item:findIsoface}\n   \t\t\\item[3.2] Use the velocity field data to estimate the isoface motion during the time interval $[t,t+\\Delta t]$ (Details in \\ref{ssec:EstIsofaceMotion}).\\label{item:findIsofaceMotion}\n   \t\t\\item[3.3] For each \\emph{downwind} face $j$ of surface cell $i$, use the isoface and its motion to calculate the face-interface intersection line during the time interval $\\tau\\in[t,t+\\Delta t]$ (Details in \\ref{ssec:EvoOfFiil}).\\label{item:findFaceIsofaceIntersection}\n   \t\t\\item[3.4] For each \\emph{downwind} face $j$ of surface cell $i$, use the motion of its face-interface intersection line to calculate $\\Delta V_j(t,\\Delta t)$ from the time integral in \\eqref{eq:DeltaVApprox2}(Details in Section \\ref{ssec:timeIntSubArea}).\\label{item:integrateFaceIsofaceIntersection}\n\t\\end{description}\n\n\t\\item[Step 4] For each cell calculate $\\alpha_i(t+\\Delta t)$ by inserting the $\\Delta V_j$'s of its faces in \\eqref{eq:finalAlpha}.\\label{item:updateVOF}\n\t\\item[Step 5] For cells with $\\alpha_i(t+\\Delta t) < 0$ or $\\alpha_i(t+\\Delta t) > 1$ adjust the $\\Delta V_j$'s of its faces using a redistribution procedure and recalculate $\\alpha_i(t+\\Delta t)$ by inserting corrected $\\Delta V_j$'s in \\eqref{eq:finalAlpha}. This step also includes an optional clipping of any $\\alpha_i < 0$ or $\\alpha_i > 1$ to ensure strict boundedness before proceeding to next time step (Details in Section \\ref{ssec:bounding}).\\label{item:boundVOF}\n\\end{description}\n\n\n\n\n\\section{Implementation details}\\label{sec:implementation}\n\nIn this section we provide the implementation details of the procedure outlined in Section \\ref{ssec:algorithm}. We first note that the time step size may vary between time steps. The user can specify a target interface Courant number, Co, based on which the time step size is calculated at the beginning of each time step to ensure that Co is not exceeded in any surface cells.\n\nStep 1 in Section \\ref{ssec:algorithm}, where we initialise $\\Delta V_j$ with upwind values, and Step 2, where we find all surface cells with $\\epsilon < \\alpha_i < 1-\\epsilon$, need no further explanation. We will therefore jump to step 3, which contains the actual calculation of the volume transport across faces.\n\n\n\\subsection{Calculating the initial isoface in a surface cell}\\label{ssec:calcIsoface}\n\nThe first step in calculating the isosurface is to interpolate the volume fractions to the mesh points. The value in a mesh point will in general be a linear combination of the volume fractions in the cells sharing the mesh point. We have chosen to use inverse point-to-cell-centre interpolation but other options, such as cell volume weighting, are also possible. \n\nLet us denote the $N$ vertices of cell $i$ by $\\mathbf X_1,...,\\mathbf X_N$ and the corresponding interpolated volume fractions by $f_1,...,f_N$. The cell edges are straight lines between pairs of points in the vertex list. To construct the $f$-isoface for cell $i$ we go through all cell edges and cut them by linear interpolation of the edge vertex values: If the edge $(\\mathbf X_k, \\mathbf X_l)$ has values $f_k < f$ and $f < f_l$, the edge is cut at the point\n\n", "index": 29, "text": "\\begin{equation}\n\t\\mathbf x_{\\textrm{cut}} = \\mathbf X_k + \\frac{f-f_k}{f_l-f_k}(\\mathbf X_l-\\mathbf X_k).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{x}_{\\textrm{cut}}=\\mathbf{X}_{k}+\\frac{f-f_{k}}{f_{l}-f_{k}}(\\mathbf{X%&#10;}_{l}-\\mathbf{X}_{k}).\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc31</mi><mtext>cut</mtext></msub><mo>=</mo><mrow><msub><mi>\ud835\udc17</mi><mi>k</mi></msub><mo>+</mo><mrow><mfrac><mrow><mi>f</mi><mo>-</mo><msub><mi>f</mi><mi>k</mi></msub></mrow><mrow><msub><mi>f</mi><mi>l</mi></msub><mo>-</mo><msub><mi>f</mi><mi>k</mi></msub></mrow></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\udc17</mi><mi>l</mi></msub><mo>-</mo><msub><mi>\ud835\udc17</mi><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nThis will vary monotonically and continuously from $0$ to $1$ as the isovalue $f$ varies from the maximum vertex value, max$(f_1,...,f_N)$, to the minimum vertex value, min$(f_1,...,f_N)$. As argued in Section \\ref{ssec:IntRecon}, the correct isovalue to use is the one recovering the cell volume fraction, that is, we should find $f^*$ such that $\\tilde\\alpha(f^*) = \\alpha_i$. In the current implementation $f^*$ is found by simple bisection root finding.\\footnote{Because $\\tilde \\alpha(f)$ is only piecewise smooth it is not a good idea to use gradient based root finding methods to try to improve convergence.} The root finding stops when $|\\tilde \\alpha(f^*)-\\alpha_i|<\\epsilon$, where $\\epsilon$ is a user specified tolerance. We typically set $\\epsilon = 10^{-8}$.\\footnote{A potentially more efficient way of finding $f^*$ is the following: Suppose $\\tilde f_1<...<\\tilde f_K$ is the sorted list of unique vertex values. We can use binary search to quickly find the interval $[\\tilde f_l,  \\tilde f_{l+1}]$ in which $f^*$ must be. On this interval the function $\\tilde \\alpha(f)$ varies as a cubic polynomial. Thus, if we evaluate $\\tilde \\alpha(f)$ at $f_l$ and $f_{l+1}$, and at two points in between, we have four equations for the four coefficients in the cubic polynomial. Solving these equations, we obtain the exact functional expression for $\\tilde \\alpha(f)$ on the relevant $f$-interval. This allows us to efficiently find $f^*$, either by analytic evaluation of the polynomial roots, or by a numerical root finding algorithm with a specified tolerance.} \n\nWe note that, due of to the cell-to-vertex interpolation, the effective stencil contributing to the isoface inside a surface cell consists of the cell itself with all its point neighbours, that is, all surrounding cells with which it shares a vertex. \n\n\n\\subsection{Estimating the isoface motion during a time step}\\label{ssec:EstIsofaceMotion}\nWe first calculate the geometric face centre, $\\mathbf x_S$, and the unit normal vector, $\\hat{\\mathbf n}_S$, of the isoface (see Fig.~\\ref{fig:isoface}). The procedure for doing this is the same as for a regular mesh face in OpenFOAM\\textregistered{}: The average point between the $N$ vertex points of the N-gonal face is calculated, and the face is decomposed into $N$ triangles all sharing this average point as their common top point. The face centre, $\\mathbf x_S$, is then calculated as the area weighted average of the geometric centres of these $N$ triangles. Likewise, the face normal vector, $\\mathbf n_S$, is calculated as the area weighted average of the $N$ triangle area vectors. \n\nThe next step is to interpolate the velocity data, $\\mathbf u_i(t)$, to $\\mathbf x_S$. This is done by first decomposing the cell into tetrahedra all sharing the cell centre as their common top point. Then we find the tetrahedron containing $\\mathbf x_S$, and interpolate the velocity field into its vertices. Finally we interpolate linearly from the tetrahedral vertices to obtain the velocity vector $\\mathbf U_S$ at $\\mathbf x_S$.\n\nThe next step is to dot $\\mathbf U_S$ with the isoface normal, $\\hat{\\mathbf n}_S$, to obtain the isoface motion normal to itself, $U_S \\equiv \\mathbf U_S\\cdot \\hat{\\mathbf n}_S$. We will make the convention that $\\hat{\\mathbf n}_S$ is directed from fluid A into fluid B. Thus, positive $U_S$ means that the cell is filling up with fluid A, while negative $U_S$ means that it is filling up with fluid B. In the current implementation we regard $U_S$ as constant during the whole time step. Possible improvements could be 1) using velocity data from previous time steps to estimate the isoface acceleration during the time step and 2) calculating the velocity gradient from surrounding cell velocity data to approximate the isoface rotation around its two tangential axes during the time step.\n\n\n\\subsection{Evolution of the face-interface intersection line}\\label{ssec:EvoOfFiil}\nWe now use $\\mathbf x_S$, $\\hat{\\mathbf n}_S$, and $U_S$ to approximate the time evolution of the face-interface intersection line of a face $j$ which is \\emph{downwind} of surface cell $i$. This we do by finding the times $t_1,...,t_N$ at which the isoface, travelling with velocity $U_S $ normal to itself, will reach the vertex points, $\\mathbf X_1,...,\\mathbf X_N$, of face $j$ (see Fig.~\\ref{subfig:sweptArea}),\n\n", "itemtype": "equation", "pos": 26670, "prevtext": "\nOnce all such edge cutting points have been found for cell $i$, they can be connected across faces to form the face-interface intersection lines, which can again be connected to form the isoface inside the cell. The isoface splits cell $i$ into a polyhedral cell, $\\mathcal A_i(f)$, entirely in fluid A, and another cell, $\\mathcal B_i(f)$, entirely in fluid B. We can calculate the volume of $\\mathcal A_i(f)$ relative to the cell volume,\n\n", "index": 31, "text": "\\begin{equation} \n\t\\tilde\\alpha(f) = \\frac{\\textrm{vol}(\\mathcal A_i(f))}{V_i}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"\\tilde{\\alpha}(f)=\\frac{\\textrm{vol}(\\mathcal{A}_{i}(f))}{V_{i}}.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>\u03b1</mi><mo stretchy=\"false\">~</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mtext>vol</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><msub><mi>V</mi><mi>i</mi></msub></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nTo obtain the face-interface intersection line at a given time $\\tau\\in[t,t+\\Delta t]$, we can now apply a linear interpolation based edge cutting procedure equivalent to the one used to find the initial (i.e. at time $t$) isoface from the volume fractions. Only, now the function values at the vertices are the times from \\eqref{eq:timeList} rather than the interpolated volume fractions. \n\nMore specifically, let us temporarily denote by $AB$ the line segment at time $t_k$, and by $CD$ the line segment at time $t_{k+1}$, such that $ABCD$ is the grey quadrilateral shown in Fig.~\\ref{subfig:sweptArea} and \\ref{subfig:quadrilateral}. Then at an intermediate time, $\\tau\\in[t_{k},t_{k+1}]$, we will assume the two end points of the segment to be\n\n", "itemtype": "equation", "pos": 31115, "prevtext": "\nThis will vary monotonically and continuously from $0$ to $1$ as the isovalue $f$ varies from the maximum vertex value, max$(f_1,...,f_N)$, to the minimum vertex value, min$(f_1,...,f_N)$. As argued in Section \\ref{ssec:IntRecon}, the correct isovalue to use is the one recovering the cell volume fraction, that is, we should find $f^*$ such that $\\tilde\\alpha(f^*) = \\alpha_i$. In the current implementation $f^*$ is found by simple bisection root finding.\\footnote{Because $\\tilde \\alpha(f)$ is only piecewise smooth it is not a good idea to use gradient based root finding methods to try to improve convergence.} The root finding stops when $|\\tilde \\alpha(f^*)-\\alpha_i|<\\epsilon$, where $\\epsilon$ is a user specified tolerance. We typically set $\\epsilon = 10^{-8}$.\\footnote{A potentially more efficient way of finding $f^*$ is the following: Suppose $\\tilde f_1<...<\\tilde f_K$ is the sorted list of unique vertex values. We can use binary search to quickly find the interval $[\\tilde f_l,  \\tilde f_{l+1}]$ in which $f^*$ must be. On this interval the function $\\tilde \\alpha(f)$ varies as a cubic polynomial. Thus, if we evaluate $\\tilde \\alpha(f)$ at $f_l$ and $f_{l+1}$, and at two points in between, we have four equations for the four coefficients in the cubic polynomial. Solving these equations, we obtain the exact functional expression for $\\tilde \\alpha(f)$ on the relevant $f$-interval. This allows us to efficiently find $f^*$, either by analytic evaluation of the polynomial roots, or by a numerical root finding algorithm with a specified tolerance.} \n\nWe note that, due of to the cell-to-vertex interpolation, the effective stencil contributing to the isoface inside a surface cell consists of the cell itself with all its point neighbours, that is, all surrounding cells with which it shares a vertex. \n\n\n\\subsection{Estimating the isoface motion during a time step}\\label{ssec:EstIsofaceMotion}\nWe first calculate the geometric face centre, $\\mathbf x_S$, and the unit normal vector, $\\hat{\\mathbf n}_S$, of the isoface (see Fig.~\\ref{fig:isoface}). The procedure for doing this is the same as for a regular mesh face in OpenFOAM\\textregistered{}: The average point between the $N$ vertex points of the N-gonal face is calculated, and the face is decomposed into $N$ triangles all sharing this average point as their common top point. The face centre, $\\mathbf x_S$, is then calculated as the area weighted average of the geometric centres of these $N$ triangles. Likewise, the face normal vector, $\\mathbf n_S$, is calculated as the area weighted average of the $N$ triangle area vectors. \n\nThe next step is to interpolate the velocity data, $\\mathbf u_i(t)$, to $\\mathbf x_S$. This is done by first decomposing the cell into tetrahedra all sharing the cell centre as their common top point. Then we find the tetrahedron containing $\\mathbf x_S$, and interpolate the velocity field into its vertices. Finally we interpolate linearly from the tetrahedral vertices to obtain the velocity vector $\\mathbf U_S$ at $\\mathbf x_S$.\n\nThe next step is to dot $\\mathbf U_S$ with the isoface normal, $\\hat{\\mathbf n}_S$, to obtain the isoface motion normal to itself, $U_S \\equiv \\mathbf U_S\\cdot \\hat{\\mathbf n}_S$. We will make the convention that $\\hat{\\mathbf n}_S$ is directed from fluid A into fluid B. Thus, positive $U_S$ means that the cell is filling up with fluid A, while negative $U_S$ means that it is filling up with fluid B. In the current implementation we regard $U_S$ as constant during the whole time step. Possible improvements could be 1) using velocity data from previous time steps to estimate the isoface acceleration during the time step and 2) calculating the velocity gradient from surrounding cell velocity data to approximate the isoface rotation around its two tangential axes during the time step.\n\n\n\\subsection{Evolution of the face-interface intersection line}\\label{ssec:EvoOfFiil}\nWe now use $\\mathbf x_S$, $\\hat{\\mathbf n}_S$, and $U_S$ to approximate the time evolution of the face-interface intersection line of a face $j$ which is \\emph{downwind} of surface cell $i$. This we do by finding the times $t_1,...,t_N$ at which the isoface, travelling with velocity $U_S $ normal to itself, will reach the vertex points, $\\mathbf X_1,...,\\mathbf X_N$, of face $j$ (see Fig.~\\ref{subfig:sweptArea}),\n\n", "index": 33, "text": "\\begin{equation}\\label{eq:timeList}\n\tt_k = t + (\\mathbf X_k-\\mathbf x_S)\\cdot \\hat{\\mathbf n}_S/U_S, \\textrm{ for } k = 1,...,N.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"t_{k}=t+(\\mathbf{X}_{k}-\\mathbf{x}_{S})\\cdot\\hat{\\mathbf{n}}_{S}/U_{S},\\textrm%&#10;{ for }k=1,...,N.\" display=\"block\"><mrow><mrow><mrow><msub><mi>t</mi><mi>k</mi></msub><mo>=</mo><mrow><mi>t</mi><mo>+</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\udc17</mi><mi>k</mi></msub><mo>-</mo><msub><mi>\ud835\udc31</mi><mi>S</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u22c5</mo><msub><mover accent=\"true\"><mi>\ud835\udc27</mi><mo stretchy=\"false\">^</mo></mover><mi>S</mi></msub></mrow><mo>/</mo><msub><mi>U</mi><mi>S</mi></msub></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mtext>\u00a0for\u00a0</mtext><mo>\u2062</mo><mi>k</mi></mrow><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>N</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nas illustrated in Fig.~\\ref{subfig:quadrilateral}. This concludes our approximation of the face-interface intersection line evolution during a time step.\n\n\\subsection{Time integral of submerged face area}\\label{ssec:timeIntSubArea}\nTo calculate the time integral of the submerged area, $A_j(\\tau)$ in \\eqref{eq:DeltaVApprox2}, we first generate a sorted list of times $\\tilde t_1,...\\tilde t_M$ starting with $\\tilde t_1 = t$ and ending with $\\tilde t_M = t+\\Delta t$ and with all the $t_k$'s from \\eqref{eq:timeList} satisfying $t<t_k<t+\\Delta t$ in between. Then the time integral in \\eqref{eq:DeltaVApprox2} may be split up as follows\n\n", "itemtype": "equation", "pos": 32007, "prevtext": "\nTo obtain the face-interface intersection line at a given time $\\tau\\in[t,t+\\Delta t]$, we can now apply a linear interpolation based edge cutting procedure equivalent to the one used to find the initial (i.e. at time $t$) isoface from the volume fractions. Only, now the function values at the vertices are the times from \\eqref{eq:timeList} rather than the interpolated volume fractions. \n\nMore specifically, let us temporarily denote by $AB$ the line segment at time $t_k$, and by $CD$ the line segment at time $t_{k+1}$, such that $ABCD$ is the grey quadrilateral shown in Fig.~\\ref{subfig:sweptArea} and \\ref{subfig:quadrilateral}. Then at an intermediate time, $\\tau\\in[t_{k},t_{k+1}]$, we will assume the two end points of the segment to be\n\n", "index": 35, "text": "\\begin{equation}\\label{eq:DCtilde}\n\t\\tilde D(\\tau) = A + \\frac{\\tau - t_k}{t_{k+1}-t_k}(D-A) \\textrm{ and } \\tilde C(\\tau) = B + \\frac{\\tau - t_k}{t_{k+1}-t_k}(C-B)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"\\tilde{D}(\\tau)=A+\\frac{\\tau-t_{k}}{t_{k+1}-t_{k}}(D-A)\\textrm{ and }\\tilde{C}%&#10;(\\tau)=B+\\frac{\\tau-t_{k}}{t_{k+1}-t_{k}}(C-B)\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>D</mi><mo stretchy=\"false\">~</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>A</mi><mo>+</mo><mrow><mfrac><mrow><mi>\u03c4</mi><mo>-</mo><msub><mi>t</mi><mi>k</mi></msub></mrow><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><msub><mi>t</mi><mi>k</mi></msub></mrow></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>D</mi><mo>-</mo><mi>A</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><mover accent=\"true\"><mi>C</mi><mo stretchy=\"false\">~</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>B</mi><mo>+</mo><mrow><mfrac><mrow><mi>\u03c4</mi><mo>-</mo><msub><mi>t</mi><mi>k</mi></msub></mrow><mrow><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><msub><mi>t</mi><mi>k</mi></msub></mrow></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>C</mi><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nOn each of these subintervals the face-interface intersection line sweeps a quadrilateral as the one shown in Fig.~\\ref{subfig:quadrilateral}. With the definition in \\eqref{eq:DCtilde} the submerged area at the intermediate time $\\tilde t_k\\leq\\tau\\leq \\tilde t_{k+1}$ is\n\\begin{eqnarray}\n\tA_j(\\tau) & = & A_j(\\tilde t_k) + \\frac12\\textrm{sign}(U_S)\\left|A\\tilde C(\\tau)\\times B\\tilde D(\\tau)\\right| \\nonumber \\\\\n\t& = & P_k\\tau^2+Q_k\\tau+A_j(\\tilde t_k).\n\\end{eqnarray}\nHere $P_k$ and $Q_k$ are polynomial coefficients that can be calculated analytically from $A, B, \\tilde C$ and $\\tilde D$. The sign of $U_S$ in cell $i$ accounts for the direction propagation of the isoface, i.e. whether the cell and face are gaining or loosing fluid A during the time interval. Once these coefficients are obtained, the contribution to the time integral in \\eqref{eq:timeIntASubTimes} from the sub time interval $[\\tilde t_k,\\tilde t_{k+1}]$ is simply\n\n", "itemtype": "equation", "pos": 32825, "prevtext": "\nas illustrated in Fig.~\\ref{subfig:quadrilateral}. This concludes our approximation of the face-interface intersection line evolution during a time step.\n\n\\subsection{Time integral of submerged face area}\\label{ssec:timeIntSubArea}\nTo calculate the time integral of the submerged area, $A_j(\\tau)$ in \\eqref{eq:DeltaVApprox2}, we first generate a sorted list of times $\\tilde t_1,...\\tilde t_M$ starting with $\\tilde t_1 = t$ and ending with $\\tilde t_M = t+\\Delta t$ and with all the $t_k$'s from \\eqref{eq:timeList} satisfying $t<t_k<t+\\Delta t$ in between. Then the time integral in \\eqref{eq:DeltaVApprox2} may be split up as follows\n\n", "index": 37, "text": "\\begin{equation}\\label{eq:timeIntASubTimes}\n\t\\int_{t}^{t+\\Delta t}A_j(\\tau)d\\tau = \\sum_{k = 1}^M\\int_{\\tilde t_k}^{\\tilde t_{k+1}}A_j(\\tau)d\\tau.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"\\int_{t}^{t+\\Delta t}A_{j}(\\tau)d\\tau=\\sum_{k=1}^{M}\\int_{\\tilde{t}_{k}}^{%&#10;\\tilde{t}_{k+1}}A_{j}(\\tau)d\\tau.\" display=\"block\"><mrow><mrow><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></msubsup><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi></msub><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></msubsup><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nAdding up all these sub interval contributions, as devised by \\eqref{eq:timeIntASubTimes}, and substituting the result into \\eqref{eq:DeltaVApprox2}, we finally reach the sought estimate for $\\Delta V_j(t,\\Delta t)$.\n\nAs stated in Section \\ref{ssec:algorithm} the above procedure should be repeated for all downwind faces of a surface cell. On all other faces we use upwind interpolation to find $\\Delta V_j$. The updated $\\alpha_i$'s at time $t+\\Delta t$ can now be calculated by inserting the $\\Delta V_j$'s into \\eqref{eq:finalAlpha}.\n\n\n\n\\subsection{Bounding procedure}\\label{ssec:bounding}\nThe procedure described above gives an accurate estimate of the fluid transport across faces in many simple cases. It does, however, not guarantee boundedness, that is, there is nothing stopping the algorithm from producing updated volume fractions outside the physically meaningful range $0\\leq\\alpha_i(t+\\Delta t)\\leq 1$. Experience shows that slight unboundedness may be produced in cells just behind (i.e. upwind of) the interface. The explanation for this is that, while the method's estimate of the $dV_j$'s are typically very good, there will inevitably be small errors, which, in cases where a cell is completely filled or emptied during the time step, will cause the algorithm to miss $0$ or $1$ by a small amount. If the produced over- and undershoots are sufficiently small, one might be tempted to simply introduce a step in the algorithm that chops $\\alpha_i(t+\\Delta t)$ at $0$ and $1$ before proceeding to the next time step. However, since this corresponds to removing and adding fluid in cells, this method destroys strict volume conservation and is not true to the VOF idea of only allowing \\emph{redistribution} of fluid amongst cells. While such a step may be practically necessary in order to ensure strict boundedness, it should be used with caution as it may potentially cause severe lack of volume conservation, in particular for long duration simulations. Can we instead introduce a bounding procedure, which is not adding or removing fluid from the domain, but only redistributing it in order to achieve boundedness? In the following we will first explain our upper bounding procedure for redistributing the surplus of fluid A in cells with $\\alpha_i(t+\\Delta t) > 1$. \n\n\n\\subsubsection{Upper bounding}\nCells with $\\alpha_i(t+\\Delta t) > 1$ are typically just upwind of the interface, in regions where the interface is moving into fluid B (i.e. $U_S > 0$). Therefore the cells just upwind of an overfilled cell $i$ are filled with fluid A, and are therefore not good candidates for taking over the surplus of fluid A in cell $i$. On the other hand, the cells just downwind of cell $i$ are only partially filled with fluid A, and are therefore able to receive cell $i$'s small surplus of fluid A. But if cell $i$ has more than one downwind cell, how should its surplus of fluid A be distributed among these? We argue as follows: The overshooting of cell $i$ starts at the time $t^* \\in [t, t+\\Delta t ]$, where the cell becomes filled, i.e. $\\alpha_i(t^*) = 1$. From this time on, all its faces must be completely filled with fluid A. Therefore pure fluid A will flow through its downwind faces from time $t^*$ and onwards. It is therefore natural to pass cell $i$'s surplus of fluid A through its downwind faces using the face fluxes, $\\phi_j$, as the weighting factors. So if the fluid A surplus in cell $i$ is $V^+$, and it has $N$ downwind faces with fluxes $\\phi_1,... ,\\phi_N$, then the fraction of $V^+$ pass on through the $j$'th of these should be $\\phi_j /\\sum_{k=1}^N \\phi_k$. However, we will not permit more fluid A to be passed through face $j$ than $\\phi_j(t) \\Delta t$. Therefore we will clip the extra flux through face $j$ to $\\min(\\phi_j\\Delta t,V^+\\phi_j /\\sum_{k=1}^N \\phi_k)$. If a face reaches its maximum fluid A transport capacity, so the surplus flux is clipped in this way, the result is that not all the surplus $V^+$ in cell $i$ is passed on to downwind cells in this first redistribution step. In that case the step is repeated to pass on the remaining surplus of fluid A through the remaining downwind faces, still using the $\\phi_j$'s as weightings, and clipping if the maximum capacity of a face is reached. The step is repeated until either all surplus fluid A in cell $i$ is passed on to the downwind neighbours or there are no more downwind cells that can take up more fluid A. \n\n\\subsubsection{Lower bounding}\nThe procedure for lower bounding (i.e. correcting cells with $\\alpha_i(t+\\Delta t) < 0$) follows simply by changing our perspective from that of fluid A to that of fluid B: We introduce the volume fraction of fluid B, $\\beta_i \\equiv 1-\\alpha_i$, and the volume of fluid B transported across faces during $\\Delta t$, $\\Delta \\tilde V_j \\equiv \\phi_j \\Delta t - \\Delta V_j$. Now $\\alpha_i < 0$ is equivalent to $\\beta_i > 1$ and we can apply the upper bounding procedure outlined above to correct the $\\Delta \\tilde V_j$'s. With the $\\Delta \\tilde V_j$'s corrected, we calculate $\\Delta V_j = \\phi_j \\Delta t - \\Delta \\tilde V_j$ and insert in \\eqref{eq:finalAlpha} to obtain the updated volume fraction $\\alpha_i(t+\\Delta t)$.\n\n\\subsubsection{Clipping}\nIt is our experience that the redistribution process outlined above succeeds in bounding most cells. However, occasionally all downwind faces of an overfilled cell will reach their maximum fluxing capacity before the cell is fully bounded. This only happens on rare occasions, and when it does it only has a minor effect on the overall quality of the solution. Nevertheless, some applications may require strict boundedness at all times, and so we have introduce an optional clipping of the volume fractions after the bounding procedure described above and before proceeding to the next time step. When this clipping is switched on the method is not strictly volume conserving, and one should therefore monitor the evolution of the total volume of fluid A, to ensure that it only varies within acceptable limits.\n\n\n\n\\section{Results}\\label{sec:results}\n\nIn the following we present the results of simple test cases with isoAdvector. The numerically advected volume fractions should reproduce as accurately as possible, with the given mesh and time step size, the solution to an interface advection problem. A simple check of this is to advect a confined volume of fluid A with a uniform velocity field across the computational mesh, and observe to what extent the method preserves the shape of the volume as it should. \n\nThe other type of test we will perform exploits the time reversibility of the advection problem: If we advect a confined volume of fluid A in a spatially and temporally varying velocity field for a period of time the interface will be distorted. If we then reverse the flow and run it backwards for the same amount of time, the volume should return to its initial position and shape. \n\nThe following error measures will be used to quantify the solution quality:\n\\begin{itemize}\n\\item \\emph{Shape preservation}. Our quantitative measure of shape preservation will be\n\n", "itemtype": "equation", "pos": 33927, "prevtext": "\nOn each of these subintervals the face-interface intersection line sweeps a quadrilateral as the one shown in Fig.~\\ref{subfig:quadrilateral}. With the definition in \\eqref{eq:DCtilde} the submerged area at the intermediate time $\\tilde t_k\\leq\\tau\\leq \\tilde t_{k+1}$ is\n\\begin{eqnarray}\n\tA_j(\\tau) & = & A_j(\\tilde t_k) + \\frac12\\textrm{sign}(U_S)\\left|A\\tilde C(\\tau)\\times B\\tilde D(\\tau)\\right| \\nonumber \\\\\n\t& = & P_k\\tau^2+Q_k\\tau+A_j(\\tilde t_k).\n\\end{eqnarray}\nHere $P_k$ and $Q_k$ are polynomial coefficients that can be calculated analytically from $A, B, \\tilde C$ and $\\tilde D$. The sign of $U_S$ in cell $i$ accounts for the direction propagation of the isoface, i.e. whether the cell and face are gaining or loosing fluid A during the time interval. Once these coefficients are obtained, the contribution to the time integral in \\eqref{eq:timeIntASubTimes} from the sub time interval $[\\tilde t_k,\\tilde t_{k+1}]$ is simply\n\n", "index": 39, "text": "\\begin{equation}\n\t\\int_{\\tilde t_k}^{\\tilde t_{k+1}}A_j(\\tau)d\\tau = \\frac13 [\\tilde t_{k+1}^3-\\tilde t_k^3] P_k+\\frac12[\\tilde t_{k+1}^2-\\tilde t_k^2]Q_k+[\\tilde t_{k+1}-\\tilde t_k]A_j(\\tilde t_k)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"\\int_{\\tilde{t}_{k}}^{\\tilde{t}_{k+1}}A_{j}(\\tau)d\\tau=\\frac{1}{3}[\\tilde{t}_{%&#10;k+1}^{3}-\\tilde{t}_{k}^{3}]P_{k}+\\frac{1}{2}[\\tilde{t}_{k+1}^{2}-\\tilde{t}_{k}%&#10;^{2}]Q_{k}+[\\tilde{t}_{k+1}-\\tilde{t}_{k}]A_{j}(\\tilde{t}_{k})\" display=\"block\"><mrow><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi></msub><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></msubsup><mrow><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msubsup><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>3</mn></msubsup><mo>-</mo><msubsup><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi><mn>3</mn></msubsup></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>P</mi><mi>k</mi></msub></mrow><mo>+</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msubsup><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>-</mo><msubsup><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi><mn>2</mn></msubsup></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>Q</mi><mi>k</mi></msub></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi></msub></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>A</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>t</mi><mo stretchy=\"false\">~</mo></mover><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhere the $\\alpha_i^{\\textrm{exact}}$'s are the volume fraction representation of the known exact interface shape. \n\\item \\emph{Volume conservation}. The change in the total volume of fluid A in the domain relative to the initial fluid A volume,\n\n", "itemtype": "equation", "pos": 41246, "prevtext": "\nAdding up all these sub interval contributions, as devised by \\eqref{eq:timeIntASubTimes}, and substituting the result into \\eqref{eq:DeltaVApprox2}, we finally reach the sought estimate for $\\Delta V_j(t,\\Delta t)$.\n\nAs stated in Section \\ref{ssec:algorithm} the above procedure should be repeated for all downwind faces of a surface cell. On all other faces we use upwind interpolation to find $\\Delta V_j$. The updated $\\alpha_i$'s at time $t+\\Delta t$ can now be calculated by inserting the $\\Delta V_j$'s into \\eqref{eq:finalAlpha}.\n\n\n\n\\subsection{Bounding procedure}\\label{ssec:bounding}\nThe procedure described above gives an accurate estimate of the fluid transport across faces in many simple cases. It does, however, not guarantee boundedness, that is, there is nothing stopping the algorithm from producing updated volume fractions outside the physically meaningful range $0\\leq\\alpha_i(t+\\Delta t)\\leq 1$. Experience shows that slight unboundedness may be produced in cells just behind (i.e. upwind of) the interface. The explanation for this is that, while the method's estimate of the $dV_j$'s are typically very good, there will inevitably be small errors, which, in cases where a cell is completely filled or emptied during the time step, will cause the algorithm to miss $0$ or $1$ by a small amount. If the produced over- and undershoots are sufficiently small, one might be tempted to simply introduce a step in the algorithm that chops $\\alpha_i(t+\\Delta t)$ at $0$ and $1$ before proceeding to the next time step. However, since this corresponds to removing and adding fluid in cells, this method destroys strict volume conservation and is not true to the VOF idea of only allowing \\emph{redistribution} of fluid amongst cells. While such a step may be practically necessary in order to ensure strict boundedness, it should be used with caution as it may potentially cause severe lack of volume conservation, in particular for long duration simulations. Can we instead introduce a bounding procedure, which is not adding or removing fluid from the domain, but only redistributing it in order to achieve boundedness? In the following we will first explain our upper bounding procedure for redistributing the surplus of fluid A in cells with $\\alpha_i(t+\\Delta t) > 1$. \n\n\n\\subsubsection{Upper bounding}\nCells with $\\alpha_i(t+\\Delta t) > 1$ are typically just upwind of the interface, in regions where the interface is moving into fluid B (i.e. $U_S > 0$). Therefore the cells just upwind of an overfilled cell $i$ are filled with fluid A, and are therefore not good candidates for taking over the surplus of fluid A in cell $i$. On the other hand, the cells just downwind of cell $i$ are only partially filled with fluid A, and are therefore able to receive cell $i$'s small surplus of fluid A. But if cell $i$ has more than one downwind cell, how should its surplus of fluid A be distributed among these? We argue as follows: The overshooting of cell $i$ starts at the time $t^* \\in [t, t+\\Delta t ]$, where the cell becomes filled, i.e. $\\alpha_i(t^*) = 1$. From this time on, all its faces must be completely filled with fluid A. Therefore pure fluid A will flow through its downwind faces from time $t^*$ and onwards. It is therefore natural to pass cell $i$'s surplus of fluid A through its downwind faces using the face fluxes, $\\phi_j$, as the weighting factors. So if the fluid A surplus in cell $i$ is $V^+$, and it has $N$ downwind faces with fluxes $\\phi_1,... ,\\phi_N$, then the fraction of $V^+$ pass on through the $j$'th of these should be $\\phi_j /\\sum_{k=1}^N \\phi_k$. However, we will not permit more fluid A to be passed through face $j$ than $\\phi_j(t) \\Delta t$. Therefore we will clip the extra flux through face $j$ to $\\min(\\phi_j\\Delta t,V^+\\phi_j /\\sum_{k=1}^N \\phi_k)$. If a face reaches its maximum fluid A transport capacity, so the surplus flux is clipped in this way, the result is that not all the surplus $V^+$ in cell $i$ is passed on to downwind cells in this first redistribution step. In that case the step is repeated to pass on the remaining surplus of fluid A through the remaining downwind faces, still using the $\\phi_j$'s as weightings, and clipping if the maximum capacity of a face is reached. The step is repeated until either all surplus fluid A in cell $i$ is passed on to the downwind neighbours or there are no more downwind cells that can take up more fluid A. \n\n\\subsubsection{Lower bounding}\nThe procedure for lower bounding (i.e. correcting cells with $\\alpha_i(t+\\Delta t) < 0$) follows simply by changing our perspective from that of fluid A to that of fluid B: We introduce the volume fraction of fluid B, $\\beta_i \\equiv 1-\\alpha_i$, and the volume of fluid B transported across faces during $\\Delta t$, $\\Delta \\tilde V_j \\equiv \\phi_j \\Delta t - \\Delta V_j$. Now $\\alpha_i < 0$ is equivalent to $\\beta_i > 1$ and we can apply the upper bounding procedure outlined above to correct the $\\Delta \\tilde V_j$'s. With the $\\Delta \\tilde V_j$'s corrected, we calculate $\\Delta V_j = \\phi_j \\Delta t - \\Delta \\tilde V_j$ and insert in \\eqref{eq:finalAlpha} to obtain the updated volume fraction $\\alpha_i(t+\\Delta t)$.\n\n\\subsubsection{Clipping}\nIt is our experience that the redistribution process outlined above succeeds in bounding most cells. However, occasionally all downwind faces of an overfilled cell will reach their maximum fluxing capacity before the cell is fully bounded. This only happens on rare occasions, and when it does it only has a minor effect on the overall quality of the solution. Nevertheless, some applications may require strict boundedness at all times, and so we have introduce an optional clipping of the volume fractions after the bounding procedure described above and before proceeding to the next time step. When this clipping is switched on the method is not strictly volume conserving, and one should therefore monitor the evolution of the total volume of fluid A, to ensure that it only varies within acceptable limits.\n\n\n\n\\section{Results}\\label{sec:results}\n\nIn the following we present the results of simple test cases with isoAdvector. The numerically advected volume fractions should reproduce as accurately as possible, with the given mesh and time step size, the solution to an interface advection problem. A simple check of this is to advect a confined volume of fluid A with a uniform velocity field across the computational mesh, and observe to what extent the method preserves the shape of the volume as it should. \n\nThe other type of test we will perform exploits the time reversibility of the advection problem: If we advect a confined volume of fluid A in a spatially and temporally varying velocity field for a period of time the interface will be distorted. If we then reverse the flow and run it backwards for the same amount of time, the volume should return to its initial position and shape. \n\nThe following error measures will be used to quantify the solution quality:\n\\begin{itemize}\n\\item \\emph{Shape preservation}. Our quantitative measure of shape preservation will be\n\n", "index": 41, "text": "\\begin{equation}\n\tE(t) \\equiv \\frac{\\sum_i V_i|\\alpha_i(t)-\\alpha_i^{\\textrm{exact}}(t)|}{\\sum_i V_i\\alpha_i^{\\textrm{exact}}(t)},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E21.m1\" class=\"ltx_Math\" alttext=\"E(t)\\equiv\\frac{\\sum_{i}V_{i}|\\alpha_{i}(t)-\\alpha_{i}^{\\textrm{exact}}(t)|}{%&#10;\\sum_{i}V_{i}\\alpha_{i}^{\\textrm{exact}}(t)},\" display=\"block\"><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mfrac><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>i</mi></msub><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msubsup><mi>\u03b1</mi><mi>i</mi><mtext>exact</mtext></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>i</mi></msub><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>\u2062</mo><msubsup><mi>\u03b1</mi><mi>i</mi><mtext>exact</mtext></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nshould be zero in simulations where no fluid A enters or leaves the domain.\n\\item \\emph{Boundedness}. For the volume fractions to be physically meaningful we should have $0 \\leq \\min_i(\\alpha_i)$ and $\\max_i (\\alpha_i )\\leq 1$ at all times.\n\\item \\emph{Sharpness}. For a sharp interface the width of the region where $\\alpha_i$ changes from $0$ to $1$ should be similar to the cell size. As quantitative sharpness measure we use the volume between the $\\alpha = 0.01$ and $0.99$ isosurfaces of the volume fraction data divided by the corresponding volume for the volume fraction representation of the exact solution. We will call this quantity $\\delta W_{\\textrm{rel}}$.\n\\item \\emph{Efficiency}. Here we give the simulation times, $T_{\\textrm{calc}}$. All simulations were executed on an Intel Xeon 3.10GHz CPU (E5-2687W) on a Dell Precision T7600 Workstation.\n\\end{itemize}\n\n\n\n\\subsection{Disc in steady uniform 2D flow}\nWe start by considering a very simple 2D case on a mesh consisting of quadrilaterals: A circular region of fluid A of radius $R = 0.25$ moving in a constant and uniform velocity field, $\\mathbf u = (1,0.5)$. The initial volume fractions are obtained from the R-isosurface of the function $\\sqrt{(x-x_0)^2 + (y-y_0)^2}$ where $(x_0,y_0) = (0.5,0.5)$ is the initial position of the disc centre.\nFig.~\\ref{fig:discInUniFlowSetup} shows the volume fraction representations of the exact initial and final interface. In the top left corner of Fig.~\\ref{fig:discInUniFlowSetup} we also show a zoom on the initial configuration with the exact circle shown in blue, and the $\\alpha = $ 0.01, 0.5, and 0.99 contours of the initial volume fraction data shown in red. For benchmarking the isoAdvector algorithm we here compare its performance with three other interface advection schemes:\n\\begin{itemize}\n\\item Multidimensional Universal Limiter with Explicit Solution (MULES) \\cite{deshpande_evaluating_2012}. This is the interface capturing method used in the OpenFOAM\\textregistered{} interface flow solver, interFoam.\n\\item High Resolution Interface Capturing (HRIC) \\cite{muzaferija1998two}. This scheme is for instance used in the commercial computational continuum mechanics software STAR-CCM+\\textregistered.\n\\item Compressive Interface Capturing Scheme for Arbitrary Meshes (CICSAM) \\cite{ubbink_method_1999}. This is for instance on of the available schemes in ANSYS Fluent\\textregistered.\n\\end{itemize}\nThese schemes are chosen partly because of their wide use in practical engineering applications and partly because they are developed for usage on general meshes.\n\nIn Fig.~\\ref{fig:discInUniFlowHex} we show in four columns (left to right) the final volume fraction solutions obtained with isoAdvector, MULES, HRIC, and CICSAM with 5 combinations of mesh and time resolution. In row 1-3 we investigate the effect of refining the mesh resolution with fixed Courant number, Co $= 0.5$. Then in row 3-5 we use the finest mesh and decrease Co from $0.5$ to $0.2$ and $0.1$. From Fig.~\\ref{fig:discInUniFlowHex} and Table~\\ref{tab:discInUniFlow} the following observations can be made:\n\\begin{itemize}\n\\item \\emph{Shape preservation}. The visual impression from Fig.~\\ref{fig:discInUniFlowHex} is that isoAdvector is superior at preserving the shape of the disc on all shown mesh-Courant number combinations. MULES has a tendency to align the interface at 45 degree with the mesh faces. Therefore the MULES solution converges to a tilted square shape as cell and time step sizes are refined (2nd column in Fig.~\\ref{fig:discInUniFlowHex}). The HRIC scheme shows a tendency to align the interface with the mesh faces, as also reported in \\cite{nielsen_numerical_2003}. This causes the initially circular interface to converge to a square (3rd column in Fig.~\\ref{fig:discInUniFlowHex}). For all the Co $= 0.5$ runs (4th column, row 1-3 in Fig.~\\ref{fig:discInUniFlowHex}) CICSAM does not perform very well in terms of shape preservation. However, it is the only one of the reference schemes which seems to converge to a circular interface solution as the time step is decreased (lower right corner in Fig.~\\ref{fig:discInUniFlowHex}). Table~\\ref{tab:E1_hex} quantifies these observations, showing that the isoAdvector $E_1$ error is at least a factor of $7$ smaller than the best of the other schemes for all runs. The table also reveals that the isoAdvector solution only improves slightly when going from Co = 0.5 to Co = 0.2 and becomes slightly worse from Co = 0.2 to 0.1. Increasing errors with decreasing time step size was also reported in \\cite{ubbink_method_1999}. \n\\item \\emph{Volume conservation}. From Table~\\ref{tab:dVrel_hex} we see that isoAdvector is the only scheme with volume preservation down to machine precision even on the coarsest mesh. On the finest mesh MULES also performs very good followed by HRIC, CICSAM being the worst performing scheme in this comparison. \n\\item \\emph{Boundedness}. From Table~\\ref{tab:amin_hex} and \\ref{tab:amax_hex} we see that isoAdvector keeps the volume fraction data bounded to within machine precision. Also MULES and HRIC produce bounded volume fractions, whereas CICSAM has severe bounding problems even on the finest mesh.\n\\item \\emph{Sharpness}. Table~\\ref{tab:dWrel_hex} shows our sharpness measure, $\\delta W_{rel}$. For all runs the isoAdvector thickness is very close to the best one can expect, i.e. the thickness of the volume fraction representation of the exact solution on the given mesh. The MULES interface width is only 30-50\\% larger than the width of the exact solution. HRIC performs rather bad in terms of interface sharpness with a smearing of the interface which is clearly visible in Fig.~\\ref{fig:discInUniFlowHex} (column 3). CICSAM keeps the interface sharp for all runs and is the best performing of the reference schemes in this respect.\n\\item \\emph{Efficiency}. From Table~\\ref{tab:calcTimes_hex} we see that, for this simple test case, isoAdvector is almost twice as slow as MULES and 4-6 times slower than HRIC and CICSAM. It is our experience that in interFoam, which uses MULES, typically 10-20\\% of the calculation time is spent in the interface advection step. Doubling the time spend in this step would therefore correspondingly cause an increase in the overall calculation time of 10-20\\%. Considering the gain in accuracy obtained with isoAdvector, this additional cost is considered to be acceptable for many applications.\n\\end{itemize}\n\nIn Fig.~\\ref{fig:discInUniFlowNonHex} we show a sequence of simulations similar to those in Fig.~\\ref{fig:discInUniFlowHex}, but now on a triangular prism mesh (Fig.~\\ref{subfig:discInUniFlowTri}) and a polygonal prism mesh (Fig.~\\ref{subfig:discInUniFlowPoly}). Again the columns show (from left to right) the solutions obtained with isoAdvector, MULES, HRIC and CICSAM. From row 1 to 2 we refined the mesh keeping the Courant number at $= 0.5$. From row 2 to 3 we keep the mesh but go from Co = 0.5 to 0.1. Since the meshes have no preferred direction, we use velocity $\\mathbf u = (1,0)$ for these simulations. The disc radius is still $R = 0.25$ and the solutions are shown at time $t = 4$. Inspection of Fig.~\\ref{fig:discInUniFlowNonHex} and the quantitative measures (here only $E_1$ is shown in Table \\ref{tab:discInUniFlowNonHex}) reveal that most of the observations listed above for the quadrilateral mesh also hold for the triangle and polygon meshes. Some exceptions are:\n\\begin{itemize}\n\\item The tendency of MULES to align the interface at $45$ degree with the mesh faces is no longer visible due to the random face orientations which presumably causes this systematic error to cancel out. However, on the triangle mesh MULES still does not seem to converge to a circular interface due to the development of ``wings'' on the sides (relative to the flow direction) of the fluid A region. On the polygon mesh MULES does significantly better in terms of shape preservation, though with a tendency to squeeze the interface along the direction of motion.\n\\item HRIC is much better at preserving the interface shape on both the triangle and polygon mesh than on the quadrilateral mesh. It is, however, still very diffusive.\n\\item CICSAM performs very poorly on the triangle mesh with threads of fluid B piercing into the disc volume from behind. On the polygon mesh these are not present and the solution quality is similar to the quadrilateral mesh solution. On both the triangle and the polygon mesh CICSAM have the same problems with unboundedness that we have seen on the quadrilateral mesh.\n\\end{itemize}\n\n\n\\subsection{Spiralling disc}\nAfter 2D uniform flow tests our next step is to test the solver performance in a spatially varying flow. We adopt the setup shown in Fig.~\\ref{fig:spiralDiscSetup} which has become a standard case for testing the ability of an interface advection schemes to deal with severe interface stretching\\cite{ubbink_method_1999, jemison_coupled_2013, ahn_adaptive_2009, le_chenadec_3d_2013, harvie_new_2000, rider_reconstructing_1998, rudman_volume-tracking_1998, rudman_volume-tracking_1997}.\n\nThe domain is the unit square with a disc of radius $R = 0.15$ initially placed at $(x,y) = (0.5,0.75)$. The velocity field is given by\n\n", "itemtype": "equation", "pos": 41638, "prevtext": "\nwhere the $\\alpha_i^{\\textrm{exact}}$'s are the volume fraction representation of the known exact interface shape. \n\\item \\emph{Volume conservation}. The change in the total volume of fluid A in the domain relative to the initial fluid A volume,\n\n", "index": 43, "text": "\\begin{equation}\n\t\\delta V_{\\textrm{rel}}(t) \\equiv \\frac{\\sum_i \\alpha_i(t)V_i-\\sum_i \\alpha_i(0))V_i}{\\sum_i \\alpha_i(0)V_i},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E22.m1\" class=\"ltx_Math\" alttext=\"\\delta V_{\\textrm{rel}}(t)\\equiv\\frac{\\sum_{i}\\alpha_{i}(t)V_{i}-\\sum_{i}%&#10;\\alpha_{i}(0))V_{i}}{\\sum_{i}\\alpha_{i}(0)V_{i}},\" display=\"block\"><mrow><mrow><mrow><mi>\u03b4</mi><mo>\u2062</mo><msub><mi>V</mi><mtext>rel</mtext></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mfrac><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>i</mi></msub><msub><mi>\u03b1</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><msub><mi>V</mi><mi>i</mi></msub><mo>-</mo><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>i</mi></msub><msub><mi>\u03b1</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo><mi>V</mi><msub><mi/><mi>i</mi></msub></mrow><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>i</mi></msub><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>V</mi><mi>i</mi></msub></mrow></mrow></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhere the period of the flow is set to $T = 16$. This flow stretches the disc into a long filament until at time $t = 4$ the flow is completely attenuated by the temporally varying cosine prefactor. Then the flow reverses and the volume of fluid flows back into its original shape at time $t = 8$. At this time our shape preservation error measure, $E_1$, can be calculated by comparing the computed final state with the initial state. \n\nIn Fig.~\\ref{fig:spiralDiscMeshes} we show the quadrilateral, triangle and polygon meshes in three different resolutions on which the isoAdvector method was tested. The results are shown in Fig.~\\ref{fig:spiralDiscResults} using the same arrangement of the meshes. All simulations are run with Co = 0.5. On each panel the exact initial and final interface shape is shown with a red circle overlayed with the 0.5-contour of the final (i.e. at time $t = 8$) volume fractions in blue. The spiral shaped volume fractions at time $t = 4$, where it is maximally stretched is shown in each panel. \n\nAll simulations show some degree of pinching at $t=4$. This occurs when the filament thickness reaches the cell size as is to be expected. The phenomena is therefore most pronounced on the coarsest meshes. We note that whereas the exact mathematical solution does not pinch, the 0.5-contour of its volume fraction representation will indeed pinch, if the mesh is coarse enough. As such, pinching does not have to be an error. However, as droplets pinch off and the local interface curvature becomes comparable to the cell size the isofaces are not able to represent the significant interface curvature inside a cell and the isoface based approximation of the advection thus becomes faulty leading to errors in the estimate of the droplet motion similar to those reported in \\cite{cerne_numerical_2002}. The irreversibility of the introduced errors causes a distortion of the final disc in the upper part which is made up of the pinched--off fluid volumes. \n\nThe error measures and calculation times are shown in Table~\\ref{tab:spirallingDiscIso}. Roughly speaking the $E_1$ error is halved when the linear cell length is halved. The volume loss percentage vary from $10^{-7}$ down to machine precision. Boundedness errors are zero to within machine precision. For the quadrilateral and polygon meshes the interface width is only a few percent larger than the ``theoretical'' width, and $\\delta W_\\textrm{rel}$ is decreasing with increasing resolution. On the triangle mesh the interface width also decreases with increasing resolution but $\\delta W_\\textrm{rel}$ increases meaning that the ``theoretical'' width decreases faster. It is, however, evident from Fig.~\\ref{fig:spiralDiscResults} that even on these very demanding triangle meshes isoAdvector yields very good results.\n\nFor a comparison we show in Fig.~\\ref{fig:spiralDiscMULES} and Table~\\ref{tab:spiralDiscMULES} the results obtained with MULES on the intermediate resolution meshes of the three types and using Co = 0.1. For the quadrilateral mesh the MULES $E_1$ error is only slightly worse than the corresponding isoAdvector error. For the triangle mesh the final interface is completely disintegrated. On the polygon mesh MULES also gives acceptable results although the $E_1$ error is more than 8 times larger than the isoAdvector error on the same mesh. In terms of calculation times MULES uses 20-40\\% more time that isoAdvector. This is in part because MULES is run with smaller time steps. However, we also ran the simulations with Co = 0.5 in which case the MULES results on all three meshes were completely disintegrated like the triangle mesh solution in Fig.~\\ref{fig:spiralDiscMULES}.\n\n\n\\subsection{Sphere in steady uniform 3D flow}\nIn this test we go back to a uniform flow but now in 3D. The velocity is $U = (0,0,1)$, and the initial interface is a sphere of radius $R = 0.25$ centred at $(0.5,0.5,0.5)$. The simulations are run on meshes consisting of random tetrahedra with 49.868, 343.441, and 1.753.352 cells covering the domain, $[0,1]\\times[0,1]\\times[0,5]$. The meshes and the 0.5-isosurface of the initial volume fraction data are shown in Fig.~\\ref{fig:sphereInUniFlowTetMeshes}. The simulations are run with Co = 0.5 until $t=4$ where the sphere has moved to $(0.5,0.5,4.5)$. The results are show in Fig.~\\ref{fig:sphereInUniFlowTet} and in Table~\\ref{tab:sphereInUniFlowIsoOnTet}. In the top row of Fig.~\\ref{fig:sphereInUniFlowTet} we show the exact final sphere (red) and the 0.5-isosurface of its volume fraction representation on the three mesh resolutions. In the bottom row we show the exact sphere (red) together with the 0.5-isosurface of the final volume fraction data obtained with isoAdvector. As seen from Table~\\ref{tab:sphereInUniFlowIsoOnTet} the $E_1$ error on the coarsest mesh is fairly large, which from Fig.~\\ref{fig:sphereInUniFlowTet} (lower left panel) can be seen to be due to an overestimation of the propagation speed rather than a lack of ability to retain the spherical interface shape. On the finer meshes $E_1$ reduces significantly all though the tendency to be slightly ahead of the exact solution is still visible in Fig.~\\ref{fig:sphereInUniFlowTet}.\n\nFor comparison we show in Fig.~\\ref{fig:sphereInUniFlowTetMULES} and Table~\\ref{tab:sphereInUniFlowMULESOnTet} the results obtained with MULES on the finest mesh running with Co = 0.1 and 0.5. In both cases the shape preservation is significantly worse than the isoAdvector results. It is also noticeable that the MULES simulations with Co = 0.1 and 0.5 spent 300\\% and 5\\% more time, respectively, on on the simulation than isoAdvector with Co = 0.5.\n\n\n\\subsection{Sphere in non-uniform 3D flow}\nOur final test case is also in 3D, but now with a non-uniform velocity field. We adopt a setup often used to test surface smearing in 3D\\cite{shin_local_2011,liovic_3d_2006,enright_fast_2005,jemison_coupled_2013}. The domain is the unit box and the initial interface is a sphere of radius $R = 0.15$ centred at $(0.35,0.35,0.35)$. This surface is advected in the velocity field\n\n", "itemtype": "equation", "pos": 51006, "prevtext": "\nshould be zero in simulations where no fluid A enters or leaves the domain.\n\\item \\emph{Boundedness}. For the volume fractions to be physically meaningful we should have $0 \\leq \\min_i(\\alpha_i)$ and $\\max_i (\\alpha_i )\\leq 1$ at all times.\n\\item \\emph{Sharpness}. For a sharp interface the width of the region where $\\alpha_i$ changes from $0$ to $1$ should be similar to the cell size. As quantitative sharpness measure we use the volume between the $\\alpha = 0.01$ and $0.99$ isosurfaces of the volume fraction data divided by the corresponding volume for the volume fraction representation of the exact solution. We will call this quantity $\\delta W_{\\textrm{rel}}$.\n\\item \\emph{Efficiency}. Here we give the simulation times, $T_{\\textrm{calc}}$. All simulations were executed on an Intel Xeon 3.10GHz CPU (E5-2687W) on a Dell Precision T7600 Workstation.\n\\end{itemize}\n\n\n\n\\subsection{Disc in steady uniform 2D flow}\nWe start by considering a very simple 2D case on a mesh consisting of quadrilaterals: A circular region of fluid A of radius $R = 0.25$ moving in a constant and uniform velocity field, $\\mathbf u = (1,0.5)$. The initial volume fractions are obtained from the R-isosurface of the function $\\sqrt{(x-x_0)^2 + (y-y_0)^2}$ where $(x_0,y_0) = (0.5,0.5)$ is the initial position of the disc centre.\nFig.~\\ref{fig:discInUniFlowSetup} shows the volume fraction representations of the exact initial and final interface. In the top left corner of Fig.~\\ref{fig:discInUniFlowSetup} we also show a zoom on the initial configuration with the exact circle shown in blue, and the $\\alpha = $ 0.01, 0.5, and 0.99 contours of the initial volume fraction data shown in red. For benchmarking the isoAdvector algorithm we here compare its performance with three other interface advection schemes:\n\\begin{itemize}\n\\item Multidimensional Universal Limiter with Explicit Solution (MULES) \\cite{deshpande_evaluating_2012}. This is the interface capturing method used in the OpenFOAM\\textregistered{} interface flow solver, interFoam.\n\\item High Resolution Interface Capturing (HRIC) \\cite{muzaferija1998two}. This scheme is for instance used in the commercial computational continuum mechanics software STAR-CCM+\\textregistered.\n\\item Compressive Interface Capturing Scheme for Arbitrary Meshes (CICSAM) \\cite{ubbink_method_1999}. This is for instance on of the available schemes in ANSYS Fluent\\textregistered.\n\\end{itemize}\nThese schemes are chosen partly because of their wide use in practical engineering applications and partly because they are developed for usage on general meshes.\n\nIn Fig.~\\ref{fig:discInUniFlowHex} we show in four columns (left to right) the final volume fraction solutions obtained with isoAdvector, MULES, HRIC, and CICSAM with 5 combinations of mesh and time resolution. In row 1-3 we investigate the effect of refining the mesh resolution with fixed Courant number, Co $= 0.5$. Then in row 3-5 we use the finest mesh and decrease Co from $0.5$ to $0.2$ and $0.1$. From Fig.~\\ref{fig:discInUniFlowHex} and Table~\\ref{tab:discInUniFlow} the following observations can be made:\n\\begin{itemize}\n\\item \\emph{Shape preservation}. The visual impression from Fig.~\\ref{fig:discInUniFlowHex} is that isoAdvector is superior at preserving the shape of the disc on all shown mesh-Courant number combinations. MULES has a tendency to align the interface at 45 degree with the mesh faces. Therefore the MULES solution converges to a tilted square shape as cell and time step sizes are refined (2nd column in Fig.~\\ref{fig:discInUniFlowHex}). The HRIC scheme shows a tendency to align the interface with the mesh faces, as also reported in \\cite{nielsen_numerical_2003}. This causes the initially circular interface to converge to a square (3rd column in Fig.~\\ref{fig:discInUniFlowHex}). For all the Co $= 0.5$ runs (4th column, row 1-3 in Fig.~\\ref{fig:discInUniFlowHex}) CICSAM does not perform very well in terms of shape preservation. However, it is the only one of the reference schemes which seems to converge to a circular interface solution as the time step is decreased (lower right corner in Fig.~\\ref{fig:discInUniFlowHex}). Table~\\ref{tab:E1_hex} quantifies these observations, showing that the isoAdvector $E_1$ error is at least a factor of $7$ smaller than the best of the other schemes for all runs. The table also reveals that the isoAdvector solution only improves slightly when going from Co = 0.5 to Co = 0.2 and becomes slightly worse from Co = 0.2 to 0.1. Increasing errors with decreasing time step size was also reported in \\cite{ubbink_method_1999}. \n\\item \\emph{Volume conservation}. From Table~\\ref{tab:dVrel_hex} we see that isoAdvector is the only scheme with volume preservation down to machine precision even on the coarsest mesh. On the finest mesh MULES also performs very good followed by HRIC, CICSAM being the worst performing scheme in this comparison. \n\\item \\emph{Boundedness}. From Table~\\ref{tab:amin_hex} and \\ref{tab:amax_hex} we see that isoAdvector keeps the volume fraction data bounded to within machine precision. Also MULES and HRIC produce bounded volume fractions, whereas CICSAM has severe bounding problems even on the finest mesh.\n\\item \\emph{Sharpness}. Table~\\ref{tab:dWrel_hex} shows our sharpness measure, $\\delta W_{rel}$. For all runs the isoAdvector thickness is very close to the best one can expect, i.e. the thickness of the volume fraction representation of the exact solution on the given mesh. The MULES interface width is only 30-50\\% larger than the width of the exact solution. HRIC performs rather bad in terms of interface sharpness with a smearing of the interface which is clearly visible in Fig.~\\ref{fig:discInUniFlowHex} (column 3). CICSAM keeps the interface sharp for all runs and is the best performing of the reference schemes in this respect.\n\\item \\emph{Efficiency}. From Table~\\ref{tab:calcTimes_hex} we see that, for this simple test case, isoAdvector is almost twice as slow as MULES and 4-6 times slower than HRIC and CICSAM. It is our experience that in interFoam, which uses MULES, typically 10-20\\% of the calculation time is spent in the interface advection step. Doubling the time spend in this step would therefore correspondingly cause an increase in the overall calculation time of 10-20\\%. Considering the gain in accuracy obtained with isoAdvector, this additional cost is considered to be acceptable for many applications.\n\\end{itemize}\n\nIn Fig.~\\ref{fig:discInUniFlowNonHex} we show a sequence of simulations similar to those in Fig.~\\ref{fig:discInUniFlowHex}, but now on a triangular prism mesh (Fig.~\\ref{subfig:discInUniFlowTri}) and a polygonal prism mesh (Fig.~\\ref{subfig:discInUniFlowPoly}). Again the columns show (from left to right) the solutions obtained with isoAdvector, MULES, HRIC and CICSAM. From row 1 to 2 we refined the mesh keeping the Courant number at $= 0.5$. From row 2 to 3 we keep the mesh but go from Co = 0.5 to 0.1. Since the meshes have no preferred direction, we use velocity $\\mathbf u = (1,0)$ for these simulations. The disc radius is still $R = 0.25$ and the solutions are shown at time $t = 4$. Inspection of Fig.~\\ref{fig:discInUniFlowNonHex} and the quantitative measures (here only $E_1$ is shown in Table \\ref{tab:discInUniFlowNonHex}) reveal that most of the observations listed above for the quadrilateral mesh also hold for the triangle and polygon meshes. Some exceptions are:\n\\begin{itemize}\n\\item The tendency of MULES to align the interface at $45$ degree with the mesh faces is no longer visible due to the random face orientations which presumably causes this systematic error to cancel out. However, on the triangle mesh MULES still does not seem to converge to a circular interface due to the development of ``wings'' on the sides (relative to the flow direction) of the fluid A region. On the polygon mesh MULES does significantly better in terms of shape preservation, though with a tendency to squeeze the interface along the direction of motion.\n\\item HRIC is much better at preserving the interface shape on both the triangle and polygon mesh than on the quadrilateral mesh. It is, however, still very diffusive.\n\\item CICSAM performs very poorly on the triangle mesh with threads of fluid B piercing into the disc volume from behind. On the polygon mesh these are not present and the solution quality is similar to the quadrilateral mesh solution. On both the triangle and the polygon mesh CICSAM have the same problems with unboundedness that we have seen on the quadrilateral mesh.\n\\end{itemize}\n\n\n\\subsection{Spiralling disc}\nAfter 2D uniform flow tests our next step is to test the solver performance in a spatially varying flow. We adopt the setup shown in Fig.~\\ref{fig:spiralDiscSetup} which has become a standard case for testing the ability of an interface advection schemes to deal with severe interface stretching\\cite{ubbink_method_1999, jemison_coupled_2013, ahn_adaptive_2009, le_chenadec_3d_2013, harvie_new_2000, rider_reconstructing_1998, rudman_volume-tracking_1998, rudman_volume-tracking_1997}.\n\nThe domain is the unit square with a disc of radius $R = 0.15$ initially placed at $(x,y) = (0.5,0.75)$. The velocity field is given by\n\n", "index": 45, "text": "\\begin{equation}\n\t\\mathbf u(x,y,t) = \\cos(2\\pi t/T)\\left(-\\sin^2(\\pi x)\\sin(2\\pi y),\\ \n\t\\sin(2\\pi x)\\sin^2(\\pi y)\\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E23.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{u}(x,y,t)=\\cos(2\\pi t/T)\\left(-\\sin^{2}(\\pi x)\\sin(2\\pi y),\\ \\sin(2\\pi&#10;x%&#10;)\\sin^{2}(\\pi y)\\right),\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>t</mi></mrow><mo>/</mo><mi>T</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mo>(</mo><mrow><mo>-</mo><mrow><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo rspace=\"7.5pt\">,</mo><mrow><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05392.tex", "nexttext": "\nwhere the period is set to $T = 6$. This flow smears the sphere into a thin sheet creating two bending and spiralling tongues. The maximum deformation is reached at $t = 1.5$, where the temporal cosine prefactor completely quenches the flow. From here on the flow reverses, and the interface returns to its initial shape and position at time $t = 3$. In Fig.~\\ref{fig:smearedSphere} the isoAdvector results are shown at time $t = 1.5$ in the top row, and at time $t = 3$ in the bottom row, on two cubic meshes with $dx = 1/100$ (left) and $dx = 1/200$ (right). In the lower panels the exact final spherical shape is also shown in red. From ODE calculations with the velocity field \\eqref{eq:3DvelocityField} we have measured the sheet thickness at $t = 1.5$ to be around $0.0063$. This, and the fact that an edge can at most be cut once by the prescribed isosurface routine, explains why there are holes in the 0.5-isosurface of the volume fraction data on the coarsest mesh with $dx = 0.01$ and no wholes in the finest simulation with $dx = 0.005$. The error measures and calculation times for the two simulations are shown in Table~\\ref{tab:smearedSphere}. \n\nWe have also performed this test on a mesh consisting of random tetrahedra. To get sufficient resolution to avoid holes in the 0.5-isosurface of the solution we used a mesh with 10.131.041 cells. A cut through this mesh and the 0.5-isosurface of the volume fraction representation of the initial sphere are shown in the left panel on Fig.~\\ref{fig:smearedSphereTet}. In the right panel we show the isoAdvector solution at time $t = 1.5$ where the smearing is maximal. This panel also contains a solution obtained by integrating the velocity field with a Runge-Kutta ODE solver  for 160.000 points evenly distributed on the initial sphere (green dots). The visual impression from Fig.~\\ref{fig:smearedSphereTet} is that there is a good match between the ODE and the isoAdvector solutions. Due to the clipping procedure in the bounding step $\\delta V_{\\textrm{rel}}$ was 0.34\\% at time $t = 1.5$. It took 6.5 days to simulate until $t = 1.5$ and it is therefore impractical to do further testing of isoAdvector on such large meshes until the code has been parallelized and profiled. \n\n\n\n\\section{Conclusion}\\label{sec:conclusion}\nWe have developed a new algorithm, isoAdvector, for numerical interface advection across general computational meshes. The method is derived from ``first principles'', i.e. from the control volume integrated continuity equation for a discontinuous density field. We give a proof--of--concept by testing the method on various simple flow-interface examples both in 2D and 3D structured and unstructured meshes. The results are very satisfactory both in terms of shape preservation, volume conservation, boundedness, sharpness, and efficiency. Also, in spite of the geometric nature of some of the steps involved, the code implementation is relatively straightforward. Finally the code, isoAdvector--0.1\\cite{isoAdvector}, is published as an open source extension to OpenFOAM\\textregistered{}. It is our hope that the isoAdvector concept and code will be used, tested, and further developed by the CFD community, and eventually result in improved simulation quality in the broad field of applications involving interfacial flows.\n\n\\section*{Acknowledgment}\n\nThis work was made possible by a Sapere Aude: DFF -- Research Talent grant from The Danish Council for Independent Research | Technology and Production Sciences to JR (Grant--ID: DFF -- 1337-00118). The grant also covers all activities of HB and HJ in connection with this work. JR also enjoys partial funding through the GTS grant to DHI from the Danish Agency for Science, Technology and Innovation.\\\\\nJR is grateful to Tomislav Mari\\'{c}, Daniel Deising, and Holger Marschall from the Mathematical Modeling and Analysis Group at the Center of Smart Interfaces, Technische Universit\\\"at Darmstadt and to Vuko Vuk\\v{c}evi\\'{c}$^3$ for fruitful discussions and for help on improving the isoAdvector code. Finally we thank Tessa Uroi\\'{c}$^3$ for providing the 3D unstructured meshes and Bjarne Jensen$^1$ for reviewing the paper. \n\n\n\n\\bibliographystyle{ieeetr}\n\\bibliography{isoAdvector}\n\n\n\n\\FloatBarrier\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=.5\\linewidth]{isoface}\n\t\\caption{A spherical surface cutting a polyhedral cell. Red dots are the edge cutting points. These are connected across the cut faces to form the face-interface intersection lines (blue). The collection of these lines form the boundary of a patch, shown in green, which we call an isoface.}\n    \\label{fig:isoface}\n\\end{center}\n\\end{figure}\n\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=.5\\linewidth]{isofaceMotion}\n\t\\caption{The isoface motion is estimated from surrounding velocity data and the isoface is propagated. Isoface at three different times within a time step are shown.}\n    \\label{fig:isofaceMotion}\n\\end{center}\n\\end{figure}\n\n\n\\begin{figure}[!tbh]\n\\begin{center}\n    \\begin{subfigure}[b]{0.49\\textwidth}\n\t\t\\includegraphics[width=\\linewidth]{sweptArea}\n\t\t\\caption{}\n\t\t\\label{subfig:sweptArea}\n    \\end{subfigure}\n    \\begin{subfigure}[b]{0.49\\textwidth}\n\t\t\\includegraphics[width=\\linewidth]{quadrilateral}\n\t\t\\caption{}\n\t\t\\label{subfig:quadrilateral}\n    \\end{subfigure}\n\t\\caption{(a): Evolving face-interface intersection line (dashed) drawn for each time where it hits a vertex. An example of the area swept between two such times is marked (grey quadrilateral). (b): Auxiliary notation for calculation of face-interface intersection line at intermediate times.}\n\t\\label{fig:fintersect}\n\\end{center}\n\\end{figure}\n\n\\FloatBarrier\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\\includegraphics[width=\\linewidth]{discInUniFlowHexSetup}\n\\caption{A disc of fluid A of radius $0.25$ is moving in constant velocity field $\\mathbf u = (1, 0.5)$ from initial position $(0.5, 0.5)$ ending up after $4$ seconds at $(4.5, 2.5)$. Exact initial and final volume fraction solutions are shown in lower left and upper right corner, respectively. A zoom of the initial condition is shown in upper left corner with the exact disc (red) and the $\\alpha = 0.01, 0.5$ and $0.99$ contours also shown (blue).}\n\\label{fig:discInUniFlowSetup}\n\\end{center}\n\\end{figure}\n\n\\FloatBarrier\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{schemeCompareHex}\n    \\caption{Disc in uniform flow $U = (1,0.5)$ at time $t = 4$. Exact solution shown with red circles. Columns from left to right: isoAdvector, MULES, HRIC, CICSAM. Rows 1-3: Mesh refinement with fixed Co $= 0.5$. Rows 3-5: Fixed mesh with Co $= 0.5, 0.2$ and $0.1$.}\\label{fig:discInUniFlowHex}\n\\end{center}\n\\end{figure}\n\n\\FloatBarrier\n\n\\begin{table}[!ptb]\n\\caption{Performance for disc in uniform flow on a quadrilateral mesh.}\n\\label{tab:discInUniFlow}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & 0.1 & 0.76 & 0.86 & 1 \\\\\n            (60,0.5) & 0.035 & 0.43 & 0.56 & 0.73 \\\\\n            (120,0.5) & 0.02 & 0.32 & 0.38 & 0.5 \\\\\n            (120,0.2) & 0.014 & 0.2 & 0.22 & 0.27 \\\\\n            (120,0.1) & 0.017 & 0.18 & 0.19 & 0.15 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$E_1$}\n        \\label{tab:E1_hex}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & -2.9e-16 & -0.0019 & -0.026 & 0.0032 \\\\\n            (60,0.5) & -2.7e-15 & -0.00018 & -0.001 & 0.0039 \\\\\n            (120,0.5) & -5e-15 & -1.1e-05 & -1e-05 & 0.0012 \\\\\n            (120,0.2) & -7.5e-15 & -5.2e-10 & 1.5e-05 & 0.00044 \\\\\n            (120,0.1) & -5.2e-15 & -2.7e-13 & -8.8e-05 & 0.00019 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$\\delta V_{\\textrm{rel}}$}\n        \\label{tab:dVrel_hex}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & -1.3e-16 & 0 & 0 & -0.16 \\\\\n            (60,0.5) & -6.7e-17 & 0 & 0 & -0.22 \\\\\n            (120,0.5) & -1.6e-16 & -1.5e-18 & -5.9e-13 & -0.23 \\\\\n            (120,0.2) & -6.4e-17 & -3.5e-127 & 0 & -0.091 \\\\\n            (120,0.1) & -6.6e-17 & 0 & 0 & -0.047 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$\\min_i(\\alpha_i)$}\n        \\label{tab:amin_hex}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & 3.4e-11 & 0.024 & 0.46 & -0.14 \\\\\n            (60,0.5) & 0 & 3.4e-11 & 0.063 & -0.15 \\\\\n            (120,0.5) & 0 & 0 & 0.0069 & -0.18 \\\\\n            (120,0.2) & 0 & 4e-14 & 0.00035 & -0.1 \\\\\n            (120,0.1) & 3.6e-12 & 6.4e-13 & 2.1e-05 & -0.034 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$1 - \\max_i(\\alpha_i)$}\n        \\label{tab:amax_hex}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & -0.00062 & 0.34 & 1.4 & 0.23 \\\\\n            (60,0.5) & -0.0031 & 0.44 & 1.9 & 0.16 \\\\\n            (120,0.5) & 0.027 & 0.51 & 3 & 0.27 \\\\\n            (120,0.2) & 0.012 & 0.32 & 1.7 & 0.14 \\\\\n            (120,0.1) & 0.0066 & 0.35 & 1.2 & 0.036 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$\\delta W_{\\textrm{rel}}$}\n        \\label{tab:dWrel_hex}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (30,0.5) & 0.82 & 0.52 & 0.21 & 0.2 \\\\\n            (60,0.5) & 3.7 & 2.16 & 0.93 & 0.89 \\\\\n            (120,0.5) & 23.36 & 12.48 & 5.33 & 4.47 \\\\\n            (120,0.2) & 51 & 28.11 & 9.42 & 8.35 \\\\\n            (120,0.1) & 96.42 & 54.89 & 16.82 & 14.48 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{$T_{\\textrm{calc}}$}\n        \\label{tab:calcTimes_hex}\n\\end{subtable}\n\\end{table}\n\n\\FloatBarrier\n\n\\begin{figure}[!tbh]\n\\begin{center}\n    \\begin{subfigure}[b]{\\textwidth}\n\t\t\\includegraphics[width=\\linewidth]{schemeComparePoly1}\n        \\caption{Triangular prism mesh}\n        \\label{subfig:discInUniFlowTri}\n    \\end{subfigure}\n    \\begin{subfigure}[b]{\\textwidth}\n\t\t\\includegraphics[width=\\linewidth]{schemeComparePoly2}\n        \\caption{Polygonal prism mesh}\n        \\label{subfig:discInUniFlowPoly}\n    \\end{subfigure}\n    \\caption{Disc in uniform flow $U = (1,0)$ at time $t = 4$. Columns from left to right: isoAdvector, MULES, HRIC, CICSAM. Rows 1-2: Mesh refinement with Co $= 0.5$. Row 2-3: Fixed mesh with Co $= 0.5$ and $0.1$.}\\label{fig:discInUniFlowNonHex}\n\\end{center}\n\\end{figure}\n\n\\FloatBarrier\n\n\\begin{table}[!tbh]\n\\caption{$E_1$ for disc in uniform flow on triangle (top) and polygon (bottom) meshes.}\\label{tab:discInUniFlowNonHex}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (20,0.5) & 0.029 & 0.27 & 0.43 & 0.96 \\\\\n            (40,0.5) & 0.014 & 0.18 & 0.26 & 0.26 \\\\\n            (40,0.1) & 0.014 & 0.13 & 0.15 & 0.096 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{Triangle mesh}\n        \\label{tab:E1_tri}\n\\end{subtable}\n\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.75cm}||p{1.75cm}|p{1.75cm}|p{1.75cm}|p{1.75cm}|}\n            \\hline\n            (Nx,Co) & isoAdvector & MULES & HRIC & CICSAM \\\\\n            \\hline\n            \\hline\n            (20,0.5) & 0.039 & 0.43 & 0.45 & 13 \\\\\n            (40,0.5) & 0.019 & 0.25 & 0.23 & 0.82 \\\\\n            (40,0.1) & 0.024 & 0.13 & 0.14 & 0.25 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{Polygon mesh}\n        \\label{tab:E1_poly}\n\\end{subtable}\n\\end{table}\n\n\\FloatBarrier\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\t\\includegraphics[width=0.5\\linewidth]{spirallingDiscSetup}\n        \\caption{Initial condition for spiralling disc test case. }\n        \\label{fig:spiralDiscSetup}\n\\end{center}\n\\end{figure}\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{spiralDiscMeshes}\n\t\\caption{Meshes used to study spiralling disc case. Zoom on part of the initial interface. Exact circular shape shown in red and 0.5-contour of volume fractions shown in blue.}\n        \\label{fig:spiralDiscMeshes}\n\\end{center}\n\\end{figure}\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\t\\includegraphics[width=\\linewidth]{spiralDiscResults}\n        \\caption{Spiral disc simulation isoAdvector results with Co = 0.5 on meshes from Fig.~\\ref{fig:spiralDiscMeshes}.}\n        \\label{fig:spiralDiscResults}\n\\end{center}\n\\end{figure}\n\n\\begin{table}[!tbh]\n        \\caption{Spiralling disc error measures for isoAdvector runs with Co = 0.5.}\n\t\\label{tab:spirallingDiscIso}\n    \\centering\n\t\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            nCells & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            10.000 & 0.1 & 3.6e-08 & -1.2e-16 & 0 & 0.039 & 84\\\\\n            40.000 &  0.054 & 6.1e-08 & -2.4e-16 & 0 & 0.014 & 421 \\\\\n            160.000 & 0.029 & -3.2e-07 & -1.3e-16 & 0 & 0.013 & 2487 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{Quadrilateral meshes}\n        \\label{tab:spirallingDiscIsoOnHex}\n\t\\end{subtable}\n\t\\begin{subtable}[!tbh]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            nCells & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            19.602 &  0.065 & -1.5e-15 & -1.4e-16 & 0 & 0.11 & 463 \\\\\n            79.202 &  0.028 & -4.9e-16 & -1.8e-16 & 0 & 0.27 & 2604 \\\\\n            318.402 & 0.014 & -3.4e-14 & -1.3e-16 & 0 & 0.4 & 18408 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{Triangle meshes}\n        \\label{tab:spirallingDiscIsoOnTri}\n\t\\end{subtable}\n\t\\begin{subtable}[htb]{\\textwidth}\n    \\centering\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            nCells & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            10000 & 0.12 & -1.9e-10 & -9.4e-16 & 0 & 0.082 & 184 \\\\\n            40000 & 0.042 & -1.6e-10 & -8.2e-17 & 0 & 0.011 & 993 \\\\\n            160000 &  0.021 & -1.1e-10 & -1.5e-16 & 0 & -0.0015 & 6776 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\caption{Polygon meshes}\n        \\label{tab:spirallingDiscIsoOnPoly}\n\t\\end{subtable}\n\\end{table}\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\t\\includegraphics[width=\\linewidth]{spiralDiscMULES}\n        \\caption{Spiral disc simulation MULES results with Co = 0.1 on the three intermediate resolution meshes from Fig.~\\ref{fig:spiralDiscMeshes}.}\n        \\label{fig:spiralDiscMULES}\n\\end{center}\n\\end{figure}\n\n\\begin{table}[!tbh]\n    \\centering\n        \\caption{Spiralling disc error measures for MULES with Co = 0.5.}\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            Mesh & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            Quad &  0.072 & 2e-14 & -8.5e-49 & 6.7e-09 & 0.58 & 542 \\\\\n            Triangle &  1 & -1.2e-14 & -5.6e-34 & 0.00027 & nan  & 4148 \\\\\n            Polygon & 0.36 & -2.3e-14 & -9.6e-33 & 2.9e-10 & 0.98 & 1313 \\\\\n            \\hline\n\t      \\end{tabular}\n        \\label{tab:spiralDiscMULES}\n\\end{table}\n\n\\FloatBarrier\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{sphereInUniFlowTetMeshes}\n    \\caption{Tetrahedron meshes including 0.5-isosurface of initial volume fraction data.}\\label{fig:sphereInUniFlowTetMeshes}\n\\end{center}\n\\end{figure}\n\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{sphereInUniFlowTet}\n    \\caption{Sphere in uniform flow $U = (0,0,1)$ on tetrahedral mesh at time $t = 4$. Top row: Exact solution (red sphere) and its $0.5$-isosurface on three different mesh resolutions. Bottom row: Exact solution (red sphere) and $0.5$-isosurface of the isoAdvector solution with Co $= 0.5$.}\\label{fig:sphereInUniFlowTet}\n\\end{center}\n\\end{figure}\n\n\\begin{table}[!tbh]\n    \\centering\n        \\caption{Sphere in uniform flow error measures for isoAdvector runs with Co = 0.5.}\n        \\label{tab:sphereInUniFlowIsoOnTet}\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            nCells & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            49.868 & 0.18 & -1.7e-08 & -1.7e-16 & 0 & -0.018 & 89 \\\\\n            343.441 & 0.039 & -4.6e-09 & -2e-16 & 0 & 0.0032 & 770 \\\\\n            1.753.352 & 0.018 & -1.5e-10 & -2.3e-16 & 0 & 0.0052 & 6907 \\\\\n            \\hline\n\t      \\end{tabular}\n\\end{table}\n\n\\begin{table}[!tbh]\n    \\centering\n        \\caption{Sphere in uniform flow errors measures for MULES on the finest tetrahedron mesh.}\n        \\label{tab:sphereInUniFlowMULESOnTet}\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            Co & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            0.5 & 0.42 & -4.5e-13 & -5e-06 & -1.9e-06 & 2 & 7306 \\\\\n            0.1 & 0.29 & -8.2e-13 & -1.9e-31 & 9e-06 & 2 & 28686 \\\\\n            \\hline\n\t      \\end{tabular}\n\\end{table}\n\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{sphereInUniFlowMULESTet}\n    \\caption{Sphere in uniform flow $U = (0,0,1)$ at time $t = 4$ on the finest tetrahedral mesh of Fig.~\\ref{fig:sphereInUniFlowTet}. Left: Exact solution (red sphere) and $0.5$-isosurface of MULES solution with Co $= 0.5$. Right: The same but with Co $= 0.1$.}\\label{fig:sphereInUniFlowTetMULES}\n\\end{center}\n\\end{figure}\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{smearedSphere2}\n    \\caption{Sphere in non-uniform flow on cube mesh with Co = 0.5. Top: $t = 1.5$. Bottom: $t = 3.0$ with exact solution in red. Left: dx = 1/100. Right: dx = 1/200.}\\label{fig:smearedSphere}\n\\end{center}\n\\end{figure}\n\n\\begin{table}[!tbh]\n    \\centering\n        \\caption{Error measures for isoAdvector simulations in Fig.~\\ref{fig:smearedSphere} of a sphere in a 3D non-uniform flow on two cube meshes.}\n        \\label{tab:smearedSphere}\n        \\begin{tabular}{|p{1.25cm}||p{1.25cm}|p{1.25cm}|p{1.25cm}|p{1.7cm}|p{1.25cm}|p{1.25cm}|}\n            \\hline\n            dx & $E_1$ & $\\delta V_{\\textrm{rel}}$ & $\\min_i(\\alpha_i)$ & 1-$\\max_i(\\alpha_i)$ & $\\delta W_{\\textrm{rel}}$ & $T_{\\textrm{calc}}$\\\\\n            \\hline\n            \\hline\n            $1/100$ &  0.089 & 2.6e-08 & -2.7e-16 & 0 & 0.098 & 2312 \\\\\n            $1/200$ & 0.023 & 3.8e-08 & -4.1e-14 & 0 & 0.0033 & 35631 \\\\\n            \\hline\n\t      \\end{tabular}\n\\end{table}\n\n\\begin{figure}[!tbh]\n\\begin{center}\n\t\\includegraphics[width=\\linewidth]{smearedSphereTet}\n    \\caption{Sphere in non-uniform flow on tetrahedral mesh. Left: Mesh and 0.5-isosurface of the initial volume fraction data. Right: isoAdvector solution (red) and the solution obtained with an accurate ODE solver (green) at time $t = 1.5$.}\\label{fig:smearedSphereTet}\n\\end{center}\n\\end{figure}\n\n\n\n", "itemtype": "equation", "pos": 57226, "prevtext": "\nwhere the period of the flow is set to $T = 16$. This flow stretches the disc into a long filament until at time $t = 4$ the flow is completely attenuated by the temporally varying cosine prefactor. Then the flow reverses and the volume of fluid flows back into its original shape at time $t = 8$. At this time our shape preservation error measure, $E_1$, can be calculated by comparing the computed final state with the initial state. \n\nIn Fig.~\\ref{fig:spiralDiscMeshes} we show the quadrilateral, triangle and polygon meshes in three different resolutions on which the isoAdvector method was tested. The results are shown in Fig.~\\ref{fig:spiralDiscResults} using the same arrangement of the meshes. All simulations are run with Co = 0.5. On each panel the exact initial and final interface shape is shown with a red circle overlayed with the 0.5-contour of the final (i.e. at time $t = 8$) volume fractions in blue. The spiral shaped volume fractions at time $t = 4$, where it is maximally stretched is shown in each panel. \n\nAll simulations show some degree of pinching at $t=4$. This occurs when the filament thickness reaches the cell size as is to be expected. The phenomena is therefore most pronounced on the coarsest meshes. We note that whereas the exact mathematical solution does not pinch, the 0.5-contour of its volume fraction representation will indeed pinch, if the mesh is coarse enough. As such, pinching does not have to be an error. However, as droplets pinch off and the local interface curvature becomes comparable to the cell size the isofaces are not able to represent the significant interface curvature inside a cell and the isoface based approximation of the advection thus becomes faulty leading to errors in the estimate of the droplet motion similar to those reported in \\cite{cerne_numerical_2002}. The irreversibility of the introduced errors causes a distortion of the final disc in the upper part which is made up of the pinched--off fluid volumes. \n\nThe error measures and calculation times are shown in Table~\\ref{tab:spirallingDiscIso}. Roughly speaking the $E_1$ error is halved when the linear cell length is halved. The volume loss percentage vary from $10^{-7}$ down to machine precision. Boundedness errors are zero to within machine precision. For the quadrilateral and polygon meshes the interface width is only a few percent larger than the ``theoretical'' width, and $\\delta W_\\textrm{rel}$ is decreasing with increasing resolution. On the triangle mesh the interface width also decreases with increasing resolution but $\\delta W_\\textrm{rel}$ increases meaning that the ``theoretical'' width decreases faster. It is, however, evident from Fig.~\\ref{fig:spiralDiscResults} that even on these very demanding triangle meshes isoAdvector yields very good results.\n\nFor a comparison we show in Fig.~\\ref{fig:spiralDiscMULES} and Table~\\ref{tab:spiralDiscMULES} the results obtained with MULES on the intermediate resolution meshes of the three types and using Co = 0.1. For the quadrilateral mesh the MULES $E_1$ error is only slightly worse than the corresponding isoAdvector error. For the triangle mesh the final interface is completely disintegrated. On the polygon mesh MULES also gives acceptable results although the $E_1$ error is more than 8 times larger than the isoAdvector error on the same mesh. In terms of calculation times MULES uses 20-40\\% more time that isoAdvector. This is in part because MULES is run with smaller time steps. However, we also ran the simulations with Co = 0.5 in which case the MULES results on all three meshes were completely disintegrated like the triangle mesh solution in Fig.~\\ref{fig:spiralDiscMULES}.\n\n\n\\subsection{Sphere in steady uniform 3D flow}\nIn this test we go back to a uniform flow but now in 3D. The velocity is $U = (0,0,1)$, and the initial interface is a sphere of radius $R = 0.25$ centred at $(0.5,0.5,0.5)$. The simulations are run on meshes consisting of random tetrahedra with 49.868, 343.441, and 1.753.352 cells covering the domain, $[0,1]\\times[0,1]\\times[0,5]$. The meshes and the 0.5-isosurface of the initial volume fraction data are shown in Fig.~\\ref{fig:sphereInUniFlowTetMeshes}. The simulations are run with Co = 0.5 until $t=4$ where the sphere has moved to $(0.5,0.5,4.5)$. The results are show in Fig.~\\ref{fig:sphereInUniFlowTet} and in Table~\\ref{tab:sphereInUniFlowIsoOnTet}. In the top row of Fig.~\\ref{fig:sphereInUniFlowTet} we show the exact final sphere (red) and the 0.5-isosurface of its volume fraction representation on the three mesh resolutions. In the bottom row we show the exact sphere (red) together with the 0.5-isosurface of the final volume fraction data obtained with isoAdvector. As seen from Table~\\ref{tab:sphereInUniFlowIsoOnTet} the $E_1$ error on the coarsest mesh is fairly large, which from Fig.~\\ref{fig:sphereInUniFlowTet} (lower left panel) can be seen to be due to an overestimation of the propagation speed rather than a lack of ability to retain the spherical interface shape. On the finer meshes $E_1$ reduces significantly all though the tendency to be slightly ahead of the exact solution is still visible in Fig.~\\ref{fig:sphereInUniFlowTet}.\n\nFor comparison we show in Fig.~\\ref{fig:sphereInUniFlowTetMULES} and Table~\\ref{tab:sphereInUniFlowMULESOnTet} the results obtained with MULES on the finest mesh running with Co = 0.1 and 0.5. In both cases the shape preservation is significantly worse than the isoAdvector results. It is also noticeable that the MULES simulations with Co = 0.1 and 0.5 spent 300\\% and 5\\% more time, respectively, on on the simulation than isoAdvector with Co = 0.5.\n\n\n\\subsection{Sphere in non-uniform 3D flow}\nOur final test case is also in 3D, but now with a non-uniform velocity field. We adopt a setup often used to test surface smearing in 3D\\cite{shin_local_2011,liovic_3d_2006,enright_fast_2005,jemison_coupled_2013}. The domain is the unit box and the initial interface is a sphere of radius $R = 0.15$ centred at $(0.35,0.35,0.35)$. This surface is advected in the velocity field\n\n", "index": 47, "text": "\\begin{equation}\\label{eq:3DvelocityField}\n\\mathbf u(x,y,z,t) = \\cos(2\\pi t/T)\\left(\n  \\begin{array}{c}\n  2\\sin^2(\\pi x)\\sin(2\\pi y)\\sin(2\\pi z) \\\\\n  -\\sin(2\\pi x)\\sin^2(\\pi y)\\sin(2\\pi z) \\\\\n  -\\sin(2\\pi x)\\sin(2\\pi y)\\sin^2(\\pi z)\n  \\end{array}\n\\right)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E24.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{u}(x,y,z,t)=\\cos(2\\pi t/T)\\left(\\begin{array}[]{c}2\\sin^{2}(\\pi x)\\sin%&#10;(2\\pi y)\\sin(2\\pi z)\\\\&#10;-\\sin(2\\pi x)\\sin^{2}(\\pi y)\\sin(2\\pi z)\\\\&#10;-\\sin(2\\pi x)\\sin(2\\pi y)\\sin^{2}(\\pi z)\\end{array}\\right)\" display=\"block\"><mrow><mrow><mi>\ud835\udc2e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>t</mi></mrow><mo>/</mo><mi>T</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mn>2</mn><mo>\u2062</mo><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>z</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mrow><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>z</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mrow><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c0</mi><mo>\u2062</mo><mi>z</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow></math>", "type": "latex"}]