[{"file": "1601.02200.tex", "nexttext": "\n\nThe actual solution, is the vector from the solution set, which has the minimum \\(l_{0}\\) norm. Since this is a NP-hard problem, so we choose the solution which minimizes the \\(l_{1}\\) norm. It is observed that minimizing \\(l_{1}\\) norm will give an accurate solution~\\cite{Tao} provided the sensing matrix $A$ satisfies the Restricted Isometry Property ($RIP$) property~\\cite{Candes}.\n\nHowever, if the sparsity of the input signal is not precisely known, but known to lie within a specified range, traditional compressed sensing as such cannot exploit this fact and would need to use the same number of measurements for all sparsity values in this range. In this case, the compressed sensing algorithm has to work taking into account the worst case, which corresponds to the signal being least sparse. For example if the input signal is a discrete-time digital signal of length $N$ and can have sparsity anywhere between $m_1=5$ to $m_2 =25$ in the frequency domain, for compressed sensing to work, one has to design the sensing matrix keeping in mind the sparsity value $m_2=25$. For this case, there are $25$ frequencies in the signal which will correspond to $48 - 50$ complex coefficients (depending upon the locations of those 25 frequency coefficients), it was experimentally observed to take about $175$ ($=7 \\cdot 25$) measurements for an accurate reconstruction by minimizing the $l_{1}$ norm. Thus if the input signal had sparsity $m=5$, conventional compressed sensing would take $175$ measurements (since it has been designed for sparsity $m_2=25$) whereas only 40 measurements would have sufficed. Thus, we have unnecessarily used 135 more measurements than needed in this case.\n\nIn this paper, we propose a novel method called Compressed Shattering to address this particular issue. The central idea of compressed shattering is to adapt compressed sensing to the specified sparsity range by creating shattered signals~\\cite{Gilbert} which have fixed sparsity using a filter-bank. Our primary aim is to reduce the number of measurements.\n\n\n\\section{Compressed Shattering}\nThe problem is stated as follows. The input signal is a discrete-time digital signal of length $N$ which needs to be sensed. It is sparse within a range $\\left[m_1,m_2\\right]$ in the frequency domain, where $0\\leq m_1\\leq m_2\\leq \\left\\lfloor N/2\\right\\rfloor$. Here,  $m$-sparse means there are only $m$ non-zero coefficients in the $DFT$ of the input signal, without considering the symmetric complex conjugate parts.\n\n\n\\subsection{Block Diagram: Overview}\nThe proposed algorithm is described in Fig.~\\ref{forward_compresss_filtering}. First the input signal is permuted. This results in a permutation of the spectrum ($DFT$) in order to remove any clusters and to spread it out. The permuted spectrum is then passed through a filter-bank, which is a set of \\(T\\) band-pass filters, where \\(1\\leq T\\leq \\left\\lfloor N/2\\right\\rfloor\\). An inverse permutation operation is done on all the filter outputs to put the spectrum back in its original position. The compressed sensing algorithm is applied on the output of the filters; using the same sensing matrix on each of them.  Depending upon the sparsity level of the original signal, the filter outputs might be zero or a very sparse signal, and the level of sparsity in the output of each of the filters can be controlled by adjusting the characteristics and number of filters. In the succeeding subsections, we describe each block in detail.\n\n\n\n\n\n\\subsection{Permutation Block}\nThe permutation block performs a mapping operation in which the indices of input signal are rearranged. It is given by:\n\n", "itemtype": "equation", "pos": 4007, "prevtext": "\n\n\n\\title{Compressed Shattering}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\author{\n\\IEEEauthorblockN{Harikumar Kannampillil, Anand Krishnadas Nambisan, Sandra Kizhakkekundil, Shreeja Sugathan}\n     \\IEEEauthorblockA{Amrita School of Engineering, Amrita Vishwa Vidyapeetham, Amritapuri, Kollam, Kerala, INDIA.}\n     \\IEEEauthorblockN{Nithin Nagaraj}\n     \\IEEEauthorblockA{School of Humanities, National Institute of Advanced Studies, \\\\ Indian Institute of Science Campus, Bengaluru, INDIA. (Email: nithin@nias.iisc.ernet.in)}}\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\\maketitle\n\n\\begin{abstract}\nThe central idea of compressed sensing is to exploit the fact that most signals of interest are sparse in some domain and use this to reduce the number of measurements to encode. However, if the sparsity of the input signal is not precisely known, but known to lie within a specified range, compressed sensing as such cannot exploit this fact and would need to use the same number of measurements even for a very sparse signal. In this paper, we propose a novel method called Compressed Shattering to adapt compressed sensing to the specified sparsity range, without changing the sensing matrix by creating shattered signals which have fixed sparsity. This is accomplished by first suitably permuting the input spectrum and then using a filter bank to create fixed sparsity shattered signals. By ensuring that all the shattered signals are utmost 1-sparse, we make use of a simple but efficient deterministic sensing matrix to yield very low number of measurements.  For a discrete-time signal of length 1000, with a sparsity range of $5 - 25$, traditional compressed sensing requires $175$ measurements, whereas Compressed Shattering would only need $20 - 100$ measurements.\n\\end{abstract}\n\n\\begin{figure*}[!ht]\n\t\\centering\n\t\\includegraphics[width=5.3in]{forward_compresss_filtering.eps} \n\t\\caption{Block diagram which illustrates the compressed shattering process. $\\sigma$ and $\\sigma^{-1}$ represent the permutation operation with the respective parameters, {$h_{1}(n), h_{2}(n), \\ldots, h_{T}(n)$} are the impulse responses of $T$ filters of the filter bank, {$x_{1}(n), x_{2}(n), \\ldots, x_{T}(n)$} are the outputs of the $T$ filters after inverse permutation, {$y_{1}, y_{2}, \\ldots, y_{T}$} are the measurements corresponding to the $T$ filters, \\textbf{TH} represents the threshold operation block, {$y_{c_{1}}, y_{c_{2}}, \\ldots, y_{c_{r}}$} represent the $r$ significant outputs.}\n\t\\label{forward_compresss_filtering}\n\\end{figure*}\n\n\n\n\\begin{figure*}[!ht]\n\t\\centering\n\t\\includegraphics[width=5.3in]{permutation_unclustering.eps} \n\t\\caption{Permutation block: $N=16$, $m=3$, $\\sigma=3$, $\\sigma^{-1}=11$, $n$ represents time domain, $k$ represents frequency domain, $x(n)$ is the input signal, $x_{p}(n)$ is the permuted signal, $X(k)$ is the input signal spectrum, $X_{p}(k)$ is the permuted signal spectrum.}\n\t\\label{permutation_unclustering}\n\\end{figure*}\n\n\\begin{figure*}[!ht]\n\t\\centering\n\t\\includegraphics[width=6.4in]{filter_performance_mega.eps}\n\t\\caption{$N=16$, $m=3$, $T=4$, $\\sigma=3$, $\\sigma^{-1}=11$, $X_{p}(k)$ is the same permuted spectrum from Fig. \\ref{permutation_unclustering}. $H_{g}(k)$ is the filter response of the $g^{th}$ filter and $X_{g}(k)$ is the spectrum after de-permutation operation from the $g^{th}$ filter where $g = 1, 2, \\ldots, T$. This figure shows what happens in the spectral domain, when the permuted signal $x_{p}(n)$ is passed through through the corresponding filters and gets de-permuted. Note that the operation with $\\sigma^{-1}$ is done in time domain.}\n\t\\label{filter_performance_mega}\n\\end{figure*}\n\n\n\\section{Introduction}\nCompressed sensing~\\cite{Candes} is a fundamental idea in mathematics, which utilizes the {\\it a priori} property of signal $x(n)$ of length $N$ being $m$ sparse in some domain, where $m<<N$, along with an appropriately constructed sensing matrix $A$, to establish a unique solution for an otherwise undetermined system of linear equations:\n\n\n", "index": 1, "text": "\\begin{equation}\nA_{M\\times N}\\cdot x_{N\\times 1}=Y_{M\\times 1}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"A_{M\\times N}\\cdot x_{N\\times 1}=Y_{M\\times 1}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>A</mi><mrow><mi>M</mi><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>\u00d7</mo><mn>1</mn></mrow></msub></mrow><mo>=</mo><msub><mi>Y</mi><mrow><mi>M</mi><mo>\u00d7</mo><mn>1</mn></mrow></msub></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhere \\(x(n)\\) is the input discrete-time signal of length \\(N\\) and $n = 0, 1, 2, \\ldots, N-1$. It is to be noted that all the operations performed on the indices are modulo \\(N\\) operations. The parameter \\(\\sigma\\) should be relatively prime to \\(N\\) to ensure that the resultant permutation matrix is invertible. Considering \\(N\\) to be power of \\(2\\), any odd number belong to set \\({1, 3, \\ldots, N-1}\\) would suffice. Permutation done using  $\\sigma$ will ensure that the spectrum of the signal also gets permuted but with \\(\\sigma^{-1}\\) as the permutation parameter~\\cite{Gilbert}, in accordance with the equation:\n\n", "itemtype": "equation", "pos": 7726, "prevtext": "\n\nThe actual solution, is the vector from the solution set, which has the minimum \\(l_{0}\\) norm. Since this is a NP-hard problem, so we choose the solution which minimizes the \\(l_{1}\\) norm. It is observed that minimizing \\(l_{1}\\) norm will give an accurate solution~\\cite{Tao} provided the sensing matrix $A$ satisfies the Restricted Isometry Property ($RIP$) property~\\cite{Candes}.\n\nHowever, if the sparsity of the input signal is not precisely known, but known to lie within a specified range, traditional compressed sensing as such cannot exploit this fact and would need to use the same number of measurements for all sparsity values in this range. In this case, the compressed sensing algorithm has to work taking into account the worst case, which corresponds to the signal being least sparse. For example if the input signal is a discrete-time digital signal of length $N$ and can have sparsity anywhere between $m_1=5$ to $m_2 =25$ in the frequency domain, for compressed sensing to work, one has to design the sensing matrix keeping in mind the sparsity value $m_2=25$. For this case, there are $25$ frequencies in the signal which will correspond to $48 - 50$ complex coefficients (depending upon the locations of those 25 frequency coefficients), it was experimentally observed to take about $175$ ($=7 \\cdot 25$) measurements for an accurate reconstruction by minimizing the $l_{1}$ norm. Thus if the input signal had sparsity $m=5$, conventional compressed sensing would take $175$ measurements (since it has been designed for sparsity $m_2=25$) whereas only 40 measurements would have sufficed. Thus, we have unnecessarily used 135 more measurements than needed in this case.\n\nIn this paper, we propose a novel method called Compressed Shattering to address this particular issue. The central idea of compressed shattering is to adapt compressed sensing to the specified sparsity range by creating shattered signals~\\cite{Gilbert} which have fixed sparsity using a filter-bank. Our primary aim is to reduce the number of measurements.\n\n\n\\section{Compressed Shattering}\nThe problem is stated as follows. The input signal is a discrete-time digital signal of length $N$ which needs to be sensed. It is sparse within a range $\\left[m_1,m_2\\right]$ in the frequency domain, where $0\\leq m_1\\leq m_2\\leq \\left\\lfloor N/2\\right\\rfloor$. Here,  $m$-sparse means there are only $m$ non-zero coefficients in the $DFT$ of the input signal, without considering the symmetric complex conjugate parts.\n\n\n\\subsection{Block Diagram: Overview}\nThe proposed algorithm is described in Fig.~\\ref{forward_compresss_filtering}. First the input signal is permuted. This results in a permutation of the spectrum ($DFT$) in order to remove any clusters and to spread it out. The permuted spectrum is then passed through a filter-bank, which is a set of \\(T\\) band-pass filters, where \\(1\\leq T\\leq \\left\\lfloor N/2\\right\\rfloor\\). An inverse permutation operation is done on all the filter outputs to put the spectrum back in its original position. The compressed sensing algorithm is applied on the output of the filters; using the same sensing matrix on each of them.  Depending upon the sparsity level of the original signal, the filter outputs might be zero or a very sparse signal, and the level of sparsity in the output of each of the filters can be controlled by adjusting the characteristics and number of filters. In the succeeding subsections, we describe each block in detail.\n\n\n\n\n\n\\subsection{Permutation Block}\nThe permutation block performs a mapping operation in which the indices of input signal are rearranged. It is given by:\n\n", "index": 3, "text": "\\begin{equation}\nx_{p}\\left(n \\right)= x((\\sigma \\cdot n)~mod\\;N),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"x_{p}\\left(n\\right)=x((\\sigma\\cdot n)~{}mod\\;N),\" display=\"block\"><mrow><mrow><mrow><msub><mi>x</mi><mi>p</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03c3</mi><mo>\u22c5</mo><mi>n</mi></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><mi>d</mi></mpadded><mo>\u2062</mo><mi>N</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\nwhere \\(X(k)\\) is the $N$-$DFT$ of $x(n)$ and $k = 0, 1, 2, \\ldots, N-1$ and $\\sigma^{-1}$ is defined as $(\\sigma\\cdot\\sigma^{-1})~mod~N = 1$.  Fig. \\ref{permutation_unclustering} depicts the permutation on an example, it can also be seen that this permutation helps to de-cluster the signal spectrum\\footnote{The permutation operation can be seen as a linear congruential generator which randomizes the indices. Instead, a more powerful pseudo-random number generator (PRNG) could be used.}.\n\n\n\\subsection{Filtering and Inverse Permutation}\nThe permuted signal is then passed through a filter-bank of $T$ non-overlapping ideal filters. It should be noted that the filter design and the algorithm that follows in this paper is done by considering $N$ to be even and the number of filters $T$ divides $\\frac{N}{2}$ to give an integer. The frequency response of the filter banks are:\n\n\n\n", "itemtype": "equation", "pos": 8433, "prevtext": "\n\nwhere \\(x(n)\\) is the input discrete-time signal of length \\(N\\) and $n = 0, 1, 2, \\ldots, N-1$. It is to be noted that all the operations performed on the indices are modulo \\(N\\) operations. The parameter \\(\\sigma\\) should be relatively prime to \\(N\\) to ensure that the resultant permutation matrix is invertible. Considering \\(N\\) to be power of \\(2\\), any odd number belong to set \\({1, 3, \\ldots, N-1}\\) would suffice. Permutation done using  $\\sigma$ will ensure that the spectrum of the signal also gets permuted but with \\(\\sigma^{-1}\\) as the permutation parameter~\\cite{Gilbert}, in accordance with the equation:\n\n", "index": 5, "text": "\\begin{equation}\nX_{p}\\left(k \\right)= X((\\sigma^{-1} \\cdot k)~mod\\;N),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"X_{p}\\left(k\\right)=X((\\sigma^{-1}\\cdot k)~{}mod\\;N),\" display=\"block\"><mrow><mrow><mrow><msub><mi>X</mi><mi>p</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\u03c3</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u22c5</mo><mi>k</mi></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><mi>d</mi></mpadded><mo>\u2062</mo><mi>N</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhere,\n\n", "itemtype": "equation", "pos": 9404, "prevtext": "\nwhere \\(X(k)\\) is the $N$-$DFT$ of $x(n)$ and $k = 0, 1, 2, \\ldots, N-1$ and $\\sigma^{-1}$ is defined as $(\\sigma\\cdot\\sigma^{-1})~mod~N = 1$.  Fig. \\ref{permutation_unclustering} depicts the permutation on an example, it can also be seen that this permutation helps to de-cluster the signal spectrum\\footnote{The permutation operation can be seen as a linear congruential generator which randomizes the indices. Instead, a more powerful pseudo-random number generator (PRNG) could be used.}.\n\n\n\\subsection{Filtering and Inverse Permutation}\nThe permuted signal is then passed through a filter-bank of $T$ non-overlapping ideal filters. It should be noted that the filter design and the algorithm that follows in this paper is done by considering $N$ to be even and the number of filters $T$ divides $\\frac{N}{2}$ to give an integer. The frequency response of the filter banks are:\n\n\n\n", "index": 7, "text": "\\begin{equation}\n\\setlength{\\nulldelimiterspace}{0pt}\nH_{b}(k)=\\left\\{\\begin{IEEEeqnarraybox}[\\relax][c]{ls}\n1,\\;\\;\\;\\;\\;\\;& $\\frac{(b-1)\\times N}{2\\times T}\\leq k< \\frac{N\\times b}{2 \\times T}$\\\\\n1,\\;\\;\\;\\;\\;\\;& $ a_1< k\\leq a_2$\\\\\n0,\\;\\;\\;\\;\\;\\;&elsewere\n\\end{IEEEeqnarraybox}\\right.,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"H_{b}(k)=\\left\\{\\IEEEeqnarraybox[][c]{ls}1,\\;\\;\\;\\;\\;\\;&amp;\\frac{(b-1)\\times N}{2%&#10;\\times T}\\leq k&lt;\\frac{N\\times b}{2\\times T}\\\\&#10;1,\\;\\;\\;\\;\\;\\;&amp;a_{1}&lt;k\\leq a_{2}\\\\&#10;0,\\;\\;\\;\\;\\;\\;&amp;elsewere\\right.,\" display=\"block\"><mrow><msub><mi>H</mi><mi>b</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mrow><mo>{</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>{IEEEeqnarraybox}</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">]</mo></mrow><mrow><mo stretchy=\"false\">[</mo><mi>c</mi><mo stretchy=\"false\">]</mo></mrow><mi>l</mi><mi>s</mi><mn>1</mn><mo rspace=\"19.3pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mfrac><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mi>N</mi></mrow><mrow><mn>2</mn><mo>\u00d7</mo><mi>T</mi></mrow></mfrac><mo>\u2264</mo><mi>k</mi><mo>&lt;</mo><mfrac><mrow><mi>N</mi><mo>\u00d7</mo><mi>b</mi></mrow><mrow><mn>2</mn><mo>\u00d7</mo><mi>T</mi></mrow></mfrac><mn>1</mn><mo rspace=\"19.3pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><msub><mi>a</mi><mn>1</mn></msub><mo>&lt;</mo><mi>k</mi><mo>\u2264</mo><msub><mi>a</mi><mn>2</mn></msub><mn>0</mn><mo rspace=\"19.3pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo>,</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 9714, "prevtext": "\n\nwhere,\n\n", "index": 9, "text": "\\begin{equation}\na_1 = N-\\frac{b\\times N}{2\\times T},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"a_{1}=N-\\frac{b\\times N}{2\\times T},\" display=\"block\"><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mrow><mi>N</mi><mo>-</mo><mfrac><mrow><mi>b</mi><mo>\u00d7</mo><mi>N</mi></mrow><mrow><mn>2</mn><mo>\u00d7</mo><mi>T</mi></mrow></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nfor $b = {2,3, \\ldots, (T-1)}$. When $b=1$, we have: $H_{1}(k)$, where $a_2=N-1$. When $b = T$, we have:\n\n\n", "itemtype": "equation", "pos": 9784, "prevtext": "\n\n\n", "index": 11, "text": "\\begin{equation}\na_2 = N-\\frac{(b-1)\\times N}{2\\times T},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"a_{2}=N-\\frac{(b-1)\\times N}{2\\times T},\" display=\"block\"><mrow><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>=</mo><mrow><mi>N</mi><mo>-</mo><mfrac><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mi>N</mi></mrow><mrow><mn>2</mn><mo>\u00d7</mo><mi>T</mi></mrow></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\nOut of the $T$ filters, only $r$ of them will have significant outputs,  where $1\\leq r\\leq m_2$. This filter bank will do a circular convolution as opposed to the normal linear convolution. It is done to preserve the length of the signal and it will be a perfect element wise multiplication in the Fourier domain without having to pad any zeros. Preservation of length is necessary for the inverse permutation block that comes next. The signal is then passed through it for reversing the permutation operation, thereby putting the spectrum back in its original position. Fig. \\ref{filter_performance_mega} gives an example of filtering and inverse permutation operations.\n\nThe output signals obtained at the end of filtering and inverse permutation are known as {\\it shattered} signals~\\cite{Gilbert,Gilbert2}. As can be seen, the shattered signals are relatively more sparse than the input signal and the sparsity can be controlled by suitably changing $\\sigma$ and $\\{ H_b(\\cdot) \\}$. It is also possible to obtain shattered signals which are at most 1-sparse as the outputs.\n\n\n\\subsection{Sensing Block}\nThe shattered signals are now ready for compressed sensing. Each of the output signals are sensed by the same sensing matrix $A$, designed for specific level of sparsity, which will preferably be much less than the original minimum sparsity  $m_2$ of the signal specified in the range. Note that more the number of frequencies present in the signal, the less sparse is its spectrum. Although it is possible to obtain different level of sparsity for the shattered signal, in this paper, we have ensured that the shattered signals are all 0 or 1-sparse. In other words, the filter outputs have at most a single frequency. Hence the number of filters $T$ should be at least $m_2$.  This is sensed by a $2 \\times N$ sensing matrix $A$ specifically designed to sense such 1-sparse data, taking into account the symmetry of the $DFT$. By this, we ensure that each of the non-zero shattered signals can be sensed in just $2$ measurements. In total that will amount to at most $2\\cdot T$ measurements.\n\n\\subsection{Deterministic Sensing Matrix $A$}\nAs opposed to use of a sensing matrix with random values, we propose a simple but efficient deterministic sensing matrix $A$. We make use of the information that shattered signals are either 0 or 1-sparse. The number of unknowns are just two for each output (position and value of complex $DFT$ coefficient). We also make use of the fact that the $DFT$, for real signals, is conjugate symmetric.\n\n\n", "itemtype": "equation", "pos": 9964, "prevtext": "\n\nfor $b = {2,3, \\ldots, (T-1)}$. When $b=1$, we have: $H_{1}(k)$, where $a_2=N-1$. When $b = T$, we have:\n\n\n", "index": 13, "text": "\\begin{equation}\nH_{T}(k)\\;,\\;H_{T}(\\frac{N}{2}) = 1.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"H_{T}(k)\\;,\\;H_{T}(\\frac{N}{2})=1.\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>H</mi><mi>T</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo rspace=\"5.3pt\" stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"5.3pt\">,</mo><mrow><msub><mi>H</mi><mi>T</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 12581, "prevtext": "\n\n\nOut of the $T$ filters, only $r$ of them will have significant outputs,  where $1\\leq r\\leq m_2$. This filter bank will do a circular convolution as opposed to the normal linear convolution. It is done to preserve the length of the signal and it will be a perfect element wise multiplication in the Fourier domain without having to pad any zeros. Preservation of length is necessary for the inverse permutation block that comes next. The signal is then passed through it for reversing the permutation operation, thereby putting the spectrum back in its original position. Fig. \\ref{filter_performance_mega} gives an example of filtering and inverse permutation operations.\n\nThe output signals obtained at the end of filtering and inverse permutation are known as {\\it shattered} signals~\\cite{Gilbert,Gilbert2}. As can be seen, the shattered signals are relatively more sparse than the input signal and the sparsity can be controlled by suitably changing $\\sigma$ and $\\{ H_b(\\cdot) \\}$. It is also possible to obtain shattered signals which are at most 1-sparse as the outputs.\n\n\n\\subsection{Sensing Block}\nThe shattered signals are now ready for compressed sensing. Each of the output signals are sensed by the same sensing matrix $A$, designed for specific level of sparsity, which will preferably be much less than the original minimum sparsity  $m_2$ of the signal specified in the range. Note that more the number of frequencies present in the signal, the less sparse is its spectrum. Although it is possible to obtain different level of sparsity for the shattered signal, in this paper, we have ensured that the shattered signals are all 0 or 1-sparse. In other words, the filter outputs have at most a single frequency. Hence the number of filters $T$ should be at least $m_2$.  This is sensed by a $2 \\times N$ sensing matrix $A$ specifically designed to sense such 1-sparse data, taking into account the symmetry of the $DFT$. By this, we ensure that each of the non-zero shattered signals can be sensed in just $2$ measurements. In total that will amount to at most $2\\cdot T$ measurements.\n\n\\subsection{Deterministic Sensing Matrix $A$}\nAs opposed to use of a sensing matrix with random values, we propose a simple but efficient deterministic sensing matrix $A$. We make use of the information that shattered signals are either 0 or 1-sparse. The number of unknowns are just two for each output (position and value of complex $DFT$ coefficient). We also make use of the fact that the $DFT$, for real signals, is conjugate symmetric.\n\n\n", "index": 15, "text": "\\begin{equation}\nA_{2\\times N}\\cdot x_{g}=y_{g},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"A_{2\\times N}\\cdot x_{g}=y_{g},\" display=\"block\"><mrow><mrow><mrow><msub><mi>A</mi><mrow><mn>2</mn><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><msub><mi>x</mi><mi>g</mi></msub></mrow><mo>=</mo><msub><mi>y</mi><mi>g</mi></msub></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 12646, "prevtext": "\n\n\n", "index": 17, "text": "\\begin{equation}\nA_{2\\times N} = \\Phi_{2\\times N}\\cdot \\Psi_{N\\times N},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"A_{2\\times N}=\\Phi_{2\\times N}\\cdot\\Psi_{N\\times N},\" display=\"block\"><mrow><mrow><msub><mi>A</mi><mrow><mn>2</mn><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>=</mo><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mn>2</mn><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><msub><mi mathvariant=\"normal\">\u03a8</mi><mrow><mi>N</mi><mo>\u00d7</mo><mi>N</mi></mrow></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 12735, "prevtext": "\n\n\n", "index": 19, "text": "\\begin{equation}\n\\Psi_{N\\times N}(k,n) = e^{\\frac{-i2\\pi nk}{N}} ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\Psi_{N\\times N}(k,n)=e^{\\frac{-i2\\pi nk}{N}},\" display=\"block\"><mrow><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a8</mi><mrow><mi>N</mi><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msup><mi>e</mi><mfrac><mrow><mo>-</mo><mrow><mi>i</mi><mo>\u2062</mo><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>k</mi></mrow></mrow><mi>N</mi></mfrac></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n\nwhere $\\theta_{s} = \\frac{\\pi \\times s}{N}$ ($s={0, 1, \\ldots, \\frac{N}{2}}$), $x_{g}$ is the signal of length $N$ at output of the $g^{th}$ filter ($g=1, 2, \\ldots, T$) which has at most a single frequency (0 or 1-sparse). $\\Psi$ is the $N-DFT$ matrix, $A$ is the sensing matrix of which any two columns of the first $\\frac{N}{2}$ columns of A are linearly independent, $y_{g}$ is $(2\\times 1)$ measurement vector which is complex valued. This sensing matrix will ensure that the sensing happens only for the first half of the spectrum. Further, at most only $r$ of the filters will have significant output, namely ${c_{1},c_{2}, \\ldots, c_{r}}$. So, only the measurements, $y_{c_{j}}$ ($j = 1, 2, \\ldots, r$), corresponding to those $r$ filters needs to be stored. For this reason all the measurements $\\{ y_g\\}$,  is passed through a threshold block \\textbf{TH} (refer to Fig.~\\ref{forward_compresss_filtering}), where insignificant measurements are discarded by choosing an appropriate threshold for the $l_2$ norm of the shattered signals.\n\n\\section{Reconstruction Block}\n\n\\begin{figure}[!ht]\n\t\\centering\n\t\\includegraphics[width=3.3in]{Reconstruction_compress_filtering.eps} \n\t\\caption{Block diagram which illustrates the process of reconstruction.}\n\t\\label{Reconstruction_compress_filtering}\n\\end{figure}\n\n\n\\begin{table*}[!ht]\n\t\\centering\n\t\\caption[Comparative Results]{Simulation Results for sparsity values $m=5$ and 25.} \n\t\\label{tab:tableresults} \n\t\\vspace{0.01in}\n\t\n\t\n\t\\begin{tabular}{|@{}c@{}|c|@{}c@{}|@{}c||c@{}|@{}c||c@{}|@{}c||c@{}|}\n\t\t\\hline\n\t\t\n\t\t&  &   & \\multicolumn{2}{|c|}{No. of Measurements}   & \\multicolumn{2}{|c|}{No. of Additions} & \\multicolumn{2}{|c|}{No. of Multiplications}\\\\\n\t\t\\cline{4-5} \\cline{6-7} \\cline{8-9}\n\t\t$N$    & $m$    & $T$  & Compressed    & Compressed       & Compressed  & Compressed & Compressed   &  Compressed \\\\\n\t\t\n\t\t&        &      & Sensing  & Shattering      &     Sensing &      Shattering &      Sensing &     Shattering\\\\\n\t\t\\hline\n\t\t1000 & 5 &  100       &  175  & 20   & 174825 & 399600 & $1.75 \\times 10^5$ & $4\\times 10^5$\\\\\n\t\t1000 & 25 & 100      &  175 & 100 & 174825 & 399600 & $1.75 \\times 10^5$ & $4\\times 10^5$\\\\\n\t\t\\hline\n\t\\end{tabular}\n\\end{table*}\n\nIn compressed shattering, since we are using a deterministic sensing matrix $A$ as described above, we can make use of the inherent structure in the matrix to design a very fast reconstruction algorithm. We directly calculate the position and the value of the frequency coefficient of the signal by the following set of equations: (because $\\theta_{s} \\leq \\frac{\\pi}{2}$)\n\n\n", "itemtype": "equation", "pos": 12818, "prevtext": "\n\n\n", "index": 21, "text": "\\begin{equation}\n\\Phi_{2\\times N} = \\left(\\begin{IEEEeqnarraybox*}[][c]{,c/c/c/c/c/c/c/c,}\n\\cos(\\theta_{0})&\\cos(\\theta_{1})&$...$&\\cos(\\theta_{\\frac{N}{2}})&0&0&...&0\\\\\n\\sin(\\theta_{0})&\\sin(\\theta_{1})&$...$&\\sin(\\theta_{\\frac{N}{2}})&0&0&...&0\n\\end{IEEEeqnarraybox*}\\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\Phi_{2\\times N}=\\left(\\IEEEeqnarraybox*[][c]{,c/c/c/c/c/c/c/c,}\\cos(\\theta_{0%&#10;})&amp;\\cos(\\theta_{1})&amp;...&amp;\\cos(\\theta_{\\frac{N}{2}})&amp;0&amp;0&amp;...&amp;0\\\\&#10;\\sin(\\theta_{0})&amp;\\sin(\\theta_{1})&amp;...&amp;\\sin(\\theta_{\\frac{N}{2}})&amp;0&amp;0&amp;...&amp;0%&#10;\\right),\" display=\"block\"><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mrow><mn>2</mn><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>=</mo><mrow><mo>(</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>{IEEEeqnarraybox*}</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>c</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mrow><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi><mo>/</mo><mi>c</mi></mrow><mo>,</mo><mrow><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mfrac><mi>N</mi><mn>2</mn></mfrac></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03b8</mi><mfrac><mi>N</mi><mn>2</mn></mfrac></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn></mrow><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 15706, "prevtext": "\n\n\n\nwhere $\\theta_{s} = \\frac{\\pi \\times s}{N}$ ($s={0, 1, \\ldots, \\frac{N}{2}}$), $x_{g}$ is the signal of length $N$ at output of the $g^{th}$ filter ($g=1, 2, \\ldots, T$) which has at most a single frequency (0 or 1-sparse). $\\Psi$ is the $N-DFT$ matrix, $A$ is the sensing matrix of which any two columns of the first $\\frac{N}{2}$ columns of A are linearly independent, $y_{g}$ is $(2\\times 1)$ measurement vector which is complex valued. This sensing matrix will ensure that the sensing happens only for the first half of the spectrum. Further, at most only $r$ of the filters will have significant output, namely ${c_{1},c_{2}, \\ldots, c_{r}}$. So, only the measurements, $y_{c_{j}}$ ($j = 1, 2, \\ldots, r$), corresponding to those $r$ filters needs to be stored. For this reason all the measurements $\\{ y_g\\}$,  is passed through a threshold block \\textbf{TH} (refer to Fig.~\\ref{forward_compresss_filtering}), where insignificant measurements are discarded by choosing an appropriate threshold for the $l_2$ norm of the shattered signals.\n\n\\section{Reconstruction Block}\n\n\\begin{figure}[!ht]\n\t\\centering\n\t\\includegraphics[width=3.3in]{Reconstruction_compress_filtering.eps} \n\t\\caption{Block diagram which illustrates the process of reconstruction.}\n\t\\label{Reconstruction_compress_filtering}\n\\end{figure}\n\n\n\\begin{table*}[!ht]\n\t\\centering\n\t\\caption[Comparative Results]{Simulation Results for sparsity values $m=5$ and 25.} \n\t\\label{tab:tableresults} \n\t\\vspace{0.01in}\n\t\n\t\n\t\\begin{tabular}{|@{}c@{}|c|@{}c@{}|@{}c||c@{}|@{}c||c@{}|@{}c||c@{}|}\n\t\t\\hline\n\t\t\n\t\t&  &   & \\multicolumn{2}{|c|}{No. of Measurements}   & \\multicolumn{2}{|c|}{No. of Additions} & \\multicolumn{2}{|c|}{No. of Multiplications}\\\\\n\t\t\\cline{4-5} \\cline{6-7} \\cline{8-9}\n\t\t$N$    & $m$    & $T$  & Compressed    & Compressed       & Compressed  & Compressed & Compressed   &  Compressed \\\\\n\t\t\n\t\t&        &      & Sensing  & Shattering      &     Sensing &      Shattering &      Sensing &     Shattering\\\\\n\t\t\\hline\n\t\t1000 & 5 &  100       &  175  & 20   & 174825 & 399600 & $1.75 \\times 10^5$ & $4\\times 10^5$\\\\\n\t\t1000 & 25 & 100      &  175 & 100 & 174825 & 399600 & $1.75 \\times 10^5$ & $4\\times 10^5$\\\\\n\t\t\\hline\n\t\\end{tabular}\n\\end{table*}\n\nIn compressed shattering, since we are using a deterministic sensing matrix $A$ as described above, we can make use of the inherent structure in the matrix to design a very fast reconstruction algorithm. We directly calculate the position and the value of the frequency coefficient of the signal by the following set of equations: (because $\\theta_{s} \\leq \\frac{\\pi}{2}$)\n\n\n", "index": 23, "text": "\\begin{equation}\n\\Theta_{j} = \\cos^{-1}(\\frac{\\left| y_{c_{j}}(0)\\right|}{||y_{c_{j}}||_2}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\Theta_{j}=\\cos^{-1}(\\frac{\\left|y_{c_{j}}(0)\\right|}{||y_{c_{j}}||_{2}}),\" display=\"block\"><mrow><mrow><msub><mi mathvariant=\"normal\">\u0398</mi><mi>j</mi></msub><mo>=</mo><mrow><msup><mi>cos</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mfrac><mrow><mo>|</mo><mrow><msub><mi>y</mi><msub><mi>c</mi><mi>j</mi></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>|</mo></mrow><msub><mrow><mo fence=\"true\">||</mo><msub><mi>y</mi><msub><mi>c</mi><mi>j</mi></msub></msub><mo fence=\"true\">||</mo></mrow><mn>2</mn></msub></mfrac><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 15815, "prevtext": "\n\n\n", "index": 25, "text": "\\begin{equation}\n\\alpha_{j} = \\frac{\\Theta_{j}}{\\Delta \\theta}\\;\\;,\\;\\;\\beta_{j} = \\frac{y_{c_{j}}(0)}{\\cos(\\Theta_{j})},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\alpha_{j}=\\frac{\\Theta_{j}}{\\Delta\\theta}\\;\\;,\\;\\;\\beta_{j}=\\frac{y_{c_{j}}(0%&#10;)}{\\cos(\\Theta_{j})},\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03b1</mi><mi>j</mi></msub><mo>=</mo><mpadded width=\"+5.6pt\"><mfrac><msub><mi mathvariant=\"normal\">\u0398</mi><mi>j</mi></msub><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>\u03b8</mi></mrow></mfrac></mpadded></mrow><mo rspace=\"8.1pt\">,</mo><mrow><msub><mi>\u03b2</mi><mi>j</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>y</mi><msub><mi>c</mi><mi>j</mi></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi mathvariant=\"normal\">\u0398</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhere $\\beta_{j}$ represents the complex coefficient and $\\alpha_{j}$ represents the position of the coefficient. From the above equation we can reconstruct the spectrum of the signal in the following way. (When $\\alpha_{j}\\neq 0$)\n\n\n\n", "itemtype": "equation", "pos": 15957, "prevtext": "\n\n\n\n\n\n\n", "index": 27, "text": "\\begin{equation}\n\\Delta \\theta = \\frac{\\pi}{N},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"\\Delta\\theta=\\frac{\\pi}{N},\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>\u03b8</mi></mrow><mo>=</mo><mfrac><mi>\u03c0</mi><mi>N</mi></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhen $\\alpha_{j} = 0$,\n\n\n", "itemtype": "equation", "pos": 16255, "prevtext": "\n\nwhere $\\beta_{j}$ represents the complex coefficient and $\\alpha_{j}$ represents the position of the coefficient. From the above equation we can reconstruct the spectrum of the signal in the following way. (When $\\alpha_{j}\\neq 0$)\n\n\n\n", "index": 29, "text": "\\begin{equation}\n\\setlength{\\nulldelimiterspace}{0pt}\n\\widetilde{X}_{j}(k)=\\left\\{\\begin{IEEEeqnarraybox}[\\relax][c]{ls}\n\\beta_{j},\\;\\;& $k = \\alpha_{j}$\\\\\n\\beta_{j}',\\;\\;& $k = N-\\alpha_{j}$\\\\\n0,\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;&elsewere\n\\end{IEEEeqnarraybox}\\right.\\;\\;\\;,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"\\widetilde{X}_{j}(k)=\\left\\{\\IEEEeqnarraybox[][c]{ls}\\beta_{j},\\;\\;&amp;k=\\alpha_{%&#10;j}\\\\&#10;\\beta_{j}^{\\prime},\\;\\;&amp;k=N-\\alpha_{j}\\\\&#10;0,\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;&amp;elsewere\\right.\\;\\;\\;,\" display=\"block\"><mrow><msub><mover accent=\"true\"><mi>X</mi><mo>~</mo></mover><mi>j</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mrow><mo>{</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>{IEEEeqnarraybox}</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">]</mo></mrow><mrow><mo stretchy=\"false\">[</mo><mi>c</mi><mo stretchy=\"false\">]</mo></mrow><mi>l</mi><mi>s</mi><msub><mi>\u03b2</mi><mi>j</mi></msub><mo rspace=\"8.1pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>k</mi><mo>=</mo><msub><mi>\u03b1</mi><mi>j</mi></msub><msubsup><mi>\u03b2</mi><mi>j</mi><mo>\u2032</mo></msubsup><mo rspace=\"8.1pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>k</mi><mo>=</mo><mi>N</mi><mo>-</mo><msub><mi>\u03b1</mi><mi>j</mi></msub><mn>0</mn><mo rspace=\"50.1pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>w</mi><mi>e</mi><mi>r</mi><mpadded width=\"+8.4pt\"><mi>e</mi></mpadded><mo>,</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhere $\\beta_{j}'$ is the complex conjugate of $\\beta_{j}$ and $\\widetilde{X}_{j}$ is the reconstructed spectrum of the output of the filter $c_{j}$. Summing up all respective reconstructed spectrums of the $r$ significant filters will give the reconstructed version of the original signal spectrum represented by $\\widetilde{X}$ (refer to Fig.~\\ref{Reconstruction_compress_filtering}).\n\n\n", "itemtype": "equation", "pos": 16571, "prevtext": "\n\nwhen $\\alpha_{j} = 0$,\n\n\n", "index": 31, "text": "\\begin{equation}\n\\setlength{\\nulldelimiterspace}{0pt}\n\\widetilde{X}_{j}(k)=\\left\\{\\begin{IEEEeqnarraybox}[\\relax][c]{ls}\n\\beta_{j},\\;\\;& $k = 0$\\\\\n0,\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;&elsewere\n\\end{IEEEeqnarraybox}\\right.,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"\\widetilde{X}_{j}(k)=\\left\\{\\IEEEeqnarraybox[][c]{ls}\\beta_{j},\\;\\;&amp;k=0\\\\&#10;0,\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;&amp;elsewere\\right.,\" display=\"block\"><mrow><msub><mover accent=\"true\"><mi>X</mi><mo>~</mo></mover><mi>j</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mrow><mo>{</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>{IEEEeqnarraybox}</mtext></merror><mrow><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">]</mo></mrow><mrow><mo stretchy=\"false\">[</mo><mi>c</mi><mo stretchy=\"false\">]</mo></mrow><mi>l</mi><mi>s</mi><msub><mi>\u03b2</mi><mi>j</mi></msub><mo rspace=\"8.1pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>k</mi><mo>=</mo><mn>0</mn><mn>0</mn><mo rspace=\"50.1pt\">,</mo><mi mathvariant=\"normal\">&amp;</mi><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo>,</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n\n", "itemtype": "equation", "pos": 17198, "prevtext": "\n\nwhere $\\beta_{j}'$ is the complex conjugate of $\\beta_{j}$ and $\\widetilde{X}_{j}$ is the reconstructed spectrum of the output of the filter $c_{j}$. Summing up all respective reconstructed spectrums of the $r$ significant filters will give the reconstructed version of the original signal spectrum represented by $\\widetilde{X}$ (refer to Fig.~\\ref{Reconstruction_compress_filtering}).\n\n\n", "index": 33, "text": "\\begin{equation}\n\\widetilde{X} = \\sum_{j=1}^{r}\\widetilde{X}_{j},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"\\widetilde{X}=\\sum_{j=1}^{r}\\widetilde{X}_{j},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>X</mi><mo>~</mo></mover><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></munderover><msub><mover accent=\"true\"><mi>X</mi><mo>~</mo></mover><mi>j</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nBy taking the Inverse $DFT$ of $\\widetilde{X}(k)$ we get $\\widetilde{x}(n)$ which represents the reconstructed version of the original time domain signal.\n\n\n\n\\section{Matrix Formulation}\nTo summarize, compressed shattering has four steps in the following order.  The input signal is 1) permuted, 2) passed through a filter-bank, 3) de-permuted, and 4) finally sensed by a sensing matrix $A$. There will be $T$ such paths corresponding to $T$ filters, however only $r$ will be significant (refer to Fig.~\\ref{forward_compresss_filtering}). Since every block is a linear transformation (up to the thresholding block), we can reduce the entire compressed shattering procedure to one single matrix (for each of the $T$ paths). This is given by:\n\n\n", "itemtype": "equation", "pos": 17281, "prevtext": "\n\n\n\n", "index": 35, "text": "\\begin{equation}\n\\widetilde{x}(n) = \\sum^{N-1}_{k = 0}\\widetilde{X}(k)\\cdot e^{\\frac{i2\\pi nk}{N}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"\\widetilde{x}(n)=\\sum^{N-1}_{k=0}\\widetilde{X}(k)\\cdot e^{\\frac{i2\\pi nk}{N}}.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>x</mi><mo>~</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mrow><mover accent=\"true\"><mi>X</mi><mo>~</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><msup><mi>e</mi><mfrac><mrow><mi>i</mi><mo>\u2062</mo><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>k</mi></mrow><mi>N</mi></mfrac></msup></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nhere $x_{g}$ can be replaced with the following:\n\n\n", "itemtype": "equation", "pos": 18139, "prevtext": "\n\nBy taking the Inverse $DFT$ of $\\widetilde{X}(k)$ we get $\\widetilde{x}(n)$ which represents the reconstructed version of the original time domain signal.\n\n\n\n\\section{Matrix Formulation}\nTo summarize, compressed shattering has four steps in the following order.  The input signal is 1) permuted, 2) passed through a filter-bank, 3) de-permuted, and 4) finally sensed by a sensing matrix $A$. There will be $T$ such paths corresponding to $T$ filters, however only $r$ will be significant (refer to Fig.~\\ref{forward_compresss_filtering}). Since every block is a linear transformation (up to the thresholding block), we can reduce the entire compressed shattering procedure to one single matrix (for each of the $T$ paths). This is given by:\n\n\n", "index": 37, "text": "\\begin{equation}\nA\\cdot x_{g} = y_{g}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"A\\cdot x_{g}=y_{g}\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u22c5</mo><msub><mi>x</mi><mi>g</mi></msub></mrow><mo>=</mo><msub><mi>y</mi><mi>g</mi></msub></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\nwhere $P$ is the permutation matrix, $P^{-1}$ is the inverse permutation matrix and $Hmat_{g}$ is an $(N \\times N)$ circular convolution matrix corresponding to the $g^{th}$ filter. These matrices can be multiplied to form a single matrix $\\gamma_{g}$, of size $(2\\times N)$, with complex entries, that takes the input $x$ and transforms it into the measurements $y_{g}$ corresponding to the $g^{th}$ filter:\n\n\n", "itemtype": "equation", "pos": 18243, "prevtext": "\n\nhere $x_{g}$ can be replaced with the following:\n\n\n", "index": 39, "text": "\\begin{equation}\nA_{2\\times N}\\cdot P^{-1}_{N\\times N}\\cdot Hmat_{g}\\cdot P_{N\\times N}\\cdot x_{N \\times 1} = y_{g},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"A_{2\\times N}\\cdot P^{-1}_{N\\times N}\\cdot Hmat_{g}\\cdot P_{N\\times N}\\cdot x_%&#10;{N\\times 1}=y_{g},\" display=\"block\"><mrow><mrow><mrow><mrow><mrow><msub><mi>A</mi><mrow><mn>2</mn><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><msubsup><mi>P</mi><mrow><mi>N</mi><mo>\u00d7</mo><mi>N</mi></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u22c5</mo><mi>H</mi></mrow><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><msub><mi>t</mi><mi>g</mi></msub></mrow><mo>\u22c5</mo><msub><mi>P</mi><mrow><mi>N</mi><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>\u00d7</mo><mn>1</mn></mrow></msub></mrow><mo>=</mo><msub><mi>y</mi><mi>g</mi></msub></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 18786, "prevtext": "\n\nwhere $P$ is the permutation matrix, $P^{-1}$ is the inverse permutation matrix and $Hmat_{g}$ is an $(N \\times N)$ circular convolution matrix corresponding to the $g^{th}$ filter. These matrices can be multiplied to form a single matrix $\\gamma_{g}$, of size $(2\\times N)$, with complex entries, that takes the input $x$ and transforms it into the measurements $y_{g}$ corresponding to the $g^{th}$ filter:\n\n\n", "index": 41, "text": "\\begin{equation}\n\\gamma_{g}\\cdot x= y_{g},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E21.m1\" class=\"ltx_Math\" alttext=\"\\gamma_{g}\\cdot x=y_{g},\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03b3</mi><mi>g</mi></msub><mo>\u22c5</mo><mi>x</mi></mrow><mo>=</mo><msub><mi>y</mi><mi>g</mi></msub></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.02200.tex", "nexttext": "\n\n\n\n\n\n\\section{Simulation Results and Discussion}\nIn this section, we perform numerical simulations to test our proposed algorithm and compare it with conventional compressed sensing. The parameters for comparison will be number of measurements stored and number of computations. The input signal to the system is a discrete-time real signal of length $N=1000$ and will have sparsity anywhere in the range $m_1=5$ to $m_2=25$ frequencies. We report results for both the extreme cases of sparsity: $m_1$ and $m_2$.\n\n\n\nThe input signal and its DFT spectrum corresponding to sparsity $m_2 = 25$ are shown in  Fig.~{\\ref{input_time_f25}} and Fig.~{\\ref{input_spectrum_f25}} respectively\\footnote{We have omitted plotting the corresponding graphs for the signal with sparsity $m_1=5$ owing to space constraints.}. Table~\\ref{tab:tableresults} shows the comparison between compressed sensing and compressed shattering in terms of number of measurements to be stored and number of additions and multiplications. Although $T=100$ filters are used in the compressed shattering algorithm ($\\sigma$=11), very few shattered signals have significant energy indicating that most of them are 0-sparse. By choosing a threshold of 0.01 for the $||y_g||_2$, only very few shattered signals are retained as 1-sparse output signals. The measurements for compressed shattering are complex values whereas as compressed sensing yields real measurement values. However, in the table we have indicated number of real measurements which implies that we have multiplied the number of measurements for compressed shattering by 2. In all cases\\footnote{We omit displaying the reconstructed outputs owing to space constraints.}, we obtained near-perfect reconstruction since the maximum absolute reconstruction error was $ < 10^{-11}$.\n\nFrom the table, we can infer that there is a tradeoff between the number of measurements that have to be stored and the computational complexity involved in taking the initial measurement. Only half the number of real values have to be stored in the case of compressed shattering compared to the conventional compressed sensing method, but the computational complexity of the former is a little more than twice that of the latter in terms of both number of addition and multiplication. This is the price we pay for the reduction in number of measurements. It also should be noted that the algorithm, as of now, is heavily dependent on the $\\sigma$ we choose.  So if we choose the wrong $\\sigma$ the algorithm might fail because one of the filters might pick up more than one frequency.\n\nA plot of number of measurements stored versus the sparsity $m$ is shown in Fig.~\\ref{measurment_vs_m_N16384}, for $N = 2^{14}$.  The flexibility of compressed shattering to the sparsity range is evident when compared to traditional compressed sensing and thus results in huge gains, especially when sparsity $m$ is small.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!ht]\n\t\\centering\n\t\\includegraphics[width = 3.4in]{input_time_f25.eps}\n\t\\caption{The input real valued signal $x(n)$ of length $N=1000$, which has a sparsity of $m_2 = 25$ frequencies. }\n\t\\label{input_time_f25}\n\\end{figure}\n\n\\begin{figure}[!ht]\n\t\\centering\n\t\\includegraphics[width = 3.4in]{input_spectrum_f25.eps}\n\t\\caption{Absolute value of the spectrum $X(k)$ of the input shown in Fig. \\ref{input_time_f25}.}\n\t\\label{input_spectrum_f25}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!ht]\n\t\\centering\n\t\\includegraphics[width = 3.4in]{measurements_vs_m_N16384.eps}\n\t\\caption{The graph shows a comparison of the number of measurements stored, for both compressed sensing and compressed shattering,  when subjected to the same input of length $2^{14}$ which has $m$ frequencies and $m$ is varied from $4 - 1024$. The number of filters used in the compressed shattering algorithm is $T=2048$. The number of measurements to be stored by compressed shattering is $(4 \\cdot m)$, while for compressed sensing it is always fixed at 6144 ($=6 \\cdot 1024$). Here, the gains provided by compressed shattering over compressed sensing method can be clearly observed, especially for small $m$.}\n\t\\label{measurment_vs_m_N16384}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Conclusions and Future Research Work}\nWe have proposed Compressed Shattering - a novel way of extending compressed sensing when the sparsity of the input signal is within a specified range. The idea of using a linear congruential generator on the discrete-time indices helps to randomize the frequency components, and thus in de-clustering the spectrum. This is then exploited by creating 1-sparse signals by means of a filter-bank. Reconstruction  is very fast owing to a simple deterministic sensing matrix that we have proposed for 1-sparse signals. It is conceivable that a more sophisticated PRNG could be used to efficiently de-cluster the spectrum. Compressed Shattering outperforms traditional compressed sensing in terms of number of measurements that needs to be stored but at the cost of increased computational cost. Future research directions include studying compressed shattering in the presence of noise, finding optimal choices for $\\sigma$, an enhanced PRNG, and a faster algorithm for generating shattered signals.\n\n\n\n\n\n\\begin{thebibliography}{1}\n\t\n\t\n\t\\bibitem{Candes}\n\tE.~J.~Candes and M.~B.~Wakin, ``An Introduction to Compressive Sampling,''\n\t\\emph{IEEE Signal Processing Magazine}, vol.\\ 114, pp.~21--30, 2008.\n\t\n\t\\bibitem{Tao}\n\tE.~J.~Candes and T.~Tao, ``Near-Optimal Signal Recovery From Random Projections: Universal Encoding Strategies? ''\n\t\\emph{IEEE Transactions on Information Theory}, vol.\\ 52, pp.~5406--5425, 2006.\n\t\n\t\n\t\\bibitem{Gilbert}\n\tJ.~A.~T.~C.~Gilbert, M.~J.~ Strauss, ``A Tutorial on Fast Fourier Sampling,''\n\t\\emph{IEEE Signal Processing Magazine}, vol.\\ 25, pp.~57--66, 2008.\n\t\n\t\\bibitem{Gilbert2}\n\tA.~C.~Gilbert, S.~Muthukrishnan, M.~Strauss, ``Improved Time Bounds for Near-Optimal Sparse Fourier\n\tRepresentations,''\n\t\\emph{in Proc. SPIE Wavelets XI}, M.~Papdakis, A.~F.~Laine, and M.~A.~Unser, Eds., San Diego, CA, 2005, pp.~59141A.1\u00c2\u009615.\n\t\n\t\n\t\n\t\n\\end{thebibliography}\n\n\n\n", "itemtype": "equation", "pos": 18845, "prevtext": "\n\n\n", "index": 43, "text": "\\begin{equation}\n\\setlength{\\nulldelimiterspace}{0pt}\n\\left[ \\begin{array}{c} \\gamma_{1}\\\\\\gamma_{2}\\\\.\\\\.\\\\.\\\\\\gamma_{T}\\end{array} \\right]_{2T\\times N}\\cdot\\;\\;\\;\\;\\; x_{N \\times 1}\\;\\; = \\left[ \\begin{array}{c} y_{1}\\\\y_{2}\\\\.\\\\.\\\\.\\\\y_{T}\\end{array} \\right]_{2T\\times 1}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E22.m1\" class=\"ltx_Math\" alttext=\"\\left[\\begin{array}[]{c}\\gamma_{1}\\\\&#10;\\gamma_{2}\\\\&#10;.\\\\&#10;.\\\\&#10;.\\\\&#10;\\gamma_{T}\\end{array}\\right]_{2T\\times N}\\cdot\\;\\;\\;\\;\\;x_{N\\times 1}\\;\\;=%&#10;\\left[\\begin{array}[]{c}y_{1}\\\\&#10;y_{2}\\\\&#10;.\\\\&#10;.\\\\&#10;.\\\\&#10;y_{T}\\end{array}\\right]_{2T\\times 1}.\" display=\"block\"><mrow><msub><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>\u03b3</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>\u03b3</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>\u03b3</mi><mi>T</mi></msub></mtd></mtr></mtable><mo>]</mo></mrow><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>T</mi></mrow><mo>\u00d7</mo><mi>N</mi></mrow></msub><mo>\u22c5</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003</mo><mpadded width=\"+5.6pt\"><msub><mi>x</mi><mrow><mi>N</mi><mo>\u00d7</mo><mn>1</mn></mrow></msub></mpadded><mo>=</mo><msub><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>y</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>y</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi/><mo>.</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>y</mi><mi>T</mi></msub></mtd></mtr></mtable><mo>]</mo></mrow><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>T</mi></mrow><mo>\u00d7</mo><mn>1</mn></mrow></msub><mo>.</mo></mrow></math>", "type": "latex"}]