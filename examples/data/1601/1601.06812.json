[{"file": "1601.06812.tex", "nexttext": "\nwhere $A \\in \\mathbb{R}^{n \\times n}$ is symmetric indefinite, is generally done by first obtaining the symmetric indefinite factorization \n\n", "itemtype": "equation", "pos": 6663, "prevtext": "\n\n\\maketitle\n\n\n\\begin{abstract} \nWe propose a new pivot selection technique for symmetric indefinite factorization of sparse matrices.\nSuch factorization should maintain both sparsity and numerical stability of the factors, both of which depend solely on the choices of the pivots.\nOur method is based on the minimum degree algorithm and also considers the stability of the factors at the same time.\n\n\nOur experiments show that our method produces factors that are sparser than the factors computed by MA57 \\cite{MA57} and are stable.\n\n\n\\end{abstract}\n\n\\section{Introduction}\n\n\nThere are two general approaches to solving linear systems: direct and iterative methods.\nIterative methods start with an initial guess and successively generate better approximate solutions at each iteration.\nThe running time of an iterative method depends directly on the required accuracy of the solution.\nDirect methods, on the other hand, attempt to find the solution by a finite number of operations and usually involve factoring the matrix.  \n\nOur work here is on direct methods for solving linear systems where the matrix is symmetric indefinite and sparse, which has many applications in linear and nonlinear optimization and finite element computation, for example.  Symmetric indefinite factorization (SIF) is not unique as the resulting factors depend on the choices of the pivots during the factorization.  Pivots should be chosen such that the resulting factors are stable and do not have many fill-ins---the entries that are zeros in the original matrix but are nonzeros in the factors.  \n\nThere are many heuristic techniques for selecting pivots to minimize the number of fill-ins for the related problem of Cholesky factorization, which is the most suitable factorization for symmetric positive definite matrices, in literature.  We briefly discuss a few such well-known techniques here since some of their ideas are also applicable to SIF.\nThese ordering algorithms can be classified into three classes: local, global, and hybrid approaches.\nLocal approach such as the minimum degree and the minimum fill algorithms \\cite{MD1, MD2, MD3, MDevol, MFNP} selects the pivot that is expected to minimize the number of fill-ins at each factorization step in a greedy fashion.  Global approach such as Cuthill-McKee and nested dissection methods \\cite{CM, ND, NDgen} selects pivots by considering the overall structure of the matrix.  Hybrid approach, on the other hand, combines the ideas from both local and global approaches.\n\nThe well-known minimum degree algorithm \\cite{MD1} chooses the column that has the minimum off-diagonal nonzero elements in the remaining matrix as the pivot for the current step.  \n\n\n\nDifferent improvements of the minimum degree algorithm have been proposed \\cite{MDevol} such as multiple minimum degree \\cite{MMD1} and approximate minimum degree algorithms \\cite{AMD1} and become the practical standard in the implementations.\n\nAnother famous pivot selection algorithm is nested dissection \\cite{ND}.  By defining a graph whose vertices represent each column of the matrix and whose edges represent nonzero entries in the matrix, nested dissection recursively find a separator---a set of vertices that partitions the graph into two disconnected subgraphs---and ordering the pivots recursively with the two subgraphs first followed by the separator vertices.  Cuthill-McKee \\cite{CM} propose another pivot selection algorithm that aims to reduce the bandwidth of the matrix based on breadth first search of the  structure graph.\n\nThe main difference between Cholesky factorization and SIF is in the size of pivots.  For SIF, each pivot can be either a scalar or a 2-by-2 matrix while pivots in Cholesky factorization are all scalar.\nMoreover, unlike Cholesky factorization, the choice of pivots in SIF also affects the stability of the resulting factors \\cite{SIF1}.\n\nThere are many pivot selection algorithms proposed specifically for SIF such as \nBunch-Parlett \\cite{BP}, Bunch-Kaufman \\cite{BK}, and bounded Bunch Kaufman (BBK) \\cite{BBK} algorithms.\nBunch-Parlett method searches the whole remaining submatrix at each stage for the largest-magnitude diagonal and the largest-magnitude off-diagonal.  It chooses the largest-magnitude diagonal as the 1-by-1 pivot if the resulting growth rate is acceptable.  Otherwise, it selects the largest-magnitude off-diagonal and its relative diagonal elements as the 2-by-2 pivot block. \nThis method requires $O(n^3)$ comparisons and yields a matrix  $L$ whose maximum element is bounded by 2.781.\nBunch-Kaufman pivoting strategy searches for the largest-magnitude off-diagonal elements of at most two columns for each iteration. It requires $O(n^2)$ comparisons, but the elements in $L$ are unbounded. \nBBK combines the two above strategies.  By monitoring the size of the elements in $L$, BBK uses the Bunch-Kaufman strategy when it yields modest element growth. Otherwise, it repeatedly searches for an acceptable pivot.\nIn average cases, the total cost of BBK is the same as Bunch-Kaufman, but in the worst cases its cost can be the same as that of the Bunch-Parlett strategy.  \n\nAdditionally, there are other types of techniques for solving symmetric indefinite linear systems.  Paige and Saunders \\cite{SSIF1} propose two algorithms, SYMMLQ and MINRES, for solving such systems.  The algorithms apply orthogonal factorization together with the conjugate gradient method to solve the system.  Duff et al.\\ \\cite{SSIF2} propose a pivotal strategy for decomposing sparse symmetric indefinite matrices that limits the magnitude of the element in the factors for stability.\n\nDuff and Reid \\cite{MFrontal1} propose a multifrontal method to solve indefinite sparse symmetric linear systems based on minimum-degree ordering.\nThe multifrontal approach is widely used in many sparse direct solvers, for example, MA57 and MUMPS \\cite{DS1, MA57}.\n\nWe propose a new pivot selection algorithm for sparse SIF.  Our algorithm applies the idea of minimum-degree ordering to consider both 1-by-1 and 2-by-2 pivots while also considers the stability of the resulting factors.  Our experiments show that our algorithm produces stable factors that are sparser than the factors produced by \\cite{MA57}.\n\nFor the rest of the article, we describe symmetric indefinite factorization in Section \\ref{sec2}.  Section \\ref{sec3} explains the minimum-degree ordering algorithm.  Section \\ref{sec4} describes our algorithm.  Section \\ref{sec5} shows our experiment and the results.  Finally, we conclude the article in Section \\ref{sec6}.\n\n\n\n\n\n\\section{Symmetric Indefinite Factorization}\\label{sec2}\nSolving a linear system\n\n", "index": 1, "text": "\\begin{equation}\\label{eq1}\nAx = b,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"Ax=b,\" display=\"block\"><mrow><mrow><mrow><mi>A</mi><mo>\u2062</mo><mi>x</mi></mrow><mo>=</mo><mi>b</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nwhere $P$ is a permutation matrix, $L$ is a unit lower triangular matrix, and $B$ is a block diagonal matrix\n", "itemtype": "equation", "pos": 6854, "prevtext": "\nwhere $A \\in \\mathbb{R}^{n \\times n}$ is symmetric indefinite, is generally done by first obtaining the symmetric indefinite factorization \n\n", "index": 3, "text": "\\begin{equation}\\label{eq2}\nP^{T}AP = LBL^{T},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"P^{T}AP=LBL^{T},\" display=\"block\"><mrow><mrow><mrow><msup><mi>P</mi><mi>T</mi></msup><mo>\u2062</mo><mi>A</mi><mo>\u2062</mo><mi>P</mi></mrow><mo>=</mo><mrow><mi>L</mi><mo>\u2062</mo><mi>B</mi><mo>\u2062</mo><msup><mi>L</mi><mi>T</mi></msup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nwhere each block $B^{(k)}$ is either a 1-by-1 or 2-by-2 matrix and is nonsingular.  Matrix $P$ represents the pivoting---the exchanging of rows and columns of $A$---during the factorization in order to maintain both sparsity and stability of the factor.\nAfter obtaining the factorization, back and forward substitutions are used to compute the solution of (\\ref{eq1}) by the following steps:\n\\begin{enumerate}\n\\item[(i)]\\label{step1} Solve $z$ : $Lz  =   P^T b$.\n\\item[(ii)]\\label{step2} Solve $\\hat{z}$ : $B\\hat{z} = z$.\n\\item[(iii)]\\label{step3}Solve $\\bar{z}$ : $L^T\\bar{z}= \\hat{z}$.\n\\item[(iv)]\\label{step4}Set : $x=P\\bar{z}$.\n\\end{enumerate}\n\n\nRecall that Steps (ii) and (iv) are trivial (due to the structure of $P$ and $B$) and therefore the computational time for solving the linear system depends solely on the factorization and back and forward substitutions in Steps (i) and (iii), which in turn depend on the sparsity of $L$.  \n\nTo perform symmetric indefinite factorization, let $A^{(k)}$ be the (smaller) matrix that remains to be factorized in the $k$th iteration. The algorithm starts with $A^{(1)}=A$. \nFor each iteration, we first identify a submatrix $B^{(k)}$ from elements of $A^{(k)}$ that is suitable to be used as the pivot block.\n\n\nThe submatrix $B^{(k)}$ is either a single diagonal element of $A^{(k)}$  \n$\\left(\\left\\lbrack a^{(k)}_{ll} \\right\\rbrack\\right)$\n or a 2-by-2 block with two diagonal elements of $A^{(k)}$  \n$\\left(\\begin{bmatrix} a^{(k)}_{ll}  & a^{(k)}_{lr} \\\\  a^{(k)}_{rl} & a^{(k)}_{rr}  \\end{bmatrix}\\right)$. \nNote that there are many methods to select the pivot (We explain pivot selection algorithms and our proposed pivot selection algorithm in the next section).  Next, we find the permutation matrix $P^{(k)}$ satisfying\n\n", "itemtype": "equation", "pos": 7024, "prevtext": "\nwhere $P$ is a permutation matrix, $L$ is a unit lower triangular matrix, and $B$ is a block diagonal matrix\n", "index": 5, "text": "\n\\[\nB=\n\\begin{bmatrix} B^{(1)}      & 0          &\\cdots  & 0        \\\\     \n                     0          & B^{(2)}      &\\cdots  & 0        \\\\\n                     \\vdots  & \\vdots &\\ddots  & \\vdots\\\\\n                     0          & 0          &\\cdots  & B^{(K)}    \\end{bmatrix},\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"B=\\begin{bmatrix}B^{(1)}&amp;0&amp;\\cdots&amp;0\\\\&#10;0&amp;B^{(2)}&amp;\\cdots&amp;0\\\\&#10;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\&#10;0&amp;0&amp;\\cdots&amp;B^{(K)}\\end{bmatrix},\" display=\"block\"><mrow><mrow><mi>B</mi><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msup><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><msup><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22f1</mi></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><msup><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nThat is, $P^{(k)}$ is the permutation matrix corresponding to the exchanges of rows and columns that move the chosen pivot to the top-left corner.  The right-hand side of (\\ref{eq3}) can be factorized as\n\\begin{eqnarray} \\label{eq4}\n(P^{(k)})^TA^{(k)}P^{(k)}&=&\\begin{bmatrix} I  & 0   \\\\  C^{(k)}(B^{(k)})^{-1}    & I \\end{bmatrix}\\cdot\n\\begin{bmatrix} B^{(k)}  & 0   \\\\      0    & Z^{(k)}-C^{(k)}(B^{(k)})^{-1} (C^{(k)})^T  \\end{bmatrix}\\cdot\\nonumber\\\\\n&&\\begin{bmatrix} I  & (B^{(k)})^{-1}(C^{(k)})^T   \\\\   0     & I  \\end{bmatrix}.\n\\end{eqnarray}\nLet $L^{(k)} = C^{(k)}(B^{(k)})^{-1}$ and $A^{(k+1)}$ = $Z^{(k)}-C^{(k)}(B^{(k)})^{-1}(C^{(k)})^T$. Equation (\\ref{eq4}) can be rewritten as\n\n", "itemtype": "equation", "pos": 9088, "prevtext": "\nwhere each block $B^{(k)}$ is either a 1-by-1 or 2-by-2 matrix and is nonsingular.  Matrix $P$ represents the pivoting---the exchanging of rows and columns of $A$---during the factorization in order to maintain both sparsity and stability of the factor.\nAfter obtaining the factorization, back and forward substitutions are used to compute the solution of (\\ref{eq1}) by the following steps:\n\\begin{enumerate}\n\\item[(i)]\\label{step1} Solve $z$ : $Lz  =   P^T b$.\n\\item[(ii)]\\label{step2} Solve $\\hat{z}$ : $B\\hat{z} = z$.\n\\item[(iii)]\\label{step3}Solve $\\bar{z}$ : $L^T\\bar{z}= \\hat{z}$.\n\\item[(iv)]\\label{step4}Set : $x=P\\bar{z}$.\n\\end{enumerate}\n\n\nRecall that Steps (ii) and (iv) are trivial (due to the structure of $P$ and $B$) and therefore the computational time for solving the linear system depends solely on the factorization and back and forward substitutions in Steps (i) and (iii), which in turn depend on the sparsity of $L$.  \n\nTo perform symmetric indefinite factorization, let $A^{(k)}$ be the (smaller) matrix that remains to be factorized in the $k$th iteration. The algorithm starts with $A^{(1)}=A$. \nFor each iteration, we first identify a submatrix $B^{(k)}$ from elements of $A^{(k)}$ that is suitable to be used as the pivot block.\n\n\nThe submatrix $B^{(k)}$ is either a single diagonal element of $A^{(k)}$  \n$\\left(\\left\\lbrack a^{(k)}_{ll} \\right\\rbrack\\right)$\n or a 2-by-2 block with two diagonal elements of $A^{(k)}$  \n$\\left(\\begin{bmatrix} a^{(k)}_{ll}  & a^{(k)}_{lr} \\\\  a^{(k)}_{rl} & a^{(k)}_{rr}  \\end{bmatrix}\\right)$. \nNote that there are many methods to select the pivot (We explain pivot selection algorithms and our proposed pivot selection algorithm in the next section).  Next, we find the permutation matrix $P^{(k)}$ satisfying\n\n", "index": 7, "text": "\\begin{equation} \\label{eq3}\n(P^{(k)})^TA^{(k)}P^{(k)}=\\begin{bmatrix} B^{(k)}     & (C^{(k)})^T   \\\\      C^{(k)}  & Z^{(k)}       \\end{bmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"(P^{(k)})^{T}A^{(k)}P^{(k)}=\\begin{bmatrix}B^{(k)}&amp;(C^{(k)})^{T}\\\\&#10;C^{(k)}&amp;Z^{(k)}\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mrow><msup><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mi>T</mi></msup><mo>\u2062</mo><msup><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo>\u2062</mo><msup><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msup><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><msup><mrow><mo stretchy=\"false\">(</mo><msup><mi>C</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mi>T</mi></msup></mtd></mtr><mtr><mtd columnalign=\"center\"><msup><mi>C</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><msup><mi>Z</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nThe same process can be repeated recursively on the matrix $A^{(k+1)}$. Note that the dimension of  $A^{(k+1)}$ is less than the dimension of $A^{(k)}$ by either one or two depending on the dimension of $B^{(k)}$.\n\n\n\n\n\\section{Pivot selection with Minimum Degree} \\label{sec3}\nFinding the optimal ordering that minimizes fill-in is NP-hard \\cite{MFNP} therefore a heuristic is often used for pivot selection. \nChoosing pivot at each step should be inexpensive, lead to at most modest growth in the elements of the remaining matrix, and not cause $L$ to be too much denser than the original matrix.  One of the well-known and efficient pivot selection techniques is the minimum degree algorithm \\cite{MD1, MD2, MD3}.\nThe algorithm considers the pivot based on the following graph model. \nDefine an undirected graph $G=(V,E)$, where $V=\\{1,...,n\\}$ and $E=\\{\\{i,j\\}:i\\neq j$ and $a_{ij}\\neq 0\\}$.\nObserve that the degree of $v$ ($\\text{deg}(v)$), where $v \\in V$, is the number of nonzero off-diagonal elements on the $v$th row.\nThe vertex $v$ with minimum $\\text{deg}(v)$ is chosen as the pivot.\n\nDefine the elimination graph $G_v=(V\\setminus \\{v\\},E')$, where $E'=E\\cup\\{\\{i,j\\}:\\{i,v\\}\\in E \\mbox{ and }\\{v,j\\}\\in E\\}\\setminus \\{\\{v,i\\}:i=1,2,...,n\\}$.\nGraph $G_v$ is used to choose the next pivot, and so on.\nThat is, the minimum degree algorithm is as follows. \n\n\n\\begin{algorithm}\n\\caption{Minimum Degree Algorithm}\\label{algo1}\n\\begin{algorithmic}\n\\STATE Define $G$ as described above.\n\\WHILE{ $G \\neq \\emptyset$}\n\\STATE  $v$ = the vertex with minimum $\\text{deg}(v)$\n \\STATE  $G=G_v$\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\nNote that the minimum degree algorithm identifies the pivot at each step without any numerical calculation.\nFor this reason, it can be used as the ordering step before factorizing the matrix.\n\n\n\nMany improvements of the minimum degree algorithm and its implementation have been proposed \\cite{MDevol} such as decreasing the computation time for the degree update by considering the indistinguishable nodes \\cite{massEli} or minimum degree independent nodes \\cite{MMD1}, reducing the computation cost by using an approximate minimum degree \\cite{AMD1}, and saving space by using the quotient graph model \\cite{quotGraph}.\n\n\n\n\n\n\n\\section{Our pivot selection algorithm} \\label{sec4}\n\nUnlike in Cholesky factorization, pivots in symmetric indefinite factorization can be either a scalar or a $2$-by-$2$ matrix therefore the minimum degree algorithm cannot be used as is in this case. \n\n\n\n\n\n\n\nThe stability condition that our algorithm uses is proposed by Duff et~al.\\ \\cite{stCond} and also used as a thresholding test for 1-by-1 and 2-by-2 pivots in MA57 \\cite{MA57}.\nWe consider a 1-by-1 pivot $a_{ii}$ to be \\emph{acceptably stable} if\n\n", "itemtype": "equation", "pos": 9945, "prevtext": "\nThat is, $P^{(k)}$ is the permutation matrix corresponding to the exchanges of rows and columns that move the chosen pivot to the top-left corner.  The right-hand side of (\\ref{eq3}) can be factorized as\n\\begin{eqnarray} \\label{eq4}\n(P^{(k)})^TA^{(k)}P^{(k)}&=&\\begin{bmatrix} I  & 0   \\\\  C^{(k)}(B^{(k)})^{-1}    & I \\end{bmatrix}\\cdot\n\\begin{bmatrix} B^{(k)}  & 0   \\\\      0    & Z^{(k)}-C^{(k)}(B^{(k)})^{-1} (C^{(k)})^T  \\end{bmatrix}\\cdot\\nonumber\\\\\n&&\\begin{bmatrix} I  & (B^{(k)})^{-1}(C^{(k)})^T   \\\\   0     & I  \\end{bmatrix}.\n\\end{eqnarray}\nLet $L^{(k)} = C^{(k)}(B^{(k)})^{-1}$ and $A^{(k+1)}$ = $Z^{(k)}-C^{(k)}(B^{(k)})^{-1}(C^{(k)})^T$. Equation (\\ref{eq4}) can be rewritten as\n\n", "index": 9, "text": "\\begin{equation} \\label{eq5}\n(P^{(k)})^TA^{(k)}P^{(k)}=\n\\begin{bmatrix} I  & 0   \\\\     L^{(k)}   & I \\end{bmatrix}\\cdot\n\\begin{bmatrix} B^{(k)}  & 0   \\\\      0    & A^{(k+1)} \\end{bmatrix}\\cdot\n\\begin{bmatrix} I  &    (L^{(k)})^T \\\\0& I \\end{bmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"(P^{(k)})^{T}A^{(k)}P^{(k)}=\\begin{bmatrix}I&amp;0\\\\&#10;L^{(k)}&amp;I\\end{bmatrix}\\cdot\\begin{bmatrix}B^{(k)}&amp;0\\\\&#10;0&amp;A^{(k+1)}\\end{bmatrix}\\cdot\\begin{bmatrix}I&amp;(L^{(k)})^{T}\\\\&#10;0&amp;I\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mrow><msup><mrow><mo stretchy=\"false\">(</mo><msup><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mi>T</mi></msup><mo>\u2062</mo><msup><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo>\u2062</mo><msup><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><mo>=</mo><mrow><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mi>I</mi></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><msup><mi>L</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><mi>I</mi></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u22c5</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msup><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><msup><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u22c5</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mi>I</mi></mtd><mtd columnalign=\"center\"><msup><mrow><mo stretchy=\"false\">(</mo><msup><mi>L</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mi>T</mi></msup></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mi>I</mi></mtd></mtr></mtable><mo>]</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nSimilarly, a 2-by-2 pivot $\\begin{bmatrix} a_{ii}&a_{ij}\\\\a_{ji}&a_{jj}\\end{bmatrix}$ is considered to be \\emph{acceptably stable} if \n\n", "itemtype": "equation", "pos": 12983, "prevtext": "\nThe same process can be repeated recursively on the matrix $A^{(k+1)}$. Note that the dimension of  $A^{(k+1)}$ is less than the dimension of $A^{(k)}$ by either one or two depending on the dimension of $B^{(k)}$.\n\n\n\n\n\\section{Pivot selection with Minimum Degree} \\label{sec3}\nFinding the optimal ordering that minimizes fill-in is NP-hard \\cite{MFNP} therefore a heuristic is often used for pivot selection. \nChoosing pivot at each step should be inexpensive, lead to at most modest growth in the elements of the remaining matrix, and not cause $L$ to be too much denser than the original matrix.  One of the well-known and efficient pivot selection techniques is the minimum degree algorithm \\cite{MD1, MD2, MD3}.\nThe algorithm considers the pivot based on the following graph model. \nDefine an undirected graph $G=(V,E)$, where $V=\\{1,...,n\\}$ and $E=\\{\\{i,j\\}:i\\neq j$ and $a_{ij}\\neq 0\\}$.\nObserve that the degree of $v$ ($\\text{deg}(v)$), where $v \\in V$, is the number of nonzero off-diagonal elements on the $v$th row.\nThe vertex $v$ with minimum $\\text{deg}(v)$ is chosen as the pivot.\n\nDefine the elimination graph $G_v=(V\\setminus \\{v\\},E')$, where $E'=E\\cup\\{\\{i,j\\}:\\{i,v\\}\\in E \\mbox{ and }\\{v,j\\}\\in E\\}\\setminus \\{\\{v,i\\}:i=1,2,...,n\\}$.\nGraph $G_v$ is used to choose the next pivot, and so on.\nThat is, the minimum degree algorithm is as follows. \n\n\n\\begin{algorithm}\n\\caption{Minimum Degree Algorithm}\\label{algo1}\n\\begin{algorithmic}\n\\STATE Define $G$ as described above.\n\\WHILE{ $G \\neq \\emptyset$}\n\\STATE  $v$ = the vertex with minimum $\\text{deg}(v)$\n \\STATE  $G=G_v$\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\nNote that the minimum degree algorithm identifies the pivot at each step without any numerical calculation.\nFor this reason, it can be used as the ordering step before factorizing the matrix.\n\n\n\nMany improvements of the minimum degree algorithm and its implementation have been proposed \\cite{MDevol} such as decreasing the computation time for the degree update by considering the indistinguishable nodes \\cite{massEli} or minimum degree independent nodes \\cite{MMD1}, reducing the computation cost by using an approximate minimum degree \\cite{AMD1}, and saving space by using the quotient graph model \\cite{quotGraph}.\n\n\n\n\n\n\n\\section{Our pivot selection algorithm} \\label{sec4}\n\nUnlike in Cholesky factorization, pivots in symmetric indefinite factorization can be either a scalar or a $2$-by-$2$ matrix therefore the minimum degree algorithm cannot be used as is in this case. \n\n\n\n\n\n\n\nThe stability condition that our algorithm uses is proposed by Duff et~al.\\ \\cite{stCond} and also used as a thresholding test for 1-by-1 and 2-by-2 pivots in MA57 \\cite{MA57}.\nWe consider a 1-by-1 pivot $a_{ii}$ to be \\emph{acceptably stable} if\n\n", "index": 11, "text": "\\begin{equation} \\label{eq6}\n|a_{ii}|\\geq \\alpha\\max_{r\\neq i}  |a_{ri}|.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"|a_{ii}|\\geq\\alpha\\max_{r\\neq i}|a_{ri}|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>i</mi></mrow></msub><mo stretchy=\"false\">|</mo></mrow><mo>\u2265</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><munder><mi>max</mi><mrow><mi>r</mi><mo>\u2260</mo><mi>i</mi></mrow></munder><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><msub><mi>a</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>i</mi></mrow></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nConditions (\\ref{eq6}) and (\\ref{eq7}) limit the magnitudes of the entries of $L$ to $1/\\alpha$ at most.\nThe appropriate value of $\\alpha$ is $0<\\alpha\\leq 0.5$.\nThe default value of $\\alpha$ in MA57 is 0.01 \\cite{MA57}.\n\nLet us call the column with the fewest number of off-diagonal nonzeros the \\textit{minimum degree column}.\nLet $i$ be the minimum degree column of the matrix $A$.\nWe accept $a_{ii}$ as the 1-by-1 pivot $(B^{(k)})$ if $a_{ii}$ satisfies (\\ref{eq6}).\nOtherwise, we proceed to search for a suitable 2-by-2 pivot $\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ that satisfies (\\ref{eq7}) as follows.\nLet \n\n", "itemtype": "equation", "pos": 13207, "prevtext": "\nSimilarly, a 2-by-2 pivot $\\begin{bmatrix} a_{ii}&a_{ij}\\\\a_{ji}&a_{jj}\\end{bmatrix}$ is considered to be \\emph{acceptably stable} if \n\n", "index": 13, "text": "\\begin{equation}\\label{eq7}\n\\left|\\begin{bmatrix} a_{ii}&a_{ij}\\\\a_{ji}&a_{jj}\\end{bmatrix}^{-1}\\right|\n\\cdot \\begin{bmatrix}\\max_{r\\neq i, r\\neq j} |a_{ri}|\\\\ \\max_{r\\neq i, r\\neq j}|a_{rj}|\\end{bmatrix}\n\\leq\n\\begin{bmatrix}\\alpha^{-1}\\\\\\alpha^{-1}\\end{bmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\left|\\begin{bmatrix}a_{ii}&amp;a_{ij}\\\\&#10;a_{ji}&amp;a_{jj}\\end{bmatrix}^{-1}\\right|\\cdot\\begin{bmatrix}\\max_{r\\neq i,r\\neq j%&#10;}|a_{ri}|\\\\&#10;\\max_{r\\neq i,r\\neq j}|a_{rj}|\\end{bmatrix}\\leq\\begin{bmatrix}\\alpha^{-1}\\\\&#10;\\alpha^{-1}\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mrow><mrow><mo>|</mo><msup><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>a</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>i</mi></mrow></msub></mtd><mtd columnalign=\"center\"><msub><mi>a</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>a</mi><mrow><mi>j</mi><mo>\u2062</mo><mi>i</mi></mrow></msub></mtd><mtd columnalign=\"center\"><msub><mi>a</mi><mrow><mi>j</mi><mo>\u2062</mo><mi>j</mi></mrow></msub></mtd></mtr></mtable><mo>]</mo></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>|</mo></mrow><mo>\u22c5</mo><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><msub><mi>max</mi><mrow><mrow><mi>r</mi><mo>\u2260</mo><mi>i</mi></mrow><mo>,</mo><mrow><mi>r</mi><mo>\u2260</mo><mi>j</mi></mrow></mrow></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><msub><mi>a</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>i</mi></mrow></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><msub><mi>max</mi><mrow><mrow><mi>r</mi><mo>\u2260</mo><mi>i</mi></mrow><mo>,</mo><mrow><mi>r</mi><mo>\u2260</mo><mi>j</mi></mrow></mrow></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><msub><mi>a</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo stretchy=\"false\">|</mo></mrow></mrow></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>\u2264</mo><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msup><mi>\u03b1</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd></mtr><mtr><mtd columnalign=\"center\"><msup><mi>\u03b1</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nConsider all submatrices $\\begin{bmatrix} a_{ii}&a_{iz}\\\\a_{zi}&a_{zz}\\end{bmatrix}$, where $z \\in Z_i$, as the candidates for a $2$-by-$2$ pivot.  The degree of each candidate $\\text{deg}(i,z)$ is the number of rows $l$ where $l \\neq i, z$ and at lease one of $a_{li}$ and $a_{lz}$ is nonzero.  To compute $\\text{deg}(i,z)$, define\n\n", "itemtype": "equation", "pos": 14129, "prevtext": "\nConditions (\\ref{eq6}) and (\\ref{eq7}) limit the magnitudes of the entries of $L$ to $1/\\alpha$ at most.\nThe appropriate value of $\\alpha$ is $0<\\alpha\\leq 0.5$.\nThe default value of $\\alpha$ in MA57 is 0.01 \\cite{MA57}.\n\nLet us call the column with the fewest number of off-diagonal nonzeros the \\textit{minimum degree column}.\nLet $i$ be the minimum degree column of the matrix $A$.\nWe accept $a_{ii}$ as the 1-by-1 pivot $(B^{(k)})$ if $a_{ii}$ satisfies (\\ref{eq6}).\nOtherwise, we proceed to search for a suitable 2-by-2 pivot $\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ that satisfies (\\ref{eq7}) as follows.\nLet \n\n", "index": 15, "text": "\\begin{equation}\n\\label{eq10}\nZ_i = \\{ z | a_{iz}\\neq 0 \\mbox{ and } z\\neq i\\}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"Z_{i}=\\{z|a_{iz}\\neq 0\\mbox{ and }z\\neq i\\}.\" display=\"block\"><mrow><mrow><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>z</mi><mo stretchy=\"false\">|</mo><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>z</mi></mrow></msub><mo>\u2260</mo><mrow><mn>0</mn><mo>\u2062</mo><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><mi>z</mi></mrow><mo>\u2260</mo><mi>i</mi></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nHence,\n\n", "itemtype": "equation", "pos": 14557, "prevtext": "\nConsider all submatrices $\\begin{bmatrix} a_{ii}&a_{iz}\\\\a_{zi}&a_{zz}\\end{bmatrix}$, where $z \\in Z_i$, as the candidates for a $2$-by-$2$ pivot.  The degree of each candidate $\\text{deg}(i,z)$ is the number of rows $l$ where $l \\neq i, z$ and at lease one of $a_{li}$ and $a_{lz}$ is nonzero.  To compute $\\text{deg}(i,z)$, define\n\n", "index": 17, "text": "\\begin{equation} \\label{eq8}\nd(i,z,l)=\\left\\{\n\\begin{array}{ll}\n0 ,& \\mbox{if } a_{li}=0 \\mbox{ and } a_{lz} = 0,\\\\\n1 ,& \\mbox{otherwise.} \n\\end{array}\n\\right.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"d(i,z,l)=\\left\\{\\begin{array}[]{ll}0,&amp;\\mbox{if }a_{li}=0\\mbox{ and }a_{lz}=0,%&#10;\\\\&#10;1,&amp;\\mbox{otherwise.}\\end{array}\\right.\" display=\"block\"><mrow><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>l</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mn>0</mn><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>i</mi></mrow></msub></mrow><mo>=</mo><mrow><mn>0</mn><mo>\u2062</mo><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>l</mi><mo>\u2062</mo><mi>z</mi></mrow></msub></mrow><mo>=</mo><mn>0</mn></mrow><mo>,</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mn>1</mn><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mtext>otherwise.</mtext></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nOur algorithm then considers all of the candidates with the minimum out-degree.  Specifically, \n$\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ is qualified if\n\n", "itemtype": "equation", "pos": 14739, "prevtext": "\nHence,\n\n", "index": 19, "text": "\\begin{equation} \\label{eq9}\n\\text{deg}(i,z) = \\sum_{l\\neq i,z}d(i,z,l).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\text{deg}(i,z)=\\sum_{l\\neq i,z}d(i,z,l).\" display=\"block\"><mrow><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>l</mi><mo>\u2260</mo><mrow><mi>i</mi><mo>,</mo><mi>z</mi></mrow></mrow></munder><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>l</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06812.tex", "nexttext": "\nIf a qualified candidate also satisfies (\\ref{eq7}), it is chosen as a pivot.  Otherwise, we remove $j$ from the $Z_i$ and repeat the process of selecting a $2$-by-$2$ pivot until we either find a qualified candidate that also satisfies (\\ref{eq7}) or $Z_i$ becomes empty.  In the latter case, we set $i$ to be the next next minimum degree column and repeat the process from the beginning (from testing whether $a_{ii}$ is a suitable $1$-by-$1$ pivot).  \nThe algorithm is as shown in Algorithm \\ref{algo2} below.\n\n\\begin{algorithm}\n\\caption{Our Pivot Selection Algorithm}\\label{algo2}\n\\begin{algorithmic}\n\\STATE // $A$ is a $n$-by-$n$ symmetric indefinite matrix\n\\STATE Let $M = \\{1, 2, ... , n\\}$\n\\WHILE{a suitable pivot is not yet found and $M$ is not empty}\n\\STATE Let $i$ be the minimum degree column among all column indices in $M$\n\\IF{$a_{ii}$ is accepted}\n   \\STATE Use $a_{ii}$ as the 1-by-1 pivot\n\\ELSE\n   \\STATE Let $Z_i = \\left\\{ z | a_{iz}\\neq 0 \\mbox{ and } z\\neq i\\right\\}$ \n   \\WHILE {a suitable pivot is not yet found and $Z_i$ is not empty}\n      \\STATE Let $j$ be such that $\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ has the minimum out-degree and $j \\in Z_i$\n      \\IF{$\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ satisfies (\\ref{eq7})}\n         \\STATE Use $\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ as the 2-by-2 pivot\n      \\ELSE\n         \\STATE Remove $j$ from $Z_i$ \n      \\ENDIF\n   \\ENDWHILE\n   \\STATE Remove $i$ from $M$\n\\ENDIF\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\nLastly, when the remaining matrix is fully dense, we continue with a conventional pivot selection algorithm such as BBK instead.\n\n\n\n\n\\section{Experiments and results} \\label{sec5}\n\nThis section compares the efficiency of our algorithm with MA57, which is based on the multifrontal method. \nThe experiments are performed in Matlab 2011a on matrices of varying dimensions from 100 to 5000.\nFor each dimension, we vary the percentage of nonzeros in the matrices from 5 to 30 percent.\nWe test with 20 different instances for problems with 100, 300, and 500 dimensions and 10 different instances for problems with 1000,3000, and 5000 dimensions.  We show the percentage of nonzeros in the factor $L$ of the two methods in Table \\ref{table1}, which shows that our method produces sparser factors than MA57 in all cases.  Note that the small percentage improvement for large matrices are not insignificant as small decrease in nonzeros does lead to significantly faster factorization time.  Finally, Table \\ref{table3} shows the residuals $\\left\\| P^TAP - LBL^T\\right\\|$ (* Is this how you compute residuals?  If not, change to the one you use.*) of the results of both methods. The result shows that our method produces more accurate factors than MA57.\n\n\n\n\n\\begin{table}\n\\caption{Average percentage of nonzeros in the factor $L$ produced by MA57 and our algorithm for problems with 100, 300, 500, 1000, 3000, and 5000 dimensions and 30, 20, 10, and 5 percent of nonzeros in the matrix.  The percentage of nonzeros in $L$ is computed by dividing the number of nonzeros in $L$ by $n^2$ and then multiplying the result by $100$.}\\label{table1}\n\\begin{tabular}{|c|r|r|r|r|r|r|r|r|}\n\\hline\n\\multirow{3}{*}{$n$} \n&\\multicolumn{8}{c|}{Percentage of nonzeros in $L$}\\\\\n\\cline{2-9}\n&\\multicolumn{2}{c|}{30}\n&\\multicolumn{2}{c|}{20}\n&\\multicolumn{2}{c|}{10}\n&\\multicolumn{2}{c|}{5}\\\\\n\\cline{2-9}\n&MA57\n&Our method\n&MA57\n&Our method\n&MA57\n&Our method\n&MA57\n&Our method\\\\\n\\hline\n100&46.20&45.54&40.90&39.24&22.68&18.73&11.02&6.60\\\\\n300&46.07&45.39&43.03&41.89&35.76&33.15&25.17&21.23\\\\\n500&47.37&46.98&45.26&44.52&39.98&38.17&17.42&12.04\\\\\n1000&48.53&48.35&47.39&47.00&44.01&43.02&38.46&36.36\\\\\n3000&49.46&49.37&49.00&48.84&47.56&47.21&45.11&44.19\\\\\n5000&49.64&49.61&49.36&49.26&48.47&48.22&46.86&46.23\\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n\n\\ifx \nTable 2 show the factorization time of both two methods.\nThe result show that, when the problem is more sparse our algorithm is save more time comparing with MA57. \n\\begin{table}\n\\caption{Average factorization time of MA57 and our algorithm for problems with 300, 500, 1000, and 2000 variables and 70, 80, 90 and 95 percent of zeros in the matrix.}\n\\begin{tabular}{|c|r|r|r|r|r|r|r|r|}\n\\hline\n\\multirow{3}{*}{$n$} \n&\\multicolumn{8}{c|}{factorization time (s)}\\\\\n\\cline{2-9}\n&\\multicolumn{4}{c|}{MA57}\n&\\multicolumn{4}{c|}{Our method}\\\\\n\\cline{2-9}\n&70\n&80\n&90\n&95\n&70\n&80\n&90\n&95\\\\\n\\hline\n100\t&\t0.00059\t&\t0.00056\t&\t0.00038\t&\t0.00029\t&\t0.01631\t&\t0.02077\t&\t0.02182\t&\t0.02176\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n300\t&\t0.00523\t&\t0.00499\t&\t0.00432\t&\t0.00275\t&\t0.11447\t&\t0.13355\t&\t0.14325\t&\t0.13120\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n500\t&\t0.01507\t&\t0.01547\t&\t0.01283\t&\t0.00579\t&\t0.48870\t&\t0.57355\t&\t0.66205\t&\t0.40296\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n1000\t&\t0.09170\t&\t0.08992\t&\t0.07798\t&\t0.06432\t&\t3.26590\t&\t3.99701\t&\t5.02232\t&\t5.48706\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n3000\t&\t1.84638\t&\t1.92231\t&\t1.87029\t&\t1.76557\t&\t47.71865\t&\t62.89543\t&\t96.95069\t&\t120.06834\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n5000\t&\t6.56945\t&\t6.68904\t&\t6.62526\t&\t6.41201\t&\t159.18106\t&\t201.59030\t&\t305.14178\t&\t409.57366\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\\hline\n\\end{tabular}\n\\end{table}\n\\fi\n\n\\begin{table}\n\\caption{Average residuals of the factorization produced by MA57 and our algorithm for problems with 300, 500, 1000, and 2000 dimensions and 30, 20, 10 and 5 percent of nonzeros in the matrix.} \\label{table3}\n\\begin{tabular}{|c|r|r|r|r|r|r|r|r|}\n\\hline\n\\multirow{3}{*}{$n$} \n&\\multicolumn{8}{c|}{Residual ($\\times 10^{-10}$)}\\\\\n\\cline{2-9}\n&\\multicolumn{2}{c|}{30}\n&\\multicolumn{2}{c|}{20}\n&\\multicolumn{2}{c|}{10}\n&\\multicolumn{2}{c|}{5}\\\\\n\\cline{2-9}\n&MA57\n&Our method\n&MA57\n&Our method\n&MA57\n&Our method\n&MA57\n&Our method\\\\\n\\hline\n100\t&\t0.00339&\t0.00018\t&\t0.00410&\t0.00022\t&\t0.00190\t&\t0.00016&\t0.00045\t&\t0.00006\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n300\t&\t0.03072&\t0.00077\t&\t0.02634&\t0.00083\t&\t0.02378&\t0.00083\t&\t0.01039\t&\t0.00059\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n500\t&\t0.08489&\t0.00128\t&\t0.06665&\t0.00161\t&\t0.04665&\t0.00169\t&\t0.02199&\t0.00076\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n1000\t&\t0.20679&\t0.00342\t&\t0.21691&\t0.00374\t&\t0.17399&\t0.00333\t&\t0.10509&\t0.00355\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n3000\t&\t1.63656\t&\t0.01312&\t1.80491\t&\t0.01281&\t1.32961\t&\t0.02150&\t1.13003\t&\t0.02160\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n5000\t&\t4.45974&\t0.02488\t&\t3.49949&\t0.02361\t&\t2.51524&\t0.03264\t&\t2.20916&\t0.03152\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\\hline\n\\end{tabular}\n\\end{table}\n\n\\ifx\n\\begin{table}\n\\caption{Average factorization time of our method using Algorithm 2 and Algorithm 3 for problems with 300, 500, 1000, and 2000 variables, 95 percent of zeros in the matrix and 70, 80, 90 and 95 percent of zeros in the matrix.}\n\\begin{tabular}{|c|r|r|r|r|r|r|r|r|}\n\\hline\n\\multirow{3}{*}{$n$} \n&\\multicolumn{8}{c|}{factorization time (s)}\\\\\n\\cline{2-9}\n&\\multicolumn{4}{c|}{Algorithm1}\n&\\multicolumn{4}{c|}{Algorithm2}\\\\\n\\cline{2-9}\n&70\n&80\n&90\n&95\n&70\n&80\n&90\n&95\\\\\n\\hline\n100\t&\t0.01631\t&\t0.02077\t&\t0.02182\t&\t0.02176\t&\t0.02800\t&\t0.03388\t&\t0.04940\t&\t0.05190\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n300\t&\t0.11447\t&\t0.13355\t&\t0.14325\t&\t0.13120\t&\t0.19929\t&\t0.21520\t&\t0.26964\t&\t0.26227\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n500\t&\t0.48870\t&\t0.57355\t&\t0.66205\t&\t0.40296\t&\t0.81153\t&\t0.78094\t&\t0.83080\t&\t0.73690\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n1000\t&\t3.26590\t&\t3.99701\t&\t5.02232\t&\t5.48706\t&\t3.56344\t&\t4.33894\t&\t5.78310\t&\t6.46104\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n3000\t&\t47.71865\t&\t62.89543\t&\t96.95069\t&\t120.06834\t&\t234.17849\t&\t66.50211\t&\t99.11141\t&\t137.02838\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\n5000\t&\t159.18106\t&\t201.59030\t&\t305.14178\t&\t409.57366\t&\t177.53116\t&\t217.69066\t&\t388.44482\t&\t410.39756\t\\\\\t\t\t\t\t\t\t\t\t\t\t\t\t\\hline\n\\end{tabular}\n\\end{table}\n\\fi\n\\ifx\nFor the problems which require more accuracy. The pivot selection needs to compare in many times. \nAlgorithm 3 is our improve algorithm with suitable to the problem which require many accuracy. \nTable 3 shows the factorization time of the our method and our improve method in Algorithm 3.\nWe compare the problem with 95 percent sparse by varying the size of variable with $\\alpha$ is equal to 0.01, 0.1, 1, and 10 respectively. \nThe result shows that our improved algorithm is saving more time when the conditional value of $\\alpha$ is larger. \n\\fi\n\n\\section{Conclusion} \\label{sec6}\n\nIn this article, we propose a new pivot selection algorithm for symmetric indefinite factorization. Our method is based on the minimum degree algorithm but is able to select both 1-by-1 and 2-by-2 pivots that are stable. Our experimental results show that our algorithm produces factors that are stable and also sparser than MA57.\n\n\\bibliography{myrefs}\n\n", "itemtype": "equation", "pos": 15007, "prevtext": "\nOur algorithm then considers all of the candidates with the minimum out-degree.  Specifically, \n$\\begin{bmatrix} a_{ii}  & a_{ij} \\\\  a_{ji} & a_{jj}\\end{bmatrix}$ is qualified if\n\n", "index": 21, "text": "\\begin{equation}\\label{eq11}\n\\text{deg}(i,j) = \\min_{z \\in Z_i} \\text{deg}(i,z).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\text{deg}(i,j)=\\min_{z\\in Z_{i}}\\text{deg}(i,z).\" display=\"block\"><mrow><mrow><mrow><mtext>deg</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mi>min</mi><mrow><mi>z</mi><mo>\u2208</mo><msub><mi>Z</mi><mi>i</mi></msub></mrow></munder><mo>\u2061</mo><mtext>deg</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}]