[{"file": "1601.05927.tex", "nexttext": "\n at propagation distance $z$ and time $t$, where   $E_{x}$ ($E_{y}$) is the $x$-polarized ($y$-polarized) electric field, represented as a complex baseband signal. \nThe linearly modulated transmitted electric field into the transmission medium  is \n\n", "itemtype": "equation", "pos": 10224, "prevtext": "\n\n\n\\title{Modulation Format Independent Joint Polarization and Phase Tracking for Coherent Receivers}\n\n\n\n\\author{Cristian~B.~Czegledi,\n        Erik~Agrell,~\\IEEEmembership{Senior~Member,~IEEE,}\n        Magnus~Karlsson,~\\IEEEmembership{Senior~Member,~IEEE,~Fellow,~OSA}, \n         and~Pontus~Johannisson,~\\IEEEmembership{~Member,~OSA}\n\\thanks{\nC. B. Czegledi and E. Agrell are with the Department of Signals and Systems, Chalmers University of Technology, SE-412 96 Gothenburg, Sweden (e-mail: czegledi@chalmers.se).\n\nM. Karlsson and P. Johannisson are with the Department of Microtechnology and Nanoscience, Chalmers University of Technology, SE-412 96 Gothenburg, Sweden.\n\n\nThis work was supported by the Swedish research council (VR) and performed within the Fiber Optic Communications Research Center (FORCE) at Chalmers. The simulations were performed on resources at Chalmers Centre for Computational Science and Engineering (C3SE) provided by the Swedish National Infrastructure for Computing (SNIC).  \n}\n}\n\n\n\n\n\n\n\n\\maketitle\n\n\\begin{abstract}\nThe state of polarization and the carrier phase drift dynamically during transmission in a random fashion in coherent optical fiber communications. \nThe typical digital signal processing solution to mitigate these impairments consists of two separate blocks that track each phenomenon independently.\nSuch algorithms have been developed without taking into account mathematical models describing the impairments.   \nWe study a  blind, model-based tracking algorithm to compensate for these impairments. The algorithm dynamically recovers the carrier phase and state of polarization jointly for an arbitrary modulation format.  \nSimulation results show the effectiveness of the proposed algorithm, having a fast convergence rate and an excellent tolerance to phase noise and\ndynamic drift of the polarization. \nThe computational complexity of the algorithm is lower compared to state-of-the-art algorithms at similar or better performance, which makes it a \nstrong candidate for future optical systems.\n\\end{abstract}\n\n\\begin{IEEEkeywords}\nCoherent optical fiber communication, model-based,   phase noise, phase recovery, polarization demultiplexing, polarization drift, polarization recovery.\n\\end{IEEEkeywords}\n\n\n\\ifCLASSOPTIONpeerreview\n \\begin{center} \\bfseries EDICS Category: 3-BBND \\end{center}\n\\fi\n\n\\IEEEpeerreviewmaketitle\n\n\n\n\n\\section{Introduction} \n\\IEEEPARstart{D}{igital} signal processing (DSP) enables  spectrally efficient communications based on coherent transmission.  Contrary to  traditional optical transmission links that are based on intensity-modulation and direct-detection, coherent transmissions carry the information in both the intensity and phase of the optical field, in both polarizations, and benefit from improved sensitivities, higher-order modulation formats, and digital  impairment mitigation.\nPolarization-multiplexed quadrature phase-shift keying (PM-QPSK) introduced for 100 Gb/s transmission has been widely deployed and reached maturity.  \nRecently, 200 Gb/s transceivers have been made commercially available based on $16$-ary polarization-multiplexed quadrature amplitude modulation (PM-16-QAM)\nand it is expected that in  the near future, higher-order PM-$M$-QAM modulation formats   will become a necessity for higher data rates. However, the improved spectral efficiency comes at the cost of a reduced tolerance to impairments such as laser phase noise and drift of the state of polarization (SOP), which have to be dynamically tracked in the receiver \\cite{Kim2009,Savory2010}.  \n\nThe phase and SOP  tracking are important DSP blocks at the receiver and are different from the chromatic dispersion compensation, which can be set once and then forgotten due to its static behavior. The  SOP drift has its origin in the imperfections of the manufacturing process of the fiber cables, mechanical/thermal stress on the deployed  fibers, splices, etc. Due to these random variations, the SOP changes dynamically in time and along the fiber, which makes it difficult to fully compensate for. The phase noise originates from the finite coherence length of the transmitter and receiver lasers and it drifts in time as a Wiener random walk. Despite the fact that the SOP drift and the phase noise arise due to different hardware imperfections, they can  be  modeled jointly as dynamic rotations of the optical field \\cite{Czegledi2015a}.\nA deterministic or static behavior of these phenomena would be straightforward to resolve, but when the impairments drift randomly, the receiver must adjust dynamically to track the phenomena.\n\nThe common DSP solution for SOP tracking is done in the Jones space using the constant modulus algorithm (CMA) \\cite{Savory2010}, initially developed for  two-dimensional  modulation formats \\cite{Godard1980}, or modified versions of it to accommodate for various modulation formats,  such as the multiple modulus algorithm (MMA)\\cite{JianYang2002,Louchet2008} or the polarization-switched \\mbox{(PS-)CMA} \\cite{Johannisson2011}. Alternatively, the polarization demultiplexing  can be done in the Stokes space \\cite{Visintin2014,Muga2014}, which in addition also aligns the phase of the two polarizations, thus improving the phase tracking by enabling joint phase estimation over the two polarizations.   In general, the phase tracking is performed independently of the SOP tracking, using algorithms such as the Viterbi--Viterbi algorithm \\cite{Viterbi1983} or the blind phase-search algorithm (BPS) \\cite{Pfau2009}, which treat each polarization independently. \n\nRecently, Louchet \\textit{et al.} proposed the {Kabsch} algorithm\\cite{Louchet2014}, which addresses the two impairments jointly in both polarizations in the real four-dimensional (4D)  space and  accommodates any modulation format. In general, joint estimation leads to better performance, and it is expected that future transceivers will benefit from  improved performance from such integrations of different DSP blocks\\cite{Morero2015}.\n\nHowever, very few algorithms present in the literature take into consideration analytical  models  describing the behavior of the  impairments. Model-based algorithms have a restricted flexibility and therefore fewer degrees of freedom (DOFs) to adjust. The DOFs of model-based algorithms are restricted to only the ones covered by the impairment to compensate for, thus resulting in a more efficient impairment cancellation, rather than scanning over a larger domain in order to find the optimal setup. \n\nIn this paper, we propose a  model-based algorithm to jointly recover  the carrier phase and SOP  for  arbitrary modulation formats. The design of the algorithm   is  based on a channel model (described in Section~\\ref{Sec:model})  that can emulate temporal stochastic polarization and phase drifts, and has been successfully validated with data measured on installed fibers\\cite{Czegledi2015a}.  The algorithm (described in Section~\\ref{sec:alg}) uses a non-data aided decision-directed architecture, hence zero overhead, and operates jointly on both polarizations. \n The performance of the algorithm is investigated in Section~\\ref{sec:results} by comparing it with state-of-the-art algorithms for different modulation formats, whereas the complexity is evaluated in Section~\\ref{sec:complexity}. The proposed algorithm performs similarly or better than state-of-the-art algorithms and provides a good trade-off between complexity and performance regardless of the modulation format. High performance and  fast convergence rate  at low complexity,  for any modulation format,  make the algorithm a strong candidate for future elastic optical systems, where the modulation format can be changed dynamically during transmission to accommodate for various channel and network conditions.\n\n\n\n\nThe following notation conventions are used throughout the paper: column vectors are denoted by bold lower case (e.g., ${\\mathbf{u}_{{}}}$) and matrices by  bold upper case (e.g., $\\bf{U}$), except a few specific cases, for literature consistency reasons, denoted by small Greek  letters such as the Pauli matrices ${ \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{i}}}}$,  the 4D basis matrices ${ \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{i}}}}\\text{, } { \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{i}}}}$, and the electric field Jones vector $\\mathbf{E}$. Transposition is written as ${\\mathbf{u}_{{}}}^\\mathrm{T}$, conjugation as ${\\mathbf{u}_{{}}}^{\\mathrm{*}}$, and conjugate transpose as ${\\mathbf{u}_{{}}}^{\\mathrm{H}}$. The $n\\times n$ identity matrix is written as $\\mathbf{I}_n$ and the expectation operator as  $\\mathbb{E}[\\cdot]$. The dot operation ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}$  should be interpreted as a  linear combination of the three matrices forming the tensor ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{3}}}})$.  Multiplication of a matrix with the tensor ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}$ result in a tensor with element-wise multiplications, e.g., $\\textbf{U} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} = (\\textbf{U}{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{1}}}},\\textbf{U}{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{2}}}},\\textbf{U}{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{3}}}})$. The absolute value is denoted by $\\abs{\\cdot}$ and the Euclidean norm  by $\\norm{\\cdot}$.\n\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{coh_DSP_arch}\n\\caption{Receiver block diagram with elementary DSP modules.}\n\\label{fig:sysm}\n\\end{figure*}\n\n\\section{Discrete-Time Channel Model} \\label{Sec:model}\nThe coherent optical signal has two quadratures in two polarizations and can be described by a Jones vector\n\n", "index": 1, "text": "\\begin{equation}\n  \\label{eq:x}\n\\mathbf{E}(z,t) = \n  \\begin{pmatrix}\n  E_{x}(z,t) \\\\\n  E_{y}(z,t)\n\\end{pmatrix},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{E}(z,t)=\\begin{pmatrix}E_{x}(z,t)\\\\&#10;E_{y}(z,t)\\end{pmatrix},\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\udc04</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><msub><mi>E</mi><mi>x</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><msub><mi>E</mi><mi>y</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere $ {\\mathbf{u}_{{k}}} \\in \\mathbb{C}^2$ are the information symbols for $k\\in\\mathbb{Z}$, $T$ is the symbol (baud) interval, and $p(t)$ is a real-valued pulse shape. \n\nThe received discrete symbols, at distance $L$, are obtained from the received electric field $\\mathbf{E}(L,t)$ after matched filtering and sampling \n\n", "itemtype": "equation", "pos": 10601, "prevtext": "\n at propagation distance $z$ and time $t$, where   $E_{x}$ ($E_{y}$) is the $x$-polarized ($y$-polarized) electric field, represented as a complex baseband signal. \nThe linearly modulated transmitted electric field into the transmission medium  is \n\n", "index": 3, "text": "\\begin{equation}\n  \\mathbf{E}(0,t) = \\displaystyle \\sum_k {\\mathbf{u}_{{k}}} p(t-kT),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{E}(0,t)=\\displaystyle\\sum_{k}{\\mathbf{u}_{{k}}}p(t-kT),\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\udc04</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>k</mi></munder><mrow><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub><mo>\u2062</mo><mi>p</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>-</mo><mrow><mi>k</mi><mo>\u2062</mo><mi>T</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\n\nThe discrete transmitted symbols  ${\\mathbf{u}_{{k}}}$ are drawn independently  from a finite constellation $\\mathscr{C} = \\{\\mathbf{c}_1, \\mathbf{c}_2, ..., \\mathbf{c}_M\\}$ with equal probability. The average energy per symbol is the average of $\\norm{{\\mathbf{u}_{{k}}}}^2$ and  in this case equals\n\n", "itemtype": "equation", "pos": 11025, "prevtext": "\nwhere $ {\\mathbf{u}_{{k}}} \\in \\mathbb{C}^2$ are the information symbols for $k\\in\\mathbb{Z}$, $T$ is the symbol (baud) interval, and $p(t)$ is a real-valued pulse shape. \n\nThe received discrete symbols, at distance $L$, are obtained from the received electric field $\\mathbf{E}(L,t)$ after matched filtering and sampling \n\n", "index": 5, "text": "\\begin{equation}\n{\\mathbf{r}_{{k}}} = \\int_{-{\\infty}}^{{\\infty}} \\mathbf{E}(L,t) p^{\\mathrm{*}}(t-kT) \\mathrm{d} t.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{r}_{{k}}}=\\int_{-{\\infty}}^{{\\infty}}\\mathbf{E}(L,t)p^{\\mathrm{*}}(t-%&#10;kT)\\mathrm{d}t.\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub><mo>=</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mrow><mo>-</mo><mi mathvariant=\"normal\">\u221e</mi></mrow><mi mathvariant=\"normal\">\u221e</mi></msubsup><mrow><mi>\ud835\udc04</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>L</mi><mo>,</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mi>p</mi><mo>*</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>-</mo><mrow><mi>k</mi><mo>\u2062</mo><mi>T</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>d</mo><mi>t</mi></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\n\n\n\n\nAssuming that the chromatic dispersion has been successfully compensated for and polarization-dependent losses and polarization mode dispersion are negligible,  the propagation of the optical field can be described by a unitary $2\\times2$ complex-valued Jones matrix ${\\mathbf{{J}}_{{k}}}$ \\cite[p.~18]{Damask2005}. \nThe received symbol ${\\mathbf{r}_{{k}}}\\in\\mathbb{C}^2$, in the presence of optical amplifier noise, SOP drift, and laser phase noise, can be related  to the input ${\\mathbf{u}_{{k}}}$ as\n\n", "itemtype": "equation", "pos": 11459, "prevtext": "\n\nThe discrete transmitted symbols  ${\\mathbf{u}_{{k}}}$ are drawn independently  from a finite constellation $\\mathscr{C} = \\{\\mathbf{c}_1, \\mathbf{c}_2, ..., \\mathbf{c}_M\\}$ with equal probability. The average energy per symbol is the average of $\\norm{{\\mathbf{u}_{{k}}}}^2$ and  in this case equals\n\n", "index": 7, "text": "\\begin{equation} \\label{eq:Es}\n  E_s = \\frac{1}{M}\\sum_{k=1}^M\\norm{\\mathbf{c}_k}^2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"E_{s}=\\frac{1}{M}\\sum_{k=1}^{M}\\norm{\\mathbf{c}_{k}}^{2}.\" display=\"block\"><mrow><mrow><msub><mi>E</mi><mi>s</mi></msub><mo>=</mo><mrow><mfrac><mn>1</mn><mi>M</mi></mfrac><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\norm</mtext></merror><mo>\u2062</mo><mmultiscripts><mi>\ud835\udc1c</mi><mi>k</mi><none/><none/><mn>2</mn></mmultiscripts></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere $i=\\sqrt{-1}$,  ${ \\ifthenelse{\\equal{{k}}{}}{\\phi}{\\phi_{{k}}}}$ models the carrier phase noise, and ${\\mathbf{n}_{{k}}}\\in\\mathbb{C}^2$ denotes the additive noise, which is represented by two independent complex circular zero-mean Gaussian random variables with variance $N_0/2$  per real dimension, i.e., $\\mathbb{E}[{\\mathbf{n}_{{k}}}{\\mathbf{n}_{{k}}}^{\\mathrm{H}}] = N_0 {\\mathbf{I}_{{2}}} $\\cite{Agrell2009}.\n\n\nThe phase noise is  modeled as a Wiener process \\cite{Pfau2009,Tur1985}\n\n", "itemtype": "equation", "pos": 12068, "prevtext": "\n\n\n\n\nAssuming that the chromatic dispersion has been successfully compensated for and polarization-dependent losses and polarization mode dispersion are negligible,  the propagation of the optical field can be described by a unitary $2\\times2$ complex-valued Jones matrix ${\\mathbf{{J}}_{{k}}}$ \\cite[p.~18]{Damask2005}. \nThe received symbol ${\\mathbf{r}_{{k}}}\\in\\mathbb{C}^2$, in the presence of optical amplifier noise, SOP drift, and laser phase noise, can be related  to the input ${\\mathbf{u}_{{k}}}$ as\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:sys_mod}\n\t{\\mathbf{r}_{{k}}}= { \\ifthenelse{\\equal{{k}}{}}{e^{-i\\phi}}{e^{-i\\phi_{{k}}}}}{\\mathbf{{J}}_{{k}}} {\\mathbf{u}_{{k}}}+{\\mathbf{n}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{r}_{{k}}}={e^{-i\\phi_{{k}}}}{\\mathbf{{J}}_{{k}}}{\\mathbf{u}_{{k}}}+{%&#10;\\mathbf{n}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub><mo>=</mo><mrow><mrow><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>i</mi><mo>\u2062</mo><msub><mi>\u03d5</mi><mi>k</mi></msub></mrow></mrow></msup><mo>\u2062</mo><msub><mi>\ud835\udc09</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></mrow><mo>+</mo><msub><mi>\ud835\udc27</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ is the \\textit{innovation} of the phase noise. \nThe innovation ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ is a random variable drawn independently at each time instance $k$ from a zero-mean Gaussian distribution \n\n", "itemtype": "equation", "pos": 12754, "prevtext": "\nwhere $i=\\sqrt{-1}$,  ${ \\ifthenelse{\\equal{{k}}{}}{\\phi}{\\phi_{{k}}}}$ models the carrier phase noise, and ${\\mathbf{n}_{{k}}}\\in\\mathbb{C}^2$ denotes the additive noise, which is represented by two independent complex circular zero-mean Gaussian random variables with variance $N_0/2$  per real dimension, i.e., $\\mathbb{E}[{\\mathbf{n}_{{k}}}{\\mathbf{n}_{{k}}}^{\\mathrm{H}}] = N_0 {\\mathbf{I}_{{2}}} $\\cite{Agrell2009}.\n\n\nThe phase noise is  modeled as a Wiener process \\cite{Pfau2009,Tur1985}\n\n", "index": 11, "text": "\\begin{equation}\\label{eq:ph_wiener}\n  { \\ifthenelse{\\equal{{k+1}}{}}{\\phi}{\\phi_{{k+1}}}}={ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}+{ \\ifthenelse{\\equal{{k}}{}}{\\phi}{\\phi_{{k}}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"{\\phi_{{k+1}}}={\\innov{\\phi}_{{k}}}+{\\phi_{{k}}},\" display=\"block\"><mrow><mrow><msub><mi>\u03d5</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\innov</mtext></merror><mo>\u2062</mo><msub><mi>\u03d5</mi><mi>k</mi></msub></mrow><mo>+</mo><msub><mi>\u03d5</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere the variance $\\sigma_\\nu^2 = 2\\pi { {\\Delta \\nu}} T$,  ${\\Delta \\nu}$ is the  sum of the linewidths of the transmitter and receiver lasers. The initial phase  ${ \\ifthenelse{\\equal{{0}}{}}{\\phi}{\\phi_{{0}}}}$ is modeled   as a random variable uniformly distributed in the interval $[0, 2\\pi)$.\n\n\n\n\nThe  time evolution of the SOP drift can be emulated by modeling ${\\mathbf{{J}}_{{k}}}$ as a sequence of random Jones matrices \\cite{Czegledi2015a}\n\n", "itemtype": "equation", "pos": 13281, "prevtext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ is the \\textit{innovation} of the phase noise. \nThe innovation ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ is a random variable drawn independently at each time instance $k$ from a zero-mean Gaussian distribution \n\n", "index": 13, "text": "\\begin{equation}\\label{eq:ph_distr}\n  { \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}} \\sim \\mathcal{N}(0,\\sigma_\\nu^2),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"{\\innov{\\phi}_{{k}}}\\sim\\mathcal{N}(0,\\sigma_{\\nu}^{2}),\" display=\"block\"><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\innov</mtext></merror><mo>\u2062</mo><msub><mi>\u03d5</mi><mi>k</mi></msub></mrow><mo>\u223c</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udca9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>\u03c3</mi><mi>\u03bd</mi><mn>2</mn></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}$ is the SOP \\emph{innovation} matrix (cf. ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ in (\\ref{eq:ph_wiener})). The matrix function ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is defined using the \\emph{matrix exponential} \\cite[p.~165]{Bellman1960} parameterized by three DOFs ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$ \\cite{Gordon2000} as \n\\begin{IEEEeqnarray}{rCl}\n{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) &=& \\exp(-i{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}), \\label{eq_rot1}\n\\end{IEEEeqnarray}\nwhere ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{1}}}{\\alpha^{({})}_{{1}}}}}, { \\ifthenelse{\\equal{{2}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{2}}}{\\alpha^{({})}_{{2}}}}},{ \\ifthenelse{\\equal{{3}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{3}}}{\\alpha^{({})}_{{3}}}}})$ is a three-component real vector and ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{3}}}})$ is a tensor of the Pauli spin matrices \\cite[eq.~(2.5.19)]{Damask2005}\n\n", "itemtype": "equation", "pos": 13884, "prevtext": "\nwhere the variance $\\sigma_\\nu^2 = 2\\pi { {\\Delta \\nu}} T$,  ${\\Delta \\nu}$ is the  sum of the linewidths of the transmitter and receiver lasers. The initial phase  ${ \\ifthenelse{\\equal{{0}}{}}{\\phi}{\\phi_{{0}}}}$ is modeled   as a random variable uniformly distributed in the interval $[0, 2\\pi)$.\n\n\n\n\nThe  time evolution of the SOP drift can be emulated by modeling ${\\mathbf{{J}}_{{k}}}$ as a sequence of random Jones matrices \\cite{Czegledi2015a}\n\n", "index": 15, "text": "\\begin{equation} \\label{eq:time_dep}\n  {\\mathbf{{J}}_{{k+1}}} = { \\ifthenelse{\\equal{{k}}{}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}{\\mathbf{{J}}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{{J}}_{{k+1}}}={{{J}(\\innov{{{\\boldsymbol{\\alpha}}}}_{{k}})}}{\\mathbf{%&#10;{J}}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc09</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>J</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\innov</mtext></merror><mo>\u2062</mo><msub><mi>\ud835\udf36</mi><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc09</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nThe vector ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}$ can be expressed  as a product \\mbox{${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}={ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}{ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$} of its length ${ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} = \\norm*{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}$  and the  unit vector ${ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}} = ({ \\ifthenelse{\\equal{{1}}{}}{ {\\mathbf{a}}}{{{a}}_{{1}}}}{}, { \\ifthenelse{\\equal{{2}}{}}{ {\\mathbf{a}}}{{{a}}_{{2}}}}{},{ \\ifthenelse{\\equal{{3}}{}}{ {\\mathbf{a}}}{{{a}}_{{3}}}}{})$, which represents its direction on the unit sphere. Based on this decomposition of ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}$, \\eqref{eq_rot1} can be rewritten into an explicit form\n\\begin{IEEEeqnarray}{rCl} \\label{eq:J_cos}\n{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})  &=& {\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} - i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}. \\label{eq_rot2}\n\\end{IEEEeqnarray}\n\nSince the transformation ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is unitary, the inverse can be found by the conjugate transpose operation or negating the argument, ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})^{-1} = {J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})^{\\mathrm{H}}=  {J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$.\n\n\nThe random nature of the SOP drift is emulated by drawing the  three innovation parameters ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$  of the innovation ${ \\ifthenelse{\\equal{{k}}{}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}$  independently from a zero-mean real Gaussian distribution at each time instance $k$\n\n", "itemtype": "equation", "pos": 16008, "prevtext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}$ is the SOP \\emph{innovation} matrix (cf. ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ in (\\ref{eq:ph_wiener})). The matrix function ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is defined using the \\emph{matrix exponential} \\cite[p.~165]{Bellman1960} parameterized by three DOFs ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$ \\cite{Gordon2000} as \n\\begin{IEEEeqnarray}{rCl}\n{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) &=& \\exp(-i{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}), \\label{eq_rot1}\n\\end{IEEEeqnarray}\nwhere ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{1}}}{\\alpha^{({})}_{{1}}}}}, { \\ifthenelse{\\equal{{2}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{2}}}{\\alpha^{({})}_{{2}}}}},{ \\ifthenelse{\\equal{{3}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{3}}}{\\alpha^{({})}_{{3}}}}})$ is a three-component real vector and ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{3}}}})$ is a tensor of the Pauli spin matrices \\cite[eq.~(2.5.19)]{Damask2005}\n\n", "index": 17, "text": "\\begin{equation} \\label{eq:pauliSpins}\n{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{1}}}} = \n\\begin{pmatrix}\n  1 & 0 \\\\\n  0&-1\\\\\n\\end{pmatrix},\n\\enspace\n{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{2}}}} = \n\\begin{pmatrix}\n  0 & 1 \\\\\n 1&0\\\\\n\\end{pmatrix},\n\\enspace\n{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{3}}}} = \n\\begin{pmatrix}\n  0 & -i \\\\\n  i &  0\\\\\n\\end{pmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"{{\\boldsymbol{\\sigma}}_{{1}}}=\\begin{pmatrix}1&amp;0\\\\&#10;0&amp;-1\\\\&#10;\\end{pmatrix},\\@math@espace{{\\boldsymbol{\\sigma}}_{{2}}}=\\begin{pmatrix}0&amp;1\\\\&#10;1&amp;0\\\\&#10;\\end{pmatrix},\\@math@espace{{\\boldsymbol{\\sigma}}_{{3}}}=\\begin{pmatrix}0&amp;-i\\\\&#10;i&amp;0\\\\&#10;\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\ud835\udf48</mi><mn>1</mn></msub><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror><mo>\u2062</mo><msub><mi>\ud835\udf48</mi><mn>2</mn></msub></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>,</mo><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\@math@espace</mtext></merror><mo>\u2062</mo><msub><mi>\ud835\udf48</mi><mn>3</mn></msub></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mi>i</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mi>i</mi></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere $\\sigma_p^2= 2\\pi { \\Delta p}\\, T$ and  $\\Delta p$ is referred as the {\\it polarization linewidth}, which quantifies the speed of the SOP drift, analogously to the linewidth describing the phase noise, cf.  (\\ref{eq:ph_distr}). \n\n\n\nThe initial state of the channel ${\\mathbf{{J}}_{{0}}} = {J}({ \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}{})$ is formed from the vector ${ \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}= { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}{ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$, which is identified from  the unit vector $(\\cos { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}, { \\ifthenelse{\\equal{{1}}{}}{ {\\mathbf{a}}}{{{a}}_{{1}}}}{}\\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}, { \\ifthenelse{\\equal{{2}}{}}{ {\\mathbf{a}}}{{{a}}_{{2}}}}{} \\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\mathbf{a}}}{{{a}}_{{3}}}}{}\\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}})^{\\mathrm{T}} = \\mathbf{g}/\\norm{\\mathbf{g}} $ where $\\mathbf{g} \\sim \\mathcal{N}(\\mathbf{0}, {\\mathbf{I}_{{4}}})$. This ensures that ${\\mathbf{{J}}_{{0}}} {\\mathbf{u}_{{}}}$ is uniformly distributed over all possible SOP for a fixed ${\\mathbf{u}_{{}}}$ \\cite{Czegledi2015a,Karlsson2015}. \n\n\nThe phase noise and the SOP drift can be combined into a single operation ${\\mathbf{{H}}_{{k}}}={ \\ifthenelse{\\equal{{k}}{}}{e^{-i\\phi}}{e^{-i\\phi_{{k}}}}}{\\mathbf{{J}}_{{k}}}$ and  (\\ref{eq:sys_mod}) can be rewritten as \n\n", "itemtype": "equation", "pos": 19051, "prevtext": "\nThe vector ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}$ can be expressed  as a product \\mbox{${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}={ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}{ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$} of its length ${ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} = \\norm*{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}$  and the  unit vector ${ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}} = ({ \\ifthenelse{\\equal{{1}}{}}{ {\\mathbf{a}}}{{{a}}_{{1}}}}{}, { \\ifthenelse{\\equal{{2}}{}}{ {\\mathbf{a}}}{{{a}}_{{2}}}}{},{ \\ifthenelse{\\equal{{3}}{}}{ {\\mathbf{a}}}{{{a}}_{{3}}}}{})$, which represents its direction on the unit sphere. Based on this decomposition of ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}$, \\eqref{eq_rot1} can be rewritten into an explicit form\n\\begin{IEEEeqnarray}{rCl} \\label{eq:J_cos}\n{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})  &=& {\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} - i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}. \\label{eq_rot2}\n\\end{IEEEeqnarray}\n\nSince the transformation ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is unitary, the inverse can be found by the conjugate transpose operation or negating the argument, ${J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})^{-1} = {J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})^{\\mathrm{H}}=  {J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$.\n\n\nThe random nature of the SOP drift is emulated by drawing the  three innovation parameters ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$  of the innovation ${ \\ifthenelse{\\equal{{k}}{}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{J}(\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}$  independently from a zero-mean real Gaussian distribution at each time instance $k$\n\n", "index": 19, "text": "\\begin{equation}\\label{eq:rand_alp}\n  { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k \\sim \\mathcal{N}(\\mathbf{0},\\sigma_p^2\\, {\\mathbf{I}_{{3}}}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"{\\innov{\\alpha}}_{k}\\sim\\mathcal{N}(\\mathbf{0},\\sigma_{p}^{2}\\,{\\mathbf{I}_{{3%&#10;}}}),\" display=\"block\"><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\innov</mtext></merror><mo>\u2062</mo><msub><mi>\u03b1</mi><mi>k</mi></msub></mrow><mo>\u223c</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udca9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn/><mo>,</mo><mrow><mpadded width=\"+1.7pt\"><msubsup><mi>\u03c3</mi><mi>p</mi><mn>2</mn></msubsup></mpadded><mo>\u2062</mo><msub><mi>\ud835\udc08</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nThe update of $ {\\mathbf{{H}}_{{k}}}$ can be expressed analogously to (\\ref{eq:time_dep}) as \n\n", "itemtype": "equation", "pos": 21210, "prevtext": "\nwhere $\\sigma_p^2= 2\\pi { \\Delta p}\\, T$ and  $\\Delta p$ is referred as the {\\it polarization linewidth}, which quantifies the speed of the SOP drift, analogously to the linewidth describing the phase noise, cf.  (\\ref{eq:ph_distr}). \n\n\n\nThe initial state of the channel ${\\mathbf{{J}}_{{0}}} = {J}({ \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}{})$ is formed from the vector ${ \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}= { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}{ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$, which is identified from  the unit vector $(\\cos { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}, { \\ifthenelse{\\equal{{1}}{}}{ {\\mathbf{a}}}{{{a}}_{{1}}}}{}\\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}, { \\ifthenelse{\\equal{{2}}{}}{ {\\mathbf{a}}}{{{a}}_{{2}}}}{} \\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\mathbf{a}}}{{{a}}_{{3}}}}{}\\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}})^{\\mathrm{T}} = \\mathbf{g}/\\norm{\\mathbf{g}} $ where $\\mathbf{g} \\sim \\mathcal{N}(\\mathbf{0}, {\\mathbf{I}_{{4}}})$. This ensures that ${\\mathbf{{J}}_{{0}}} {\\mathbf{u}_{{}}}$ is uniformly distributed over all possible SOP for a fixed ${\\mathbf{u}_{{}}}$ \\cite{Czegledi2015a,Karlsson2015}. \n\n\nThe phase noise and the SOP drift can be combined into a single operation ${\\mathbf{{H}}_{{k}}}={ \\ifthenelse{\\equal{{k}}{}}{e^{-i\\phi}}{e^{-i\\phi_{{k}}}}}{\\mathbf{{J}}_{{k}}}$ and  (\\ref{eq:sys_mod}) can be rewritten as \n\n", "index": 21, "text": "\\begin{equation}\\label{eq:sys_mod_ful}\n\t{\\mathbf{r}_{{k}}}=  {\\mathbf{{H}}_{{k}}} {\\mathbf{u}_{{k}}}+{\\mathbf{n}_{{k}}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{r}_{{k}}}={\\mathbf{{H}}_{{k}}}{\\mathbf{u}_{{k}}}+{\\mathbf{n}_{{k}}}.\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub><mo>=</mo><mrow><mrow><msub><mi>\ud835\udc07</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></mrow><mo>+</mo><msub><mi>\ud835\udc27</mi><mi>k</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere the phase innovation ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ and the random vector ${ \\ifthenelse{\\equal{{}}{}}{\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\innov{\\alpha}_{{}}}}_k$ are defined as (\\ref{eq:ph_distr}) and  (\\ref{eq:rand_alp}), respectively. The matrix  function ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ can be expressed as\n\\begin{IEEEeqnarray}{rCl}\n{H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) &=& { \\ifthenelse{\\equal{{}}{}}{e^{-i\\phi}}{e^{-i\\phi_{{}}}}}{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) =  \\exp(-i({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}+{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}{\\mathbf{I}_{{2}}})) \\label{eq_rot_full}\\\\\n                 &=& ( \\cos{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}} - i \\sin{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}})({\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} - i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}),\\IEEEeqnarraynumspace \\label{eq_rot_full2}\n\\end{IEEEeqnarray}\nwhich combines the effects of both phase noise and SOP drift.\n\n\n\n\n\\section{Polarization and Phase Tracking Algorithm} \\label{sec:alg}\nIn order to successfully decode the data at the receiver, the channel matrix ${\\mathbf{{H}}_{{k}}}$ (or, equivalently, ${ \\ifthenelse{\\equal{{k}}{}}{\\phi}{\\phi_{{k}}}}$ and ${\\mathbf{{J}}_{{k}}}$) needs to be estimated and tracked during transmission such that it is possible to accurately estimate ${\\mathbf{u}_{{k}}}$ from the received sample ${\\mathbf{r}_{{k}}}$. This section provides a description of the proposed algorithm to estimate ${\\mathbf{{H}}_{{k}}}$, first using the Jones formalism, thereafter alternatives using the Stokes and real 4D formalisms are given.\n\nThe Jones description can be replaced by the Stokes or real 4D descriptions, which can provide benefits in  some situations \\cite{Czegledi2015a}. The analytics describing  wave propagation based on the Jones formalism rely on complex two-dimensional vectors and matrices that have \\emph{four} DOFs. This description is sufficient for wave propagation since it can cover any linear phenomenon that can arise during photon propagation. The Stokes description is preferred in some situations since the Stokes vectors  are observable quantities and can be visualized as points on a  three-dimensional sphere, called the Poincar\\'e sphere. In this case, the channel matrix ${\\mathbf{{J}}_{{k}}}$ is replaced by a $3\\times 3$ Mueller matrix ${\\mathbf{{M}}_{{k}}}$ with \\emph{three} DOFs that models only the changes of the SOP. The Stokes description cannot model absolute phase shifts, therefore it is immune to phase noise.\nThe real 4D formalism models the channel behavior using $4\\times 4$ real rotation matrices that have \\emph{six} DOFs, which span over a richer space than \nthe  Jones (four DOFs) or Mueller  (three DOFs) matrices can. However, only four of them are physically realizable for propagating photons and the other two can be synthesized using DSP \\cite{Karlsson2014}.\n\nIn the remainder of this section, we will provide the derivation of the proposed tracking algorithm using the Jones description, after which the equivalent algorithms  using the Stokes and the real 4D descriptions are given. The details of the channel model descriptions using the Stokes and real 4D descriptions are omitted  and can be found in \\cite{Czegledi2015a}.\n\\subsection{Jones Description} \\label{sec:Jones_descr}\nThe considered DSP setup is shown in Fig.~\\ref{fig:sysm}, where we combine the SOP drift and carrier phase tracking, i.e., estimation of ${\\mathbf{{H}}_{{k}}}$, into a single block after the  frequency offset compensation, which can be done in this case using spectrum-based methods {\\cite{Sun2011,Nakagawa2010}}.\nConsidering that ${\\mathbf{{H}}_{{k}}}$ does not change significantly over a symbol duration, we estimate the transmitted symbol from ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}$ based on a previously calculated estimate of the channel matrix  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$ using the minimum Euclidean distance criterion\n\n", "itemtype": "equation", "pos": 21440, "prevtext": "\nThe update of $ {\\mathbf{{H}}_{{k}}}$ can be expressed analogously to (\\ref{eq:time_dep}) as \n\n", "index": 23, "text": "\\begin{equation} \\label{eq:T_time_dep}\n  {\\mathbf{{H}}_{{k+1}}} = { \\ifthenelse{\\equal{{k}}{}}{{{H}( \\btin{k}, \\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}})}}{{{H}(\\btin{k}, \\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}})}}}{\\mathbf{{H}}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{{H}}_{{k+1}}}={{{H}(\\btin{k},\\innov{{{\\boldsymbol{\\alpha}}}}_{{k}})}}%&#10;{\\mathbf{{H}}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc07</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\btin</mtext></merror><mo>\u2062</mo><mi>k</mi></mrow><mo>,</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\innov</mtext></merror><mo>\u2062</mo><msub><mi>\ud835\udf36</mi><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc07</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nThereafter  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$ is updated as \n\n", "itemtype": "equation", "pos": 26461, "prevtext": "\nwhere the phase innovation ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ and the random vector ${ \\ifthenelse{\\equal{{}}{}}{\\innov{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\innov{\\alpha}_{{}}}}_k$ are defined as (\\ref{eq:ph_distr}) and  (\\ref{eq:rand_alp}), respectively. The matrix  function ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ can be expressed as\n\\begin{IEEEeqnarray}{rCl}\n{H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) &=& { \\ifthenelse{\\equal{{}}{}}{e^{-i\\phi}}{e^{-i\\phi_{{}}}}}{J}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) =  \\exp(-i({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}+{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}{\\mathbf{I}_{{2}}})) \\label{eq_rot_full}\\\\\n                 &=& ( \\cos{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}} - i \\sin{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}})({\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} - i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}),\\IEEEeqnarraynumspace \\label{eq_rot_full2}\n\\end{IEEEeqnarray}\nwhich combines the effects of both phase noise and SOP drift.\n\n\n\n\n\\section{Polarization and Phase Tracking Algorithm} \\label{sec:alg}\nIn order to successfully decode the data at the receiver, the channel matrix ${\\mathbf{{H}}_{{k}}}$ (or, equivalently, ${ \\ifthenelse{\\equal{{k}}{}}{\\phi}{\\phi_{{k}}}}$ and ${\\mathbf{{J}}_{{k}}}$) needs to be estimated and tracked during transmission such that it is possible to accurately estimate ${\\mathbf{u}_{{k}}}$ from the received sample ${\\mathbf{r}_{{k}}}$. This section provides a description of the proposed algorithm to estimate ${\\mathbf{{H}}_{{k}}}$, first using the Jones formalism, thereafter alternatives using the Stokes and real 4D formalisms are given.\n\nThe Jones description can be replaced by the Stokes or real 4D descriptions, which can provide benefits in  some situations \\cite{Czegledi2015a}. The analytics describing  wave propagation based on the Jones formalism rely on complex two-dimensional vectors and matrices that have \\emph{four} DOFs. This description is sufficient for wave propagation since it can cover any linear phenomenon that can arise during photon propagation. The Stokes description is preferred in some situations since the Stokes vectors  are observable quantities and can be visualized as points on a  three-dimensional sphere, called the Poincar\\'e sphere. In this case, the channel matrix ${\\mathbf{{J}}_{{k}}}$ is replaced by a $3\\times 3$ Mueller matrix ${\\mathbf{{M}}_{{k}}}$ with \\emph{three} DOFs that models only the changes of the SOP. The Stokes description cannot model absolute phase shifts, therefore it is immune to phase noise.\nThe real 4D formalism models the channel behavior using $4\\times 4$ real rotation matrices that have \\emph{six} DOFs, which span over a richer space than \nthe  Jones (four DOFs) or Mueller  (three DOFs) matrices can. However, only four of them are physically realizable for propagating photons and the other two can be synthesized using DSP \\cite{Karlsson2014}.\n\nIn the remainder of this section, we will provide the derivation of the proposed tracking algorithm using the Jones description, after which the equivalent algorithms  using the Stokes and the real 4D descriptions are given. The details of the channel model descriptions using the Stokes and real 4D descriptions are omitted  and can be found in \\cite{Czegledi2015a}.\n\\subsection{Jones Description} \\label{sec:Jones_descr}\nThe considered DSP setup is shown in Fig.~\\ref{fig:sysm}, where we combine the SOP drift and carrier phase tracking, i.e., estimation of ${\\mathbf{{H}}_{{k}}}$, into a single block after the  frequency offset compensation, which can be done in this case using spectrum-based methods {\\cite{Sun2011,Nakagawa2010}}.\nConsidering that ${\\mathbf{{H}}_{{k}}}$ does not change significantly over a symbol duration, we estimate the transmitted symbol from ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}$ based on a previously calculated estimate of the channel matrix  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$ using the minimum Euclidean distance criterion\n\n", "index": 25, "text": "\\begin{equation}\\label{eq:dec}\n  {\\hat{\\bx{}}_{{k}}} = {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}}- \\mathbf{c}}^2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"{\\hat{\\bx{}}_{{k}}}={\\operatorname{arg\\,min}}_{\\mathbf{c}\\in\\mathscr{C}}\\norm{%&#10;{{\\hat{{\\mathbf{{H}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}}-\\mathbf{c}}^{2}.\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bx</mtext></merror><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>=</mo><mrow><mrow><msub><mrow><mpadded width=\"+1.7pt\"><mi>arg</mi></mpadded><mo>\u2062</mo><mi>min</mi></mrow><mrow><mi>\ud835\udc1c</mi><mo>\u2208</mo><mi class=\"ltx_font_mathscript\">\ud835\udc9e</mi></mrow></msub><mo>\u2061</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\norm</mtext></merror><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc07</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow></mrow><mo>-</mo><msup><mi>\ud835\udc1c</mi><mn>2</mn></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and  ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$  are estimates of ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}  $ and ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$. These estimates are calculated such that  the error function \n\n", "itemtype": "equation", "pos": 26732, "prevtext": "\nThereafter  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$ is updated as \n\n", "index": 27, "text": "\\begin{equation}\\label{eq:T_hat_up}\n  {\\hat{{\\mathbf{{H}}_{{}}}}_{{k+1}}} = {H}({ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"{\\hat{{\\mathbf{{H}}}}_{{k+1}}}={H}({\\hat{{\\phi}}_{{k}}},{\\hat{{{\\boldsymbol{%&#10;\\alpha}}}}_{{k}}}){\\hat{{\\mathbf{{H}}}}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udc07</mi><mo stretchy=\"false\">^</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>\u03d5</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>,</mo><msub><mover accent=\"true\"><mi>\ud835\udf36</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mover accent=\"true\"><mi>\ud835\udc07</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nis  minimized with respect to ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}$ and ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$, i.e., \n\n", "itemtype": "equation", "pos": 27734, "prevtext": "\nwhere ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and  ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$  are estimates of ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}  $ and ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$. These estimates are calculated such that  the error function \n\n", "index": 29, "text": "\\begin{equation}\\label{eq:error_func}\n{e}_{{k}} = \\norm{\\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}}}^2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"{e}_{{k}}=\\norm{\\Big{(}{H}({\\phi},{{\\boldsymbol{\\alpha}}}{}){\\hat{{\\mathbf{{H}%&#10;}}}_{{k}}}\\Big{)}^{-1}{\\mathbf{r}_{{k}}}-{\\hat{\\bx{}}_{{k}}}}^{2},\" display=\"block\"><mrow><mrow><msub><mi>e</mi><mi>k</mi></msub><mo>=</mo><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\norm</mtext></merror><mo>\u2062</mo><msup><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mo>,</mo><mi>\ud835\udf36</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mover accent=\"true\"><mi>\ud835\udc07</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow><mo>-</mo><mmultiscripts><mover accent=\"true\"><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bx</mtext></merror><mo stretchy=\"false\">^</mo></mover><mi>k</mi><none/><none/><mn>2</mn></mmultiscripts></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nThis can be achieved by computing   ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and  ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$  using the   gradient descent method \\cite[p.~466]{Boyd2004} \n\\begin{IEEEeqnarray}{rCl}\n  { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}  &=& - {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Bigg ( {\\frac{\\partial {{e}_{{k}}}}{\\partial {{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}}\\bigg\\vert_{\\raisemath{4.5pt}{{\\subalign{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}&=0\\\\ { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}&=[0,0,0]^{\\mathrm{T}}}}}} \\Bigg )  \\label{eq:ph_up} \\\\\n                   &=& -2  {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}  {\\mathbf{r}_{{k}}}\\Big ), \\label{eq:ph_up2}\n\\end{IEEEeqnarray}\n\\begin{IEEEeqnarray}{rCl}\n  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}  &=& - {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Bigg (\\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}} {e}_{{k}} \\bigg\\vert_{\\raisemath{4.5pt}{{\\subalign{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}&=0\\\\ { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}&=[0,0,0]^{\\mathrm{T}}}}}} \\Bigg ) \\label{eq:SOP_up} \\\\\n                       &=& - 2 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} {\\mathbf{r}_{{k}}}\\Big ), \\label{eq:SOP_up2}\n\\end{IEEEeqnarray}\nwhere ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ are positive tracking  step sizes of the phase and of the SOP parameters, respectively, which determine the speed of the algorithm's convergence, the tracking accuracy, and the rate at which changes in the channel can be tracked. The derivations of \\eqref{eq:ph_up2}  and \\eqref{eq:SOP_up2} can be found in the Appendix. Both innovation parameters ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ and ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k $ have zero mean by (\\ref{eq:ph_distr}) and (\\ref{eq:rand_alp}); therefore the partial derivatives in (\\ref{eq:ph_up}) and (\\ref{eq:SOP_up}) are evaluated at ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}=0 , \\, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}=[0,0,0]^{\\mathrm{T}}$, which results in no preferred direction of ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$. Evaluating the gradient at non-zero values could compensate for constant offsets; e.g., using ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}} \\neq 0$ could compensate for frequency offsets.\n\nIt is important to note that ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is a many-to-one function. Therefore ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and $  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ are not necessarily equal to ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ and can have different values, but resulting in same matrix ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$.  \n\n\n\n\n\nSince the typical drift time of the SOP  is  slower  ($\\sim1~$\\si{\\ms} or larger) \\cite{Ogaki2003, Krummrich2005, Czegledi2015a} than the drift of the phase noise ($\\sim1$ \\si{\\micro\\second}) \\cite{Pfau2009}, we chose the tracking steps ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}, {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ of the two phenomena differently. For the same reasons, the update of the SOP estimate ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}} $ can be done less often than the update of the absolute phase estimate $ { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$, which will result in a decreased DSP complexity. In this case, ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ can be calculated using (\\ref{eq:ph_up2}) at every time instance $k$ and ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ using (\\ref{eq:SOP_up2}) only at every $P$ symbols, otherwise should be set to $[0,0,0]^{\\mathrm{T}}$. \n\nFig.~\\ref{fig:tracking} shows an example of the algorithm's tracking capability, where we compare the sum of the innovations ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ with their estimates  ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ obtained using the proposed algorithm. Even though, as mentioned above,  ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ do not have to follow ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ to obtain a good estimate of the channel matrix ${\\mathbf{{H}}_{{k}}}$, the algorithm manages to obtain similar parameters efficiently without exhibiting cycle slips over the $10^5$ simulated symbols. Perhaps different values of ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ may be obtained if the initial values ${ \\ifthenelse{\\equal{{0}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{0}}}}, { \\ifthenelse{\\equal{{0}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{0}}}}$  are not set to be the same as  ${ \\ifthenelse{\\equal{{0}}{}}{\\phi}{\\phi_{{0}}}}, { \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}{}$. Note that the plotted parameters are just for demonstration purposes and do not reflect the behavior of ${\\mathbf{{H}}_{{k}}}$ or ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$,  since ${\\mathbf{{H}}_{{k}}} \\neq {H}(\\underset{\\tiny k}{\\Sigma} \\, { \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, \\underset{\\tiny k}{\\Sigma} \\,{ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}{}_k)$ because in general ${H}({ \\ifthenelse{\\equal{{1}}{}}{\\phi}{\\phi_{{1}}}}+{ \\ifthenelse{\\equal{{2}}{}}{\\phi}{\\phi_{{2}}}}, { \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{}+{ \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{}) \\neq  {H}({ \\ifthenelse{\\equal{{1}}{}}{\\phi}{\\phi_{{1}}}}, { \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{}){H}({ \\ifthenelse{\\equal{{2}}{}}{\\phi}{\\phi_{{2}}}}, { \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{})$. \n\n\nIn a prestudy for this work\\cite{Czegledi2015}, we investigated a similar algorithm that tracks both the carrier phase and the SOP jointly. The main difference between the two algorithms consists in the updating rule of ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$, which in (\\ref{eq:T_hat_up}) is done as a matrix multiplication. However, the method in \\cite{Czegledi2015} was based on a different system model that did not reflect random SOP drift accurately; therefore it is not suited for installed fiber transmissions.\n\n\n\n\n\n\\begin{figure}[t]\n  \\centering\n  \n  \\hspace{0.5cm} \n  \\includegraphics{tracking2_z}\n  \n \\\\\n \\vspace{0.2cm}\n  \\includegraphics{tracking2}\n\\psframe[linewidth=0.5pt,framearc=0](-5.85, 4.05)(-6.25, 4.7)\n\\psline[linewidth=0.5pt](-5.85, 4.7)(-1.3,  5.3)\n\\psline[linewidth=0.5pt](-6.25, 4.7)(-6.45, 5.3)\n\\caption{Tracked channel parameters using the proposed algorithm with ${\\Delta \\nu}=1$ MHz and ${\\Delta p}=1$ kHz at  28 Gbaud PM-16-QAM are shown. As can be seen,  the algorithm has excellent tracking capabilities without exhibiting cycle slips.}\n\\label{fig:tracking}\n\\end{figure}\n\n\n\n\n\\subsection{Stokes Description}\n\\label{sec:sts_descr}\nIn this case, the propagation of the electric field can be  modeled as \\cite{Czegledi2015a}\n\n", "itemtype": "equation", "pos": 28178, "prevtext": "\nis  minimized with respect to ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}$ and ${ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$, i.e., \n\n", "index": 31, "text": "\\begin{equation} \\label{eq:min_er}\n [{ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}] = {\\operatorname{arg\\,min}}_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, \\, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}} {e}_{{k}} .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"[{\\hat{{\\phi}}_{{k}}},{\\hat{{{\\boldsymbol{\\alpha}}}}_{{k}}}]={\\operatorname{%&#10;arg\\,min}}_{{\\phi},\\,{{\\boldsymbol{\\alpha}}}{}}{e}_{{k}}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">[</mo><msub><mover accent=\"true\"><mi>\u03d5</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>,</mo><msub><mover accent=\"true\"><mi>\ud835\udf36</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mrow><msub><mrow><mpadded width=\"+1.7pt\"><mi>arg</mi></mpadded><mo>\u2062</mo><mi>min</mi></mrow><mrow><mi>\u03d5</mi><mo rspace=\"4.2pt\">,</mo><mi>\ud835\udf36</mi></mrow></msub><mo>\u2061</mo><msub><mi>e</mi><mi>k</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere  ${\\mathbf{s}_{{{\\mathbf{u}_{{k}}}}}} ={\\mathbf{u}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{u}_{{k}}}$ and   ${\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} ={\\mathbf{r}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{r}_{{k}}}$ are the corresponding Stokes vectors of ${\\mathbf{u}_{{k}}}$ and ${\\mathbf{r}_{{k}}}$ \\cite[eq.~(2.5.26)]{Damask2005}. The noise term is ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}} =  ({\\mathbf{{H}}_{{k}}} {\\mathbf{u}_{{k}}})^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}+{\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{{H}}_{{k}}} {\\mathbf{u}_{{k}}} + {\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}$ and can be identified by equating terms after substituting \\eqref{eq:sys_mod_ful} in ${\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} ={\\mathbf{r}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{r}_{{k}}}$. As can be noted, ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}}$ is signal dependent and \\eqref{eq:st_sys_mod} is not an additive noise model, opposed to \\eqref{eq:sys_mod_ful}.  The channel matrix ${\\mathbf{{M}}_{{k}}}$ modeling the evolution of the SOP can be expressed using a $3 \\times 3$ Mueller matrix defined as\\cite{Gordon2000}\n\\begin{IEEEeqnarray}{c} \n  {M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}) = \\exp(2{\\mathcal{K}({{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}})}), \\label{eq:st_mat_exp1}\n\\end{IEEEeqnarray}\nwhere ${\\mathcal{K}({{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}})}$ denotes the cross-product operator \\cite[eq.~(11)]{Karlsson2014}\n\n", "itemtype": "equation", "pos": 39122, "prevtext": "\nThis can be achieved by computing   ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and  ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$  using the   gradient descent method \\cite[p.~466]{Boyd2004} \n\\begin{IEEEeqnarray}{rCl}\n  { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}  &=& - {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Bigg ( {\\frac{\\partial {{e}_{{k}}}}{\\partial {{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}}\\bigg\\vert_{\\raisemath{4.5pt}{{\\subalign{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}&=0\\\\ { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}&=[0,0,0]^{\\mathrm{T}}}}}} \\Bigg )  \\label{eq:ph_up} \\\\\n                   &=& -2  {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}  {\\mathbf{r}_{{k}}}\\Big ), \\label{eq:ph_up2}\n\\end{IEEEeqnarray}\n\\begin{IEEEeqnarray}{rCl}\n  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}  &=& - {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Bigg (\\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}} {e}_{{k}} \\bigg\\vert_{\\raisemath{4.5pt}{{\\subalign{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}&=0\\\\ { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}&=[0,0,0]^{\\mathrm{T}}}}}} \\Bigg ) \\label{eq:SOP_up} \\\\\n                       &=& - 2 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} {\\mathbf{r}_{{k}}}\\Big ), \\label{eq:SOP_up2}\n\\end{IEEEeqnarray}\nwhere ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ are positive tracking  step sizes of the phase and of the SOP parameters, respectively, which determine the speed of the algorithm's convergence, the tracking accuracy, and the rate at which changes in the channel can be tracked. The derivations of \\eqref{eq:ph_up2}  and \\eqref{eq:SOP_up2} can be found in the Appendix. Both innovation parameters ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}$ and ${ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k $ have zero mean by (\\ref{eq:ph_distr}) and (\\ref{eq:rand_alp}); therefore the partial derivatives in (\\ref{eq:ph_up}) and (\\ref{eq:SOP_up}) are evaluated at ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}=0 , \\, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}=[0,0,0]^{\\mathrm{T}}$, which results in no preferred direction of ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$. Evaluating the gradient at non-zero values could compensate for constant offsets; e.g., using ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}} \\neq 0$ could compensate for frequency offsets.\n\nIt is important to note that ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ is a many-to-one function. Therefore ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ and $  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ are not necessarily equal to ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ and can have different values, but resulting in same matrix ${H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$.  \n\n\n\n\n\nSince the typical drift time of the SOP  is  slower  ($\\sim1~$\\si{\\ms} or larger) \\cite{Ogaki2003, Krummrich2005, Czegledi2015a} than the drift of the phase noise ($\\sim1$ \\si{\\micro\\second}) \\cite{Pfau2009}, we chose the tracking steps ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}, {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ of the two phenomena differently. For the same reasons, the update of the SOP estimate ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}} $ can be done less often than the update of the absolute phase estimate $ { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$, which will result in a decreased DSP complexity. In this case, ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ can be calculated using (\\ref{eq:ph_up2}) at every time instance $k$ and ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ using (\\ref{eq:SOP_up2}) only at every $P$ symbols, otherwise should be set to $[0,0,0]^{\\mathrm{T}}$. \n\nFig.~\\ref{fig:tracking} shows an example of the algorithm's tracking capability, where we compare the sum of the innovations ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ with their estimates  ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ obtained using the proposed algorithm. Even though, as mentioned above,  ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ do not have to follow ${ \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, { \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}_k$ to obtain a good estimate of the channel matrix ${\\mathbf{{H}}_{{k}}}$, the algorithm manages to obtain similar parameters efficiently without exhibiting cycle slips over the $10^5$ simulated symbols. Perhaps different values of ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ may be obtained if the initial values ${ \\ifthenelse{\\equal{{0}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{0}}}}, { \\ifthenelse{\\equal{{0}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{0}}}}$  are not set to be the same as  ${ \\ifthenelse{\\equal{{0}}{}}{\\phi}{\\phi_{{0}}}}, { \\ifthenelse{\\equal{{0}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{0}}}}{}$. Note that the plotted parameters are just for demonstration purposes and do not reflect the behavior of ${\\mathbf{{H}}_{{k}}}$ or ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$,  since ${\\mathbf{{H}}_{{k}}} \\neq {H}(\\underset{\\tiny k}{\\Sigma} \\, { \\ifthenelse{\\equal{{k}}{}}{\\innov{\\phi}}{\\innov{\\phi}_{{k}}}}, \\underset{\\tiny k}{\\Sigma} \\,{ \\ifthenelse{\\equal{{}}{}}{\\innov{\\alpv{}}}{\\innov{\\alpha}_{{}}}}{}_k)$ because in general ${H}({ \\ifthenelse{\\equal{{1}}{}}{\\phi}{\\phi_{{1}}}}+{ \\ifthenelse{\\equal{{2}}{}}{\\phi}{\\phi_{{2}}}}, { \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{}+{ \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{}) \\neq  {H}({ \\ifthenelse{\\equal{{1}}{}}{\\phi}{\\phi_{{1}}}}, { \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{}){H}({ \\ifthenelse{\\equal{{2}}{}}{\\phi}{\\phi_{{2}}}}, { \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{})$. \n\n\nIn a prestudy for this work\\cite{Czegledi2015}, we investigated a similar algorithm that tracks both the carrier phase and the SOP jointly. The main difference between the two algorithms consists in the updating rule of ${\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}$, which in (\\ref{eq:T_hat_up}) is done as a matrix multiplication. However, the method in \\cite{Czegledi2015} was based on a different system model that did not reflect random SOP drift accurately; therefore it is not suited for installed fiber transmissions.\n\n\n\n\n\n\\begin{figure}[t]\n  \\centering\n  \n  \\hspace{0.5cm} \n  \\includegraphics{tracking2_z}\n  \n \\\\\n \\vspace{0.2cm}\n  \\includegraphics{tracking2}\n\\psframe[linewidth=0.5pt,framearc=0](-5.85, 4.05)(-6.25, 4.7)\n\\psline[linewidth=0.5pt](-5.85, 4.7)(-1.3,  5.3)\n\\psline[linewidth=0.5pt](-6.25, 4.7)(-6.45, 5.3)\n\\caption{Tracked channel parameters using the proposed algorithm with ${\\Delta \\nu}=1$ MHz and ${\\Delta p}=1$ kHz at  28 Gbaud PM-16-QAM are shown. As can be seen,  the algorithm has excellent tracking capabilities without exhibiting cycle slips.}\n\\label{fig:tracking}\n\\end{figure}\n\n\n\n\n\\subsection{Stokes Description}\n\\label{sec:sts_descr}\nIn this case, the propagation of the electric field can be  modeled as \\cite{Czegledi2015a}\n\n", "index": 33, "text": "\\begin{equation}\\label{eq:st_sys_mod}\n  {\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} = {\\mathbf{{M}}_{{k}}} {\\mathbf{s}_{{{\\mathbf{u}_{{k}}}}}} + {\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}}={\\mathbf{{M}}_{{k}}}{\\mathbf{s}_{{{\\mathbf%&#10;{u}_{{k}}}}}}+{\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub><mo>=</mo><mrow><mrow><msub><mi>\ud835\udc0c</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></msub></mrow><mo>+</mo><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc27</mi><mi>k</mi></msub></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nThe inverse can be obtained as \n${M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{-1}={M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{{\\mathrm{T}}}={M}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$. \nThe  polarization transformations introduced by ${\\mathbf{{M}}_{{k}}}$ can be seen as  {rotations} of the Poincar\\'e sphere around the unit vector ${ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$ by an angle $2{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}$.\n\n\nAnalogously to the Jones description, the algorithm decides first which was the transmitted Stokes vector  based on the  minimum Euclidean distance criterion\n\n", "itemtype": "equation", "pos": 41201, "prevtext": "\nwhere  ${\\mathbf{s}_{{{\\mathbf{u}_{{k}}}}}} ={\\mathbf{u}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{u}_{{k}}}$ and   ${\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} ={\\mathbf{r}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{r}_{{k}}}$ are the corresponding Stokes vectors of ${\\mathbf{u}_{{k}}}$ and ${\\mathbf{r}_{{k}}}$ \\cite[eq.~(2.5.26)]{Damask2005}. The noise term is ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}} =  ({\\mathbf{{H}}_{{k}}} {\\mathbf{u}_{{k}}})^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}+{\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{{H}}_{{k}}} {\\mathbf{u}_{{k}}} + {\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}$ and can be identified by equating terms after substituting \\eqref{eq:sys_mod_ful} in ${\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} ={\\mathbf{r}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{r}_{{k}}}$. As can be noted, ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}}$ is signal dependent and \\eqref{eq:st_sys_mod} is not an additive noise model, opposed to \\eqref{eq:sys_mod_ful}.  The channel matrix ${\\mathbf{{M}}_{{k}}}$ modeling the evolution of the SOP can be expressed using a $3 \\times 3$ Mueller matrix defined as\\cite{Gordon2000}\n\\begin{IEEEeqnarray}{c} \n  {M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}) = \\exp(2{\\mathcal{K}({{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}})}), \\label{eq:st_mat_exp1}\n\\end{IEEEeqnarray}\nwhere ${\\mathcal{K}({{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}})}$ denotes the cross-product operator \\cite[eq.~(11)]{Karlsson2014}\n\n", "index": 35, "text": "\\begin{equation}\n  {\\mathcal{K}({{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}})} =\n\\begin{pmatrix}\n  0 &  -{ \\ifthenelse{\\equal{{3}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{3}}}}{} & { \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{} \\\\\n { \\ifthenelse{\\equal{{3}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{3}}}}{} &  0 & -{ \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{} \\\\\n  -{ \\ifthenelse{\\equal{{2}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{2}}}}{} &  { \\ifthenelse{\\equal{{1}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{1}}}}{} & 0 \n\\end{pmatrix}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{K}({{{{\\boldsymbol{\\alpha}}}}})}=\\begin{pmatrix}0&amp;-{{\\boldsymbol{%&#10;\\alpha}}_{{3}}}&amp;{{\\boldsymbol{\\alpha}}_{{2}}}\\\\&#10;{{\\boldsymbol{\\alpha}}_{{3}}}&amp;0&amp;-{{\\boldsymbol{\\alpha}}_{{1}}}\\\\&#10;-{{\\boldsymbol{\\alpha}}_{{2}}}&amp;{{\\boldsymbol{\\alpha}}_{{1}}}&amp;0\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udca6</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udf36</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><msub><mi>\ud835\udf36</mi><mn>3</mn></msub></mrow></mtd><mtd columnalign=\"center\"><msub><mi>\ud835\udf36</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>\ud835\udf36</mi><mn>3</mn></msub></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><msub><mi>\ud835\udf36</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><msub><mi>\ud835\udf36</mi><mn>2</mn></msub></mrow></mtd><mtd columnalign=\"center\"><msub><mi>\ud835\udf36</mi><mn>1</mn></msub></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nusing the inverted estimate of ${\\mathbf{{M}}_{{k}}}$, where\\footnote{Note that for constellations with rotational symmetry, more than one constellation point  will correspond to the same Stokes vector; e.g.,  the PM-QAM modulation format has a  four-fold rotational symmetry, therefore four distinct constellation points $\\mathbf{c}$ will correspond to the same Stokes vector ${\\mathbf{s}_{{\\mathbf{c}}}}$.} ${\\mathbf{s}_{{\\mathbf{c}}}} = \\mathbf{c}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\mathbf{c}$.  Thereafter, $ {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}}$ is updated analogously to (\\ref{eq:T_hat_up}) as\n\n", "itemtype": "equation", "pos": 42593, "prevtext": "\nThe inverse can be obtained as \n${M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{-1}={M}{}({ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{{\\mathrm{T}}}={M}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$. \nThe  polarization transformations introduced by ${\\mathbf{{M}}_{{k}}}$ can be seen as  {rotations} of the Poincar\\'e sphere around the unit vector ${ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$ by an angle $2{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}$.\n\n\nAnalogously to the Jones description, the algorithm decides first which was the transmitted Stokes vector  based on the  minimum Euclidean distance criterion\n\n", "index": 37, "text": "\\begin{equation} \\label{eq:st_err_func}\n  {\\hat{\\mathbf{s}}_{{{\\mathbf{u}_{{k}}}}}} = {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}^{-1}}{\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}}}- {\\mathbf{s}_{{\\mathbf{c}}}}}^2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"{\\hat{\\mathbf{s}}_{{{\\mathbf{u}_{{k}}}}}}={\\operatorname{arg\\,min}}_{\\mathbf{c%&#10;}\\in\\mathscr{C}}\\norm{{{\\hat{{\\mathbf{{M}}}}_{{k}}^{-1}}{\\mathbf{s}_{{{\\mathbf%&#10;{r}_{{k}}}}}}}-{\\mathbf{s}_{{\\mathbf{c}}}}}^{2},\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udc2c</mi><mo stretchy=\"false\">^</mo></mover><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></msub><mo>=</mo><mrow><mrow><msub><mrow><mpadded width=\"+1.7pt\"><mi>arg</mi></mpadded><mo>\u2062</mo><mi>min</mi></mrow><mrow><mi>\ud835\udc1c</mi><mo>\u2208</mo><mi class=\"ltx_font_mathscript\">\ud835\udc9e</mi></mrow></msub><mo>\u2061</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\norm</mtext></merror><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc0c</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub></mrow></mrow><mo>-</mo><mmultiscripts><mi>\ud835\udc2c</mi><mi>\ud835\udc1c</mi><none/><none/><mn>2</mn></mmultiscripts></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nAnalogously with \\eqref{eq:min_er}--\\eqref{eq:SOP_up2}, it can be shown that the optimal   ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}=[{ \\ifthenelse{\\equal{{k,1}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,1}}}},{ \\ifthenelse{\\equal{{k,2}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,2}}}},{ \\ifthenelse{\\equal{{k,3}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,3}}}}]^{\\mathrm{T}}$ are computed as \n\n", "itemtype": "equation", "pos": 43513, "prevtext": "\nusing the inverted estimate of ${\\mathbf{{M}}_{{k}}}$, where\\footnote{Note that for constellations with rotational symmetry, more than one constellation point  will correspond to the same Stokes vector; e.g.,  the PM-QAM modulation format has a  four-fold rotational symmetry, therefore four distinct constellation points $\\mathbf{c}$ will correspond to the same Stokes vector ${\\mathbf{s}_{{\\mathbf{c}}}}$.} ${\\mathbf{s}_{{\\mathbf{c}}}} = \\mathbf{c}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\mathbf{c}$.  Thereafter, $ {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}}$ is updated analogously to (\\ref{eq:T_hat_up}) as\n\n", "index": 39, "text": "\\begin{equation}\\label{eq:M_hat_up}\n    {\\hat{{\\mathbf{{M}}_{{}}}}_{{k+1}}} = {M}({ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}) {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"{\\hat{{\\mathbf{{M}}}}_{{k+1}}}={M}({\\hat{{{\\boldsymbol{\\alpha}}}}_{{k}}}){\\hat%&#10;{{\\mathbf{{M}}}}_{{k}}}.\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udc0c</mi><mo stretchy=\"false\">^</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>M</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>\ud835\udf36</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mover accent=\"true\"><mi>\ud835\udc0c</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nfor $i = 1, 2 ,3$,  using the gradient descent algorithm such that the Euclidean distance in the Stokes space is minimized. \nThe vectors $\\mathbf{e}_i$  form the standard basis in $\\mathbb{R}^3$.\n\nNote that the error function that minimizes the Euclidean distance is not optimum in this case since ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}}$ includes not only noise, but signal--noise interaction. Furthermore, the noise term ${\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}$ is non-Gaussian.  Better metrics \\cite{Visintin2014} that take into account the non-Gaussian  distribution of the noise can be used, but it is outside the scope of this work.\n\n\n\\subsection{4D Real  Description}\n\\label{sec:4D-space-descr} \nIn the 4D formalism, the phase and SOP drifts are combined and modeled using a $4\\times4$ real orthogonal  matrix ${\\mathbf{R}_{{k}}}$ \\cite{Karlsson2014,Betti1991,Cusani1992}  as\n\n", "itemtype": "equation", "pos": 44530, "prevtext": "\nAnalogously with \\eqref{eq:min_er}--\\eqref{eq:SOP_up2}, it can be shown that the optimal   ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}=[{ \\ifthenelse{\\equal{{k,1}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,1}}}},{ \\ifthenelse{\\equal{{k,2}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,2}}}},{ \\ifthenelse{\\equal{{k,3}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,3}}}}]^{\\mathrm{T}}$ are computed as \n\n", "index": 41, "text": "\\begin{equation} \\label{eq:alpv_M}\n { \\ifthenelse{\\equal{{k,i}}{}}{ {\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}}{{{\\hat{\\alpha}}}_{{k,i}}}} = 4 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} ( {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}^{-1}} {\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}} - {\\hat{\\mathbf{s}}_{{{\\mathbf{u}_{{k}}}}}})^{\\mathrm{T}} {\\hat{{\\mathbf{{M}}_{{}}}}_{{k}}^{-1}}{\\mathcal{K}({{\\mathbf{e}_i}})} {\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E21.m1\" class=\"ltx_Math\" alttext=\"{{{\\hat{\\alpha}}}_{{k,i}}}=4{\\mu_{{{\\boldsymbol{\\alpha}}}}}({\\hat{{\\mathbf{{M}%&#10;}}}_{{k}}^{-1}}{\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}}-{\\hat{\\mathbf{s}}_{{{%&#10;\\mathbf{u}_{{k}}}}}})^{\\mathrm{T}}{\\hat{{\\mathbf{{M}}}}_{{k}}^{-1}}{\\mathcal{K%&#10;}({{\\mathbf{e}_{i}}})}{\\mathbf{s}_{{{\\mathbf{r}_{{k}}}}}}\" display=\"block\"><mrow><msub><mover accent=\"true\"><mi>\u03b1</mi><mo stretchy=\"false\">^</mo></mover><mrow><mi>k</mi><mo>,</mo><mi>i</mi></mrow></msub><mo>=</mo><mrow><mn>4</mn><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>\ud835\udf36</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msubsup><mover accent=\"true\"><mi>\ud835\udc0c</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub></mrow><mo>-</mo><msub><mover accent=\"true\"><mi>\ud835\udc2c</mi><mo stretchy=\"false\">^</mo></mover><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mi mathvariant=\"normal\">T</mi></msup><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc0c</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udca6</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc2c</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere $\\mathbf{v_z}$ for any $\\mathbf{z} = [z_1, z_2]^{\\mathrm{T}} \\in \\mathbb{C}^2$ is defined as $[ \\mathpzc{Re}(z_1), \\mathpzc{Im}(z_1), \\mathpzc{Re}(z_2), \\mathpzc{Im}(z_2)]^{\\mathrm{T}}$.\nThe channel matrix ${\\mathbf{R}_{{k}}}$ can be expressed using the matrix function \\cite{Karlsson2014}\n\\begin{IEEEeqnarray}{rCl}\\label{eq:4D_rot}\n{R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}) &=& \\exp(({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},0,0) \\cdot { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{}}}}-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{}}}}),\n\\end{IEEEeqnarray}\nwhere ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}})\\text{ and }{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}})$ are six\\footnote{The matrices ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}}$ and ${ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}}$ are not shown since they do not influence ${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$ in \\eqref{eq:4D_rot}.} constant basis matrices \\cite[eqs. (20)--(25)]{Karlsson2014}\n\\begin{IEEEeqnarray}{rClrCl}\n{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}} &=& \n\\begin{pmatrix}\n  0 & -1 &  0 & 0\\\\\n  1 &  0 &  0 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n  0 &  0 & -1 & 0\\\\\n\\end{pmatrix},\n\\enspace&\n{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}} &=& \n\\begin{pmatrix}\n  0 &  0 &  0 & -1\\\\\n  0 &  0 &  1 &  0\\\\\n  0 & -1 &  0 &  0\\\\\n  1 &  0 &  0 &  0\\\\\n\\end{pmatrix},\n\\IEEEeqnarraynumspace \\\\\n{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}} &=& \n\\begin{pmatrix}\n  0 &  0 &  1 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n -1 &  0 &  0 & 0\\\\\n  0 & -1 &  0 & 0\\\\\n\\end{pmatrix},\n\\enspace&\n{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}} &=&\n\\begin{pmatrix}\n  0 &  1 &  0 & 0\\\\\n -1 &  0 &  0 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n  0 &  0 & -1 & 0\\\\\n\\end{pmatrix}.\n\\end{IEEEeqnarray}\nThe inverse can be obtained as  \n${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{-1}={R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{{\\mathrm{T}}}={R}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$.\n\nAnalogously to the Jones/Stokes description, the algorithm decides first which was the transmitted symbol based on the  minimum Euclidean distance criterion\n\n", "itemtype": "equation", "pos": 45995, "prevtext": "\nfor $i = 1, 2 ,3$,  using the gradient descent algorithm such that the Euclidean distance in the Stokes space is minimized. \nThe vectors $\\mathbf{e}_i$  form the standard basis in $\\mathbb{R}^3$.\n\nNote that the error function that minimizes the Euclidean distance is not optimum in this case since ${\\mathbf{s}_{{{\\mathbf{n}_{{k}}}}}}$ includes not only noise, but signal--noise interaction. Furthermore, the noise term ${\\mathbf{n}_{{k}}}^{\\mathrm{H}}{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}{\\mathbf{n}_{{k}}}$ is non-Gaussian.  Better metrics \\cite{Visintin2014} that take into account the non-Gaussian  distribution of the noise can be used, but it is outside the scope of this work.\n\n\n\\subsection{4D Real  Description}\n\\label{sec:4D-space-descr} \nIn the 4D formalism, the phase and SOP drifts are combined and modeled using a $4\\times4$ real orthogonal  matrix ${\\mathbf{R}_{{k}}}$ \\cite{Karlsson2014,Betti1991,Cusani1992}  as\n\n", "index": 43, "text": "\\begin{equation}\\label{eq:st_sys_mod}\n  {\\mathbf{v}_{{{\\mathbf{r}_{{k}}}}}} = {\\mathbf{R}_{{k}}} {\\mathbf{v}_{{{\\mathbf{u}_{{k}}}}}} + {\\mathbf{v}_{{{\\mathbf{n}_{{k}}}}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E22.m1\" class=\"ltx_Math\" alttext=\"{\\mathbf{v}_{{{\\mathbf{r}_{{k}}}}}}={\\mathbf{R}_{{k}}}{\\mathbf{v}_{{{\\mathbf{u%&#10;}_{{k}}}}}}+{\\mathbf{v}_{{{\\mathbf{n}_{{k}}}}}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc2f</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub><mo>=</mo><mrow><mrow><msub><mi>\ud835\udc11</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2f</mi><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></msub></mrow><mo>+</mo><msub><mi>\ud835\udc2f</mi><msub><mi>\ud835\udc27</mi><mi>k</mi></msub></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nusing the inverted estimate of ${\\mathbf{R}_{{k}}}$. The estimate of the channel matrix $ {\\hat{{\\mathbf{R}_{{}}}}_{{k}}}$ is updated analogously to (\\ref{eq:T_hat_up}) as\n\n", "itemtype": "equation", "pos": 49407, "prevtext": "\nwhere $\\mathbf{v_z}$ for any $\\mathbf{z} = [z_1, z_2]^{\\mathrm{T}} \\in \\mathbb{C}^2$ is defined as $[ \\mathpzc{Re}(z_1), \\mathpzc{Im}(z_1), \\mathpzc{Re}(z_2), \\mathpzc{Im}(z_2)]^{\\mathrm{T}}$.\nThe channel matrix ${\\mathbf{R}_{{k}}}$ can be expressed using the matrix function \\cite{Karlsson2014}\n\\begin{IEEEeqnarray}{rCl}\\label{eq:4D_rot}\n{R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}) &=& \\exp(({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},0,0) \\cdot { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{}}}}-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{}}}}),\n\\end{IEEEeqnarray}\nwhere ${ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}})\\text{ and }{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{}}}}=({ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}},{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}})$ are six\\footnote{The matrices ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}}$ and ${ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}}$ are not shown since they do not influence ${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$ in \\eqref{eq:4D_rot}.} constant basis matrices \\cite[eqs. (20)--(25)]{Karlsson2014}\n\\begin{IEEEeqnarray}{rClrCl}\n{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}} &=& \n\\begin{pmatrix}\n  0 & -1 &  0 & 0\\\\\n  1 &  0 &  0 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n  0 &  0 & -1 & 0\\\\\n\\end{pmatrix},\n\\enspace&\n{ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}} &=& \n\\begin{pmatrix}\n  0 &  0 &  0 & -1\\\\\n  0 &  0 &  1 &  0\\\\\n  0 & -1 &  0 &  0\\\\\n  1 &  0 &  0 &  0\\\\\n\\end{pmatrix},\n\\IEEEeqnarraynumspace \\\\\n{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}} &=& \n\\begin{pmatrix}\n  0 &  0 &  1 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n -1 &  0 &  0 & 0\\\\\n  0 & -1 &  0 & 0\\\\\n\\end{pmatrix},\n\\enspace&\n{ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}} &=&\n\\begin{pmatrix}\n  0 &  1 &  0 & 0\\\\\n -1 &  0 &  0 & 0\\\\\n  0 &  0 &  0 & 1\\\\\n  0 &  0 & -1 & 0\\\\\n\\end{pmatrix}.\n\\end{IEEEeqnarray}\nThe inverse can be obtained as  \n${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{-1}={R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})^{{\\mathrm{T}}}={R}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$.\n\nAnalogously to the Jones/Stokes description, the algorithm decides first which was the transmitted symbol based on the  minimum Euclidean distance criterion\n\n", "index": 45, "text": "\\begin{equation}\n  {\\hat{\\mathbf{v}}_{{{\\mathbf{u}_{{k}}}}}} = {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\hat{{\\mathbf{R}_{{}}}}_{{k}}^{-1}}{\\mathbf{v}_{{{\\mathbf{r}_{{k}}}}}}}- {\\mathbf{v}_{{\\mathbf{c}}}}}^2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E23.m1\" class=\"ltx_Math\" alttext=\"{\\hat{\\mathbf{v}}_{{{\\mathbf{u}_{{k}}}}}}={\\operatorname{arg\\,min}}_{\\mathbf{c%&#10;}\\in\\mathscr{C}}\\norm{{{\\hat{{\\mathbf{R}}}_{{k}}^{-1}}{\\mathbf{v}_{{{\\mathbf{r%&#10;}_{{k}}}}}}}-{\\mathbf{v}_{{\\mathbf{c}}}}}^{2},\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udc2f</mi><mo stretchy=\"false\">^</mo></mover><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub></msub><mo>=</mo><mrow><mrow><msub><mrow><mpadded width=\"+1.7pt\"><mi>arg</mi></mpadded><mo>\u2062</mo><mi>min</mi></mrow><mrow><mi>\ud835\udc1c</mi><mo>\u2208</mo><mi class=\"ltx_font_mathscript\">\ud835\udc9e</mi></mrow></msub><mo>\u2061</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\norm</mtext></merror><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2f</mi><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></msub></mrow></mrow><mo>-</mo><mmultiscripts><mi>\ud835\udc2f</mi><mi>\ud835\udc1c</mi><none/><none/><mn>2</mn></mmultiscripts></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere, analogously with \\eqref{eq:ph_up}--\\eqref{eq:SOP_up2} and \\eqref{eq:alpv_M},\n\n", "itemtype": "equation", "pos": 49827, "prevtext": "\nusing the inverted estimate of ${\\mathbf{R}_{{k}}}$. The estimate of the channel matrix $ {\\hat{{\\mathbf{R}_{{}}}}_{{k}}}$ is updated analogously to (\\ref{eq:T_hat_up}) as\n\n", "index": 47, "text": "\\begin{equation}\\label{eq:4D_time_dep}\n  {\\hat{{\\mathbf{R}_{{}}}}_{{k+1}}} = {R}({ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}){\\hat{{\\mathbf{R}_{{}}}}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E24.m1\" class=\"ltx_Math\" alttext=\"{\\hat{{\\mathbf{R}}}_{{k+1}}}={R}({\\hat{{\\phi}}_{{k}}},{\\hat{{{\\boldsymbol{%&#10;\\alpha}}}}_{{k}}}){\\hat{{\\mathbf{R}}}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>\u03d5</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>,</mo><msub><mover accent=\"true\"><mi>\ud835\udf36</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 50357, "prevtext": "\nwhere, analogously with \\eqref{eq:ph_up}--\\eqref{eq:SOP_up2} and \\eqref{eq:alpv_M},\n\n", "index": 49, "text": "\\begin{equation}\\label{eq:ph_4D_up}\n  { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}  = 2  {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}  (\\hat{{\\mathbf{R}_{{}}}}_{k}^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{T}} \\hat{{\\mathbf{R}_{{}}}}_{k}^{-1}  { \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}} {\\mathbf{r}_{{k}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E25.m1\" class=\"ltx_Math\" alttext=\"{\\hat{{\\phi}}_{{k}}}=2{\\mu_{{\\phi}}}(\\hat{{\\mathbf{R}}}_{k}^{-1}{\\mathbf{r}_{{%&#10;k}}}-{\\hat{\\bx{}}_{{k}}})^{\\mathrm{T}}\\hat{{\\mathbf{R}}}_{k}^{-1}{{\\boldsymbol%&#10;{\\lambda}}_{{1}}}{\\mathbf{r}_{{k}}},\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\u03d5</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>=</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>\u03d5</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msubsup><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow><mo>-</mo><msub><mover accent=\"true\"><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bx</mtext></merror><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mi mathvariant=\"normal\">T</mi></msup><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udf40</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\n\n\nIn the above description, only four DOFs, i.e., the scalars ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}$, ${ \\ifthenelse{\\equal{{1}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{1}}}{\\alpha^{({})}_{{1}}}}}$, ${ \\ifthenelse{\\equal{{2}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{2}}}{\\alpha^{({})}_{{2}}}}}$, and ${ \\ifthenelse{\\equal{{3}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{3}}}{\\alpha^{({})}_{{3}}}}}$ corresponding to ${ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}}$, ${ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}}$, ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}}$, and ${ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}}$, respectively,  of the matrix ${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$ were used, which correspond to the carrier phase and the SOP drift. The other two DOFs, i.e., the scalars corresponding to ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}}$ in (\\ref{eq:4D_rot}), can be used to correct certain transmitter and/or receiver hardware imperfections, which cannot be done using Jones or Stokes formalisms, such as \\SI{90}{\\degree} I/Q error or the time skew between I and Q \\cite{Crivelli2014}.\n\nThe algorithm presented in this section is fully equivalent to the one in Section \\ref{sec:Jones_descr} and will have the same performance, but not to the one in Section \\ref{sec:sts_descr}. The latter may have a different performance due to the suboptimal error function and  a separate solution to mitigate the phase noise is required in the latter case since it will not be covered by $\\hat{{\\mathbf{{M}}_{{}}}}_k$.\n\\section{Results}\\label{sec:results}\nWe evaluated the achievable performance of the proposed recovery algorithm numerically.  The details of the simulation setup are described in Section~\\ref{sec:sim-setup}, whereas in Sections~\\labelcref{subsec:pol_tol,subsec:ls_tol,subsec:snr_tol,subsec:conv_rate} various  performance metrics of the algorithm are evaluated. \n\n\\begin{table*}[!t]\n\t\t\n\t\t\\ra{1.2}\n\t\t\\caption[]{Algorithm parameters, achievable performance, and hardware complexity}\n\t\t\\centering\n\t\t\\begin{tabu}\n                  {p{1.4cm}  p{1.6cm}  p{2.45cm} p{1.23cm} p{1.5cm} p{1.27cm} p{1.5cm} C{0.95cm} C{1.2cm}  C{0.8cm}}\n                  \\toprule\n                  & & {Algorithm parameters} & {Max. tol. ${\\Delta p} \\cdot T$} & \\mbox{{Max.~tol. ${\\Delta p}$}} \\mbox{at 28 Gbaud} & {Max.~tol. ${\\Delta \\nu} \\cdot T$} & \\mbox{Max. tol. ${\\Delta \\nu} $} \\mbox{at 28 Gbaud} &  Operations & Comparisons  & Memory units \\\\\n                  \\midrule\n\n\n                  \\multirow{5}{*}{PS-QPSK} \n                  & Kabsch & $N_\\mathrm{Kab}=31$     &  \\mbox{$ 0.34\\cdot 10^{-4}$} & $ 0.95$ MHz  &   $0.91\\cdot 10^{-4}$ & $2.55 $ MHz & 132 &  7  & 0.5  \\\\\n                  & \\multirow{3}{*}{PS-CMA+BPS} &   $N_{\\mathrm{BPS}}=13$     &    \\multirow{3}{*}{\\mbox{$0.33\\cdot 10^{-4}$}}  &    \\multirow{3}{*}{$0.93$ MHz} &    \\multirow{3}{*}{$6.67\\cdot 10^{-4}$}   &    \\multirow{3}{*}{$18.68$ MHz} &  \\multirow{3}{*}{1320}  &  \\multirow{3}{*}{267} &  \\multirow{3}{*}{856} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{CMA}}=0.04/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=27$       & \\mbox{$  3.20\\cdot 10^{-4}$} &  $8.96$ MHz & $11.5\\cdot 10^{-4}$ & $32.2$ MHz & 346 & 7 & 8\\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-QPSK}\n                  & Kabsch & $N_\\mathrm{Kab}=16$     &\\mbox{$   0.17\\cdot 10^{-4}$} & $ 0.47$ MHz &   $0.79\\cdot 10^{-4 }$ & $ 2.23$ MHz & 171 &   4  & 1  \\\\\n                  & \\multirow{3}{*}{CMA+BPS} & $N_{\\mathrm{BPS}}=19$   &    \\multirow{3}{*}{\\mbox{$0.37\\cdot 10^{-4}$}}  &    \\multirow{3}{*}{$1.04$ MHz} &    \\multirow{3}{*}{$6.98\\cdot 10^{-4}$}  &    \\multirow{3}{*}{$19.54$ MHz} &  \\multirow{3}{*}{2936}  &  \\multirow{3}{*}{304} &  \\multirow{3}{*}{1264} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{CMA}}=0.16/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=64$     &  \\mbox{$1.17\\cdot 10^{-4}$}& $ 3.28$ MHz &  $ 9.06\\cdot 10^{-4}$ & $25.37$ MHz  & 346 & 4   & 8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-16-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$    & \\mbox{$ 0.44\\cdot 10^{-5}$}& $122.1 $ kHz & $  0.15\\cdot 10^{-4}$ & $ 0.412$ MHz & 171 &  12  & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{BPS}}=19$    &    \\multirow{3}{*}{\\mbox{$0.14\\cdot 10^{-5}$}}  &    \\multirow{3}{*}{$ 37.8$ kHz} &    \\multirow{3}{*}{$1.48\\cdot 10^{-4}$}  &    \\multirow{3}{*}{$ 4.14$ MHz} &  \\multirow{3}{*}{2940}  &  \\multirow{3}{*}{840} & \\multirow{3}{*}{1264} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}=0.04/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=400$    & \\mbox{$  2.48\\cdot 10^{-5}$}& $694.4 $ kHz  &  $1.35\\cdot 10^{-4}$ & $3.78 $ MHz  & 346 & 12  & 8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-64-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$   & \\mbox{$0.66\\cdot 10^{-6}$}& $ 18.4$ kHz &  $ 0.32\\cdot 10^{-5}$  & $ 90.2$ kHz & 171 &  28   & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{BPS}}=19$    &    \\multirow{3}{*}{\\mbox{$0.11\\cdot 10^{-6}$}}  &    \\multirow{3}{*}{$ 3.1 $ kHz} &    \\multirow{3}{*}{$3.06\\cdot 10^{-5}$}  &    \\multirow{3}{*}{$856.8 $ kHz} &  \\multirow{3}{*}{5768}  &  \\multirow{3}{*}{3806} &  \\multirow{3}{*}{2480} \\\\\n                  & & $P_\\mathrm{BPS} =64$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}=0.035/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=2352$    & \\mbox{$4.59\\cdot 10^{-6}$}& $128.5 $ kHz  & $  2.54\\cdot 10^{-5}$ & $711.2 $ kHz  & 346 & 28 &  8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-256-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$    &  \\mbox{$0.19\\cdot 10^{-6}$}  & $ 5.3$ kHz &  $ 0.74\\cdot 10^{-6}$ & $ 20.6$ kHz & 171 &  60  & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{\\mathrm{BPS}}}=19$     &    \\multirow{3}{*}{\\mbox{$8.42\\cdot 10^{-9}$}}  &    \\multirow{3}{*}{$ 0.2 $ kHz} &    \\multirow{3}{*}{--}  &    \\multirow{3}{*}{--} &  \\multirow{3}{*}{5814}  &  \\multirow{3}{*}{8058} &   \\multirow{3}{*}{2480} \\\\\n                  & & $P_\\mathrm{BPS} =64$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}~= 0.017/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=6084$     &   \\mbox{$1.22\\cdot 10^{-6}$} & $ 34.1$ kHz&  $ 6.30\\cdot 10^{-6}$ & $ 176.4 $ kHz  & 346 & 60  & 8 \\\\\n                  \\bottomrule\n\t\t\\end{tabu} \n\\label{tab:results}\n\\end{table*}\n\n\n\\subsection{Simulation Setup}\n\\label{sec:sim-setup}\nThe considered modulation formats are PS-QPSK, PM-QPSK, PM-16-QAM, PM-64-QAM, and PM-256-QAM at a symbol rate of $28$ Gbaud. The performance is quantified by counting the number of erroneous (4D) symbols to obtain the symbol error rate (SER) at the receiver for various setups in the presence of  laser phase noise,  SOP drift, and additive white Gaussian noise (AWGN). The latter is quantified through the signal-to-noise (SNR) ratio defined as $\\mathrm{SNR} = E_s/N_0$. To remove phase ambiguities differential coding \\cite[Sec.~2.6.1]{Siemetz2009} was employed independently in each polarization. Note that the presented results when only AWGN is considered (for comparison reasons) still imply differential coding. The presented results are obtained using the Jones description of the algorithm from Section \\ref{sec:Jones_descr}. \n\n\nThe proposed algorithm was implemented such that both  \\eqref{eq:ph_up2} and \\eqref{eq:SOP_up2} were calculated for every $k$, i.e., $P=1$.  The tracking step size ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ were chosen for each set of system parameters according to the heuristically obtained relations\n\n", "itemtype": "equation", "pos": 50827, "prevtext": "\n\n", "index": 51, "text": "\\begin{equation} \\label{eq:ph_4D_up2}\n  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}   = - 2 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} (\\hat{{\\mathbf{R}_{{}}}}_{k}^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{T}} \\hat{{\\mathbf{R}_{{}}}}_{k}^{-1} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{}}}} \\, {\\mathbf{r}_{{k}}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E26.m1\" class=\"ltx_Math\" alttext=\"{\\hat{{{\\boldsymbol{\\alpha}}}}_{{k}}}=-2{\\mu_{{{\\boldsymbol{\\alpha}}}}}(\\hat{{%&#10;\\mathbf{R}}}_{k}^{-1}{\\mathbf{r}_{{k}}}-{\\hat{\\bx{}}_{{k}}})^{\\mathrm{T}}\\hat{%&#10;{\\mathbf{R}}}_{k}^{-1}{{\\boldsymbol{\\rho}}}\\,{\\mathbf{r}_{{k}}}.\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>\ud835\udf36</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub><mo>=</mo><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>\ud835\udf36</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msubsup><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow><mo>-</mo><msub><mover accent=\"true\"><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\bx</mtext></merror><mo stretchy=\"false\">^</mo></mover><mi>k</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mi mathvariant=\"normal\">T</mi></msup><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc11</mi><mo stretchy=\"false\">^</mo></mover><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msubsup><mo>\u2062</mo><mpadded width=\"+1.7pt\"><mi>\ud835\udf46</mi></mpadded><mo>\u2062</mo><msub><mi>\ud835\udc2b</mi><mi>k</mi></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 59704, "prevtext": "\n\n\nIn the above description, only four DOFs, i.e., the scalars ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}$, ${ \\ifthenelse{\\equal{{1}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{1}}}{\\alpha^{({})}_{{1}}}}}$, ${ \\ifthenelse{\\equal{{2}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{2}}}{\\alpha^{({})}_{{2}}}}}$, and ${ \\ifthenelse{\\equal{{3}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{3}}}{\\alpha^{({})}_{{3}}}}}$ corresponding to ${ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{1}}}}$, ${ \\ifthenelse{\\equal{{1}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{1}}}}$, ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{2}}}}$, and ${ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\rho}}}}{{\\pmb{\\rho}}_{{3}}}}$, respectively,  of the matrix ${R}{}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}},{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}})$ were used, which correspond to the carrier phase and the SOP drift. The other two DOFs, i.e., the scalars corresponding to ${ \\ifthenelse{\\equal{{2}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{2}}}},{ \\ifthenelse{\\equal{{3}}{}}{ {\\vec{\\pmb{\\lambda}}}}{{\\pmb{\\lambda}}_{{3}}}}$ in (\\ref{eq:4D_rot}), can be used to correct certain transmitter and/or receiver hardware imperfections, which cannot be done using Jones or Stokes formalisms, such as \\SI{90}{\\degree} I/Q error or the time skew between I and Q \\cite{Crivelli2014}.\n\nThe algorithm presented in this section is fully equivalent to the one in Section \\ref{sec:Jones_descr} and will have the same performance, but not to the one in Section \\ref{sec:sts_descr}. The latter may have a different performance due to the suboptimal error function and  a separate solution to mitigate the phase noise is required in the latter case since it will not be covered by $\\hat{{\\mathbf{{M}}_{{}}}}_k$.\n\\section{Results}\\label{sec:results}\nWe evaluated the achievable performance of the proposed recovery algorithm numerically.  The details of the simulation setup are described in Section~\\ref{sec:sim-setup}, whereas in Sections~\\labelcref{subsec:pol_tol,subsec:ls_tol,subsec:snr_tol,subsec:conv_rate} various  performance metrics of the algorithm are evaluated. \n\n\\begin{table*}[!t]\n\t\t\n\t\t\\ra{1.2}\n\t\t\\caption[]{Algorithm parameters, achievable performance, and hardware complexity}\n\t\t\\centering\n\t\t\\begin{tabu}\n                  {p{1.4cm}  p{1.6cm}  p{2.45cm} p{1.23cm} p{1.5cm} p{1.27cm} p{1.5cm} C{0.95cm} C{1.2cm}  C{0.8cm}}\n                  \\toprule\n                  & & {Algorithm parameters} & {Max. tol. ${\\Delta p} \\cdot T$} & \\mbox{{Max.~tol. ${\\Delta p}$}} \\mbox{at 28 Gbaud} & {Max.~tol. ${\\Delta \\nu} \\cdot T$} & \\mbox{Max. tol. ${\\Delta \\nu} $} \\mbox{at 28 Gbaud} &  Operations & Comparisons  & Memory units \\\\\n                  \\midrule\n\n\n                  \\multirow{5}{*}{PS-QPSK} \n                  & Kabsch & $N_\\mathrm{Kab}=31$     &  \\mbox{$ 0.34\\cdot 10^{-4}$} & $ 0.95$ MHz  &   $0.91\\cdot 10^{-4}$ & $2.55 $ MHz & 132 &  7  & 0.5  \\\\\n                  & \\multirow{3}{*}{PS-CMA+BPS} &   $N_{\\mathrm{BPS}}=13$     &    \\multirow{3}{*}{\\mbox{$0.33\\cdot 10^{-4}$}}  &    \\multirow{3}{*}{$0.93$ MHz} &    \\multirow{3}{*}{$6.67\\cdot 10^{-4}$}   &    \\multirow{3}{*}{$18.68$ MHz} &  \\multirow{3}{*}{1320}  &  \\multirow{3}{*}{267} &  \\multirow{3}{*}{856} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{CMA}}=0.04/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=27$       & \\mbox{$  3.20\\cdot 10^{-4}$} &  $8.96$ MHz & $11.5\\cdot 10^{-4}$ & $32.2$ MHz & 346 & 7 & 8\\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-QPSK}\n                  & Kabsch & $N_\\mathrm{Kab}=16$     &\\mbox{$   0.17\\cdot 10^{-4}$} & $ 0.47$ MHz &   $0.79\\cdot 10^{-4 }$ & $ 2.23$ MHz & 171 &   4  & 1  \\\\\n                  & \\multirow{3}{*}{CMA+BPS} & $N_{\\mathrm{BPS}}=19$   &    \\multirow{3}{*}{\\mbox{$0.37\\cdot 10^{-4}$}}  &    \\multirow{3}{*}{$1.04$ MHz} &    \\multirow{3}{*}{$6.98\\cdot 10^{-4}$}  &    \\multirow{3}{*}{$19.54$ MHz} &  \\multirow{3}{*}{2936}  &  \\multirow{3}{*}{304} &  \\multirow{3}{*}{1264} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{CMA}}=0.16/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=64$     &  \\mbox{$1.17\\cdot 10^{-4}$}& $ 3.28$ MHz &  $ 9.06\\cdot 10^{-4}$ & $25.37$ MHz  & 346 & 4   & 8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-16-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$    & \\mbox{$ 0.44\\cdot 10^{-5}$}& $122.1 $ kHz & $  0.15\\cdot 10^{-4}$ & $ 0.412$ MHz & 171 &  12  & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{BPS}}=19$    &    \\multirow{3}{*}{\\mbox{$0.14\\cdot 10^{-5}$}}  &    \\multirow{3}{*}{$ 37.8$ kHz} &    \\multirow{3}{*}{$1.48\\cdot 10^{-4}$}  &    \\multirow{3}{*}{$ 4.14$ MHz} &  \\multirow{3}{*}{2940}  &  \\multirow{3}{*}{840} & \\multirow{3}{*}{1264} \\\\\n                  & & $P_\\mathrm{BPS} =32$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}=0.04/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=400$    & \\mbox{$  2.48\\cdot 10^{-5}$}& $694.4 $ kHz  &  $1.35\\cdot 10^{-4}$ & $3.78 $ MHz  & 346 & 12  & 8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-64-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$   & \\mbox{$0.66\\cdot 10^{-6}$}& $ 18.4$ kHz &  $ 0.32\\cdot 10^{-5}$  & $ 90.2$ kHz & 171 &  28   & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{BPS}}=19$    &    \\multirow{3}{*}{\\mbox{$0.11\\cdot 10^{-6}$}}  &    \\multirow{3}{*}{$ 3.1 $ kHz} &    \\multirow{3}{*}{$3.06\\cdot 10^{-5}$}  &    \\multirow{3}{*}{$856.8 $ kHz} &  \\multirow{3}{*}{5768}  &  \\multirow{3}{*}{3806} &  \\multirow{3}{*}{2480} \\\\\n                  & & $P_\\mathrm{BPS} =64$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}=0.035/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=2352$    & \\mbox{$4.59\\cdot 10^{-6}$}& $128.5 $ kHz  & $  2.54\\cdot 10^{-5}$ & $711.2 $ kHz  & 346 & 28 &  8 \\\\\n\n                  \\tabucline[0.2pt gray!140]{-}\n\n                  \\multirow{5}{*}{PM-256-QAM}\n                  & Kabsch & $N_\\mathrm{Kab}=16$    &  \\mbox{$0.19\\cdot 10^{-6}$}  & $ 5.3$ kHz &  $ 0.74\\cdot 10^{-6}$ & $ 20.6$ kHz & 171 &  60  & 1  \\\\\n                  & \\multirow{3}{*}{MMA+BPS} & $N_{\\mathrm{\\mathrm{BPS}}}=19$     &    \\multirow{3}{*}{\\mbox{$8.42\\cdot 10^{-9}$}}  &    \\multirow{3}{*}{$ 0.2 $ kHz} &    \\multirow{3}{*}{--}  &    \\multirow{3}{*}{--} &  \\multirow{3}{*}{5814}  &  \\multirow{3}{*}{8058} &   \\multirow{3}{*}{2480} \\\\\n                  & & $P_\\mathrm{BPS} =64$ \\\\\n                  & & \\mbox{${\\mu_\\mathrm{MMA}}~= 0.017/{E_s}^2$} \\\\\n                  & Proposed~alg. & $c=6084$     &   \\mbox{$1.22\\cdot 10^{-6}$} & $ 34.1$ kHz&  $ 6.30\\cdot 10^{-6}$ & $ 176.4 $ kHz  & 346 & 60  & 8 \\\\\n                  \\bottomrule\n\t\t\\end{tabu} \n\\label{tab:results}\n\\end{table*}\n\n\n\\subsection{Simulation Setup}\n\\label{sec:sim-setup}\nThe considered modulation formats are PS-QPSK, PM-QPSK, PM-16-QAM, PM-64-QAM, and PM-256-QAM at a symbol rate of $28$ Gbaud. The performance is quantified by counting the number of erroneous (4D) symbols to obtain the symbol error rate (SER) at the receiver for various setups in the presence of  laser phase noise,  SOP drift, and additive white Gaussian noise (AWGN). The latter is quantified through the signal-to-noise (SNR) ratio defined as $\\mathrm{SNR} = E_s/N_0$. To remove phase ambiguities differential coding \\cite[Sec.~2.6.1]{Siemetz2009} was employed independently in each polarization. Note that the presented results when only AWGN is considered (for comparison reasons) still imply differential coding. The presented results are obtained using the Jones description of the algorithm from Section \\ref{sec:Jones_descr}. \n\n\nThe proposed algorithm was implemented such that both  \\eqref{eq:ph_up2} and \\eqref{eq:SOP_up2} were calculated for every $k$, i.e., $P=1$.  The tracking step size ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$ were chosen for each set of system parameters according to the heuristically obtained relations\n\n", "index": 53, "text": "\\begin{equation}\\label{eq:miuPh}\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}=\\frac{\\sqrt{{\\Delta \\nu} T c}}{E_s},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E27.m1\" class=\"ltx_Math\" alttext=\"{\\mu_{{\\phi}}}=\\frac{\\sqrt{{\\Delta\\nu}Tc}}{E_{s}},\" display=\"block\"><mrow><mrow><msub><mi>\u03bc</mi><mi>\u03d5</mi></msub><mo>=</mo><mfrac><msqrt><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>\u03bd</mi><mo>\u2062</mo><mi>T</mi><mo>\u2062</mo><mi>c</mi></mrow></msqrt><msub><mi>E</mi><mi>s</mi></msub></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nwhere  $c$ is a constant given in Table~\\ref{tab:results}, which depends on the modulation format.  The constant $c$ was optimized to ensure the best performance in the steady-state regime at $\\mathrm{SER}=10^{-3}$. In some applications, the linewidth parameters of the optical link may be unknown at the receiver, and therefore it is impossible to accurately compute ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$. To overcome this problem, the ${\\Delta p}$ and ${\\Delta \\nu}$ parameters should be overestimated to be on the safe side. Typically, overestimating these parameters does not lead to considerable degradation in the performance.\n\nFor comparison, results obtained by the Kabsch algorithm~\\cite{Louchet2014} and combinations of the (PS-)CMA/MMA \\cite{Johannisson2011, Savory2010, Louchet2008} and BPS \\cite{Pfau2009} algorithms are presented. The Kabsch algorithm operates simultaneously on both polarizations in a decision-directed block-wise fashion, using a rectangular filter of size equal to $N_\\mathrm{Kab}=16$ \\cite{Louchet2014}, except for PS-QPSK, where it was set to $N_\\mathrm{Kab}=31$ since we observed better results with a longer block size. The BPS algorithm uses a sliding-window technique in each polarization independently since a relative phase offset between the two polarization may occur. The length of the window was set to $N_\\mathrm{BPS}=19$ \\cite{Pfau2009}, except for PS-QPSK, where for the same considerations as above the filter length was set to $N_\\mathrm{BPS}=13$. The number of test phases of the BPS algorithm was set to $P_\\mathrm{BPS} =32$ for PS-QPSK, PM-QPSK, PM-16-QAM and $P_\\mathrm{BPS}=64$ for PM-64-QAM and PM-256-QAM \\cite{Pfau2009}. The convergence parameter of the \\mbox{(PS-)CMA/MMA} algorithm ${\\mu_\\mathrm{CMA}}$ was optimized to tolerate the most polarization noise and the chosen values are listed in Table~\\ref{tab:results}. \n \n\n\\begin{figure*}\n\\centering\n\n\n\\hspace{0.6cm} \n\\includegraphics[width=0.5\\paperwidth]{legend_v3}\\\\\n\\vspace{0.05cm}\n\\includegraphics{pol_tol_fig_2}\n\\includegraphics{pol_tol_fig_3}\n\\includegraphics{pol_tol_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{lw_tol_fig_2}\n\\includegraphics{lw_tol_fig_3}\n\\includegraphics{lw_tol_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{SER_fig_2}\n\\includegraphics{SER_fig_3}\n\\includegraphics{SER_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{conv_rate_2}\n\\includegraphics{conv_rate_3}\n\\includegraphics{conv_rate_4}\n\\caption{The achievable performance of the three tracking schemes for PM-16-QAM, PM-64-QAM, and PM-256-QAM is shown. Each column corresponds to a modulation format, whereas the rows present different performance metrics. The polarization-noise tolerance is shown in the first row by plotting SER versus ${\\Delta p} \\cdot T$. The penalty compared to the AWGN curve at low ${\\Delta p} \\cdot T$ is due to the applied phase noise. The tolerance to phase noise is plotted on the second row, where ${\\Delta \\nu} \\cdot T$ is varied, whereas the noise sensitivity is shown in the third row by varying the SNR. The round markers shown in the first three rows correspond to the same channel conditions, i.e., the same ${\\Delta p} \\cdot T$, ${\\Delta \\nu} \\cdot T$, and SNR. The convergence  rate is compared on the fourth row, where the SER is plotted versus the symbol index $k$.}\n\\label{fig:performace}\n\\end{figure*}\n\nIn Sections~\\labelcref{subsec:pol_tol,subsec:ls_tol,subsec:snr_tol}, the SOP and phase tracking capabilities of the algorithms are evaluated and therefore the initial channel matrix ${\\mathbf{{H}}_{{0}}}$ is considered to be known to the receiver, i.e.,  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{0}}}={\\mathbf{{H}}_{{0}}}$. Section~\\ref{subsec:conv_rate} presents results on the convergence rate of the algorithms, where the channel matrix ${\\mathbf{{H}}_{{0}}}$ is unknown to the receiver. The achieved results are shown in Fig.~\\ref{fig:performace}, where each row corresponds to one of  Sections \\ref{subsec:pol_tol}--\\ref{subsec:conv_rate} and each column corresponds to a modulation format. We omitted results obtained for  PS-QPSK and PM-QPSK in the figure for space reasons,  and these are summarized  in Table~\\ref{tab:results}.  \n\n\\subsection{Polarization Noise Tolerance} \\label{subsec:pol_tol}\nIn this section, the ability to track time-varying SOP drift is evaluated. To measure the polarization sensitivity, the polarization linewidth ${\\Delta p}$ is varied while keeping the other parameters fixed. The SNR is set such that  $\\mathrm{SER}=10^{-3}$ is achieved in an AWGN scenario and the accumulated laser linewidth ${\\Delta \\nu}$ is chosen such that ${\\Delta \\nu}\\cdot T = \\{3.6\\cdot 10^{-5}, \\, 3.6\\cdot 10^{-5}, \\,0.36\\cdot 10^{-5}, \\, 0.18\\cdot 10^{-5}, \\, 0.04\\cdot 10^{-5}\\}$ (corresponding to ${\\Delta \\nu} = \\{1000, \\, 1000, \\, 100, \\, 50, \\, 10\\}$ kHz at 28 Gbaud) for PS-QPSK, PM-QPSK, PM-16-QAM, PM-64-QAM, and PM-256-QAM, respectively. \n\nThe results of the simulation are shown in the top row of Fig.~\\ref{fig:performace}, where the SER is plotted versus the polarization linewidth times the symbol time.  As can be seen, the proposed algorithm offers the best tolerance to SOP drift at any ${\\Delta p} \\cdot T$ for all modulation formats. High tolerance to SOP drift enables the use of high-order modulation formats even on rapidly varying channels, such as aerial fibers.\nBoth competitor algorithms show error floors higher than the proposed algorithm, possibly due to the block-wise operation of the Kabsch algorithm and finite number of test phases of the BPS algorithm, respectively. Perhaps the performance of both  competitor algorithms could be improved if the block size/tracking step/number of test phases would be optimized for each set of system parameters. However, this is outside the scope of the paper. The performance of the MMA-based algorithms   degrades significantly as the size of the constellation increases, providing the worst performance for PM-256-QAM. \n\nTable \\ref{tab:results} summarizes the maximum-tolerable polarization linewidth times the symbol time  such that the receiver requires an extra 1 dB SNR to achieve $\\mathrm{SER}=10^{-3}$ compared to the case without laser and polarization noise.  As can be seen in  Table~\\ref{tab:results}, the proposed algorithm performs the best in all scenarios, being able to tolerate  up to nine times more polarization noise.\n\n\n\\subsection{Phase-Noise Tolerance} \\label{subsec:ls_tol}\nAnother important feature of the considered tracking algorithms is the tolerance to phase noise. The phase-noise sensitivity is evaluated by varying ${\\Delta \\nu}$ and keeping the rest of the parameters fixed.  The SNR is set such that a $\\mathrm{SER}=10^{-3}$ is achieved in an AWGN scenario and the polarization linewidth  is set such that ${\\Delta p}\\cdot T=3.57 \\cdot 10^{-8}$ (corresponding to ${\\Delta p}=1$ kHz at 28 Gbaud).\n\nFig.~\\ref{fig:performace}, second row,  shows results obtained by the evaluated algorithms, where the SER is plotted versus the accumulated laser linewidth times the symbol time. The proposed algorithm has similar  performance compared to BPS, which is known to have one of the best phase-noise sensitivities  for QAM modulation formats \\cite{Zhou2014}. \n\n Table \\ref{tab:results} summarizes the maximum tolerable laser linewidth times the symbol time  for an extra 1 dB SNR to achieve $\\mathrm{SER}=10^{-3}$ compared to the case without laser and polarization noise. As can be seen in  Table~\\ref{tab:results}, the proposed algorithm performs the best in all scenarios, except for PM-16-QAM and PM-64-QAM where it has a slightly worse phase-noise sensitivity, being able to tolerate  laser linewidths  up to $32$ MHz.\n\n\n\n\n\n\\subsection{Additive-Noise Sensitivity} \\label{subsec:snr_tol}\nFig.~\\ref{fig:performace}, third row, shows the SER as a function of  SNR for fixed ${\\Delta p}$ and ${\\Delta \\nu}$ shown in the figure. The Kabsch algorithm has the biggest penalty compared to the AWGN scenario, up $1.2$ dB for PM-256-QAM, while the proposed algorithm has the smallest penalty for all three modulation formats with a maximum of $0.4$ dB for PM-256-QAM. The performance of the MMA+BPS combination  is in between  the two other algorithms, but is the worst at low SNR. \n\n\n\n\n\n\\subsection{Convergence Rate} \\label{subsec:conv_rate}\nAn important quality of non-data aided algorithms is the convergence rate based on blind data.\nTo compare the convergence rates of the three algorithms, additional numerical simulations have been performed, in which the initial channel matrix ${\\mathbf{{H}}_{{0}}}$ was not known by the algorithms  and generated by the method described in Section \\ref{Sec:model}. Note that the channel matrix was dynamic and updated according to (\\ref{eq:T_time_dep}). In order to compare the algorithms in a fair manner, the initial estimates of the channel matrix were set to be the identity, i.e.,  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{0}}}={\\mathbf{I}_{{2}}}$ or ${\\mathbf{I}_{{4}}}$ for the Kabsch algorithm.\n\n\nThe convergence rates  for the different modulation formats are shown in Fig.~\\ref{fig:performace}, bottom row, where the SER evolution is plotted versus the symbol index $k$. The results were obtained by averaging over $4\\cdot 10^5$ realizations, where in each realization the initial channel matrix was randomly generated.  To improve the convergence rate of the MMA algorithm, the training regime has been split into several stages with increasing numbers of target radii from QPSK to the final constellation \\cite{Guiomar2015}, as is shown in the figures. The performance of the Kabsch algorithm could be improved by splitting the training regime into different stages  with different window lengths $N_\\mathrm{Kab}$,  but it is outside the scope of this work. The convergence rate of the proposed algorithm is improved by dividing the training regime into two stages, each with different tracking parameters ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}, {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$. The first stage, $k=1,\\dots,2000$, uses the same value for both step sizes ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}={\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}=0.1/E_s$, which is bigger than the ones used in the second stage, $k>2000$, where  the values were obtained using (\\ref{eq:miuPh}) and (\\ref{eq:miuSOP}). It was observed that high step sizes give faster convergence but less accurate tracking in steady state.\n\nFig.~\\ref{fig:performace}, bottom row, shows that the proposed algorithm provides the fastest convergence compared to  the other two algorithms and it approaches the AWGN scenario the closest.  In the considered scenarios, the convergence takes up to $2500$ symbols, depending on the constellation, corresponding to $\\sim 100$ {\\si{\\pico\\second}.\n \nThe convergence rate of the three algorithms can be improved by parallelization \\cite{Johannisson2011a}, where the computations are  performed for a number of different initial matrices in parallel and the best candidate is chosen at a later stage. \n\n\n\n\n\\section{Hardware Complexity}\\label{sec:complexity}\nThe assessment of the hardware complexity of the three considered algorithms is done by comparing the number of required real\\footnote{The complex multiplications have been converted to real operations such that a complex multiplication requires four real multiplications and two real summations, thus six operations in total.}} operations (additions and multiplications), comparisons, and memory units. Although this approach of quantifying complexity does not accurately measure the algorithm's efficiency and  is a rough approximation, it is a starting point.\n\nFor pedagogical reasons, in (\\ref{eq:T_hat_up}), (\\ref{eq:M_hat_up}), and (\\ref{eq:4D_time_dep}), the estimate of the channel matrix is computed (instead of the estimate of the inverse), which is then inverted and used throughout the rest of the algorithm. The inversion step is unnecessary  and can be skipped by estimating the inverse of the channel matrix already in (\\ref{eq:T_hat_up}),  (\\ref{eq:M_hat_up}), and (\\ref{eq:4D_time_dep}) by negating ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$, thus reducing the required number of operations. In addition, calculations that occurs multiple times in the decoding procedure, e.g., $ {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}$ in \\eqref{eq:dec}, \\eqref{eq:ph_up2}, \\eqref{eq:SOP_up2}, are computed only once.\n\nThis holds for all three algorithms. \n\nIn Table~\\ref{tab:results},  the obtained results corresponding to one processed 4D symbol are listed. In this evaluation, the required number of operations was minimized by using memory units instead. This choice highly affects the BPS algorithm, where instead of recomputing previously done calculations for every processed symbol, the values are stored in the memory.  Therefore, the results are different from the ones presented in \\cite{Ke2012}, where no memory was used.  \n\nAs can be seen in Table~\\ref{tab:results}, the Kabsch algorithm\\footnote{We considered the Golub--Reinsch method \\cite[p.~493]{Golub2013} for singular value decomposition required by the  algorithm.} has the lowest complexity since it operates in a block-wise fashion processing the entire block at a time. This reduces the complexity significantly, which depends on the block length, i.e., a longer block will require less computing power per symbol, but also degrades the performance since it assumes that the channel does not change  during the block.  The \\mbox{(PS-)CMA/MMA+BPS} combination requires the highest computational effort and it increases with the constellation size and the size of the sliding-window over which the BPS algorithm operates.\nThe complexity of the proposed algorithm  was evaluated using the Jones description, which is the same with respect to different modulation formats and it is in between the other two algorithms.\nThe overall complexity of the algorithm can be reduced  if the SOP tracking is not updated at every symbol in (\\ref{eq:T_hat_up}), as discussed in Section \\ref{sec:Jones_descr}. This is a reasonable approach since the SOP does not drift as fast as the phase noise and it can be considered constant over a limited observation time  in some scenarios. In this case, if ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ is computed every $P$ symbols and ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ (which compensates for the phase noise) is updated at every symbol, the number of required operations is reduced from $346$ (Table~\\ref{tab:results}) to $203+143/P$. Of course in this scenario the performance will degrade, thus resulting in less tolerable polarization noise, but still sufficient for most installed fiber links. \n\n\n\n\n\n\\section{Algorithmic Summary}\nThis section  provides an easily implementable form of the proposed algorithm without requiring knowledge about the details of the derivations. \n\n\n\\removelatexerror\n\\begin{algorithm}[t]\n\\label{alg:a}\n\\caption{Proposed algorithm}\n\n\\setcounter{algoline}{-1}\n\\SetAlgoNlRelativeSize{-0.5}\n\\KwIn{${\\mathbf{r}_{{k}}}$, ${\\mathbf{{G}}_{{k}}}$, $k$}\n\\KwOut{${\\hat{\\bx{}}_{{k}}}$, ${\\mathbf{{G}}_{{k+1}}}$}\n\n${\\mathbf{{G}}_{{0}}} = \\mathbf{I}_2$ \\tcp*[f]{\\hspace{-0.2cm}initialize the channel matrix} \n\\\\\n{\n\n{\\setbox0=\\hbox{{{${\\hat{\\bx{}}_{{k}}} = \\displaystyle {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\mathbf{{G}}_{{k}}}{\\mathbf{r}_{{k}}}}- \\mathbf{c}}^2$ \\hspace{0.25cm}}}\\hspace{1in}}\\algowd=\\wd0\\relax{{${\\hat{\\bx{}}_{{k}}} = \\displaystyle {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\mathbf{{G}}_{{k}}}{\\mathbf{r}_{{k}}}}- \\mathbf{c}}^2$ \\hspace{0.25cm}}}}   \\tcp*[f]{\\parbox[t]{\\dimexpr\\algowidth-\\algowd}{{\\hspace{-0.15cm}\\mbox{decide the} \\mbox{\\hspace{0.5cm} symbol}}}} \\\\\n\n\\If(\\tcp*[f]{\\hspace{-0.2cm}set the tracking steps}){$k\\leq 2000$}{${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}={\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}=0.1/E_s$ \\tcp*[f]{\\hspace{-0.2cm}convergence stage}}\n\\Else{\n$\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}  =\\frac{\\sqrt{{\\Delta \\nu} T c}}{E_s}\n$ \\tcp*[f]{\\hspace{-0.2cm}tracking stage}\n\\\\\n$\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} = \\frac{\\sqrt{{\\Delta p} T c}}{E_s}\n$\n}\n\n$\n  { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}    = -2  {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\mathbf{{G}}_{{k}}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\mathbf{{G}}_{{k}}}  {\\mathbf{r}_{{k}}}\\Big )\n$\n\\\\\n$\n  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}  = - 2 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\mathbf{{G}}_{{k}}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\mathbf{{G}}_{{k}}} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} {\\mathbf{r}_{{k}}}\\Big ) \\label{alg:alpv_line}\n$\n\\\\\n\n{\\setbox0=\\hbox{{{${\\mathbf{{G}}_{{k+1}}} ={\\mathbf{{G}}_{{k}}}  {H}(-{ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, -{ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}})$\\hspace{0.51cm}}}\\hspace{1in}}\\algowd=\\wd0\\relax{{${\\mathbf{{G}}_{{k+1}}} ={\\mathbf{{G}}_{{k}}}  {H}(-{ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, -{ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}})$\\hspace{0.51cm}}}}   \\tcp*[f]{\\parbox[t]{\\dimexpr\\algowidth-\\algowd}{{\\hspace{-0.2cm}\\mbox{update the} \\mbox{\\hspace{-1.25cm} channel matrix}}}}\n}\n\\end{algorithm}\n\n\n\n\nThe algorithm is summarized in Algorithm \\ref{alg:a}, where for ease of notation we denote ${\\mathbf{{G}}_{{k}}}={\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}$ to be the inverted estimate of the channel matrix at time $k$. The algorithm receives as  inputs the received symbol ${\\mathbf{r}_{{k}}}$, the previous inverse estimate of the channel matrix ${\\mathbf{{G}}_{{k}}}$, and the symbol index $k$, and outputs the decided symbol ${\\hat{\\bx{}}_{{k}}}$ and the updated  matrix ${\\mathbf{{G}}_{{k}}}$.  The step sizes, which should be precomputed, are higher during convergence  ($k\\leq2000$) than tracking  ($k>2000$). In the tracking stage,  they are computed   based on the laser linewidth ${\\Delta \\nu}$ and the polarization linewidth ${\\Delta p}$, which should be overestimated if they are unknown to the receiver. The Pauli matrices $ { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}$ are given in \\eqref{eq:pauliSpins}, $\\mathscr{C}$ is the set of constellation points, ${E_s}$ is the average symbol energy \\eqref{eq:Es}, $T$ is the symbol time, and  ${H}(\\cdot)$ is computed according to (\\ref{eq_rot_full}). \n\nTo decrease the computational effort, for slowly-varying channels, the update of  ${\\mathbf{{G}}_{{k}}}$ can be done less frequently than for every received symbol. Moreover, since the SOP drift varies slower than the phase noise, the SOP update of  ${\\mathbf{{G}}_{{k}}}$ can be done less often by not calculating ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ in line~\\ref{alg:alpv_line} at each iteration but setting it to ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}=[0,0,0]^{\\mathrm{T}}$ instead.\n\nThe description shown in Algorithm \\ref{alg:a} uses the Jones formalism. This can be interchanged with the Stokes or real 4D formalisms by replacing the Jones matrix ${\\mathbf{{G}}_{{k}}}$ with $ \\hat{{\\mathbf{{M}}_{{}}}}_k^{-1}$ (Section~\\ref{sec:sts_descr}) or $\\hat{{\\mathbf{R}_{{}}}}_k^{-1}$ (Section~\\ref{sec:4D-space-descr}), and ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$, ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ should be calculated using (\\ref{eq:alpv_M}) or \\eqref{eq:ph_4D_up}--\\eqref{eq:ph_4D_up2}, respectively. In this case, the Jones vectors ${\\mathbf{r}_{{k}}}$, ${\\hat{\\bx{}}_{{k}}}$ become Stokes vectors or real 4D vectors. The Jones description of the algorithm is fully equivalent with the real 4D description and they achieve the same performance. However, the latter involves more computations since multiplying two  $4\\times 4$ real matrices requires more operations than multiplying two  $2\\times 2$ complex matrices. Nevertheless, the real 4D description can be modified to account for hardware imperfections. On the other hand, the Stokes description is immune to absolute phase shifts and only tracks the SOP, requiring a separate solution for absolute phase tracking. This can be beneficial in some situations since fast oscillations of the phase noise will not affect the algorithm, and therefore the SOP tracking. Performance-wise, the Stokes description will behave differently from the other two as it relies on a suboptimal error function \\eqref{eq:st_err_func}. \n\n\n\n\n\\section{Discussion and Conclusions}\\label{sec:conclusions}\nWe have proposed a model-based algorithm to jointly track  random polarization and phase drifts. The algorithm uses the gradient descent optimization algorithm in a decision-directed architecture processing one symbol at a time. The achievable performance of the algorithm was evaluated by means of numerical simulations and compared to  state-of-the-art  algorithms. Results show the effectiveness of the proposed algorithm, having a fast convergence rate and an excellent tolerance to phase noise and dynamic drifts of the polarization, in particular when using high-order modulation formats. At similar or better performance, the computational complexity of our algorithm is lower compared to state-of-the-art algorithms. The increased  phase and polarization  noise tolerance for high-order modulation formats at low complexity makes the algorithm a strong candidate  for future  optical systems.\n\nThe proposed algorithm is tested in a somewhat idealized scenario assuming that chromatic dispersion, polarization-dependent losses, and polarization mode dispersion are nonexistent. In general, the polarization demultiplexing is performed using finite impulse response filters in conjunction with the CMA or MMA algorithms, which, in addition to SOP recovery,  perform channel equalization.  This equalization is not covered by the proposed algorithm, but  it can be overcame by  coupling the algorithm with a separate equalization stage as in  \\cite{Buchali2015} to compensate for the slowly-varying transfer characteristics of the channel.\n\n\n\n\n\n\n\\appendix\\label{app:grad}\nIn this appendix, the gradient of the error function (\\ref{eq:error_func}) with respect to ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$ is derived as\n\\begin{IEEEeqnarray}{rCl}\n\\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  {e}_{{k}}  &=& \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  \\norm{\\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}}}^2 \\label{eq:Er_dev1}\\\\\n&=& \n\\mathpzc{Re} \\Bigg( 2 \\bigg ( \\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )^{\\mathrm{H}} \\nonumber \\\\\n& & \n\\qquad \\cdot  \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  \\bigg ( \\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )  \\Bigg) \\label{eq:Er_dev2}\\\\\n\n\n\n\n&=& \n2 \\mathpzc{Re} \\Bigg(  \\bigg ( {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} \\nonumber  \\\\\n& & \n\\qquad \\cdot  \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) {\\mathbf{r}_{{k}}} \\Bigg),\\label{eq:Er_dev4}\n\\end{IEEEeqnarray}\nwhere \\eqref{eq:Er_dev2} follows because, for any $ \\mathbf{y} \\in \\mathbb{C}^n$ and  $ \\mathbf{x} \\in \\mathbb{R}^m$, $\\nabla_\\mathbf{x}\\norm{\\mathbf{y} }^2= \\nabla_\\mathbf{x} (\\mathbf{y}^{\\mathrm{H}} \\mathbf{y}) =2\\mathpzc{Re}(\\mathbf{y}^{\\mathrm{H}} \\nabla_\\mathbf{x} \\mathbf{y})$.\nThe partial derivatives of $ {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) = { \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}{J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ are, from \\eqref{eq:J_cos} and \\eqref{eq_rot_full},\n\n\\begin{IEEEeqnarray}{rCl}\n   {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial {{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}} &=&  i{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}{J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}),  \\label{eq:T_dev3}  \\\\\n   {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}} \\label{eq:TT_dev1}\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}} {\\frac{\\partial { {J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}}  \\label{eq:TT_dev2}\\\\\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}} {\\frac{\\partial {\\Big ({\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}  + i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\\Big )  }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}}  \\label{eq:TT_dev3}\\\\\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}   \\bigg(-{\\mathbf{I}_{{2}}}{ \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} +  i   \\Big (  \\frac{{ \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{i}}}}}{{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}}- \\frac{{ \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}}{{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}} { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} \\Big) \\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\\nonumber\n\\\\\n&&  \\hspace{1.5cm} \n+ i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} \\, { \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}\\cos { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\n \\bigg ) , \\IEEEeqnarraynumspace\\label{eq:TT_dev4}\n\\end{IEEEeqnarray}\nwhere  \\eqref{eq:TT_dev4} follows because $\\partial { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} / \\partial { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}} = { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}} /  \\norm*{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}} = { \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}$.\n\n\n\n\n\nEvaluating  (\\ref{eq:T_dev3}) and (\\ref{eq:TT_dev4}) at ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}=0 , \\, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}=[0,0,0]^{\\mathrm{T}}$ results in \n\n", "itemtype": "equation", "pos": 59843, "prevtext": "\n\n", "index": 55, "text": "\\begin{equation}\\label{eq:miuSOP}\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} = \\frac{\\sqrt{{\\Delta p} T c}}{E_s},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E28.m1\" class=\"ltx_Math\" alttext=\"{\\mu_{{{\\boldsymbol{\\alpha}}}}}=\\frac{\\sqrt{{\\Delta p}Tc}}{E_{s}},\" display=\"block\"><mrow><mrow><msub><mi>\u03bc</mi><mi>\ud835\udf36</mi></msub><mo>=</mo><mfrac><msqrt><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>p</mi><mo>\u2062</mo><mi>T</mi><mo>\u2062</mo><mi>c</mi></mrow></msqrt><msub><mi>E</mi><mi>s</mi></msub></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05927.tex", "nexttext": "\nas  ${ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} \\to 0$ for any direction ${ \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}$.\nThe gradient of the error function can be obtained by substituting \\eqref{eq:part-d} and ${H}(0,0)={\\mathbf{I}_{{2}}}$ in  (\\ref{eq:Er_dev4}), which is then substituted in \\eqref{eq:ph_up} and \\eqref{eq:SOP_up} to obtain \\eqref{eq:ph_up2}  and \\eqref{eq:SOP_up2}, respectively. \n\n\n\\ifCLASSOPTIONcaptionsoff\n  \\newpage\n\\fi\n\n\n\\bibliographystyle{IEEEtran}\n\n\n\n\\begin{thebibliography}{10}\n\\providecommand{\\url}[1]{#1}\n\\csname url@samestyle\\endcsname\n\\providecommand{\\newblock}{\\relax}\n\\providecommand{\\bibinfo}[2]{#2}\n\\providecommand{\\BIBentrySTDinterwordspacing}{\\spaceskip=0pt\\relax}\n\\providecommand{\\BIBentryALTinterwordstretchfactor}{4}\n\\providecommand{\\BIBentryALTinterwordspacing}{\\spaceskip=\\fontdimen2\\font plus\n\\BIBentryALTinterwordstretchfactor\\fontdimen3\\font minus\n  \\fontdimen4\\font\\relax}\n\\providecommand{\\BIBforeignlanguage}[2]{{\n\\expandafter\\ifx\\csname l@#1\\endcsname\\relax\n\\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}\n\\typeout{** loaded for the language `#1'. Using the pattern for}\n\\typeout{** the default language instead.}\n\\else\n\\language=\\csname l@#1\\endcsname\n\\fi\n#2}}\n\\providecommand{\\BIBdecl}{\\relax}\n\\BIBdecl\n\n\\bibitem{Kim2009}\nR.~Kim, M.~O'Sullivan, {Kuang-Tsan Wu}, {Han Sun}, A.~Awadalla, D.~Krause, and\n  C.~Laperle, ``{Performance of dual-polarization {QPSK} for optical transport\n  systems},'' \\emph{Journal of Lightwave Technology}, vol.~27, no.~16, pp.\n  3546--3559, Aug. 2009.\n\n\\bibitem{Savory2010}\nS.~J. Savory, ``{Digital coherent optical receivers: algorithms and\n  subsystems},'' \\emph{IEEE Journal of Selected Topics in Quantum Electronics},\n  vol.~16, no.~5, pp. 1164--1179, Sept.--Oct. 2010.\n\n\\bibitem{Czegledi2015a}\nC.~B. Czegledi, M.~Karlsson, E.~Agrell, and P.~Johannisson, ``Polarization\n  drift channel model for coherent fibre-optic systems,'' \\emph{Nature\n  Scientific Reports}, to appear, 2016.\n\n\\bibitem{Godard1980}\nD.~N. Godard, ``{Self-recovering equalization and carrier tracking in\n  two-dimensional data communication systems},'' \\emph{IEEE Transactions on\n  Communications}, vol.~28, no.~11, pp. 1867--1875, Nov. 1980.\n\n\\bibitem{JianYang2002}\nJ.~Yang, J.-J. Werner, and G.~A. Dumont, ``{The multimodulus blind equalization\n  and its generalized algorithms},'' \\emph{IEEE Journal on Selected Areas in\n  Communications}, vol.~20, no.~5, pp. 997--1015, Jun. 2002.\n\n\\bibitem{Louchet2008}\nH.~Louchet, K.~Kuzmin, and A.~Richter, ``{Improved {DSP} algorithms for\n  coherent 16-{QAM} transmission},'' in \\emph{Proc. European Conference on\n  Optical Communication (ECOC)}, Brussels, Belgium, Sept. 2008, p. Tu.1.E.6.\n\n\\bibitem{Johannisson2011}\nP.~Johannisson, M.~Sj\\\"{o}din, M.~Karlsson, H.~Wymeersch, E.~Agrell, and P.~A.\n  Andrekson, ``{Modified constant modulus algorithm for polarization-switched\n  {QPSK}},'' \\emph{Optics Express}, vol.~19, no.~8, pp. 7734--7741, Apr. 2011.\n\n\\bibitem{Visintin2014}\nM.~Visintin, G.~Bosco, P.~Poggiolini, and F.~Forghieri, ``{Adaptive digital\n  equalization in optical coherent receivers with Stokes-space update\n  algorithm},'' \\emph{Journal of Lightwave Technology}, vol.~32, no.~24, pp.\n  4759--4767, Dec. 2014.\n\n\\bibitem{Muga2014}\nN.~J. Muga and A.~N. Pinto, ``{Adaptive 3-D Stokes space-based polarization\n  demultiplexing algorithm},'' \\emph{Journal of Lightwave Technology}, vol.~32,\n  no.~19, pp. 3290--3298, Oct. 2014.\n\n\\bibitem{Viterbi1983}\nA.~Viterbi and A.~Viterbi, ``{Nonlinear estimation of {PSK}-modulated carrier\n  phase with application to burst digital transmission},'' \\emph{IEEE\n  Transactions on Information Theory}, vol.~29, no.~4, pp. 543--551, Jul. 1983.\n\n\\bibitem{Pfau2009}\nT.~Pfau, S.~Hoffmann, and R.~No\\'e, ``{Hardware-efficient coherent digital\n  receiver concept with feedforward carrier recovery for \\textit{M}-{QAM}\n  constellations},'' \\emph{Journal of Lightwave Technology}, vol.~27, no.~8,\n  pp. 989--999, Apr. 2009.\n\n\\bibitem{Louchet2014}\nH.~Louchet, K.~Kuzmin, and A.~Richter, ``{Joint carrier-phase and polarization\n  rotation recovery for arbitrary signal constellations},'' \\emph{IEEE\n  Photonics Technology Letters}, vol.~26, no.~9, pp. 922--924, May 2014.\n\n\\bibitem{Morero2015}\nD.~A. Morero, M.~A. Castrill\\'on, A.~Aguirre, M.~R. Hueda, and O.~E. Agazzi,\n  ``{Design trade-offs and challenges in practical coherent optical transceiver\n  implementations},'' \\emph{Journal of Lightwave Technology}, to appear, 2016.\n\n\\bibitem{Damask2005}\nJ.~N. Damask, \\emph{{Polarization Optics in Telecommunications}}.\\hskip 1em\n  plus 0.5em minus 0.4em\\relax New York, NY: Springer, 2005.\n\n\\bibitem{Agrell2009}\nE.~Agrell and M.~Karlsson, ``{Power-efficient modulation formats in coherent\n  transmission systems},'' \\emph{Journal of Lightwave Technology}, vol.~27,\n  no.~22, pp. 5115--5126, Nov. 2009.\n\n\\bibitem{Tur1985}\nM.~Tur, B.~Moslehi, and J.~Goodman, ``{Theory of laser phase noise in\n  recirculating fiber-optic delay lines},'' \\emph{Journal of Lightwave\n  Technology}, vol.~3, no.~1, pp. 20--31, Feb. 1985.\n\n\\bibitem{Bellman1960}\nR.~Bellman, \\emph{Introduction to Matrix Analysis}.\\hskip 1em plus 0.5em minus\n  0.4em\\relax New York, NY: McGraw-Hill, 1960.\n\n\\bibitem{Gordon2000}\nJ.~P. Gordon and H.~Kogelnik, ``{{PMD} fundamentals: polarization mode\n  dispersion in optical fibers},'' \\emph{Proceedings of the National Academy of\n  Sciences of the United States of America}, vol.~97, no.~9, pp. 4541--4550,\n  Apr. 2000.\n\n\\bibitem{Karlsson2015}\nM.~Karlsson, C.~B. Czegledi, and E.~Agrell, ``{Coherent transmission channels\n  as 4d rotations},'' in \\emph{Proc. Signal Processing in Photonic\n  Communication (SPPcom)}, Boston, MA, Jul. 2015, p. SpM3E.2.\n\n\\bibitem{Karlsson2014}\nM.~Karlsson, ``{Four-dimensional rotations in coherent optical\n  communications},'' \\emph{Journal of Lightwave Technology}, vol.~32, no.~6,\n  pp. 1246--1257, Mar. 2014.\n\n\\bibitem{Sun2011}\nH.~Sun and K.-T. Wu, ``{A novel dispersion and {PMD} tolerant clock phase\n  detector for coherent transmission systems},'' in \\emph{Proc. Optical Fiber\n  Communication Conference (OFC)}, Los Angeles, CA, Mar. 2011, p. OMJ4.\n\n\\bibitem{Nakagawa2010}\nT.~Nakagawa, K.~Ishihara, T.~Kobayashi, R.~Kudo, M.~Matsui, Y.~Takatori, and\n  M.~Mizoguchi, ``{Wide-range and fast-tracking frequency offset estimator for\n  optical coherent receivers},'' in \\emph{Proc. European Conference on Optical\n  Communication (ECOC)}, Torino, Italy, Sept. 2010, p. We.7.A.2.\n\n\\bibitem{Boyd2004}\nS.~Boyd and L.~Vandenberghe, \\emph{Convex Optimization}.\\hskip 1em plus 0.5em\n  minus 0.4em\\relax New York, NY: Cambridge University Press, 2004.\n\n\\bibitem{Ogaki2003}\nK.~Ogaki, M.~Nakada, Y.~Nagao, and K.~Nishijima, ``{Fluctuation differences in\n  the principal states of polarization in aerial and buried cables},'' in\n  \\emph{Proc. Optical Fiber Communication Conference (OFC)}, Atlanta, GA, Mar.\n  2003, p. MF13.\n\n\\bibitem{Krummrich2005}\nP.~Krummrich, E.-D. Schmidt, W.~Weiershausen, and A.~Mattheus, ``{Field trial\n  results on statistics of fast polarization changes in long haul WDM\n  transmission systems},'' in \\emph{Proc. Optical Fiber Communication\n  Conference (OFC)}, Anaheim, CA, Mar. 2005, p. OThT6.\n\n\\bibitem{Czegledi2015}\nC.~B. Czegledi, E.~Agrell, and M.~Karlsson, ``{Symbol-by-symbol joint\n  polarization and phase tracking in coherent receivers},'' in \\emph{Proc.\n  Optical Fiber Communication Conference (OFC)}, Los Angeles, CA, Mar. 2015, p.\n  W1E.3.\n\n\\bibitem{Betti1991}\nS.~Betti, F.~Curti, G.~{De Marchis}, and E.~Iannone, ``{A novel multilevel\n  coherent optical system: 4-quadrature signaling},'' \\emph{Journal of\n  Lightwave Technology}, vol.~9, no.~4, pp. 514--523, Apr. 1991.\n\n\\bibitem{Cusani1992}\nR.~Cusani, E.~Iannone, A.~M. Salonico, and M.~Todaro, ``{An efficient\n  multilevel coherent optical system: {M-4Q-QAM}},'' \\emph{Journal of Lightwave\n  Technology}, vol.~10, no.~6, pp. 777--786, Jun. 1992.\n\n\\bibitem{Crivelli2014}\nD.~E. Crivelli, M.~R. Hueda, H.~S. Carrer, M.~{del Barco}, R.~R. L\\'opez,\n  P.~Gianni, J.~Finochietto, N.~Swenson, P.~Voois, and O.~E. Agazzi,\n  ``{Architecture of a single-chip 50 {G}b/s {DP-QPSK/BPSK} transceiver with\n  electronic dispersion compensation for coherent optical channels},''\n  \\emph{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol.~61,\n  no.~4, pp. 1012--1025, Apr. 2014.\n\n\\bibitem{Siemetz2009}\nM.~Seimetz, \\emph{{High-Order Modulation for Optical Fiber\n  Transmission}}.\\hskip 1em plus 0.5em minus 0.4em\\relax Heidelberg, Germany:\n  Springer, 2009.\n\n\\bibitem{Zhou2014}\nX.~Zhou, ``{Efficient clock and carrier recovery algorithms for single-carrier\n  coherent optical systems: a systematic review on challenges and recent\n  progress},'' \\emph{IEEE Signal Processing Magazine}, vol.~31, no.~2, pp.\n  35--45, Mar. 2014.\n\n\\bibitem{Guiomar2015}\nF.~P. Guiomar, S.~B. Amado, A.~Carena, G.~Bosco, A.~Nespola, A.~Teixeira, and\n  A.~N. Pinto, ``{Fully-blind linear and nonlinear equalization for {100G\n  PM-64QAM} optical systems},'' \\emph{Journal of Lightwave Technology},\n  vol.~33, no.~7, pp. 1265--1274, Apr. 2015.\n\n\\bibitem{Johannisson2011a}\nP.~Johannisson, H.~Wymeersch, M.~Sj\\\"{o}din, A.~S. Tan, E.~Agrell, P.~A.\n  Andrekson, and M.~Karlsson, ``{Convergence comparison of the {CMA} and {ICA}\n  for blind polarization demultiplexing},'' \\emph{Journal of Optical\n  Communications and Networking}, vol.~3, no.~6, pp. 493--501, Jun. 2011.\n\n\\bibitem{Ke2012}\nJ.~H. Ke, K.~P. Zhong, Y.~Gao, J.~C. Cartledge, A.~S. Karar, and M.~A. Rezania,\n  ``{Linewidth-tolerant and low-complexity two-stage carrier phase estimation\n  for dual-polarization 16-{QAM} coherent optical fiber communications},''\n  \\emph{Journal of Lightwave Technology}, vol.~30, no.~24, pp. 3987--3992, Dec.\n  2012.\n\n\\bibitem{Golub2013}\nG.~H. Golub and C.~F. {Van Loan}, \\emph{{Matrix Computations}}, 4th~ed.\\hskip\n  1em plus 0.5em minus 0.4em\\relax Baltimore, MD: Johns Hopkins Univ. Press,\n  2013.\n\n\\bibitem{Buchali2015}\nF.~Buchali, H.~B\\\"ulow, K.~Schuh, and W.~Idler, ``{{4D-CMA}: enabling\n  separation of channel compensation and polarization demultiplex},'' in\n  \\emph{Proc. Optical Fiber Communication Conference (OFC)}, Los Angeles, CA,\n  Mar. 2015, p. Th2A.15.\n\n\\end{thebibliography}\n\n\n", "itemtype": "equation", "pos": 90590, "prevtext": "\nwhere  $c$ is a constant given in Table~\\ref{tab:results}, which depends on the modulation format.  The constant $c$ was optimized to ensure the best performance in the steady-state regime at $\\mathrm{SER}=10^{-3}$. In some applications, the linewidth parameters of the optical link may be unknown at the receiver, and therefore it is impossible to accurately compute ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}$ and ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$. To overcome this problem, the ${\\Delta p}$ and ${\\Delta \\nu}$ parameters should be overestimated to be on the safe side. Typically, overestimating these parameters does not lead to considerable degradation in the performance.\n\nFor comparison, results obtained by the Kabsch algorithm~\\cite{Louchet2014} and combinations of the (PS-)CMA/MMA \\cite{Johannisson2011, Savory2010, Louchet2008} and BPS \\cite{Pfau2009} algorithms are presented. The Kabsch algorithm operates simultaneously on both polarizations in a decision-directed block-wise fashion, using a rectangular filter of size equal to $N_\\mathrm{Kab}=16$ \\cite{Louchet2014}, except for PS-QPSK, where it was set to $N_\\mathrm{Kab}=31$ since we observed better results with a longer block size. The BPS algorithm uses a sliding-window technique in each polarization independently since a relative phase offset between the two polarization may occur. The length of the window was set to $N_\\mathrm{BPS}=19$ \\cite{Pfau2009}, except for PS-QPSK, where for the same considerations as above the filter length was set to $N_\\mathrm{BPS}=13$. The number of test phases of the BPS algorithm was set to $P_\\mathrm{BPS} =32$ for PS-QPSK, PM-QPSK, PM-16-QAM and $P_\\mathrm{BPS}=64$ for PM-64-QAM and PM-256-QAM \\cite{Pfau2009}. The convergence parameter of the \\mbox{(PS-)CMA/MMA} algorithm ${\\mu_\\mathrm{CMA}}$ was optimized to tolerate the most polarization noise and the chosen values are listed in Table~\\ref{tab:results}. \n \n\n\\begin{figure*}\n\\centering\n\n\n\\hspace{0.6cm} \n\\includegraphics[width=0.5\\paperwidth]{legend_v3}\\\\\n\\vspace{0.05cm}\n\\includegraphics{pol_tol_fig_2}\n\\includegraphics{pol_tol_fig_3}\n\\includegraphics{pol_tol_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{lw_tol_fig_2}\n\\includegraphics{lw_tol_fig_3}\n\\includegraphics{lw_tol_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{SER_fig_2}\n\\includegraphics{SER_fig_3}\n\\includegraphics{SER_fig_4}\\\\\n\\vspace{0.2cm}\n\\includegraphics{conv_rate_2}\n\\includegraphics{conv_rate_3}\n\\includegraphics{conv_rate_4}\n\\caption{The achievable performance of the three tracking schemes for PM-16-QAM, PM-64-QAM, and PM-256-QAM is shown. Each column corresponds to a modulation format, whereas the rows present different performance metrics. The polarization-noise tolerance is shown in the first row by plotting SER versus ${\\Delta p} \\cdot T$. The penalty compared to the AWGN curve at low ${\\Delta p} \\cdot T$ is due to the applied phase noise. The tolerance to phase noise is plotted on the second row, where ${\\Delta \\nu} \\cdot T$ is varied, whereas the noise sensitivity is shown in the third row by varying the SNR. The round markers shown in the first three rows correspond to the same channel conditions, i.e., the same ${\\Delta p} \\cdot T$, ${\\Delta \\nu} \\cdot T$, and SNR. The convergence  rate is compared on the fourth row, where the SER is plotted versus the symbol index $k$.}\n\\label{fig:performace}\n\\end{figure*}\n\nIn Sections~\\labelcref{subsec:pol_tol,subsec:ls_tol,subsec:snr_tol}, the SOP and phase tracking capabilities of the algorithms are evaluated and therefore the initial channel matrix ${\\mathbf{{H}}_{{0}}}$ is considered to be known to the receiver, i.e.,  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{0}}}={\\mathbf{{H}}_{{0}}}$. Section~\\ref{subsec:conv_rate} presents results on the convergence rate of the algorithms, where the channel matrix ${\\mathbf{{H}}_{{0}}}$ is unknown to the receiver. The achieved results are shown in Fig.~\\ref{fig:performace}, where each row corresponds to one of  Sections \\ref{subsec:pol_tol}--\\ref{subsec:conv_rate} and each column corresponds to a modulation format. We omitted results obtained for  PS-QPSK and PM-QPSK in the figure for space reasons,  and these are summarized  in Table~\\ref{tab:results}.  \n\n\\subsection{Polarization Noise Tolerance} \\label{subsec:pol_tol}\nIn this section, the ability to track time-varying SOP drift is evaluated. To measure the polarization sensitivity, the polarization linewidth ${\\Delta p}$ is varied while keeping the other parameters fixed. The SNR is set such that  $\\mathrm{SER}=10^{-3}$ is achieved in an AWGN scenario and the accumulated laser linewidth ${\\Delta \\nu}$ is chosen such that ${\\Delta \\nu}\\cdot T = \\{3.6\\cdot 10^{-5}, \\, 3.6\\cdot 10^{-5}, \\,0.36\\cdot 10^{-5}, \\, 0.18\\cdot 10^{-5}, \\, 0.04\\cdot 10^{-5}\\}$ (corresponding to ${\\Delta \\nu} = \\{1000, \\, 1000, \\, 100, \\, 50, \\, 10\\}$ kHz at 28 Gbaud) for PS-QPSK, PM-QPSK, PM-16-QAM, PM-64-QAM, and PM-256-QAM, respectively. \n\nThe results of the simulation are shown in the top row of Fig.~\\ref{fig:performace}, where the SER is plotted versus the polarization linewidth times the symbol time.  As can be seen, the proposed algorithm offers the best tolerance to SOP drift at any ${\\Delta p} \\cdot T$ for all modulation formats. High tolerance to SOP drift enables the use of high-order modulation formats even on rapidly varying channels, such as aerial fibers.\nBoth competitor algorithms show error floors higher than the proposed algorithm, possibly due to the block-wise operation of the Kabsch algorithm and finite number of test phases of the BPS algorithm, respectively. Perhaps the performance of both  competitor algorithms could be improved if the block size/tracking step/number of test phases would be optimized for each set of system parameters. However, this is outside the scope of the paper. The performance of the MMA-based algorithms   degrades significantly as the size of the constellation increases, providing the worst performance for PM-256-QAM. \n\nTable \\ref{tab:results} summarizes the maximum-tolerable polarization linewidth times the symbol time  such that the receiver requires an extra 1 dB SNR to achieve $\\mathrm{SER}=10^{-3}$ compared to the case without laser and polarization noise.  As can be seen in  Table~\\ref{tab:results}, the proposed algorithm performs the best in all scenarios, being able to tolerate  up to nine times more polarization noise.\n\n\n\\subsection{Phase-Noise Tolerance} \\label{subsec:ls_tol}\nAnother important feature of the considered tracking algorithms is the tolerance to phase noise. The phase-noise sensitivity is evaluated by varying ${\\Delta \\nu}$ and keeping the rest of the parameters fixed.  The SNR is set such that a $\\mathrm{SER}=10^{-3}$ is achieved in an AWGN scenario and the polarization linewidth  is set such that ${\\Delta p}\\cdot T=3.57 \\cdot 10^{-8}$ (corresponding to ${\\Delta p}=1$ kHz at 28 Gbaud).\n\nFig.~\\ref{fig:performace}, second row,  shows results obtained by the evaluated algorithms, where the SER is plotted versus the accumulated laser linewidth times the symbol time. The proposed algorithm has similar  performance compared to BPS, which is known to have one of the best phase-noise sensitivities  for QAM modulation formats \\cite{Zhou2014}. \n\n Table \\ref{tab:results} summarizes the maximum tolerable laser linewidth times the symbol time  for an extra 1 dB SNR to achieve $\\mathrm{SER}=10^{-3}$ compared to the case without laser and polarization noise. As can be seen in  Table~\\ref{tab:results}, the proposed algorithm performs the best in all scenarios, except for PM-16-QAM and PM-64-QAM where it has a slightly worse phase-noise sensitivity, being able to tolerate  laser linewidths  up to $32$ MHz.\n\n\n\n\n\n\\subsection{Additive-Noise Sensitivity} \\label{subsec:snr_tol}\nFig.~\\ref{fig:performace}, third row, shows the SER as a function of  SNR for fixed ${\\Delta p}$ and ${\\Delta \\nu}$ shown in the figure. The Kabsch algorithm has the biggest penalty compared to the AWGN scenario, up $1.2$ dB for PM-256-QAM, while the proposed algorithm has the smallest penalty for all three modulation formats with a maximum of $0.4$ dB for PM-256-QAM. The performance of the MMA+BPS combination  is in between  the two other algorithms, but is the worst at low SNR. \n\n\n\n\n\n\\subsection{Convergence Rate} \\label{subsec:conv_rate}\nAn important quality of non-data aided algorithms is the convergence rate based on blind data.\nTo compare the convergence rates of the three algorithms, additional numerical simulations have been performed, in which the initial channel matrix ${\\mathbf{{H}}_{{0}}}$ was not known by the algorithms  and generated by the method described in Section \\ref{Sec:model}. Note that the channel matrix was dynamic and updated according to (\\ref{eq:T_time_dep}). In order to compare the algorithms in a fair manner, the initial estimates of the channel matrix were set to be the identity, i.e.,  ${\\hat{{\\mathbf{{H}}_{{}}}}_{{0}}}={\\mathbf{I}_{{2}}}$ or ${\\mathbf{I}_{{4}}}$ for the Kabsch algorithm.\n\n\nThe convergence rates  for the different modulation formats are shown in Fig.~\\ref{fig:performace}, bottom row, where the SER evolution is plotted versus the symbol index $k$. The results were obtained by averaging over $4\\cdot 10^5$ realizations, where in each realization the initial channel matrix was randomly generated.  To improve the convergence rate of the MMA algorithm, the training regime has been split into several stages with increasing numbers of target radii from QPSK to the final constellation \\cite{Guiomar2015}, as is shown in the figures. The performance of the Kabsch algorithm could be improved by splitting the training regime into different stages  with different window lengths $N_\\mathrm{Kab}$,  but it is outside the scope of this work. The convergence rate of the proposed algorithm is improved by dividing the training regime into two stages, each with different tracking parameters ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}, {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}$. The first stage, $k=1,\\dots,2000$, uses the same value for both step sizes ${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}={\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}=0.1/E_s$, which is bigger than the ones used in the second stage, $k>2000$, where  the values were obtained using (\\ref{eq:miuPh}) and (\\ref{eq:miuSOP}). It was observed that high step sizes give faster convergence but less accurate tracking in steady state.\n\nFig.~\\ref{fig:performace}, bottom row, shows that the proposed algorithm provides the fastest convergence compared to  the other two algorithms and it approaches the AWGN scenario the closest.  In the considered scenarios, the convergence takes up to $2500$ symbols, depending on the constellation, corresponding to $\\sim 100$ {\\si{\\pico\\second}.\n \nThe convergence rate of the three algorithms can be improved by parallelization \\cite{Johannisson2011a}, where the computations are  performed for a number of different initial matrices in parallel and the best candidate is chosen at a later stage. \n\n\n\n\n\\section{Hardware Complexity}\\label{sec:complexity}\nThe assessment of the hardware complexity of the three considered algorithms is done by comparing the number of required real\\footnote{The complex multiplications have been converted to real operations such that a complex multiplication requires four real multiplications and two real summations, thus six operations in total.}} operations (additions and multiplications), comparisons, and memory units. Although this approach of quantifying complexity does not accurately measure the algorithm's efficiency and  is a rough approximation, it is a starting point.\n\nFor pedagogical reasons, in (\\ref{eq:T_hat_up}), (\\ref{eq:M_hat_up}), and (\\ref{eq:4D_time_dep}), the estimate of the channel matrix is computed (instead of the estimate of the inverse), which is then inverted and used throughout the rest of the algorithm. The inversion step is unnecessary  and can be skipped by estimating the inverse of the channel matrix already in (\\ref{eq:T_hat_up}),  (\\ref{eq:M_hat_up}), and (\\ref{eq:4D_time_dep}) by negating ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$, thus reducing the required number of operations. In addition, calculations that occurs multiple times in the decoding procedure, e.g., $ {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}{\\mathbf{r}_{{k}}}$ in \\eqref{eq:dec}, \\eqref{eq:ph_up2}, \\eqref{eq:SOP_up2}, are computed only once.\n\nThis holds for all three algorithms. \n\nIn Table~\\ref{tab:results},  the obtained results corresponding to one processed 4D symbol are listed. In this evaluation, the required number of operations was minimized by using memory units instead. This choice highly affects the BPS algorithm, where instead of recomputing previously done calculations for every processed symbol, the values are stored in the memory.  Therefore, the results are different from the ones presented in \\cite{Ke2012}, where no memory was used.  \n\nAs can be seen in Table~\\ref{tab:results}, the Kabsch algorithm\\footnote{We considered the Golub--Reinsch method \\cite[p.~493]{Golub2013} for singular value decomposition required by the  algorithm.} has the lowest complexity since it operates in a block-wise fashion processing the entire block at a time. This reduces the complexity significantly, which depends on the block length, i.e., a longer block will require less computing power per symbol, but also degrades the performance since it assumes that the channel does not change  during the block.  The \\mbox{(PS-)CMA/MMA+BPS} combination requires the highest computational effort and it increases with the constellation size and the size of the sliding-window over which the BPS algorithm operates.\nThe complexity of the proposed algorithm  was evaluated using the Jones description, which is the same with respect to different modulation formats and it is in between the other two algorithms.\nThe overall complexity of the algorithm can be reduced  if the SOP tracking is not updated at every symbol in (\\ref{eq:T_hat_up}), as discussed in Section \\ref{sec:Jones_descr}. This is a reasonable approach since the SOP does not drift as fast as the phase noise and it can be considered constant over a limited observation time  in some scenarios. In this case, if ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ is computed every $P$ symbols and ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$ (which compensates for the phase noise) is updated at every symbol, the number of required operations is reduced from $346$ (Table~\\ref{tab:results}) to $203+143/P$. Of course in this scenario the performance will degrade, thus resulting in less tolerable polarization noise, but still sufficient for most installed fiber links. \n\n\n\n\n\n\\section{Algorithmic Summary}\nThis section  provides an easily implementable form of the proposed algorithm without requiring knowledge about the details of the derivations. \n\n\n\\removelatexerror\n\\begin{algorithm}[t]\n\\label{alg:a}\n\\caption{Proposed algorithm}\n\n\\setcounter{algoline}{-1}\n\\SetAlgoNlRelativeSize{-0.5}\n\\KwIn{${\\mathbf{r}_{{k}}}$, ${\\mathbf{{G}}_{{k}}}$, $k$}\n\\KwOut{${\\hat{\\bx{}}_{{k}}}$, ${\\mathbf{{G}}_{{k+1}}}$}\n\n${\\mathbf{{G}}_{{0}}} = \\mathbf{I}_2$ \\tcp*[f]{\\hspace{-0.2cm}initialize the channel matrix} \n\\\\\n{\n\n{\\setbox0=\\hbox{{{${\\hat{\\bx{}}_{{k}}} = \\displaystyle {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\mathbf{{G}}_{{k}}}{\\mathbf{r}_{{k}}}}- \\mathbf{c}}^2$ \\hspace{0.25cm}}}\\hspace{1in}}\\algowd=\\wd0\\relax{{${\\hat{\\bx{}}_{{k}}} = \\displaystyle {\\operatorname{arg\\,min}}_{\\mathbf{c} \\in \\mathscr{C}} \\norm{ { {\\mathbf{{G}}_{{k}}}{\\mathbf{r}_{{k}}}}- \\mathbf{c}}^2$ \\hspace{0.25cm}}}}   \\tcp*[f]{\\parbox[t]{\\dimexpr\\algowidth-\\algowd}{{\\hspace{-0.15cm}\\mbox{decide the} \\mbox{\\hspace{0.5cm} symbol}}}} \\\\\n\n\\If(\\tcp*[f]{\\hspace{-0.2cm}set the tracking steps}){$k\\leq 2000$}{${\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}={\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}=0.1/E_s$ \\tcp*[f]{\\hspace{-0.2cm}convergence stage}}\n\\Else{\n$\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}  =\\frac{\\sqrt{{\\Delta \\nu} T c}}{E_s}\n$ \\tcp*[f]{\\hspace{-0.2cm}tracking stage}\n\\\\\n$\n{\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} = \\frac{\\sqrt{{\\Delta p} T c}}{E_s}\n$\n}\n\n$\n  { \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}    = -2  {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\mathbf{{G}}_{{k}}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\mathbf{{G}}_{{k}}}  {\\mathbf{r}_{{k}}}\\Big )\n$\n\\\\\n$\n  { \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}  = - 2 {\\mu_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}} \\mathpzc{Re} \\Big ( i({\\mathbf{{G}}_{{k}}} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}})^{\\mathrm{H}} {\\mathbf{{G}}_{{k}}} { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} {\\mathbf{r}_{{k}}}\\Big ) \\label{alg:alpv_line}\n$\n\\\\\n\n{\\setbox0=\\hbox{{{${\\mathbf{{G}}_{{k+1}}} ={\\mathbf{{G}}_{{k}}}  {H}(-{ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, -{ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}})$\\hspace{0.51cm}}}\\hspace{1in}}\\algowd=\\wd0\\relax{{${\\mathbf{{G}}_{{k+1}}} ={\\mathbf{{G}}_{{k}}}  {H}(-{ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}, -{ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}})$\\hspace{0.51cm}}}}   \\tcp*[f]{\\parbox[t]{\\dimexpr\\algowidth-\\algowd}{{\\hspace{-0.2cm}\\mbox{update the} \\mbox{\\hspace{-1.25cm} channel matrix}}}}\n}\n\\end{algorithm}\n\n\n\n\nThe algorithm is summarized in Algorithm \\ref{alg:a}, where for ease of notation we denote ${\\mathbf{{G}}_{{k}}}={\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}}$ to be the inverted estimate of the channel matrix at time $k$. The algorithm receives as  inputs the received symbol ${\\mathbf{r}_{{k}}}$, the previous inverse estimate of the channel matrix ${\\mathbf{{G}}_{{k}}}$, and the symbol index $k$, and outputs the decided symbol ${\\hat{\\bx{}}_{{k}}}$ and the updated  matrix ${\\mathbf{{G}}_{{k}}}$.  The step sizes, which should be precomputed, are higher during convergence  ($k\\leq2000$) than tracking  ($k>2000$). In the tracking stage,  they are computed   based on the laser linewidth ${\\Delta \\nu}$ and the polarization linewidth ${\\Delta p}$, which should be overestimated if they are unknown to the receiver. The Pauli matrices $ { \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}$ are given in \\eqref{eq:pauliSpins}, $\\mathscr{C}$ is the set of constellation points, ${E_s}$ is the average symbol energy \\eqref{eq:Es}, $T$ is the symbol time, and  ${H}(\\cdot)$ is computed according to (\\ref{eq_rot_full}). \n\nTo decrease the computational effort, for slowly-varying channels, the update of  ${\\mathbf{{G}}_{{k}}}$ can be done less frequently than for every received symbol. Moreover, since the SOP drift varies slower than the phase noise, the SOP update of  ${\\mathbf{{G}}_{{k}}}$ can be done less often by not calculating ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ in line~\\ref{alg:alpv_line} at each iteration but setting it to ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}=[0,0,0]^{\\mathrm{T}}$ instead.\n\nThe description shown in Algorithm \\ref{alg:a} uses the Jones formalism. This can be interchanged with the Stokes or real 4D formalisms by replacing the Jones matrix ${\\mathbf{{G}}_{{k}}}$ with $ \\hat{{\\mathbf{{M}}_{{}}}}_k^{-1}$ (Section~\\ref{sec:sts_descr}) or $\\hat{{\\mathbf{R}_{{}}}}_k^{-1}$ (Section~\\ref{sec:4D-space-descr}), and ${ \\ifthenelse{\\equal{{k}}{}}{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}_{{k}}}}$, ${ \\ifthenelse{\\equal{{k}}{}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}}{\\hat{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}}_{{k}}}}$ should be calculated using (\\ref{eq:alpv_M}) or \\eqref{eq:ph_4D_up}--\\eqref{eq:ph_4D_up2}, respectively. In this case, the Jones vectors ${\\mathbf{r}_{{k}}}$, ${\\hat{\\bx{}}_{{k}}}$ become Stokes vectors or real 4D vectors. The Jones description of the algorithm is fully equivalent with the real 4D description and they achieve the same performance. However, the latter involves more computations since multiplying two  $4\\times 4$ real matrices requires more operations than multiplying two  $2\\times 2$ complex matrices. Nevertheless, the real 4D description can be modified to account for hardware imperfections. On the other hand, the Stokes description is immune to absolute phase shifts and only tracks the SOP, requiring a separate solution for absolute phase tracking. This can be beneficial in some situations since fast oscillations of the phase noise will not affect the algorithm, and therefore the SOP tracking. Performance-wise, the Stokes description will behave differently from the other two as it relies on a suboptimal error function \\eqref{eq:st_err_func}. \n\n\n\n\n\\section{Discussion and Conclusions}\\label{sec:conclusions}\nWe have proposed a model-based algorithm to jointly track  random polarization and phase drifts. The algorithm uses the gradient descent optimization algorithm in a decision-directed architecture processing one symbol at a time. The achievable performance of the algorithm was evaluated by means of numerical simulations and compared to  state-of-the-art  algorithms. Results show the effectiveness of the proposed algorithm, having a fast convergence rate and an excellent tolerance to phase noise and dynamic drifts of the polarization, in particular when using high-order modulation formats. At similar or better performance, the computational complexity of our algorithm is lower compared to state-of-the-art algorithms. The increased  phase and polarization  noise tolerance for high-order modulation formats at low complexity makes the algorithm a strong candidate  for future  optical systems.\n\nThe proposed algorithm is tested in a somewhat idealized scenario assuming that chromatic dispersion, polarization-dependent losses, and polarization mode dispersion are nonexistent. In general, the polarization demultiplexing is performed using finite impulse response filters in conjunction with the CMA or MMA algorithms, which, in addition to SOP recovery,  perform channel equalization.  This equalization is not covered by the proposed algorithm, but  it can be overcame by  coupling the algorithm with a separate equalization stage as in  \\cite{Buchali2015} to compensate for the slowly-varying transfer characteristics of the channel.\n\n\n\n\n\n\n\\appendix\\label{app:grad}\nIn this appendix, the gradient of the error function (\\ref{eq:error_func}) with respect to ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}$ is derived as\n\\begin{IEEEeqnarray}{rCl}\n\\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  {e}_{{k}}  &=& \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  \\norm{\\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}}}^2 \\label{eq:Er_dev1}\\\\\n&=& \n\\mathpzc{Re} \\Bigg( 2 \\bigg ( \\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )^{\\mathrm{H}} \\nonumber \\\\\n& & \n\\qquad \\cdot  \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  \\bigg ( \\Big ({H}({ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}){\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}}\\Big )^{-1} {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )  \\Bigg) \\label{eq:Er_dev2}\\\\\n\n\n\n\n&=& \n2 \\mathpzc{Re} \\Bigg(  \\bigg ( {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) {\\mathbf{r}_{{k}}} - {\\hat{\\bx{}}_{{k}}} \\bigg )^{\\mathrm{H}} {\\hat{{\\mathbf{{H}}_{{}}}}_{{k}}^{-1}} \\nonumber  \\\\\n& & \n\\qquad \\cdot  \\nabla_{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}}  {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) {\\mathbf{r}_{{k}}} \\Bigg),\\label{eq:Er_dev4}\n\\end{IEEEeqnarray}\nwhere \\eqref{eq:Er_dev2} follows because, for any $ \\mathbf{y} \\in \\mathbb{C}^n$ and  $ \\mathbf{x} \\in \\mathbb{R}^m$, $\\nabla_\\mathbf{x}\\norm{\\mathbf{y} }^2= \\nabla_\\mathbf{x} (\\mathbf{y}^{\\mathrm{H}} \\mathbf{y}) =2\\mathpzc{Re}(\\mathbf{y}^{\\mathrm{H}} \\nabla_\\mathbf{x} \\mathbf{y})$.\nThe partial derivatives of $ {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) = { \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}{J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{})$ are, from \\eqref{eq:J_cos} and \\eqref{eq_rot_full},\n\n\\begin{IEEEeqnarray}{rCl}\n   {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial {{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}} &=&  i{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}{J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}),  \\label{eq:T_dev3}  \\\\\n   {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}} \\label{eq:TT_dev1}\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}} {\\frac{\\partial { {J}(-{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}}  \\label{eq:TT_dev2}\\\\\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}} {\\frac{\\partial {\\Big ({\\mathbf{I}_{{2}}} \\cos{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}  + i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\\Big )  }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}}  \\label{eq:TT_dev3}\\\\\n&=&\n{ \\ifthenelse{\\equal{{}}{}}{e^{i\\phi}}{e^{i\\phi_{{}}}}}   \\bigg(-{\\mathbf{I}_{{2}}}{ \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}\\sin{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} +  i   \\Big (  \\frac{{ \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{i}}}}}{{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}}- \\frac{{ \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}}{{ \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}} { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} \\Big) \\sin { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\\nonumber\n\\\\\n&&  \\hspace{1.5cm} \n+ i { \\ifthenelse{\\equal{{}}{}}{ {\\mathbf{a}}}{{{a}}_{{}}}}\\cdot{ \\ifthenelse{\\equal{{}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{}}}} \\, { \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}\\cos { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}}\n \\bigg ) , \\IEEEeqnarraynumspace\\label{eq:TT_dev4}\n\\end{IEEEeqnarray}\nwhere  \\eqref{eq:TT_dev4} follows because $\\partial { \\ifthenelse{\\equal{{}}{}}{\\ifthenelse{\\equal{{}}{}}{\\theta}{\\theta^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\theta_{{}}}{\\theta^{({})}_{{}}}}} / \\partial { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}} = { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}} /  \\norm*{{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}} = { \\ifthenelse{\\equal{{i}}{}}{ {\\mathbf{a}}}{{{a}}_{{i}}}}$.\n\n\n\n\n\nEvaluating  (\\ref{eq:T_dev3}) and (\\ref{eq:TT_dev4}) at ${ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}=0 , \\, { \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}=[0,0,0]^{\\mathrm{T}}$ results in \n\n", "index": 57, "text": "\\begin{equation} \\label{eq:part-d}\n     {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial {{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}}}} = i {\\mathbf{I}_{{2}}} , \\qquad \\quad      {\\frac{\\partial { {H}(-{ \\ifthenelse{\\equal{{}}{}}{\\phi}{\\phi_{{}}}}, -{ \\ifthenelse{\\equal{{}}{}}{ \\pmb{\\alpha}}{{\\pmb{\\alpha}}_{{}}}}{}) }}{\\partial { { \\ifthenelse{\\equal{{i}}{}}{\\ifthenelse{\\equal{{}}{}}{\\alpha}{\\alpha^{({})}}}{\\ifthenelse{\\equal{{}}{}}{\\alpha_{{i}}}{\\alpha^{({})}_{{i}}}}}}}}  = i{ \\ifthenelse{\\equal{{i}}{}}{ {\\vec{\\pmb{\\sigma}}}}{{\\pmb{\\sigma}}_{{i}}}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E29.m1\" class=\"ltx_Math\" alttext=\"{\\frac{\\partial{{H}(-{\\phi},-{{\\boldsymbol{\\alpha}}}{})}}{\\partial{{\\phi}}}}=i%&#10;{\\mathbf{I}_{{2}}},\\qquad\\quad{\\frac{\\partial{{H}(-{\\phi},-{{\\boldsymbol{%&#10;\\alpha}}}{})}}{\\partial{{\\alpha^{({})}_{{i}}}}}}=i{{\\boldsymbol{\\sigma}}_{{i}}},\" display=\"block\"><mrow><mrow><mrow><mfrac><mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>H</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mi>\u03d5</mi></mrow><mo>,</mo><mrow><mo>-</mo><mi>\ud835\udf36</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03d5</mi></mrow></mfrac><mo>=</mo><mrow><mi>i</mi><mo>\u2062</mo><msub><mi>\ud835\udc08</mi><mn>2</mn></msub></mrow></mrow><mo rspace=\"32.5pt\">,</mo><mrow><mfrac><mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>H</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mi>\u03d5</mi></mrow><mo>,</mo><mrow><mo>-</mo><mi>\ud835\udf36</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msubsup><mi>\u03b1</mi><mi>i</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow></msubsup></mrow></mfrac><mo>=</mo><mrow><mi>i</mi><mo>\u2062</mo><msub><mi>\ud835\udf48</mi><mi>i</mi></msub></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]