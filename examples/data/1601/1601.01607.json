[{"file": "1601.01607.tex", "nexttext": "\nwhere $D$ is the dimension and $x = (x1, x2, \u00c2\u00b7 \u00c2\u00b7 \u00c2\u00b7 , x_{D})$ is a\n$D$-dimensional row vector (i.e., a $1 \u00c3\u0097 D$ matrix). Rastrigin\u00e2\u0080\u0099s function \nis a classical multimodal problem. Such problem is difficult since the number of local\noptima grows exponentially with the increase of dimensionality. To make it \nnon-separable, an orthogonal matrix is also used for coordinate rotation.\nThe rotated Rastrigin's function is defined as follows:\n\n", "itemtype": "equation", "pos": 23653, "prevtext": "\n\n\\title{{\\sf NodIO}, a JavaScript framework for volunteer-based evolutionary algorithms : first results}\n\n\n\n\n\n\n\\author{Juan-J.~Merelo*$^1$, Mario Garc\\'ia-Valdez$^2$, Pedro\n  A. Castillo$^1$,\\\\ \nPablo Garc\\'ia-S\\'anchez$^1$, P. de las Cuevas*$^1$, Nuria Rico$^3$\n\\thanks{Manuscript submitted for review on \\today.}\n\\thanks{$^1$Dept. of Computer Architecture and Technology and CITIC University of Granada}\n\\thanks{$^2$Dept. of Graduate Studies at Instituto Tecnol\\'ogico de Tijuana}\n\\thanks{$^3$Dept. of Statistics and Operational Research University of Granada}\n\\thanks{E-mail addresses: {\\tt jmerelo@ugr.es}, {\\tt\n    mario@tectijuana.edu.mx}, {\\tt pacv@ugr.es}, {\\tt pablogarcia@ugr.es},{\\tt nrico@ugr.es}}\n\\thanks{*Corresponding author.}\n}\n\n\\maketitle\n\n\\begin{abstract}\n\nJavaScript is an interpreted language mainly known for its inclusion\nin web browsers, making them a container for rich Internet based applications. This has\ninspired its use, for a long time, as a tool for evolutionary\nalgorithms, mainly so in browser-based volunteer computing\nenvironments. Several libraries have also been published so far and are in\nuse. However, the last years have seen a resurgence of interest in the\nlanguage, becoming one of the most popular and thus spawning the\nimprovement of its implementations, which are now the foundation of many\nnew client-server applications. We present such an application for\nrunning distributed volunteer-based evolutionary algorithm \nexperiments, and we make a series of\nmeasurements to establish the speed of JavaScript in evolutionary\nalgorithms that can serve as a baseline for comparison with other\ndistributed computing experiments. These experiments use different\ninteger and floating point problems, and prove that the speed of\nJavaScript is actually competitive with other languages commonly used\nby the evolutionary algorithm practitioner. \n\n\\end{abstract}\n\n\n{\\bf Keywords}\nEvolutionary algorithms, evolutionary computation, distributed computing, internet computing,\nsocial networks, volunteer computing, metacomputing, performance evaluation.\n\n\n\\section{Introduction}\n\nThe need to use non-permanent and potentially massive computing\ninfrastructure for distributed scientific experiments has lead to the\nrising of {\\em volunteer computing} defined as a set of tools that allow\ncitizens to {\\em donate} cycles to scientific experiments by running\nan application \\cite{Anderson06thecomputational}; this application can be embedded in a web page. And\nsince browsers are ubiquitous, we are more interested in these kind of systems, this has led us to create a framework for\nevolutionary algorithm experiments that is able to work in that mode\n\\cite{DBLP:journals/corr/GuervosG15}. {\\sf NodIO} is a\ncloud or bare metal based volunteer evolutionary computing system\nderived from the {\\sf NodEO} library, whose architecture has been\ndeveloped using JavaScript on the client as well as the server.\nAll parts of the framework are free and available with a free license\nfrom \\url{https://github.com/JJ/splash-volunteer}.\n\n\n\nAs a volunteer based system, there are some issues that have to be addressed \n\\cite{sarmenta2001volunteer,web:BOINC} :\n\\begin{enumerate}\n\\item Volunteers are anonymous, only the Internet Protocol addresses (IP) sent in \neach request is known.\n\\item As anonymous entities, volunteers are not accountable. \nIf a volunteer misbehaves in some way the provider cannot \nprosecute or discipline the volunteer. In the case of JavaScript,\nthis issue is aggravated because even if it is obfuscated, source code\nand data is sent to clients. \n\\item Participants must also trust the application provider, \nregarding invasion of privacy, the integrity of their devices, \nand intended application. \n\\end{enumerate}\n\nSeveral kind of threats are possible in this environment; first, since its\nprogramming interface is open and its code is open source, it is\nrelatively easy to find vulnerabilities and \nsabotage the system, as indicated in \\cite{domingues2007sabotage}, by\ncrafting a fake request which, for instance, assigns a fake fitness to\na particular chromosome.\nOther two different kinds of attacks are also\npossible: a denial of service attack as well as penetration\ntesting. We have approached this threat in a pragmatic way: all\nsources, client and server, for the application, are openly released\nas free software. \n We also released as an open access paper the result of the \n experiments performed \\cite{DBLP:journals/corr/GuervosG15}  \n and all data, once anonymized, as open data. This\nbuilds trust between the user and the scientist, which indeed has an\nimpact on the performance of the system, since there is no need to\ninclude cheating checks or other functions that would degrade it. This\nsocio-technical approach is, indeed, \ncoherent with our whole approach to the study of a distributed volunteer\n system which can only be tackled by approaching it from the\ntechnical as well as the social, as in social media, angle. \n\n\nIn general, a distributed volunteer-based evolutionary computation\nframework based on the browser such as NodIO is simply a client-server system\nwhose client is, or can be, embedded in the browser via\nJavaScript. Since JavaScript is  the only language that is present\nacross all browsers, the choice was quite clear. Even so, there might\nbe some issues with the performance of the language itself, which \n is\nwhy we have made a comparison between JavaScript and other languages\n\\cite{2015arXiv151101088M}. In that paper we prove that JavaScript can be\nfaster than compiled languages such as Scala and, in any case, it provides\na performance that is comparable to other languages usually employed \nin evolutionary computation and numerical optimization such as Python. \nCompiled languages such as\nJava or C might be faster when \nconsidering the performance of a single-user, \nbut this is more than offset by the computational power of\nthe spontaneous volunteers we can gather at whim, including people\nusing their mobile phones or tablets. Together, the performance is several orders of magnitude\nhigher, which is the objective in this kind of systems.\n\nSince JavaScript is\nquite a popular language nowadays, it also provides compilers from a number\nof languages, many of them in their family (like CoffeeScript), but\nmany other outside, so researchers can, in fact, write their fitness\nfunction in Python, Erlang, Scala, or even Java, and then compile it to\nJavaScript. For completeness, an experiment comparing the performance of\na JavaScript implementation versus Java and Matlab is included in section\n\\ref{sec:experiments}. We will first describe the {\\sf NodIO} architecture in\nthe next Section.\n\n\n\\section{{\\sf NodIO } architecture}\n\n\nThe {\\sf NodIO} architecture has two tiers. \nThe figure \\ref{fig:system} describes the general system architecture and\nalgorithm behavior. Different web technologies, such as JQuery or {\\tt\n  Chart.js} have\nbeen used to build the user interface elements of the framework.\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[width=4in]{system.pdf}\n\\caption{Description of the proposed framework. Clients execute a JavaScript EA\n  in the browser, which, every 100 generations, sends the best\n  individual and receives a random one from the server.}\n\\label{fig:system}\n\\end{figure}\n\\begin{enumerate}\n\n\\item A REST server, that is, a server that includes several {\\em\n  routes} \n  that can be called for storing and retrieving information (the ``CRUD'' cycle:\n  create, request, update, and delete) from the server. \n  A JSON data format is used for the communication between \n  clients and the server. There are two kinds of information:\n  {\\em problem} based, that is, related to the\n  evolutionary algorithm such as {\\tt PUT}ing a chromosome in or {\\tt\n  GET}ing a random chromosome from it, and {\\em information} related\n  to the performance and state of the experiments. It also performs logging\n  duties, but they are basically a very lightweight and high performance\n  data storage \\cite{jj:idc:lowcost}.\n  The server has the capability to\n  run a single experiment, storing the chromosomes in a data structure\n  that is reset when the solution is found.\n\n\\item A client that includes the evolutionary algorithm as\n  JavaScript code embedded in a web page that displays graphs, some\n  additional links, and information on the experiment. This code runs\n  an evolutionary algorithm {\\em island} starting with a random\n  population, then it sends, every 100 generations, the best individual\n  back to the server (via a {\\tt PUT} request), and requests a random\n  individual from the server (via a {\\tt GET} request). \n\\end{enumerate}\n\n\n  This is the invariant part of the framework, but other than that,\n  the algorithm can be run in many different ways: \n  stopping when a solution is found or using Web Workers. In fact, since it is a pool-based system such as\n  the one described in \\cite{LNCS86720702}, any kind of client that\n  calls the application programming interface (API) can be used,\n  written in any kind of language. However, in this paper we are going\n  to focus on the dynamics and measurements of the volunteer part of\n  the framework. \n\nThe researcher only has to change a function, which can be written in\nJavaScript or in any other language with cross-compilation to\nJavaScript \\cite{web:compilersjs} to solve different optimization\nproblems. \n\nLet us see how this system addresses the different challenges\noutlined above:\n\\begin{itemize}\n\\item {\\em Scalability} is provided via the use of a lightweight and\n  high-performance, single-threaded, server based in Node.js and\n  Express.js. Although this single server is a bottleneck since it\n  will eventually saturate, the fact that it runs as a non-blocking single thread\n  allows the service of many requests. In fact, a limit in the\n  number of simultaneous requests will be reached, but so far it has\n  not been found, unlike what we found in our previous systems, DCoR,\n  \\cite{gecco07:workshop:dcor}, which had a low scalability. \n\\item The framework is {\\em heterogeneous} since it does not need any\n  performance, operating system, or even browser requirement as long\n  as JavaScript is enabled: anyone\n  visiting the page, even from mobile devices, can load the algorithm.\n  In case the browser does not support HTML5 Web workers (e.g., \n  Windows Phone or some version of Android) or their use\n  has been disabled, a basic version of {\\sf NodIO} can also be used.\n\\item {\\em Fault tolerance} is always an issue, and in this case, the\n  single point of failure would be the server: the system, as such,\n  would break down if the server fails. However, the individual\n  islands in every browser would continue running, and having access\n  to just one of them would allow the local algorithm to proceed. In\n  fact, the island does not need the server to run: it runs locally if\n  needed, with the only exception that it is obviously unable to\n  communicate with the rest of the islands.\n\\item {\\em Adaptiveness} is achieved simply through the autonomous\n  operation of every individual island without any synchronization\n  mechanism. The islands in the system are, in fact, unaware of each\n  other, communicating only through the server. This architecture \n  has been tested in other high demand systems with success, but \n  in the case of {\\sf NodIO}, additional experiments are needed to asses \n  the scalability of the communication system. \n                                \n                                \n                                \n                                \n  \n\\item Since the algorithm runs in the browser, user's {\\em safety} is\n  achieved through its sandbox mechanisms. The user is thus assured\n  that there is no unsafe access either to their local files or even\n  to more resources than the browser should be allotted.\n\\item Running the algorithm is just a matter of loading the page,\n  which makes the operation totally {\\em anonymous}. For the same\n  reason, {\\em ease of use} is optimal, being as easy as simply\n  clicking on an URL, available to anyone with access to a browser.\n\\item {\\em Reasonable performance} is not ensured. In fact, we should\n  make sure that there is a reasonable amount of clients over which\n  the performance achieved is better than what you would obtain in\n  your own desktop system. If this is not the case, it is a pointless\n  academic exercise.\n\\end{itemize}\n\nThere are many different ways to validate a framework that intends to\naddress these challenges. Some of them are included by design: it is\nanonymous, since no accounts are needed to participate in the\nexperiment, it is safe for the user, since we are using the browser\nblack box, and it is also heterogeneous. We have designed the\nexperiments so that they show adaptability to different types of\nexperiments and clients, scalability with the number of clients and\nthe problem size, and measured performance by comparing it with\na baseline configuration, with which, as indicated above, is\ncompatible and can be used in a complementary way. Fault tolerance\nwill be experimented by dropping the server and checking the continuity\nof the experiments. \n\nAfter the initial experiments \\cite{DBLP:journals/corr/GuervosG15}, we\nrealized that we needed to make some improvements. So, in order to\nimprove the number of cycles per user, we enhanced the \nbasic architecture in several different aspects. One proposed improvement\ninvolved restarting the client once the solution was\nfound, so that as long as the user was visiting the page it was\nrunning an evolutionary algorithm. Another was a small algorithmic\nenhancement: instead of having a fixed population,\npopulation size was randomly distributed between 128 and 256 and\ndifferent for each client. We called this instance of\nthe architecture NodIO-W$^2$. The other improvement was to \nuse the Web Worker API as described next.\n\nThe rationale for this change comes from the realization that JavaScript has been commonly used to develop client-side scripts\nthat handle the user interface, communicating asynchronously with servers and\nupdating the content that is displayed \\cite{flanagan2006javascript}.\nLong-running scripts like those proposed in this work can interfere with the\nresponsiveness of the web application, because everything is handled by a\nsingle thread. The Web Workers specification \\cite{hickson2012web} defines an\nAPI that allows Web developers to execute long-running scripts in parallel\nwith the scripts of the main page. Worker scripts are spawned in the\nbackground allowing a thread-like operation using message-passing as the\ncommunication mechanism between the worker's execution environment and the\nmain thread. According to the Web Workers W3C Candidate Recommendation\n\\cite{hickson2012web} workers are expected to be long-lived, they have a high\nstart-up performance cost, and a high per-instance memory cost. The Web Worker\nAPI is implemented in current versions of both desktop and mobile web browsers.\nFor volunteer computing using the Web Worker API brings several advantages\nover a single threaded implementation:\n\n\\begin{itemize}\n\\item If the browser uses a tabbed document interface, the worker script\nkeeps running in the background even in case the user brings forward another tabbed\nwindow.\n\\item Several evolutionary algorithms can be executed in parallel in a single web\npage. \n\\item Many implementations of the Web Worker API can use multiple-core CPUs for\nthe execution of worker scripts, in particular the execution in multiple-core CPUs\nwas tested in desktop versions of Chrome, FireFox and Safari.\n\\item Each {\\sf NodEO} instance can be restarted independently.\n\\end{itemize}\n\nA sequence diagram of NodIO-W$^2$, is presented\nin Figure~\\ref{fig:system:w2}. In this version, clients use the Web Workers\nAPI to run two {\\sf NodEO} instances per browser. The sequence diagram shows the\ninteraction between processes in a time sequence. In this version there are\ntwo kinds of asynchronous messages: HTTP Requests shown as bold arrows between\nthe client and the server where PUT and GET HTTP methods are represented by\nred and blue arrows respectively. There are also messages between workers and\nthe main thread locally in the client, which are shown as thin solid arrows.\nThere are three processes involved:\n\\begin{itemize}\n\\item {\\em Node.js} This is the server side process which is basically\n  the same as used previously, except for some minor log-related\n  changes. \n\\item {\\em Client main thread} The main script creates\nworker instances and handles the user interface.\n\\item {\\em Worker global scope} The worker execution space does not have\naccess to the Document Object Model (DOM) or JQuery objects in the main thread.\nAsynchronous HTTP requests to the server are implemented using the\nXMLHttpRequest object.  \n\\end{itemize}\n\n\\begin{figure}[!htb]\n\\centering\n\\includegraphics[width=4in]{Algorithm.pdf}\n\\caption{Description of the W$^2$ version of {\\sf NodIO}. In this\n  version, clients use Web Workers to run the evolutionary algorithm,\n  with two of them per browser.}\n\\label{fig:system:w2}\n\\end{figure}\n\n\nThe sequence of events happens as follows:\n\\begin{enumerate}\n\\item First the {\\sf NodIO} process is started in Node.js. As part of the\ninitialization procedure, the sequential number of experiments is initialized and a log\nfile is created. The shared pool implemented as an array is reset.\n\\item A volunteer follows the link of the experiment triggering a GET HTTP\nrequest, then the page is loaded.\n\\item The main script renders the page and creates the worker instance. In\norder to create a dedicated worker instance, another GET request is sent to the\nserver, then the client receives the second worker implementation script.\nEach worker instance executes over time one or more evolutionary algorithms\n{\\em islands}. Each island starts with a random population and it is assigned a\nuniversally unique identifier (UUID). The UUID is included in each of the HTTP\nrequests sent to the server.\nThe initial parameters for each island\ncan be distinct. Once the worker is created and the parameters have been set,\na message is sent to the worker to start the algorithm.\n\\item The worker first creates the population following the previously\nspecified parameters. Once the population has been initialized, the EA\ngeneration loop is started. After {\\em n} generations the state of the population\nis evaluated. The chromosome with the best fitness is sent to the shared\npopulation with a PUT HTTP request. If the best fitness is not the global best,\nthe EA loop must continue, but first a chromosome is randomly selected from\nthe shared population. The current generation number and the best\nchromosome are also sent to the client's main thread in order to update the DOM to\ndisplay the current state of the island (described next). These messages are\nall asynchronous, so the EA loop of\nthe worker continues even before a message is received by the target. If the best fitness is a global best, the best\nchromosome is sent to the server and the loop ends. A message is sent to the\nmain thread indicating that the best individual has been found.\n\\item The main thread receives messages from workers as events handled by\na callback function. When an iteration message is received, the page is\nupdated by displaying a dynamic plot of the generation number and best\nfitness, and a representation of the chromosome is also generated.\n\\item When a global best is received from an island, the current experiment\nends, the experiment number is incremented, and the population array is reset.\n\\item When the main thread receives a message indicating that a worker has ended the EA\nloop, that worker is reinitialized. The worker process is not ended, to\navoid the start-up cost, only the parameters and population are reset and a new UUID\nassigned.\n\\end{enumerate}\n\n\nThese two versions of the framework will have to be tested {\\em in the\n  wild} to measure its performance. \nHowever, before testing this framework in a real experiment, we have\nto establish a baseline for comparison. \n\n\n\\section{Baseline Experiments} \n\\label{sec:experiments}\n\nWe have used the classical Trap function \\cite{Ackley1987}\nused as well as the Rastrigin's floating-point optimization\nproblem. Since JavaScript is a functional language and declaring a different \nfunction and handing at the creation of the algorithm object, called\n{\\tt Classic}, is the only change needed to work with a different\nproblem. \n\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[width=10cm]{baseline-times.png}\n\\caption{Comparison of times to solution (labeled as {\\bf times}) for the baseline system, using a {\\tt\n    Node.js} client, for different population sizes. Only\nruns in which solution has been found are used for this graph.}\n\n\\label{fig:baseline}\n\\end{figure}\nFirst, we establish the baseline performance by running fifty runs of the\nevolutionary algorithm in a desktop client written using {\\sf NodEO}\n\\cite{nodeo2014}, the basic JavaScript library we have used as base to\nbuild {\\sf NodIO}, the framework. This experiment tries to \nfind the solution to the 40-trap function with parameters $l=4, a=1,\nb=2, z=3$ and a population size equal to 512. The algorithm in a\nsingle island was run until the solution (a string with all\nones) was found or five million evaluations had been performed. It\ntook around a minute, on average, that is $68.9694$ seconds, to\nperform these runs. In this experiment only 33, that is, 66\\% were\nsuccessful. The experiments were repeated for population $p=1024$,\nwith a success rate upgraded to 100\\% and an {\\em average} duration of $3.46$\nseconds. Results for these two experiments\nare shown in Figure \\ref{fig:baseline}. The baseline hardware system has these\ncharacteristics: \n\\begin{verbatim}\nLinux penny 3.13.0-34-generic #60-Ubuntu SMP Wed Aug 13 15:45:27 UTC\n2014 x86_64 x86_64 x86_64 GNU/Linux\n\\end{verbatim}\nwith a 4-core {\\tt Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz}.\n\nThese two experiments establish a baseline result and show that\nthe time to success depends on the population size, with a bigger population\ncontributing to have more diversity and thus speeding up the solution \\cite{DBLP:conf/lion/LaredoDFGB13}. The volunteer computing\nexperiments that we will describe next do not and can not have the\nsame conditions, but\nthe baseline is that if they eventually take longer than a basic\ndesktop, their interest will be purely academic.\n\n\n\n\\subsection{Tests with a floating-point hard optimization problem} \n\nJavaScript has been traditionally implemented as an interpreted\nlanguage not designed for the development of high performance\nsystems. On the other hand, current JavaScript  \nvirtual machines (VMs from now on) are closing the gap, for instance the Google V8 \nis an engine specifically designed for the fast execution of \nlarge JavaScript applications. In order to increase performance\nV8 compiles JavaScript source code directly into machine code when it is first executed. \nThere are no intermediate byte codes or an interpreter \\cite{Gray:2009:GCM:1610564.1610565}.\nJavaScript has gained popularity in server-side development using runtime\nenvironments such as Node.js and is also used in desktop and mobile applications. \n\n\nTo further evaluate how a current JavaScript implementation could be used by a\ncomputer scientist to develop complex optimization problems,\na benchmark function, which was provided by the CEC2010 Special Session on\nLarge-Scale Global Optimization \\cite{tang2007benchmark} is used in this section. \nThe function is described next.\n\n\nThe basic Rastrigin's function is separable, and is defined as follows;\n\n", "index": 1, "text": "\\begin{equation}\nF_{rastrigin}(x)=\\sum\\limits_{i=1}^D [ x_{i}^{2}-10\\cos(2\\pi x_i)+10  ] \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"F_{rastrigin}(x)=\\sum\\limits_{i=1}^{D}[x_{i}^{2}-10\\cos(2\\pi x_{i})+10]\" display=\"block\"><mrow><mrow><msub><mi>F</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>D</mi></munderover><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup><mo>-</mo><mrow><mn>10</mn><mo>\u2062</mo><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>+</mo><mn>10</mn></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01607.tex", "nexttext": "\nWhere $\\textbf{M}$ is  a $D \\times{D}$ orthogonal matrix. The benchmark\nemulates real-world optimization problems that most likely will consist \nof different groups of parameters with strong dependencies within\nbut little interaction between the groups. This issue is reflected in the benchmark \nby randomly dividing the objective variables\ninto several groups, each of which contains a number of variables. The parameter $m$ \nis used to control the number of variables in each group and hence, defining the degree\nof separability:\n\n", "itemtype": "equation", "pos": 24198, "prevtext": "\nwhere $D$ is the dimension and $x = (x1, x2, \u00c2\u00b7 \u00c2\u00b7 \u00c2\u00b7 , x_{D})$ is a\n$D$-dimensional row vector (i.e., a $1 \u00c3\u0097 D$ matrix). Rastrigin\u00e2\u0080\u0099s function \nis a classical multimodal problem. Such problem is difficult since the number of local\noptima grows exponentially with the increase of dimensionality. To make it \nnon-separable, an orthogonal matrix is also used for coordinate rotation.\nThe rotated Rastrigin's function is defined as follows:\n\n", "index": 3, "text": "\\begin{equation}\nF_{rot\\_rastrigin}(x)=F_{rastrigin}(\\textbf{z}), \\textbf{z}= \\textbf{x} * \\textbf{M}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"F_{rot\\_rastrigin}(x)=F_{rastrigin}(\\textbf{z}),\\textbf{z}=\\textbf{x}*\\textbf{M}\" display=\"block\"><mrow><mrow><mrow><msub><mi>F</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi mathvariant=\"normal\">_</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>F</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc33</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mtext>\ud835\udc33</mtext><mo>=</mo><mrow><mtext>\ud835\udc31</mtext><mo>*</mo><mtext>\ud835\udc0c</mtext></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01607.tex", "nexttext": "\nFor the benchmark $D = 1000$, Group size $m = 50$, $\\textbf{x} = (x_1, x_2, \\ldots , x_{D})$ is the\ncandidate solution, $\\textbf{o} = (o_1, o_2, \\ldots  , o_{D})$ is the shifted global optimum,\n$\\textbf{z} = \\textbf{x} - \\textbf{o}$ is the shifted candidate solution and\nfinally $\\textbf{P}$ is a random permutation of $\\lbrace1, 2, \\ldots  ,D\\rbrace$.\n\nThis optimization problem was selected because it is representative of the kind of\nalgorithms, data types, and structures employed in large scale optimization problems. \nThe function was implemented in both Matlab and Java languages as part of the\nTest Suite of the companion competition of the Special Session and to give competitors an idea of the\ncomputational cost of the challenge, the runtime required for 10,000 function evaluations \nfor a particular configuration was published by organizers. The Java\nimplementation took 7596ms and the Matlab version 1115ms. The whole experiment had the value of\n3,000,000 function evaluations as termination condition. Using the Java implementation as\na guide, the function described above was implemented to compare the performance of JavaScript against\nboth implementations, again using the time required for 10,000 function evaluations. \nBefore discussing the setup and performance results, certain details of\nthe implementation in JavaScript are presented to give readers an idea of \nhow practical and mature this language is for developing complex mathematical functions.\n\n\\begin{figure}[!htb]\n\\centering\n\\includegraphics[width=0.9\\linewidth]{f15_times.png}\n\\caption{ Runtime of 10,000 function evaluations for $F_{15}$} \n\\label{fig:f15_times}\n\\end{figure}\n\n\\begin{itemize}\n\\item {\\em Randomize} Both Matlab and Java programs rely on a \nJava Randomizer library for the \nrandomization of the shift vectors and matrices used by the function.\nThe library includes the generation of pseudorandom Gaussians of type\ndouble and uniformly distributed integers. Generators use a single\n{\\tt long} seed. In order to implement the same functionality in\nJavaScript, the library {\\tt random-js} was used, as there are inconsistencies \nin the implementation of the standard {\\tt Math.random()} between engines\nand also their results are non-deterministic. \nThe library {\\tt random-js}, implements a Mersenne Twister algorithm producing \nconsistent results across all JavaScript VMs.\n\\item {\\em Timing functions} In order to compare the performance of \neach implementation, an accurate and consistent way of measuring \nthe runtime of functions is needed.\nIn JavaScript the {\\tt Date class} is often used \nto measure execution time, but has the limitation of having a maximum \nresolution given in milliseconds.\nIn order to measure the runtime intervals with a higher precision two functions\nwhere used: for Node.js we used the native {\\tt process.hrtime()} function\nwhich returns a high-resolution measure in a {\\tt [seconds, nanoseconds]}\narray, and for measuring in the browser the {\\tt Performance.now()} function was called,\nwhich uses floating-point numbers with up to microsecond precision. \nA drawback found is that the {\\tt Performance.now()} function is only implemented\nin Firefox and Chrome browsers. Both functions are independent of the system clock. \n\\item {\\em Tools} An important consideration when choosing certain \nlanguage to write non-trivial programs is the availability of development tools. While developing\nthe experiments, we used a comprehensive set of developer tools available for both\nbrowsers and desktop \\cite{tilkov2010node}. These tools included\npackage managers, in this case {\\tt npm}, debuggers, logging libraries\nsuch as {\\tt winston}, \nnetwork monitors, editors, and even debugging of the multi-threaded execution of Web Workers.\nAlthough the fact that developer tools vary from browser to browser\nsupposed a drawback, they all have the same functionality. The\nJavaScript debugger can be accessed directly from the user menu in\nmost browsers. \n\\item {\\em Data Types} JavaScript uses floating point numbers with a \nlimited precision of 64 bits that partially implement the functionality of\nthe {\\tt StrictMath} library used by the Java implementation. If more precision\nis needed, developers could use {\\tt math.js}, an extensive math library with\nsupport for matrices and big numbers.\n\\end{itemize}\n\nWe found that the JavaScript ecosystem is mature enough for developing non-trivial \ncode, but developers have to consider the differences between VMs implementations\nand therefore use certain libraries in order to increase the precision and repeatability of\nalgorithms. As for the performance of JavaScript against Java and Matlab\nwe conducted first the basic test described earlier in a 3.7 GHz Quad-Core\nIntel Xeon E5 processor running OS X 10.10.5, \nusing Java(TM) SE Runtime Environment (build 1.8.0\\_25-b17), \nMatLab version R2015a for Mac OSX, Node FrameWork version 0.12.2,\nGoogle Chrome Version 46.0.2490.86 (64-bit) \nand Firefox version 41.0.2. \n The performance of the time required for 10,000 function evaluations is presented in\nFigure \\ref{fig:f15_times}. In our test the Matlab implementation had the best\nperformance with an average of 935ms, followed by Java with\n991ms. On the other hand, JavaScript took 32\\% more time than Java with 1238ms in Chrome using a \nsingle Web Worker and 1,234ms using Node.js. \nThe results also show that there is not much difference between the Node.js\nimplementation and that of a\nbrowser. There is also not much difference between running the code in the main thread or in Web\nWorkers. When running the experiment in Firefox a dialog alerted that the\nscript was taking too much time, showing that this\nkind of processing is not intended for the main thread. Additionally, there is not much overhead\nwhen running two\nWeb Workers in parallel as they took 1279ms each. This experiment\nshows that JavaScript is viable as a language\nlanguage for developing complex mathematical functions an these can run in a browser\nwith acceptable performance. \n\n\n\n\n\\section{Conclusion}\n\\label{sec:conclusion}\n\nThis paper has been intended mainly as a description of the {\\sf\n  NodIO} architecture as well as two different implementations, with\nor without web workers, as well as a collection of measurements of the\nperformance of the JavaScript language in different implementations,\nand compared with other languages.\n\nThe first conclusion we can draw is that, even if JavaScript is not\nthe fastest language around, its performance is competitive and can be\nused profitably for medium size problems, with its speed in floating\npoint problems being around 30\\% less than Matlab or Java. \n\nA framework created around this language, like the {\\sf NodIO} we\nsystematize and introduce in this paper, can more than compensate this\ndifference with the recourse of the users that can be spontaneously\ngathered in a volunteer computing experiment. The fact that it is so\nsimple to participate in it, without needing to download anything,\nimplies that it can be used for peak or non-permanent workloads.\n\nHowever, it remains to be seen how many users and the real performance\nthat {\\sf NodIO}, in any of its implementations, would achieve. This\nis left for future work.\n\n\n\\section*{Acknowledgment}\n\nThis work has been supported in part by TIN2011-28627-C04-02 and\nTIN2014-56494-C4-3-P (Spanish Ministry of Economy and Competitivity),\nSPIP2014-01437 (Direcci{\\'o}n General de Tr{\\'a}fico) and PYR-2014-17\nGENIL project (CEI-BIOTIC Granada). Additional support was recieved by\nProjects 5622.15-P (ITM) and  PROINNOVA 2015: 220590 (CONACYT).\nWe would also like to thank the\nanonymous reviewers of previous versions of this paper who have really\nhelped us to improve \nthis paper (and our work) with their suggestions. We are also grateful\nto Anna S\\'aez de Tejada for her help with the data processing scripts.\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{geneura,volunteer,javascript,ror-js,GA-general}\n\n\n", "itemtype": "equation", "pos": 24847, "prevtext": "\nWhere $\\textbf{M}$ is  a $D \\times{D}$ orthogonal matrix. The benchmark\nemulates real-world optimization problems that most likely will consist \nof different groups of parameters with strong dependencies within\nbut little interaction between the groups. This issue is reflected in the benchmark \nby randomly dividing the objective variables\ninto several groups, each of which contains a number of variables. The parameter $m$ \nis used to control the number of variables in each group and hence, defining the degree\nof separability:\n\n", "index": 5, "text": "\\begin{equation}\nF_{15}(x)=\\sum\\limits_{k=1}^\\frac{D}{m}F_{rot\\_rastrigin}[\\textbf{z}(P_{(k-1)*m+1}:P_{k*m})] \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"F_{15}(x)=\\sum\\limits_{k=1}^{\\frac{D}{m}}F_{rot\\_rastrigin}[\\textbf{z}(P_{(k-1%&#10;)*m+1}:P_{k*m})]\" display=\"block\"><mrow><msub><mi>F</mi><mn>15</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mfrac><mi>D</mi><mi>m</mi></mfrac></munderover><msub><mi>F</mi><mrow><mi>r</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi mathvariant=\"normal\">_</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi></mrow></msub><mrow><mo stretchy=\"false\">[</mo><mtext>\ud835\udc33</mtext><mrow><mo stretchy=\"false\">(</mo><msub><mi>P</mi><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>*</mo><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow></msub><mo>:</mo><msub><mi>P</mi><mrow><mi>k</mi><mo>*</mo><mi>m</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></math>", "type": "latex"}]