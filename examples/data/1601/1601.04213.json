[{"file": "1601.04213.tex", "nexttext": "\nand equals the value exactly when $T$ includes all the $m$-bit keys as the worst case. Here the query $q$ performs with the naive backtracking algorithm in $T$. It is similarly shown that the average is $O \\left(   \\frac{k^w  m}{w} \\right) $ in a general trie of maximum out-degree $k$. \nOur analysis for tries is extended to a distributed hash table (DHT), which is among the most frequently used decentralized data structures in networking. \nWe show, under a natural probabilistic assumption for the largest class of DHTs, that the average number of hops required by an $m$-bit query $q$ to a DHT $D$ with random $w$ wildcards meets the same asymptotic bound. As a result, $q$ is answered with average $O \\left(   \\frac{2^w  m}{w} \\right) $ hops rather than $\\Theta \\left(   2^w m \\right) $ in the four major DHTs Chord, Pastry, Tapestry and Kademlia. In addition, with a uniform key distribution for sufficiently many entries, we prove that a lookup request to the DHT Chord is answered correctly with $O \\left(   m \\right) $ hops and probability $1 - 2^{-\\Omega \\left(   m \\right) }$. To the author's knowledge, the probability $1 - 2^{-\\Omega \\left(   m \\right) }$ of correct lookup in Chord has not been identified so far. \n\n\n{\\par\\addvspace\\baselineskip \\noindent\\keywordname\\enspace\\ignorespaces{partial-match query, trie, distributed hash table, Chord, Kademlia, Tapestry, Pastry, Koorde, wildcard matching}}\n\\end{abstract}\n\n\n\n\n\\section{Introduction} \\label{Introduction}\n\n\nFinding information that partially matches to a given pattern has been a major problem in computer science for decades. In addition to the classical RK and KMP-algorithms in textbooks such as \\cite{Textbook}, a collection of research results on {\\em partial-match queries} is found in literature such as \\cite{R76,CIP02}. It is common in practice to construct a trie \nas the data structure for partial-match queries with wildcards \\cite{Sedgewick}. \nHere a {\\em trie} is the well-known prefix tree data structure to store keys \\cite{Knuth}, used for applications including dictionary search and lexicographic sorting. The most basic form of a trie $T$ is the {\\em bitwise trie} to store $m$-bit integer keys. Denote by $q$ a query to such $T$. \nA {\\em wildcard $*$} in $q$ is defined as an unspecified bit for which $q$ asks the membership for both cases $*=0$ and $*=1$. For example, $q=1*0*0$ is a 5-bit query asking if $10000$, $10010$, $11000$ and $11010$ are in $T$.\n\n\nIn the paper, we first analyze the average performance of an $m$-bit query $q$ to $T$ with random $w$ wildcards. Assume that $T$ is a bitwise trie for which the wildcards occur in $w$ positions in $q$, chosen randomly with the uniform probability density function (PDF), and also that $q$ performs with the naive backtracking algorithm. \nWe show that the average number of steps in $T$ required by $q$ does not exceed \n", "itemtype": "equation", "pos": 890, "prevtext": "\n\n\\mainmatter  \n\n\n\\title{Partial-Match Queries with Random Wildcards: In Tries and Distributed Hash Tables}\n\n\n\\titlerunning{Partial-Match Queries with Random Wildcards}\n\n\n\n\n\n\n\n\\author{Junichiro Fukuyama}\n\n\\authorrunning{Junichiro Fukuyama}\n\n\n\n\n\\institute{Applied Research Laboratory, The Pennsylvania State University\\\\\njxf140@psu.edu}\n\n\n\n\n\n\n\n\n\\toctitle{Partial-Match Queries with Wildcards}\n\\tocauthor{}\n\\maketitle\n\n\n\\begin{abstract}\nConsider an $m$-bit query $q$ to a bitwise trie $T$. A {\\em wildcard $*$} is an unspecified bit in $q$ for which the query asks the membership for both cases $*=0$ and $*=1$. It is common that such {\\em partial-match queries} with wildcards are issued in tries. \nWith uniformly random occurrences of $w$ wildcards in $q$ assumed, the obvious upper bound on the average number of traversal steps in $T$ is $2^w m$. We show that the average does not exceed \n", "index": 1, "text": "\n\\[\n\\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m  = \nO \\left(   \\frac{2^w  m}{w} \\right) ,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m=O\\left(\\frac{2^{w}m}{w}\\right),\" display=\"block\"><mrow><mrow><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mrow><mi>O</mi><mo>\u2062</mo><mrow><mo>(</mo><mfrac><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>\u2062</mo><mi>m</mi></mrow><mi>w</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nand equals the value exactly when $T$ includes all the $m$-bit keys as the worst case. Here the query $q$ performs with the naive backtracking algorithm in $T$. It is similarly shown that the average is $O \\left(   \\frac{k^w  m}{w} \\right) $ in a general trie of maximum out-degree $k$. \nOur analysis for tries is extended to a distributed hash table (DHT), which is among the most frequently used decentralized data structures in networking. \nWe show, under a natural probabilistic assumption for the largest class of DHTs, that the average number of hops required by an $m$-bit query $q$ to a DHT $D$ with random $w$ wildcards meets the same asymptotic bound. As a result, $q$ is answered with average $O \\left(   \\frac{2^w  m}{w} \\right) $ hops rather than $\\Theta \\left(   2^w m \\right) $ in the four major DHTs Chord, Pastry, Tapestry and Kademlia. In addition, with a uniform key distribution for sufficiently many entries, we prove that a lookup request to the DHT Chord is answered correctly with $O \\left(   m \\right) $ hops and probability $1 - 2^{-\\Omega \\left(   m \\right) }$. To the author's knowledge, the probability $1 - 2^{-\\Omega \\left(   m \\right) }$ of correct lookup in Chord has not been identified so far. \n\n\n{\\par\\addvspace\\baselineskip \\noindent\\keywordname\\enspace\\ignorespaces{partial-match query, trie, distributed hash table, Chord, Kademlia, Tapestry, Pastry, Koorde, wildcard matching}}\n\\end{abstract}\n\n\n\n\n\\section{Introduction} \\label{Introduction}\n\n\nFinding information that partially matches to a given pattern has been a major problem in computer science for decades. In addition to the classical RK and KMP-algorithms in textbooks such as \\cite{Textbook}, a collection of research results on {\\em partial-match queries} is found in literature such as \\cite{R76,CIP02}. It is common in practice to construct a trie \nas the data structure for partial-match queries with wildcards \\cite{Sedgewick}. \nHere a {\\em trie} is the well-known prefix tree data structure to store keys \\cite{Knuth}, used for applications including dictionary search and lexicographic sorting. The most basic form of a trie $T$ is the {\\em bitwise trie} to store $m$-bit integer keys. Denote by $q$ a query to such $T$. \nA {\\em wildcard $*$} in $q$ is defined as an unspecified bit for which $q$ asks the membership for both cases $*=0$ and $*=1$. For example, $q=1*0*0$ is a 5-bit query asking if $10000$, $10010$, $11000$ and $11010$ are in $T$.\n\n\nIn the paper, we first analyze the average performance of an $m$-bit query $q$ to $T$ with random $w$ wildcards. Assume that $T$ is a bitwise trie for which the wildcards occur in $w$ positions in $q$, chosen randomly with the uniform probability density function (PDF), and also that $q$ performs with the naive backtracking algorithm. \nWe show that the average number of steps in $T$ required by $q$ does not exceed \n", "itemtype": "equation", "pos": 890, "prevtext": "\n\n\\mainmatter  \n\n\n\\title{Partial-Match Queries with Random Wildcards: In Tries and Distributed Hash Tables}\n\n\n\\titlerunning{Partial-Match Queries with Random Wildcards}\n\n\n\n\n\n\n\n\\author{Junichiro Fukuyama}\n\n\\authorrunning{Junichiro Fukuyama}\n\n\n\n\n\\institute{Applied Research Laboratory, The Pennsylvania State University\\\\\njxf140@psu.edu}\n\n\n\n\n\n\n\n\n\\toctitle{Partial-Match Queries with Wildcards}\n\\tocauthor{}\n\\maketitle\n\n\n\\begin{abstract}\nConsider an $m$-bit query $q$ to a bitwise trie $T$. A {\\em wildcard $*$} is an unspecified bit in $q$ for which the query asks the membership for both cases $*=0$ and $*=1$. It is common that such {\\em partial-match queries} with wildcards are issued in tries. \nWith uniformly random occurrences of $w$ wildcards in $q$ assumed, the obvious upper bound on the average number of traversal steps in $T$ is $2^w m$. We show that the average does not exceed \n", "index": 1, "text": "\n\\[\n\\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m  = \nO \\left(   \\frac{2^w  m}{w} \\right) ,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m=O\\left(\\frac{2^{w}m}{w}\\right),\" display=\"block\"><mrow><mrow><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mrow><mi>O</mi><mo>\u2062</mo><mrow><mo>(</mo><mfrac><mrow><msup><mn>2</mn><mi>w</mi></msup><mo>\u2062</mo><mi>m</mi></mrow><mi>w</mi></mfrac><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\naverage steps, and in exactly $b$ average steps when $T$ includes all the possible $m$-bit keys. \n\\qed\n\\end{proposition}\n\nWe construct its proof in what follows. We first show that the average is at most \n\n", "itemtype": "equation", "pos": 9736, "prevtext": "\nand is exactly equal to the value when $T$ includes all the $m$-bit keys as the worst case. \nThis improves the obvious upper bound $2^w m$ asymptotically.  \nWe will also prove that the average is $O \\left(   \\frac{k^w  m}{w} \\right) $ in a general trie of maximum out-degree $k$.  The results have been unknown so far despite the common use of queries with wildcards in $T$. In Section 4, we will present an example of a practical system in which the above analysis could be useful. \n\n\nThe second half of the paper extends our analysis to a distributed hash table (DHT), which is among the most significant decentralized data structures used in networking. A DHT  can support a number of application services such as web caching, file sharing, name-address mapping to track node mobility \\cite{DMap}, instant messaging, multicast, content distribution, etc. \nIn \\cite{DHTAnalysis}, detailed analysis is presented on the tradeoff between the routing table size and average number of hops per lookup ({\\em network diameter}) in different DHTs. In the taxonomy, the class of DHTs with $O \\left(   \\log n \\right) $ routing table size and $O \\left(   \\log n \\right) $ network diameter is the largest one ($n$: the number of nodes in the DHT). We focus on this DHT class denoted by ${\\cal C}$, which includes the four major DHTs Chord \\cite{Chord}, Pastry \\cite{Pastry}, Tapestry \\cite{Tapestry}, and Kademlia \\cite{Kademlia}. \n\n\nWe will see a structural similarity between a bitwise trie and DHT in order to answer an $m$-bit query. \nWith the above $O \\left(   \\frac{2^w  m}{w} \\right) $ bound for bitwise tries and another probabilistic assumption, we show that the average number of hops required by an $m$-bit query $q$ to a DHT $D$ with random $w$ wildcards meets the same asymptotic bound. \nArguing that the probabilistic assumption holds generally for the DHT class ${\\cal C}$, we will especially confirm it for the above four DHTs.  \nThe result thus improves the theoretical upper bound on the lookup time with $w$ random wildcards from $O \\left(   2^w \\log n \\right) $ to $O \\left(   \\frac{2^w  \\log n}{w} \\right) $ in the four DHTs. \n\n\nIn addition, with a uniform key distribution for $\\Omega \\left(   mn \\right) $ entries, we prove that a lookup request to the DHT Chord is answered correctly with $O \\left(   m \\right) $ hops and  probability $1 - 2^{-\\Omega \\left(   m \\right) }$. The probability $1 - 2^{-\\Omega \\left(   m \\right) }$ of correct lookup in Chord will be identified for the first time to the author's knowledge. \n\n\nThe rest of the paper is structured as follows. In Section 2, we will prove the $O \\left(   \\frac{2^w  m}{w} \\right) $ and $O \\left(   \\frac{k^w  m}{w} \\right) $ bounds\nfor tries $T$. Section 3 shows  the $O \\left(   \\frac{2^w  m}{w} \\right) $ bound for the four DHTs, and the probability $1 - 2^{-\\Omega \\left(   m \\right) }$ of correct lookup in Chord. It is followed by concluding remarks in Section 4. \n\n\n\n\\section{Average Search Time with Random Wildcards in Tries} \\label{Trie}\n\n\n\\subsection{In a Bitwise Trie}\n\nAn {\\em $m$-bit query $q$ to a bitwise trie $T$ with $w$ wildcards} is a string consisting of $m-w$ 0s and/or 1s, and $w$ wildcards *. \nWe assume that the letters in $q$ are numbered $m$, $m-1$, $\\ldots$, $1$ from the left to right ({\\em bit positions}). \n\n\nWe measure the running time of a query by the number of edges in $T$ traversed by the search algorithm, calling them {\\em steps}. A query $q$ with $w$ wildcards completes in no more than $2^w m$ steps. We use the  standard $O$, $\\Omega$ and $\\Theta$-notations to express asymptotic quantities. A {\\em constant} in this paper means a fixed positive real number depending on no other variable. \n\n\nIn this section, we prove that $q$ with $w$ random wildcards takes average $O \\left(   \\frac{2^w m}{w} \\right) $ steps. By $w$ random wildcards, we mean the following uniform assumption.\n\n\\medskip\n\n\\noindent\n{\\bf Assumption I: In an {\\boldmath $m$}-bit query {\\boldmath $q$} with {\\boldmath $w$} wildcards,  $*$ occurs in {\\boldmath $w$} positions with the uniform PDF.} \n\n\\medskip\n\n\\noindent\nIn other words, every wildcard pattern, or {\\em configuration}, occurs with the same probability $1 \\bigr/ {m \\choose w}$. Here a configuration determines the wildcard positions of a query $q$ to $T$. For example, c*cc* is a configuration in which $c$ represents 0/1. If $q$ satisfies Assumption I, it is said to be a {\\em query $q$ to $T$ with uniformly random $w$ wildcards}. \n\n\nAlso consider the following natural backtracking search algorithm in $T$:\n\n\n\\medskip\n\n\\noindent\n{\\bf Algorithm {\\sc Query}:} {\\em Started at the root of $T$, search for the key such that every wildcard $*$ is 0 in $q$. When the current key's membership is determined, backtrack to the node of $T$ representing the closest unfinished wildcard\\footnote{This means $*$ such that the search for $*=0$ is finished but $*=1$ is not.} * in $q$. Change $*=0$ into $*=1$. Search for the new key in $T$. Continue until the memberships of all the $2^w$ keys are determined.} \n\n\\medskip\n\n\n\n\nThe intuition behind the proof of $O \\left(   \\frac{2^w  m}{w} \\right) $ steps is the following. If the wildcards in $q$ occur in bit positions bounded by a small integer $j \\ge 1$, it takes at most $m+ O \\left(   2^w j \\right) $ steps to answer $q$, which is much smaller than $2^w m$. Since wildcards are placed randomly with the uniform PDF, this must affect the asymptotic number of steps required by $q$. \n\n\n\nWe prove the proposition below. It will be extended to a general trie of maximum out-degree $k$ in the next subsection. \n\n\\begin{proposition} \\label{Main}\nLet $q$ be an $m$-bit query to a trie $T$ with uniformly random $w$ wildcards. Algorithm {\\sc Query} answers $q$ in no more than \n", "index": 5, "text": "\n\\[\nb= \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"b=\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m\" display=\"block\"><mrow><mi>b</mi><mo>=</mo><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nThe fraction ${z \\choose j} {m-z \\choose w-j}\\Big/{m \\choose w}$ is well-known as the {\\em hypergeometric distribution} \\cite{hyper}. It is the probability of $j$ successes in $w$ draws without replacement, from $m$ items including $z$ successes and $m-z$ failures. \n\n\n\nLet $z_1$ denote the position of the rightmost wildcard bit, $i.e.$, the {\\em least significant wildcard} in the given query $q$. Likewise, let $z_j$ be the position of the $j^{th}$ least significant wildcard. The set\n", "itemtype": "equation", "pos": 10009, "prevtext": "\naverage steps, and in exactly $b$ average steps when $T$ includes all the possible $m$-bit keys. \n\\qed\n\\end{proposition}\n\nWe construct its proof in what follows. We first show that the average is at most \n\n", "index": 7, "text": "\\begin{equation} \\label{{smw}}\ns(m, w) \\stackrel{def}{=} m + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} \nj 2^{w-j+1} \\frac{{z \\choose j}{m-z \\choose w-j}}{{m \\choose w}}. \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"s(m,w)\\stackrel{def}{=}m+\\sum_{\\scriptstyle 1\\leq z\\leq m\\atop 1\\leq j\\leq w}j%&#10;2^{w-j+1}\\frac{{z\\choose j}{m-z\\choose w-j}}{{m\\choose w}}.\" display=\"block\"><mrow><mrow><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mo>,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mover><mo movablelimits=\"false\">=</mo><mrow><mi mathsize=\"142%\">d</mi><mo>\u2062</mo><mi mathsize=\"142%\">e</mi><mo>\u2062</mo><mi mathsize=\"142%\">f</mi></mrow></mover><mrow><mi>m</mi><mo>+</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mfrac linethickness=\"0pt\"><mrow><mn mathsize=\"140%\">1</mn><mo mathsize=\"140%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"140%\">z</mi><mo mathsize=\"140%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"140%\">m</mi></mrow><mrow><mn>1</mn><mo>\u2264</mo><mi>j</mi><mo>\u2264</mo><mi>w</mi></mrow></mfrac></munder><mrow><mi>j</mi><mo>\u2062</mo><msup><mn>2</mn><mrow><mrow><mi>w</mi><mo>-</mo><mi>j</mi></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mfrac><mrow><mrow><mo>(</mo><mfrac linethickness=\"0pt\"><mi>z</mi><mi>j</mi></mfrac><mo>)</mo></mrow><mo>\u2062</mo><mrow><mo>(</mo><mfrac linethickness=\"0pt\"><mrow><mi>m</mi><mo>-</mo><mi>z</mi></mrow><mrow><mi>w</mi><mo>-</mo><mi>j</mi></mrow></mfrac><mo>)</mo></mrow></mrow><mrow><mo>(</mo><mfrac linethickness=\"0pt\"><mi>m</mi><mi>w</mi></mfrac><mo>)</mo></mrow></mfrac></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\ndetermines a configuration of $q$. Observe a lemma first for $q$ with a fixed configuration. \n\n\n\\begin{lemma} \\label{Config1}\nAlgorithm {\\sc Query} on a query $q$ with configuration $\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ terminates in \n\n", "itemtype": "equation", "pos": 10694, "prevtext": "\nThe fraction ${z \\choose j} {m-z \\choose w-j}\\Big/{m \\choose w}$ is well-known as the {\\em hypergeometric distribution} \\cite{hyper}. It is the probability of $j$ successes in $w$ draws without replacement, from $m$ items including $z$ successes and $m-z$ failures. \n\n\n\nLet $z_1$ denote the position of the rightmost wildcard bit, $i.e.$, the {\\em least significant wildcard} in the given query $q$. Likewise, let $z_j$ be the position of the $j^{th}$ least significant wildcard. The set\n", "index": 9, "text": "\n\\[\nZ= \\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"Z=\\left\\{z_{1},z_{2},\\ldots,z_{w}\\right\\}\" display=\"block\"><mrow><mi>Z</mi><mo>=</mo><mrow><mo>{</mo><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>z</mi><mi>w</mi></msub><mo>}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nsteps or less.\n\\end{lemma}\n\\begin{proof}\nProve the claim by induction on $w$. The basis occurs when $w=1$. One can check that $q$ with one wildcard in position $z_1$ takes at most $m+ 2 z_1= \\hat{s} \\left(   m, 1 \\right) $ steps, verifying the basis.\n\nAssume true for $w-1$ and prove true for $w$. Below the stated number of steps are all in the worst case. The algorithm {\\sc Query} first sets the most significant wildcard at $z_w$ as $*=0$, and performs the $m$-bit query with $w-1$ wildcards. It takes\n$\n\\hat{s} \\left(   m, w-1 \\right) \n$\nsteps by induction hypothesis. Then it backtracks to the node representing the bit position $z_w$ with $z_w$ steps, set $*=1$, and recursively search for the remaining $w-1$ wildcards again. This takes extra $\\hat{s}\\left(   z_w, w-1 \\right) $ steps. \n\nSo the total number of steps required by $q$ is at most \n\\begin{eqnarray*}\n&&\n\\hat{s} \\left(   m, w - 1 \\right)  + z_w +  \\hat{s} \\left(   z_w, w-1 \\right) \n{\\\\ &=&}\n\\left(   m + \\sum_{j=1}^{w-1} 2^{w-j} z_j \\right)  + z_w +\n\\left(   z_w + \\sum_{j=1}^{w-1} 2^{w-j} z_j \\right) \n{\\\\ &=&}\nm + \\sum_{j=1}^w 2^{w-j+1} z_j\n=\\hat{s} \\left(   m, w \\right) ,\n\\end{eqnarray*}\nproving the induction step. The lemma follows.\n\\qed\\end{proof}\n\n\nNext we calculate the average of $\\hat{s} \\left(   m, w \\right) $ with the uniform occurrence of $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $. \nLet $z\\le m$ and $j \\le w$ be positive integers. Denote by $p_{z,j}$ the probability that $z$ is the position of the $j^{th}$ least significant wildcard. We have the following lemma.\n\n\n\\begin{lemma}\n$\np_{z, j} = \n{z-1 \\choose j-1} {m-z \\choose w-j}\\Big/{m \\choose w}\n$.\n\\end{lemma}\n\\begin{proof}\nFix $z$ and $j$. The number of $Z$ such that $z_j=z$ is ${z-1 \\choose j-1} {m-z \\choose w-j}$. Since each configuration occurs with probability $1 \\big/ {m \\choose w}$, \nthe probability of $z_j=z$ is $p_{z, j}$ as claimed.\n\\qed\\end{proof}\n\nIf a given integer $z$ is $z_j$ in (\\ref{Estimate}), it causes $2^{w-j+1} z_j =2^{w-j+1} z$ steps in the summation, which occurs with the probability $p_{z, j}$. The average number of steps required by $q$ is thus bounded by \n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2^{w-j+1} z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2^{w-j+1} z \n{z-1 \\choose j-1} {m-z \\choose w-j} \\Big/ {m \\choose w}\n{\\\\ &=&}\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} j 2^{w-j+1}  \n{z \\choose j} {m-z \\choose w-j} \\Big/ {m \\choose w}\n=\ns(m,w).\n\\end{eqnarray*}\nThis proves our claim that the algorithm \n{\\sc Query} takes at most $s(m, w)$ steps on average. \nThe bound is tight; when $T$ includes all the possible $m$-bit keys, {\\sc Query} actually takes average $s(m,w)$ steps. \n\n\n\n\\medskip\n\n\nIt now suffices to show \n\n", "itemtype": "equation", "pos": 10989, "prevtext": "\ndetermines a configuration of $q$. Observe a lemma first for $q$ with a fixed configuration. \n\n\n\\begin{lemma} \\label{Config1}\nAlgorithm {\\sc Query} on a query $q$ with configuration $\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ terminates in \n\n", "index": 11, "text": "\\begin{equation} \\label{{Estimate}}\n\\hat{s} \\left(   m , w \\right)  \\stackrel{def}{=} m + \\sum_{j=1}^w 2^{w-j+1} z_j\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\hat{s}\\left(m,w\\right)\\stackrel{def}{=}m+\\sum_{j=1}^{w}2^{w-j+1}z_{j}\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>s</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo>(</mo><mi>m</mi><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow><mover><mo movablelimits=\"false\">=</mo><mrow><mi mathsize=\"142%\">d</mi><mo>\u2062</mo><mi mathsize=\"142%\">e</mi><mo>\u2062</mo><mi mathsize=\"142%\">f</mi></mrow></mover><mrow><mi>m</mi><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>w</mi></munderover><mrow><msup><mn>2</mn><mrow><mrow><mi>w</mi><mo>-</mo><mi>j</mi></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><msub><mi>z</mi><mi>j</mi></msub></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nto prove {Proposition~\\ref{{Main}}}. As in standard textbooks on generating functions such as \\cite{ConcreteMath}, for a function $f: (0,1) \\rightarrow {\\mbox{\\Bb R}}$ with its Taylor series, denote by $[x^k] f(x)$ the coefficient of $x^k$ in the series. Since ${z \\choose j} = [x^z] \\frac{x^j}{(1-x)^{j+1}}$ and ${m-z \\choose w-j} = [x^{m-z}] \\frac{x^{w-j}}{(1-x)^{w-j+1}}$, \n\\begin{eqnarray*}\n&&\n\\sum_{1 \\le z \\le m} {z \\choose j} {m-z \\choose m-j} = \n\\sum_{0 \\le z \\le m} {z \\choose j} {m-z \\choose m-j} \n{\\\\ &=&}\n[x^m]  \\frac{x^j}{(1-x)^{j+1}} \\cdot \\frac{x^{w-j}}{(1-x)^{w-j+1}}\n=\n[x^m]  \\frac{x^w}{(1-x)^{w+2}} \n{\\\\ &=&}\n[x^{m+1}]  \\frac{x^{w+1}}{(1-x)^{w+2}} \n={m+1 \\choose w+1}. \n\\end{eqnarray*}\n\n\nSo, \n\\begin{eqnarray*}\ns(m, w) &=& m + \\sum_{\\scriptstyle 1 \\le j \\le w} \nj 2^{w-j+1} \\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n= \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m, \n\\end{eqnarray*}\nverifying {(\\ref{{eqMain}})}. As we have already confirmed that the bound is tight, this completes the proof of {Proposition~\\ref{{Main}}}. \n\n\n\n\n\n\\subsection{In a Trie of Maximum Out-Degree $k$}\n\n\n\n\n\n\nWe now consider a general trie $T$ of maximum out-degree $k$. We generalize {Proposition~\\ref{{Main}}} into:\n\n\\begin{theorem} \\label{RadixTree}\nLet $T$ be a trie with maximum out-degree $k \\ge 2$. \nA query to $T$ of length $m$ with $w$ uniformly random wildcards can be answered in average \n", "itemtype": "equation", "pos": 13902, "prevtext": "\nsteps or less.\n\\end{lemma}\n\\begin{proof}\nProve the claim by induction on $w$. The basis occurs when $w=1$. One can check that $q$ with one wildcard in position $z_1$ takes at most $m+ 2 z_1= \\hat{s} \\left(   m, 1 \\right) $ steps, verifying the basis.\n\nAssume true for $w-1$ and prove true for $w$. Below the stated number of steps are all in the worst case. The algorithm {\\sc Query} first sets the most significant wildcard at $z_w$ as $*=0$, and performs the $m$-bit query with $w-1$ wildcards. It takes\n$\n\\hat{s} \\left(   m, w-1 \\right) \n$\nsteps by induction hypothesis. Then it backtracks to the node representing the bit position $z_w$ with $z_w$ steps, set $*=1$, and recursively search for the remaining $w-1$ wildcards again. This takes extra $\\hat{s}\\left(   z_w, w-1 \\right) $ steps. \n\nSo the total number of steps required by $q$ is at most \n\\begin{eqnarray*}\n&&\n\\hat{s} \\left(   m, w - 1 \\right)  + z_w +  \\hat{s} \\left(   z_w, w-1 \\right) \n{\\\\ &=&}\n\\left(   m + \\sum_{j=1}^{w-1} 2^{w-j} z_j \\right)  + z_w +\n\\left(   z_w + \\sum_{j=1}^{w-1} 2^{w-j} z_j \\right) \n{\\\\ &=&}\nm + \\sum_{j=1}^w 2^{w-j+1} z_j\n=\\hat{s} \\left(   m, w \\right) ,\n\\end{eqnarray*}\nproving the induction step. The lemma follows.\n\\qed\\end{proof}\n\n\nNext we calculate the average of $\\hat{s} \\left(   m, w \\right) $ with the uniform occurrence of $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $. \nLet $z\\le m$ and $j \\le w$ be positive integers. Denote by $p_{z,j}$ the probability that $z$ is the position of the $j^{th}$ least significant wildcard. We have the following lemma.\n\n\n\\begin{lemma}\n$\np_{z, j} = \n{z-1 \\choose j-1} {m-z \\choose w-j}\\Big/{m \\choose w}\n$.\n\\end{lemma}\n\\begin{proof}\nFix $z$ and $j$. The number of $Z$ such that $z_j=z$ is ${z-1 \\choose j-1} {m-z \\choose w-j}$. Since each configuration occurs with probability $1 \\big/ {m \\choose w}$, \nthe probability of $z_j=z$ is $p_{z, j}$ as claimed.\n\\qed\\end{proof}\n\nIf a given integer $z$ is $z_j$ in (\\ref{Estimate}), it causes $2^{w-j+1} z_j =2^{w-j+1} z$ steps in the summation, which occurs with the probability $p_{z, j}$. The average number of steps required by $q$ is thus bounded by \n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2^{w-j+1} z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2^{w-j+1} z \n{z-1 \\choose j-1} {m-z \\choose w-j} \\Big/ {m \\choose w}\n{\\\\ &=&}\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} j 2^{w-j+1}  \n{z \\choose j} {m-z \\choose w-j} \\Big/ {m \\choose w}\n=\ns(m,w).\n\\end{eqnarray*}\nThis proves our claim that the algorithm \n{\\sc Query} takes at most $s(m, w)$ steps on average. \nThe bound is tight; when $T$ includes all the possible $m$-bit keys, {\\sc Query} actually takes average $s(m,w)$ steps. \n\n\n\n\\medskip\n\n\nIt now suffices to show \n\n", "index": 13, "text": "\\begin{equation} \\label{{eqMain}}\ns(m, w) = \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m, \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"s(m,w)=\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m,\" display=\"block\"><mrow><mrow><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mo>,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nsteps or less. The average is exactly $b$ when $q$ performs with Algorithm {\\sc Query}, and \n$T$ is a complete $k$-ary tree. \n\\qed\n\\end{theorem}\nThis means $q$ requires $O \\left(   \\frac{k^w m}{w} \\right) $ steps in $T$ as claimed in the introduction. \n\n\nA general trie $T$ is formally defined with its {\\em membership}: It is a tree such that each edge is associated with a letter in a given set $A$ ({\\em alphabet}). A string $s \\in A^*$ is said to be a {\\em member of $T$} if there exists a maximal directed path $\\left\\{   e_1, e_2, \\ldots, e_n \\right\\} $ in $T$ such that $s$ is the concatenation of the letters given on the edges $e_1, e_2, \\ldots, e_n$ in the order. \nFor such $T$, the algorithm {\\sc Query} is naturally generalized. \nWe re-define $\\hat{s}(m, w)$ in {(\\ref{{Estimate}})} by\n", "itemtype": "equation", "pos": 15420, "prevtext": "\nto prove {Proposition~\\ref{{Main}}}. As in standard textbooks on generating functions such as \\cite{ConcreteMath}, for a function $f: (0,1) \\rightarrow {\\mbox{\\Bb R}}$ with its Taylor series, denote by $[x^k] f(x)$ the coefficient of $x^k$ in the series. Since ${z \\choose j} = [x^z] \\frac{x^j}{(1-x)^{j+1}}$ and ${m-z \\choose w-j} = [x^{m-z}] \\frac{x^{w-j}}{(1-x)^{w-j+1}}$, \n\\begin{eqnarray*}\n&&\n\\sum_{1 \\le z \\le m} {z \\choose j} {m-z \\choose m-j} = \n\\sum_{0 \\le z \\le m} {z \\choose j} {m-z \\choose m-j} \n{\\\\ &=&}\n[x^m]  \\frac{x^j}{(1-x)^{j+1}} \\cdot \\frac{x^{w-j}}{(1-x)^{w-j+1}}\n=\n[x^m]  \\frac{x^w}{(1-x)^{w+2}} \n{\\\\ &=&}\n[x^{m+1}]  \\frac{x^{w+1}}{(1-x)^{w+2}} \n={m+1 \\choose w+1}. \n\\end{eqnarray*}\n\n\nSo, \n\\begin{eqnarray*}\ns(m, w) &=& m + \\sum_{\\scriptstyle 1 \\le j \\le w} \nj 2^{w-j+1} \\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n= \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m, \n\\end{eqnarray*}\nverifying {(\\ref{{eqMain}})}. As we have already confirmed that the bound is tight, this completes the proof of {Proposition~\\ref{{Main}}}. \n\n\n\n\n\n\\subsection{In a Trie of Maximum Out-Degree $k$}\n\n\n\n\n\n\nWe now consider a general trie $T$ of maximum out-degree $k$. We generalize {Proposition~\\ref{{Main}}} into:\n\n\\begin{theorem} \\label{RadixTree}\nLet $T$ be a trie with maximum out-degree $k \\ge 2$. \nA query to $T$ of length $m$ with $w$ uniformly random wildcards can be answered in average \n", "index": 15, "text": "\n\\[\nb = m+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"b=m+\\frac{2(m+1)}{w+1}\\cdot\\frac{k^{w+1}-(w+1)k+w}{k-1}\" display=\"block\"><mrow><mi>b</mi><mo>=</mo><mrow><mi>m</mi><mo>+</mo><mrow><mfrac><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u22c5</mo><mfrac><mrow><mrow><msup><mi>k</mi><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>k</mi></mrow></mrow><mo>+</mo><mi>w</mi></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nWe show the same claim as {Lemma~\\ref{{Config1}}} with the new $\\hat{s}(m, w)$. \n\n\\newpage\n\n\\begin{lemma} \\label{Config2}\nAlgorithm {\\sc Query} on a given query $q$ having a configuration $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ takes no more than $\\hat{s} \\left(   m , w \\right) $ steps.\n\\end{lemma}\n\\begin{proof}\nProve by induction on $w$. The basis $w=1$ is straightforward to check. Assume true for $w-1$ and prove true for $w$. It suffices show that the number of steps required by $q$ is at most $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $ since\n\\begin{small}\n\\begin{eqnarray*}\n&& \n\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) \n\\\\ &=&\n\\left(   m + \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j \\right)  + (k-1) z_w +\n(k-1) \\left(   z_w + \\sum_{j=1}^{w-1} 2k^{w-j-1}(k-1) z_j \\right) \n{\\\\ &=&}\nm+ 2(k-1) z_w + k \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j\n{\\\\ &=&}\nm + \\sum_{j=1}^w 2k^{w-j}(k-1) z_j\n=\\hat{s} \\left(   m, w \\right) .\n\\end{eqnarray*}\n\\end{small}\n\nTo verify it, wlog let $v$ be the node such that the letters $a_1, a_2, \\ldots, a_k$ given on the edges from $v$ correspond to the most significant wildcard in $q$. The algorithm {\\sc Query} first chooses $a_1$ as the value of the wildcard, then finds all the members of $T$ matching to $q$. This requires at most $\\hat{s} (m, w-1)$ steps by induction hypothesis. Then it backtracks to $v$ in $z_w$ steps to find all the members of $T$ that match to $q$ including $a_2$. It takes at most $z_w + \\hat{s} (z_w, w-1)$ steps.\n\n\nThe above repeats $k-1$ times for $a_2, a_3, \\ldots, a_k$. Thus the total number of traversal steps required by $q$ is upper-bounded by $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $, completing the proof.\n\\qed \\end{proof}\n\n\\medskip\n\n\nThe rest of the proof is the same as for a bitwise trie. We find that the average number of steps required by $q$ is no more than\n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2 k^{w-j}(k-1) z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{z \\choose j} {m-z \\choose w-j}}{{m \\choose w}}\n{\\\\ &=&}\nm + \\sum_{1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n{\\\\ &=&}\nm+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}.\n\\end{eqnarray*}\nThe bound is tight by the same argument also; for $q$ having a configuration $Z$, {\\em Query} takes $\\hat{s} \\left(   m , w \\right) $ steps exactly if $T$ is a complete $k$-ary tree. \nThis completes the proof of {Theorem~\\ref{{RadixTree}}}. \n\n\n\n\n\n\n\n\n\n\\section{Lookup Response Time with Wildcards in a Distributed Hash Table}\n\n\nIn this section, we show the same asymptotic upper bound $O \\left(   \\frac{2^w m}{w} \\right) $ for a DHT $D$. We will verify it through the structural similarity between a bitwise trie and DHT: key search by incremental bit improvement. We first define general terminology on a DHT with related facts in Section 3.1. The second subsection presents a necessary probabilistic assumption general in the aforementioned DHT class ${\\cal C}$. In Section 3.3, we show that the probability of correct lookup is $1-  2^{-\\Omega \\left(   m \\right) }$ in the DHT Chord with sufficiently many independent keys. \nThe $O \\left(   \\frac{2^w m}{w} \\right) $ bound will be proved with {Proposition~\\ref{{Main}}} in Section 3.4.\n\n\n\\subsection{Distributed Hash Table and Wildcard Query}\n\nLet $S$ be the {\\em key space} for DHT $D$. Suppose it consists of the $m$-bit binary integers so that $|S|=2^m$. A node $v$ in $D$ is labeled by a key denoted by $key(v) \\in S$. It is said to be the {\\em node key} of $v$, which is typically a large random number such as a hash of the IP address of $v$ or that of a file name. The mapping $v \\mapsto key(v)$ is an injection, $i.e.$, there is no other node $v'$ in $D$ such that $key(v')=key(v)$. Information is stored at a node as a pair $<$key, value$>$ called {\\em entry}. We denote an entry by $<\n", "itemtype": "equation", "pos": 16290, "prevtext": "\nsteps or less. The average is exactly $b$ when $q$ performs with Algorithm {\\sc Query}, and \n$T$ is a complete $k$-ary tree. \n\\qed\n\\end{theorem}\nThis means $q$ requires $O \\left(   \\frac{k^w m}{w} \\right) $ steps in $T$ as claimed in the introduction. \n\n\nA general trie $T$ is formally defined with its {\\em membership}: It is a tree such that each edge is associated with a letter in a given set $A$ ({\\em alphabet}). A string $s \\in A^*$ is said to be a {\\em member of $T$} if there exists a maximal directed path $\\left\\{   e_1, e_2, \\ldots, e_n \\right\\} $ in $T$ such that $s$ is the concatenation of the letters given on the edges $e_1, e_2, \\ldots, e_n$ in the order. \nFor such $T$, the algorithm {\\sc Query} is naturally generalized. \nWe re-define $\\hat{s}(m, w)$ in {(\\ref{{Estimate}})} by\n", "index": 17, "text": "\n\\[\n\\hat{s} \\left(   m , w \\right)  = m + \\sum_{j=1}^w 2k^{w-j} (k-1) z_j.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\hat{s}\\left(m,w\\right)=m+\\sum_{j=1}^{w}2k^{w-j}(k-1)z_{j}.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>s</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo>(</mo><mi>m</mi><mo>,</mo><mi>w</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mi>m</mi><mo>+</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>w</mi></munderover><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>k</mi><mrow><mi>w</mi><mo>-</mo><mi>j</mi></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>z</mi><mi>j</mi></msub></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": ">$ where $d \\in S$ is its {\\em data key}. \n\n\n\n\nThe {\\em distance from $d \\in S$ to $d' \\in S$} is written as  $\\Delta \\left(   d, d' \\right) $, which is defined by the DHT design. For example, Chord measures $\\Delta \\left(   d, d' \\right) $ as $d' - d$ mod $2^m$ evaluated clockwise in the circular ring $0,1, \\ldots, 2^{m-1}$  \\cite{Chord}. Kademlia measures $\\Delta \\left(   d, d' \\right) $ by the XOR metric \\cite{Kademlia}.  For a data key $d$, we say that the node $v$ such that $\\Delta \\left(   d, key(v) \\right) $ is minimum is the {\\em successor of $d$}, and $v$ such that $\\Delta \\left(   key(v), d \\right) $ is minimum is the {\\em predecessor}. \nAn entry $<\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe show the same claim as {Lemma~\\ref{{Config1}}} with the new $\\hat{s}(m, w)$. \n\n\\newpage\n\n\\begin{lemma} \\label{Config2}\nAlgorithm {\\sc Query} on a given query $q$ having a configuration $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ takes no more than $\\hat{s} \\left(   m , w \\right) $ steps.\n\\end{lemma}\n\\begin{proof}\nProve by induction on $w$. The basis $w=1$ is straightforward to check. Assume true for $w-1$ and prove true for $w$. It suffices show that the number of steps required by $q$ is at most $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $ since\n\\begin{small}\n\\begin{eqnarray*}\n&& \n\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) \n\\\\ &=&\n\\left(   m + \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j \\right)  + (k-1) z_w +\n(k-1) \\left(   z_w + \\sum_{j=1}^{w-1} 2k^{w-j-1}(k-1) z_j \\right) \n{\\\\ &=&}\nm+ 2(k-1) z_w + k \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j\n{\\\\ &=&}\nm + \\sum_{j=1}^w 2k^{w-j}(k-1) z_j\n=\\hat{s} \\left(   m, w \\right) .\n\\end{eqnarray*}\n\\end{small}\n\nTo verify it, wlog let $v$ be the node such that the letters $a_1, a_2, \\ldots, a_k$ given on the edges from $v$ correspond to the most significant wildcard in $q$. The algorithm {\\sc Query} first chooses $a_1$ as the value of the wildcard, then finds all the members of $T$ matching to $q$. This requires at most $\\hat{s} (m, w-1)$ steps by induction hypothesis. Then it backtracks to $v$ in $z_w$ steps to find all the members of $T$ that match to $q$ including $a_2$. It takes at most $z_w + \\hat{s} (z_w, w-1)$ steps.\n\n\nThe above repeats $k-1$ times for $a_2, a_3, \\ldots, a_k$. Thus the total number of traversal steps required by $q$ is upper-bounded by $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $, completing the proof.\n\\qed \\end{proof}\n\n\\medskip\n\n\nThe rest of the proof is the same as for a bitwise trie. We find that the average number of steps required by $q$ is no more than\n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2 k^{w-j}(k-1) z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{z \\choose j} {m-z \\choose w-j}}{{m \\choose w}}\n{\\\\ &=&}\nm + \\sum_{1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n{\\\\ &=&}\nm+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}.\n\\end{eqnarray*}\nThe bound is tight by the same argument also; for $q$ having a configuration $Z$, {\\em Query} takes $\\hat{s} \\left(   m , w \\right) $ steps exactly if $T$ is a complete $k$-ary tree. \nThis completes the proof of {Theorem~\\ref{{RadixTree}}}. \n\n\n\n\n\n\n\n\n\n\\section{Lookup Response Time with Wildcards in a Distributed Hash Table}\n\n\nIn this section, we show the same asymptotic upper bound $O \\left(   \\frac{2^w m}{w} \\right) $ for a DHT $D$. We will verify it through the structural similarity between a bitwise trie and DHT: key search by incremental bit improvement. We first define general terminology on a DHT with related facts in Section 3.1. The second subsection presents a necessary probabilistic assumption general in the aforementioned DHT class ${\\cal C}$. In Section 3.3, we show that the probability of correct lookup is $1-  2^{-\\Omega \\left(   m \\right) }$ in the DHT Chord with sufficiently many independent keys. \nThe $O \\left(   \\frac{2^w m}{w} \\right) $ bound will be proved with {Proposition~\\ref{{Main}}} in Section 3.4.\n\n\n\\subsection{Distributed Hash Table and Wildcard Query}\n\nLet $S$ be the {\\em key space} for DHT $D$. Suppose it consists of the $m$-bit binary integers so that $|S|=2^m$. A node $v$ in $D$ is labeled by a key denoted by $key(v) \\in S$. It is said to be the {\\em node key} of $v$, which is typically a large random number such as a hash of the IP address of $v$ or that of a file name. The mapping $v \\mapsto key(v)$ is an injection, $i.e.$, there is no other node $v'$ in $D$ such that $key(v')=key(v)$. Information is stored at a node as a pair $<$key, value$>$ called {\\em entry}. We denote an entry by $<\n", "index": 19, "text": "$$d, r$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"d,r\" display=\"block\"><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": ">$ where $d \\in S$ is its {\\em data key}. \n\n\n\n\nThe {\\em distance from $d \\in S$ to $d' \\in S$} is written as  $\\Delta \\left(   d, d' \\right) $, which is defined by the DHT design. For example, Chord measures $\\Delta \\left(   d, d' \\right) $ as $d' - d$ mod $2^m$ evaluated clockwise in the circular ring $0,1, \\ldots, 2^{m-1}$  \\cite{Chord}. Kademlia measures $\\Delta \\left(   d, d' \\right) $ by the XOR metric \\cite{Kademlia}.  For a data key $d$, we say that the node $v$ such that $\\Delta \\left(   d, key(v) \\right) $ is minimum is the {\\em successor of $d$}, and $v$ such that $\\Delta \\left(   key(v), d \\right) $ is minimum is the {\\em predecessor}. \nAn entry $<\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe show the same claim as {Lemma~\\ref{{Config1}}} with the new $\\hat{s}(m, w)$. \n\n\\newpage\n\n\\begin{lemma} \\label{Config2}\nAlgorithm {\\sc Query} on a given query $q$ having a configuration $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ takes no more than $\\hat{s} \\left(   m , w \\right) $ steps.\n\\end{lemma}\n\\begin{proof}\nProve by induction on $w$. The basis $w=1$ is straightforward to check. Assume true for $w-1$ and prove true for $w$. It suffices show that the number of steps required by $q$ is at most $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $ since\n\\begin{small}\n\\begin{eqnarray*}\n&& \n\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) \n\\\\ &=&\n\\left(   m + \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j \\right)  + (k-1) z_w +\n(k-1) \\left(   z_w + \\sum_{j=1}^{w-1} 2k^{w-j-1}(k-1) z_j \\right) \n{\\\\ &=&}\nm+ 2(k-1) z_w + k \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j\n{\\\\ &=&}\nm + \\sum_{j=1}^w 2k^{w-j}(k-1) z_j\n=\\hat{s} \\left(   m, w \\right) .\n\\end{eqnarray*}\n\\end{small}\n\nTo verify it, wlog let $v$ be the node such that the letters $a_1, a_2, \\ldots, a_k$ given on the edges from $v$ correspond to the most significant wildcard in $q$. The algorithm {\\sc Query} first chooses $a_1$ as the value of the wildcard, then finds all the members of $T$ matching to $q$. This requires at most $\\hat{s} (m, w-1)$ steps by induction hypothesis. Then it backtracks to $v$ in $z_w$ steps to find all the members of $T$ that match to $q$ including $a_2$. It takes at most $z_w + \\hat{s} (z_w, w-1)$ steps.\n\n\nThe above repeats $k-1$ times for $a_2, a_3, \\ldots, a_k$. Thus the total number of traversal steps required by $q$ is upper-bounded by $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $, completing the proof.\n\\qed \\end{proof}\n\n\\medskip\n\n\nThe rest of the proof is the same as for a bitwise trie. We find that the average number of steps required by $q$ is no more than\n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2 k^{w-j}(k-1) z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{z \\choose j} {m-z \\choose w-j}}{{m \\choose w}}\n{\\\\ &=&}\nm + \\sum_{1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n{\\\\ &=&}\nm+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}.\n\\end{eqnarray*}\nThe bound is tight by the same argument also; for $q$ having a configuration $Z$, {\\em Query} takes $\\hat{s} \\left(   m , w \\right) $ steps exactly if $T$ is a complete $k$-ary tree. \nThis completes the proof of {Theorem~\\ref{{RadixTree}}}. \n\n\n\n\n\n\n\n\n\n\\section{Lookup Response Time with Wildcards in a Distributed Hash Table}\n\n\nIn this section, we show the same asymptotic upper bound $O \\left(   \\frac{2^w m}{w} \\right) $ for a DHT $D$. We will verify it through the structural similarity between a bitwise trie and DHT: key search by incremental bit improvement. We first define general terminology on a DHT with related facts in Section 3.1. The second subsection presents a necessary probabilistic assumption general in the aforementioned DHT class ${\\cal C}$. In Section 3.3, we show that the probability of correct lookup is $1-  2^{-\\Omega \\left(   m \\right) }$ in the DHT Chord with sufficiently many independent keys. \nThe $O \\left(   \\frac{2^w m}{w} \\right) $ bound will be proved with {Proposition~\\ref{{Main}}} in Section 3.4.\n\n\n\\subsection{Distributed Hash Table and Wildcard Query}\n\nLet $S$ be the {\\em key space} for DHT $D$. Suppose it consists of the $m$-bit binary integers so that $|S|=2^m$. A node $v$ in $D$ is labeled by a key denoted by $key(v) \\in S$. It is said to be the {\\em node key} of $v$, which is typically a large random number such as a hash of the IP address of $v$ or that of a file name. The mapping $v \\mapsto key(v)$ is an injection, $i.e.$, there is no other node $v'$ in $D$ such that $key(v')=key(v)$. Information is stored at a node as a pair $<$key, value$>$ called {\\em entry}. We denote an entry by $<\n", "index": 19, "text": "$$d, r$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"d,r\" display=\"block\"><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nThe three conditions are:\n\\begin{enumerate} [A)]\n\\item The routing table of $v$ include $v'$ such that {(\\ref{{v'Condition}})} with probability $1 - 2^{-m^{1/2+{\\epsilon}}}$ for some sufficiently small  constant ${\\epsilon}>0$.\n\\item If there exists such $v'$, the lookup protocol must move the current peer node to $v'$.\n\\item  The worst case number of hops for the lookup does not exceed a polynomial in $m$.\n\\end{enumerate}\n\n\nIf the routing table of $v$ does not include such $v'$, the lookup protocol may decide $d \\not \\in D$, or change $v$ to another with no guarantee on the closeness to $d$. This {\\em error case} occurs with a small probability at most $2^{-m^{1/2+{\\epsilon}}}$ for each $v$. \n\n\nOur assumption for the proof of $h=O \\left(   \\frac{2^w \\log n}{w} \\right) $ is now stated as: \n\n\\medskip\n\n\\noindent\n{\\bf Assumption II: The lookup protocol of the considered DHT improves at least one bit per hop, correctly with high probability.}\n\n\\medskip\n\n\nThis property of incremental bit improvement is common in the considered DHT class ${\\cal C}$. The lookup protocol keeps improving another bit until $d$ is between the node keys of $v$ and its neighbor for the first time. In the end it identifies both the successor and predecessor of $d$. An error case may occur with probability $p(m) 2^{-m^{1/2+ {\\epsilon}}} < 2^{-m^{\\left(   1+ {\\epsilon} \\right) /2}}$ for some polynomial $p(m)$. Thus any lookup in $D$ satisfying the assumption is resolved with average number of hops $O \\left(   m \\right)  = O \\left(   \\log n \\right) $, and probability at least $2^{-m^{\\left(   1+ {\\epsilon} \\right) /2}}$. \n\n\n\n\n\n\nHence Assumption II is general in ${\\cal C}$, and is satisfied by the above four DHTs: One can check that all of their lookup protocols improve at least one bit per hop with high probability. The actual magnitude of the high probability depends on $m$, $n$, and the frequencies of entry updates and routing table maintenance. Assumption II with the bound $1-2^{-m^{1/2+{\\epsilon}}}$ is true for the four DHTs with some possible performance parameters in practice. Notice that if $m=C \\log n$ for a constant $C$, it means $1-2^{-m^{1/2+{\\epsilon}}} \\le  1 - n^{-{\\epsilon}}$ for any small constant ${\\epsilon}>0$ and sufficiently large $m$ and $n$. The error probability bound $n^{-{\\epsilon}}$ can be achieved in any of the four DHTs. Also the condition C) is satisfied by the maximum number of hops allowed for a lookup, which is set in the DHT. \n\n\\medskip\n\nIt has been seen that $D$ satisfying Assumption II searches for keys with the same incremental bit improvement as a bitwise trie $T$. Hence we will be able to apply {Proposition~\\ref{{Main}}} to $D$ to show the $O \\left(   \\frac{2^w m}{w} \\right) $ bound. Here the following {\\em natural query protocol} is assumed for $D$, which is equivalent to the algorithm {\\sc Query}. \n\n\n\\medskip\n\n\\noindent\n{\\bf Natural Query Protocol}: {\\em First set every $*$ in $q$ as 0 and search for the data key in the DHT. Change the least significant unfinished wildcard from $*=0$ into $*=1$. Search for the new data key started at the current peer node. Repeat until the membership of every desired data key is determined.}\n\n\\medskip\n\nNote that we consider two independent probability spaces for a) the key distribution in $D$, and b) the distribution of configurations of $q$. If we say the average number of hops for $q$ in $D$, it means the average over the joint distribution decided by a) and b). \n\n\n\n\n\\subsection{The Probability of Correct Lookup in the DHT Chord}\n\nIn case $D$ is Chord, we can present a parameter class such that $D$ satisfies Assumption II exactly. Consider the following argument. \n\n\n\n\\begin{lemma} \\label{ChordAndII}\nLet $D$ be a distributed hash table Chord defined over the $m$-bit key space $S$ with $n$ nodes where $n$ and $m=O \\left(   \\log n \\right) $ are sufficiently large. $D$ satisfies Assumption II if:\n{}\n\\item there are at least $C m n$ entries stored in $D$ for a sufficiently large constant $C>1$, and\n\\item an entry $<\n", "itemtype": "equation", "pos": 24031, "prevtext": ">$ is stored at the successor or predecessor of $d$, or in a generalized object to include them. \nAlso the {\\em successor of $v$} is the node $v' \\ne v$ such that $\\Delta \\left(   key(v), key(v') \\right) $ is minimum, and {\\em predecessor of $v$} is $v' \\ne v$ such that $\\Delta \\left(   key(v'), key(v) \\right) $ is minimum. \nA {\\em neighbor} of $d$ or $v$ is its successor or predecessor. \nDenote by $n$ the number of nodes in $D$. We assume $m = O \\left(   \\log n \\right) $ conventionally. \n\n\n\nIt is called {\\em lookup in $D$} to determine the membership of a given key $d \\in S$ in $D$, written as $d \\in D$ or $d \\not\\in D$. \nTo answer it, the lookup protocol runs at the {\\em current peer node} of $D$ moving to another if necessary. A {\\em hop} is a change of the current peer node. The average number of hops per lookup is said to be the {\\em network diameter of $D$}. \n\n\nIn addition, each node $v$ holds a set of addresses of other nodes determined by certain rules, usually including all the $v$'s neighbors. \nIt is called the {\\em routing table of $v$}. We may simply say the routing table includes the nodes rather than their addresses. \nA good DHT is designed with a routing table and distance $\\Delta \\left(   d, d' \\right) $ that allow for efficient lookups and updates of entries. For $D$ in the aforementioned DHT class ${\\cal C}$, the routing table size and network diameter are both  $O \\left(   \\log n \\right) $. The class ${\\cal C}$ includes the four major DHTs Chord, Pastry, Tapestry and Kademlia. \n\n\n\nWith the above, a {\\em query $q$ to $D$ with uniformly random $w$ wildcards} is defined the same way as to a bitwise trie $T$. We say that a lookup/query is {\\em resolved} if the protocol returns the correct answer. \nLet $h$ stand for the average number of hops required to resolve $q$. It is our measure of $q$'s response time. Our goal in this section is to show $h=O \\left(   \\frac{2^w \\log n}{w} \\right) $ for DHT $D \\in {\\cal C}$ and $q$ with uniformly random $w$ wildcards.\n\n\n\n\\subsection{A Probabilistic Assumption for $D$}\n\n\nIt works similarly to a bitwise trie $T$ how to find a data key $d$ that is a member of DHT $D$: by repeatedly moving to a node $v$ such that $key(v)$ has a smaller distance to $d$ than the current peer node. The number of significant bits shared by $d$ and $key(v)$ is increased incrementally. \nIn our proof of the $O \\left(   \\frac{2^w m}{w} \\right) $ bound for $D$, we need another probabilistic assumption to justify this incremental bit improvement. \n\n\n\nA DHT $D$ or its lookup protocol is said to {\\em improve at least one bit per hop, correctly with high probability} if it satisfies the three conditions A)--C) below: In finding a target data key $d$, let $v$ be the current peer node and $v_d$ be a neighbor of $d$. \nSuppose that $2^{g-1} \\le \\Delta \\left(   key(v), key(v_d) \\right) <2^g$ for an integer $g>1$. Let $v'$ be a node in the routing table such that\n\n", "index": 23, "text": "\\begin{equation} \\label{{v'Condition}}\n2^{g-2} \\le \\Delta \\left(   key(v'), key(v_d) \\right) <2^{g-1}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"2^{g-2}\\leq\\Delta\\left(key(v^{\\prime}),key(v_{d})\\right)&lt;2^{g-1}.\" display=\"block\"><mrow><mrow><msup><mn>2</mn><mrow><mi>g</mi><mo>-</mo><mn>2</mn></mrow></msup><mo>\u2264</mo><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><mi>k</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>v</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>k</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mi>d</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>)</mo></mrow></mrow><mo>&lt;</mo><msup><mn>2</mn><mrow><mi>g</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": ">$ where $d \\in S$ is its {\\em data key}. \n\n\n\n\nThe {\\em distance from $d \\in S$ to $d' \\in S$} is written as  $\\Delta \\left(   d, d' \\right) $, which is defined by the DHT design. For example, Chord measures $\\Delta \\left(   d, d' \\right) $ as $d' - d$ mod $2^m$ evaluated clockwise in the circular ring $0,1, \\ldots, 2^{m-1}$  \\cite{Chord}. Kademlia measures $\\Delta \\left(   d, d' \\right) $ by the XOR metric \\cite{Kademlia}.  For a data key $d$, we say that the node $v$ such that $\\Delta \\left(   d, key(v) \\right) $ is minimum is the {\\em successor of $d$}, and $v$ such that $\\Delta \\left(   key(v), d \\right) $ is minimum is the {\\em predecessor}. \nAn entry $<\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe show the same claim as {Lemma~\\ref{{Config1}}} with the new $\\hat{s}(m, w)$. \n\n\\newpage\n\n\\begin{lemma} \\label{Config2}\nAlgorithm {\\sc Query} on a given query $q$ having a configuration $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ takes no more than $\\hat{s} \\left(   m , w \\right) $ steps.\n\\end{lemma}\n\\begin{proof}\nProve by induction on $w$. The basis $w=1$ is straightforward to check. Assume true for $w-1$ and prove true for $w$. It suffices show that the number of steps required by $q$ is at most $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $ since\n\\begin{small}\n\\begin{eqnarray*}\n&& \n\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) \n\\\\ &=&\n\\left(   m + \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j \\right)  + (k-1) z_w +\n(k-1) \\left(   z_w + \\sum_{j=1}^{w-1} 2k^{w-j-1}(k-1) z_j \\right) \n{\\\\ &=&}\nm+ 2(k-1) z_w + k \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j\n{\\\\ &=&}\nm + \\sum_{j=1}^w 2k^{w-j}(k-1) z_j\n=\\hat{s} \\left(   m, w \\right) .\n\\end{eqnarray*}\n\\end{small}\n\nTo verify it, wlog let $v$ be the node such that the letters $a_1, a_2, \\ldots, a_k$ given on the edges from $v$ correspond to the most significant wildcard in $q$. The algorithm {\\sc Query} first chooses $a_1$ as the value of the wildcard, then finds all the members of $T$ matching to $q$. This requires at most $\\hat{s} (m, w-1)$ steps by induction hypothesis. Then it backtracks to $v$ in $z_w$ steps to find all the members of $T$ that match to $q$ including $a_2$. It takes at most $z_w + \\hat{s} (z_w, w-1)$ steps.\n\n\nThe above repeats $k-1$ times for $a_2, a_3, \\ldots, a_k$. Thus the total number of traversal steps required by $q$ is upper-bounded by $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $, completing the proof.\n\\qed \\end{proof}\n\n\\medskip\n\n\nThe rest of the proof is the same as for a bitwise trie. We find that the average number of steps required by $q$ is no more than\n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2 k^{w-j}(k-1) z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{z \\choose j} {m-z \\choose w-j}}{{m \\choose w}}\n{\\\\ &=&}\nm + \\sum_{1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n{\\\\ &=&}\nm+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}.\n\\end{eqnarray*}\nThe bound is tight by the same argument also; for $q$ having a configuration $Z$, {\\em Query} takes $\\hat{s} \\left(   m , w \\right) $ steps exactly if $T$ is a complete $k$-ary tree. \nThis completes the proof of {Theorem~\\ref{{RadixTree}}}. \n\n\n\n\n\n\n\n\n\n\\section{Lookup Response Time with Wildcards in a Distributed Hash Table}\n\n\nIn this section, we show the same asymptotic upper bound $O \\left(   \\frac{2^w m}{w} \\right) $ for a DHT $D$. We will verify it through the structural similarity between a bitwise trie and DHT: key search by incremental bit improvement. We first define general terminology on a DHT with related facts in Section 3.1. The second subsection presents a necessary probabilistic assumption general in the aforementioned DHT class ${\\cal C}$. In Section 3.3, we show that the probability of correct lookup is $1-  2^{-\\Omega \\left(   m \\right) }$ in the DHT Chord with sufficiently many independent keys. \nThe $O \\left(   \\frac{2^w m}{w} \\right) $ bound will be proved with {Proposition~\\ref{{Main}}} in Section 3.4.\n\n\n\\subsection{Distributed Hash Table and Wildcard Query}\n\nLet $S$ be the {\\em key space} for DHT $D$. Suppose it consists of the $m$-bit binary integers so that $|S|=2^m$. A node $v$ in $D$ is labeled by a key denoted by $key(v) \\in S$. It is said to be the {\\em node key} of $v$, which is typically a large random number such as a hash of the IP address of $v$ or that of a file name. The mapping $v \\mapsto key(v)$ is an injection, $i.e.$, there is no other node $v'$ in $D$ such that $key(v')=key(v)$. Information is stored at a node as a pair $<$key, value$>$ called {\\em entry}. We denote an entry by $<\n", "index": 19, "text": "$$d, r$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"d,r\" display=\"block\"><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nThen \n$Pr \\left(   j  \\le m \\right)  < e^{- \\frac{C}{2} m} < e^{- m^{1/2+{\\epsilon}}}$, meaning $v$ has $m$ entries with high probability as required by Assumption II. (Note that the assumption considers a single particular hop from the current peer node $v$.) \n\n\nWe show {(\\ref{{L5Target}})} by the Chernoff bound given in \\cite{Kobayashi}. For our case, it provides the upper bound\n\\begin{eqnarray}\n&& \\label{ChernoffBound}\nPr \\big( X_1 + X_2 + \\cdots + X_N \\le m  \\big)\n\\le \\min_{t \\le 0} \\left\\{   e^{-tm + N \\ln M(t)} \\right\\} , \n\\\\ \\textrm{where} && \\nonumber\nM(t)= \\left(   1  - \\frac{1}{n} \\right)  e^{0 \\cdot t}+ \\frac{1}{n} e^{1 \\cdot t}\n= 1 + \\frac{e^t - 1}{n}.\n\\end{eqnarray}\nHere $X_i$ is the random variable that represents the $i^{th}$ Bernoulli trial, $i.e.$, $X_i=1$ if $i^{th}$ entry is stored at $v$ and $X_i=0$ otherwise. Also $M(t)$ is the {\\em moment generating function of $X_i$} where $t$ is a real parameter.\n\n\nBy {(\\ref{{ChernoffBound}})}, \n$\nPr \\left(   j \\le m \\right)  \\le  e^{-tm + N \\ln M(t)}\n$\nfor the parameter \n$\nt = \\ln \\frac{mn}{N} \\le \\ln \\frac{1}{C} < 0\n$ that is particularly chosen. \nThe natural logarithm of the moment generating function is \n$\n\\ln M(t) = \\ln \\left(   1 + \\frac{\\frac{mn}{N} - 1}{n} \\right) \n$ for this $t$. We now have \n\n", "itemtype": "equation", "pos": 30110, "prevtext": ">$ is stored at a node chosen with the uniform probability density function, independently of the others\\footnote{This statement considers a probability space constructed for each given $m$, $n$ and the number of stored entries. Its event set consists of all the cases of contained node keys and entries. It defines a PDF of \nnode choice to store each entry. It is uniform and independent of any other event, as the statement assumes.  \n}.\n\\end{list}\n\\end{lemma}\n\\begin{proof}\nIt suffices to show that there are at least $m$ entries stored at any given node $v$ with high probability, which is seen as follows. By the construction of Chord \\cite{Chord}, the $i^{th}$ entry stored at $v$ has a pointer to the successor of $key(v)+2^{i-1}$, called {\\em finger}. In other words, $v$'s routing table is required to include the address of the successor if there are $i$ entries or more stored at $v$. If there are $m$ entries at $v$ with high probability, its routing table has the finger to the successor of $key(v)+2^{i-1}$ for every $i \\le m$. Then the lookup protocol defined by Chord improves at least one bit per hop correctly with high probability\\footnote{\nIf the routing table of $v$ includes no other node $v'$ closer to the desired key $d$ ($i.e.$, such that {(\\ref{{v'Condition}})}), the protocol of Chord decides $d \\not \\in D$, rather than performing further lookup with no guarantee to the closeness to $d$. \n}. \n\n\n\n\nLet $N$ be the total number of entries in $D$ that is at least $Cmn$ by Condition i), and $j$ be the number of entries stored at $v$. Due to ii), deciding if the $i^{th}$ entry is stored at $v$ is a Bernoulli trial with probability of success equal to $\\frac{1}{n}$. Repeating it $N$ times, we have \n$\nPr(j \\le m) = \\sum_{j \\le m} {N \\choose j} \\left(   \\frac{1}{n} \\right) ^j \\left(   1 - \\frac{1}{n} \\right) ^{N-j}, \n$\nwhere $Pr(\\cdot)$ denotes the probability of the argument event.\nWe will show \n\n", "index": 27, "text": "\\begin{equation} \\label{{L5Target}}\nPr \\left(   j \\le m \\right)  < e^{- \\frac{C}{2} m}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"Pr\\left(j\\leq m\\right)&lt;e^{-\\frac{C}{2}m}.\" display=\"block\"><mrow><mi>P</mi><mi>r</mi><mrow><mo>(</mo><mi>j</mi><mo>\u2264</mo><mi>m</mi><mo>)</mo></mrow><mo>&lt;</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mfrac><mi>C</mi><mn>2</mn></mfrac><mo>\u2062</mo><mi>m</mi></mrow></mrow></msup><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\ndesiring that its RHS is at most $-Cm/2$ to show {(\\ref{{L5Target}})}. \n\n\nPut $y = \\frac{N}{mn} \\ge C$ that is sufficiently large. By the Taylor series of the natural logarithm, $\\ln \\left(   1 + \\frac{\\frac{mn}{N} - 1}{n} \\right)  = \\ln \\left(   1 - \\frac{1- \\frac{1}{y}}{n} \\right)  \\le  - \\frac{1- \\frac{1}{y}}{n} + O \\left(   \\frac{1}{n^2} \\right) $. By {(\\ref{{Eq1L5}})} and $N=mny$, \n\\begin{eqnarray*}\n\\ln Pr \\left(   j \\le m \\right)  &<&\nm \\ln y  - \\frac{N}{n}  \\left(   1  - \\frac{1}{y} \\right)  + O \\left(   \\frac{N}{n^2} \\right) \n{\\\\ &=&}\nm \\left(   \\ln y  -  y   \\left(   1  - \\frac{1}{y} \\right)  + O \\left(   \\frac{y}{n} \\right)  \\right) \n{\\\\ &=&}\nm \\left(   \\ln y  -  y   +  1 + O \\left(   \\frac{y}{n} \\right)  \\right) \n<- \\frac{y}{2} m \\le -\\frac{C}{2}m.\n\\end{eqnarray*}\nThis confirms {(\\ref{{L5Target}})} proving the lemma. \n\\qed\\end{proof}\n\n\n\nObserve that if Chord $D$ satisfies Conditions i) and ii), an error case occurs for each lookup with probability at most $m \\cdot e^{- \\frac{C}{2} m} < 2^{-\\Omega \\left(   m \\right) }$ due to {(\\ref{{L5Target}})}. Then any lookup in $D$ is resolved correctly with at most $m=O \\left(   \\log n \\right) $ hops and probability $1 - 2^{- \\Omega \\left(   m \\right) }$. Therefore:\n\n\\begin{theorem} \\label{CorrectLookup}\nLet $D$ be a distributed hash table Chord defined over the $m$-bit key space $S$ with $n$ nodes where $n$ and $m=O \\left(   \\log n \\right) $ are sufficiently large. Suppose that it satisfies the following two.\n{}\n\\item There are at least $C m n$ entries stored in $D$ for a large constant $C>1$. \n\\item An entry  $<\n", "itemtype": "equation", "pos": 31492, "prevtext": "\nThen \n$Pr \\left(   j  \\le m \\right)  < e^{- \\frac{C}{2} m} < e^{- m^{1/2+{\\epsilon}}}$, meaning $v$ has $m$ entries with high probability as required by Assumption II. (Note that the assumption considers a single particular hop from the current peer node $v$.) \n\n\nWe show {(\\ref{{L5Target}})} by the Chernoff bound given in \\cite{Kobayashi}. For our case, it provides the upper bound\n\\begin{eqnarray}\n&& \\label{ChernoffBound}\nPr \\big( X_1 + X_2 + \\cdots + X_N \\le m  \\big)\n\\le \\min_{t \\le 0} \\left\\{   e^{-tm + N \\ln M(t)} \\right\\} , \n\\\\ \\textrm{where} && \\nonumber\nM(t)= \\left(   1  - \\frac{1}{n} \\right)  e^{0 \\cdot t}+ \\frac{1}{n} e^{1 \\cdot t}\n= 1 + \\frac{e^t - 1}{n}.\n\\end{eqnarray}\nHere $X_i$ is the random variable that represents the $i^{th}$ Bernoulli trial, $i.e.$, $X_i=1$ if $i^{th}$ entry is stored at $v$ and $X_i=0$ otherwise. Also $M(t)$ is the {\\em moment generating function of $X_i$} where $t$ is a real parameter.\n\n\nBy {(\\ref{{ChernoffBound}})}, \n$\nPr \\left(   j \\le m \\right)  \\le  e^{-tm + N \\ln M(t)}\n$\nfor the parameter \n$\nt = \\ln \\frac{mn}{N} \\le \\ln \\frac{1}{C} < 0\n$ that is particularly chosen. \nThe natural logarithm of the moment generating function is \n$\n\\ln M(t) = \\ln \\left(   1 + \\frac{\\frac{mn}{N} - 1}{n} \\right) \n$ for this $t$. We now have \n\n", "index": 29, "text": "\\begin{equation} \\label{{Eq1L5}}\n\\ln Pr \\left(   j \\le m \\right)  < - m \\ln \\frac{mn}{N} + N \\ln \\left(   1 + \\frac{\\frac{mn}{N} - 1}{n} \\right) , \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\ln Pr\\left(j\\leq m\\right)&lt;-m\\ln\\frac{mn}{N}+N\\ln\\left(1+\\frac{\\frac{mn}{N}-1}%&#10;{n}\\right),\" display=\"block\"><mrow><mi>ln</mi><mi>P</mi><mi>r</mi><mrow><mo>(</mo><mi>j</mi><mo>\u2264</mo><mi>m</mi><mo>)</mo></mrow><mo>&lt;</mo><mo>-</mo><mi>m</mi><mi>ln</mi><mfrac><mrow><mi>m</mi><mo>\u2062</mo><mi>n</mi></mrow><mi>N</mi></mfrac><mo>+</mo><mi>N</mi><mi>ln</mi><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mfrac><mrow><mi>m</mi><mo>\u2062</mo><mi>n</mi></mrow><mi>N</mi></mfrac><mo>-</mo><mn>1</mn></mrow><mi>n</mi></mfrac><mo>)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": ">$ where $d \\in S$ is its {\\em data key}. \n\n\n\n\nThe {\\em distance from $d \\in S$ to $d' \\in S$} is written as  $\\Delta \\left(   d, d' \\right) $, which is defined by the DHT design. For example, Chord measures $\\Delta \\left(   d, d' \\right) $ as $d' - d$ mod $2^m$ evaluated clockwise in the circular ring $0,1, \\ldots, 2^{m-1}$  \\cite{Chord}. Kademlia measures $\\Delta \\left(   d, d' \\right) $ by the XOR metric \\cite{Kademlia}.  For a data key $d$, we say that the node $v$ such that $\\Delta \\left(   d, key(v) \\right) $ is minimum is the {\\em successor of $d$}, and $v$ such that $\\Delta \\left(   key(v), d \\right) $ is minimum is the {\\em predecessor}. \nAn entry $<\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe show the same claim as {Lemma~\\ref{{Config1}}} with the new $\\hat{s}(m, w)$. \n\n\\newpage\n\n\\begin{lemma} \\label{Config2}\nAlgorithm {\\sc Query} on a given query $q$ having a configuration $Z=\\left\\{   z_1, z_2, \\ldots,  z_w \\right\\} $ takes no more than $\\hat{s} \\left(   m , w \\right) $ steps.\n\\end{lemma}\n\\begin{proof}\nProve by induction on $w$. The basis $w=1$ is straightforward to check. Assume true for $w-1$ and prove true for $w$. It suffices show that the number of steps required by $q$ is at most $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $ since\n\\begin{small}\n\\begin{eqnarray*}\n&& \n\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) \n\\\\ &=&\n\\left(   m + \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j \\right)  + (k-1) z_w +\n(k-1) \\left(   z_w + \\sum_{j=1}^{w-1} 2k^{w-j-1}(k-1) z_j \\right) \n{\\\\ &=&}\nm+ 2(k-1) z_w + k \\sum_{j=1}^{w-1} 2 k^{w-j-1}(k-1) z_j\n{\\\\ &=&}\nm + \\sum_{j=1}^w 2k^{w-j}(k-1) z_j\n=\\hat{s} \\left(   m, w \\right) .\n\\end{eqnarray*}\n\\end{small}\n\nTo verify it, wlog let $v$ be the node such that the letters $a_1, a_2, \\ldots, a_k$ given on the edges from $v$ correspond to the most significant wildcard in $q$. The algorithm {\\sc Query} first chooses $a_1$ as the value of the wildcard, then finds all the members of $T$ matching to $q$. This requires at most $\\hat{s} (m, w-1)$ steps by induction hypothesis. Then it backtracks to $v$ in $z_w$ steps to find all the members of $T$ that match to $q$ including $a_2$. It takes at most $z_w + \\hat{s} (z_w, w-1)$ steps.\n\n\nThe above repeats $k-1$ times for $a_2, a_3, \\ldots, a_k$. Thus the total number of traversal steps required by $q$ is upper-bounded by $\\hat{s} \\left(   m, w - 1 \\right)  + (k-1) z_w +  (k-1) \\hat{s} \\left(   z_w, w-1 \\right) $, completing the proof.\n\\qed \\end{proof}\n\n\\medskip\n\n\nThe rest of the proof is the same as for a bitwise trie. We find that the average number of steps required by $q$ is no more than\n\\begin{eqnarray*}\n&&\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2 k^{w-j}(k-1) z p_{z, j}\n=\nm + \\sum_{\\scriptstyle 1 \\le z \\le m \\atop 1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{z \\choose j} {m-z \\choose w-j}}{{m \\choose w}}\n{\\\\ &=&}\nm + \\sum_{1 \\le j \\le w} 2j k^{w-j}(k-1)  \n\\frac{{m+1 \\choose w+1}}{{m \\choose w}}\n{\\\\ &=&}\nm+ \\frac{2(m+1)}{w+1} \\cdot \\frac{k^{w+1} - (w+1) k + w}{k-1}.\n\\end{eqnarray*}\nThe bound is tight by the same argument also; for $q$ having a configuration $Z$, {\\em Query} takes $\\hat{s} \\left(   m , w \\right) $ steps exactly if $T$ is a complete $k$-ary tree. \nThis completes the proof of {Theorem~\\ref{{RadixTree}}}. \n\n\n\n\n\n\n\n\n\n\\section{Lookup Response Time with Wildcards in a Distributed Hash Table}\n\n\nIn this section, we show the same asymptotic upper bound $O \\left(   \\frac{2^w m}{w} \\right) $ for a DHT $D$. We will verify it through the structural similarity between a bitwise trie and DHT: key search by incremental bit improvement. We first define general terminology on a DHT with related facts in Section 3.1. The second subsection presents a necessary probabilistic assumption general in the aforementioned DHT class ${\\cal C}$. In Section 3.3, we show that the probability of correct lookup is $1-  2^{-\\Omega \\left(   m \\right) }$ in the DHT Chord with sufficiently many independent keys. \nThe $O \\left(   \\frac{2^w m}{w} \\right) $ bound will be proved with {Proposition~\\ref{{Main}}} in Section 3.4.\n\n\n\\subsection{Distributed Hash Table and Wildcard Query}\n\nLet $S$ be the {\\em key space} for DHT $D$. Suppose it consists of the $m$-bit binary integers so that $|S|=2^m$. A node $v$ in $D$ is labeled by a key denoted by $key(v) \\in S$. It is said to be the {\\em node key} of $v$, which is typically a large random number such as a hash of the IP address of $v$ or that of a file name. The mapping $v \\mapsto key(v)$ is an injection, $i.e.$, there is no other node $v'$ in $D$ such that $key(v')=key(v)$. Information is stored at a node as a pair $<$key, value$>$ called {\\em entry}. We denote an entry by $<\n", "index": 19, "text": "$$d, r$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"d,r\" display=\"block\"><mrow><mi>d</mi><mo>,</mo><mi>r</mi></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nObserve facts on $h$ and $d_i$. \n\n{}\n\\item At most $m$ hops are necessary to determine if $d_1 \\in D$, and $j$ hops to determine if $d_i \\in D$ for $i >1$, where $j$ is the position of the unfinished least significant wildcard in $q$ when the lookup for $d_{i-1}$ is complete. By Assumption II, this is true except for an error case occurring with probability $2^{m^{1/2+{\\epsilon}}}$ or less.\n\\item In an error case, the total number of hops is bounded by $2^w$ times a polynomial in $m$. Its contribution to $h$ is the $O \\left(   2^{-m^{\\left(   1+ {\\epsilon} \\right) /2}} \\right) $ term in {(\\ref{{eqDHT}})}. \nWe ignore it in the arguments below. \n\\item Denote by $h_i$ the number of extra hops required for $d_i$ considered in a). \nTo compare it with traversal steps in a bitwise trie $T$, let $s_i$ be the worst case number of extra steps necessary for Algorithm {\\sc Query} to determine if $d_i$ is in $T$, after the search for $d_{i-1}$ is complete. We have \n", "itemtype": "equation", "pos": 34577, "prevtext": ">$  is stored at a node chosen with the uniform probability density function, independently of the others.\n\\end{list}\nThen any lookup in $D$ is resolved with at most $m=O \\left(   \\log n \\right) $ hops and probability $1 - 2^{- \\Omega \\left(   m \\right) }$. \\qed\n\\end{theorem}\n\n\nThe theorem confirms the aforementioned bound $1 - 2^{-\\Omega \\left(   m \\right) }$. \nIn other words, the sufficient condition for a successful lookup in Chord with the probability bound is i) and ii), which assumes that there are enough entries in $D$ created by a series of mutually independent $N$ Bernoulli trials.\n\n\n\n\n\n\\subsection{Proof of the $O \\left(   \\frac{2^w \\log n}{w} \\right) $ Bound}\n\n\nWe now show our main claim. \n\n\n\\begin{theorem} \\label{DHTQueryTime}\nLet $D$ be a distributed hash table defined over the $m$-bit key space, which improves at least one bit per hop correctly with high probability, and let $q$ be a query to $D$ with uniformly random $w$ wildcards. Then the natural query protocol resolves $q$ with high probability, and with the average number of hops at most $O \\left(   \\frac{2^w m}{w} \\right) $.  \n\\end{theorem}\n\\begin{proof}\nDenote by $h$ the average number of hops, and by $d_1, d_2, \\ldots, d_{2^w}$ the $2^w$ data keys specified by $q$ in the order determined by the natural query protocol. \nWe first show\n\n", "index": 33, "text": "\\begin{equation} \\label{{eqDHT}}\nh \\le \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m + O \\left(   2^{-m^{\\left(   1+ {\\epsilon} \\right) /2}} \\right) .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"h\\leq\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m+O\\left(2^{-m^{\\left(1+{%&#10;\\epsilon}\\right)/2}}\\right).\" display=\"block\"><mrow><mrow><mi>h</mi><mo>\u2264</mo><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi><mo>+</mo><mrow><mi>O</mi><mo>\u2062</mo><mrow><mo>(</mo><msup><mn>2</mn><mrow><mo>-</mo><msup><mi>m</mi><mrow><mrow><mo>(</mo><mrow><mn>1</mn><mo>+</mo><mi>\u03f5</mi></mrow><mo>)</mo></mrow><mo>/</mo><mn>2</mn></mrow></msup></mrow></msup><mo>)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nIf $i=1$ then $h_1=s_1=m$, otherwise $h_i=j$ and $s_i=2j$ where $j$ is the same as in a). \n\n\\item Let $b$ be as given by {Proposition~\\ref{{Main}}}. It upper-bounds the average number of steps required by $q$ in $T$. Thus  \n$\n{\\mbox{\\Bb E}} \\left(   \\sum_{i=1}^{2^w} s_i \\right)  \\le b, \n$\nwhere ${\\mbox{\\Bb E}}(\\cdot)$ denotes the average of the argument random variable. \n\\end{list}\n\n\\medskip\n\nHence we have\n", "itemtype": "equation", "pos": 35720, "prevtext": "\nObserve facts on $h$ and $d_i$. \n\n{}\n\\item At most $m$ hops are necessary to determine if $d_1 \\in D$, and $j$ hops to determine if $d_i \\in D$ for $i >1$, where $j$ is the position of the unfinished least significant wildcard in $q$ when the lookup for $d_{i-1}$ is complete. By Assumption II, this is true except for an error case occurring with probability $2^{m^{1/2+{\\epsilon}}}$ or less.\n\\item In an error case, the total number of hops is bounded by $2^w$ times a polynomial in $m$. Its contribution to $h$ is the $O \\left(   2^{-m^{\\left(   1+ {\\epsilon} \\right) /2}} \\right) $ term in {(\\ref{{eqDHT}})}. \nWe ignore it in the arguments below. \n\\item Denote by $h_i$ the number of extra hops required for $d_i$ considered in a). \nTo compare it with traversal steps in a bitwise trie $T$, let $s_i$ be the worst case number of extra steps necessary for Algorithm {\\sc Query} to determine if $d_i$ is in $T$, after the search for $d_{i-1}$ is complete. We have \n", "index": 35, "text": "\n\\[\nh_i \\le s_i \\textrm{~for~} i=1,2, \\ldots, 2^w: \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"h_{i}\\leq s_{i}\\textrm{~{}for~{}}i=1,2,\\ldots,2^{w}:\" display=\"block\"><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>\u2264</mo><msub><mi>s</mi><mi>i</mi></msub><mtext>\u00a0for\u00a0</mtext><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msup><mn>2</mn><mi>w</mi></msup><mo>:</mo></mrow></math>", "type": "latex"}, {"file": "1601.04213.tex", "nexttext": "\nproving {(\\ref{{eqDHT}})}. \n\n\nIt remains show that the natural query protocol resolves $q$ with high probability. If no further bit is improved at the current peer node $v$, the protocol may decide that $d_i \\not \\in D$ or change $v$ to another with no closeness guarantee. Such an error case occurs with probability at most $2^{- m^{1/2 + {\\epsilon}}}$ by Assumption II. The total number of hops is at most $2^w$ times a polynomial in $m$, say $p(m)$.  An error case occurs at any peer node with probability no more than \n$\n2^{- m^{1/2 + {\\epsilon}}}  \\cdot 2^w p(m)\n<\n2^{- m^{\\left(   1+ {\\epsilon} \\right) /2}}.\n$\nTherefore, the protocol returns the correct answer to $q$ with probability at least $1-2^{- m^{(1+{\\epsilon})/2}}$, a high probability. The theorem follows this statement. \n\\qed\\end{proof}\n\n\nAs stated in Section 3.1, we assume $m = O \\left(   \\log n \\right) $ in a DHT, so the theorem means $h= O \\left(   \\frac{2^w \\log n }{w} \\right) $ as desired. \nThe bound is applicable to Chord, Pastry, Tapestry and Kademlia since they satisfy Assumption II. \n\n\nWe note that the bound could also improve the performance of $2^w$ independent lookups in Koorde \\cite{Koorde}: Koorde is a variant of Chord with the use of De Bruijin graph, achieving $O \\left(   \\log n \\big/ \\log \\log n \\right) $ hops per lookup with $O \\left(   \\log n \\right) $ routing table size. If $2^w$ lookups run independently in Koorde, its number of hops is $O \\left(   \\frac{2^w \\log n }{\\log \\log n} \\right) $ whose argument is greater than  $O \\left(   \\frac{2^w \\log n }{w} \\right) $ when $w$ is sufficiently larger than $\\log \\log n$. \n\n\n\n\n\n\\section{Concluding Remarks and Open Problems}\n\n\nWe have shown the bound $O \\left(   \\frac{2^w m}{w}  \\right) $ for both bitwise tries and distributed hash tables in ${\\cal C}$, and $O \\left(   \\frac{k^w m}{w}  \\right) $ for a general trie of maximum out-degree $k$. They limit the asymptotic running time required by a partial-match query of length $m$ with $w$ uniformly random wildcards. We also confirmed the probability $1 - 2^{-\\Omega \\left(   m \\right) }$ of correct lookup in Chord under the natural assumption. \n\n\n\nThere are some practical cases to which the obtained results can be applied with the assumption of uniform wildcard occurrences. One such case is data retrieval: Suppose that one searches for data records with $m$ attributes, managed as a trie $T$ such that each attribute takes at most $k$ values. \nAn example of such a data record is of form {\\tt <college, department, building, title, last name, first name>}. The $m=6$ attributes are hierarchical but with the independent equal probability $\\frac{1}{m}$ to be a wildcard in a query. The trie $T$ organizing such data records could be an auxiliary data structure to enhance the search speed. In this situation, wildcards included in a query $q$ occur randomly with the uniform PDF. By {Theorem~\\ref{{RadixTree}}}, $q$ takes average $O \\left(   \\frac{k^w m}{w} \\right) $ steps rather than $k^w m$. \n\n\nFurther research on this problem could consider query protocols to resolve $q$ with non-uniform probability distributions of wildcard occurrence. It is possible that such a protocol runs at multiple peer nodes simultaneously. It would be interesting to investigate its lookup efficiency. \n\n\n\n\n\n\n\n\n\n\\section*{Acknowledgements}\n\nThe author is especially thankful to Yan Shvartzshnaider and Max Ott for introducing him to this problem. Also the author would like to thank Professor Hisashi Kobayashi at Princeton University, and Processors Martin F\\\"urer and Piotr Berman at Penn State for their helpful suggestions.\n\n\n\n\\begin{thebibliography}{20}\n\n\\bibitem{Textbook} Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C.: Introduction to Algorithms, Third Edition. MIT Press (2009).\n\n\\bibitem{R76} Rivest, R.L.: Parttial-match retrieval algorithms. SIAM Journal on Computing, vol. 5, pp. 15-50 (1976). \n\n\t\n\\bibitem{CIP02} Charikar, M., Indyk, P., Panigrahy, R.: New Algorithms for Subset Query, Partial Match, Orthogonal Range Searching, and Related Problems. LNCS, vol.\\ 2380, pp.\\ 451--463, Springer, Heidelberg (2002)\n\n\n\\bibitem{Sedgewick} Sedgewick, R., Wayne, K.: Algorithms (4th edn.). Addison-Wesley (2011).\n\n\n\\bibitem{Knuth} Knuth, D.E.: The art of computer programming, volume 3. Addison-Wesley (1997).\n\n\n\n\\bibitem{DMap}  Vu, T., Baid, A., Zhang, Y., Nguyen, T. D., Fukuyama, J., Martin, R. P., Raychaudhuri, D.: DMap: A shared hosting scheme for\ndynamic identifier to locator mappings\nin the global internet. In: Proc. of the 32nd International Conference on Distributed Computing Systems (ICDCS12). IEEE, pp. 698--707 (2012).\n\n\n\\bibitem {DHTAnalysis} Xu, J., Kumar, A., Yu, X.: On the fundamental tradeoffs between routing table size and network diameter in peer-to-peer networks. IEEE Journal on Selected Areas in Communications, vol. 22, pp. 151--163 (2004).\n\n\n\n\\bibitem{hyper} Rosenkrantz, W. A.: Introduction to probability and statistics for science, engineering, and finance. Chapman and Hall (2009).\n\n\n\n\\bibitem{ConcreteMath} Graham, R. L., Knuth, D. E., Patashnik, O.: Concrete mathematics. Addison-Wesley (1994).\n\n\\bibitem{Chord}\nStoica, I., Morris, R., Karger, D., Kaashoek, M. F., Balakrishnan, H.: Chord: a scalable peer-to-peer lookup service for internet applications. In: Proc. of the SIGCOMM 2001 Conference (SIGCOMM01). ACM, vol.\\ 31, pp.\\ 149--160, New York (2001).\n\n\n\\bibitem{Pastry} Rowstron, A., Druschel, P.: Pastry: scalable, decentralized object location and routing for large-scale peer-to-peer systems. In: Proc. of IFIP/ACM International Conference on Distributed Systems Platforms (Middleware). LNCS, vol. 2218, pp.\\ 329--350. Springer, Heidelberg (2001).\n\n\n\n\\bibitem{Tapestry} Zhao, B.Y., Huang, L., Stribling, J., Rhea, S.C., Joseph, A.D., Kubiatowicz, J.D.: Tapestry: a resilient global-scale overlay for service deployment. IEEE Journal on Selected Areas in Communications vol. 22, pp. 41--53 (2004).\n\n\n\\bibitem{Kademlia} Maymounkov, P., Mazi`eres, D.: Kademlia: a peer-to-peer information system based on the XOR metric. In: Proc. of the 1st International Workshop on Peer-to Peer Systems (IPTPS02). LNCS, vol.\\ 2429, pp. 53--65. Springer, Heidelberg (2002).\n\n\n\n\\bibitem{KnuthBook} Graham, R. L., Knuth, D. E., Patashnik, O.:   Concrete mathematics: a foundation for computer science (2nd edn.).\nAddison-Wesley (1994). \n\n\n\\bibitem{Kobayashi} Kobayashi, H., Mark, L.M., Turin, W.: Probability, random processes, and statistical analysis: applications to communications, signal processing, queueing theory and mathematical finance. Cambridge University Press (2012).\n \n\n\n\\bibitem{Koorde}\nKaashoek, M.F., Karger, D.R.: \nKoorde: a simple degree-optimal distributed hash table. In: Proc. \nof the 2nd International Workshop on Peer-to-Peer Systems (IPTPS '03). LNCS, vol.\\ 2735, pp.\\ 98--107. Springer, Heidelberg (2003).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\end{thebibliography}\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 36184, "prevtext": "\nIf $i=1$ then $h_1=s_1=m$, otherwise $h_i=j$ and $s_i=2j$ where $j$ is the same as in a). \n\n\\item Let $b$ be as given by {Proposition~\\ref{{Main}}}. It upper-bounds the average number of steps required by $q$ in $T$. Thus  \n$\n{\\mbox{\\Bb E}} \\left(   \\sum_{i=1}^{2^w} s_i \\right)  \\le b, \n$\nwhere ${\\mbox{\\Bb E}}(\\cdot)$ denotes the average of the argument random variable. \n\\end{list}\n\n\\medskip\n\nHence we have\n", "index": 37, "text": "\n\\[\nh = {\\mbox{\\Bb E}} \\left(   \\sum_{i=1}^{2^w} h_i \\right)  \\le {\\mbox{\\Bb E}} \\left(   \\sum_{i=1}^{2^w} s_i \\right)  \n\\le b \n= \\frac{m+1}{w+1} \\left(   2^{w+2} - 2 w - 4 \\right)   + m, \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"h={\\mbox{\\Bb E}}\\left(\\sum_{i=1}^{2^{w}}h_{i}\\right)\\leq{\\mbox{\\Bb E}}\\left(%&#10;\\sum_{i=1}^{2^{w}}s_{i}\\right)\\leq b=\\frac{m+1}{w+1}\\left(2^{w+2}-2w-4\\right)+m,\" display=\"block\"><mrow><mrow><mi>h</mi><mo>=</mo><mrow><mrow><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\Bb</span></mtext><mtext>E</mtext></mrow><mo>\u2062</mo><mrow><mo>(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msup><mn>2</mn><mi>w</mi></msup></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow><mo>\u2264</mo><mrow><mrow><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\Bb</span></mtext><mtext>E</mtext></mrow><mo>\u2062</mo><mrow><mo>(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msup><mn>2</mn><mi>w</mi></msup></munderover><msub><mi>s</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow><mo>\u2264</mo><mi>b</mi><mo>=</mo><mrow><mrow><mfrac><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>w</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>\u2062</mo><mrow><mo>(</mo><mrow><msup><mn>2</mn><mrow><mi>w</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>w</mi></mrow><mo>-</mo><mn>4</mn></mrow><mo>)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]