[{"file": "1601.07409.tex", "nexttext": "\nis more readable than\n\n", "itemtype": "equation", "pos": 29548, "prevtext": "\n\n\\title{Multi-Objective\nReasoning \nwith Constrained Goal Models\n\\thanks{This research was partially supported by the ERC advanced grant\n267856, `Lucretius: Foundations for Software Evolution'. Roberto Sebastiani is also supported in part by\n{Semiconductor Research Corporation} (SRC)\n  under\nGRC Research Project 2012-TJ-2266 WOLF.\n}\n}\n\n\n\n\n\n\\author{Chi Mai Nguyen \\and\nRoberto Sebastiani \\and\n\\\\Paolo Giorgini \\and\nJohn Mylopoulos \n}\n\n\n\n\\institute{\nDISI, University of Trento\n\n\n\n\n\n\n\n\n\n }\n\n\\date{}\n\n\n\n\\maketitle\n\n\\begin{abstract}\n Goal models have been widely used in Computer Science to \nrepresent software requirements, business objectives, and \ndesign qualities. Existing goal modeling techniques, however, \nhave shown limitations of expressiveness and/or tractability \nin coping with complex real-world problems. In this work, we \nexploit advances in automated reasoning technologies, \nnotably Satisfiability and Optimization Modulo Theories (SMT/OMT), \nand we propose and formalize: \n(i) an extended notion of goal model, namely \n{\\em {Constrained Goal Model (CGM)}}, which makes \nexplicit the notion of {\\em {goal refinement}} {and of\n{\\em {domain assumption}}}, \n{allows for expressing {\\em {preferences}}\n between goals and refinements,} and\nallows \nfor associating {\\em {numerical attributes}} to goals and refinements for \ndefining \n{\\em {constraints}} and multiple {\\em {objective functions}} over goals,\nrefinements and their numerical attributes;\n(ii) a novel set of automated reasoning functionalities over CGMs, \nallowing for automatically generating suitable refinements of input \nCGMs, under user-specified assumptions and constraints, that also \n{maximize preferences and}\noptimize given objective functions. \n\n\nWe have implemented \nthese modeling and reasoning functionalities in a tool, \n{named CGM-Tool},\nusing the OMT solver OptiMathSAT \nas automated reasoning backend.\n\n{An empirical evaluation on large CGMs supports the}\n{claim that our proposal scales well for goal models capturing real-world problems.}\n\n\\keywords{Goal models \\and Goal-oriented requirements engineering \\and Conceptual modelling}\n\n\\end{abstract}\n\n\\remark{\"Under journal submission.\"}\n\n\n\n\\section{Introduction}\n\\label{sec:intro}\nThe concept of goal has long been used as useful abstraction \nin many areas of computer science,  for example \nartificial intelligence planning\n{~\\cite{newell63}}, agent-based systems\n{~\\cite{BDIAgents95}}, and  knowledge management\n{~\\cite{Jarvis01}}. More recently, software engineering has also \nbeen using goals to model requirements for software systems, \nbusiness objectives for enterprises, and design qualities\n{~\\cite{anton96,anton98,dardenne93,Lamsweerde01,Giorgini04formalreasoning}.}\n\n\nGoal-oriented requirements engineering approaches have gained \npopularity in the last two decades for a number of significant \nbenefits in conceptualizing and analyzing requirements\n~\\cite{Lamsweerde01}.  Goal models provide a broader system engineering \nperspective compared to traditional requirements engineering methods, \na precise criterion for completeness of the requirements analysis process, \nand rationale for requirements specification, \nas well as automated support for early requirements analysis.\nMoreover, goal models are useful in explaining requirements to stakeholders, \nand goal refinements offer an accessible level of abstraction for \nvalidating choices among alternative designs.\n\nCurrent goal modeling and reasoning techniques, however, have\nlimitations in coping with complex real-world problems, as recently\nhighlighted by Horkoff and Yu in~\\cite{HorkoffY13}.  Leading\napproaches such as KAOS ~\\cite{dardenne93} and $i^*$~\\cite{Yu97} are\nlimited in expressing stakeholder preferences, but also in supporting\nscalable reasoning over goal models. Although, more recent approaches, such as\nTechne ~\\cite{JuretaBEM10,Liaskos10}, propose expressive\nextensions to goal models, they still lack of scalable reasoning facilities.\n\nAs an answer to the need for more expressiveness and more\nsophisticated reasoning support, we exploit advances in\nautomated reasoning technologies,\nnotably {\\em Satisfiability Modulo Theories (SMT)}~\\cite{barrettsst09} and \n{\\em Optimization Modulo Theories\n  (OMT)}~\\cite{sebastiani15_optimathsat}, to propose and formalize\nan extended notion of goal model, \nnamely {\\em {Constrained Goal Model (CGM)}}.  \n\n\nCGMs advance the state-of-the-art for goal modeling and reasoning in several ways:\n\n\\begin{enumerate}[(i)]\n\\item\nAllow for explicit labelling of {\\em {goal refinements}} with Boolean propositions that can be\n  interactively/automatically reasoned upon; \n\n\\item\nProvide an explicit representation of {\\em {domain assumptions}} to represent\n  preconditions to goals;\n\n\\item\nAllow for  {\\em {Boolean constraints}} over goals, domain assumptions\nand refinements;\n\n\n\n\\item\nProvide a representation of {\\em {preferences}} over goals and their\nrefinements,\n by distinguishing between mandatory and nice-to-have\nrequirements and by assigning preference {\\em {weights}} \n(i.e., penalties/rewards) \nto goals and domain assumptions. \n\n{\nAlternatively, preferences can be expressed  explicitly  by\nsetting {\\em {binary preference relations}} between pairs of goals or pairs of refinements;}\n\n\n\\item\nAssign {\\em {numerical attributes}} (e.g., resources like \ncost, worktime, and room) to goals and/or refinements and define\n{\\em {constraints}} and multiple {\\em {objective functions}} over goals,\nrefinements and their numerical attributes.\n\n\n\n\\end{enumerate}\n  \n\n\\noindent\nA realization of a CGM represents one of the alternative ways of\nrefining the mandatory requirements (plus possibly some of the \nnice-to-have ones) in compliance with the user-defined constraints.\n\n\\noindent\nTaking advantage of CGMs' formal semantics and\nthe expressiveness and efficiency of current SMT\n and OMT solvers, we also provide a set of automated\nreasoning functionalities on CGMs. Particularly, on a given CGM, our\napproach allows for: \n\n\\begin{itemize}\n\\item[(a)] the automatic check of the CGM's realizability; \n\\item[(b)] the interactive/automatic search for realizations; \n\\item[(c)] the automatic search for the ``best\" realization in terms\nof penalties/rewards {and/or of user-defined preferences;}\n\\item[(d)] the automatic search for the  realization(s) which optimize \ngiven objective functions.\n \n\\end{itemize}\n\n\nOur approach is\nimplemented as a tool (CGM-Tool), a standalone java\napplication based on the Eclipse RCP engine. The tool offers\nfunctionalities to create CGM models as graphical diagrams and to\nexplore alternatives scenarios running automated reasoning\ntechniques. CGM-Tool uses the SMT/OMT solver OptiMathSAT\n~{\\cite{sebastiani15_optimathsat,st_tacas15,st_cav15},\n  which is built on top of the SMT solver {\\textsc{MathSAT5}\\xspace} \\cite{mathsat5_tacas13},}\nas automated reasoning backend.~\\footnote{{The OMT solver OptiMathSAT\n  can be used also as an SMT solver if no objective function is set: in\n  such case it works as a wrapper of {\\textsc{MathSAT5}\\xspace}.}} \n\nThe structure of the paper is as follows: \n\n{\\S{}\\ref{{sec:background}}} provides the necessary background  on goal\nmodeling and on SMT/OMT;\n\n{\\S{}\\ref{{sec:goalmodels_example}}} introduces the notion of CGM\nthrough an example;\n\n{\\S{}\\ref{{sec:goalmodels}}} introduces the syntax and semantics of CGMs;\n\n{\\S{}\\ref{{sec:functionalities}}} presents the set of automated reasoning functionalities for CGMs;\n\n{\\S{}\\ref{{sec:implementation}}} gives a quick overview of our tool\nbased on the presented approach;\n\n{{\\S{}\\ref{{sec:expeval}}} provides an experimental evaluation of the\nperformances of our tool on large CGMs, showing that the\napproach scales well with respect to CGM size;}\n\n{\\S{}\\ref{{sec:related}}} gives overview of related work,\nwhile in {\\S{}\\ref{{sec:concl}}} we draw conclusions and present future\nresearch challenges.\n\n\n\n\n\n\n\\section{Background}\n\\label{sec:background}\n\nOur research baseline consists of our previous work on qualitative\ngoal models and of Satisfiability and Optimization Modulo Theories (SMT\nand OMT respectively). \n{Our aim in this section is to introduce the necessary \nbackground notions on the these topics, so that the reader can follow the\nnarrative in subsequent sections.}\n\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Goal Models.}}}}}\n\\label{sec:background_goalmodels}\nQualitative goal models are introduced in~\\cite{Mylopoulos92}, where the concept of goal \nis used to represent respectively a functional and non-functional requirement in terms of a\nproposition. A goal can be refined by means of AND/OR refinement relationships and\nqualitative evidence (strong and weak) for/against the fulfillment of a goal is provided by\ncontribution links labelled $+, -$ etc. In~\\cite{Giorgini04formalreasoning}, goal models are formalized by replacing\neach proposition $g$, standing for a goal, by four propositions ($FS_g$, $PS_g$, $PD_g$, $FD_g$) \nrepresenting full (and partial) evidence for the satisfaction/denial of $g$. A traditional\nimplication such as $(p \\wedge q) \\rightarrow r$ is then translated into a series of implications connecting\nthese new symbols, including $(FS_p \\wedge FS_q) \\rightarrow FS_r$, $(PS_p \\wedge PS_q) \\rightarrow\nPS_r$, as well as $FD_p \\rightarrow FD_r$, $FD_q \\rightarrow FD_r$, etc. The conflict between goals $a$ and $b$ is captured by axioms of the form $FS_a\\rightarrow FD_b$, and it is consistent to have both $FS_a$ and $FD_a$\nevaluated to true at the same time. As a result, even though the semantics of a goal model is a classical propositional theory, inconsistency does not result in everything being true. In fact, a predicate $g$ can be assigned a subset of truth values $\\{FS, PS,\nFD, PD\\}$.   \n\n~\\cite{sebastiani_caise04} extended the approach further by including axioms\nfor avoiding conflicts of the form $FS_a \\wedge FD_a$. The approach\nrecognized the need to formalize goal models so as to automatically\nevaluate the satisfiability of goals. These goal models, however, do not incorporate the notion of conflict as inconsistency, they do not include concepts other than goals, cannot distinguish \"nice-to-have\" from mandatory requirements and have no notion of a robust\nsolution, i.e. solution without \"conflict\", where a goal can not be\n(fully or partially) denied and (respectively, fully or partially) satisfied at the same\ntime. \n\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Satisfiability and Optimization Modulo Theories.}}}}}\n{\\em {Satisfiability Modulo Theories (SMT)}} is the problem of deciding\nthe satisfiability of a quantifier-free first-order\nformula $\\Phi$ with respect to some decidable theory {\\ensuremath{\\mathcal{T}}\\xspace} (see\n\\cite{sebastiani07,barrettsst09}).\n\n\nIn this paper, we focus on the theory of {\\em {linear arithmetic over the rationals, {\\ensuremath{\\mathcal{LRA}}\\xspace}}}: {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} is the problem of checking the\nsatisfiability of a formula $\\Phi$ consisting in atomic propositions\n$A_1,A_2,...$ and linear-arithmetic constraints like ``$(2.1 x_1 -3.4\nx_2 + 3.2 x_3 \\le 4.2)$'', combined by means of Boolean operators\n$\\neg,\\wedge,\\vee,\\ensuremath{\\rightarrow}\\xspace,\\ensuremath{\\leftrightarrow}\\xspace$.\n\nTo this extent, an {\\em {{\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation}} $\\mu$ is a function\n  which assigns truth values to Boolean atoms and rational values to\n  numerical variables; $\\mu$ {\\em {satisfies}} $\\Phi$ in {\\ensuremath{\\mathcal{LRA}}\\xspace}{},\nwritten\n  ``$\\mu\\models\\Phi$'' --aka, $\\mu$\n  is a {\\em {solution}} for $\\Phi$ in {\\ensuremath{\\mathcal{LRA}}\\xspace}--  iff $\\mu$ makes the formula $\\Phi$ evaluate to\n  true; $\\Phi$ is {\\ensuremath{\\mathcal{LRA}}\\xspace}-satisfiable iff it has at least one\n  {\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation $\\mu$ s.t. $\\mu\\models\\Phi$.\n \n\n\n\nAn {\\em {Optimization Modulo Theories over {\\ensuremath{\\mathcal{LRA}}\\xspace} ({\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace})}} problem {\\ensuremath{\\langle{{\\Phi,{\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace}}}\\rangle}\\xspace} is the problem of finding\nsolution(s) to an {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} formula $\\Phi$ which optimize the\n rational-valued objective functions $obj_1,...,obj_k$, either\n singularly or lexicographically \n{\\cite{nieuwenhuis_sat06,st-ijcar12,sebastiani15_optimathsat,st_tacas15}}\n).~\n\\footnote{{A solution optimizes lexicographically\n{\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace} if it optimizes $obj_1$ and, if more than \none such $obj_1$-optimal solutions exists, it also optimizes $obj_2$,..., and so on.}}\n\n\nVery efficient {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} and {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} solvers are available, \nwhich combine the power of modern SAT\nsolvers with dedicated linear-programming decision and minimization\nprocedures (see\n{\\cite{sebastiani07,barrettsst09,mathsat5_tacas13,nieuwenhuis_sat06,st-ijcar12,sebastiani15_optimathsat,st_tacas15,st_cav15}}\n).\n\nFor instance, in the empirical evaluation reported in\n  \\cite{sebastiani15_optimathsat}\n the {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} solver OptiMathSAT \\cite{sebastiani15_optimathsat,st_cav15} was able to\nhandle optimization problems with up to thousands Boolean/rational\nvariables  in less than 10 minutes each.\n\n\n\n\\label{sec:background_sat}\n\n\n\n\\section{Constrained Goal Models}\n\\label{sec:goalmodels_example}\n\n\nWe introduce the main ideas of CGMs and the main functionalities of\nthe CGM-Tool through a meeting scheduling example (Figure~\\ref{figGMEx}), \nwhere we model the requirements for a meeting scheduling system, including\nthe functional requirement {\\ensuremath{\\mathsf{{Schedule\\-Meeting}}}}, \nas well as non-functional/quality requirements {\\ensuremath{\\mathsf{{Low\\-Cost}}}},  ~{\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}, \n{\\ensuremath{\\mathsf{{Minimal\\-Effort}}}} and {\\ensuremath{\\mathsf{{Good\\-Quality\\-Schedule}}}}. \nThey are represented as root goals.\n\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Goals, Refinements, and Domain Assumptions.}}}}}\n\nNotationally, round-corner rectangles (e.g., {\\ensuremath{\\mathsf{{Schedule\\-Meeting}}}})\nare root goals, representing stakeholder {\\em {requirements}}; \n\novals (e.g. {\\ensuremath{\\mathsf{{Collect\\-Timetables}}}})\nare {\\em {intermediate goals}};\n\n{\\em {hexagons}} (e.g. {\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}})\nare {\\em {tasks}}, i.e.  non-root leaf goals;\n\nrectangles (e.g., {\\ensuremath{\\mathsf{{Participants\\-Use\\-System\\-Calendar}}}}) are\n{\\em {domain assumptions}}. \n\nWe call {\\em {elements}} both goals and domain assumptions.\n\nLabeled bullets at the merging point of the edges \nconnecting a group of source elements to a\ntarget element   are {\\em {refinements}}\n(e.g., \n~{\\ensuremath{ {({\\ensuremath{\\mathsf{{Good\\-Participation}}}},{\\ensuremath{\\mathsf{{Minimal\\-Conflict}}}})} \\xrightarrow{R_{{20}}} { {\\ensuremath{\\mathsf{{Good Quality     Schedule}}}}}}}), while the $R_i$s denote\ntheir labels.~\n{The label of a refinement can be omitted when\n  there is no need to refer to it explicitly.}\n \n\n\nIntuitively, requirements represent desired states of affairs we want the system-to-be\nto achieve (either mandatorily or possibly); they are progressively\nrefined into intermediate goals, until the process produces actionable\ngoals (tasks) that need no further decomposition and can be executed;\ndomain assumptions are propositions about the domain that need to hold for a goal refinement to work.  {Refinements} are used to represent the alternatives of\nhow to achieve an element; a refinement of an element is a conjunction\nof the sub-elements that are necessary to achieve it.\n\n\nThe main objective of the CGM in Figure~\\ref{figGMEx}\nis to achieve the requirement {\\ensuremath{\\mathsf{{Schedule\\-Meeting}}}}, \nwhich is  {\\em {mandatory}}. \n\n{\\ensuremath{\\mathsf{{Schedule\\-Meeting}}}} has only one candidate refinement $R_1$, \nconsisting in five sub-goals: {\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}}, {\\ensuremath{\\mathsf{{Collect\\-Timetables}}}}, \n{\\ensuremath{\\mathsf{{Find\\-A\\-Suitable\\-Room}}}}, {\\ensuremath{\\mathsf{{Choose\\-Schedule}}}}, and\n~{\\ensuremath{\\mathsf{{Manage\\-Meeting}}}}. Since $R_1$ is the only refinement of the\nrequirement, all these sub-goals must be satisfied in order to\nsatisfy it. \n\nThere may be more than one way to refine an element;\ne.g., {\\ensuremath{\\mathsf{{Collect\\-Timetables}}}} is further refined either by\n$R_{10}$ into the single goal {\\ensuremath{\\mathsf{{By\\-Person}}}} or by \n$R_{2}$ into the single goal {\\ensuremath{\\mathsf{{By\\-System}}}}.\n{Similarly, {\\ensuremath{\\mathsf{{Find\\-A\\-Suitable\\-Room}}}} and \n{\\ensuremath{\\mathsf{{Choose\\-Schedule}}}} have three and two possible refinements respectively.}\n\nThe subgoals are further refined until they\nreach the level of  domain assumptions and tasks.\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{User Assertions.}}}}}\nSome requirements  \ncan be {``{\\em {nice-to-have}}''}, \nlike \n{\\ensuremath{\\mathsf{{Low\\-Cost}}}}, {\\ensuremath{\\mathsf{{Minimal\\-Effort}}}}, {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}, and\n{\\ensuremath{\\mathsf{{Good\\-Quality\\-Schedule}}}} (in blue in  Figure~\\ref{figGMEx}).\nThey are requirements that we would like to fulfill with our solution,\n provided they do not conflict with other requirements.\nTo this extent, in order to analyze interactively the \npossible different realizations, one can interactively mark [or unmark] \nrequirements as satisfied, thus making them mandatory \n(if unmarked, they are nice-to-have ones). Similarly, \none can interactively mark/unmark (effortful) tasks as denied,\nor mark/unmark some domain assumption as satisfied or denied.\nMore generally, one can mark as satisfied or denied every goal or domain assumption.\nWe call these marks {\\em {user assertions}}.\n\n\n\n\\begin{figure*}\n\\centering \n\\includegraphics[height=0.95\\textheight, width=\\textwidth]{GoalModelEx_1.pdf}\n\\caption{{An example of a CGM with one of its realizations.}}\n\\label{figGMEx}\n\\end{figure*}\n\n\\begin{figure*}\n\\centering \n\\includegraphics[height=0.95\\textheight, width=\\textwidth]{GoalModelOptimumRealization.pdf}\n\\caption{{Realization of a CGM minimizing {\\ensuremath{\\mathsf{{Weight}}}}.}}\n\\label{figCGMRelization}\n\\end{figure*}\n\n\\begin{figure*}\n\\centering \n\\includegraphics[height=0.95\\textheight, width=\\textwidth]{GoalModelLexRealization.pdf}\n\\caption{{Realization of a CGM minimizing lexicographically\n  {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}}, {\\ensuremath{\\mathsf{{workTime}}}}, {\\ensuremath{\\mathsf{{cost}}}}}}\\rangle}\\xspace}, or minimizing\nlexicographically {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}},{\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{}}}\\rangle}\\xspace}.\n}}\n\\label{figCGMLex}\n\\end{figure*}\n\n\n\nImportantly, in a CGM, elements and refinements are enriched by user-defined\n{\\em {constraints}}, which can be expressed either graphically \nas  {\\em {relation edges}} or textually as {\\em {Boolean or {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} formulas}}.\n\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Relation Edges.}}}}}\nWe have three kinds of relation edges.\n\n{\\em {Contribution edges}} ``{\\ensuremath{ {E_i} \\xrightarrow{++} {E_j}}}'' between elements  (in green in Figure~\\ref{figGMEx}),\nlike ``{\\ensuremath{ {{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}}} \\xrightarrow{++} {{\\ensuremath{\\mathsf{{Minimal\\-Conflicts}}}}}}}'', \nmean that if the source element $E_i$ is satisfied, then \nalso the target element $E_j$ must be satisfied (but not vice versa). \n\n{\\em {Conflict edges}} ``{\\ensuremath{ {E_i} \\overset{--}{\\longleftrightarrow} {E_j}}}'' between elements (in red), like \n``{\\ensuremath{ {{\\ensuremath{\\mathsf{{Confirm\\-Occurrence}}}}} \\overset{--}{\\longleftrightarrow} {{\\ensuremath{\\mathsf{{Cancel\\-Meeting}}}}}}}'',\nmean that $E_i$ and $E_j$ cannot be both satisfied. \n\n{\\em {Refinement bindings}} ``{\\ensuremath{ {R_i}{\\longleftrightarrow} {R_j}}}'' between two refinements\n(in purple), like ``{\\ensuremath{ {R_2}{\\longleftrightarrow} {R_7}}}'', are used to state that, if the  target\nelements $E_i$ and $E_j$ of the two refinements $R_i$ and $R_j$,\nrespectively, are both\nsatisfied, then $E_i$ is refined by $R_i$ if and only if $E_j$ is\nrefined by $R_j$. Intuitively, this means that the two refinements are\nbound, as if they were two different instances of the same choice.\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Boolean Constraints.}}}}}\n\nIt is possible to enrich CGMs with logic formulas, representing\narbitrary logic \nconstraints on elements and refinements.\n\nSuch constraints can be {\\em {global}} or {\\em {local}} to elements and\nrefinements, that is, each goal ${{G}}$ can be tagged with   a pair \nof {\\em {prerequisite}} formulas ${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$, so that \n ${{\\phi}^{+}_{{G}}}$ [resp. ${{\\phi}^{-}_{{G}}}$] must be\n satisfied  when  ${{G}}$ is\nsatisfied [resp. denied].\n(The same holds for each requirement $R$.)\n\n\nFor example, to require that, as a prerequisite for {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Manually}}}} and {\\ensuremath{\\mathsf{{Call\\-Participants}}}} cannot be both satisfied, \none can add a constraint to the positive \nprerequisite formula of {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}:\n\\begin{eqnarray}\n\\label{eq:lowtimelocal}\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}}}} {\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\n&& ... \n\\wedge \\neg ({\\ensuremath{\\mathsf{{Schedule\\-Manually}}}} \\wedge {\\ensuremath{\\mathsf{{Call\\-Participants}}}}),\n\\end{eqnarray}\n\nor, equivalently, add globally to the CGM the following\nBoolean formula: \n\n\\begin{eqnarray}\n\\label{eq:lowtimeglobal}\n{\\ensuremath{\\mathsf{{Fast\\-Schedule}}}} & \\rightarrow & \\neg ({\\ensuremath{\\mathsf{{Schedule\\-Manually}}}} \\wedge {\\ensuremath{\\mathsf{{Call\\-Participants}}}}).\n\\end{eqnarray}\n\n\\noindent\nNotice that there is no way we can express \\eqref{eq:lowtimelocal}\nor \\eqref{eq:lowtimeglobal} with the relation edges above.\n\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Realizations of a CGM.}}}}}\n\n\n\nWe suppose now that {\\ensuremath{\\mathsf{{Schedule\\-Meeting}}}} is marked satisfied\n(i.e. it is mandatory) and that no other element is marked.\n\nThen the CGM in Figure~\\ref{figGMEx} has more than 20 possible\n{\\em {realizations}}. The sub-graph which is \nhighlighted in yellow describes one of them. \n\nIntuitively, a realization of a CGM under given user assertions (if\nany) represents one of the alternative ways of refining the mandatory\nrequirements (plus possibly some of the nice-to-have ones) in compliance\nwith the user assertions and user-defined constraints.  It is a\nsub-graph of the CGM including a set of satisfied elements and\nrefinements: it includes all mandatory requirements, and\n[resp. does not include] all elements satisfied [resp. denied] in the\nuser assertions; for each non-leaf element included, at least one of\nits refinement is included; for each refinement included, all its\ntarget elements are included; finally, a realization complies with all\nrelation edges and with all Boolean and {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} constraints (see\nlater).\n\n\n\nApart from the mandatory requirement, \nthe realization in Figure~\\ref{figGMEx} allows to achieve \nalso the nice-to-have requirements {\\ensuremath{\\mathsf{{Low\\-Cost}}}},\n{\\ensuremath{\\mathsf{{Good\\-Quality\\-Schedule}}}}, but not {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}} and {\\ensuremath{\\mathsf{{Minimal\\-Effort}}}};\nit  requires accomplishing the tasks \n{\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}}, \n{\\ensuremath{\\mathsf{{Call\\-Participants}}}},\n{\\ensuremath{\\mathsf{{List\\-Available\\-Rooms}}}},\n{\\ensuremath{\\mathsf{{Use\\-Available\\-Room}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Manually}}}}, \n{\\ensuremath{\\mathsf{{Confirm\\-Occurrence}}}}, \n{\\ensuremath{\\mathsf{{Good\\-Participation}}}}, {\\ensuremath{\\mathsf{{Minimal\\-Conflicts}}}},\nand requires  the domain assumption \n{\\ensuremath{\\mathsf{{Local\\-Room\\-Available}}}}. \n\n\n\\smallskip\nIn general, a CGM under given user assertions\nhas many possible realizations. To distinguish among them, \nstakeholders may want to express {\\em {preferences}} on the requirements\n to achieve, on the tasks to accomplish, and on \nelements and refinements to choose. The CGM-Tool \nprovides various methods to express preferences:\n\\begin{itemize}\n\\item attribute {\\em penalties and rewards} for tasks and requirements;\n\\item introduce {\\em numerical attributes}, \n  {\\em constraints}  and  {\\em objectives};\n\\item introduce {\\em binary preference relations} between elements\n  and between refinements.\n\\end{itemize}\nThese methods, which are described in what follows, can also be combined. \n\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Penalties/Rewards.}}}}}\nFirst, stakeholders\ncan assign {\\em {positive weights}} ({\\em {penalties}}) to tasks\nand {\\em {negative weights}} ({\\em {rewards}}) to (non-mandatory)\nrequirements (the numbers ``${\\ensuremath{\\mathsf{{Weight}}}} = \\ldots$'' in Figure~\\ref{figGMEx}).\nThis implies that requirements [resp. tasks] with higher rewards\n[resp. smaller penalties] are preferable.\n When a model represents preferences, an OMT solver will look for a realization that \n minimizes its global weight, that is, \n the total difference between the penalties and rewards. \n\nFor instance, one minimum-weight realization of the example CGM, as shown in Figure~\\ref{figCGMRelization},\nachieves all the nice-to-have requirements except {\\ensuremath{\\mathsf{{Minimal\\-Effort}}}},\nwith a total weight of $-65$, {which is the minimum which can be\nachieved with this CGM.}\n\nSuch realization requires accomplishing the tasks\n{\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}},\n{\\ensuremath{\\mathsf{{Email\\-Participants}}}},\n{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institution}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Manually}}}}, \n{\\ensuremath{\\mathsf{{Confirm\\-Occurrence}}}},\n{\\ensuremath{\\mathsf{{Good\\-Participation}}}}, and\n{\\ensuremath{\\mathsf{{Minimal\\-Conflicts}}}},\nand requires no domain assumption.\n(This was found automatically by our CGM-Tool of {\\S{}\\ref{{sec:implementation}}}\n\nin $0.008$ seconds on an Apple MacBook Air laptop.)\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Numerical Attributes.}}}}}\nIn addition to Boolean constraints and penalties/rewards, \nit is also possible to use numerical variables to \nexpress different numerical attributes of elements \n(such as cost, worktime, space, fuel, etc.)\nFor example, suppose we estimate that \n~{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institutions}}}} costs 80\\euro{}, whereas \n~{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}\ncosts 200\\euro{}.\nOne can express these facts straightforwardly and intuitively by adding\na global numerical variable {\\ensuremath{\\mathsf{{cost}}}} to the model; then \nthe system automatically generates a numerical\n{variable ${\\ensuremath{\\mathsf{{cost_E}}}}$ for each element $E \\in {\\ensuremath{\\mathcal{E}}\\xspace}$ \n\\footnote{{\\ensuremath{\\mathcal{E}}\\xspace} is the set of all elements of the CGM},\nrepresenting the attribute {\\ensuremath{\\mathsf{{cost}}}} of the element $E$,}\n whose value is set to the default value $0$, and the\ndefault global constraint\n$({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}})$.~\n\\footnote{{Notice that this is only a {\\em default} global constraint: the user is free to to define her own objective functions.}}\n\nThen, for some element $E$ of interest, \none can set the value for {\\ensuremath{\\mathsf{{cost_{E}}}}} in case $E$ is satisfied\n(or denied): e.g.,\n~${\\ensuremath{\\mathsf{{cost_{Use\\-Partner\\-Institutions}}}}} := 80\\euro{}$ and\n~${\\ensuremath{\\mathsf{{cost_{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}} := 200\\euro{}$.\nBy doing so, the following prerequisite {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} constraints are\n automatically added:\n\\begin{eqnarray}\n\\label{eq:costlocalsmt}\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institutions}}}}}}} {\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\n&&... \\wedge ({\\ensuremath{\\mathsf{{cost_{Use\\-Partner\\-Institutions}}}}} = 80)\\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}} {\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\n&& ... \\wedge ({\\ensuremath{\\mathsf{{cost_{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}} = 200)\n\\end{eqnarray} \nand the corresponding negative prerequisite constraints (like\n${{\\phi}^{-}_{{~{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institutions}}}}}}} {\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\n...\\wedge({\\ensuremath{\\mathsf{{cost_{Use\\-Partner\\-Institutions}}}}} = 0)$), are also\nautomatically added (if not specified otherwise). \n\n\nNotationally, \nwe use variables and formulas indexed by the \nelement they belong to \n\n(e.g. ${\\ensuremath{\\mathsf{{cost_{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}$ and\n${{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}}$)\nrather than attribute variables and formulas of the elements\nin an object-oriented notation\n(e.g. ${\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.cost}}}}$ and ${\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.\\phi^+}}}}$)\nbecause they are more suitable to be used within the {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} encodings \n({\\S{}\\ref{{sec:goalmodels}}} and {\\S{}\\ref{{sec:functionalities}}}).\n\n\\ignore{\n{E.g., the formula \n\n", "index": 1, "text": "$${{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}}\n\\ensuremath{\\rightarrow}\\xspace\n({\\ensuremath{\\mathsf{{cost_{Use\\-Hotels\\-And\\-Convention\\-Centers.cost}}}}}=200)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"{{\\phi}^{+}_{{~{}{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}%&#10;\\rightarrow({\\mathsf{{cost_{Use\\-Hotels\\-And\\-Convention\\-Centers.cost}}}}=200)\" display=\"block\"><mrow><msubsup><mi>\u03d5</mi><mpadded lspace=\"3.3pt\" width=\"+3.3pt\"><mi>\ud835\uddb4\ud835\uddcc\ud835\uddbe\ud835\udda7\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddc5\ud835\uddcc\ud835\udda0\ud835\uddc7\ud835\uddbd\ud835\udda2\ud835\uddc8\ud835\uddc7\ud835\uddcf\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddc2\ud835\uddc8\ud835\uddc7\ud835\udda2\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddbe\ud835\uddcb\ud835\uddcc</mi></mpadded><mo>+</mo></msubsup><mo>\u2192</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mrow><mi>\ud835\uddb4\ud835\uddcc\ud835\uddbe\ud835\udda7\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddc5\ud835\uddcc\ud835\udda0\ud835\uddc7\ud835\uddbd\ud835\udda2\ud835\uddc8\ud835\uddc7\ud835\uddcf\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddc2\ud835\uddc8\ud835\uddc7\ud835\udda2\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddbe\ud835\uddcb\ud835\uddcc</mi><mo>.</mo><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi></mrow></msub><mo>=</mo><mn>200</mn><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07409.tex", "nexttext": "}\n}\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} Constraints.}}}}}\nSuppose that, in order to achieve the nice-to-have requirement {\\ensuremath{\\mathsf{{Low\\-Cost}}}}, \nwe need to have a total cost smaller than 100\\euro{}. This can be expressed\nby adding the prerequisite constraint:\n${{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Low\\-Cost}}}}}}} = \\ldots \\wedge ({\\ensuremath{\\mathsf{{cost}}}} < 100) $.\nHence, e.g., due to \\eqref{eq:costlocalsmt}, \nevery realization that the tool generates automatically \nwhich satisfies {\\ensuremath{\\mathsf{{Low\\-Cost}}}} will not involve the task {\\ensuremath{\\mathsf{{Use Hotels And   Convention Centers}}}}. \n\nSimilarly to {\\ensuremath{\\mathsf{{cost}}}}, \none can introduce, e.g.,  another global numerical attribute {\\ensuremath{\\mathsf{{workTime}}}} \nto reason on working time, and \nestimate, e.g.,  that the total working time for {\\ensuremath{\\mathsf{{Schedule\\-Manually}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}}, {\\ensuremath{\\mathsf{{Email\\-Participants}}}}, {\\ensuremath{\\mathsf{{Call\\-Participants}}}}, \n{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}} are 3, 1, 1, 2, and 1\nhour(s), respectively, and state that the nice-to-have\nrequirement \n {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}} must require a global time smaller than 5 hours.\n\n{\nAs a result of this process, the system will produce the following\nconstraints. \n\\begin{eqnarray}\n\\label{eq:timelocalconstraint}\n&&({\\ensuremath{\\mathsf{{workTime}}}} =  \\sum_{E_i \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{workTime_{E_i}}}}})\\\\\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}}}} &{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime}}}} <  5)\\\\\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Schedule\\-Manually}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Schedule\\-Manually}}}}} = 3)\\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Schedule\\-Automatically}}}}} = 1)\\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Email\\-Participants}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Email\\-Participants}}}}} = 1) \\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Call\\-Participants}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Call\\-Participants}}}}} = 2) \\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Collect\\-From\\-System\\-Calendar}}}}} = 1),\n\\end{eqnarray}\nplus the corresponding negative prerequisite constraint, which force\nthe corresponding numerical attributes to be zero.\n}\n\nNotice that one can build combinations of numerical attributes.\nFor instance, if labor cost is $35\\euro/hour$, then one can redefine\n{\\ensuremath{\\mathsf{{cost}}}} as \n$({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}}+35\\cdot{\\ensuremath{\\mathsf{{workTime}}}})$,\nor introduce  a new global variable {\\ensuremath{\\mathsf{{totalCost}}}} as \n$({\\ensuremath{\\mathsf{{totalCost}}}} = {\\ensuremath{\\mathsf{{cost}}}}+35\\cdot{\\ensuremath{\\mathsf{{workTime}}}})$.\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Multiple Objectives.}}}}} \nStakeholders may define rational-valued {\\em {objectives}}\n$obj_1,...,obj_k$ to optimize (i.e., maximize or minimize) as\nfunctions of Boolean and numerical variables\n---e.g., \n${\\ensuremath{\\mathsf{{cost}}}}$, {\\ensuremath{\\mathsf{{workTime}}}}, \n${\\ensuremath{\\mathsf{{totalCost}}}}$ can be suitable objectives, {\\ensuremath{\\mathsf{{Weight}}}} is\nconsidered a pre-defined objective--- and ask the tool to automatically \ngenerate realization(s) which optimize one objective, or some\ncombination of more objectives (like {\\ensuremath{\\mathsf{{totalCost}}}}), or which\noptimizes lexicographically an ordered list of objectives\n{\\ensuremath{\\langle{{obj_1,obj_2,...}}\\rangle}\\xspace}.\n\\ignore{\n~\\footnote{{We recall that\n a solution optimizes\n    lexicographically an ordered list of objectives\n    {\\ensuremath{\\langle{{obj_1,obj_2,...}}\\rangle}\\xspace} if it makes $obj_1$ optimum\n  and, if more than one such solution exists, it makes also $obj_2$\n  optimum, ..., and so on. }}}\n\n\nOther examples of pre-defined objectives stakeholders may want to\n minimize, either singularly or in combination\nwith other objectives, are the number of \nnon-mandatory requirements which are not satisfied (namely\n  {\\ensuremath{\\mathsf{{numUnsatRequirements}}}}{}) and the number of \ntasks which need to be satisfied (namely\n  {\\ensuremath{\\mathsf{{numSatTasks}}}}{}).\n\n\n\nFor example, the previously-mentioned optimum-weight realization of\nFigure~\\ref{figCGMRelization} \nis such that\n~${\\ensuremath{\\mathsf{{Weight}}}} = -65$,\n~${\\ensuremath{\\mathsf{{workTime}}}} = 4$ and \n~${\\ensuremath{\\mathsf{{cost}}}} = 80$.\nOur CGM has many different\nminimum-weight realizations s.t. \n~${\\ensuremath{\\mathsf{{Weight}}}} = -65$, \nwith different values of {\\ensuremath{\\mathsf{{cost}}}} and {\\ensuremath{\\mathsf{{workTime}}}}. \nAmong them, \n it is possible to search, e.g., for the realizations with minimum {\\ensuremath{\\mathsf{{workTime}}}},\nand among these  for those with minimum {\\ensuremath{\\mathsf{{cost}}}}, by setting\nlexicographic minimization with order\n{\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}},{\\ensuremath{\\mathsf{{workTime}}}},{\\ensuremath{\\mathsf{{cost}}}}}}\\rangle}\\xspace}. \n\nThis results into one realization with ${\\ensuremath{\\mathsf{{Weight}}}} = -65$,\n${\\ensuremath{\\mathsf{{workTime}}}} =  2$ and ${\\ensuremath{\\mathsf{{cost}}}}=0$ achieving all the nice-to-have\nrequirements, as shown in Figure~\\ref{figCGMLex}, which  requires\n accomplishing the tasks: \n{\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}},\n{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}},\n{\\ensuremath{\\mathsf{{Get\\-Room\\-Suggestions}}}},\n{\\ensuremath{\\mathsf{{Cancel\\-Less\\-Important\\-Meeting}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}},\n{\\ensuremath{\\mathsf{{Confirm\\-Occurrence}}}},\n{\\ensuremath{\\mathsf{{Good\\-Participation}}}},\n{\\ensuremath{\\mathsf{{Minimal\\-Conflicts}}}},\n{\\ensuremath{\\mathsf{{Collection\\-Effort}}}}, \n{\\ensuremath{\\mathsf{{Matching\\-Effort}}}},\nand which requires the domain assumptions:\n{\\ensuremath{\\mathsf{{Participants\\-Use\\-System\\-Calendar}}}},\n{\\ensuremath{\\mathsf{{Local\\-Room\\-Available}}}}.\n(This was found automatically by our CGM-Tool of {\\S{}\\ref{{sec:implementation}}}\n\nin $0.016$ seconds on an Apple MacBook Air laptop.)\n\n\n\\ignore{\n\\begin{mcchange}\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Priorities.}}}}} \nIt is also possible to express the stakeholders preferences by using prefer-relation, denoted as {\\ensuremath{{A}\\succeq {B}}}, between two elements or refinements. {\\ensuremath{{A}\\succeq {B}}} means that we would rather having $A$ satisfied (while not care about $B$) than having $B$ satisfied but not $A$ (this does not have any constraint over $A$ and $B$ to be satisfied at the same time). For example, let say we only want to minimize the total weight of our example goal model, we do not care about the cost and the time, but rather we would like to add some preferences: (i) we would prefer to collect the timetable {\\ensuremath{\\mathsf{{By\\-System}}}} over {\\ensuremath{\\mathsf{{By\\-Person}}}}, and (ii) we would prefer {\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}} over the others choice of refining {\\ensuremath{\\mathsf{{Find\\-A\\-Suitable\\-Room}}}}. Then with our tool the output realization of the model will also be the one showed in Figure \\ref{figCGMLex} instead of the one in Figure \\ref{figCGMRelization} (This solution was found in $0.018$ seconds on an Apple MacBook Air laptop.)\n\\end{mcchange}\n}\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Binary Preference Relations.}}}}}\n\nIn general, stakeholders might not always be at ease in assigning\n numerical values to state their preferences, or in dealing with\n {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} terms, constraints and objectives. \nThus, as a more user-friendly solution, it \nis also possible for stakeholders to express their preferences \nin a more direct way by stating explicitly a list of\n{\\em binary preference relations}, denoted as ``{\\ensuremath{{P_1}\\succeq {P_2}}}'',\nbetween pairs of elements of the same kind (e.g. pair of requirements,\nof tasks, of domain assumptions) or pairs of\nrefinements. ``{\\ensuremath{{P_1}\\succeq {P_2}}}'' means that one prefers to have\n$P_1$ satisfied than $P_2$ satisfied, that is, that he/she would rather avoid\nhaving $P_1$ denied and $P_2$ satisfied. In the latter case, we say that a\npreference is unsatisfied. \nNotice that {\\ensuremath{{P_1}\\succeq {P_2}}} \nallows for having both $P_1$ and $P_2$\nsatisfied or both denied.\n\nIn CGM-Tool, binary preference relations can be expressed either graphically, via a\n``prefer'' arc ``{\\ensuremath{ {P_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {P_2}}}'', or via and ad-hoc menu window.\nOnce a list of binary preference relations is set, the system\ncan be asked to consider the number of unsatisfied preference relations\nas an objective (namely {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{}), \nand it searches for a realization which minimizes it. \n\nIt is also possible \nto combine such objective lexicographically with\nthe other objectives. \n\nFor example, suppose we want to minimize the total weight of our\nexample goal model. As  previously mentioned, there is more than one\nrealization with minimum weight $-65$. \nUnlike the previous example, as a secondary choice we\ndisregard {\\ensuremath{\\mathsf{{workTime}}}} and {\\ensuremath{\\mathsf{{cost}}}}; rather, we express also the\nfollowing  binary preferences:\n\\begin{eqnarray}\n\\label{eq:preferences}\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{By\\-System}}}}}\\succeq {{\\ensuremath{\\mathsf{{By\\-Person}}}}}}},\\\\\n\\nonumber\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}}}\\succeq {{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institutions}}}}}}},\\\\\n\\nonumber\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}}}\\succeq {{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}},\n\\end{eqnarray}\n{\\noindent} \nand set {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} as secondary objective to\nminimize after {\\ensuremath{\\mathsf{{Weight}}}},\nthat is, we set the lexicographic order {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}},{\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{}}}\\rangle}\\xspace}.\nThen our tool returned the same realization of\nFigure~\\ref{figCGMLex} ---that is, the same as with minimizing \n{\\ensuremath{\\mathsf{{workTime}}}} and {\\ensuremath{\\mathsf{{cost}}}} as secondary and tertiary choice---\n instead of that in Figure \\ref{figCGMRelization}. (This solution was found in $0.018$ seconds on an Apple MacBook Air laptop.)\n\n\n\n\n\n\n\\section{Abstract Syntax and Semantics}\n\\label{sec:goalmodels}\n\\label{sec:goalmodels_structure}\n{In this section we describe formally the abstract syntax and\n  semantics of CGMs. \n\n\\subsection{Abstract Syntax}\n}\n{We introduce first some general definitions.}\n\\label{def:gg}\n\\noindent\nWe call a {\\em {goal graph}} {\\ensuremath{\\mathcal{D}}\\xspace} a directed acyclic graph (DAG)\n  alternating {element nodes} (hereafter ``elements'')  and {refinement\n    nodes} (``refinements'', collapsed into bullets), s.t.:\n$(a)$ each element has from zero to many outgoing edges to\n  distinct refinements\n  and from zero to many incoming edges from distinct refinements;\n$(b)$ each refinement node has exactly one outgoing edge to an\n  element ({\\em {target}}) and one or more incoming edges from distinct\n  elements ({\\em {sources}}). \n\n{\n\\noindent\n\nWe call a {\\em {root element node }} any element node that has no\n  outgoing refinement edges, a {\\em {leaf element node}} any (non-root) element\n  node that has no incoming refinement edges, and an {\\em {internal     element node}} any other element node.~\n\nNotice that, by construction, only element nodes can be\n  roots and leaves of a goal graph. (Hereafter we will usually drop \n  the word \"node\", simply saying \"refinement\" for \"refinement node\",\n  \"element\" for \"element node\", etc.)\n  \nThe sets of root, leaf and internal element nodes of a goal graph\n{\\ensuremath{\\mathcal{D}}\\xspace} are denoted as {\\em {{\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}}, {\\em {{\\ensuremath{{\\sf Leaves}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}},\n{\\em {{\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}} respectively. \n\nGiven a refinement  $R$\n with outcoming edge to the element\n $E$ and incoming edges from the element s ${{E}_1, \\ldots,{E}_{{n}}}$,\nwe call ${{E}_1, \\ldots,{E}_{{n}}}$ the {\\em {source elements}} of $R$ and $E$ the\n{\\em {target element}} of $R$, which are denoted by \n{\\em {{\\ensuremath{{\\sf Sources}({R})}\\xspace}}} and {\\em {{\\ensuremath{{\\sf Target}({R})}\\xspace}}} respectively. We say that \n$R$ is {\\em {a refinement of $E$}} and that \n{\\em {$R$ refines $E$ into ${{E}_1, \\ldots,{E}_{{n}}}$}}, denoted ``{\\ensuremath{ {({{E}_1, \\ldots,{E}_{{n}}})} \\xrightarrow{R} {E}}}''.\n\nThe set of refinements of an element $E$\nare denoted with {\\em {{\\ensuremath{{\\sf Refinements}({E})}\\xspace}}}. \n} \n\n\n\\noindent\nElements are either {\\em {goals}} or {\\em {domain assumptions}}, subject to the following constraints:\na domain assumption cannot be a root element;\nif the target of a refinement $R$ is a domain assumption, then it sources must be only  domain assumptions;\nif the target of a refinement $R$ is a goal,\nthen at least one of its sources must be a goal.\nWe call root goals and leaf goals {\\em {requirements}} and\n{\\em {tasks}} respectively.\n\n{\n\n\n\\input{goalmodels_table}\n}\nNotationally, \nwe use the symbols \n$R$, $R_j$ for  labeling refinements, \n$E$, $E_i$ for generic elements (without specifying \nif goals or domain assumptions), \n$G$, $G_i$ for goals, \n$A$, $A_i$ for domain assumptions.\n{\nGraphically (see Figure~\\ref{figGMEx})\n we collapse refinements nodes into one bullet, so\nthat we see a refinement as an aggregation of edges from a set of\nother goals.\n\n\n\n}\n\n{(See Table~\\ref{tabSumGM}.)}\n\n{\nHence, in a goal graph we consider element nodes as the only nodes,\nand refinements as (aggregations of) edges from a group of source\nelements to a target element.\n}\n\n\n\n\n\n\n\\begin{definition}[Constrained Goal Model] \n\n\\label{def:cgm}\nA {\\em {Constrained Goal Model (CGM)}} is a tuple ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$, s.t.\n\\begin{itemize}\n\\item ${\\ensuremath{\\mathcal{B}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\mathcal{G}}\\xspace}\\cup{\\ensuremath{\\mathcal{R}}\\xspace}\\cup{\\ensuremath{\\mathcal{A}}\\xspace}$ is a set of atomic\n  propositions, where\n${\\ensuremath{\\mathcal{G}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{G_1,...,G_N\\}$,\n${\\ensuremath{\\mathcal{R}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{R_1,...,R_K\\}$,\n${\\ensuremath{\\mathcal{A}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{A_1,...,A_M\\}$ are respectively sets of \n{goal},\n{refinement} and\n{domain-assumption labels}.\nWe denote with {\\ensuremath{\\mathcal{E}}\\xspace} the set of element labels:\n${\\ensuremath{\\mathcal{E}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\mathcal{G}}\\xspace}\\cup{\\ensuremath{\\mathcal{A}}\\xspace}$;\n\\item {\\ensuremath{\\mathcal{N}}\\xspace} is a set of numerical variables in the rationals;\n\n\\item {\\ensuremath{\\mathcal{D}}\\xspace} is a goal graph, s.t. all its goal nodes are univocally labeled\n  by a goal label in {\\ensuremath{\\mathcal{G}}\\xspace}, all its refinements are univocally\n  labelled by a refinement label in {\\ensuremath{\\mathcal{R}}\\xspace},\n and all its domain assumption are univocally labeled\n by a assumption label in {\\ensuremath{\\mathcal{A}}\\xspace};\n\\item $\\Psi$ is a {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} formula on {\\ensuremath{\\mathcal{B}}\\xspace} and {\\ensuremath{\\mathcal{N}}\\xspace}.\n\n\\end{itemize}\n\\end{definition}\n\n\n\\noindent\nA CGM is thus an and-or directed acyclic graph (DAG) of\n\\emph{elements}, as \nnodes, and \\emph{refinements}, as (grouped) edges, which are labeled\nby atomic propositions and can be augmented with arbitrary constraints\nin form of {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} formulas --typically conjunctions of smaller global\nand local constraints-- on the element and refinement labels and on\nthe numerical variables.  \n\n{\nNotice that each non-leaf element $E$ is implicitly or-decomposed into \nthe set of its incoming refinements ${\\ensuremath{\\{{{R_i}}\\}}\\xspace}$, and that each refinement $R$\nis and-decomposed into the set of its source elements ${\\ensuremath{\\{{{E_j}}\\}}\\xspace}$.~\n(\nIn fact, by combining the propositional encodings of goal refinement\nand closed world in Table~\\ref{tabSumGM}, we can infer the formulas\n$E \\ensuremath{\\leftrightarrow}\\xspace (\\bigvee_i R_i)$  and $R \\ensuremath{\\leftrightarrow}\\xspace (\\bigwedge_j E_j)$.\n\\footnote{{We recall that in Boolean logic $\\bigwedge_i (\n    R_i\\ensuremath{\\rightarrow}\\xspace E)$\n  is equivalent to $E \\ensuremath{\\leftarrow}\\xspace (\\bigvee_i R_i)$.}}\n)\n\n}\n\nIntuitively, a CGM describes a (possibly complex) combination of\nalternative ways of realizing a set of requirements in terms \nof a set of tasks, under certain domain assumptions.\n\n\\begin{figure}[t]\n  \\centering\n\\resizebox{\\textwidth}{!}{\n\\input{fig_cgmvsgm.pdf_t}  \n}  \\caption{{A simple CGM (left) and its translation into standard\n      and-or goal model format (right). It is necessary to\n      introduce two auxiliary goals\n    $G'$ and $G''$ to encode the refinements $R_1$ and $R_2$.}}\n  \\label{fig:cgmvsgm}\n\\end{figure}\n\n{\n{\nNotice that CGMs are more succinct in terms of number of goals \nthan standard and-or decompositions:\nwhereas a standard $n$-ary and-decomposition [resp. or-decomposition] of a\ngoal can be represented straightforwardly in a CGM by \none refinement with $n$ sources [resp. $n$ one-source refinements],\nin order to represent a CGM decomposition with $n$ non-unary refinements by\nmeans of standard and-or decomposition we need  introducing $n$ \nnew auxiliary intermediate goals to encode refinements, which CGMs\nencode natively.\n(See Figure~\\ref{fig:cgmvsgm}.) We recall from\n{\\S{}\\ref{{sec:goalmodels_example}}} that refinements do not \nneed to be explicitly labeled unless strictly necessary.\n}}\n\n\nIn general, the user might not be at ease in defining\na possibly-complex\n{\\em global} {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} formula $\\Psi$ to encode constraints among elements\nand refinements, plus numerical variables. \n\n To this extent, as mentioned in {\\S{}\\ref{{sec:goalmodels_example}}},\napart from the possibility of defining global formulas,\n CGMs provide  constructs allowing the\nuser to encode {\\em graphically} and {\\em locally} desired constraints\nof frequent usage: {\\em {relation edges}}, {\\em {prerequisite constraints}}\n${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$ and ${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$ and {\\em {user assertions}}.\nEach is automatically converted into a simple {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} formula \nas follows, and then conjoined to $\\Psi$.\n\n\n\\begin{itemize}\n\\item[{\\em Element-contribution edges},] \n  ${\\ensuremath{ {E_1} \\xrightarrow{++} {E_2}}}$, { meaning that \nsatisfying $E_1$ forces $E_2$ to be satisfied (but not vice versa). \n \n \nThey }\nare encoded into  the formula $(E_1\\ensuremath{\\rightarrow}\\xspace E_2)$.\n(The edge\n${\\ensuremath{ {E_1} \\overset{++}{\\longleftrightarrow} {E_2}}}$ can be used to denote the merging of the\ntwo contribution edges\n${\\ensuremath{ {E_1} \\xrightarrow{++} {E_2}}}$ and\n${\\ensuremath{ {E_2} \\xrightarrow{++} {E_1}}}$ into one.)\n\n\\item[{\\em Element-conflict edges},] \n  ${\\ensuremath{ {E_1} \\overset{--}{\\longleftrightarrow} {E_2}}}$, {meaning that \n$E_1$ and $E_2$ cannot be both\n  satisfied. \n\n\nThey }\nare encoded into the formula\n$\\neg (E_1\\wedge E_2)$.\n\n\n\n\n\n\\item[{\\em Refinement-binding edges},] \n\n  ${\\ensuremath{ {{{R_1}}}{\\longleftrightarrow} {{{R_2}}}}}$, \n{meaning that, if both \nthe target goals of $R_1$ and $R_2$ (namely $E_1$ and  $E_2$\nrespectively) are satisfied, \nthen $R_1$ refines $E_1$  if and only if \n$R_2$ refines $E_2$. They\n\n\n\n\n\n\n}\nare encoded into the formula \n$(E_1 \\wedge E_2) \n\\ensuremath{\\rightarrow}\\xspace \n({{R_1}}\\ensuremath{\\leftrightarrow}\\xspace{{R_2}})$.\n\n\n\\item[{\\em Prerequisite constraints},] ${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$ \n[resp. ${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$]\nare\n  encoded into the formulas \n$(G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{G}}})$ and\n$(\\neg G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{G}}})$ \n[resp. \n$(R\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{R}}})$ and\n$(\\neg R\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{R}}})$].\n\n\\item[{\\em User assertions},] $E_i:=\\top$ and $E_j:=\\bot$, are\n  encoded into the formulas $(E_i)$, $(\\neg E_j)$.\n\\end{itemize}\n\\noindent\n\n\nThe following are instead encoded\ninto {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} ``soft''~\n\\footnote{{In constraint programming and other related disciplines\n    (e.g. MaxSAT, MaxSMT, OMT) constraints which must be satisfied are\n  called ``hard'', whereas constraints which are preferably satisfied\n  but which can be safely violated, although paying some penalty, are\n  called ``soft''.}}\n constraints:\n\\begin{itemize}\n\\item[{\\em Preference edges},] \n${\\ensuremath{ {E_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {E_2}}}$ (resp. ${\\ensuremath{ {R_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {R_2}}}$ ), and their\nequivalent \n{\\em binary preference relations}\n${\\ensuremath{{E_1}\\succeq {E_2}}}$ (resp. ${\\ensuremath{{R_1}\\succeq {R_2}}}$ ), are implemented into the soft constraint\n$\\phi_{{\\ensuremath{{E_1}\\succeq {E_2}}}}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}(E_1 \\vee (\\neg E_2))$ \n(resp. $\\phi_{{\\ensuremath{{R_1}\\succeq {R_2}}}}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}(R_1 \\vee (\\neg R_2))$).\n(Notice that $E_1$ and $E_2$ should be of the same kind, i.e. they must \nbe  both tasks, or both requirements, or both refinements, \nor both intermediate goals, or both domain\nassumptions.) \n\\end{itemize}\n\nUnlike other constraints, these soft constraints \nare {\\em not} added directly to $\\Psi$. Rather, it is added to $\\Psi$ \nthe following {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} constraint, which defines \na numeric Pseudo-Boolean {\\em cost function}:\n\n\\begin{eqnarray}\n\\label{eq:costpref}\n ({\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} &=&\n\\sum_{{\\ensuremath{\\langle{{{E_i}{E_j}}}\\rangle}\\xspace}\\in {\\ensuremath{\\mathcal{P}}\\xspace}}\n{\\sf ite}(\\phi_{{\\ensuremath{{E_i}\\succeq {E_j}}}},0,1) +\n\n\n\\sum_{{\\ensuremath{\\langle{{{R_i}{R_j}}}\\rangle}\\xspace}\\in {\\ensuremath{\\mathcal{P}}\\xspace}} {\\sf ite}(\\phi_{{\\ensuremath{{R_i}\\succeq {R_j}}}},0,1)), \n\\end{eqnarray}\n\n\\noindent\nwhere ${\\ensuremath{\\mathcal{P}}\\xspace}$ is the list of binary preference relations, and\n``${\\sf ite}(\\phi_{*},0,1)$\" denotes an\nif-then-else arithmetical term, which is evaluated to 0 if $\\phi_{*}$\nis evaluated \nto true, to 1 otherwise. Hence, {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} counts the number of\nunsatisfied preferences.~\n\n\n(In practice, OMT solvers like\n  OptiMathSAT \\cite{st_cav15} provide more efficient ad-hoc encodings\nfor soft constraints, which we have exploited\n in the implementation of CGM-Tool; we refer the reader \nto \\cite{st_cav15} for details.)\n\n\n\n\nNotice that, unlike refinements, relation edges and preference edges \nare allowed to create\nloops, possibly involving refinements. \n\n\n\n\n\n\\ignore{\nIt is easy to provide the user the possibility of defining, both\nglobally and locally, more\ngeneral and intuitive Boolean\nconstraints (e.g., \n$\\mathsf{{Requires}}\\left({E_1,E_2}\\right)$, \n$\\mathsf{{AtMost}}\\left({N,\\{E_1,...,E_n\\}}\\right)$)\n with no need for the user to define\nthe corresponding complicate propositional formulas. \n}\n\n\\ignore{\nSecond, it is made possible to add ``local'' pre-requisite constraints to goal\n  nodes $G$  or to refinements $R$:\n\n\nfor each goal ${{G}}$ it is possible to introduce locally  a pair \nof propositional constraints ${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$  on {\\ensuremath{\\mathcal{B}}\\xspace}, so that \n ${{\\phi}^{+}_{{G}}}$ (resp. ${{\\phi}^{-}_{{G}}}$) must be\n satisfied whenever the goal ${{G}}$ is  \nsatisfied (resp. denied), but not vice versa.\n This corresponds to conjoining  to $\\Psi$ the formulas\n$(G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{G}}})$ \nand\n$(\\neg G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{G}}})$ respectively.\nThe same holds for each requirements $R$. \n \nThird, we provide the user the possibility of defining, both\nglobally and locally, more\ngeneral and intuitive Boolean\nconstraints (e.g., \n$\\mathsf{{Requires}}\\left({E_1,E_2}\\right)$, \n$\\mathsf{{AtMost}}\\left({N,\\{E_1,...,E_n\\}}\\right)$)\n with no need of defining\nthe corresponding complicate propositional formulas. \n\nFinally, it is made possible to force [unforce]  interactively each \nelement $E_i$ to be satisfied or\n  denied.~\n\n  This corresponds to conjoining to [dropping from] $\\Psi$ the unit\n  clauses $(E_i)$ or $(\\neg E_i)$ respectively.  The same holds for\n  each requirements $R_j$.  We call these unit clauses the\n  user {\\em {assertions}}.\n\nFor example, typically the user may try interactively to force\nrequirements to be satisfied to achieve a desired result, and/or to\nforce effortful tasks be denied, to reduce the effort; we call the\nformer {\\em {mandatory requirements}}.  The user may also \ninteractively force\nsome domain assumption to be satisfied or denied in order to investigate the\neffects of such assertions.\n}\n\n{\nFinally we provide the user {of a list of\n  syntactic-sugaring constructs, which allow for} defining, both\nglobally and locally, the most\nstandard and intuitive \nconstraints among assumption, goal and refinement labels,\n with no need of defining\nthe corresponding complicate or less-intuitive propositional formulas. \n(In what follows, $P_1,...,P_n$ denote atomic propositions in {\\ensuremath{\\mathcal{B}}\\xspace}.)\n\n\\begin{itemize}\n\\item[$\\mathsf{{Alt}}\\left({P_1,P_2}\\right)$] denotes the fact\n$P_1$ and $P_2$ are alternative, e.g., that one and only one of them \nis satisfied. \nThis is encoded by the formula $(P_1\\ensuremath{\\leftrightarrow}\\xspace \\neg P_2)$. \n\\item[$\\mathsf{{Causes}}\\left({P_1,P_2}\\right)$] denotes the fact\n  that satisfying ${{P_1}}$  causes ${{P_2}}$ to be satisfied.\nThis is\nencoded by the formula $(P_1\\ensuremath{\\rightarrow}\\xspace P_2)$. \n\\item[$\\mathsf{{Requires}}\\left({P_1,P_2}\\right)$] denotes the fact\n  that satisfying ${{P_1}}$ requires ${{P_2}}$ to be satisfied.\nThis is encoded by the formula $(P_1\\ensuremath{\\rightarrow}\\xspace P_2)$. \n\n\\item[$\\mathsf{{AtMostOneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact that at most\n  one of $\\{P_1,...,P_n\\}$ must be satisfied. This is  encoded \nby the formula  $\\bigl(\\bigwedge_{1 \\leq i < j \\leq n} (\\neg P_i \\vee\n\\neg P_j)\\bigr)$.  \n\n\\item[$\\mathsf{{AtLeastOneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact\n  that at least one of $\\{P_1,...,P_n\\}$ must be satisfied. This is\n encoded by the formula $\\bigl(\\bigvee_{1 \\leq i \\leq n}\n  P_i\\bigr)$.\n\\item[$\\mathsf{{OneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact\n  that exactly one of $\\{P_1,...,P_n\\}$ must be satisfied. This is\n   encoded by the conjunction of the previous two formulas.\n\n\\end{itemize}\n} \n\n\n\\subsection{{Semantics}}\n\nThe semantics of CGMs is formally defined as follows.\n\n\n\n\n\n\n\\begin{definition}[Realization of a CGM]\n\n\\label{def:realization}\n{Let ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM.\nA {\\em {realization}} of {\\ensuremath{\\mathcal{M}}\\xspace} \nis a {\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation $\\mu$ over ${\\ensuremath{\\mathcal{B}}\\xspace}\\cup{\\ensuremath{\\mathcal{N}}\\xspace}$\nsuch that:\n}\n\\begin{aenumerate}\n\\item \n$\\mu \\models ((\\bigwedge_{i=1}^{n} E_i) \\leftrightarrow R) \\wedge  (R\n\\rightarrow E)$ for each refinement  ${\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}}$;\n\\item \n$\\mu\\models \\bigl( E \\rightarrow (\\bigvee_{R_i \\in \\rm{Ref}(E)}\nR_i)\\bigr)  $, for each non-leaf element $E$;\n\n\\item $\\mu\\models\\Psi$.\n\\end{aenumerate}\n\n\n\n\\noindent\nWe say that {\\ensuremath{\\mathcal{M}}\\xspace}\n\nis {\\em {realizable}} if it has at least one realization, \n {\\em {unrealizable}}\n\notherwise.\n\n\\end{definition}\n\n{ \nFrom Definition~\\ref{def:realization}, \na realization \nrepresents  a sub-graph of the CGM, such that:\n\\begin{enumerate}\n\\item If a non-leaf goal is in a realization sub-graph, then at least one of its refinements is included in the realization.\n\\item If a refinement is in a realization sub-graph, then all of its sub-elements is included in the realization.\n\\item If an element is included in a realization sub-graph, and it is a contribution of another element, then that other element is also included in the realization.\n\\item In a realization sub-graph, there are no two elements that have conflict relationship.\n\\item The realization complies with all user-defined constraints of the goal model.\n\\end{enumerate}\nIntuitively, a realization represents the alternatives of achieving the root goal(s).\n} \n\n\n\\noindent\n\nIn a realization,\n\n\n each element $E$ or refinement $R$ can be\neither \\emph{satisfied} or \\emph{denied} (i.e., their label can be\nassigned to $\\top$ or $\\bot$ respectively by $\\mu$). \n\nIf an element $E$ is not a leaf, then it can be satisfied only by satisfying\nthe set of source elements ${{E}_1, \\ldots,{E}_{{n}}}$ \nof one of its refinements\n${\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}}$.\n\nIf $\\mu$ satisfies a refinement ${{R}}$ of an element $E$, i.e.,\nit satisfies all the source elements ${{E}_1, \\ldots,{E}_{{n}}}$, then it \nsatisfies the element $E$, but not vice versa (condition $(a)$). \n\n\nFor a non-leaf element to be satisfied, at least one\nof its refinements must be satisfied (condition $(b)$).\nWe call this fact  {\\em {Closed World Assumption (CWA)}}.\n\n The satisfiability or deniability of each element or refinement can be\n further constrained by all the constraints defined inside the formula\n $\\Psi$:  every realization $\\mu$ \n must satisfy such constraints (condition $(c)$). \n\nNotice that, by fulfilling condition $(c)$,  \n a realization must implicitly comply also with all the\nrelation edges, with the user assertions and\n with the\nlocal pre-requisite constraints ${\\bigl\\{ {{{\\phi}}^{+}_{{{E}}}}, {{{\\phi}}^{-}_{{{E}}}}\\bigr\\}}$ and\n${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$, \nbecause the corresponding formulas are conjuncts of $\\Psi$. \n\n\nThus $\\Psi$ contains also the  global and local\n{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} constraints over global and local numerical attributes\n(e.g. \n${\\ensuremath{\\mathsf{{Low Cost}}}}\\ensuremath{\\rightarrow}\\xspace ({\\ensuremath{\\mathsf{{cost}}}} \\leq 100)$,\n${\\ensuremath{\\mathsf{{Use Partner Institutions}}}}\\ensuremath{\\rightarrow}\\xspace ({\\ensuremath{\\mathsf{{cost_{Use Partner     Institutions}}}}} = 80)$, and the definitions of \nobjectives\n (e.g., $({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}}$).\n \n  \n\n   \\begin{remark}\n\\label{remark:onlynonzeros}\n   Importantly, in the definition of objectives only\n   non-zero terms of the sums need to be considered. (E.g., the sum\nin $({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E   \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}})$ can be safely\nrestricted to the elements \n{\\ensuremath{\\mathsf{{Use Partner Institutions}}}} and  {\\ensuremath{\\mathsf{{Use Hotels And Convention   Centers}}}}.)\nThis allows for reducing drastically the number of rational variables \ninvolved in the encoding.      \n   \\end{remark}\n\n\n\n\nA realization $\\mu$ for a CGM\n${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$  \nis represented graphically as the  sub-graph of {\\ensuremath{\\mathcal{D}}\\xspace} where \nall the denied element and refinement nodes are eliminated. \n\n\n\n\n\n\\section{Automated Reasoning with Constrained Goal Models}\n\\label{sec:functionalities}\n{In this section we describe how to perform automated\n  reasoning functionalities on CGMs by encoding them into SMT and OMT.}\n\n\n\n\\subsection{Encoding of Constrained Goal Models}\n\\label{sec:goalmodels_encodings}\n\\begin{definition}[{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} Encoding of a CGM]\n\\label{def:encoding}\nLet ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM.\nThe {\\em {{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} encoding}} of {\\ensuremath{\\mathcal{M}}\\xspace} is the  formula \n${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\Psi\\wedge\\Psi_{\\ensuremath{\\mathcal{E}}\\xspace}\\wedge\\Psi_{\\ensuremath{\\mathcal{R}}\\xspace}$, where:\n\\begin{eqnarray}\n\\Psi_{\\ensuremath{\\mathcal{E}}\\xspace}&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}& \n\\textstyle\n\\bigwedge_{E\\in{\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}\\cup{\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}\\ \n\\bigl( E \\rightarrow (\\bigvee_{R_i \\in \\rm{{\\sf Refinements}}(E)} R_i) \\bigr) \n\\\\\n \\Psi_{\\ensuremath{\\mathcal{R}}\\xspace}&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}& \n\\textstyle\n\\bigwedge_{{\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}},\\ R\n  \\in {\\ensuremath{\\mathcal{R}}\\xspace}}\\  \n\\bigl(\n (\\bigwedge_{i=1}^{n} E_i \\leftrightarrow R) \\wedge  (R\n\\rightarrow E)\n\\bigr),\n\\end{eqnarray}\n{\\noindent} {\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace} and {\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace} being the root and internal\nelements of {\\ensuremath{\\mathcal{D}}\\xspace} respectively.\n\n\\end{definition}\n\nThe following facts are straightforward consequences of\nDefinitions~\\ref{def:realization} and \\ref{def:encoding} and of the\ndefinition and {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}.\n\n \n\\begin{proposition}\n\\label{prop:main} \nLet ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM, ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$\n  its {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} encoding \nand $\\mu$ a {\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation over ${\\ensuremath{\\mathcal{B}}\\xspace}\\cup{\\ensuremath{\\mathcal{N}}\\xspace}$. \nThen $\\mu$ is a realization of\n{\\ensuremath{\\mathcal{M}}\\xspace} \nif and only if \n$\n  \\mu\\models\n{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}.\n$\n\\end{proposition}\n\n\\begin{proposition}\n\\label{prop:main2} \nLet ${\\ensuremath{\\mathcal{M}}\\xspace}$ and ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$ be as in Proposition~\\ref{prop:main},\nand let $\\mu$ be a realization of {\\ensuremath{\\mathcal{M}}\\xspace}. \nLet ${\\ensuremath{\\{{{obj_1,...,obj_k}}\\}}\\xspace}$ be {\\ensuremath{\\mathcal{LRA}}\\xspace}-terms occurring in $\\Psi$.\nThen we have that:\n\\begin{itemize}\n\\item[(i)] for every i in $1,...,k$, $\\mu$ minimizes [resp. maximizes] $obj_i$\nif and only if  $\\mu$ is a solution of the {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} minimization\n[resp. maximization] problem \n{\\ensuremath{\\langle{{{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{},{\\ensuremath{\\langle{{obj_i}}\\rangle}\\xspace}}}\\rangle}\\xspace};\n\n\\item[(ii)] $\\mu$ lexicographically minimizes [resp. maximizes]\n  ${\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace}$ \nif and only if  $\\mu$ is a solution of the {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} lexicographic minimization\n[resp. maximization] problem \n{\\ensuremath{\\langle{{{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{},{\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace}}}\\rangle}\\xspace}.\n\n\\end{itemize}\n\\end{proposition}  \n\n\n\n\n\\subsection{Automated Reasoning on Constrained Goal Models}\n\\label{sec:goalmodels_functionalities}\n\\noindent\nPropositions~\\ref{prop:main}  and \\ref{prop:main2} suggest\n that realizations of a CGM {\\ensuremath{\\mathcal{M}}\\xspace}\ncan be produced by applying {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} solving to the encoding\n${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$, and that {\\em optimal} realizations can \nbe produced by applying {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} to ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$ and  a list of\ndefined objectives $obj_1,...,obj_k$.\n\n{(Notice that such list may include also the pre-defined \nobjectives\n{\\ensuremath{\\mathsf{{numUnsatRequirements}}}}{}, {\\ensuremath{\\mathsf{{numSatTasks}}}}{} and \n    {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} of {\\S{}\\ref{{sec:goalmodels_example}}} and\n    \\eqref{eq:costpref}  to be minimized.)} \n\nThis allowed us to  implement straightforwardly the following reasoning\nfunctionalities on CGMs by interfacing with a SMT/OMT tool.\n\n\n\n\n\\begin{description} \n\\item[Search/enumerate realizations.] \n  Stakeholders can automatically check the realizability of a CGM {\\ensuremath{\\mathcal{M}}\\xspace}{} --or to\n  enumerate one or more of its possible realizations-- under a group\n  of user assertions and of user-defined Boolean and {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}\n  constraints; \n the tool performs this task by invoking the\n SMT solver on the formula $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ of\n  Definition~\\ref{def:encoding}. \n\n\\item[Search/enumerate minimum-penalty/maximum reward realizations.]\n  Stakeholders \n  can assert the desired requirements and set penalties\n  of tasks; then the tool \n  finds automatically realizations \n  achieving the former while minimizing \n  the latter,  by invoking the OMT solver on $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ with the pre-defined\n  {\\ensuremath{\\mathsf{{Weight}}}} objective. The vice versa is obtained by \n  negating undesired tasks and setting the rewards of\n  nice-to-have requirements. \n  Every intermediate situations can be also be obtained.\n\n\\item[Search/enumerate optimal realizations wrt. pre-defined/user-defined\n  objectives.] Stakeholders can define their own objective functions\n  $obj_1,...,obj_k$ over goals, refinements and their numerical\n  attributes; then the tool finds automatically realizations optimizing\n  them, either independently or lexicographically, by invoking the OMT\n  solver on $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ and $obj_1,...,obj_k$.\n  {User-defined objectives can also be combined with the pre-defined\n    ones,\n like  {\\ensuremath{\\mathsf{{Weight}}}}, {\\ensuremath{\\mathsf{{numUnsatRequirements}}}},  {\\ensuremath{\\mathsf{{numSatTasks}}}}{} and\n {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}. \n}\n\n\\end{description}\n{{\\noindent} In particular, notice that the latter allows for addressing the\nfulfillment of the maximum number of binary preferences as the\noptimization of a pre-defined objective.}\n\n\n\\begin{example}\n\\label{ex:lexicographically}\nAs a potentially frequent scenario, stakeholders may want to find a realization\nwhich minimizes, in order \nof preference, the number of unsatisfied non-mandatory requirements, \nthe number of unsatisfied binary preferences, and the number of\nsatisfied tasks.  This can be achieved my setting the following\nordered list of pre-defined objectives to minimize lexicographically:\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nis more readable than\n\n", "index": 3, "text": "$${\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.\\Phi^+}}}}\n\\ensuremath{\\rightarrow}\\xspace\n({\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.cost}}}}=200)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.\\Phi^{+}}}}\\rightarrow({%&#10;\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers.cost}}}=200)\" display=\"block\"><mrow><mi>\ud835\uddb4\ud835\uddcc\ud835\uddbe\ud835\udda7\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddc5\ud835\uddcc\ud835\udda0\ud835\uddc7\ud835\uddbd\ud835\udda2\ud835\uddc8\ud835\uddc7\ud835\uddcf\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddc2\ud835\uddc8\ud835\uddc7\ud835\udda2\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddbe\ud835\uddcb\ud835\uddcc</mi><mo>.</mo><msup><mi mathvariant=\"sans-serif\">\u03a6</mi><mo>+</mo></msup><mo>\u2192</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\uddb4\ud835\uddcc\ud835\uddbe\ud835\udda7\ud835\uddc8\ud835\uddcd\ud835\uddbe\ud835\uddc5\ud835\uddcc\ud835\udda0\ud835\uddc7\ud835\uddbd\ud835\udda2\ud835\uddc8\ud835\uddc7\ud835\uddcf\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddc2\ud835\uddc8\ud835\uddc7\ud835\udda2\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddbe\ud835\uddcb\ud835\uddcc</mi><mo>.</mo><mi>\ud835\uddbc\ud835\uddc8\ud835\uddcc\ud835\uddcd</mi><mo>=</mo><mn>200</mn><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07409.tex", "nexttext": "\n\\end{example}  \n\n\n\nNotice that all the above actions can be performed {\\em interactively} by\nmarking an unmarking (nice-to-have) requirements, tasks and domain\nassumptions, each time searching for a suitable or optimal\nrealization.\n \n\n{\nImportantly, when a CGM is found un-realizable under a group of user\nassertions and of user-defined Boolean and {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}\n  constraints, it highlights the\nsubparts of the CGM and the subset of assertions causing the problem. \nThis is implemented by asking the SMT/OMT solver to identify the \n{\\em unsatisfiable core} of the input formula  ---i.e. the subset of\nsub-formulas which caused the inconsistency, see e.g. \\cite{cimattigs11_unsatcore}--- and mapping them back\ninto the corresponding information.\n}\n\n \n\n\n \n\n\n\\section{Implementation}\n\\label{sec:implementation}\n\n\\begin{figure}[t]\n\\centering \n\\includegraphics[height=0.39\\textheight, width=\\textwidth]{CGM-tool-architecture-1.pdf}\n\\caption{\\label{figCGM--Tool} CGM-Tool Component view}\n\\end{figure}\n\nCGM-Tool provides support  modeling and reasoning on\nCGMs.  Technically, CGM-Tool is a standalone\napplication written in Java and its core is based on Eclipse RCP\nengine. Under the hood, it encodes constraint goal models and invokes\nthe OptiMathSAT\n~\\footnote{\\url{http://optimathsat.disi.unitn.it}} SMT/OMT solver\n \\cite{st_cav15} to support reasoning on goal models. It is freely distributed as a compressed archive file for multiple platforms \\footnote{\\url{http://www.cgm-tool.eu/}}. CGM-Tool supports: \n\n\\begin{description}\n\t\\item[Specification of projects:] CGMs\nare created within the scope of project containers. A project contains\na set of CGMs that can be used to generate  reasoning sessions with\nOptiMathSAT (i.e., scenarios);\t\n\n\\item[Diagrammatic modeling:] the tool enables the creation (drawing) of CGMs in terms of diagrams; furthermore it enhances the modeling process by providing real-time check for refinement cycles and by reporting invalid refinement, contribution and binding links;\n\t\n\\item[Consistency/well-formedness check:] CGM-Tool allows for the\n  creation of diagrams conform with the semantics of the modeling\n  language by providing the ability to run consistency analysis on the\n  model;\t\n\n\\item[Automated Reasoning:] CGM-Tool provides the automated reasoning\n  functionalities of {\\S{}\\ref{{sec:goalmodels_functionalities}}} by encoding\n  the model into an SMT formula. The results of OptiMathSAT are shown\n  directly on the model as well as in a tabular form.\n\n\n\\end{description}\n\n\n\nCGM-Tool extends the STS-Tool~\\cite{paja:2012:ststool:re} as an RCP application by using the major frameworks shown in Figure~\\ref{figCGM--Tool}: {\\em Rich Client Platform (RCP)}, a platform for building rich client applications, made up of a collection of low level frameworks such as OSGi, SWT, JFace and Equnix, which provide us a workbench where to get things  like menus, editors and views; \n{\\em Graphical Editing Framework (GEF)}, a framework used to create\ngraphical editors for graphical modeling tools (e.g., tool palette and\nfigures which can be used to graphically represent the underlying data\nmodel concepts); {\\em Eclipse Modeling Framework (EMF)}, a modeling\nframework and a code generation facility for building tools and\napplications based on a structured data model. \n\n\n\n\n\n\\section{{\nScalability of\n    the Reasoning Tool}}\n\\label{sec:expeval}\nWe address the issue of the scalability of the\nautomated-reasoning functionalities of\n{\\S{}\\ref{{sec:goalmodels_functionalities}}} wrt. the  size of CGMs,\n\n\nby providing an empirical evaluation of the\nperformances of CGM-Tool on increasingly-large CGMs.\n(For the sake of readability, here we provide only a qualitative\ndescription, whereas the data and plots are reported in Appendix.)\nLike in {\\S{}\\ref{{sec:goalmodels_example}}}, all experiments have been run on\n{a MacBook Air laptop, Intel Core i5 1.8 GHz, 2 cores, 256 KB L2 Cache per Core, 3 MB L3 Cache, 4GB RAM.}\n\nFor the reviewers' convenience, a compressed directory containing \nall the material to reproduce these esperiments (models, \ntools, scripts, etc.) is available at \\url{http://www.cgm-tool.eu/experiment-version/}.\n\nWe consider first the schedule-meeting CGM of\n{\\S{}\\ref{{sec:goalmodels_example}}} as a basic case study.\n\nThe model consists in $32$ goals --among which there are $1$ mandatory\n requirement, $4$ nice-to-have requirements, and $18$ tasks-- plus $20$ refinements\n and $2$ domain assumptions, totaling $54$ nodes.\n\nThe CGM contains also $3$\nnumerical objectives: {\\ensuremath{\\mathsf{{cost}}}}, {\\ensuremath{\\mathsf{{workTime}}}},\nand {\\ensuremath{\\mathsf{{Weight}}}}.\nThe user-defined objectives {\\ensuremath{\\mathsf{{cost}}}} and {\\ensuremath{\\mathsf{{workTime}}}}  involve\nrespectively $2$ and $5$ tasks and no requirement, whilst the pre-defined \n attributes {\\ensuremath{\\mathsf{{Weight}}}} involves $16$\ntasks plus all $4$ non-mandatory requirements. \nThis involves $3+2+5+0+0+16+4=30$  rational variables (recall\nRemark~\\ref{remark:onlynonzeros}). \nThere are also three binary preference relations \\eqref{eq:preferences}.\n\nIn the example reported in {\\S{}\\ref{{sec:goalmodels_example}}}\nwith different configurations, the tool returned the optimal solutions\nin negligible time \n(all took less than $0.02$ seconds).\n\nThis is not surprising: as mentioned in {\\S{}\\ref{{sec:background_goalmodels}}}, \n\nin previous empirical evaluation of OMT-encoded problems from formal\nverification,  OptiMathSAT \n successfully handled optimization problems with up\nto thousands Boolean/rational variables\n\\cite{sebastiani15_optimathsat}, so that\n\n hand-made CGMs resulting into SMT formulas with few tens of Boolean and \nrational variables, like that in {\\S{}\\ref{{sec:goalmodels_example}}}, are \nnot a computational challenge. \n\n\nIn perspective, since CGM-Tool is supposed to be used \nto design CGMs representing possibly-large projects, \nwe wonder how its\nautomated-reasoning functionalities will scale on large\nmodels. \n\nTo do this, we choose to build benchmark CGMs of increasing\nsize, by combining different instances of the schedule-meeting CGM of\n{\\S{}\\ref{{sec:goalmodels_example}}} in various ways, and testing them with\ndifferent combination of objectives. \n\n{\\vspace{2 mm}\\noindent{\\bf{{Experiment Setup.}}}}\n\nIn all our experiments CGMs were produced as follows, according to\nthree positive integer parameters $N$, $k$, and $p$, and some choices\nof objectives.\n\nGiven $N$  and $k$, we pick $N$ distinct instances of the\nschedule-meeting CGM of \n{\\S{}\\ref{{sec:goalmodels_example}}}, each with a fresh set of Boolean labels\nand\nrational variables, we create a fake root goal $G$ with\nonly one refinement $R$ whose source goals are the $N$ mandatory\nrequirements ``${\\ensuremath{\\mathsf{{Schedule   Meeting}}}}_i$'' of each CGM instance. \n\nHence,  the resulting CGM has\n$54\\cdot N+2$ nodes and $30\\cdot N$ rational variables (see\nFigure~\n\\ref{tabExpData_2} in Appendices\n).\n\nIn another group of experiments \n(see Figure~\n\\ref{tabExpData} in Appendices\n\n) \nwe dropped the non-mandatory requirements and their 4 direct\nsub-tasks, so that each instance contains $24$ goals, $2$ domain\nassumptions and $18$ refinements, and the resulting CGM has\n$44\\cdot N+2$ nodes and $26\\cdot N$ rational variables.  \n\n\n\n\nThen we randomly add $(k-1)\\cdot N$ contribution relations \n``{\\ensuremath{ {} \\xrightarrow{++} {}}}''\nand $N$ conflict relations ``{\\ensuremath{ {} \\overset{--}{\\longleftrightarrow} {}}}'' between tasks \nbelonging to different instances.  \n\nWhen binary preference relations are involved (see below), we also\nrandomly add $p\\cdot N$ binary preference relations, each involving two \n refinements of one same goal. \n\n\n\n\nIn each group of experiments we fix the definition of the objectives\nand we set the value of $k$ (and $p$ when applies), and increase the\nvalues of $N$. For every choice of $N$, we generate 100 instances\nof random problems as in the above schema, which we feed to our tool,\nand collect the median CPU times over the solved instances \n--including both encoding and solving\ntimes-- as well as the number of unrealizable instances as\nwell as the number of instances which OptiMathSAT could not solve\nwithin a timeout of $1000$ seconds. \n\n\n\n\\begin{remark}\n  We are aware that the CGMs produced with this \n  approach may not represent {\\em realistic} problems.\n  However, we stress the fact that here we focus only on providing a\n test on the {\\em\n    scalability} of our automated-reasoning functionalities. \nAlso, this technique allows us to {\\em increase monotonically} and\n{\\em tune} some\nessential features of the CGMs under test, which may significantly influence the performances: e.g., $N$ \nincreases linearly the number  of Boolean and rational\nvariables, $k$ (and, to some extent, $p$) increases the \nconnectivity of the graph and the ratio between \nunrealizable and realizable CGMs, whilst the choice of \nthe objectives influences the number of Boolean atoms per objective.\n\nImportantly, $k$ and $p$  also play an essential role in drastically reducing\n the {\\em symmetry} of the resulting CGMs, and insert some degree of randomness. \n\n\\end{remark}\n\nIn a first group of experiments \n\n(see Figures~\n\\ref{tabExpData}-\n\\ref{figRuntimeComp} in Appendix\n) \n\nwe consider the reduced version of the CGMs (i.e. \nwithout nice-to-have requirements) \nwithout random binary preference relations. We fix $k = 2, 4, 5, 8$.\nIn each setting, we run experiments on three functionalities:\n\\begin{itemize}\n\\item[a.] plain realizability check (without objectives),\n\\item[b.] single-objective optimization on {\\ensuremath{\\mathsf{{cost}}}}, {\\ensuremath{\\mathsf{{workTime}}}},\n  and {\\ensuremath{\\mathsf{{Weight}}}} respectively, \n \n\\item[c.] lexicographic optimization respectively on\n  {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{cost}}}}, {\\ensuremath{\\mathsf{{workTime}}}}, {\\ensuremath{\\mathsf{{Weight}}}}}}\\rangle}\\xspace} and on \n  {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}}, {\\ensuremath{\\mathsf{{workTime}}}}, {\\ensuremath{\\mathsf{{cost}}}}}}\\rangle}\\xspace}. \n\\end{itemize}\n{\\noindent}\nFirst, we notice that checking the realizability of the CGM, that is, \nfinding one realization or verifying there is none, requires\nnegligible time, even with huge CGMs ($> 8,000$ nodes, $> 5,000$\nrational variables) and even when \nthe CGM is not realizable. \n\nSecond, the  time taken to find optimal solutions on single objectives\nseem to depend more on the number of terms in the objective than on the\nactual size of the CGM: for {\\ensuremath{\\mathsf{{cost}}}} ($2\\cdot N$ terms) the solver can\nfind optimum solutions very quickly even with huge CGMs ($> 8.000$\nnodes, $> 5,000$\nrational variables) whilst with {\\ensuremath{\\mathsf{{Weight}}}} ($16\\cdot N$ terms) it can handle problems\nof up to\n $~\\approx{}400$ nodes and $~\\approx{}200$ rational variables. \nThird, lexicographic optimization takes more time than single-objective\noptimization, but the time mostly depends on the first objective in\nthe list. \n\nIn a second group of experiments\n\n(see\nFigures~\n\\ref{tabExpData_2}-\n\\ref{figRuntimeComp_Pref} in Appendix\n)\n\nwe consider the full version of the CGMs (with nice-to-have requirements) \nand introduce the random binary preference relations. \nWe fix $k=2$ and we run different experiments for $p=6$, $p=8$ and\n$p=12$. In each setting, we run experiments on three functionalities:\n\\begin{itemize}\n\\item[a.] plain realizability check (without objectives),\n\\item[b.] lexicographic optimization on\n  {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{numUnsatPrefs}}}},{\\ensuremath{\\mathsf{{numUnsatRequirements}}}},{\\ensuremath{\\mathsf{{numSatTasks}}}}}}\\rangle}\\xspace} (PRT), \n\\item[c.] lexicographic optimization on\n  {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{numUnsatRequirements}}}},{\\ensuremath{\\mathsf{{numUnsatPrefs}}}},{\\ensuremath{\\mathsf{{numSatTasks}}}}}}\\rangle}\\xspace} (RPT).\n\\end{itemize}\n\\noindent\n\nFirst, checking realizability is accomplished in negligible time even with\nhuge CGMs ($> 10,000$ nodes, $> 6,000$ rational variables), as before.  \n\nSecond, we notice that  optimal solutions, even with a three-level\nlexicographic combination of objectives, can be found with large\nCGMs  ($> 1,000$ nodes, $> 600$ rational variables). \n\n\n\nA few remarks are in order. \n\nFirst, when interrupted by a timeout, OptiMathSAT can be instructed to\nreturn the current best solution. Since OptiMathSAT typically takes most of its\ntime in fine-tuning the optimum and in checking  there is no better one\n(see \\cite{sebastiani15_optimathsat}), we envisage that often good\nsub-optimal solutions can be found even when optimal ones are out of\nreach. \n\nSecond, our CGMs are very large in breadth and \nsmall in depth, with a dominating percentage of tasks over the total\nnumber of goals. \nWe envisage that this may have made the number of terms in the\nsums defining {\\ensuremath{\\mathsf{{Weight}}}} and {\\ensuremath{\\mathsf{{numSatTasks}}}}{} unrealistically\nlarge wrt. the total size of the CGMs.\nThis underscores the need for\nfurther experimentation to confirm the scalability of our proposal.\n\nThird, in our experiments we did not consider user assertions which,\nif considered,\nwould force deterministic assignments and hence reduce drastically the size\nof the OMT search space. \n\n\n\\smallskip\nOverall, our evaluation showed that CGM-Tool always checks\nthe realizability of huge CGMs in negligible time and finds optimal\nrealizations on problems whose size ranges from few hundreds \nto thousands of nodes, mostly depending on the number of variables involved in\nthe objective functions. \n\n\n \n\n\n\n\n\n\\section{Related work}\n\\label{sec:related}\nWe next offer a quick overview of, and comparison with some the state\nof the art goal-oriented modeling languages. \n{~\\cite{Lapouchnian05}, ~\\cite{Jureta08}, and ~\\cite{Borgida13}} \nprovide better\nand deeper comparisons on requirements modeling languages and the\ngoal-oriented approach, including their advantages and limitations. \n\n{\\vspace{2 mm}\\noindent{\\bf{{{KAOS.}}}}}\nKAOS~\\cite{dardenne93} supports a rich ontology for requirements that goes well beyond goals, as well as a Linear Temporal Logic (LTL)-grounded formal language for constraints. This language is coupled with a concrete methodology for solving requirements problems. KAOS supports a number of analysis techniques, including obstacle, inconsistency and probabilistic goal analysis. However, unlike our proposal, KAOS does not support nice-to-have requirements and preferences, nor does it exploit SAT/SMT solver technologies for scalability.\n\n{\\vspace{2 mm}\\noindent{\\bf{{{$I^*$ and Tropos.}}}}} \n$i^*$~\\cite{Yu97} focuses on modelling actors for a requirements engineering problem (stakeholders, users, analysts, etc.), their goals and inter-dependencies. $i^*$ provides two complementary views of requirements: the Actor Strategic Dependency Model (SD model) and the Actor Strategic Rationale Model (SR model). Typically, SD models are used to analyze alternative networks of delegations among actors for fulfilling stakeholder goals, whilst SR models are used to explore alternative ways of fulfilling a single actor's goals. $i^*$ is expressively lightweight, intended for early stages of requirements analysis, and did not support formal reasoning until recent thesis work by Horkoff~\\cite{Horkoff12}. Tropos~\\cite{Castro02} is a requirements-driven agent-oriented software development methodology founded on $i^*$. Goal models can be formalized in Tropos by using Formal Tropos~\\cite{Fuxman04}, an extension of $i^*$ that supports  LTL for formalizing constraints. Alternatively, qualitative goal models can be used, briefly reviewed in~{\\S{}\\ref{{sec:background}}}. The main deficiencies of this work relative to our proposal is that Formal Tropos is expressive but not scalable, while qualitative goal models are variants of propositional logic, hence not too expressive.\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Techne and Liaskos.}}}}} \nTechne~\\cite{JuretaBEM10} is a recent proposal for a class of goal-modeling languages that supports nice-to-have goals and preferences, but is strictly propositional and has not been studied at all for reasoning and tractability. Liaskos~\\cite{Liaskos10,Liaskos12} has proposed extensions to qualitative goal models to support nice-to-have goals and preferences, as well as decision-theoretic concepts such as utility. This proposal is comparable to our proposal in this paper, but uses AI reasoners for reasoning (AI planners and GOLOG) and, consequently, does not scale very well relative to our proposal.\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Feature Models.}}}}}\nFeature models~\\cite{ClassenBH11} share many similarities with goal models: they are hierarchically structured, with AND/OR refinements, constraints and attributes. However, each feature represents a bundle of functionality or quality and as such, feature models are models of software specification, not requirements. Moreover, reasoning techniques for feature models are limited relative to their goal model cousins.\n\n\n\n\n\\section{Conclusions and Future Work}\n\\label{sec:concl} \nWe have proposed, a goal-based modeling language for requirements that\nsupports the representation of nice-to-have requirements, preferences,\nconstraints and more. Moreover, we have exploited automated reasoning\nsolvers in order to develop a tool that scales well as goal\nmodels grow to realistic sizes for real world requirements problems. \n\nNotice that, the goal model concept has been accepted and widely used \nin software engineering as well as requirements modeling for decades. \nOur claim in this paper is not to introduce a completely new modeling concept, \nrather our main contribution lies in the expressiveness of the new formalization \nof the constrained goal model and the automated reasoning functionalities of our CGM-Tool.\n\nAs future work, we planned to do an empirical validation of the CGM-Tool \nwith modelers and domain experts. We are currently working in this direction \nwithin our research group with PhD students and post-docs who are expert i\nn the modelling field. Next, we will extend the validation to industrial experts \nof different domains. We planned to do different case studies with \nreal-life-complex-large-scale goal model of a specific domain, such as \nAir-Traffic Control Management, healthcare, and smart cities and smart environments.\n\nIn the future, we plan to formalize {\\em {evolutionary}} versions of\nCGMs, which can handle evolution requirements problems\n~\\cite{ErnstBJ11}. For such problems, the goal models can be changed\neven after a solution has been implemented. Thus, given a modified CGM\nand its previous solution, we have to find a new solution that\nminimize the effort of applying changes. {Again, we plan to address\nthis problem via OMT encodings.}\n\n\n\n\\begin{acknowledgements}\nWe would thank Dagmawi\nNeway  for his technical support in developing CGM-Tool, and Patrick\nTrentin for assistance with the usage of OptiMathSAT. \n\\end{acknowledgements}\n\n\\bibliographystyle{spphys} \n\\bibliography{pg,mc,rs_refs,rs_ownrefs,rs_specific,sathanbook}\n\n\\newpage\n\n\n\n\n\\appendix\n\\section{Appendix: Data Tables and Plots}\n{\\noindent}\n{\\vspace{2 mm}\\noindent{\\bf{*}}}{Note for reviewers.} \n{\\em For the reviewers' convenience, \nin this appendix we report the tables and plots of our empirical\nresults. If the paper is accepted, we will summarize the data inside \n{\\S{}\\ref{{sec:expeval}}}, drop this appendix from the final paper and leave\nit in a publically-available extended version of the paper.}\n\n\n\\subsection{First Group of Experiments}\n\\input{exptable}\n\\input{expchart}\n\n\\FloatBarrier\n\\newpage\n\\subsection{Second Group of Experiments}\n\\input{exp2table} \n\\input{exp2chart}\n\n\n  \n\n", "itemtype": "equation", "pos": 70919, "prevtext": "}\n}\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} Constraints.}}}}}\nSuppose that, in order to achieve the nice-to-have requirement {\\ensuremath{\\mathsf{{Low\\-Cost}}}}, \nwe need to have a total cost smaller than 100\\euro{}. This can be expressed\nby adding the prerequisite constraint:\n${{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Low\\-Cost}}}}}}} = \\ldots \\wedge ({\\ensuremath{\\mathsf{{cost}}}} < 100) $.\nHence, e.g., due to \\eqref{eq:costlocalsmt}, \nevery realization that the tool generates automatically \nwhich satisfies {\\ensuremath{\\mathsf{{Low\\-Cost}}}} will not involve the task {\\ensuremath{\\mathsf{{Use Hotels And   Convention Centers}}}}. \n\nSimilarly to {\\ensuremath{\\mathsf{{cost}}}}, \none can introduce, e.g.,  another global numerical attribute {\\ensuremath{\\mathsf{{workTime}}}} \nto reason on working time, and \nestimate, e.g.,  that the total working time for {\\ensuremath{\\mathsf{{Schedule\\-Manually}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}}, {\\ensuremath{\\mathsf{{Email\\-Participants}}}}, {\\ensuremath{\\mathsf{{Call\\-Participants}}}}, \n{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}} are 3, 1, 1, 2, and 1\nhour(s), respectively, and state that the nice-to-have\nrequirement \n {\\ensuremath{\\mathsf{{Fast\\-Schedule}}}} must require a global time smaller than 5 hours.\n\n{\nAs a result of this process, the system will produce the following\nconstraints. \n\\begin{eqnarray}\n\\label{eq:timelocalconstraint}\n&&({\\ensuremath{\\mathsf{{workTime}}}} =  \\sum_{E_i \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{workTime_{E_i}}}}})\\\\\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Fast\\-Schedule}}}}}}} &{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime}}}} <  5)\\\\\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Schedule\\-Manually}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Schedule\\-Manually}}}}} = 3)\\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} & ... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Schedule\\-Automatically}}}}} = 1)\\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Email\\-Participants}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Email\\-Participants}}}}} = 1) \\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Call\\-Participants}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Call\\-Participants}}}}} = 2) \\\\\n\\nonumber\n{{\\phi}^{+}_{{~{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}}}}} \n&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace} &... \\wedge ({\\ensuremath{\\mathsf{{workTime_{Collect\\-From\\-System\\-Calendar}}}}} = 1),\n\\end{eqnarray}\nplus the corresponding negative prerequisite constraint, which force\nthe corresponding numerical attributes to be zero.\n}\n\nNotice that one can build combinations of numerical attributes.\nFor instance, if labor cost is $35\\euro/hour$, then one can redefine\n{\\ensuremath{\\mathsf{{cost}}}} as \n$({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}}+35\\cdot{\\ensuremath{\\mathsf{{workTime}}}})$,\nor introduce  a new global variable {\\ensuremath{\\mathsf{{totalCost}}}} as \n$({\\ensuremath{\\mathsf{{totalCost}}}} = {\\ensuremath{\\mathsf{{cost}}}}+35\\cdot{\\ensuremath{\\mathsf{{workTime}}}})$.\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Multiple Objectives.}}}}} \nStakeholders may define rational-valued {\\em {objectives}}\n$obj_1,...,obj_k$ to optimize (i.e., maximize or minimize) as\nfunctions of Boolean and numerical variables\n---e.g., \n${\\ensuremath{\\mathsf{{cost}}}}$, {\\ensuremath{\\mathsf{{workTime}}}}, \n${\\ensuremath{\\mathsf{{totalCost}}}}$ can be suitable objectives, {\\ensuremath{\\mathsf{{Weight}}}} is\nconsidered a pre-defined objective--- and ask the tool to automatically \ngenerate realization(s) which optimize one objective, or some\ncombination of more objectives (like {\\ensuremath{\\mathsf{{totalCost}}}}), or which\noptimizes lexicographically an ordered list of objectives\n{\\ensuremath{\\langle{{obj_1,obj_2,...}}\\rangle}\\xspace}.\n\\ignore{\n~\\footnote{{We recall that\n a solution optimizes\n    lexicographically an ordered list of objectives\n    {\\ensuremath{\\langle{{obj_1,obj_2,...}}\\rangle}\\xspace} if it makes $obj_1$ optimum\n  and, if more than one such solution exists, it makes also $obj_2$\n  optimum, ..., and so on. }}}\n\n\nOther examples of pre-defined objectives stakeholders may want to\n minimize, either singularly or in combination\nwith other objectives, are the number of \nnon-mandatory requirements which are not satisfied (namely\n  {\\ensuremath{\\mathsf{{numUnsatRequirements}}}}{}) and the number of \ntasks which need to be satisfied (namely\n  {\\ensuremath{\\mathsf{{numSatTasks}}}}{}).\n\n\n\nFor example, the previously-mentioned optimum-weight realization of\nFigure~\\ref{figCGMRelization} \nis such that\n~${\\ensuremath{\\mathsf{{Weight}}}} = -65$,\n~${\\ensuremath{\\mathsf{{workTime}}}} = 4$ and \n~${\\ensuremath{\\mathsf{{cost}}}} = 80$.\nOur CGM has many different\nminimum-weight realizations s.t. \n~${\\ensuremath{\\mathsf{{Weight}}}} = -65$, \nwith different values of {\\ensuremath{\\mathsf{{cost}}}} and {\\ensuremath{\\mathsf{{workTime}}}}. \nAmong them, \n it is possible to search, e.g., for the realizations with minimum {\\ensuremath{\\mathsf{{workTime}}}},\nand among these  for those with minimum {\\ensuremath{\\mathsf{{cost}}}}, by setting\nlexicographic minimization with order\n{\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}},{\\ensuremath{\\mathsf{{workTime}}}},{\\ensuremath{\\mathsf{{cost}}}}}}\\rangle}\\xspace}. \n\nThis results into one realization with ${\\ensuremath{\\mathsf{{Weight}}}} = -65$,\n${\\ensuremath{\\mathsf{{workTime}}}} =  2$ and ${\\ensuremath{\\mathsf{{cost}}}}=0$ achieving all the nice-to-have\nrequirements, as shown in Figure~\\ref{figCGMLex}, which  requires\n accomplishing the tasks: \n{\\ensuremath{\\mathsf{{Characterise\\-Meeting}}}},\n{\\ensuremath{\\mathsf{{Collect\\-From\\-System\\-Calendar}}}},\n{\\ensuremath{\\mathsf{{Get\\-Room\\-Suggestions}}}},\n{\\ensuremath{\\mathsf{{Cancel\\-Less\\-Important\\-Meeting}}}},\n{\\ensuremath{\\mathsf{{Schedule\\-Automatically}}}},\n{\\ensuremath{\\mathsf{{Confirm\\-Occurrence}}}},\n{\\ensuremath{\\mathsf{{Good\\-Participation}}}},\n{\\ensuremath{\\mathsf{{Minimal\\-Conflicts}}}},\n{\\ensuremath{\\mathsf{{Collection\\-Effort}}}}, \n{\\ensuremath{\\mathsf{{Matching\\-Effort}}}},\nand which requires the domain assumptions:\n{\\ensuremath{\\mathsf{{Participants\\-Use\\-System\\-Calendar}}}},\n{\\ensuremath{\\mathsf{{Local\\-Room\\-Available}}}}.\n(This was found automatically by our CGM-Tool of {\\S{}\\ref{{sec:implementation}}}\n\nin $0.016$ seconds on an Apple MacBook Air laptop.)\n\n\n\\ignore{\n\\begin{mcchange}\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Priorities.}}}}} \nIt is also possible to express the stakeholders preferences by using prefer-relation, denoted as {\\ensuremath{{A}\\succeq {B}}}, between two elements or refinements. {\\ensuremath{{A}\\succeq {B}}} means that we would rather having $A$ satisfied (while not care about $B$) than having $B$ satisfied but not $A$ (this does not have any constraint over $A$ and $B$ to be satisfied at the same time). For example, let say we only want to minimize the total weight of our example goal model, we do not care about the cost and the time, but rather we would like to add some preferences: (i) we would prefer to collect the timetable {\\ensuremath{\\mathsf{{By\\-System}}}} over {\\ensuremath{\\mathsf{{By\\-Person}}}}, and (ii) we would prefer {\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}} over the others choice of refining {\\ensuremath{\\mathsf{{Find\\-A\\-Suitable\\-Room}}}}. Then with our tool the output realization of the model will also be the one showed in Figure \\ref{figCGMLex} instead of the one in Figure \\ref{figCGMRelization} (This solution was found in $0.018$ seconds on an Apple MacBook Air laptop.)\n\\end{mcchange}\n}\n\n\n{\\vspace{2 mm}\\noindent{\\bf{{{Preferences via Binary Preference Relations.}}}}}\n\nIn general, stakeholders might not always be at ease in assigning\n numerical values to state their preferences, or in dealing with\n {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} terms, constraints and objectives. \nThus, as a more user-friendly solution, it \nis also possible for stakeholders to express their preferences \nin a more direct way by stating explicitly a list of\n{\\em binary preference relations}, denoted as ``{\\ensuremath{{P_1}\\succeq {P_2}}}'',\nbetween pairs of elements of the same kind (e.g. pair of requirements,\nof tasks, of domain assumptions) or pairs of\nrefinements. ``{\\ensuremath{{P_1}\\succeq {P_2}}}'' means that one prefers to have\n$P_1$ satisfied than $P_2$ satisfied, that is, that he/she would rather avoid\nhaving $P_1$ denied and $P_2$ satisfied. In the latter case, we say that a\npreference is unsatisfied. \nNotice that {\\ensuremath{{P_1}\\succeq {P_2}}} \nallows for having both $P_1$ and $P_2$\nsatisfied or both denied.\n\nIn CGM-Tool, binary preference relations can be expressed either graphically, via a\n``prefer'' arc ``{\\ensuremath{ {P_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {P_2}}}'', or via and ad-hoc menu window.\nOnce a list of binary preference relations is set, the system\ncan be asked to consider the number of unsatisfied preference relations\nas an objective (namely {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{}), \nand it searches for a realization which minimizes it. \n\nIt is also possible \nto combine such objective lexicographically with\nthe other objectives. \n\nFor example, suppose we want to minimize the total weight of our\nexample goal model. As  previously mentioned, there is more than one\nrealization with minimum weight $-65$. \nUnlike the previous example, as a secondary choice we\ndisregard {\\ensuremath{\\mathsf{{workTime}}}} and {\\ensuremath{\\mathsf{{cost}}}}; rather, we express also the\nfollowing  binary preferences:\n\\begin{eqnarray}\n\\label{eq:preferences}\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{By\\-System}}}}}\\succeq {{\\ensuremath{\\mathsf{{By\\-Person}}}}}}},\\\\\n\\nonumber\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}}}\\succeq {{\\ensuremath{\\mathsf{{Use\\-Partner\\-Institutions}}}}}}},\\\\\n\\nonumber\n&&{\\ensuremath{{{\\ensuremath{\\mathsf{{Use\\-Local\\-Room}}}}}\\succeq {{\\ensuremath{\\mathsf{{Use\\-Hotels\\-And\\-Convention\\-Centers}}}}}}},\n\\end{eqnarray}\n{\\noindent} \nand set {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} as secondary objective to\nminimize after {\\ensuremath{\\mathsf{{Weight}}}},\nthat is, we set the lexicographic order {\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{Weight}}}},{\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{}}}\\rangle}\\xspace}.\nThen our tool returned the same realization of\nFigure~\\ref{figCGMLex} ---that is, the same as with minimizing \n{\\ensuremath{\\mathsf{{workTime}}}} and {\\ensuremath{\\mathsf{{cost}}}} as secondary and tertiary choice---\n instead of that in Figure \\ref{figCGMRelization}. (This solution was found in $0.018$ seconds on an Apple MacBook Air laptop.)\n\n\n\n\n\n\n\\section{Abstract Syntax and Semantics}\n\\label{sec:goalmodels}\n\\label{sec:goalmodels_structure}\n{In this section we describe formally the abstract syntax and\n  semantics of CGMs. \n\n\\subsection{Abstract Syntax}\n}\n{We introduce first some general definitions.}\n\\label{def:gg}\n\\noindent\nWe call a {\\em {goal graph}} {\\ensuremath{\\mathcal{D}}\\xspace} a directed acyclic graph (DAG)\n  alternating {element nodes} (hereafter ``elements'')  and {refinement\n    nodes} (``refinements'', collapsed into bullets), s.t.:\n$(a)$ each element has from zero to many outgoing edges to\n  distinct refinements\n  and from zero to many incoming edges from distinct refinements;\n$(b)$ each refinement node has exactly one outgoing edge to an\n  element ({\\em {target}}) and one or more incoming edges from distinct\n  elements ({\\em {sources}}). \n\n{\n\\noindent\n\nWe call a {\\em {root element node }} any element node that has no\n  outgoing refinement edges, a {\\em {leaf element node}} any (non-root) element\n  node that has no incoming refinement edges, and an {\\em {internal     element node}} any other element node.~\n\nNotice that, by construction, only element nodes can be\n  roots and leaves of a goal graph. (Hereafter we will usually drop \n  the word \"node\", simply saying \"refinement\" for \"refinement node\",\n  \"element\" for \"element node\", etc.)\n  \nThe sets of root, leaf and internal element nodes of a goal graph\n{\\ensuremath{\\mathcal{D}}\\xspace} are denoted as {\\em {{\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}}, {\\em {{\\ensuremath{{\\sf Leaves}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}},\n{\\em {{\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}} respectively. \n\nGiven a refinement  $R$\n with outcoming edge to the element\n $E$ and incoming edges from the element s ${{E}_1, \\ldots,{E}_{{n}}}$,\nwe call ${{E}_1, \\ldots,{E}_{{n}}}$ the {\\em {source elements}} of $R$ and $E$ the\n{\\em {target element}} of $R$, which are denoted by \n{\\em {{\\ensuremath{{\\sf Sources}({R})}\\xspace}}} and {\\em {{\\ensuremath{{\\sf Target}({R})}\\xspace}}} respectively. We say that \n$R$ is {\\em {a refinement of $E$}} and that \n{\\em {$R$ refines $E$ into ${{E}_1, \\ldots,{E}_{{n}}}$}}, denoted ``{\\ensuremath{ {({{E}_1, \\ldots,{E}_{{n}}})} \\xrightarrow{R} {E}}}''.\n\nThe set of refinements of an element $E$\nare denoted with {\\em {{\\ensuremath{{\\sf Refinements}({E})}\\xspace}}}. \n} \n\n\n\\noindent\nElements are either {\\em {goals}} or {\\em {domain assumptions}}, subject to the following constraints:\na domain assumption cannot be a root element;\nif the target of a refinement $R$ is a domain assumption, then it sources must be only  domain assumptions;\nif the target of a refinement $R$ is a goal,\nthen at least one of its sources must be a goal.\nWe call root goals and leaf goals {\\em {requirements}} and\n{\\em {tasks}} respectively.\n\n{\n\n\n\\input{goalmodels_table}\n}\nNotationally, \nwe use the symbols \n$R$, $R_j$ for  labeling refinements, \n$E$, $E_i$ for generic elements (without specifying \nif goals or domain assumptions), \n$G$, $G_i$ for goals, \n$A$, $A_i$ for domain assumptions.\n{\nGraphically (see Figure~\\ref{figGMEx})\n we collapse refinements nodes into one bullet, so\nthat we see a refinement as an aggregation of edges from a set of\nother goals.\n\n\n\n}\n\n{(See Table~\\ref{tabSumGM}.)}\n\n{\nHence, in a goal graph we consider element nodes as the only nodes,\nand refinements as (aggregations of) edges from a group of source\nelements to a target element.\n}\n\n\n\n\n\n\n\\begin{definition}[Constrained Goal Model] \n\n\\label{def:cgm}\nA {\\em {Constrained Goal Model (CGM)}} is a tuple ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$, s.t.\n\\begin{itemize}\n\\item ${\\ensuremath{\\mathcal{B}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\mathcal{G}}\\xspace}\\cup{\\ensuremath{\\mathcal{R}}\\xspace}\\cup{\\ensuremath{\\mathcal{A}}\\xspace}$ is a set of atomic\n  propositions, where\n${\\ensuremath{\\mathcal{G}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{G_1,...,G_N\\}$,\n${\\ensuremath{\\mathcal{R}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{R_1,...,R_K\\}$,\n${\\ensuremath{\\mathcal{A}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\{A_1,...,A_M\\}$ are respectively sets of \n{goal},\n{refinement} and\n{domain-assumption labels}.\nWe denote with {\\ensuremath{\\mathcal{E}}\\xspace} the set of element labels:\n${\\ensuremath{\\mathcal{E}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\mathcal{G}}\\xspace}\\cup{\\ensuremath{\\mathcal{A}}\\xspace}$;\n\\item {\\ensuremath{\\mathcal{N}}\\xspace} is a set of numerical variables in the rationals;\n\n\\item {\\ensuremath{\\mathcal{D}}\\xspace} is a goal graph, s.t. all its goal nodes are univocally labeled\n  by a goal label in {\\ensuremath{\\mathcal{G}}\\xspace}, all its refinements are univocally\n  labelled by a refinement label in {\\ensuremath{\\mathcal{R}}\\xspace},\n and all its domain assumption are univocally labeled\n by a assumption label in {\\ensuremath{\\mathcal{A}}\\xspace};\n\\item $\\Psi$ is a {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} formula on {\\ensuremath{\\mathcal{B}}\\xspace} and {\\ensuremath{\\mathcal{N}}\\xspace}.\n\n\\end{itemize}\n\\end{definition}\n\n\n\\noindent\nA CGM is thus an and-or directed acyclic graph (DAG) of\n\\emph{elements}, as \nnodes, and \\emph{refinements}, as (grouped) edges, which are labeled\nby atomic propositions and can be augmented with arbitrary constraints\nin form of {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} formulas --typically conjunctions of smaller global\nand local constraints-- on the element and refinement labels and on\nthe numerical variables.  \n\n{\nNotice that each non-leaf element $E$ is implicitly or-decomposed into \nthe set of its incoming refinements ${\\ensuremath{\\{{{R_i}}\\}}\\xspace}$, and that each refinement $R$\nis and-decomposed into the set of its source elements ${\\ensuremath{\\{{{E_j}}\\}}\\xspace}$.~\n(\nIn fact, by combining the propositional encodings of goal refinement\nand closed world in Table~\\ref{tabSumGM}, we can infer the formulas\n$E \\ensuremath{\\leftrightarrow}\\xspace (\\bigvee_i R_i)$  and $R \\ensuremath{\\leftrightarrow}\\xspace (\\bigwedge_j E_j)$.\n\\footnote{{We recall that in Boolean logic $\\bigwedge_i (\n    R_i\\ensuremath{\\rightarrow}\\xspace E)$\n  is equivalent to $E \\ensuremath{\\leftarrow}\\xspace (\\bigvee_i R_i)$.}}\n)\n\n}\n\nIntuitively, a CGM describes a (possibly complex) combination of\nalternative ways of realizing a set of requirements in terms \nof a set of tasks, under certain domain assumptions.\n\n\\begin{figure}[t]\n  \\centering\n\\resizebox{\\textwidth}{!}{\n\\input{fig_cgmvsgm.pdf_t}  \n}  \\caption{{A simple CGM (left) and its translation into standard\n      and-or goal model format (right). It is necessary to\n      introduce two auxiliary goals\n    $G'$ and $G''$ to encode the refinements $R_1$ and $R_2$.}}\n  \\label{fig:cgmvsgm}\n\\end{figure}\n\n{\n{\nNotice that CGMs are more succinct in terms of number of goals \nthan standard and-or decompositions:\nwhereas a standard $n$-ary and-decomposition [resp. or-decomposition] of a\ngoal can be represented straightforwardly in a CGM by \none refinement with $n$ sources [resp. $n$ one-source refinements],\nin order to represent a CGM decomposition with $n$ non-unary refinements by\nmeans of standard and-or decomposition we need  introducing $n$ \nnew auxiliary intermediate goals to encode refinements, which CGMs\nencode natively.\n(See Figure~\\ref{fig:cgmvsgm}.) We recall from\n{\\S{}\\ref{{sec:goalmodels_example}}} that refinements do not \nneed to be explicitly labeled unless strictly necessary.\n}}\n\n\nIn general, the user might not be at ease in defining\na possibly-complex\n{\\em global} {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}{} formula $\\Psi$ to encode constraints among elements\nand refinements, plus numerical variables. \n\n To this extent, as mentioned in {\\S{}\\ref{{sec:goalmodels_example}}},\napart from the possibility of defining global formulas,\n CGMs provide  constructs allowing the\nuser to encode {\\em graphically} and {\\em locally} desired constraints\nof frequent usage: {\\em {relation edges}}, {\\em {prerequisite constraints}}\n${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$ and ${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$ and {\\em {user assertions}}.\nEach is automatically converted into a simple {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} formula \nas follows, and then conjoined to $\\Psi$.\n\n\n\\begin{itemize}\n\\item[{\\em Element-contribution edges},] \n  ${\\ensuremath{ {E_1} \\xrightarrow{++} {E_2}}}$, { meaning that \nsatisfying $E_1$ forces $E_2$ to be satisfied (but not vice versa). \n \n \nThey }\nare encoded into  the formula $(E_1\\ensuremath{\\rightarrow}\\xspace E_2)$.\n(The edge\n${\\ensuremath{ {E_1} \\overset{++}{\\longleftrightarrow} {E_2}}}$ can be used to denote the merging of the\ntwo contribution edges\n${\\ensuremath{ {E_1} \\xrightarrow{++} {E_2}}}$ and\n${\\ensuremath{ {E_2} \\xrightarrow{++} {E_1}}}$ into one.)\n\n\\item[{\\em Element-conflict edges},] \n  ${\\ensuremath{ {E_1} \\overset{--}{\\longleftrightarrow} {E_2}}}$, {meaning that \n$E_1$ and $E_2$ cannot be both\n  satisfied. \n\n\nThey }\nare encoded into the formula\n$\\neg (E_1\\wedge E_2)$.\n\n\n\n\n\n\\item[{\\em Refinement-binding edges},] \n\n  ${\\ensuremath{ {{{R_1}}}{\\longleftrightarrow} {{{R_2}}}}}$, \n{meaning that, if both \nthe target goals of $R_1$ and $R_2$ (namely $E_1$ and  $E_2$\nrespectively) are satisfied, \nthen $R_1$ refines $E_1$  if and only if \n$R_2$ refines $E_2$. They\n\n\n\n\n\n\n}\nare encoded into the formula \n$(E_1 \\wedge E_2) \n\\ensuremath{\\rightarrow}\\xspace \n({{R_1}}\\ensuremath{\\leftrightarrow}\\xspace{{R_2}})$.\n\n\n\\item[{\\em Prerequisite constraints},] ${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$ \n[resp. ${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$]\nare\n  encoded into the formulas \n$(G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{G}}})$ and\n$(\\neg G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{G}}})$ \n[resp. \n$(R\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{R}}})$ and\n$(\\neg R\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{R}}})$].\n\n\\item[{\\em User assertions},] $E_i:=\\top$ and $E_j:=\\bot$, are\n  encoded into the formulas $(E_i)$, $(\\neg E_j)$.\n\\end{itemize}\n\\noindent\n\n\nThe following are instead encoded\ninto {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} ``soft''~\n\\footnote{{In constraint programming and other related disciplines\n    (e.g. MaxSAT, MaxSMT, OMT) constraints which must be satisfied are\n  called ``hard'', whereas constraints which are preferably satisfied\n  but which can be safely violated, although paying some penalty, are\n  called ``soft''.}}\n constraints:\n\\begin{itemize}\n\\item[{\\em Preference edges},] \n${\\ensuremath{ {E_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {E_2}}}$ (resp. ${\\ensuremath{ {R_1} \\overset{\\text{\\tiny prefer}}{\\longrightarrow} {R_2}}}$ ), and their\nequivalent \n{\\em binary preference relations}\n${\\ensuremath{{E_1}\\succeq {E_2}}}$ (resp. ${\\ensuremath{{R_1}\\succeq {R_2}}}$ ), are implemented into the soft constraint\n$\\phi_{{\\ensuremath{{E_1}\\succeq {E_2}}}}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}(E_1 \\vee (\\neg E_2))$ \n(resp. $\\phi_{{\\ensuremath{{R_1}\\succeq {R_2}}}}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}(R_1 \\vee (\\neg R_2))$).\n(Notice that $E_1$ and $E_2$ should be of the same kind, i.e. they must \nbe  both tasks, or both requirements, or both refinements, \nor both intermediate goals, or both domain\nassumptions.) \n\\end{itemize}\n\nUnlike other constraints, these soft constraints \nare {\\em not} added directly to $\\Psi$. Rather, it is added to $\\Psi$ \nthe following {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} constraint, which defines \na numeric Pseudo-Boolean {\\em cost function}:\n\n\\begin{eqnarray}\n\\label{eq:costpref}\n ({\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} &=&\n\\sum_{{\\ensuremath{\\langle{{{E_i}{E_j}}}\\rangle}\\xspace}\\in {\\ensuremath{\\mathcal{P}}\\xspace}}\n{\\sf ite}(\\phi_{{\\ensuremath{{E_i}\\succeq {E_j}}}},0,1) +\n\n\n\\sum_{{\\ensuremath{\\langle{{{R_i}{R_j}}}\\rangle}\\xspace}\\in {\\ensuremath{\\mathcal{P}}\\xspace}} {\\sf ite}(\\phi_{{\\ensuremath{{R_i}\\succeq {R_j}}}},0,1)), \n\\end{eqnarray}\n\n\\noindent\nwhere ${\\ensuremath{\\mathcal{P}}\\xspace}$ is the list of binary preference relations, and\n``${\\sf ite}(\\phi_{*},0,1)$\" denotes an\nif-then-else arithmetical term, which is evaluated to 0 if $\\phi_{*}$\nis evaluated \nto true, to 1 otherwise. Hence, {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} counts the number of\nunsatisfied preferences.~\n\n\n(In practice, OMT solvers like\n  OptiMathSAT \\cite{st_cav15} provide more efficient ad-hoc encodings\nfor soft constraints, which we have exploited\n in the implementation of CGM-Tool; we refer the reader \nto \\cite{st_cav15} for details.)\n\n\n\n\nNotice that, unlike refinements, relation edges and preference edges \nare allowed to create\nloops, possibly involving refinements. \n\n\n\n\n\n\\ignore{\nIt is easy to provide the user the possibility of defining, both\nglobally and locally, more\ngeneral and intuitive Boolean\nconstraints (e.g., \n$\\mathsf{{Requires}}\\left({E_1,E_2}\\right)$, \n$\\mathsf{{AtMost}}\\left({N,\\{E_1,...,E_n\\}}\\right)$)\n with no need for the user to define\nthe corresponding complicate propositional formulas. \n}\n\n\\ignore{\nSecond, it is made possible to add ``local'' pre-requisite constraints to goal\n  nodes $G$  or to refinements $R$:\n\n\nfor each goal ${{G}}$ it is possible to introduce locally  a pair \nof propositional constraints ${\\bigl\\{ {{{\\phi}}^{+}_{{{G}}}}, {{{\\phi}}^{-}_{{{G}}}}\\bigr\\}}$  on {\\ensuremath{\\mathcal{B}}\\xspace}, so that \n ${{\\phi}^{+}_{{G}}}$ (resp. ${{\\phi}^{-}_{{G}}}$) must be\n satisfied whenever the goal ${{G}}$ is  \nsatisfied (resp. denied), but not vice versa.\n This corresponds to conjoining  to $\\Psi$ the formulas\n$(G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{+}_{{G}}})$ \nand\n$(\\neg G\\ensuremath{\\rightarrow}\\xspace {{\\phi}^{-}_{{G}}})$ respectively.\nThe same holds for each requirements $R$. \n \nThird, we provide the user the possibility of defining, both\nglobally and locally, more\ngeneral and intuitive Boolean\nconstraints (e.g., \n$\\mathsf{{Requires}}\\left({E_1,E_2}\\right)$, \n$\\mathsf{{AtMost}}\\left({N,\\{E_1,...,E_n\\}}\\right)$)\n with no need of defining\nthe corresponding complicate propositional formulas. \n\nFinally, it is made possible to force [unforce]  interactively each \nelement $E_i$ to be satisfied or\n  denied.~\n\n  This corresponds to conjoining to [dropping from] $\\Psi$ the unit\n  clauses $(E_i)$ or $(\\neg E_i)$ respectively.  The same holds for\n  each requirements $R_j$.  We call these unit clauses the\n  user {\\em {assertions}}.\n\nFor example, typically the user may try interactively to force\nrequirements to be satisfied to achieve a desired result, and/or to\nforce effortful tasks be denied, to reduce the effort; we call the\nformer {\\em {mandatory requirements}}.  The user may also \ninteractively force\nsome domain assumption to be satisfied or denied in order to investigate the\neffects of such assertions.\n}\n\n{\nFinally we provide the user {of a list of\n  syntactic-sugaring constructs, which allow for} defining, both\nglobally and locally, the most\nstandard and intuitive \nconstraints among assumption, goal and refinement labels,\n with no need of defining\nthe corresponding complicate or less-intuitive propositional formulas. \n(In what follows, $P_1,...,P_n$ denote atomic propositions in {\\ensuremath{\\mathcal{B}}\\xspace}.)\n\n\\begin{itemize}\n\\item[$\\mathsf{{Alt}}\\left({P_1,P_2}\\right)$] denotes the fact\n$P_1$ and $P_2$ are alternative, e.g., that one and only one of them \nis satisfied. \nThis is encoded by the formula $(P_1\\ensuremath{\\leftrightarrow}\\xspace \\neg P_2)$. \n\\item[$\\mathsf{{Causes}}\\left({P_1,P_2}\\right)$] denotes the fact\n  that satisfying ${{P_1}}$  causes ${{P_2}}$ to be satisfied.\nThis is\nencoded by the formula $(P_1\\ensuremath{\\rightarrow}\\xspace P_2)$. \n\\item[$\\mathsf{{Requires}}\\left({P_1,P_2}\\right)$] denotes the fact\n  that satisfying ${{P_1}}$ requires ${{P_2}}$ to be satisfied.\nThis is encoded by the formula $(P_1\\ensuremath{\\rightarrow}\\xspace P_2)$. \n\n\\item[$\\mathsf{{AtMostOneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact that at most\n  one of $\\{P_1,...,P_n\\}$ must be satisfied. This is  encoded \nby the formula  $\\bigl(\\bigwedge_{1 \\leq i < j \\leq n} (\\neg P_i \\vee\n\\neg P_j)\\bigr)$.  \n\n\\item[$\\mathsf{{AtLeastOneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact\n  that at least one of $\\{P_1,...,P_n\\}$ must be satisfied. This is\n encoded by the formula $\\bigl(\\bigvee_{1 \\leq i \\leq n}\n  P_i\\bigr)$.\n\\item[$\\mathsf{{OneOf}}\\left({\\{P_1,...,P_n\\}}\\right)$] denotes the fact\n  that exactly one of $\\{P_1,...,P_n\\}$ must be satisfied. This is\n   encoded by the conjunction of the previous two formulas.\n\n\\end{itemize}\n} \n\n\n\\subsection{{Semantics}}\n\nThe semantics of CGMs is formally defined as follows.\n\n\n\n\n\n\n\\begin{definition}[Realization of a CGM]\n\n\\label{def:realization}\n{Let ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM.\nA {\\em {realization}} of {\\ensuremath{\\mathcal{M}}\\xspace} \nis a {\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation $\\mu$ over ${\\ensuremath{\\mathcal{B}}\\xspace}\\cup{\\ensuremath{\\mathcal{N}}\\xspace}$\nsuch that:\n}\n\\begin{aenumerate}\n\\item \n$\\mu \\models ((\\bigwedge_{i=1}^{n} E_i) \\leftrightarrow R) \\wedge  (R\n\\rightarrow E)$ for each refinement  ${\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}}$;\n\\item \n$\\mu\\models \\bigl( E \\rightarrow (\\bigvee_{R_i \\in \\rm{Ref}(E)}\nR_i)\\bigr)  $, for each non-leaf element $E$;\n\n\\item $\\mu\\models\\Psi$.\n\\end{aenumerate}\n\n\n\n\\noindent\nWe say that {\\ensuremath{\\mathcal{M}}\\xspace}\n\nis {\\em {realizable}} if it has at least one realization, \n {\\em {unrealizable}}\n\notherwise.\n\n\\end{definition}\n\n{ \nFrom Definition~\\ref{def:realization}, \na realization \nrepresents  a sub-graph of the CGM, such that:\n\\begin{enumerate}\n\\item If a non-leaf goal is in a realization sub-graph, then at least one of its refinements is included in the realization.\n\\item If a refinement is in a realization sub-graph, then all of its sub-elements is included in the realization.\n\\item If an element is included in a realization sub-graph, and it is a contribution of another element, then that other element is also included in the realization.\n\\item In a realization sub-graph, there are no two elements that have conflict relationship.\n\\item The realization complies with all user-defined constraints of the goal model.\n\\end{enumerate}\nIntuitively, a realization represents the alternatives of achieving the root goal(s).\n} \n\n\n\\noindent\n\nIn a realization,\n\n\n each element $E$ or refinement $R$ can be\neither \\emph{satisfied} or \\emph{denied} (i.e., their label can be\nassigned to $\\top$ or $\\bot$ respectively by $\\mu$). \n\nIf an element $E$ is not a leaf, then it can be satisfied only by satisfying\nthe set of source elements ${{E}_1, \\ldots,{E}_{{n}}}$ \nof one of its refinements\n${\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}}$.\n\nIf $\\mu$ satisfies a refinement ${{R}}$ of an element $E$, i.e.,\nit satisfies all the source elements ${{E}_1, \\ldots,{E}_{{n}}}$, then it \nsatisfies the element $E$, but not vice versa (condition $(a)$). \n\n\nFor a non-leaf element to be satisfied, at least one\nof its refinements must be satisfied (condition $(b)$).\nWe call this fact  {\\em {Closed World Assumption (CWA)}}.\n\n The satisfiability or deniability of each element or refinement can be\n further constrained by all the constraints defined inside the formula\n $\\Psi$:  every realization $\\mu$ \n must satisfy such constraints (condition $(c)$). \n\nNotice that, by fulfilling condition $(c)$,  \n a realization must implicitly comply also with all the\nrelation edges, with the user assertions and\n with the\nlocal pre-requisite constraints ${\\bigl\\{ {{{\\phi}}^{+}_{{{E}}}}, {{{\\phi}}^{-}_{{{E}}}}\\bigr\\}}$ and\n${\\bigl\\{ {{{\\phi}}^{+}_{{{R}}}}, {{{\\phi}}^{-}_{{{R}}}}\\bigr\\}}$, \nbecause the corresponding formulas are conjuncts of $\\Psi$. \n\n\nThus $\\Psi$ contains also the  global and local\n{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} constraints over global and local numerical attributes\n(e.g. \n${\\ensuremath{\\mathsf{{Low Cost}}}}\\ensuremath{\\rightarrow}\\xspace ({\\ensuremath{\\mathsf{{cost}}}} \\leq 100)$,\n${\\ensuremath{\\mathsf{{Use Partner Institutions}}}}\\ensuremath{\\rightarrow}\\xspace ({\\ensuremath{\\mathsf{{cost_{Use Partner     Institutions}}}}} = 80)$, and the definitions of \nobjectives\n (e.g., $({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}}$).\n \n  \n\n   \\begin{remark}\n\\label{remark:onlynonzeros}\n   Importantly, in the definition of objectives only\n   non-zero terms of the sums need to be considered. (E.g., the sum\nin $({\\ensuremath{\\mathsf{{cost}}}} = \\sum_{E   \\in {\\ensuremath{\\mathcal{E}}\\xspace}}{\\ensuremath{\\mathsf{{cost_{E}}}}})$ can be safely\nrestricted to the elements \n{\\ensuremath{\\mathsf{{Use Partner Institutions}}}} and  {\\ensuremath{\\mathsf{{Use Hotels And Convention   Centers}}}}.)\nThis allows for reducing drastically the number of rational variables \ninvolved in the encoding.      \n   \\end{remark}\n\n\n\n\nA realization $\\mu$ for a CGM\n${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$  \nis represented graphically as the  sub-graph of {\\ensuremath{\\mathcal{D}}\\xspace} where \nall the denied element and refinement nodes are eliminated. \n\n\n\n\n\n\\section{Automated Reasoning with Constrained Goal Models}\n\\label{sec:functionalities}\n{In this section we describe how to perform automated\n  reasoning functionalities on CGMs by encoding them into SMT and OMT.}\n\n\n\n\\subsection{Encoding of Constrained Goal Models}\n\\label{sec:goalmodels_encodings}\n\\begin{definition}[{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} Encoding of a CGM]\n\\label{def:encoding}\nLet ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM.\nThe {\\em {{\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} encoding}} of {\\ensuremath{\\mathcal{M}}\\xspace} is the  formula \n${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}\\Psi\\wedge\\Psi_{\\ensuremath{\\mathcal{E}}\\xspace}\\wedge\\Psi_{\\ensuremath{\\mathcal{R}}\\xspace}$, where:\n\\begin{eqnarray}\n\\Psi_{\\ensuremath{\\mathcal{E}}\\xspace}&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}& \n\\textstyle\n\\bigwedge_{E\\in{\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}\\cup{\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace}}\\ \n\\bigl( E \\rightarrow (\\bigvee_{R_i \\in \\rm{{\\sf Refinements}}(E)} R_i) \\bigr) \n\\\\\n \\Psi_{\\ensuremath{\\mathcal{R}}\\xspace}&{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}& \n\\textstyle\n\\bigwedge_{{\\ensuremath{ {\\bigl({{E}_1, \\ldots,{E}_{{n}}}\\bigr)} \\xrightarrow{R} {E}}},\\ R\n  \\in {\\ensuremath{\\mathcal{R}}\\xspace}}\\  \n\\bigl(\n (\\bigwedge_{i=1}^{n} E_i \\leftrightarrow R) \\wedge  (R\n\\rightarrow E)\n\\bigr),\n\\end{eqnarray}\n{\\noindent} {\\ensuremath{{\\sf Roots}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace} and {\\ensuremath{{\\sf Internals}({{\\ensuremath{\\mathcal{D}}\\xspace}})}\\xspace} being the root and internal\nelements of {\\ensuremath{\\mathcal{D}}\\xspace} respectively.\n\n\\end{definition}\n\nThe following facts are straightforward consequences of\nDefinitions~\\ref{def:realization} and \\ref{def:encoding} and of the\ndefinition and {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}.\n\n \n\\begin{proposition}\n\\label{prop:main} \nLet ${\\ensuremath{\\mathcal{M}}\\xspace}{\\ensuremath{\\stackrel{\\text{\\tiny def}}{=}}\\xspace}{\\ensuremath{\\langle{{{\\ensuremath{\\mathcal{B}}\\xspace},{\\ensuremath{\\mathcal{N}}\\xspace},{\\ensuremath{\\mathcal{D}}\\xspace},\\Psi}}\\rangle}\\xspace}$ be a CGM, ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$\n  its {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} encoding \nand $\\mu$ a {\\ensuremath{\\mathcal{LRA}}\\xspace}-interpretation over ${\\ensuremath{\\mathcal{B}}\\xspace}\\cup{\\ensuremath{\\mathcal{N}}\\xspace}$. \nThen $\\mu$ is a realization of\n{\\ensuremath{\\mathcal{M}}\\xspace} \nif and only if \n$\n  \\mu\\models\n{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}.\n$\n\\end{proposition}\n\n\\begin{proposition}\n\\label{prop:main2} \nLet ${\\ensuremath{\\mathcal{M}}\\xspace}$ and ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$ be as in Proposition~\\ref{prop:main},\nand let $\\mu$ be a realization of {\\ensuremath{\\mathcal{M}}\\xspace}. \nLet ${\\ensuremath{\\{{{obj_1,...,obj_k}}\\}}\\xspace}$ be {\\ensuremath{\\mathcal{LRA}}\\xspace}-terms occurring in $\\Psi$.\nThen we have that:\n\\begin{itemize}\n\\item[(i)] for every i in $1,...,k$, $\\mu$ minimizes [resp. maximizes] $obj_i$\nif and only if  $\\mu$ is a solution of the {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} minimization\n[resp. maximization] problem \n{\\ensuremath{\\langle{{{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{},{\\ensuremath{\\langle{{obj_i}}\\rangle}\\xspace}}}\\rangle}\\xspace};\n\n\\item[(ii)] $\\mu$ lexicographically minimizes [resp. maximizes]\n  ${\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace}$ \nif and only if  $\\mu$ is a solution of the {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} lexicographic minimization\n[resp. maximization] problem \n{\\ensuremath{\\langle{{{\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{},{\\ensuremath{\\langle{{obj_1,...,obj_k}}\\rangle}\\xspace}}}\\rangle}\\xspace}.\n\n\\end{itemize}\n\\end{proposition}  \n\n\n\n\n\\subsection{Automated Reasoning on Constrained Goal Models}\n\\label{sec:goalmodels_functionalities}\n\\noindent\nPropositions~\\ref{prop:main}  and \\ref{prop:main2} suggest\n that realizations of a CGM {\\ensuremath{\\mathcal{M}}\\xspace}\ncan be produced by applying {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} solving to the encoding\n${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$, and that {\\em optimal} realizations can \nbe produced by applying {\\ensuremath{\\text{OMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace} to ${\\ensuremath{\\Psi_{{\\ensuremath{\\mathcal{M}}\\xspace}}}}{}$ and  a list of\ndefined objectives $obj_1,...,obj_k$.\n\n{(Notice that such list may include also the pre-defined \nobjectives\n{\\ensuremath{\\mathsf{{numUnsatRequirements}}}}{}, {\\ensuremath{\\mathsf{{numSatTasks}}}}{} and \n    {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}{} of {\\S{}\\ref{{sec:goalmodels_example}}} and\n    \\eqref{eq:costpref}  to be minimized.)} \n\nThis allowed us to  implement straightforwardly the following reasoning\nfunctionalities on CGMs by interfacing with a SMT/OMT tool.\n\n\n\n\n\\begin{description} \n\\item[Search/enumerate realizations.] \n  Stakeholders can automatically check the realizability of a CGM {\\ensuremath{\\mathcal{M}}\\xspace}{} --or to\n  enumerate one or more of its possible realizations-- under a group\n  of user assertions and of user-defined Boolean and {\\ensuremath{\\text{SMT}({{\\ensuremath{\\mathcal{LRA}}\\xspace}})}\\xspace}\n  constraints; \n the tool performs this task by invoking the\n SMT solver on the formula $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ of\n  Definition~\\ref{def:encoding}. \n\n\\item[Search/enumerate minimum-penalty/maximum reward realizations.]\n  Stakeholders \n  can assert the desired requirements and set penalties\n  of tasks; then the tool \n  finds automatically realizations \n  achieving the former while minimizing \n  the latter,  by invoking the OMT solver on $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ with the pre-defined\n  {\\ensuremath{\\mathsf{{Weight}}}} objective. The vice versa is obtained by \n  negating undesired tasks and setting the rewards of\n  nice-to-have requirements. \n  Every intermediate situations can be also be obtained.\n\n\\item[Search/enumerate optimal realizations wrt. pre-defined/user-defined\n  objectives.] Stakeholders can define their own objective functions\n  $obj_1,...,obj_k$ over goals, refinements and their numerical\n  attributes; then the tool finds automatically realizations optimizing\n  them, either independently or lexicographically, by invoking the OMT\n  solver on $\\Psi_{\\ensuremath{\\mathcal{M}}\\xspace}$ and $obj_1,...,obj_k$.\n  {User-defined objectives can also be combined with the pre-defined\n    ones,\n like  {\\ensuremath{\\mathsf{{Weight}}}}, {\\ensuremath{\\mathsf{{numUnsatRequirements}}}},  {\\ensuremath{\\mathsf{{numSatTasks}}}}{} and\n {\\ensuremath{\\mathsf{{numUnsatPrefs}}}}. \n}\n\n\\end{description}\n{{\\noindent} In particular, notice that the latter allows for addressing the\nfulfillment of the maximum number of binary preferences as the\noptimization of a pre-defined objective.}\n\n\n\\begin{example}\n\\label{ex:lexicographically}\nAs a potentially frequent scenario, stakeholders may want to find a realization\nwhich minimizes, in order \nof preference, the number of unsatisfied non-mandatory requirements, \nthe number of unsatisfied binary preferences, and the number of\nsatisfied tasks.  This can be achieved my setting the following\nordered list of pre-defined objectives to minimize lexicographically:\n\n", "index": 5, "text": "$$\n{\\ensuremath{\\langle{{{\\ensuremath{\\mathsf{{numUnsatRequirements}}}},{\\ensuremath{\\mathsf{{numUnsatPrefs}}}},{\\ensuremath{\\mathsf{{numSatTasks}}}}}}\\rangle}\\xspace}.\n\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"{\\langle{{{\\mathsf{{numUnsatRequirements}}},{\\mathsf{{numUnsatPrefs}}},{%&#10;\\mathsf{{numSatTasks}}}}}\\rangle}.\\par&#10;\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\uddc7\ud835\uddce\ud835\uddc6\ud835\uddb4\ud835\uddc7\ud835\uddcc\ud835\uddba\ud835\uddcd\ud835\uddb1\ud835\uddbe\ud835\uddca\ud835\uddce\ud835\uddc2\ud835\uddcb\ud835\uddbe\ud835\uddc6\ud835\uddbe\ud835\uddc7\ud835\uddcd\ud835\uddcc</mi><mo>,</mo><mi>\ud835\uddc7\ud835\uddce\ud835\uddc6\ud835\uddb4\ud835\uddc7\ud835\uddcc\ud835\uddba\ud835\uddcd\ud835\uddaf\ud835\uddcb\ud835\uddbe\ud835\uddbf\ud835\uddcc</mi><mo>,</mo><mi>\ud835\uddc7\ud835\uddce\ud835\uddc6\ud835\uddb2\ud835\uddba\ud835\uddcd\ud835\uddb3\ud835\uddba\ud835\uddcc\ud835\uddc4\ud835\uddcc</mi><mo stretchy=\"false\">\u27e9</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}]