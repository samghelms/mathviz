[{"file": "1601.03874.tex", "nexttext": "\nwhere $C_a$ is a root CA certificate, $C_b$ and possibly other certificates are owned\nby intermediate CAs, and $C_c$ is an end-entity (leaf) certificate.\n\nStarting 1 April 2015, certificates must not be issued with a validity period greater than\n39 months~\\cite{CABForum}. However, this concerns only leaf certificates,\ni.e., not CA certificates. In fact, certain root CA certificates are\nvalid for up to 30 years (e.g., the certificate of \\emph{CA Disig Root R1}, present in the\nlist provided by Mozilla~\\cite{MozillaList}, will be valid until July 2042).\n\n\n\\subsection{Desired properties}\\label{sec:pre:prop}\n\nHere are the properties that we expect of a satisfactory revocation system:\n\n\\begin{description}\n\\item[Efficiency:] transmission, computation, and storage overheads are\n    reasonable and the deployment of the system is cost-effective.\n\n\\item[Timeliness:] the \\textit{attack window}, i.e., the time between the detection of an\n    attack and the moment when the corresponding certificate is considered invalid\n    by all clients, is short (ideally, on the order of minutes/hours).\n\n\\item[Privacy:] clients can obtain certificate-validity information without sacrificing their privacy.\n    In particular, users should not be forced to contact any other party than\n    the server they connect to in order to obtain the certificate status.\n\n\\item[Authenticity:] only legitimate parties can create a revocation message\n    for a certificate, but that message is verifiable by everyone.\n    The set of legitimate parties depends on a revocation policy.\n\n\\item[Independence:] the revocation is independent from the circumstances in which\n    the process takes place (e.g., server configuration or the availability of a\n    special third party).\n    Ideally, whenever an allowed entity has issued a revocation message,\n    and a certain server is accessible, then clients of this server should be able\n    to access the disseminated message.\n    An adversary must not be able to suppress a revocation.\n\n\\item[Complete status information:] revocation messages must provide the status of\n    all certificates in the chain of trust.\n\n\\item[Transparency:] revocations must be publicly accessible and persistent,\n    to guarantee to the interested parties that, when a revocation is\n    successfully issued, it is impossible to claim that the certificate is still\n    valid.\n\n\\item[Backward availability:] the revocation system must solve the\n    too-big-to-be-revoked problem of the current TLS PKI. In other words, it must\n    be possible to revoke any CA, without causing collateral\n    damage, i.e., without revoking certificates that were legitimately issued before\n    the CA's private key got compromised.\n\\end{description}\n(The efficiency of {PKISN\\xspace} is evaluated in \\S\\ref{sec:impl:perf},\n\\S\\ref{sec:eval:storage}, and \\S\\ref{sec:eval:bw},  while security properties\nare discussed throughout \\S\\ref{sec:analysis}.)\n\n\\subsection{The Evolution of Revocation Schemes and their Drawbacks}\n\\label{sec:pre:related}\n\n\\begin{inparaenum}[\\itshape a\\upshape)]\nThe first attempt to address the revocation problem was realized with Certificate\nRevocation Lists (CRLs)~\\cite{ccitt1988509}, published by CAs at CRL\ndistribution points. To verify the validity of a certificate, the browser downloads a CRL\nand checks whether the certificate is listed. Unfortunately, the CRL approach has\nmany drawbacks:\n\\item It is inefficient, since the entire CRL must be downloaded to verify a\nsingle certificate (a $n$-certificate chain requires $n$ connections).\n\\item CAs can violate the privacy of users by creating a dedicated distribution\npoint for a target certificate. Whenever a user connects to this special\ndistribution point, it means that this user is very likely to visit the website\nthat corresponds to the target certificate.\n\\item Gruschka et al.~\\cite{gruschka2014analysis} reported that, during a 3-month\nperiod, only 86.1\\% of the CRL distribution points had been available.\nMainly due to efficiency issues, the usefulness of CRLs was\nquestioned several years ago~\\cite{rivest1998can,conf/fc/McDanielR00,iliadis2003towards}.\n\\end{inparaenum}\n\nThere are many schemes that improve the format of standard CRLs.  For instance,\nKocher~\\cite{kocher1998certificate} proposed to use a Certificate Revocation Tree. This\ndata structure, based on binary hash trees, allows to efficiently prove that a\ncertificate is not revoked. Naor and Nissim~\\cite{naor2000certificate}\nsuggested a similar solution, and their Authenticated Dictionaries support\ncertificate insertion and deletion more efficiently. Unfortunately, these\nmethods have not been adopted.\n\nTo address the inefficiency of CRLs, the Online Certificate Status Protocol\n(OCSP)~\\cite{santesson2013x} was proposed.  In OCSP, clients contact a CA to get\nthe status of a certificate. However, this solution is still inefficient (the CA\nmay be under heavy load, and an extra connection is required), and has a serious\nprivacy issue (the CA learns about the server that the browser is contacting). OCSP\nStapling~\\cite{pettersen2013transport} solves these problems. In OCSP Stapling,\nthe server periodically obtains an OCSP response from its CA, and then sends\nthe response along with the certificate in subsequent TLS connections.\nUnfortunately, the deployment and effectiveness of this technique depend on the server\nconfiguration (e.g., the age of a stapled response can be customized by a configuration\nparameter, which may introduce a long attack window).\nLiu~et~al. reported~\\cite{liu-2015-revocation} that only 3\\% of certificates are\nserved by servers supporting OCSP Stapling.\nMoreover, OCSP and OCSP Stapling only return the status of a single certificate\n(not the entire chain). To address this problem, an\nextension~\\cite{pettersen2013transport} was proposed.\n\nRecently, browser vendors decided to disseminate special CRLs (called CRLSets)\nthrough software updates~\\cite{langley2012revocation,mozilla_rev}. Such an approach\ndoes not require any server reconfiguration,\nbut CRLSets only support certain \\textit{Extended Validation} (EV) certificates~\\cite{langley2012revocation}.\nSuch a policy restricts the deployability and effectiveness of the method, as\nthe fraction of EV certificates is relatively\nsmall~\\cite{Holz:2011:SLT:2068816.2068856,Durumeric:2013:AHC:2504730.2504755},\nand the revocation process is still conducted through a CA (a user cannot revoke his own\ncertificate without contacting the CA).\nA study showed that Chrome's CRLSet contains only\n0.35\\% of all revoked certificates~\\cite{liu-2015-revocation}.\n\nShort-Lived Certificates (SLCs)~\\cite{rivest1998can,topalovic2012towards} solve\nproblems associated with CRLs and OCSP, by periodically providing domains with\nfresh certificates with a limited validity period. SLCs are designed to be\nvalid for a few days, and as they are irrevocable, a long attack window exists.\nSLCs are intended for leaf certificates, hence intermediate and especially root\ncertificates cannot benefit from the properties of SLCs. In addition, their\ndeployment depends on server configuration.\n\nAnother recent approach, called RevCast~\\cite{schulman2014revcast}, improves\nrevocation dissemination through unique properties of radio broadcast. RevCast\nproposes an architecture where CAs broadcast revocation messages and users with\nradio receivers can receive them immediately. RevCast employs a blacklist approach\nwhere the user must possess the entire CRL, and to satisfy this requirement an\nadditional infrastructure must be provided or users have to continuously listen\nto broadcast\ntransmission. RevCast also requires users to purchase and install\nradio receivers.\n\n\nNone of the schemes presented above provides the transparency property. Revocation\nTransparency~\\cite{laurie2012revocation}, which was proposed as a supplement for\nCertificate Transparency (see \\S\\ref{sec:pre:ct}), was the first attempt to provide\nthat property. Unfortunately, due to the\nintroduced data structure, checking whether a certificate is revoked might be\ninefficient in practice. Additionally, Revocation Transparency lacks a detailed\ndescription.\n\nLog-based approaches such as AKI~\\cite{AKI}, ECT~\\cite{CIRT},\nARPKI~\\cite{ARPKI}, PoliCert~\\cite{PoliCert}, and DTKI~\\cite{yu2014dtki} take the transparency of\nrevocations into consideration. However, AKI, ECT, and ARPKI do not allow\ndomains to use multiple certificates (which is a common\npractice today~\\cite{ssl_lab}). In ECT, only the most recent certificate is\nconsidered valid for any given entity. Similarly, in AKI and ARPKI, a certificate\nexpresses the domain's policy, which must be unique. Consequently, these\nsystems are designed in such a way that, at a given point in time, there can\nexist only one active certificate per domain name. \nTo solve this issue PoliCert decouples\npolicies from certificates. Similarly, DTKI introduces a \\textit{master\ncertificate} and a \\textit{mapping server}, which also allow a domain to possess\nmultiple certificates.\nUnfortunately,\nall these schemes (including PoliCert and DTKI) simplify the certificate hierarchy by\nignoring intermediate CAs, and consider that certificates are signed directly\nby root CAs. Such certificates are unusual in practice, and taking intermediate\nCAs into consideration would introduce a significant complexity to the log and protocol designs.\nFor instance, to return complete status information, a log would need to efficiently\nlook up all relevant information about a particular certificate chain (without performing\na linear search).\nFurthermore, the previous proposals do not handle revocation of CA certificates.\n\nUnfortunately, none of the methods proposed in the literature identifies and\nsolves the too-big-to-be-revoked problem of the current TLS PKI and would thus\ncreate large collateral damage if a popular CA certificate were revoked.\n\n\\subsection{Certificate Transparency}\n\\label{sec:pre:ct}\n\nThe Certificate Transparency (CT)~\\cite{rfc6962} project was initiated by Google\nand aims at making the issuance of TLS certificates accountable and publicly\nvisible. In order to achieve this goal, log servers are used to collect\ncertificates that can be submitted by anyone (clients, servers, CAs).\n\nThe CT framework relies on the Merkle tree (also called\nhash tree) data structure. In the binary Merkle trees used in CT, leaves are\nessentially hashes of\ncertificates and the other nodes are obtained by hashing the\nconcatenation of their two children. We can distinguish between two types of Merkle\ntrees. When new leaves are generated, they can either be appended\nto the tree (in chronological order) or the tree can be continuously\nsorted (in lexicographical order).\nIn CT, logs use append-only trees sorted in chronological order, because\nit can be efficiently proven (with a number of nodes logarithmically proportional\nto the number of entries in the tree) that a\ncertificate is part of the tree and that a given tree is the extension of\nanother tree.\nTrees that are sorted in lexicographical order, on the other hand,\nallow to efficiently show that a certain entry is absent from the tree.\n\nWhen a certificate is submitted to the log for inclusion, it returns a \nSigned Certificate Timestamp (SCT), which is a promise to incorporate the\ncertificate to the tree within a fixed time period called the Maximum Merge Delay (MMD).\nThe SCT must be provided by the TLS server\nto its clients at every connection, and the documentation~\\cite{rfc6962} of CT\ndescribes three ways to do so:\nvia OCSP Stapling, via a TLS extension, or via an X.509v3 extension. The last method\nis of particular interest as it is CA-driven (i.e., CAs directly embed the\nSCT into the certificate at issuance) and does not require servers to be updated,\nbut it requires that CAs participate.\n\n\n\\subsection{Assumptions}\nFor our revocation system to be operational, we make the following assumptions:\n\\begin{itemize}[leftmargin=0.5cm]\n\\item It is possible to determine when the private key of a CA is misused, in particular,\nby monitoring logs or with audits. (This is easier to achieve if certificate\nlogging is mandatory, which is the case for {PKISN\\xspace}.)\n\\item CAs can store a special private key offline in a secure manner.\n\\item Browser software is provided by a single vendor. (This assumption\nis introduced for the sake of simplicity and can be easily relaxed.)\n\\item Browsers have a working software-update mechanism.\n\\item The log server is highly available (for both read and update operations) to all parties.\n\\item The different parties are loosely time-synchronized (up to few minutes),\n    and\n    time is expressed in Unix seconds.\n\\item The cryptographic primitives used by PKISN are secure.\n\\item Only one log server exists, but extending PKISN to\nmulti-log settings is discussed in \\S\\ref{sec:discussion}.\n\\end{itemize}\n\n\\subsection{Adversary Model}\n\\begin{inparaenum}[\\itshape a\\upshape)]\nWe consider that an adversary can steal a domain's private key to perform a man-in-the-middle\nattack or a CA's private key to issue malicious certificates/revocations, but an attacker\ncannot access a CA's offline (revocation) key,\nand cannot access key(s) used for software update.\nThe adversary can also contact the log (to fetch or submit data) as any other party.\nThe adversary's goal can be to:\n\\item cause collateral damage and make many websites unavailable,\n\\item violate the revocation policy and convince a client that a revoked certificate\nis still valid, or\n\\item revoke a valid certificate without legitimately owning the appropriate key.\n\\end{inparaenum}\n\n\\subsection{Notation}\nThroughout the paper, we use the notation presented in Table~\\ref{tab:notation}.\n\n\\begin{table}\n\\caption{Notation.}\n\\normalsize\n\\begin{tabular}{@{~}lp{200pt}@{~}}\n\\toprule\n$C_x$ & certificate \\\\\n$R_{C_x}$ & revocation of certificate $C_x$ \\\\\n$t_x$ & timestamp \\\\\n$\\textnormal{\\textit{sk}}_x$ & secret key associated with the public key\n        authenticated by $C_x$ \\\\\n$\\textnormal{\\textit{rk}}_x$ & revocation key (stored offline) associated with\n        a CA certificate $C_x$ \\\\\n$\\textnormal{\\textit{vk}}$ & key used by the software vendor \\\\\n$k_{\\textnormal{\\textit{log}}}$ & log key \\\\\n$H(.)$ & cryptographic hash function \\\\\n$\\textnormal{\\textit{Sig}}_k(m)$ & message $m$ signed with key $k$ \\\\\n$\\varnothing$ & \\textit{null} value \\\\\n$\\|$ & concatenation \\\\\n\\bottomrule\n\\end{tabular}\n\\label{tab:notation}\n\\end{table}\n\n\n\\section{{PKISN\\xspace} Overview}\n\\label{sec:overview}\nThis section gives a high-level picture of the overall system and introduces the\nentities involved and basic terminology.\nIn {PKISN\\xspace}, clients/browsers want to communicate securely with servers/domains.\nA server is authenticated through a certificate chain created\nby a number of CAs. All certificates and revocations must be logged by a log server. At every\n\\textit{update time}, each log updates its local database, and the time period between\nthese updates is called the \\textit{scheduling period}. The log is\nverified by browsers and dedicated parties called \\textit{monitors}. CAs must also act as\nmonitors to verify that no illegitimate certificate (issued on their\nbehalf) is present in the log.\n\n\\subsection{The Certificate Log as a Timestamping Service}\nThe main goal of our work is to solve the {too-big-to-be-revoked\\xspace} problem of the current TLS PKI.\nNamely, we want to enable revocation of CA certificates without causing\ncollateral damage. The typical scenario in which a revocation is required is\nafter a private key compromise. Currently, revocation of a compromised private\nkey owned by an important CA, should invalidate all certificates signed by this\nkey, as the certificates may have been fraudulently created.\n\n\nOur main observation is that when a compromised CA can determine the time of the\nattack---more precisely, the time at which an illegitimate action (like\ncertificate issuance or revocation) was first\nobserved---then the certificates signed before the attack can still be considered valid.\nOnly certificates issued after the attack are potentially malicious, and should not be\ntrusted. It is possible for CAs to determine the time of that attack as, in the PKISN\nframework, all certificates and revocations must be logged before they are\nconsidered valid.\nThus, the instant of the first maliciously registered certificate is the instant\nof compromise.\n\nAs we cannot rely on the creation-time field of a certificate (because it may\nbe easily predated by the adversary), the main challenge in resolving the {too-big-to-be-revoked\\xspace} issue\nis the lack of a trusted timestamping service~\\cite{Haber91howto}. {PKISN\\xspace} leverages the\nconcept of a certificate log to provide this service. Depending on the deployment scenario,\na domain or a CA submits the certificate to a log. When the certificate is accepted, the log\nreturns a \\textit{chain commitment}~(CC) and appends the certificate to the\ntree in the next update. Additionally, all intermediate certificates are\nadded as well (if they are not already in the log).  The returned commitment\nincludes a list of \\textit{registration timestamps} that specifies when the\nnon-registered\ncertificates in the chain will be present in the log (in this case, the timestamp\ndenotes the next update time) and when the already registered certificates were appended to\nthe log.\n\nEvery new certificate is appended along with its registration timestamp. Thereafter,\nanyone with the obtained commitment can query the log for the presence proof of the certificate.\nAs a presence proof includes a registration timestamp, it is the confirmation that the log\ncontained a given certificate at a given point in time. Hence, a requester can\nassert that the certificate was created before this timestamp.\n\n\\subsection{Transparent and Persistent Revocation}\n{PKISN\\xspace} also employs a public log for storing revocations. In order to\nenhance the transparency of the current PKI ecosystem, revocations\nneed to be logged. For instance, whenever a key is compromised or lost, the\nowner should have a guarantee that a revocation will be visible for others at\nleast until the revoked certificate expires. The obligation of logging\ncertificates also makes CAs more transparent, as they cannot misbehave by\ndistributing two different CRLs or two different OCSP responses.\n\n{PKISN\\xspace} introduces special types of revocation messages (see\n\\S\\ref{sec:rev_msg}), and due to the hierarchical nature of the certificate\nchain, a given certificate can be revoked by a set of entities (see {PKISN\\xspace}'s revocation\npolicy below).\n\nAn authorized entity (usually the owner of a certificate) who wishes to revoke a\ncertificate can create a special revocation message. This message is submitted to\nthe log, which, after verification, returns a \\textit{revocation commitment}\nstating that the revocation will be appended to the log in the next update. When the\nrevocation message is in the log, the presence proof for the corresponding\ncertificate must contain this revocation message. To minimize the\nattack window, whenever a revocation is pending for addition, the log can\naccompany the presence proof of a certificate with its revocation,\nwithout waiting for the end of a scheduling period.\n\n\\subsection{Revocation Policy}\\label{subsec:revocation_policy}\nIn the current PKI ecosystem, a certificate can be revoked only by two\nparties, namely the issuer and a software vendor (e.g., a browser or an\nOS vendor). \nWhenever a domain wishes to revoke its own certificate, the domain must contact the\nappropriate CA that will eventually issue the revocation. Obviously, such a procedure\nresults in a prolonged attack window and depends completely on the issuing CA. Alternatively,\nthe software vendor can simply blacklist certain certificates and\npropagate the changes through software updates. In this case,\na domain has to contact the software vendor. This option can be also used for revoking\nmisbehaving CAs. However, software vendors are reluctant to use this option, as\nit renders all servers with a certificate issued by that particular CA unavailable.\n\n{PKISN\\xspace} introduces a revocation policy that reflects the interactions of the current PKI\nand the hierarchical structure of the certificate chain. Specifically, we introduce the\nfollowing revocation rules:\n\\begin{description}\n    \\item[The owner] of a leaf certificate can revoke this certificate using the associated\n        private key.\\footnote{By \\textit{associated private key} we mean the one\n        corresponding to the public key that the certificate authenticates.}\n        This option gives domains the opportunity to revoke, without the need\n        to contact CAs or a software vendor.\n\n    \\item[The issuer] (or an upper-level issuer, i.e., a CA in the certificate chain)\n        of a leaf certificate can revoke that certificate. The revocation message is created by the\n        issuer's (i.e., a CA's) private key and can be performed, for\n        example, when a domain lost its private key. Note that a certificate can be\n        revoked directly by a root CA, without involving intermediate CAs.\n\n    \\item[CAs] can revoke their own certificates and the\n        certificates of their child CAs from a given point in time called\n        \\textit{revocation timestamp}. This revocation states that certificates\n        and revocations issued after a revocation timestamp should be considered\n        invalid and should be ignored during the certificate-chain validation.\n        The CA's own certificates are revoked with a dedicated \\textit{revocation key}, while\n        child certificates are revoked with a regular private key.\n        With the revocation key, a CA can prevent all\n        potentially malicious actions starting from a certain point in time.\n        A CA can use its revocation key only once, and as it invalidates the\n        CA's certificate there is no need to revoke or update a revocation\n        key. A new revocation key is generated every time a CA's certificate is\n        created.\n\n    \\item[A software vendor] can revoke any certificate, and for CA\n        certificates, they have to specify a revocation timestamp as above. Only\n        child certificates and revocations issued with the revoked\n        certificate before that timestamp are considered valid.\n        Currently, software vendors effectively have the ability to revoke\n        any certificate, so this option explicitly reflects their power in the current\n        TLS PKI ecosystem. Moreover, {PKISN\\xspace} holds their actions accountable and\n        transparent. For the sake of simplicity, we assume that there is a\n        single software vendor that issues revocations with a private \\emph{vendor key}.\n        The corresponding public key is provided to the clients within the software\n        (like today), and can be updated with a software update (but cannot be\n        revoked through {PKISN\\xspace}).\n\\end{description}\nNote that we do not allow a revoked (i.e., compromised, usually) CA to revoke its child certificates,\neven if the revocation had been legitimate \n(otherwise an adversary could cause collateral damage by invalidating\ncertificates with the already revoked key).\nIn such a case, any non-revoked\nCA in the certificate chain can still issue a valid revocation for the leaf certificate. \nHowever, after a CA is revoked, its clients should be informed that, although\ntheir legitimately-issued certificates are still valid and can be used, the CA lost its revocation\nability, and the certificates should be reissued in the near future (e.g., few days or weeks).\n\nPossible revocation actions for an example certificate chain are presented\nin Fig.~\\ref{fig:revocations}.\nA single certificate can have many associated revocations. All these revocations\ncan be fetched from the log with a presence proof.\n\\begin{figure}[h]\n  \\centering\n  \\includegraphics[width=\\linewidth]{revocations.eps}\n  \\caption{All possible revocations for a certificate chain $C_a\\rightarrow\n      C_b\\rightarrow C_c$, where $C_a$ and $C_b$ have associated keys $\\textit{sk}_a,\n      \\textit{rk}_a$ and $\\textit{sk}_b, \\textit{rk}_b$, respectively (standard and revocation private keys),\n      while the leaf certificate is associated only with a standard private key $\\textit{sk}_c$,\n  and $\\textit{vk}$ denotes the software vendor key.}\n  \\label{fig:revocations}\n\\end{figure}\n\n\n\\subsection{Validation}\nFor a successful validation, a client must be provided with a certificate chain,\na corresponding chain commitment (CC), and a proof from the log. \nFirst, the input data is pre-validated (for details see \\S\\ref{sec:pre_valid}),\nand verified. This includes a standard chain validation as executed in modern\nbrowsers. However, the {PKISN\\xspace} validation process goes further, as it \ndetermines time periods for which CAs were behaving legitimately.\n\nAs shown in Fig.~\\ref{fig:revocations}, a single certificate can be revoked\nby different entities and through different revocation messages. Hence,\nto achieve an unambiguous validation of revocation messages, priorities\nmust be established. {PKISN\\xspace} introduces the following priorities for revocation messages,\nfrom the highest priority to the lowest:\n\\begin{enumerate}\n\\item revocations issued by the software vendor,\n\\item revocations created with a dedicated revocation key (only applies to non-leaf certificates),\n\\item revocations issued by parent CAs,\n\\item revocations created with the standard private key associated with the\ncertificate (only applies to leaf certificates).\n\\end{enumerate}\n\nTo conduct a validation, {PKISN\\xspace} introduces the notion of a \\textit{legitimacy\nperiod}, which denotes a time period during which actions performed by\nCAs are considered valid. The legitimacy period is \ndefined between the moment when a certificate is received by the log for the\nfirst time (registration timestamp) and the moment when it expires or is legitimately\nrevoked (revocation timestamp). A certificate is considered valid when it\npasses the \\textit{pre-validation} and when all certificates in the chain\nwere issued (and never revoked) during corresponding legitimacy periods.\n\nAn example that illustrates the concept of legitimacy periods is presented in\nFig.~\\ref{fig:timelines}. In this example, the root CA certificate $C_a$ gets compromised,\nbut the attack is then detected and the CA is able to determine the time at which the attack\nwas performed. In the meantime, the adversary used the private key to maliciously revoke\nthe certificate $C_b$ of an intermediate CA.\\footnote{Although such an attack was never observed\nin the real world (to the best of our knowledge), nothing currently prevents an adversary who\ncompromised a private key from performing revocations. Therefore, our new scheme should\ntake this case into account.}\nIn this particular case, the leaf certificate $C_c$ is\nvalid even though its parent CA certificate was revoked, as {PKISN\\xspace} allows to express the fact\nthat $C_b$ was maliciously revoked (the revocation was done during the\n\\emph{illegitimacy period} of $C_a$).\n\n\\begin{figure}[h!]\n  \\centering\n  \\includegraphics[width=\\linewidth]{timelines.eps}\n  \\caption{Timelines for a chain of three certificates, with an attack (against the root CA) and a detection thereof.}\n  \\label{fig:timelines}\n\\end{figure}\n\n\n\\subsection{Log Consistency}\nPeriodically, a browser contacts a random monitor to ensure that they share the\nsame view of the log. As monitors have a copy of the log, they can inform about\nhistoric versions. To prevent equivocation, browsers can compare log information\nobtained during the TLS connections with corresponding monitor statements. Even\nif such\na procedure does not completely protect against malicious logs, it enables to\ndetect log misbehavior.\n\n\n\\section{{PKISN\\xspace} Details}\n\\label{sec:details}\n\\subsection{Revocation Messages}\\label{sec:rev_msg}\n{PKISN\\xspace} introduces a new dedicated revocation\nkey pair for CAs.\nThe revocation private key is only used when a given CA notices that its\nstandard private key (used in production) has been compromised or lost.\nAs the revocation key is not used in production, it should be securely\nstored offline.\n\n{PKISN\\xspace} supports two formats of revocation messages. The first one is used\nfor invalidating leaf certificates:\n\n", "itemtype": "equation", "pos": 7360, "prevtext": "\n\n\\author{\n    \\IEEEauthorblockN{Pawel Szalachowski, Laurent Chuat, and Adrian Perrig}\n    \\IEEEauthorblockA{Department of Computer Science\\\\ETH Zurich, Switzerland}\n}\n\n\n\\title{PKI Safety Net (PKISN):\\\\ Addressing the Too-Big-to-Be-Revoked Problem of\nthe TLS Ecosystem}\n\n\\maketitle\n\n\\begin{abstract}\nIn a public-key infrastructure (PKI), clients must have an efficient and secure\nway to determine whether a certificate was revoked (by an entity considered as\nlegitimate to do so), while preserving user privacy. A few certification\nauthorities~(CAs) are currently responsible for the issuance of the large majority of\nTLS certificates. These certificates are considered valid only if the\ncertificate of the issuing CA is also valid. The certificates of these important\nCAs are effectively \\emph{too big to be revoked}, as revoking them would result\nin massive collateral damage. To solve this problem, we redesign the current\nrevocation system with a novel approach that we call PKI Safety Net (PKISN),\nwhich uses publicly accessible logs to store certificates (in the spirit of\nCertificate Transparency) and revocations. The proposed system extends existing\nmechanisms, which enables simple deployment. Moreover, we present a complete\nimplementation and evaluation of our scheme.\n\\end{abstract}\n\n\\section{Introduction}\n\\label{sec:intro}\nThe TLS public-key infrastructure (PKI) is an essential component of today's Internet,\nas it enables to use and verify certificates for secure communications.\nCertification authorities~(CAs) are trusted third parties responsible for\nissuing and signing digital certificates, which contain authenticated public keys.\nTo do so, CAs also own certificates. Naturally, the\nproblem is that private keys can get compromised. As a\nconsequence, the ability to revoke any certificate (including a CA certificate)\nand verify if a given certificate has been revoked is crucial. This process\nshould be lightweight, secure, and preserve user privacy. To develop a new\nrevocation scheme, one should also answer the question of who must be able to\nrevoke a given certificate. The owner, the issuer, the root CA, intermediate\nCAs, or a combination of these?\n\nThe current revocation schemes simplify many aspects of the PKI ecosystem. The\nmost striking example is the following. As any private key can be stolen, it\nshould be possible to revoke any certificate; however, just like some\ncorporations are said to be ``too big to fail'', the certificates of some\ncertification authorities are, in practice, \\emph{too big to be revoked}. A\nstudy showed that around 75\\% of certificates had been issued by only three\ndifferent companies, and one specific GoDaddy CA private key had signed 26\\% of\nall valid certificates in March\n2013~\\cite{Durumeric:2013:AHC:2504730.2504755,Arnbak:2014:SCH:2668152.2673311}.\nRevoking this particular certificate, if the corresponding private key were\ncompromised, would mean that 26\\% of all websites that use HTTPS would be\nunavailable (or accessible only if the security warning displayed by\nbrowsers is ignored). Diginotar and Comodo are two infamous examples of\nattacked CAs. After the breach, while Diginotar had its certificate revoked\nand removed from most CA lists~\\cite{MozillaDigiNotarRemoval} (before eventually\ndeclaring bankruptcy), Comodo's incriminated CA certificate was not revoked and\nis still present in CA lists~\\cite{MozillaList}.\nThe Comodo Group is leading the certificate issuance business (with a\nmarket share of 33.9\\%, and some single private keys that have been used to sign the\ncertificates of 5.5\\% of all the websites considered in a W3Techs survey from\nFebruary 2015~\\cite{W3Techs}). Consequently, Comodo's root certificate could not\nbe revoked without effectively preventing users from establishing TLS\nconnections with a significant\nportion of the Internet. For this reason, we claim that the TLS revocation system needs to be\nredesigned to remove the collateral damage that would be induced by the revocation of\nsome CA certificates.\n\nWe observe that time is a key element in this problem, as certificates\nissued before the certification authority was compromised should not become\ninvalid when the CA certificate is revoked. Therefore, we suggest that introducing\na timestamp server for certificates and revocations can prevent invalidating\nany legitimate certificate. Another problem of current revocation schemes is\nthat a certificate cannot be directly revoked by its owner. Our approach,\nPKI Safety Net~(PKISN), solves this issue. In PKISN, domain owners can use their\nprivate keys to revoke the corresponding certificates, while CAs can use a dedicated\nrevocation key, which can be securely stored offline as it is not needed during\nnormal operation.\n\nThe scheme we present is inspired by log-based solutions such as\nCertificate Transparency (CT), which was recently introduced and\ndeployed~\\cite{rfc6962}. CT aims to\nmake the actions of CAs more transparent by introducing a log that makes\ncertificates publicly visible. However, CT mainly covers the issuance aspect of\nthe problem. We propose to improve the system in several ways, in particular, by\nusing two distinct hash trees (the data structure on which CT relies) to store\nnot only certificates, but also revocations. Moreover, {PKISN\\xspace} gives CAs\nthe ability to revoke their own certificates after a certain point in time to ensure\nthat previously-signed certificates remain valid.\n\nSecurity breach notification laws require CAs to notify relevant\nauthorities about a data breach. For example, in the E.U., this notification\nmust occur within 24 hours. In other words, certification authorities are\ncompelled by law to take rapid action to disclose a data breach when\nit is detected. This notification should be immediately followed (if not\npreceded) by a set of measures that can mitigate the attack, but it is currently\nnot possible to simply revoke certain compromised CA certificates without\nincurring substantial collateral damage.\n\nThe major contributions of this paper are the following.\nThrough {PKISN\\xspace}, we redesign the revocation system to better express the\nhierarchical structure of certificates, rebalance the power of PKI actors, and\naddress the too-big-to-be-revoked problem.\nIn addition to the existing deployment plans of CT, we propose and discuss\nnew models that maximize privacy and allow to monitor the log in a lightweight\nmanner, and we show how the log can be designed to handle these deployment models.\nWe present an evaluation and a full implementation of our system.\n\n\n\\section{Background}\n\\label{sec:pre}\n\n\\subsection{The TLS Public-Key Infrastructure}\nIn TLS, certificates form a chain of trust (\\textit{certificate chain}) that\nstarts with the root CA's self-signed certificate and ends with the server's\ncertificate. This chain can contain a number of intermediate CAs and each\ncertificate in the chain (except the root) is signed by the private key\ncorresponding to the public key of the parent certificate. TLS clients\n(e.g., browsers) need a list of root CA certificates considered trustworthy\nto initiate the verification of other certificates. The \\texttt{basicConstraints} extension\nindicates whether a certificate is a CA certificate. For convenience, we will\nuse a simple notation to represent the chain of trust formed by a series of\ncertificates, as follows:\n\n", "index": 1, "text": "\\begin{equation}\nC_a \\rightarrow C_b \\rightarrow \\dots \\rightarrow C_c,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"C_{a}\\rightarrow C_{b}\\rightarrow\\dots\\rightarrow C_{c},\" display=\"block\"><mrow><mrow><msub><mi>C</mi><mi>a</mi></msub><mo>\u2192</mo><msub><mi>C</mi><mi>b</mi></msub><mo>\u2192</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2192</mo><msub><mi>C</mi><mi>c</mi></msub></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nwhere $k$ can be:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item a private key associated with the authenticated public key in a leaf certificate,\n\\item the private key of one of the CAs in the certification chain, or\n\\item a software vendor key. Note that in contrast with the current\nrevocation system, domains can revoke their own certificates without any\ninteraction with the issuing CAs. Leaf certificates do not contain a special\nrevocation key and can be revoked without a revocation timestamp, as they cannot\ncause collateral damage.\n\\end{inparaenum}\n\nBecause CA certificates introduce collateral damage,\nthey are always revoked by the following revocation message:\n\n", "itemtype": "equation", "pos": 35774, "prevtext": "\nwhere $C_a$ is a root CA certificate, $C_b$ and possibly other certificates are owned\nby intermediate CAs, and $C_c$ is an end-entity (leaf) certificate.\n\nStarting 1 April 2015, certificates must not be issued with a validity period greater than\n39 months~\\cite{CABForum}. However, this concerns only leaf certificates,\ni.e., not CA certificates. In fact, certain root CA certificates are\nvalid for up to 30 years (e.g., the certificate of \\emph{CA Disig Root R1}, present in the\nlist provided by Mozilla~\\cite{MozillaList}, will be valid until July 2042).\n\n\n\\subsection{Desired properties}\\label{sec:pre:prop}\n\nHere are the properties that we expect of a satisfactory revocation system:\n\n\\begin{description}\n\\item[Efficiency:] transmission, computation, and storage overheads are\n    reasonable and the deployment of the system is cost-effective.\n\n\\item[Timeliness:] the \\textit{attack window}, i.e., the time between the detection of an\n    attack and the moment when the corresponding certificate is considered invalid\n    by all clients, is short (ideally, on the order of minutes/hours).\n\n\\item[Privacy:] clients can obtain certificate-validity information without sacrificing their privacy.\n    In particular, users should not be forced to contact any other party than\n    the server they connect to in order to obtain the certificate status.\n\n\\item[Authenticity:] only legitimate parties can create a revocation message\n    for a certificate, but that message is verifiable by everyone.\n    The set of legitimate parties depends on a revocation policy.\n\n\\item[Independence:] the revocation is independent from the circumstances in which\n    the process takes place (e.g., server configuration or the availability of a\n    special third party).\n    Ideally, whenever an allowed entity has issued a revocation message,\n    and a certain server is accessible, then clients of this server should be able\n    to access the disseminated message.\n    An adversary must not be able to suppress a revocation.\n\n\\item[Complete status information:] revocation messages must provide the status of\n    all certificates in the chain of trust.\n\n\\item[Transparency:] revocations must be publicly accessible and persistent,\n    to guarantee to the interested parties that, when a revocation is\n    successfully issued, it is impossible to claim that the certificate is still\n    valid.\n\n\\item[Backward availability:] the revocation system must solve the\n    too-big-to-be-revoked problem of the current TLS PKI. In other words, it must\n    be possible to revoke any CA, without causing collateral\n    damage, i.e., without revoking certificates that were legitimately issued before\n    the CA's private key got compromised.\n\\end{description}\n(The efficiency of {PKISN\\xspace} is evaluated in \\S\\ref{sec:impl:perf},\n\\S\\ref{sec:eval:storage}, and \\S\\ref{sec:eval:bw},  while security properties\nare discussed throughout \\S\\ref{sec:analysis}.)\n\n\\subsection{The Evolution of Revocation Schemes and their Drawbacks}\n\\label{sec:pre:related}\n\n\\begin{inparaenum}[\\itshape a\\upshape)]\nThe first attempt to address the revocation problem was realized with Certificate\nRevocation Lists (CRLs)~\\cite{ccitt1988509}, published by CAs at CRL\ndistribution points. To verify the validity of a certificate, the browser downloads a CRL\nand checks whether the certificate is listed. Unfortunately, the CRL approach has\nmany drawbacks:\n\\item It is inefficient, since the entire CRL must be downloaded to verify a\nsingle certificate (a $n$-certificate chain requires $n$ connections).\n\\item CAs can violate the privacy of users by creating a dedicated distribution\npoint for a target certificate. Whenever a user connects to this special\ndistribution point, it means that this user is very likely to visit the website\nthat corresponds to the target certificate.\n\\item Gruschka et al.~\\cite{gruschka2014analysis} reported that, during a 3-month\nperiod, only 86.1\\% of the CRL distribution points had been available.\nMainly due to efficiency issues, the usefulness of CRLs was\nquestioned several years ago~\\cite{rivest1998can,conf/fc/McDanielR00,iliadis2003towards}.\n\\end{inparaenum}\n\nThere are many schemes that improve the format of standard CRLs.  For instance,\nKocher~\\cite{kocher1998certificate} proposed to use a Certificate Revocation Tree. This\ndata structure, based on binary hash trees, allows to efficiently prove that a\ncertificate is not revoked. Naor and Nissim~\\cite{naor2000certificate}\nsuggested a similar solution, and their Authenticated Dictionaries support\ncertificate insertion and deletion more efficiently. Unfortunately, these\nmethods have not been adopted.\n\nTo address the inefficiency of CRLs, the Online Certificate Status Protocol\n(OCSP)~\\cite{santesson2013x} was proposed.  In OCSP, clients contact a CA to get\nthe status of a certificate. However, this solution is still inefficient (the CA\nmay be under heavy load, and an extra connection is required), and has a serious\nprivacy issue (the CA learns about the server that the browser is contacting). OCSP\nStapling~\\cite{pettersen2013transport} solves these problems. In OCSP Stapling,\nthe server periodically obtains an OCSP response from its CA, and then sends\nthe response along with the certificate in subsequent TLS connections.\nUnfortunately, the deployment and effectiveness of this technique depend on the server\nconfiguration (e.g., the age of a stapled response can be customized by a configuration\nparameter, which may introduce a long attack window).\nLiu~et~al. reported~\\cite{liu-2015-revocation} that only 3\\% of certificates are\nserved by servers supporting OCSP Stapling.\nMoreover, OCSP and OCSP Stapling only return the status of a single certificate\n(not the entire chain). To address this problem, an\nextension~\\cite{pettersen2013transport} was proposed.\n\nRecently, browser vendors decided to disseminate special CRLs (called CRLSets)\nthrough software updates~\\cite{langley2012revocation,mozilla_rev}. Such an approach\ndoes not require any server reconfiguration,\nbut CRLSets only support certain \\textit{Extended Validation} (EV) certificates~\\cite{langley2012revocation}.\nSuch a policy restricts the deployability and effectiveness of the method, as\nthe fraction of EV certificates is relatively\nsmall~\\cite{Holz:2011:SLT:2068816.2068856,Durumeric:2013:AHC:2504730.2504755},\nand the revocation process is still conducted through a CA (a user cannot revoke his own\ncertificate without contacting the CA).\nA study showed that Chrome's CRLSet contains only\n0.35\\% of all revoked certificates~\\cite{liu-2015-revocation}.\n\nShort-Lived Certificates (SLCs)~\\cite{rivest1998can,topalovic2012towards} solve\nproblems associated with CRLs and OCSP, by periodically providing domains with\nfresh certificates with a limited validity period. SLCs are designed to be\nvalid for a few days, and as they are irrevocable, a long attack window exists.\nSLCs are intended for leaf certificates, hence intermediate and especially root\ncertificates cannot benefit from the properties of SLCs. In addition, their\ndeployment depends on server configuration.\n\nAnother recent approach, called RevCast~\\cite{schulman2014revcast}, improves\nrevocation dissemination through unique properties of radio broadcast. RevCast\nproposes an architecture where CAs broadcast revocation messages and users with\nradio receivers can receive them immediately. RevCast employs a blacklist approach\nwhere the user must possess the entire CRL, and to satisfy this requirement an\nadditional infrastructure must be provided or users have to continuously listen\nto broadcast\ntransmission. RevCast also requires users to purchase and install\nradio receivers.\n\n\nNone of the schemes presented above provides the transparency property. Revocation\nTransparency~\\cite{laurie2012revocation}, which was proposed as a supplement for\nCertificate Transparency (see \\S\\ref{sec:pre:ct}), was the first attempt to provide\nthat property. Unfortunately, due to the\nintroduced data structure, checking whether a certificate is revoked might be\ninefficient in practice. Additionally, Revocation Transparency lacks a detailed\ndescription.\n\nLog-based approaches such as AKI~\\cite{AKI}, ECT~\\cite{CIRT},\nARPKI~\\cite{ARPKI}, PoliCert~\\cite{PoliCert}, and DTKI~\\cite{yu2014dtki} take the transparency of\nrevocations into consideration. However, AKI, ECT, and ARPKI do not allow\ndomains to use multiple certificates (which is a common\npractice today~\\cite{ssl_lab}). In ECT, only the most recent certificate is\nconsidered valid for any given entity. Similarly, in AKI and ARPKI, a certificate\nexpresses the domain's policy, which must be unique. Consequently, these\nsystems are designed in such a way that, at a given point in time, there can\nexist only one active certificate per domain name. \nTo solve this issue PoliCert decouples\npolicies from certificates. Similarly, DTKI introduces a \\textit{master\ncertificate} and a \\textit{mapping server}, which also allow a domain to possess\nmultiple certificates.\nUnfortunately,\nall these schemes (including PoliCert and DTKI) simplify the certificate hierarchy by\nignoring intermediate CAs, and consider that certificates are signed directly\nby root CAs. Such certificates are unusual in practice, and taking intermediate\nCAs into consideration would introduce a significant complexity to the log and protocol designs.\nFor instance, to return complete status information, a log would need to efficiently\nlook up all relevant information about a particular certificate chain (without performing\na linear search).\nFurthermore, the previous proposals do not handle revocation of CA certificates.\n\nUnfortunately, none of the methods proposed in the literature identifies and\nsolves the too-big-to-be-revoked problem of the current TLS PKI and would thus\ncreate large collateral damage if a popular CA certificate were revoked.\n\n\\subsection{Certificate Transparency}\n\\label{sec:pre:ct}\n\nThe Certificate Transparency (CT)~\\cite{rfc6962} project was initiated by Google\nand aims at making the issuance of TLS certificates accountable and publicly\nvisible. In order to achieve this goal, log servers are used to collect\ncertificates that can be submitted by anyone (clients, servers, CAs).\n\nThe CT framework relies on the Merkle tree (also called\nhash tree) data structure. In the binary Merkle trees used in CT, leaves are\nessentially hashes of\ncertificates and the other nodes are obtained by hashing the\nconcatenation of their two children. We can distinguish between two types of Merkle\ntrees. When new leaves are generated, they can either be appended\nto the tree (in chronological order) or the tree can be continuously\nsorted (in lexicographical order).\nIn CT, logs use append-only trees sorted in chronological order, because\nit can be efficiently proven (with a number of nodes logarithmically proportional\nto the number of entries in the tree) that a\ncertificate is part of the tree and that a given tree is the extension of\nanother tree.\nTrees that are sorted in lexicographical order, on the other hand,\nallow to efficiently show that a certain entry is absent from the tree.\n\nWhen a certificate is submitted to the log for inclusion, it returns a \nSigned Certificate Timestamp (SCT), which is a promise to incorporate the\ncertificate to the tree within a fixed time period called the Maximum Merge Delay (MMD).\nThe SCT must be provided by the TLS server\nto its clients at every connection, and the documentation~\\cite{rfc6962} of CT\ndescribes three ways to do so:\nvia OCSP Stapling, via a TLS extension, or via an X.509v3 extension. The last method\nis of particular interest as it is CA-driven (i.e., CAs directly embed the\nSCT into the certificate at issuance) and does not require servers to be updated,\nbut it requires that CAs participate.\n\n\n\\subsection{Assumptions}\nFor our revocation system to be operational, we make the following assumptions:\n\\begin{itemize}[leftmargin=0.5cm]\n\\item It is possible to determine when the private key of a CA is misused, in particular,\nby monitoring logs or with audits. (This is easier to achieve if certificate\nlogging is mandatory, which is the case for {PKISN\\xspace}.)\n\\item CAs can store a special private key offline in a secure manner.\n\\item Browser software is provided by a single vendor. (This assumption\nis introduced for the sake of simplicity and can be easily relaxed.)\n\\item Browsers have a working software-update mechanism.\n\\item The log server is highly available (for both read and update operations) to all parties.\n\\item The different parties are loosely time-synchronized (up to few minutes),\n    and\n    time is expressed in Unix seconds.\n\\item The cryptographic primitives used by PKISN are secure.\n\\item Only one log server exists, but extending PKISN to\nmulti-log settings is discussed in \\S\\ref{sec:discussion}.\n\\end{itemize}\n\n\\subsection{Adversary Model}\n\\begin{inparaenum}[\\itshape a\\upshape)]\nWe consider that an adversary can steal a domain's private key to perform a man-in-the-middle\nattack or a CA's private key to issue malicious certificates/revocations, but an attacker\ncannot access a CA's offline (revocation) key,\nand cannot access key(s) used for software update.\nThe adversary can also contact the log (to fetch or submit data) as any other party.\nThe adversary's goal can be to:\n\\item cause collateral damage and make many websites unavailable,\n\\item violate the revocation policy and convince a client that a revoked certificate\nis still valid, or\n\\item revoke a valid certificate without legitimately owning the appropriate key.\n\\end{inparaenum}\n\n\\subsection{Notation}\nThroughout the paper, we use the notation presented in Table~\\ref{tab:notation}.\n\n\\begin{table}\n\\caption{Notation.}\n\\normalsize\n\\begin{tabular}{@{~}lp{200pt}@{~}}\n\\toprule\n$C_x$ & certificate \\\\\n$R_{C_x}$ & revocation of certificate $C_x$ \\\\\n$t_x$ & timestamp \\\\\n$\\textnormal{\\textit{sk}}_x$ & secret key associated with the public key\n        authenticated by $C_x$ \\\\\n$\\textnormal{\\textit{rk}}_x$ & revocation key (stored offline) associated with\n        a CA certificate $C_x$ \\\\\n$\\textnormal{\\textit{vk}}$ & key used by the software vendor \\\\\n$k_{\\textnormal{\\textit{log}}}$ & log key \\\\\n$H(.)$ & cryptographic hash function \\\\\n$\\textnormal{\\textit{Sig}}_k(m)$ & message $m$ signed with key $k$ \\\\\n$\\varnothing$ & \\textit{null} value \\\\\n$\\|$ & concatenation \\\\\n\\bottomrule\n\\end{tabular}\n\\label{tab:notation}\n\\end{table}\n\n\n\\section{{PKISN\\xspace} Overview}\n\\label{sec:overview}\nThis section gives a high-level picture of the overall system and introduces the\nentities involved and basic terminology.\nIn {PKISN\\xspace}, clients/browsers want to communicate securely with servers/domains.\nA server is authenticated through a certificate chain created\nby a number of CAs. All certificates and revocations must be logged by a log server. At every\n\\textit{update time}, each log updates its local database, and the time period between\nthese updates is called the \\textit{scheduling period}. The log is\nverified by browsers and dedicated parties called \\textit{monitors}. CAs must also act as\nmonitors to verify that no illegitimate certificate (issued on their\nbehalf) is present in the log.\n\n\\subsection{The Certificate Log as a Timestamping Service}\nThe main goal of our work is to solve the {too-big-to-be-revoked\\xspace} problem of the current TLS PKI.\nNamely, we want to enable revocation of CA certificates without causing\ncollateral damage. The typical scenario in which a revocation is required is\nafter a private key compromise. Currently, revocation of a compromised private\nkey owned by an important CA, should invalidate all certificates signed by this\nkey, as the certificates may have been fraudulently created.\n\n\nOur main observation is that when a compromised CA can determine the time of the\nattack---more precisely, the time at which an illegitimate action (like\ncertificate issuance or revocation) was first\nobserved---then the certificates signed before the attack can still be considered valid.\nOnly certificates issued after the attack are potentially malicious, and should not be\ntrusted. It is possible for CAs to determine the time of that attack as, in the PKISN\nframework, all certificates and revocations must be logged before they are\nconsidered valid.\nThus, the instant of the first maliciously registered certificate is the instant\nof compromise.\n\nAs we cannot rely on the creation-time field of a certificate (because it may\nbe easily predated by the adversary), the main challenge in resolving the {too-big-to-be-revoked\\xspace} issue\nis the lack of a trusted timestamping service~\\cite{Haber91howto}. {PKISN\\xspace} leverages the\nconcept of a certificate log to provide this service. Depending on the deployment scenario,\na domain or a CA submits the certificate to a log. When the certificate is accepted, the log\nreturns a \\textit{chain commitment}~(CC) and appends the certificate to the\ntree in the next update. Additionally, all intermediate certificates are\nadded as well (if they are not already in the log).  The returned commitment\nincludes a list of \\textit{registration timestamps} that specifies when the\nnon-registered\ncertificates in the chain will be present in the log (in this case, the timestamp\ndenotes the next update time) and when the already registered certificates were appended to\nthe log.\n\nEvery new certificate is appended along with its registration timestamp. Thereafter,\nanyone with the obtained commitment can query the log for the presence proof of the certificate.\nAs a presence proof includes a registration timestamp, it is the confirmation that the log\ncontained a given certificate at a given point in time. Hence, a requester can\nassert that the certificate was created before this timestamp.\n\n\\subsection{Transparent and Persistent Revocation}\n{PKISN\\xspace} also employs a public log for storing revocations. In order to\nenhance the transparency of the current PKI ecosystem, revocations\nneed to be logged. For instance, whenever a key is compromised or lost, the\nowner should have a guarantee that a revocation will be visible for others at\nleast until the revoked certificate expires. The obligation of logging\ncertificates also makes CAs more transparent, as they cannot misbehave by\ndistributing two different CRLs or two different OCSP responses.\n\n{PKISN\\xspace} introduces special types of revocation messages (see\n\\S\\ref{sec:rev_msg}), and due to the hierarchical nature of the certificate\nchain, a given certificate can be revoked by a set of entities (see {PKISN\\xspace}'s revocation\npolicy below).\n\nAn authorized entity (usually the owner of a certificate) who wishes to revoke a\ncertificate can create a special revocation message. This message is submitted to\nthe log, which, after verification, returns a \\textit{revocation commitment}\nstating that the revocation will be appended to the log in the next update. When the\nrevocation message is in the log, the presence proof for the corresponding\ncertificate must contain this revocation message. To minimize the\nattack window, whenever a revocation is pending for addition, the log can\naccompany the presence proof of a certificate with its revocation,\nwithout waiting for the end of a scheduling period.\n\n\\subsection{Revocation Policy}\\label{subsec:revocation_policy}\nIn the current PKI ecosystem, a certificate can be revoked only by two\nparties, namely the issuer and a software vendor (e.g., a browser or an\nOS vendor). \nWhenever a domain wishes to revoke its own certificate, the domain must contact the\nappropriate CA that will eventually issue the revocation. Obviously, such a procedure\nresults in a prolonged attack window and depends completely on the issuing CA. Alternatively,\nthe software vendor can simply blacklist certain certificates and\npropagate the changes through software updates. In this case,\na domain has to contact the software vendor. This option can be also used for revoking\nmisbehaving CAs. However, software vendors are reluctant to use this option, as\nit renders all servers with a certificate issued by that particular CA unavailable.\n\n{PKISN\\xspace} introduces a revocation policy that reflects the interactions of the current PKI\nand the hierarchical structure of the certificate chain. Specifically, we introduce the\nfollowing revocation rules:\n\\begin{description}\n    \\item[The owner] of a leaf certificate can revoke this certificate using the associated\n        private key.\\footnote{By \\textit{associated private key} we mean the one\n        corresponding to the public key that the certificate authenticates.}\n        This option gives domains the opportunity to revoke, without the need\n        to contact CAs or a software vendor.\n\n    \\item[The issuer] (or an upper-level issuer, i.e., a CA in the certificate chain)\n        of a leaf certificate can revoke that certificate. The revocation message is created by the\n        issuer's (i.e., a CA's) private key and can be performed, for\n        example, when a domain lost its private key. Note that a certificate can be\n        revoked directly by a root CA, without involving intermediate CAs.\n\n    \\item[CAs] can revoke their own certificates and the\n        certificates of their child CAs from a given point in time called\n        \\textit{revocation timestamp}. This revocation states that certificates\n        and revocations issued after a revocation timestamp should be considered\n        invalid and should be ignored during the certificate-chain validation.\n        The CA's own certificates are revoked with a dedicated \\textit{revocation key}, while\n        child certificates are revoked with a regular private key.\n        With the revocation key, a CA can prevent all\n        potentially malicious actions starting from a certain point in time.\n        A CA can use its revocation key only once, and as it invalidates the\n        CA's certificate there is no need to revoke or update a revocation\n        key. A new revocation key is generated every time a CA's certificate is\n        created.\n\n    \\item[A software vendor] can revoke any certificate, and for CA\n        certificates, they have to specify a revocation timestamp as above. Only\n        child certificates and revocations issued with the revoked\n        certificate before that timestamp are considered valid.\n        Currently, software vendors effectively have the ability to revoke\n        any certificate, so this option explicitly reflects their power in the current\n        TLS PKI ecosystem. Moreover, {PKISN\\xspace} holds their actions accountable and\n        transparent. For the sake of simplicity, we assume that there is a\n        single software vendor that issues revocations with a private \\emph{vendor key}.\n        The corresponding public key is provided to the clients within the software\n        (like today), and can be updated with a software update (but cannot be\n        revoked through {PKISN\\xspace}).\n\\end{description}\nNote that we do not allow a revoked (i.e., compromised, usually) CA to revoke its child certificates,\neven if the revocation had been legitimate \n(otherwise an adversary could cause collateral damage by invalidating\ncertificates with the already revoked key).\nIn such a case, any non-revoked\nCA in the certificate chain can still issue a valid revocation for the leaf certificate. \nHowever, after a CA is revoked, its clients should be informed that, although\ntheir legitimately-issued certificates are still valid and can be used, the CA lost its revocation\nability, and the certificates should be reissued in the near future (e.g., few days or weeks).\n\nPossible revocation actions for an example certificate chain are presented\nin Fig.~\\ref{fig:revocations}.\nA single certificate can have many associated revocations. All these revocations\ncan be fetched from the log with a presence proof.\n\\begin{figure}[h]\n  \\centering\n  \\includegraphics[width=\\linewidth]{revocations.eps}\n  \\caption{All possible revocations for a certificate chain $C_a\\rightarrow\n      C_b\\rightarrow C_c$, where $C_a$ and $C_b$ have associated keys $\\textit{sk}_a,\n      \\textit{rk}_a$ and $\\textit{sk}_b, \\textit{rk}_b$, respectively (standard and revocation private keys),\n      while the leaf certificate is associated only with a standard private key $\\textit{sk}_c$,\n  and $\\textit{vk}$ denotes the software vendor key.}\n  \\label{fig:revocations}\n\\end{figure}\n\n\n\\subsection{Validation}\nFor a successful validation, a client must be provided with a certificate chain,\na corresponding chain commitment (CC), and a proof from the log. \nFirst, the input data is pre-validated (for details see \\S\\ref{sec:pre_valid}),\nand verified. This includes a standard chain validation as executed in modern\nbrowsers. However, the {PKISN\\xspace} validation process goes further, as it \ndetermines time periods for which CAs were behaving legitimately.\n\nAs shown in Fig.~\\ref{fig:revocations}, a single certificate can be revoked\nby different entities and through different revocation messages. Hence,\nto achieve an unambiguous validation of revocation messages, priorities\nmust be established. {PKISN\\xspace} introduces the following priorities for revocation messages,\nfrom the highest priority to the lowest:\n\\begin{enumerate}\n\\item revocations issued by the software vendor,\n\\item revocations created with a dedicated revocation key (only applies to non-leaf certificates),\n\\item revocations issued by parent CAs,\n\\item revocations created with the standard private key associated with the\ncertificate (only applies to leaf certificates).\n\\end{enumerate}\n\nTo conduct a validation, {PKISN\\xspace} introduces the notion of a \\textit{legitimacy\nperiod}, which denotes a time period during which actions performed by\nCAs are considered valid. The legitimacy period is \ndefined between the moment when a certificate is received by the log for the\nfirst time (registration timestamp) and the moment when it expires or is legitimately\nrevoked (revocation timestamp). A certificate is considered valid when it\npasses the \\textit{pre-validation} and when all certificates in the chain\nwere issued (and never revoked) during corresponding legitimacy periods.\n\nAn example that illustrates the concept of legitimacy periods is presented in\nFig.~\\ref{fig:timelines}. In this example, the root CA certificate $C_a$ gets compromised,\nbut the attack is then detected and the CA is able to determine the time at which the attack\nwas performed. In the meantime, the adversary used the private key to maliciously revoke\nthe certificate $C_b$ of an intermediate CA.\\footnote{Although such an attack was never observed\nin the real world (to the best of our knowledge), nothing currently prevents an adversary who\ncompromised a private key from performing revocations. Therefore, our new scheme should\ntake this case into account.}\nIn this particular case, the leaf certificate $C_c$ is\nvalid even though its parent CA certificate was revoked, as {PKISN\\xspace} allows to express the fact\nthat $C_b$ was maliciously revoked (the revocation was done during the\n\\emph{illegitimacy period} of $C_a$).\n\n\\begin{figure}[h!]\n  \\centering\n  \\includegraphics[width=\\linewidth]{timelines.eps}\n  \\caption{Timelines for a chain of three certificates, with an attack (against the root CA) and a detection thereof.}\n  \\label{fig:timelines}\n\\end{figure}\n\n\n\\subsection{Log Consistency}\nPeriodically, a browser contacts a random monitor to ensure that they share the\nsame view of the log. As monitors have a copy of the log, they can inform about\nhistoric versions. To prevent equivocation, browsers can compare log information\nobtained during the TLS connections with corresponding monitor statements. Even\nif such\na procedure does not completely protect against malicious logs, it enables to\ndetect log misbehavior.\n\n\n\\section{{PKISN\\xspace} Details}\n\\label{sec:details}\n\\subsection{Revocation Messages}\\label{sec:rev_msg}\n{PKISN\\xspace} introduces a new dedicated revocation\nkey pair for CAs.\nThe revocation private key is only used when a given CA notices that its\nstandard private key (used in production) has been compromised or lost.\nAs the revocation key is not used in production, it should be securely\nstored offline.\n\n{PKISN\\xspace} supports two formats of revocation messages. The first one is used\nfor invalidating leaf certificates:\n\n", "index": 3, "text": "\\begin{equation}\\label{eq:rev1}\n    R_{C_x} = \\textit{Sig}_k(H(C_x), \\texttt{revoke}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"R_{C_{x}}=\\textit{Sig}_{k}(H(C_{x}),\\texttt{revoke}),\" display=\"block\"><mrow><mrow><msub><mi>R</mi><msub><mi>C</mi><mi>x</mi></msub></msub><mo>=</mo><mrow><msub><mtext>\ud835\udc46\ud835\udc56\ud835\udc54</mtext><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mtext>\ud835\ude9b\ud835\ude8e\ud835\ude9f\ud835\ude98\ud835\ude94\ud835\ude8e</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nwhere $k$ can be\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item the CA's revocation key,\n\\item the standard private key of a parent CA, or\n\\item a software vendor key.  This revocation message contains a\nrevocation timestamp, that indicates a time from which all actions\n(certificates and revocations issuances) of the revoked CA must be considered\ninvalid. This timestamp must be earlier than the expiration time specified within the\nrevoked certificate.\n\\end{inparaenum}\n\n\\subsection{Structure of the Log}\nIn {PKISN\\xspace}, a log stores all the issued certificates and revocations, and additionally\nprocesses them like a timestamping service. \nOn demand, the log can produce efficient\nproofs about the stored content. The log is designed to support the following\noperations:\n\\begin{enumerate}\n    \\item prove that a given certificate or revocation is in the log and was\n        appended to the log at a given point in time,\n    \\item prove that a given certificate or revocation was not appended to the\n        log at a given point in time,\n    \\item with a given chain commitment (CC), prove that all certificates from\n        the chain were appended correctly (according to the timestamps of the CC)\n        and show all revocations associated with these certificates, \n    \\item prove that one snapshot of the log is an append-only extension of any\n        previous one.\n\\end{enumerate}\n\nAdditionally, relevant information about a particular certificate chain must\nbe processed efficiently. To provide these features, the log maintains two\nhash-tree-based data structures: a \\textit{TimeTree} and a \\textit{RevTree}\n(Revocation Tree). Fig.~\\ref{fig:trees} depicts an example of these trees.\n\nThe TimeTree contains all objects added to the log in chronological\norder. It stores certificates ($C_x$), revocations ($R_{C_x}$), and roots of the\nRevTree. All objects are accompanied with a registration timestamp that denotes\nwhen the object was actually appended to the tree. \nWith the TimeTree, it is possible to prove that a given object is indeed an\nelement of the log and was inserted at a given registration timestamp.\nAdditionally, it is possible to prove that one version of the TimeTree is an\nextension of the previous TimeTree.\n\nThe RevTree consists of sub-trees (it is, in fact, a forest) that reflect the\nhierarchical structure of certificate chains. The RevTree is built\nafter every scheduling period, and the root of this tree is the last element appended to the\nTimeTree in every update of the log. The leaves of every sub-tree consist of:\n\\begin{itemize}\n    \\item A hash $H_x=H(C_x\\|t_x)$ that identifies a certificate $C_x$ and\n        a registration timestamp $t_x$. The leaves of every sub-tree are sorted\n        in lexicographical order of these hashes.\n    \\item The possible revocation messages of $C_x$. This may be\n        $\\varnothing$ when a certificate has no associated revocation message. Every\n        revocation $R_{C_x}$ is accompanied with a registration timestamp, which indicates\n        when the revocation was appended to the log (this is not a\n        revocation timestamp as in Eq.~(\\ref{eq:rev2})).\n    \\item The root ($r_x$) of the sub-tree (the sub-tree contains certificates\n        signed with the private key associated to $C_x$), that may be $\\varnothing$ when\n        the certificate does not have any children (e.g., leaf certificates). For\n        efficiency reasons, leaves can also store pointers to their sub-trees. \n\\end{itemize}\nThe RevTree's top sub-tree identifies root certificates, and every leaf is\nassociated with a sub-tree of its child certificates. This design allows\nthe log to efficiently:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item prove that all certificates from a chain were appended to the log at a given\ntime, and\n\\item show all the revocations associated with these certificates.\nAs all the leaves of a RevTree's sub-trees are sorted in lexicographical order, it\nis also possible to prove that a given certificate was not appended to the tree at\na given time. In combination with a TimeTree, a complete proof contains the\ninformation that the RevTree's proof comes from the current version of the\nRevTree, as its root is the very last element of the TimeTree.\n\\end{inparaenum}\n\n\\begin{figure*}[t!]\n\\centering\n  \\begin{tikzpicture}[scale=.45,every tree node/.style={font=\\LARGE,anchor=base}]\n    \\Tree \n    [.\\textit{root}\n        [.\\fbox{$H_{abcdefgr_0}$}\n     [.${H_\\mathit{abcd}}$\n        [.${H_{ab}}$\n        [.$H_a$ $C_{a},t_0$ ] [.$H_b$ $C_{b},t_0$  ] ]\n        [.${H_{cd}}$\n        [.$H_c$ $C_{c},t_0$ ] [.$H_d$ $C_d,t_0$ ] ] \n    ]\n    [.${H_\\mathit{efgr_0}}$\n        [.${H_{ef}}$\n        [.${H_e}$ $C_e,t_0$ ] [.$H_f$ $C_f,t_0$  ] ]\n        [.${H_\\mathit{gr_0}}$\n        [.$H_g$ $C_g,t_0$ ] [.$H_{r_0}$ $r_0,t_0$ ] ] \n    ]\n ]\n  [.$H_\\mathit{hijd'klmr_1}$\n    [.\\fbox{$H_{hijd'}$}\n        [.${H_{hi}}$\n        [.${H_h}$ $C_h,t_1$ ] [.$H_i$ $C_i,t_1$  ] ]\n        [.${H_{jd'}}$\n        [.$H_j$ $C_j,t_1$ ] [.$H_{d'}$ $R_{C_d},t_1$ ] ] \n    ]\n    [.${H_\\mathit{klmr_1}}$\n        [.\\fbox{$H_{kl}$}\n        [.${H_k}$ $C_k,t_1$ ] [.$H_l$ $C_l,t_1$  ] ]\n        [.${H_{mr_1}}$\n            [.\\fbox{$H_m$} $C_m,t_1$ ] [.$H_{r_1}$\n        \\node(r1t){$r_1,$\\fbox{$t_1$}}; ] ] \n    ]\n  ]\n ]\n \\begin{scope}[shift={(20,-1.5cm)}]\n    \\Tree \n    [.\\node(r1f){$r_1$};\n        [.$H_{12}$\n        [.\\fbox{$H_1$} [.$H_b,\\varnothing$ ... ] ] [.$H_2$ [.\\fbox{$H_a$,$\\varnothing$} $r_a$ ]  ] ]\n        [.{} [.\\fbox{$H_3$} \n        [.$H_c,\\varnothing$ ... ] ] ]\n    ]\n\\end{scope}\n \\begin{scope}[shift={(19.5,-5.8cm)}]\n     \\Tree   \n     [.{}\n         [.$H^a_{12}$\n             [.\\fbox{$H^a_1$} [.$H_e,\\varnothing$ ... ] ] [.$H^a_2$\n                 [.\\fbox{$H_d,(R_{C_d},t_1)$} $r_d$ ]  \n        ] ]\n        [.{} [.\\fbox{$H^a_{3}$} [.$H_f,\\varnothing$ ... ]\n         ]  \n        ]\n    ]\n\\end{scope}\n\\begin{scope}[shift={(18.75,-10.2cm)}]\n     \\Tree   \n     [.{}\n         [.$H^d_{12}$\n             [.\\fbox{$H^d_1$} [.$H_k,\\varnothing$ $\\varnothing$ ] ] [.$H^d_2$\n                 [.\\fbox{$H_{m},\\varnothing$} \\fbox{$\\varnothing$} ]  \n        ] ]\n        [.\\fbox{$H^d_{34}$}\n             [.$H^d_3$ [.$H_g,\\varnothing$ $\\varnothing$ ] ] [.$H^d_4$\n                 [.$H_j,\\varnothing$ $\\varnothing$ ]\n        ] ]  \n    ]\n\\end{scope}\n\\draw[->](r1f) .. controls +(north:5) and +(south:5) .. (r1t);\n\\begin{scope}[dashed]\n    \\draw[->](-10,-6) -- node[below] {\\textit{time}} (10,-6);\n\\end{scope}\n\\node [draw] at (0,-11) {\n    \\begin{minipage}{0.50\\textwidth}\n        Presence proof for $C_m$ (in the chain $C_a\\rightarrow C_d\\rightarrow C_m$): \n\n", "itemtype": "equation", "pos": 36549, "prevtext": "\nwhere $k$ can be:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item a private key associated with the authenticated public key in a leaf certificate,\n\\item the private key of one of the CAs in the certification chain, or\n\\item a software vendor key. Note that in contrast with the current\nrevocation system, domains can revoke their own certificates without any\ninteraction with the issuing CAs. Leaf certificates do not contain a special\nrevocation key and can be revoked without a revocation timestamp, as they cannot\ncause collateral damage.\n\\end{inparaenum}\n\nBecause CA certificates introduce collateral damage,\nthey are always revoked by the following revocation message:\n\n", "index": 5, "text": "\\begin{equation}\\label{eq:rev2}\n    R_{C_x} = \\textit{Sig}_k(H(C_x), \\texttt{revoke from } \\textit{rev\\_timestamp}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"R_{C_{x}}=\\textit{Sig}_{k}(H(C_{x}),\\texttt{revoke from }\\textit{rev\\_%&#10;timestamp}),\" display=\"block\"><mrow><mrow><msub><mi>R</mi><msub><mi>C</mi><mi>x</mi></msub></msub><mo>=</mo><mrow><msub><mtext>\ud835\udc46\ud835\udc56\ud835\udc54</mtext><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mtext mathvariant=\"monospace\">revoke from\u00a0</mtext><mtext mathvariant=\"italic\">rev_timestamp</mtext></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\n    \\end{minipage}\n};\n\\end{tikzpicture}\n\\caption{Example of log trees. The TimeTree stores all objects in chronological\n    order, while the leaves of the RevTree's subtrees are sorted lexicographically.\n    The log contains one revocation message $R_{C_d}$ associated with the\n    certificate $C_d$. Nodes in boxes are needed for the presence proof of\n    certificate chain $C_a\\rightarrow C_d\\rightarrow C_m$.}\n\\label{fig:trees}\n\\end{figure*}\n\n\\subsection{Interactions with the Log}\n{\\noindent{\\bf{Certificate Registration}.}}\nBefore a certificate is used it must be submitted to the log.\nFor instance, a domain with leaf certificate $C_m$ sends the following certificate\nchain to the log:\n\n", "itemtype": "equation", "pos": 43280, "prevtext": "\nwhere $k$ can be\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item the CA's revocation key,\n\\item the standard private key of a parent CA, or\n\\item a software vendor key.  This revocation message contains a\nrevocation timestamp, that indicates a time from which all actions\n(certificates and revocations issuances) of the revoked CA must be considered\ninvalid. This timestamp must be earlier than the expiration time specified within the\nrevoked certificate.\n\\end{inparaenum}\n\n\\subsection{Structure of the Log}\nIn {PKISN\\xspace}, a log stores all the issued certificates and revocations, and additionally\nprocesses them like a timestamping service. \nOn demand, the log can produce efficient\nproofs about the stored content. The log is designed to support the following\noperations:\n\\begin{enumerate}\n    \\item prove that a given certificate or revocation is in the log and was\n        appended to the log at a given point in time,\n    \\item prove that a given certificate or revocation was not appended to the\n        log at a given point in time,\n    \\item with a given chain commitment (CC), prove that all certificates from\n        the chain were appended correctly (according to the timestamps of the CC)\n        and show all revocations associated with these certificates, \n    \\item prove that one snapshot of the log is an append-only extension of any\n        previous one.\n\\end{enumerate}\n\nAdditionally, relevant information about a particular certificate chain must\nbe processed efficiently. To provide these features, the log maintains two\nhash-tree-based data structures: a \\textit{TimeTree} and a \\textit{RevTree}\n(Revocation Tree). Fig.~\\ref{fig:trees} depicts an example of these trees.\n\nThe TimeTree contains all objects added to the log in chronological\norder. It stores certificates ($C_x$), revocations ($R_{C_x}$), and roots of the\nRevTree. All objects are accompanied with a registration timestamp that denotes\nwhen the object was actually appended to the tree. \nWith the TimeTree, it is possible to prove that a given object is indeed an\nelement of the log and was inserted at a given registration timestamp.\nAdditionally, it is possible to prove that one version of the TimeTree is an\nextension of the previous TimeTree.\n\nThe RevTree consists of sub-trees (it is, in fact, a forest) that reflect the\nhierarchical structure of certificate chains. The RevTree is built\nafter every scheduling period, and the root of this tree is the last element appended to the\nTimeTree in every update of the log. The leaves of every sub-tree consist of:\n\\begin{itemize}\n    \\item A hash $H_x=H(C_x\\|t_x)$ that identifies a certificate $C_x$ and\n        a registration timestamp $t_x$. The leaves of every sub-tree are sorted\n        in lexicographical order of these hashes.\n    \\item The possible revocation messages of $C_x$. This may be\n        $\\varnothing$ when a certificate has no associated revocation message. Every\n        revocation $R_{C_x}$ is accompanied with a registration timestamp, which indicates\n        when the revocation was appended to the log (this is not a\n        revocation timestamp as in Eq.~(\\ref{eq:rev2})).\n    \\item The root ($r_x$) of the sub-tree (the sub-tree contains certificates\n        signed with the private key associated to $C_x$), that may be $\\varnothing$ when\n        the certificate does not have any children (e.g., leaf certificates). For\n        efficiency reasons, leaves can also store pointers to their sub-trees. \n\\end{itemize}\nThe RevTree's top sub-tree identifies root certificates, and every leaf is\nassociated with a sub-tree of its child certificates. This design allows\nthe log to efficiently:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n\\item prove that all certificates from a chain were appended to the log at a given\ntime, and\n\\item show all the revocations associated with these certificates.\nAs all the leaves of a RevTree's sub-trees are sorted in lexicographical order, it\nis also possible to prove that a given certificate was not appended to the tree at\na given time. In combination with a TimeTree, a complete proof contains the\ninformation that the RevTree's proof comes from the current version of the\nRevTree, as its root is the very last element of the TimeTree.\n\\end{inparaenum}\n\n\\begin{figure*}[t!]\n\\centering\n  \\begin{tikzpicture}[scale=.45,every tree node/.style={font=\\LARGE,anchor=base}]\n    \\Tree \n    [.\\textit{root}\n        [.\\fbox{$H_{abcdefgr_0}$}\n     [.${H_\\mathit{abcd}}$\n        [.${H_{ab}}$\n        [.$H_a$ $C_{a},t_0$ ] [.$H_b$ $C_{b},t_0$  ] ]\n        [.${H_{cd}}$\n        [.$H_c$ $C_{c},t_0$ ] [.$H_d$ $C_d,t_0$ ] ] \n    ]\n    [.${H_\\mathit{efgr_0}}$\n        [.${H_{ef}}$\n        [.${H_e}$ $C_e,t_0$ ] [.$H_f$ $C_f,t_0$  ] ]\n        [.${H_\\mathit{gr_0}}$\n        [.$H_g$ $C_g,t_0$ ] [.$H_{r_0}$ $r_0,t_0$ ] ] \n    ]\n ]\n  [.$H_\\mathit{hijd'klmr_1}$\n    [.\\fbox{$H_{hijd'}$}\n        [.${H_{hi}}$\n        [.${H_h}$ $C_h,t_1$ ] [.$H_i$ $C_i,t_1$  ] ]\n        [.${H_{jd'}}$\n        [.$H_j$ $C_j,t_1$ ] [.$H_{d'}$ $R_{C_d},t_1$ ] ] \n    ]\n    [.${H_\\mathit{klmr_1}}$\n        [.\\fbox{$H_{kl}$}\n        [.${H_k}$ $C_k,t_1$ ] [.$H_l$ $C_l,t_1$  ] ]\n        [.${H_{mr_1}}$\n            [.\\fbox{$H_m$} $C_m,t_1$ ] [.$H_{r_1}$\n        \\node(r1t){$r_1,$\\fbox{$t_1$}}; ] ] \n    ]\n  ]\n ]\n \\begin{scope}[shift={(20,-1.5cm)}]\n    \\Tree \n    [.\\node(r1f){$r_1$};\n        [.$H_{12}$\n        [.\\fbox{$H_1$} [.$H_b,\\varnothing$ ... ] ] [.$H_2$ [.\\fbox{$H_a$,$\\varnothing$} $r_a$ ]  ] ]\n        [.{} [.\\fbox{$H_3$} \n        [.$H_c,\\varnothing$ ... ] ] ]\n    ]\n\\end{scope}\n \\begin{scope}[shift={(19.5,-5.8cm)}]\n     \\Tree   \n     [.{}\n         [.$H^a_{12}$\n             [.\\fbox{$H^a_1$} [.$H_e,\\varnothing$ ... ] ] [.$H^a_2$\n                 [.\\fbox{$H_d,(R_{C_d},t_1)$} $r_d$ ]  \n        ] ]\n        [.{} [.\\fbox{$H^a_{3}$} [.$H_f,\\varnothing$ ... ]\n         ]  \n        ]\n    ]\n\\end{scope}\n\\begin{scope}[shift={(18.75,-10.2cm)}]\n     \\Tree   \n     [.{}\n         [.$H^d_{12}$\n             [.\\fbox{$H^d_1$} [.$H_k,\\varnothing$ $\\varnothing$ ] ] [.$H^d_2$\n                 [.\\fbox{$H_{m},\\varnothing$} \\fbox{$\\varnothing$} ]  \n        ] ]\n        [.\\fbox{$H^d_{34}$}\n             [.$H^d_3$ [.$H_g,\\varnothing$ $\\varnothing$ ] ] [.$H^d_4$\n                 [.$H_j,\\varnothing$ $\\varnothing$ ]\n        ] ]  \n    ]\n\\end{scope}\n\\draw[->](r1f) .. controls +(north:5) and +(south:5) .. (r1t);\n\\begin{scope}[dashed]\n    \\draw[->](-10,-6) -- node[below] {\\textit{time}} (10,-6);\n\\end{scope}\n\\node [draw] at (0,-11) {\n    \\begin{minipage}{0.50\\textwidth}\n        Presence proof for $C_m$ (in the chain $C_a\\rightarrow C_d\\rightarrow C_m$): \n\n", "index": 7, "text": "\\begin{multline}\\label{eq:proof}\n    \\{H_m,\\varnothing,\\varnothing, H^d_1, H^d_{34}, H_d, (R_{C_d},t_1), H^a_1, H^a_3, \\\\\n        H_a,\\varnothing, H_1, H_3, t_1, H_m, H_\\mathit{kl}, H_\\mathit{hijd'},\n    H_\\mathit{abcdefgr_0}\\}.\n\\end{multline}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{H_{m},\\varnothing,\\varnothing,H^{d}_{1},H^{d}_{34},H_{d},(R_{C_%&#10;{d}},t_{1}),H^{a}_{1},H^{a}_{3},\\\\&#10;\\displaystyle H_{a},\\varnothing,H_{1},H_{3},t_{1},H_{m},H_{\\mathit{kl}},H_{%&#10;\\mathit{hijd^{\\prime}}},H_{\\mathit{abcdefgr_{0}}}\\}.\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo stretchy=\"false\">{</mo><msub><mi>H</mi><mi>m</mi></msub><mo>,</mo><mi mathvariant=\"normal\">\u2205</mi><mo>,</mo><mi mathvariant=\"normal\">\u2205</mi><mo>,</mo><msubsup><mi>H</mi><mn>1</mn><mi>d</mi></msubsup><mo>,</mo><msubsup><mi>H</mi><mn>34</mn><mi>d</mi></msubsup><mo>,</mo><msub><mi>H</mi><mi>d</mi></msub><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><msub><mi>C</mi><mi>d</mi></msub></msub><mo>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><msubsup><mi>H</mi><mn>1</mn><mi>a</mi></msubsup><mo>,</mo><msubsup><mi>H</mi><mn>3</mn><mi>a</mi></msubsup><mo>,</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><msub><mi>H</mi><mi>a</mi></msub><mo>,</mo><mi mathvariant=\"normal\">\u2205</mi><mo>,</mo><msub><mi>H</mi><mn>1</mn></msub><mo>,</mo><msub><mi>H</mi><mn>3</mn></msub><mo>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><msub><mi>H</mi><mi>m</mi></msub><mo>,</mo><msub><mi>H</mi><mi>\ud835\udc58\ud835\udc59</mi></msub><mo>,</mo><msub><mi>H</mi><msup><mi>\u210e\ud835\udc56\ud835\udc57\ud835\udc51</mi><mo>\u2032</mo></msup></msub><mo>,</mo><msub><mi>H</mi><msub><mi>\ud835\udc4e\ud835\udc4f\ud835\udc50\ud835\udc51\ud835\udc52\ud835\udc53\ud835\udc54\ud835\udc5f</mi><mn/></msub></msub><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nTo automate this operation, certificates can also be submitted to the log by CAs,\nin a similar way as \\emph{pre-certificates} can be submitted in CT~\\cite{rfc6962}.\nThe log verifies the chain, and schedules the inclusion of non-appended\ncertificates from the chain to the TimeTree and the RevTree.\nAny new certificate will be appended along with a\nregistration timestamp. The log\nreturns a \\emph{Chain Commitment}~(CC) signed with $k_{\\textit{log}}$ immediately after verification.\nThe CC consists of:\n\n", "itemtype": "equation", "pos": 44216, "prevtext": "\n    \\end{minipage}\n};\n\\end{tikzpicture}\n\\caption{Example of log trees. The TimeTree stores all objects in chronological\n    order, while the leaves of the RevTree's subtrees are sorted lexicographically.\n    The log contains one revocation message $R_{C_d}$ associated with the\n    certificate $C_d$. Nodes in boxes are needed for the presence proof of\n    certificate chain $C_a\\rightarrow C_d\\rightarrow C_m$.}\n\\label{fig:trees}\n\\end{figure*}\n\n\\subsection{Interactions with the Log}\n{\\noindent{\\bf{Certificate Registration}.}}\nBefore a certificate is used it must be submitted to the log.\nFor instance, a domain with leaf certificate $C_m$ sends the following certificate\nchain to the log:\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:chain}\nC_a\\rightarrow C_d\\rightarrow C_m.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"C_{a}\\rightarrow C_{d}\\rightarrow C_{m}.\" display=\"block\"><mrow><mrow><msub><mi>C</mi><mi>a</mi></msub><mo>\u2192</mo><msub><mi>C</mi><mi>d</mi></msub><mo>\u2192</mo><msub><mi>C</mi><mi>m</mi></msub></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nIt constitutes a promise that $C_m$ will be appended at $t_m$, and that $C_d, C_a$ are\nor will be visible after $t_d$ and $t_a$, respectively. As each certificate\nis unique within a log, the registration timestamps for CA\ncertificates will often be from the past (as it is likely that these\ncertificates have been submitted before). The following must always be\nsatisfied: $t_m\\ge t_d\\ge t_a$.\n\n{\\noindent{\\bf{Proof Querying}.}}\nIn the first update time after a successful submission, the certificate is added to the\ntrees. Thereafter, anyone can query the log for the presence proof of the certificate.\nThe internal design of {PKISN\\xspace} optimizes the log for serving presence/absence\nproofs to a\nrequester with a certificate chain and a corresponding CC, as this is the most\ncommon interaction with the log.\n\nFor instance, with a certificate chain $C_a\\rightarrow C_d\\rightarrow C_m$ and\nthe corresponding CC from Eq.~(\\ref{eq:CC}), the following request is prepared\nand sent to the log:\n\n", "itemtype": "equation", "pos": 44801, "prevtext": "\nTo automate this operation, certificates can also be submitted to the log by CAs,\nin a similar way as \\emph{pre-certificates} can be submitted in CT~\\cite{rfc6962}.\nThe log verifies the chain, and schedules the inclusion of non-appended\ncertificates from the chain to the TimeTree and the RevTree.\nAny new certificate will be appended along with a\nregistration timestamp. The log\nreturns a \\emph{Chain Commitment}~(CC) signed with $k_{\\textit{log}}$ immediately after verification.\nThe CC consists of:\n\n", "index": 11, "text": "\\begin{equation}\\label{eq:CC}\n    \\textit{Sig}_{k_{\\textit{log}}}(H(C_m), t_m, t_d, t_a).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\textit{Sig}_{k_{\\textit{log}}}(H(C_{m}),t_{m},t_{d},t_{a}).\" display=\"block\"><mrow><mrow><msub><mtext>\ud835\udc46\ud835\udc56\ud835\udc54</mtext><msub><mi>k</mi><mtext>\ud835\udc59\ud835\udc5c\ud835\udc54</mtext></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>m</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><msub><mi>t</mi><mi>m</mi></msub><mo>,</mo><msub><mi>t</mi><mi>d</mi></msub><mo>,</mo><msub><mi>t</mi><mi>a</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nDue to the structure of the request, the log can efficiently locate the requested\nleaves in the RevTree, and generate a presence proof, by showing all\nintermediate nodes necessary to build the tree root. For instance, for the\ncontent presented in Fig.~\\ref{fig:trees} and the previous request, the log can\nproduce the presence proof from Eq.~(\\ref{eq:proof}) (see\nFig.~\\ref{fig:trees}).\nNote that whenever a certificate from the chain has some associated revocation messages,\nthese messages must be contained within the proof.\nIt guarantees that a revocation status for every certificate from the chain is\nknown.\nThe proof is returned to the requester accompanied with the current signed root:\n\n", "itemtype": "equation", "pos": 45899, "prevtext": "\nIt constitutes a promise that $C_m$ will be appended at $t_m$, and that $C_d, C_a$ are\nor will be visible after $t_d$ and $t_a$, respectively. As each certificate\nis unique within a log, the registration timestamps for CA\ncertificates will often be from the past (as it is likely that these\ncertificates have been submitted before). The following must always be\nsatisfied: $t_m\\ge t_d\\ge t_a$.\n\n{\\noindent{\\bf{Proof Querying}.}}\nIn the first update time after a successful submission, the certificate is added to the\ntrees. Thereafter, anyone can query the log for the presence proof of the certificate.\nThe internal design of {PKISN\\xspace} optimizes the log for serving presence/absence\nproofs to a\nrequester with a certificate chain and a corresponding CC, as this is the most\ncommon interaction with the log.\n\nFor instance, with a certificate chain $C_a\\rightarrow C_d\\rightarrow C_m$ and\nthe corresponding CC from Eq.~(\\ref{eq:CC}), the following request is prepared\nand sent to the log:\n\n", "index": 13, "text": "\\begin{equation}\\label{eq:req}\n    H(C_m\\|t_m), H(C_d\\|t_d), H(C_a\\|t_a).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"H(C_{m}\\|t_{m}),H(C_{d}\\|t_{d}),H(C_{a}\\|t_{a}).\" display=\"block\"><mrow><mi>H</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>m</mi></msub><mo>\u2225</mo><msub><mi>t</mi><mi>m</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>H</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>d</mi></msub><mo>\u2225</mo><msub><mi>t</mi><mi>d</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>H</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>C</mi><mi>a</mi></msub><mo>\u2225</mo><msub><mi>t</mi><mi>a</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nThe signed root can also be requested separately. In our setting, the combination\nof a presence proof and the signed root is the most important piece of information\nfrom a client's perspective; it contains almost everything to perform a certificate\nvalidation. However, in {PKISN\\xspace}, a log is also obligated to provide extension proofs\nbetween two versions of the TimeTree (to prove the consistency of two snapshots of\nthe log).\n\n{\\noindent{\\bf{Certificate Revocation}.}}\nAn entity allowed to revoke a certificate ${C_x}$ can create a revocation message\nfrom Eq.~(\\ref{eq:rev1}) or Eq.~(\\ref{eq:rev2}). The revocation message\n$R_{C_x}$ is sent along with a certificate chain whose last certificate is\nintended to be revoked. The log, after verifying whether the revocation is legitimate\nand matches the certificate, schedules the revocation and returns a message:\n\n", "itemtype": "equation", "pos": 46682, "prevtext": "\nDue to the structure of the request, the log can efficiently locate the requested\nleaves in the RevTree, and generate a presence proof, by showing all\nintermediate nodes necessary to build the tree root. For instance, for the\ncontent presented in Fig.~\\ref{fig:trees} and the previous request, the log can\nproduce the presence proof from Eq.~(\\ref{eq:proof}) (see\nFig.~\\ref{fig:trees}).\nNote that whenever a certificate from the chain has some associated revocation messages,\nthese messages must be contained within the proof.\nIt guarantees that a revocation status for every certificate from the chain is\nknown.\nThe proof is returned to the requester accompanied with the current signed root:\n\n", "index": 15, "text": "\\begin{equation}\\label{eq:root}\n    \\textit{Sig}_{k_{\\textit{log}}}(root, t_x).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\textit{Sig}_{k_{\\textit{log}}}(root,t_{x}).\" display=\"block\"><mrow><mrow><msub><mtext>\ud835\udc46\ud835\udc56\ud835\udc54</mtext><msub><mi>k</mi><mtext>\ud835\udc59\ud835\udc5c\ud835\udc54</mtext></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>t</mi></mrow><mo>,</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nwhich states that the revocation will be appended to the log after time $t_x$.\nHowever, during the scheduling period (when the revocation is not yet\nappended) the log can attach a revocation message to every relevant presence\nproof. This would reduce the attack window. During the update of the log,\nthe revocation message is appended to the TimeTree and is appended to the \nRevTree's leaf which corresponds to the revoked certificate. From that time\nforward, every presence proof requested for a chain that contains the revoked\ncertificate must contain the revocation message.\n\n{\\noindent{\\bf{Monitoring}.}}\\label{sec:monitoring}\nThe role of a \\emph{monitor} is to verify the correct behavior of a log. Each monitor\nperiodically (after every log update) contacts the log and downloads the newly\nappended objects and the current signed root. Then, the monitor updates its own\ncopy of the log, by appending new certificates and revocations to the TimeTree,\nand by introducing all changes to the RevTree. After that, the monitor puts the current\nroot of its RevTree as the last leaf into the TimeTree. Finally, the monitor computes\nthe root of its own copy of the TimeTree and compares it with the root received from\nthe log. During this update, the monitor also verifies whether the certificates\nand revocations accepted by the log were legitimate. \n\nThrough this periodic update, the monitors can detect any inconsistency/misbehavior\nof the log. Anyone can request signed roots from a monitor, and report a proof of\nmisbehavior such as:\n\\begin{itemize}\n    \\item an incorrect CC (with incorrect registration timestamps or absence proof of a\n        certificate that was not appended), \n    \\item a revocation that is not appended (showing a message from\n        Eq.~(\\ref{eq:rev_commit}), and a proof that the revocation is not in the\n        log),\n    \\item two different roots from the same time period,\n    \\item the presence proof of an invalid certificate or revocation. \n\\end{itemize}\n\nThe monitor, in such a setting, must replicate the log's content. In\n\\S\\ref{sec:light_monitor}, we propose a novel deployment model that allows to\nimplement a monitor in a lightweight manner. \n\n\\subsection{Validation}\\label{sec:validation}\nTo conduct a certificate validation, a client needs:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n    \\item a certificate chain, \n    \\item a chain commitment, \n    \\item a proof of presence, \n    \\item and the corresponding signed root. \n\\end{inparaenum}\nThe full validation is presented in Algorithm~\\ref{alg:validation}. This section\npresents the different steps. We assume that before validation, the structure and format of\nall messages is checked.\n\\begin{algorithm}[h!]\n\t\\caption{Complete certificate validation.}\n\t\\label{alg:validation}\n\t\\small\n\t\n\t\\begin{description}\n        \\item[$\\textnormal{\\textit{root}}:$] signed root (TimeTree), e.g.,\n            Eq.~(\\ref{eq:root})\n\t\t\\item[$\\textnormal{\\textit{proof}}:$] presence proof, e.g.,\n            Eq.~(\\ref{eq:proof})\n\t\t\\item[$\\textnormal{\\textit{chain}}:$] certificate chain, e.g.,\n            Eq.~(\\ref{eq:chain})\n\t\t\\item[$\\textnormal{\\textit{CC}}:$] signed chain commitment, e.g.,\n            Eq.~(\\ref{eq:CC})\n\t\t\\item[$\\textnormal{\\textit{name}}:$] name of the contacted domain\n\t\t\\item[$t_x:$] registration timestamp of $C_x$\n\t\t\\item[$\\textnormal{\\textit{LP}}:$] dictionary that maps certificates to\n            their legitimacy periods\n\t\t\\item[$\\textnormal{\\textit{currTime()}}:$] returns current time in Unix seconds\n\t\t\\item[$\\textnormal{\\textit{preValidate()}}:$] returns \\textit{true} $\\Leftrightarrow$ pre-validation passes\n\t\t\\item[$\\textnormal{\\textit{verifyProofs()}}:$] returns \\textit{true} $\\Leftrightarrow$ proof is correct\n\t\t\\item[$\\textnormal{\\textit{determineLP()}}:$] returns legitimacy period\n            of a certificate \n\t\\end{description}\n\t\n    \\SetKwProg{func}{function}{}{}\n    \\func{isValid(root, proof, chain, CC, name)}{\n    \t\\If{\\textbf{not} preValidate(chain, name)}{\n    \t\t\\Return{FAIL}\\;\n    \t}\n    \t\\If{\\textbf{not} verifyProofs(root, proof, chain, CC)}{\n    \t\t\\Return{FAIL}\\;\n    \t}\n    \t\\For{$C_x \\in \\textit{chain}$ \\textnormal{/*start from root CA*/}}{\n    \t\t$\\textit{LP}[C_x] \\leftarrow \\textit{determineLP}(\\textit{LP}, C_x, t_x, R_{C_x}, ...)$\\;\n    \t\t\\If{$C_x$ \\textbf{is not} a root certificate}{\n    \t\t\t\\If{$t_x \\not\\in \\textit{LP}[C_x.\\textit{parent}]$}{\n    \t\t\t\t\\Return{FAIL}\\;\n    \t\t\t}\n    \t\t}\n    \t\t\\If{$C_x$ \\textbf{is} a leaf certificate \\textnormal{/*last certificate*/}}{\n    \t\t\t\\uIf{$\\textit{currTime}() \\in \\textit{LP}[C_x]$}{\n    \t\t\t\t\\Return{SUCCESS}\\;\n    \t\t\t}\n    \t\t\t\\Else{\n    \t\t\t\t\\Return{FAIL}\\;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\\end{algorithm}\n\n{\\noindent{\\bf{Pre-Validation}.}}\\label{sec:pre_valid}\nThe first step is to pre-validate the certificate chain against a given domain name.\nThis is similar to the standard validation procedure executed by modern browsers.\nIt encompasses checking whether the leaf certificate is issued for the given\ndomain, checking whether the certificate chain is correct and terminates with a trusted\nroot certificate. Usually, such a pre-validation also includes expiration\nchecks, but this functionality is enhanced by {PKISN\\xspace}.\n\n{\\noindent{\\bf{Proof Verification}.}}\\label{sec:proof_verif}\nDuring the next step, the browser verifies the authenticity and correctness of the\nobtained log proofs. First, the match between a proof, a certificate chain, and a\nchain commitment is verified. The browser checks whether the proof contains (in\ncorrect locations) the hashes of all the chain's certificates concatenated with the\ncorresponding timestamps (from the CC). Then, by hashing the elements of the proof,\na root is computed and compared with the signed root provided as input.\nWhen the roots are the same, the verification passes, and the signed\nroot can be kept for further consistency checks and monitoring (\\S\\ref{sec:monitoring}).\n\n{\\noindent{\\bf{Legitimacy-Period Determination}.}}\\label{sec:lp_deter}\nThe next step in the validation procedure is to determine the legitimacy periods of all\ncertificates in the chain. This procedure slightly differs depending on the type of\ncertificate (leaf certificates do not introduce any collateral damage and thus are\nrevoked without specifying a revocation timestamp).\nLegitimacy periods are determined as presented in Fig.~\\ref{fig:period} (for CA\ncertificates) and as in Fig.~\\ref{fig:period_leaf} (for leaf certificates). \n\n\\begin{figure}[b!]\n  \\centering\n  \\includegraphics[width=0.84\\linewidth]{legitimate_period.eps}\n  \\caption{Legitimacy period determination for CA certificates, where $t_x$\n  denotes $C_x$'s registration timestamp.  After the algorithm's execution, the\n  legitimacy period is expressed as a time range (from \\textbf{begin} to\n  \\textbf{end}).} \n  \\label{fig:period}\n\\end{figure}\n\\begin{figure}[b!]\n  \\centering\n  \\includegraphics[width=0.94\\linewidth]{legitimate_period_leaf.eps}\n  \\caption{Legitimacy period determination for leaf certificates, where $t_x$\n  denotes $C_x$'s registration timestamp.  After the algorithm's execution, the\n  legitimacy period is expressed as a time range (from \\textbf{begin} to\n  \\textbf{end}).} \n  \\label{fig:period_leaf}\n\\end{figure}\n\nThe procedure starts with the first (the root) certificate in the chain, and is\nexecuted for every subsequent certificate. First, the legitimacy period is set as\na time range from $t_x$ (the registration timestamp) to $C_x.\\texttt{NotAfter}$ (which\ndenotes the expiration time specified within the certificate). If a revocation\nissued by the software vendor is present, the legitimacy period of the current certificate\nis limited by the time from which the vendor revoked this certificate (i.e., up to the\nrevocation timestamp). If a certificate is\nrevoked with a private key associated with the certificate ($\\textit{rk}_x$ for a CA certificate and $\\textit{sk}_x$ for a leaf certificate), the legitimacy\nperiod is similarly limited by the revocation timestamp from the revocation message. The last option is\na revocation realized by parent CAs. Similarly, the legitimacy period can be\nrestricted, but this revocation message must be issued during the legitimacy\nperiod of the issuer.\n\nThe legitimacy period of a leaf certificate can express two states (revoked or\nnon-revoked), but the processing logic is similar to the previous case.\n\nDuring the complete validation procedure (see Algorithm~\\ref{alg:validation}), it is\nalso ensured that every certificate from the chain (except the root) has a\nregistration timestamp within the legitimacy period of its parent. In the final step of\nthe validation, it is ensured that the leaf certificate is neither revoked nor\nexpired.\n\n{\\noindent{\\bf{Log Consistency}.}}\nAfter validation succeeded, the client saves the signed root for future\nconsistency checks. Then periodically, the client contacts a monitor to compare\nthe obtained root with the monitor's version.  If two roots with the same timestamps\nare different, it means that the log misbehaved, which can be proved and reported\n(e.g., to a software vendor).  To strengthen consistency checking, {PKISN\\xspace} can be\nenhanced by a system such as ARPKI~\\cite{ARPKI}, or by\ngossip protocols as proposed by Chuat et al.~\\cite{gossip}.\n\n\n\\section{Deployment}\n\\label{sec:deployment}\nThe deployability of a system like {PKISN\\xspace} depends on many factors, such as the\nincentives of the different parties to adopt the technology and the number of required\nparties.\nCT introduced two ways of providing proofs that a certificate is logged to clients\nwhile preserving privacy~\\cite{rfc6962,laurie2012certificatve}.\nWe describe these models in the context of\n{PKISN\\xspace} in the following two subsections. We also show that the deployment of {PKISN\\xspace} is\nchallenging with one of the models introduced by CT, and the main reason for this\nis that the ultimate goals of the two systems are different (CT tries to detect\nmisbehaving CAs, while a revocation system tries to avoid using invalid certificates).\nHowever, we present new models including a browser-driven deployment that brings many\nadvantages, and a new lightweight realization of a log monitor. The presented deployment models\ncan also be used in conjunction.\n\n\\subsection{Server-Driven Deployment}\\label{sec:server_deploy}\nIn the first deployment scenario, depicted in\nFig.~\\ref{fig:server-deployment}, servers are driving the process of proving\nto their clients that their certificate is not revoked:\n\n\\begin{enumerate}\n    \\item The server contacts the log at regular intervals (at least every\n        scheduling period) to obtain a fresh signed tree root and a fresh\n        presence proof.\n    \\item The log returns the requested data.\n    \\item Every time a client connects to the server, this data, together with the\n    certificate chain and the CC, is transmitted to the client (e.g., via an OCSP-stapling\n    mechanism). \n    \\item Clients can communicate with monitors to verify that they share a consistent\n    and compatible vision of the log.\n\\end{enumerate}\n\n\\begin{figure}[h!]\n\\centering\n\\includegraphics[width=0.55\\columnwidth]{server-deployment.eps}\n\\caption{Server-driven deployment model. Dotted and dashed lines represent\noptional and periodic communications, respectively.}\n\\label{fig:server-deployment}\n\\end{figure}\n\nThis deployment model is ideal in terms of efficiency (because only the server\nneeds to periodically perform a few extra connections and the storage\nrequirements are low) and privacy (because the client does not need to contact a third party\nto verify the validity of a server certificate).  However, this\nmodel requires that servers are updated and this is not likely to happen\nrapidly for all TLS servers on the Internet.\n\n\n\\subsection{ISP-Driven Deployment}\\label{sec:isp_deploy}\nAs many servers are not updated regularly, the burden of contacting the log\nto retrieve the revocation information could be put on clients, but there is\na privacy issue if clients do so directly. The documentation of CT~\\cite{laurie2012certificatve}\nmentions that clients could use a modified DNS resolver (provided by their\nISPs) as an intermediary to contact the log.\nHowever, this model is problematic when it comes to revocation, since the\ngoal is no longer to simply detect attacks in an unspecified future, but to\ninstantly determine if a certificate can be considered valid.\nMoreover, in a revocation system, such a connection would be required after\nthe certificate chain is received and before it is accepted (otherwise the client\ndoes not know for which certificate chain a validity message should be\nreturned), which would increase latency and be prone to blocking attacks. For\nthese reasons, it would be challenging to adapt this model in {PKISN\\xspace}.\n\n\n\\subsection{Browser-Driven Deployment}\\label{sec:browser_deploy}\nSince the ISP-driven deployment does not fit the requirements of {PKISN\\xspace},\nand since we cannot assume that all servers would quickly be configured to provide \nfresh proofs to TLS connections (server-driven model), we\nseek an alternative solution. We present a variant of browser-driven\ndeployment with the goal of providing users with the minimal\ninformation required to ensure that no certificate (from the chain) is revoked.\nTo achieve this goal, we propose to extend a browser update mechanism\n(mentioned in \\S\\ref{sec:pre:related}) that is already deployed,\nnamely CRLSets.\n\nAs in a browser-driven deployment clients are periodically provided with\nrevocation messages, it is crucial to minimize bandwidth and\nstorage overheads. In our deployment model, vendors employ the log as a source of\nnew revocations, and they push CRLSets that consist of identifiers (in our case\nhashes) of all revoked and non-expired certificates with their corresponding\nlegitimacy periods (for CA certificates). Additionally, vendors are obliged to\nlog every CRLSet before it is propagated to the browsers, and are obliged to\npropagate the CRLSet with a commitment (or presence proof) from the log,\nindicating that the CRLSet is accepted by the log and will be visible in the near\nfuture. We call this concept a \\textit{Transparent CRL} (TCRL). On the log-side,\nthe TCRL is simply appended to the TimeTree. \nThis deployment model does not provide properties as strong as the server-driven\ndeployment, but it allows to verify certificate validity and it enables the\naudit of TCRLs.\n\n\\begin{figure}[h!]\n\\centering\n\\includegraphics[width=0.65\\columnwidth]{vendor-deployment.eps}\n\\caption{Browser-driven deployment model. Dotted and dashed lines represent\noptional and periodic communications, respectively.}\n\\label{fig:vendor-deployment}\n\\end{figure}\n\nThe connection establishment and certificate validation of this deployment model\nare presented in Fig.~\\ref{fig:vendor-deployment} and proceed as follows:\n\\begin{enumerate}\n    \\item Periodically, the browser vendor contacts a log to obtain the new\n    revocations (note that a vendor can also act here as a monitor).\n    \\item The vendor prepares a software update creating a list of new\n    revocations (TCRL). Then this TCRL is submitted to the log, which returns a commitment\n    indicating that the TCRL will be appended to the TimeTree. Finally, with this commitment\n    (or a presence proof), the vendor pushes the TCRL to the browsers.\n    Browsers verify whether log proofs matched the TCRL and accept the update.\n    \\item During the TLS handshake, the client obtains a certificate chain along\n    with the corresponding CC.\\footnote{If a server deploys {PKISN\\xspace}, then a proof\n    is sent during the\n    handshake, and the client validates the certificate chain as in\n    \\S\\ref{sec:server_deploy}.}\n    Then, with a locally-stored TCRL,\n    the browser verifies whether all certificates from the chain have not been\n    revoked. (As TCRLs provide complete revocation messages, clients\n    can determine the legitimacy periods.) The browser continues with a verification\n    similar to Algorithm~\\ref{alg:validation}. \n    \n    \\item The browser can (optionally) contact a monitor, to\n    verify that the local version of the TCRL (vendor's view) is consistent with\n    the monitor's view. Note that this communication does not reveal any\n    information on the domains that the browser has contacted.\n\\end{enumerate}\n\n\n\\subsection{Lightweight Monitoring}\\label{sec:light_monitor}\nMonitors are an integral part of many log-based schemes. They have the responsibility to\nconstantly monitor the logs to verify whether they behave correctly.\nIn previous proposals~\\cite{AKI,ARPKI,laurie2012certificatve} monitors were\nimplemented as replicas of the logs that perform some extra checks on demand\n(e.g., confirm that their view of the log is consistent with the root provided\nby the client). Because of that design, the bandwidth and storage required to\noperate a monitor are significant. In this section, we propose a novel\ndeployment model that allows to run a lightweight monitoring service.\nThis model could be used by network devices with security features or by power-users, for example.\nSuch a service can assist the clients in additional verification of a connection, and\nthe required features are:\n\\begin{itemize}\n\t\\item confirm the root of the log,\n\t\\item prove that the log is consistent (i.e., a version of the log is the extension of a previous one),\n\t\\item prove that a given object is in the log.\n\\end{itemize}\n\nOur first observation is that the large storage requirement of the log is\ninduced by the necessity of storing entire certificates (a single certificate\ntakes about 2 kB in PEM format). However, as {PKISN\\xspace} clients are provided with\ncertificate chains and the corresponding information during TLS\nconnections, monitors need not store actual certificates but only the corresponding hashes.\nThis is sufficient to ensure that a certificate is indeed in the log and that the log is consistent.\nIn our proposal, a lightweight monitor is not directly equipped with the TimeTree's\nleaves, but with their parent nodes (i.e., hashes) and with revocation messages.\nAnother observation is that certificates have a standardized maximum lifetime.\nTherefore, after some time, the TimeTree will contain a continuous list of expired\ncertificates and there is no need to store the hashes of these certificates, unless\nthey are parts of non-expired chains.\n\n\\begin{figure}[h!]\n\\centering\n  \\begin{tikzpicture}[scale=.49,every tree node/.style={text width=0.8cm,font=\\LARGE,anchor=base}]\n    \\Tree \n    [.\\textit{root}\n        [.$H_{abcdefr_0r_1}$\n            [.\\fbox{$H_\\mathit{abcd}$}\n        [.${H_{ab}}$\n        [.$H_a$ $C_{a}$,\\\\$t_0$ ] [.$H_b$ $C_{b}$,\\\\$t_0$  ] ]\n        [.${H_{cd}}$\n        [.$H_c$ $C_{c}$,\\\\$t_0$ ] [.$H_d$ $C_d$,\\\\$t_0$ ] ] \n    ]\n    [.${H_\\mathit{efr_0r_1}}$\n        [.\\fbox{${H_{ef}}$}\n        [.$H_{e}$ $C_e$,\\\\$t_0$ ] [.$H_f$ $C_f$,\\\\$t_0$  ] ]\n        [.${H_\\mathit{r_0r_1}}$\n        [.\\fbox{$H_{r_0}$} $r_0$,\\\\$t_0$ ] [.\\fbox{$H_{r_1}$} $r_1$,\\\\$t_1$ ] ] \n    ]\n ]\n  [.$H_\\mathit{hijf'klmr_2}$\n    [.$H_{hijf'}$\n        [.${H_{hi}}$\n        [.\\fbox{${H_h}$} $C_h$,\\\\$t_2$ ] [.\\fbox{$H_i$} $C_i$,\\\\$t_2$  ] ]\n        [.${H_{jf'}}$\n        [.\\fbox{$H_j$} $C_j$,\\\\$t_2$ ] [.$H_{f'}$ \\fbox{$R_{C_f}$}\\\\$t_2$ ] ] \n    ]\n    [.${H_\\mathit{klmr_2}}$\n        [.$H_{kl}$\n        [.\\fbox{${H_k}$} $C_k$,\\\\$t_2$ ] [.\\fbox{$H_l$} $C_l$,\\\\$t_2$  ] ]\n        [.${H_{mr_2}}$\n        [.\\fbox{$H_m$} $C_m$,\\\\$t_2$ ] [.\\fbox{$H_{r_2}$} $r_2$,\\\\$t_2$ ] ] \n    ]\n  ]\n ]\n\\end{tikzpicture}\n\\caption{An example of a TimeTree, where all certificates before $t_1$ are\nexpired. Only nodes in boxes are stored by the lightweight monitor.}\n\\label{fig:browser_tree}\n\\end{figure}\n\nAn example of our optimization is depicted in Fig.~\\ref{fig:browser_tree}.\nIt shows the original TimeTree and the values that a monitor must provide.\nIn this case, a monitor must initially obtain from the log only the following:\n\n", "itemtype": "equation", "pos": 47646, "prevtext": "\nThe signed root can also be requested separately. In our setting, the combination\nof a presence proof and the signed root is the most important piece of information\nfrom a client's perspective; it contains almost everything to perform a certificate\nvalidation. However, in {PKISN\\xspace}, a log is also obligated to provide extension proofs\nbetween two versions of the TimeTree (to prove the consistency of two snapshots of\nthe log).\n\n{\\noindent{\\bf{Certificate Revocation}.}}\nAn entity allowed to revoke a certificate ${C_x}$ can create a revocation message\nfrom Eq.~(\\ref{eq:rev1}) or Eq.~(\\ref{eq:rev2}). The revocation message\n$R_{C_x}$ is sent along with a certificate chain whose last certificate is\nintended to be revoked. The log, after verifying whether the revocation is legitimate\nand matches the certificate, schedules the revocation and returns a message:\n\n", "index": 17, "text": "\\begin{equation}\\label{eq:rev_commit}\n    \\textit{Sig}_{{k}_{\\textit{log}}}(H(R_{C_x}), t_x),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\textit{Sig}_{{k}_{\\textit{log}}}(H(R_{C_{x}}),t_{x}),\" display=\"block\"><mrow><mrow><msub><mtext>\ud835\udc46\ud835\udc56\ud835\udc54</mtext><msub><mi>k</mi><mtext>\ud835\udc59\ud835\udc5c\ud835\udc54</mtext></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><msub><mi>C</mi><mi>x</mi></msub></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03874.tex", "nexttext": "\nThen, periodically, a \\textit{delta update} between the current TimeTree\nand the monitor's local list is transferred. Every update is also accompanied with the\ncorresponding signed root (Eq.~(\\ref{eq:root})). Such a design allows a monitor to\nstore a \\textit{minimized} version of TimeTree and to:\n\\begin{itemize}\n    \\item check if every non-expired certificate of the chain is indeed present in the tree (e.g., on a client's query),\n    \\item check the revocations of certificates and determine legitimacy periods (e.g., on a client's query),\n    \\item build the TimeTree's root, and optionally compare it with other monitors to\nverify that the view is consistent, \n    \\item extend the tree with new hashes,\n    \\item verify the proofs received from the clients.\n\\end{itemize}\n\nIn this setting, a monitor is able to verify \nmillions of certificates and needs to store only tens of megabytes, instead of\nseveral gigabytes for a complete TimeTree. A detailed analysis of the required\nresources\nis presented in \\S\\ref{sec:eval:storage}. \nMoreover, such an optimization can be easily applied to other \nlog-based approaches that employ hash trees.\n\n\n\\section{Security Analysis}\n\\label{sec:analysis}\nOur first claim is that {PKISN\\xspace} provides authenticity, i.e., \\textit{a non-capturing\nadversary cannot create any legitimate revocation message}, as long as he cannot\nforge a digital signature. An adversary with the private key of the\ndomain can revoke only the domain's certificate. However, by this action, an\nattacker would reveal that the key is compromised, as the revocation must be\nlogged.\n\nA more powerful adversary, able to capture a CA's private key, can revoke that\nCA's certificate, and all its child certificates. We claim that {PKISN\\xspace} provides\nbackward availability and timeliness, i.e., \\emph{such an\nadversary can misbehave only for a short time period} (e.g., by temporarily\nintroducing collateral damage or malicious certificates).  Specifically, that\ntime period is less than or equal to $T_d+T_a+T_s+T_p$, where $T_d$ is a\ndetection time, i.e., the duration between the moment when a misbehavior\n(illegitimate revocation or certificate issuance) is logged and the moment when\nthe CA notices that misbehavior. $T_a$ denotes the audit delay, i.e., the time\nduring which the CA determines when the first misbehavior was logged, $T_s$ is\nthe scheduling period of the log (see \\S\\ref{sec:overview}).  For existing CT\nlogs a scheduling period (called in CT MMD) is set between 1-24 hours.  $T_p$\nstands for the propagation time, i.e., the time it takes for a new change to be\npropagated to clients. This time depends on a deployment model, however in all\npresented models (see \\S\\ref{sec:deployment}) we may expect this time to be\nbounded by a few hours.  Overall, we estimate that it is feasible to conduct the\nentire process within several hours.\n\nLet's consider the extreme case in which such an adversary compromises the root\nCA's private key and revokes all child certificates with a revocation timestamp\nclose to the creation time of the CA. This would invalidate all the actions of\nthis CA. With {PKISN\\xspace}, these revocation messages must be submitted to the log. The\nlog accepts them if they are signed with an authentic key.  These revocation\nmessages will be visible, at the latest, when the log is updated. After the\nupdate, the malicious revocations are noticed by the CA, which, after an audit\nprocedure, can estimate when the breach happened, and can revoke its own\ncertificate with a revocation timestamp set to the breach time, using the\noffline revocation key. Thereafter, in the next update of the log, all malicious\nrevocations will be invalidated, and this change will eventually be propagated\namong clients (see \\S\\ref{sec:deployment}).  In general $T_a > T_d$, but when a\nCA is revoked, or many revocations are submitted with a single key, the log\ncould inform the CA about these actions before the update. Such an information\nwould give a CA some time to take actions in order to completely eliminate the\ncollateral damage.  \n\nAs explained above, {PKISN\\xspace} enables to remove collateral damage from the TLS PKI,\nbut with the assumption that the log is not malicious. We stress that the log\nitself is only trusted to a certain extent, as it is constantly monitored and is\nonly supposed to: 1) be append-only, 2) accept object registrations, 3) return\ncryptographic evidence about the content/consistency of the trees. Hence, the\nlog cannot revoke certificates by itself, as it requires a private key to sign\nappropriate revocation messages. However, a misbehaving log can block requests\n(by simply ignoring them), which is a more generic problem of all log-based\nschemes.\n\nThe combination of a capturing adversary and a malicious log is especially\ndangerous.  Consider the case (similar to the previous one) in which an\nimportant CA is compromised and malicious revocation messages for child\ncertificates are issued and logged. Then, when the CA wants to revoke its own\ncertificate, the malicious log can just ignore the requests. As a consequence,\nthe malicious revocations will not be invalidated.  This attack is simple and\nsevere, but to succeed, an adversary must compromise the CA and the log at the\nsame time.\n\n{PKISN\\xspace} requires that all actions are signed and logged, \\textit{making the parties\naccountable}.  Revocations as well as certificates are \\textit{transparent and\nvisible}, which makes \\textit{split-world\nattacks}~\\cite{Mazieres:2002:BSF:571825.571840} detectable. Consider the case\nwhere an adversary controls the log and captures a server's old revoked key.\nNow, the adversary can produce a single fake presence proof, which states that a\ngiven certificate is not revoked for example, and can launch a man-in-the-middle\nattack on clients. Then, with such a proof, the adversary must provide the\ncorresponding signed root to the attacked client. The attack can succeed, as the\nclient trusts the log, but the attack is detectable if the client contacts a\nmonitor (or any other party) which has a different (legitimate) view of the log.\nSuch an attack is more difficult to conduct with the deployment scenario\nsketched in \\S\\ref{sec:browser_deploy}, as revocations are stored in the\nbrowsers.\n\n{PKISN\\xspace} \\textit{preserves user privacy}. In all the presented deployment models\n(\\S\\ref{sec:deployment}), clients receive complete revocation status either through\nbrowser update or directly from the contacted server.  Clients do not contact\nany third parties to ensure that a given certificate is valid.  Clients obtain\nsigned roots and extension proofs from the monitors, but this action also does\nnot reveal any information about websites visited.\n\n\n\\section{Realization in Practice}\n\\label{sec:implementation}\n\\subsection{Implementation}\nIn order to prove the feasibility of {PKISN\\xspace}, we implemented the system in\nPython~(2.7.6) and C++~(gcc-4.8.2), using the M2Crypto, libpki, and OpenSSL (1.0.1f)\ncryptographic libraries. We modified libpki to add a\ndedicated revocation key into the extension field of every CA X509v3\ncertificate~\\cite{citeulike:6983793}. To minimize overheads we decided to use\nthe Ed25519 signature scheme, except for the standard keys of X509v3 certificates\nwhere RSA-4096 was used instead. We used the SHA-256 hash function for\nboth certificates and the implementation of hash trees.\n\nWe wrote a complete log and TLS client that implements the validation logic from\n\\S\\ref{sec:validation}. For the server side, we used Nginx, which\nperiodically requests a fresh presence proof and signed root from the log.\nFor every subsequent TLS Handshake, the server sends these values\n(and the chain commitment) using \\texttt{TLS Certificate Status\nRequest}~\\cite{santesson2013x}, while the server's certificate is sent within a\nstandard \\texttt{ServerHello} message. Such a configuration enables deployment of\n{PKISN\\xspace} without any changes to the TLS protocol. This setting is specific to the\ndeployment scenario presented in \\S\\ref{sec:server_deploy}.\n\n\\subsection{Performance}\\label{sec:impl:perf}\nWith the setting presented above, we measured the efficiency of our\nsystem by conducting a series of experiments. Every presence proof in our test\ncontained two revocation messages (pessimistic setting) and every certificate\nchain contained three certificates. All results were obtained by\nexecuting a given operation one thousand times on one Intel i5-3380M core @\n2.90 GHz, on Ubuntu 14.04 with 16 GB of RAM. During one second,\nthe log was able to register 1907 certificate chains on average. For these\nregistrations, the log verified the chains and returned signed chain commitments. To add\n10000 new certificate chains to the trees, and to update the trees, the log\nneeded on average 3.154 seconds. Our client's implementation conducted a complete\nvalidation within 1.266 ms on average, where the pre-validation and proofs validations\ntake 0.405 ms and 0.370 ms, respectively. This computational overhead\nshould be unnoticed by users~\\cite{journals/computer/ToliaAS06}.\n\n\n\n\\section{Evaluation}\n\\label{sec:eval}\nWe evaluate {PKISN\\xspace} in terms of storage and bandwidth overheads and focus on the\nserver-driven deployment model, the browser-driven model, and the lightweight-monitor\nproposal. For the server-driven deployment, the information required to\nverify a certificate chain is obtained directly from the TLS Handshake. For the\nlightweight monitor deployment, the monitor is provided with a delta update, as\nin Eq.~(\\ref{eq:update}), which allows the browser to reconstruct minimized\ntrees. In the browser-driven deployment~(TCRL), the browser receives\na delta update from the vendor as hashes of revoked certificates. Note that\nthese two variants provide different properties (see\n\\S\\ref{sec:browser_deploy}). In our simulations, we assume that the\nEd25519~\\cite{bernstein2012high} scheme is used as the signature scheme and that\nthe hash function produces an output of 20 bytes (this is a parameter, and\nsecond pre-image resistance is the main property we rely on).\n\n\\subsection{Storage}\\label{sec:eval:storage}\nThe Server-driven deployment does not require any storage on the client-side, and only\na small amount of storage on the server-side: a signed root (88 bytes), a chain commitment (96 bytes\nfor a chain of three certificates), and a presence proof (each node takes 20 bytes).\nIn the standard case, this overhead should be around 1~kB.\n\nTo estimate the storage overhead required for the presented deployment\nvariants, we used data available from one of CT's public\nlogs.\\footnote{ \\url{http://ct.googleapis.com/pilot}}  First, we\nconservatively qualified certificates as valid considering their\n\\texttt{NotBefore} and \\texttt{NotAfter} validity fields, and found that out of\nthe 7,427,474 certificates in the log, 3,938,656 were valid on 15 May 2015,\n12:00:00 UTC (note that certificate chains can be added to the log only if the\nroot certificate is contained in a set of acceptable roots that the log\nmaintains). Then, we simulated storage overheads for the two deployment\nvariants, depending on the number of certificates and the fraction of revoked\ncertificates (this fraction in HTTPS was recently reported as 8\\%~\\cite{liu-2015-revocation}).\n\n\\begin{figure}[t!]\n  \\centering\n  \\includegraphics[width=\\linewidth]{storage.eps}\n  \\caption{Storage overhead required by TCRL-enabled browser (top chart),\n  and by a monitor with the minimized-trees variant (bottom chart).}\n  \\label{fig:storage}\n\\end{figure}\n\nAs shown in Fig.~\\ref{fig:storage}, the results differ significantly depending\non the deployment variant.  With today's number of valid certificates and a 10\\% revocation rate\n(which is considered as high), a browser employing the TCRL mechanism needs 8 MB of storage,\nwhile, for the same scenario, a lightweight monitor needs 115 MB,\nwhereas the log in such a setting stores about 8 GB.\n\n\n\\subsection{Bandwidth}\\label{sec:eval:bw}\nWe also evaluated {PKISN\\xspace} in terms of bandwidth required, using real-world traces.\nZhang et al.~\\cite{Zhang:2014:ASC:2663716.2663758}, using data gathered by\nRapid7,\\footnote{ \\url{https://scans.io/study/sonar.ssl}} collected\ninformation about certificates and the corresponding revocations. The certificates\nwere filtered to consider only valid ones from the Alexa Top 1 Million global\nsites.\\footnote{ \\url{http://s3.amazonaws.com/alexa-static/top-1m.csv.zip}}\nFor these 628,692 certificates, the 1,386 corresponding CRLs were downloaded and processed.\n\nThe dataset we\nused\\footnote{ \\url{https://ssl-research.ccs.neu.edu/dataset.html}} covers a\nperiod from 30 October 2013 to 28 April 2014. This period is especially\ninteresting from our point of view as \\textit{Heartbleed}---a critical\nvulnerability in an OpenSSL extension---was publicly announced in April 2014.\nHeartbleed allowed attackers to remotely read a server's protected memory\nincluding sensitive information like private keys.\nAs a consequence, in mid-April 2014 we observed the highest\nfrequency of certificate re-issuance and revocation ever. This unique event and\nits impact on the TLS ecosystem has been thoroughly\nanalyzed~\\cite{Zhang:2014:ASC:2663716.2663758,durumeric2014matter}.\n\nWe evaluated the bandwidth required by {PKISN\\xspace} during normal operations (i.e., a\nfew months before Heartbleed) and during what we will refer to as the\n\\textit{peak time} (i.e., right after Heartbleed was announced). For this test, we\nused the above-mentioned dataset to extract all new certificate issuances and\nrevocations observed over the time period. We assumed that certificate chains\nconsist of three certificates, as this is, reportedly, the length of the vast majority\n(about 98\\%) of certificate chains~\\cite{Holz:2011:SLT:2068816.2068856,Durumeric:2013:AHC:2504730.2504755}.\nBy fetching all entries from one of CT's public logs (as in \\S\\ref{sec:eval:storage}),\nwe determined that the average size of a single certificate is about 1966 bytes.\nThe setting of cryptographic primitives used here is the same as in the\nprevious test.\n\nFirst, we estimated the total bandwidth required by the log to register all\nissued certificates and revocations.\n\\begin{figure}[t!]\n  \\centering\n  \\includegraphics[width=\\linewidth]{bw.eps}\n  \\caption{Bandwidth required by the log to receive certificate registrations\n  and revocations (top chart), and by the browser to receive daily updates\n  (bottom chart, note that the y-axis is in logarithmic scale).}\n  \\label{fig:bw}\n\\end{figure}\nThe results are presented in Fig.~\\ref{fig:bw}. During the normal period\n(between November 2013 and March 2014), the log receives 5--13 MB per day. At\npeak time, the number of certificate issuances and revocations increases,\ncausing higher demands on bandwidth. However, even then, the maximum bandwidth\nrequired is less than 35 MB per day.\n\nSecond, we estimated the bandwidth required for the daily update of a browser (TCRL) and a lightweight monitor (minimized trees). Fig.~\\ref{fig:bw}\ndepicts the results for these two variants.\n\n\nIn a standard scenario, the daily update for the minimized trees variant is\n15--40 kB, but with the increasing number of revocations caused by\nHeartbleed, the required bandwidth increases as well. On 17 April 2014, it reaches\naround 1.4 MB, which is the highest number observed. After this date, the\nbandwidth required decreases rapidly. In a similar manner, for the deployment variant\nusing TCRL, the normal update is below 1 kB, while the update during the peak\nreaches 300 kB at most.\nWe believe that such overhead is acceptable, but we expect that with a higher\nrevocation rate (which may occur in practice) browser vendors would reduce the\ntransfer cost through a more efficient encoding of TCRLs or by limiting the scope of TCRLs\n(e.g., to EV certificates only---see CRLSets in \\S\\ref{sec:pre:related}).\n\nIn the server-driven deployment, for every TLS connection, a client is provided\nwith about 1 kB (see \\S\\ref{sec:eval:storage}) of additional data. \n\n\n\n\\subsection{Comparison}\nWe now summarize the above results and compare the different deployment models\nof {PKISN\\xspace} with competing revocation schemes.  The comparison encompasses storage\nand bandwidth overhead on the client-side, as well as the potential latency\nintroduced by the revocation scheme to the TLS connection.\n\\begin{table}[b!]\n\\footnotesize\n\\centering\n\\caption{Comparison of revocation schemes.}\n\\label{tab:compar}\n\\begin{tabular}{@{~}lrrl@{~}}\n\\toprule\n\\textbf{Scheme} &\\textbf{Storage} & \\textbf{Bandwidth} & \\textbf{Latency} \\\\\n\\cmidrule{1-4}\nCRL         & 34 MB& 24 kB/conn.& increased \\\\\nOCSP         & None & 0.5 kB/conn.& increased \\\\\nOCSP Stapling& None & 0.5 kB/conn. & unaltered \\\\\nCRLSet       & 0.2 MB & 0.12 kB/day   & unaltered \\\\\nECT/DTKI  & None & 1 kB/conn.  & increased\\\\\nAKI/ARPKI  & None & 0.5 kB/conn.  & unaltered \\\\\n{PKISN\\xspace} (srv-driven, \\S\\ref{sec:server_deploy})/PoliCert & None & 1 kB/conn.  & unaltered \\\\\n{PKISN\\xspace} (browser-driven, \\S\\ref{sec:browser_deploy}) & 6.4 MB & 0.7 kB/day & unaltered \\\\\n{PKISN\\xspace} (light. monitor, \\S\\ref{sec:light_monitor}) & 108 MB & 39 kB/day & unaltered \\\\\n\\bottomrule\n\\end{tabular}\n\\end{table}\nThe results are presented in Table~\\ref{tab:compar}.  Depending on the scheme,\nthe revocation information can be passed through an update (e.g., daily) or\nduring every TLS Handshake (per connection), which is described in the Bandwidth\ncolumn.  For {PKISN\\xspace} and other log-based approaches we show the storage\nrequired for a revocation rate of 8\\% and four million active certificates (see\n\\S\\ref{sec:eval:storage}). The bandwidth required by {PKISN\\xspace} is given\nas the median value observed in \\S\\ref{sec:eval:bw}, while for CRLSets we used the\ndataset provided by Liu et al., and for CRLs we used a dataset provided by\nISC~\\cite{isc_crl}.\n\nBesides efficiency, the schemes compared here differ significantly in the properties\nthey offer (see \\S\\ref{sec:pre:related} and \\S\\ref{sec:deployment}).\n\n\\subsection{Case Study}\n\nGoDaddy is currently one of the largest issuers\nof TLS certificates~\\cite{Arnbak:2014:SCH:2668152.2673311}.\nWe take the ``Go Daddy Secure Certification Authority'' certificate\n(serial number \\texttt{07969287}) as an example in a case study on how effective {PKISN\\xspace} could\nbe in practice. By analyzing the content of Google's pilot CT log, we found\n139,086 valid certificates (on 19 November 2015) signed by the aforementioned intermediate CA.\nThe oldest of these certificates (as indicated by the \\texttt{NotBefore} field)\nwas issued on 29 January 2007, which means that a single private key was used to\nsign about 43.25 certificates per day on average, during more than 8 years.\nIf that key was compromised and the corresponding certificate revoked with current\nmethods, thousands of websites would be affected. With {PKISN\\xspace}, only a small number of\ncertificates would be revoked (provided that the detection process is reasonably\nfast). For instance, if a misbehavior was detected after one week, only about 300\ncertificates would have to be revoked and re-issued, which constitutes only about\n0.2\\% of all certificates issued with this key.\n\n\n\\section{Discussion}\n\\label{sec:discussion}\nThe effectiveness and security of our system depend on the length of update periods,\nwhich introduces an obvious trade-off between the log's performance and the size\nof the attack window. We believe that a delay of a few hours between\nlog updates is a good compromise.\n\nOne remaining challenge, and a potential subject for future work, is the multi-log\nscenario, which is challenging as synchronization between\nthe logs would be necessary. \nOne interesting approach to make the multi-log scenario scalable, is to introduce\ndomain-driven security policies~\\cite{PoliCert} that would allow domains to specify\nwhich logs they trust. Then, all certificate registrations and revocations could\nbe submitted only to these logs. Another interesting aspect that could be investigated\nrelates to the question of how {PKISN\\xspace} can be extended to other trust models, log systems,\nand their applications~\\cite{melara2014,Fahl:2014:HNS:2660267.2660311}. In particular,\n{PKISN\\xspace} could be combined with ARPKI~\\cite{ARPKI}, for example, to provide additional\nsecurity properties (such as ``connection integrity'').\nWe also plan to conduct a formal analysis of {PKISN\\xspace}.\n\nAn open problem, that all new log-based approaches face, is to find an optimal\ndeployment model and an incremental deployment plan. {PKISN\\xspace} can benefit from the\nprevious works~\\cite{matsumoto2015deployment,Bates:2014:SSC:2660267.2660338}, but we plan to\ninvestigate and analyze the proposed deployment models in depth.\nAn advantage of {PKISN\\xspace} is that it can be easily built on the top of CT, which\ncurrently is being deployed.\n\nWe believe that the revocation policy employed by {PKISN\\xspace} fits the current TLS ecosystem\nand reflects the power of PKI actors and the connections between them.\nHowever, we envision that this policy could be optimized and standardized by\norganizations and consortia such as the CAB Forum~\\cite{cabf}.\n\n\n\n\\section{Conclusion}\n\\label{sec:conclusions}\nThe current certificate revocation systems suffer from many drawbacks such as large\nattack windows, privacy issues, and configuration dependencies. \nIn this paper, we redesigned the current TLS revocation system and presented {PKISN\\xspace},\nwhich resolves several problems that we identified.\nThe most important advantage of {PKISN\\xspace} is that it is the first system (to the best of our knowledge)\nto solve the too-big-to-be-revoked problem of the current PKI.\nIt also enhances transparency and introduces a novel revocation policy that\nreflects the actual interactions within the TLS ecosystem.\nOnly a few changes are required to deploy {PKISN\\xspace} with the current infrastructure.\nMoreover, the evaluation and performance results of our implementation indicate that {PKISN\\xspace}\nis viable for use in practice.\n\n\n\n\\section*{Acknowledgments}\nWe thank our shepherd Bart Preneel, the anonymous reviewers, and Franz Saller for their\nvaluable feedback.\nWe gratefully acknowledge support from ETH Zurich and from the Zurich\nInformation Security and Privacy Center (ZISC).\n\n\\bibliographystyle{abbrv}\n\\bibliography{references}\n\n\n", "itemtype": "equation", "pos": 67669, "prevtext": "\nwhich states that the revocation will be appended to the log after time $t_x$.\nHowever, during the scheduling period (when the revocation is not yet\nappended) the log can attach a revocation message to every relevant presence\nproof. This would reduce the attack window. During the update of the log,\nthe revocation message is appended to the TimeTree and is appended to the \nRevTree's leaf which corresponds to the revoked certificate. From that time\nforward, every presence proof requested for a chain that contains the revoked\ncertificate must contain the revocation message.\n\n{\\noindent{\\bf{Monitoring}.}}\\label{sec:monitoring}\nThe role of a \\emph{monitor} is to verify the correct behavior of a log. Each monitor\nperiodically (after every log update) contacts the log and downloads the newly\nappended objects and the current signed root. Then, the monitor updates its own\ncopy of the log, by appending new certificates and revocations to the TimeTree,\nand by introducing all changes to the RevTree. After that, the monitor puts the current\nroot of its RevTree as the last leaf into the TimeTree. Finally, the monitor computes\nthe root of its own copy of the TimeTree and compares it with the root received from\nthe log. During this update, the monitor also verifies whether the certificates\nand revocations accepted by the log were legitimate. \n\nThrough this periodic update, the monitors can detect any inconsistency/misbehavior\nof the log. Anyone can request signed roots from a monitor, and report a proof of\nmisbehavior such as:\n\\begin{itemize}\n    \\item an incorrect CC (with incorrect registration timestamps or absence proof of a\n        certificate that was not appended), \n    \\item a revocation that is not appended (showing a message from\n        Eq.~(\\ref{eq:rev_commit}), and a proof that the revocation is not in the\n        log),\n    \\item two different roots from the same time period,\n    \\item the presence proof of an invalid certificate or revocation. \n\\end{itemize}\n\nThe monitor, in such a setting, must replicate the log's content. In\n\\S\\ref{sec:light_monitor}, we propose a novel deployment model that allows to\nimplement a monitor in a lightweight manner. \n\n\\subsection{Validation}\\label{sec:validation}\nTo conduct a certificate validation, a client needs:\n\\begin{inparaenum}[\\itshape a\\upshape)]\n    \\item a certificate chain, \n    \\item a chain commitment, \n    \\item a proof of presence, \n    \\item and the corresponding signed root. \n\\end{inparaenum}\nThe full validation is presented in Algorithm~\\ref{alg:validation}. This section\npresents the different steps. We assume that before validation, the structure and format of\nall messages is checked.\n\\begin{algorithm}[h!]\n\t\\caption{Complete certificate validation.}\n\t\\label{alg:validation}\n\t\\small\n\t\n\t\\begin{description}\n        \\item[$\\textnormal{\\textit{root}}:$] signed root (TimeTree), e.g.,\n            Eq.~(\\ref{eq:root})\n\t\t\\item[$\\textnormal{\\textit{proof}}:$] presence proof, e.g.,\n            Eq.~(\\ref{eq:proof})\n\t\t\\item[$\\textnormal{\\textit{chain}}:$] certificate chain, e.g.,\n            Eq.~(\\ref{eq:chain})\n\t\t\\item[$\\textnormal{\\textit{CC}}:$] signed chain commitment, e.g.,\n            Eq.~(\\ref{eq:CC})\n\t\t\\item[$\\textnormal{\\textit{name}}:$] name of the contacted domain\n\t\t\\item[$t_x:$] registration timestamp of $C_x$\n\t\t\\item[$\\textnormal{\\textit{LP}}:$] dictionary that maps certificates to\n            their legitimacy periods\n\t\t\\item[$\\textnormal{\\textit{currTime()}}:$] returns current time in Unix seconds\n\t\t\\item[$\\textnormal{\\textit{preValidate()}}:$] returns \\textit{true} $\\Leftrightarrow$ pre-validation passes\n\t\t\\item[$\\textnormal{\\textit{verifyProofs()}}:$] returns \\textit{true} $\\Leftrightarrow$ proof is correct\n\t\t\\item[$\\textnormal{\\textit{determineLP()}}:$] returns legitimacy period\n            of a certificate \n\t\\end{description}\n\t\n    \\SetKwProg{func}{function}{}{}\n    \\func{isValid(root, proof, chain, CC, name)}{\n    \t\\If{\\textbf{not} preValidate(chain, name)}{\n    \t\t\\Return{FAIL}\\;\n    \t}\n    \t\\If{\\textbf{not} verifyProofs(root, proof, chain, CC)}{\n    \t\t\\Return{FAIL}\\;\n    \t}\n    \t\\For{$C_x \\in \\textit{chain}$ \\textnormal{/*start from root CA*/}}{\n    \t\t$\\textit{LP}[C_x] \\leftarrow \\textit{determineLP}(\\textit{LP}, C_x, t_x, R_{C_x}, ...)$\\;\n    \t\t\\If{$C_x$ \\textbf{is not} a root certificate}{\n    \t\t\t\\If{$t_x \\not\\in \\textit{LP}[C_x.\\textit{parent}]$}{\n    \t\t\t\t\\Return{FAIL}\\;\n    \t\t\t}\n    \t\t}\n    \t\t\\If{$C_x$ \\textbf{is} a leaf certificate \\textnormal{/*last certificate*/}}{\n    \t\t\t\\uIf{$\\textit{currTime}() \\in \\textit{LP}[C_x]$}{\n    \t\t\t\t\\Return{SUCCESS}\\;\n    \t\t\t}\n    \t\t\t\\Else{\n    \t\t\t\t\\Return{FAIL}\\;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\\end{algorithm}\n\n{\\noindent{\\bf{Pre-Validation}.}}\\label{sec:pre_valid}\nThe first step is to pre-validate the certificate chain against a given domain name.\nThis is similar to the standard validation procedure executed by modern browsers.\nIt encompasses checking whether the leaf certificate is issued for the given\ndomain, checking whether the certificate chain is correct and terminates with a trusted\nroot certificate. Usually, such a pre-validation also includes expiration\nchecks, but this functionality is enhanced by {PKISN\\xspace}.\n\n{\\noindent{\\bf{Proof Verification}.}}\\label{sec:proof_verif}\nDuring the next step, the browser verifies the authenticity and correctness of the\nobtained log proofs. First, the match between a proof, a certificate chain, and a\nchain commitment is verified. The browser checks whether the proof contains (in\ncorrect locations) the hashes of all the chain's certificates concatenated with the\ncorresponding timestamps (from the CC). Then, by hashing the elements of the proof,\na root is computed and compared with the signed root provided as input.\nWhen the roots are the same, the verification passes, and the signed\nroot can be kept for further consistency checks and monitoring (\\S\\ref{sec:monitoring}).\n\n{\\noindent{\\bf{Legitimacy-Period Determination}.}}\\label{sec:lp_deter}\nThe next step in the validation procedure is to determine the legitimacy periods of all\ncertificates in the chain. This procedure slightly differs depending on the type of\ncertificate (leaf certificates do not introduce any collateral damage and thus are\nrevoked without specifying a revocation timestamp).\nLegitimacy periods are determined as presented in Fig.~\\ref{fig:period} (for CA\ncertificates) and as in Fig.~\\ref{fig:period_leaf} (for leaf certificates). \n\n\\begin{figure}[b!]\n  \\centering\n  \\includegraphics[width=0.84\\linewidth]{legitimate_period.eps}\n  \\caption{Legitimacy period determination for CA certificates, where $t_x$\n  denotes $C_x$'s registration timestamp.  After the algorithm's execution, the\n  legitimacy period is expressed as a time range (from \\textbf{begin} to\n  \\textbf{end}).} \n  \\label{fig:period}\n\\end{figure}\n\\begin{figure}[b!]\n  \\centering\n  \\includegraphics[width=0.94\\linewidth]{legitimate_period_leaf.eps}\n  \\caption{Legitimacy period determination for leaf certificates, where $t_x$\n  denotes $C_x$'s registration timestamp.  After the algorithm's execution, the\n  legitimacy period is expressed as a time range (from \\textbf{begin} to\n  \\textbf{end}).} \n  \\label{fig:period_leaf}\n\\end{figure}\n\nThe procedure starts with the first (the root) certificate in the chain, and is\nexecuted for every subsequent certificate. First, the legitimacy period is set as\na time range from $t_x$ (the registration timestamp) to $C_x.\\texttt{NotAfter}$ (which\ndenotes the expiration time specified within the certificate). If a revocation\nissued by the software vendor is present, the legitimacy period of the current certificate\nis limited by the time from which the vendor revoked this certificate (i.e., up to the\nrevocation timestamp). If a certificate is\nrevoked with a private key associated with the certificate ($\\textit{rk}_x$ for a CA certificate and $\\textit{sk}_x$ for a leaf certificate), the legitimacy\nperiod is similarly limited by the revocation timestamp from the revocation message. The last option is\na revocation realized by parent CAs. Similarly, the legitimacy period can be\nrestricted, but this revocation message must be issued during the legitimacy\nperiod of the issuer.\n\nThe legitimacy period of a leaf certificate can express two states (revoked or\nnon-revoked), but the processing logic is similar to the previous case.\n\nDuring the complete validation procedure (see Algorithm~\\ref{alg:validation}), it is\nalso ensured that every certificate from the chain (except the root) has a\nregistration timestamp within the legitimacy period of its parent. In the final step of\nthe validation, it is ensured that the leaf certificate is neither revoked nor\nexpired.\n\n{\\noindent{\\bf{Log Consistency}.}}\nAfter validation succeeded, the client saves the signed root for future\nconsistency checks. Then periodically, the client contacts a monitor to compare\nthe obtained root with the monitor's version.  If two roots with the same timestamps\nare different, it means that the log misbehaved, which can be proved and reported\n(e.g., to a software vendor).  To strengthen consistency checking, {PKISN\\xspace} can be\nenhanced by a system such as ARPKI~\\cite{ARPKI}, or by\ngossip protocols as proposed by Chuat et al.~\\cite{gossip}.\n\n\n\\section{Deployment}\n\\label{sec:deployment}\nThe deployability of a system like {PKISN\\xspace} depends on many factors, such as the\nincentives of the different parties to adopt the technology and the number of required\nparties.\nCT introduced two ways of providing proofs that a certificate is logged to clients\nwhile preserving privacy~\\cite{rfc6962,laurie2012certificatve}.\nWe describe these models in the context of\n{PKISN\\xspace} in the following two subsections. We also show that the deployment of {PKISN\\xspace} is\nchallenging with one of the models introduced by CT, and the main reason for this\nis that the ultimate goals of the two systems are different (CT tries to detect\nmisbehaving CAs, while a revocation system tries to avoid using invalid certificates).\nHowever, we present new models including a browser-driven deployment that brings many\nadvantages, and a new lightweight realization of a log monitor. The presented deployment models\ncan also be used in conjunction.\n\n\\subsection{Server-Driven Deployment}\\label{sec:server_deploy}\nIn the first deployment scenario, depicted in\nFig.~\\ref{fig:server-deployment}, servers are driving the process of proving\nto their clients that their certificate is not revoked:\n\n\\begin{enumerate}\n    \\item The server contacts the log at regular intervals (at least every\n        scheduling period) to obtain a fresh signed tree root and a fresh\n        presence proof.\n    \\item The log returns the requested data.\n    \\item Every time a client connects to the server, this data, together with the\n    certificate chain and the CC, is transmitted to the client (e.g., via an OCSP-stapling\n    mechanism). \n    \\item Clients can communicate with monitors to verify that they share a consistent\n    and compatible vision of the log.\n\\end{enumerate}\n\n\\begin{figure}[h!]\n\\centering\n\\includegraphics[width=0.55\\columnwidth]{server-deployment.eps}\n\\caption{Server-driven deployment model. Dotted and dashed lines represent\noptional and periodic communications, respectively.}\n\\label{fig:server-deployment}\n\\end{figure}\n\nThis deployment model is ideal in terms of efficiency (because only the server\nneeds to periodically perform a few extra connections and the storage\nrequirements are low) and privacy (because the client does not need to contact a third party\nto verify the validity of a server certificate).  However, this\nmodel requires that servers are updated and this is not likely to happen\nrapidly for all TLS servers on the Internet.\n\n\n\\subsection{ISP-Driven Deployment}\\label{sec:isp_deploy}\nAs many servers are not updated regularly, the burden of contacting the log\nto retrieve the revocation information could be put on clients, but there is\na privacy issue if clients do so directly. The documentation of CT~\\cite{laurie2012certificatve}\nmentions that clients could use a modified DNS resolver (provided by their\nISPs) as an intermediary to contact the log.\nHowever, this model is problematic when it comes to revocation, since the\ngoal is no longer to simply detect attacks in an unspecified future, but to\ninstantly determine if a certificate can be considered valid.\nMoreover, in a revocation system, such a connection would be required after\nthe certificate chain is received and before it is accepted (otherwise the client\ndoes not know for which certificate chain a validity message should be\nreturned), which would increase latency and be prone to blocking attacks. For\nthese reasons, it would be challenging to adapt this model in {PKISN\\xspace}.\n\n\n\\subsection{Browser-Driven Deployment}\\label{sec:browser_deploy}\nSince the ISP-driven deployment does not fit the requirements of {PKISN\\xspace},\nand since we cannot assume that all servers would quickly be configured to provide \nfresh proofs to TLS connections (server-driven model), we\nseek an alternative solution. We present a variant of browser-driven\ndeployment with the goal of providing users with the minimal\ninformation required to ensure that no certificate (from the chain) is revoked.\nTo achieve this goal, we propose to extend a browser update mechanism\n(mentioned in \\S\\ref{sec:pre:related}) that is already deployed,\nnamely CRLSets.\n\nAs in a browser-driven deployment clients are periodically provided with\nrevocation messages, it is crucial to minimize bandwidth and\nstorage overheads. In our deployment model, vendors employ the log as a source of\nnew revocations, and they push CRLSets that consist of identifiers (in our case\nhashes) of all revoked and non-expired certificates with their corresponding\nlegitimacy periods (for CA certificates). Additionally, vendors are obliged to\nlog every CRLSet before it is propagated to the browsers, and are obliged to\npropagate the CRLSet with a commitment (or presence proof) from the log,\nindicating that the CRLSet is accepted by the log and will be visible in the near\nfuture. We call this concept a \\textit{Transparent CRL} (TCRL). On the log-side,\nthe TCRL is simply appended to the TimeTree. \nThis deployment model does not provide properties as strong as the server-driven\ndeployment, but it allows to verify certificate validity and it enables the\naudit of TCRLs.\n\n\\begin{figure}[h!]\n\\centering\n\\includegraphics[width=0.65\\columnwidth]{vendor-deployment.eps}\n\\caption{Browser-driven deployment model. Dotted and dashed lines represent\noptional and periodic communications, respectively.}\n\\label{fig:vendor-deployment}\n\\end{figure}\n\nThe connection establishment and certificate validation of this deployment model\nare presented in Fig.~\\ref{fig:vendor-deployment} and proceed as follows:\n\\begin{enumerate}\n    \\item Periodically, the browser vendor contacts a log to obtain the new\n    revocations (note that a vendor can also act here as a monitor).\n    \\item The vendor prepares a software update creating a list of new\n    revocations (TCRL). Then this TCRL is submitted to the log, which returns a commitment\n    indicating that the TCRL will be appended to the TimeTree. Finally, with this commitment\n    (or a presence proof), the vendor pushes the TCRL to the browsers.\n    Browsers verify whether log proofs matched the TCRL and accept the update.\n    \\item During the TLS handshake, the client obtains a certificate chain along\n    with the corresponding CC.\\footnote{If a server deploys {PKISN\\xspace}, then a proof\n    is sent during the\n    handshake, and the client validates the certificate chain as in\n    \\S\\ref{sec:server_deploy}.}\n    Then, with a locally-stored TCRL,\n    the browser verifies whether all certificates from the chain have not been\n    revoked. (As TCRLs provide complete revocation messages, clients\n    can determine the legitimacy periods.) The browser continues with a verification\n    similar to Algorithm~\\ref{alg:validation}. \n    \n    \\item The browser can (optionally) contact a monitor, to\n    verify that the local version of the TCRL (vendor's view) is consistent with\n    the monitor's view. Note that this communication does not reveal any\n    information on the domains that the browser has contacted.\n\\end{enumerate}\n\n\n\\subsection{Lightweight Monitoring}\\label{sec:light_monitor}\nMonitors are an integral part of many log-based schemes. They have the responsibility to\nconstantly monitor the logs to verify whether they behave correctly.\nIn previous proposals~\\cite{AKI,ARPKI,laurie2012certificatve} monitors were\nimplemented as replicas of the logs that perform some extra checks on demand\n(e.g., confirm that their view of the log is consistent with the root provided\nby the client). Because of that design, the bandwidth and storage required to\noperate a monitor are significant. In this section, we propose a novel\ndeployment model that allows to run a lightweight monitoring service.\nThis model could be used by network devices with security features or by power-users, for example.\nSuch a service can assist the clients in additional verification of a connection, and\nthe required features are:\n\\begin{itemize}\n\t\\item confirm the root of the log,\n\t\\item prove that the log is consistent (i.e., a version of the log is the extension of a previous one),\n\t\\item prove that a given object is in the log.\n\\end{itemize}\n\nOur first observation is that the large storage requirement of the log is\ninduced by the necessity of storing entire certificates (a single certificate\ntakes about 2 kB in PEM format). However, as {PKISN\\xspace} clients are provided with\ncertificate chains and the corresponding information during TLS\nconnections, monitors need not store actual certificates but only the corresponding hashes.\nThis is sufficient to ensure that a certificate is indeed in the log and that the log is consistent.\nIn our proposal, a lightweight monitor is not directly equipped with the TimeTree's\nleaves, but with their parent nodes (i.e., hashes) and with revocation messages.\nAnother observation is that certificates have a standardized maximum lifetime.\nTherefore, after some time, the TimeTree will contain a continuous list of expired\ncertificates and there is no need to store the hashes of these certificates, unless\nthey are parts of non-expired chains.\n\n\\begin{figure}[h!]\n\\centering\n  \\begin{tikzpicture}[scale=.49,every tree node/.style={text width=0.8cm,font=\\LARGE,anchor=base}]\n    \\Tree \n    [.\\textit{root}\n        [.$H_{abcdefr_0r_1}$\n            [.\\fbox{$H_\\mathit{abcd}$}\n        [.${H_{ab}}$\n        [.$H_a$ $C_{a}$,\\\\$t_0$ ] [.$H_b$ $C_{b}$,\\\\$t_0$  ] ]\n        [.${H_{cd}}$\n        [.$H_c$ $C_{c}$,\\\\$t_0$ ] [.$H_d$ $C_d$,\\\\$t_0$ ] ] \n    ]\n    [.${H_\\mathit{efr_0r_1}}$\n        [.\\fbox{${H_{ef}}$}\n        [.$H_{e}$ $C_e$,\\\\$t_0$ ] [.$H_f$ $C_f$,\\\\$t_0$  ] ]\n        [.${H_\\mathit{r_0r_1}}$\n        [.\\fbox{$H_{r_0}$} $r_0$,\\\\$t_0$ ] [.\\fbox{$H_{r_1}$} $r_1$,\\\\$t_1$ ] ] \n    ]\n ]\n  [.$H_\\mathit{hijf'klmr_2}$\n    [.$H_{hijf'}$\n        [.${H_{hi}}$\n        [.\\fbox{${H_h}$} $C_h$,\\\\$t_2$ ] [.\\fbox{$H_i$} $C_i$,\\\\$t_2$  ] ]\n        [.${H_{jf'}}$\n        [.\\fbox{$H_j$} $C_j$,\\\\$t_2$ ] [.$H_{f'}$ \\fbox{$R_{C_f}$}\\\\$t_2$ ] ] \n    ]\n    [.${H_\\mathit{klmr_2}}$\n        [.$H_{kl}$\n        [.\\fbox{${H_k}$} $C_k$,\\\\$t_2$ ] [.\\fbox{$H_l$} $C_l$,\\\\$t_2$  ] ]\n        [.${H_{mr_2}}$\n        [.\\fbox{$H_m$} $C_m$,\\\\$t_2$ ] [.\\fbox{$H_{r_2}$} $r_2$,\\\\$t_2$ ] ] \n    ]\n  ]\n ]\n\\end{tikzpicture}\n\\caption{An example of a TimeTree, where all certificates before $t_1$ are\nexpired. Only nodes in boxes are stored by the lightweight monitor.}\n\\label{fig:browser_tree}\n\\end{figure}\n\nAn example of our optimization is depicted in Fig.~\\ref{fig:browser_tree}.\nIt shows the original TimeTree and the values that a monitor must provide.\nIn this case, a monitor must initially obtain from the log only the following:\n\n", "index": 19, "text": "\\begin{equation}\n\\begin{aligned}\n\\label{eq:update}\n    t_0 &: \\{H_\\mathit{abcd},H_{ef}, H_{r_0}\\},\\\\\n    t_1 &: \\{H_{r_1}\\}, \\\\\n    t_2 &: \\{H_h, H_i, H_j,R_{C_f}, H_k, H_l, H_m, H_{r_2}\\},\\\\\n        & \\hspace{0.29cm}\\{\\textit{root}, t_2\\}_{{k}_{\\textit{log}}}.\n\\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle t_{0}\" display=\"inline\"><msub><mi>t</mi><mn>0</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10X.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle:\\{H_{\\mathit{abcd}},H_{ef},H_{r_{0}}\\},\" display=\"inline\"><mrow><mrow><mi/><mo>:</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>H</mi><mi>\ud835\udc4e\ud835\udc4f\ud835\udc50\ud835\udc51</mi></msub><mo>,</mo><msub><mi>H</mi><mrow><mi>e</mi><mo>\u2062</mo><mi>f</mi></mrow></msub><mo>,</mo><msub><mi>H</mi><msub><mi>r</mi><mn>0</mn></msub></msub><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10Xa.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle t_{1}\" display=\"inline\"><msub><mi>t</mi><mn>1</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10Xa.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle:\\{H_{r_{1}}\\},\" display=\"inline\"><mrow><mrow><mi/><mo>:</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>H</mi><msub><mi>r</mi><mn>1</mn></msub></msub><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10Xb.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle t_{2}\" display=\"inline\"><msub><mi>t</mi><mn>2</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10Xb.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle:\\{H_{h},H_{i},H_{j},R_{C_{f}},H_{k},H_{l},H_{m},H_{r_{2}}\\},\" display=\"inline\"><mrow><mrow><mi/><mo>:</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>H</mi><mi>h</mi></msub><mo>,</mo><msub><mi>H</mi><mi>i</mi></msub><mo>,</mo><msub><mi>H</mi><mi>j</mi></msub><mo>,</mo><msub><mi>R</mi><msub><mi>C</mi><mi>f</mi></msub></msub><mo>,</mo><msub><mi>H</mi><mi>k</mi></msub><mo>,</mo><msub><mi>H</mi><mi>l</mi></msub><mo>,</mo><msub><mi>H</mi><mi>m</mi></msub><mo>,</mo><msub><mi>H</mi><msub><mi>r</mi><mn>2</mn></msub></msub><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10Xc.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\hskip 8.251299pt\\{\\textit{root},t_{2}\\}_{{k}_{\\textit{log}}}.\" display=\"inline\"><mrow><msub><mrow><mo lspace=\"10.8pt\" stretchy=\"false\">{</mo><mtext>\ud835\udc5f\ud835\udc5c\ud835\udc5c\ud835\udc61</mtext><mo>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy=\"false\">}</mo></mrow><msub><mi>k</mi><mtext>\ud835\udc59\ud835\udc5c\ud835\udc54</mtext></msub></msub><mo>.</mo></mrow></math>", "type": "latex"}]