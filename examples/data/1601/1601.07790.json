[{"file": "1601.07790.tex", "nexttext": "\nThe length of the second part, i.e., the length of $\\viewPath[z_{i'}]{\\view[l]}{u_{k+1}}$ is {at most}\n", "itemtype": "equation", "pos": 27717, "prevtext": "\n\n\\title{Topology Recognition and Leader Election in Colored Networks}\n\n\\author{Dariusz Dereniowski\\thanks{Faculty of Electronics, Telecommunications and Informatics, Gda{\\'n}sk University of Technology, Narutowicza 11/12, 80-233 Gda\\'{n}sk, Poland. Email: deren@eti.pg.gda.pl. Partially supported by National Science Centre grant DEC-2015/17/B/ST6/01887.}\n\\and\nAndrzej Pelc\\thanks{D\\'epartement d'informatique, Universit\\'e du Qu\\'ebec en Outaouais, Gatineau, Qu\\'ebec J8X 3X7, Canada. Email: pelc@uqo.ca. Partly supported by the NSERC discovery grant 8136 -- 2013 and by the Research Chair in Distributed Computing at the Universit\\'e du Qu\\'ebec en Outaouais.}\n}\n\n\\date{}\n\\maketitle\n\n\n\n\n\n\\begin{abstract}\nTopology recognition and leader election are fundamental tasks in distributed computing in  networks. The first of them requires each node to find a labeled isomorphic copy of the network, while the result of the second one consists in a single node adopting the label 1 (leader), with all\nother nodes adopting the label 0 and learning a path to the leader. We consider both these problems in networks whose nodes \nare equipped with not necessarily distinct labels called {\\em colors}, and ports at each node of degree $d$ are arbitrarily numbered $0,1,\\dots, d-1$. Colored networks are generalizations both of labeled networks, in which nodes have distinct labels, and of anonymous \nnetworks, in which nodes do not have labels (all nodes have the same color). \n\nIn colored networks, topology recognition and leader election are not always feasible. Hence we study two more general problems.\nConsider a colored network and an input $I$ given to its nodes.\nThe aim of the problem ${\\textup{TOP}}$, for this colored network and for $I$, is to solve topology recognition in this network, if this is possible under input $I$, and to have all nodes answer ``unsolvable'' otherwise.\nLikewise, the aim of the problem ${\\textup{LE}}$ is to solve leader election in this network, if this is possible under input $I$, and to have all nodes answer ``unsolvable'' otherwise. \n\nWe show that nodes of a network can solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, if they are given, as input $I$,\nan upper bound $k$ on the number of nodes of a given color, called the {\\em size} of this color.\nOn the other hand we show that, if the nodes are given an input that does not bound the size of any color, then the answer to ${\\textup{TOP}}$ and ${\\textup{LE}}$ must be ``unsolvable'', even for the class of rings.\n\nUnder the assumption that nodes are given an upper bound $k$ on the size of a given color, we study the time of solving problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ in the $\\cal{LOCAL}$ model in which, during each round, each node can exchange arbitrary messages with all its neighbors and perform arbitrary local computations.\nWe give an algorithm to solve each of these problems in arbitrary networks in time $O(kD+D\\log(n/D))$, where $D$ is the diameter\nof the network and $n$ is its size. We also show that this time is optimal, by exhibiting\nclasses of networks in which every algorithm solving problems ${\\textup{TOP}}$ or ${\\textup{LE}}$ must use time\n$\\Omega(kD+D\\log(n/D))$.\n\\end{abstract}\n\n\\textbf{Keywords:} topology recognition, leader election, colored network, local model\n\n\\section{Introduction} \\label{sec:intro}\n\n\\subsection{The model and the problem} \\label{subsec:model}\n\nTopology recognition and leader election are fundamental tasks in distributed computing in  networks. The goal of topology recognition is for each node of the network to acquire a faithful map of it (an isomorphic\ncopy of the underlying network with all nodes having distinct identifiers), with the position of the node marked in the map. If nodes can solve this problem, any other \ndistributed task, such as leader election \\cite{HS,P}, minimum weight spanning tree construction \\cite{A}, \nrenaming \\cite{ABDKPR}, etc. can be performed by them using\nonly local computations. Thus topology recognition converts all distributed problems to centralized ones, \nin the sense that nodes can solve any distributed problem simulating a central monitor.\n\nLeader election, first stated in \\cite{LL}, is likewise of fundamental importance.\nEach node of the network has a Boolean variable initialized to 0 and, after the election, exactly one node,\ncalled the {\\em leader}, should change this value to 1. All other nodes should know which one becomes the leader by discovering a path to it.\nNotice that the above two problems are equivalent: having a map of the network with distinct node labels, nodes can elect the node with the smallest\nlabel as the leader, and conversely, knowing a leader, nodes can construct a map of the network using the leader as a stationary token, cf. \\cite{CDK}.\n\nIt should be noted that formulations of the leader election problem vary across the literature (cf. \\cite{Ly}). In a weak formulation, every node should only know if it is the leader or not. (In \\cite{MP}, this task was called selection, by contrast to election). In a strong formulation, every node should moreover get to know who is the leader. We adopt the latter formulation of the leader election problem. When nodes have distinct identities, knowing who is the leader means outputting its identity. In our scenario distinct identities need not exist, hence knowing who is the leader means that every node outputs a path to the leader, coded as a sequence of ports. This formulation of leader election was used, e.g., in \\cite{GMP} for anonymous networks.   \n\n\nA network is modeled as a simple undirected connected graph. As commonly done in the literature, cf., e.g. \\cite{YK3} {or $KT_0$ model in \\cite{AGPV}}, we assume that\nports at a node of degree $d$ have arbitrary fixed labelings $0,\\dots,$ $d-1$.\nWe do not assume any coherence between port labelings at various nodes.\nAs for nodes, we assume that they are equipped with not necessarily distinct labels called {\\em colors}.  In applications, colors may be types of the devices interconnected by the network, \nsuch as workstations, servers, laptops, or mobile phones.\nNetworks with colored nodes are generalizations both of labeled networks in which nodes have distinct labels, and of anonymous \nnetworks, in which nodes do not have labels (all nodes have the same color). \nNodes communicate by exchanging arbitrary messages along links. A node sending a message\nthrough a given port appends the port number to the message, and a node receiving a message\nthrough a port is aware of the port number by which the message is received.\n\nIf nodes have distinct identities, both topology recognition and leader election are easily accomplished in any network. By contrast, it is well known that, in the absence of distinct node labels, these tasks are often impossible, if no additional information about the network is provided to nodes. In fact, even the less demanding task of reconstructing an unlabeled isomorphic copy of the\nnetwork is sometimes impossible. \nFor example, in an anonymous ring whose each edge has port numbers 0 and 1 at its\nendpoints, not only topology recognition and leader election cannot be achieved but even \nthe size of the ring cannot be learned by nodes. Providing the size of the network as input is not a remedy\neither: the authors of \\cite{YK3} give examples of two (anonymous) non-isomorphic graphs of size 6 whose\nnodes cannot decide in which of these two graphs they are.\n\nDue to these impossibilities, we consider two problems more general than topology recognition\nand leader election, respectively.\nConsider a colored network and an input $I$ given to its nodes.\nThe aim of the problem ${\\textup{TOP}}$, for this colored network and for $I$, is to solve topology recognition in this network, if this is possible under input $I$, and to have all nodes answer ``unsolvable'' otherwise.\nLikewise, the aim of the problem ${\\textup{LE}}$ is to solve leader election in this network, if this is possible under input $I$, and to have all nodes answer ``unsolvable'' otherwise. \n\nOur goal is to find out what type of input has to be given to the nodes of a colored network in order to enable them to solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, and what is the minimal time in which they can solve these problems, if this input is provided.\nTo investigate time, we use the extensively studied $\\cal{LOCAL}$ model \\cite{Pe}.\nIn this model, communication proceeds in synchronous rounds and all nodes start simultaneously.\nIn each round each node can exchange arbitrary messages with all its neighbors and perform arbitrary local computations. \nThe time of completing a task is the number of rounds it takes.\n\n\n\n\n\n\n\n\\subsection{Our results} \\label{subsec:our_results}\n\n\nWe first show that nodes of a network can solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, if they are given\nan upper bound $k$ on the number of nodes of a given color, called the {\\em size} of this color.\nThis means that, if such an upper bound is known to all nodes (even if they do not know any upper bound on the total number of nodes\nor on the number of colors), then they can correctly decide if leader election and topology recognition\nare feasible in the given network, and if so, they can perform these tasks. \nOn the other hand, if the nodes are given an input that does not bound the size of any color, then the answer to ${\\textup{TOP}}$ and ${\\textup{LE}}$ must be ``unsolvable'', even for the class of rings.\n\nHence, providing all nodes with an upper bound on the size of some color is the weakest assumption under which problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ can be meaningfully solved. \nThis justifies the use of this assumption in our algorithms.\n\n\nNext, assuming that all nodes have an upper bound $k$ on the size of a given color,\nwe study the time of solving problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ in the $\\cal{LOCAL}$ model. We give an \nalgorithm to solve each of these problems in arbitrary networks in time $O(kD+D\\log(n/D))$, where $D$ is the diameter\nof the network and $n$ is its size. We also show that this time is optimal, by exhibiting\nclasses of networks in which every algorithm solving problems ${\\textup{TOP}}$ or ${\\textup{LE}}$ must use time\n$\\Omega(kD+D\\log(n/D))$.\n\n\n\n\n\\subsection{Related work} \\label{subsec:related_work}\n\nEarly studies of leader election in networks mostly concerned the scenario where all nodes have distinct labels.\nThis task was first studied for rings.\nA synchronous algorithm, based on comparisons of labels, and using\n$O(n \\log n)$ messages was given in \\cite{HS}. It was proved in \\cite{FL} that\nthis complexity is optimal for comparison-based algorithms. On the other hand, the authors showed\nan algorithm using a linear number of messages but requiring very large running time.\nAn asynchronous algorithm using $O(n \\log n)$ messages was given, e.g., in \\cite{P} and\nthe optimality of this message complexity was shown in \\cite{B}. Deterministic leader election in radio networks has been studied, e.g., \nin \\cite{JKZ,KP,NO} and randomized leader election, e.g., in \\cite{Wil}. In \\cite{HKMMJ} the leader election problem is\napproached in a model based on mobile agents for networks with labeled nodes.\n\nMany authors \\cite{An,ASW,AtSn,BV,DKMP,Kr,KKV,Saka,YK,YK3} studied leader election\nand other computational problems\nin anonymous networks. In particular, \\cite{BSVCGS,YK3} characterize message passing networks in which\nleader election can be achieved when nodes are anonymous. \nThe authors assume that nodes know an upper bound on the size of the network. In \\cite{YK2} the authors study\nthe problem of leader election in general networks, under the assumption that labels are\nnot unique. They characterize networks in which this can be done and give an algorithm\nwhich performs election when it is feasible. They assume that the number of nodes of the\nnetwork is known to all nodes. In\n \\cite{FKKLS}  the authors\nstudy feasibility and message complexity of sorting and leader election in rings with\nnonunique labels, while in \\cite{DoPe} the authors provide algorithms for the\ngeneralized leader election problem in rings with arbitrary labels,\nunknown (and arbitrary) size of the ring, and for both\nsynchronous and asynchronous communication. \nCharacterizations of feasible instances for leader election and naming problems have been provided in~\\cite{C,CMM,CM}.\nMemory needed for leader election in unlabeled networks has been studied in \\cite{FP}. \nIn \\cite{FP1}, the authors investigated the time of leader election in anonymous networks\nby characterizing this time in terms of the size and diameter of the network, and of an additional\nparameter, called level of symmetry, which measures how deeply nodes have to inspect the network to notice differences in their views of it.\nIn \\cite{DP1}, the authors studied feasibility of leader election among anonymous agents that\nnavigate in a network in an asynchronous way.\n\n\nFeasibility of topology recognition for anonymous networks with adversarial port labelings was studied in~\\cite{YK3},\nunder the assumption that nodes know an upper bound on the size of the network.\nThe problem of efficiency of map construction by a mobile agent, equipped with a token and exploring an anonymous network,  has\nbeen studied in \\cite{CDK}. In \\cite{DP}, the authors investigated the minimum size of advice\nthat has to be given to a mobile agent, in order to enable it to reconstruct  the topology of an anonymous network or to construct its spanning tree.\nIn \\cite{FPR},\ntradeoffs between time of topology recognition and the size of advice given to nodes were studied\nin the $\\cal{LOCAL}$ communication model.  \n\n\n\n\n\\section{Preliminaries} \\label{sec:feasibility}\n\n\nIn this section we introduce some basic terminology and provide preliminary  results known from the literature. Let $G$ be a simple connected undirected network with the set of nodes $V$, and let $c$ be a positive integer.\nConsider any surjective function $f: V \\longrightarrow \\{1,\\dots , c\\}$.\nThe couple $(G,f)$ is called a {\\em colored network}, the function $f$ is called a\n{\\em coloring} of this network, and $f(v)$ is called the {\\em color} of node $v$. \n\n\n\nWe will use the following notion from \\cite{YK3}. Let $G$ be a network and $v$ a node of $G$.  We first define, for any $l \\geq 0$,  the {\\em truncated view}\n${\\cal V}^l(v)$ at depth $l$, by induction on $l$. ${\\cal V}^0(v)$ is a tree consisting of a single node $x_0$. \nIf ${\\cal V}^l(u)$ is defined for any node $u$ in the network, then ${\\cal V}^{l+1}(v)$ is the port-labeled tree\nrooted at $x_0$ and defined as follows.\nFor every node $v_i$, $i=1,\\dots ,k$, adjacent to $v$, \nthere is a child $x_i$ of $x_0$ in ${\\cal V}^{l+1}(v)$ such that the port number at $v$ corresponding to edge $\\{v,v_i\\} $ is the same as the port number \nat $x_0$ corresponding to edge $\\{x_0,x_i\\}$,\nand the port number at $v_i$ corresponding to edge $\\{v,v_i\\} $ is the same as the port number at $x_i$ corresponding to edge $\\{x_0,x_i\\}$.  We say that the node $x_i$ {\\em represents} node $v_i$.\nNow node $x_i$, for $i=1,\\dots ,k$ becomes \nthe root of the truncated view ${\\cal V}^l(v_i)$.   \n The {\\em view} of $v$ is the infinite rooted tree ${\\cal V}(v)$ with labeled ports, such that ${\\cal V}^l(v)$ is its truncation to depth $l$, for each $l\\geq 0$.\n\nWe will also use a notion similar to that of the view but corresponding to colored networks (cf. \\cite{Norris}). Consider a colored network $(G,f)$. Let $v$ be any node of $G$. \nLet $f^*: {\\cal V}(v) \\longrightarrow \\{1,\\dots , c\\} $ be the function defined as follows:\n$f^*(x)=f(v)$, where  $x$ is a node of ${\\cal V}(v)$ representing node $v$.\nThe couple $({\\cal V}(v), f^*)$ is called the {\\em colored view} of node $v$.\nThus, the colored view of a node additionally marks colors of nodes represented in it.\nThe couple $({\\cal V}^{l}(v), f_l)$, where $f_l$ is the truncation of $f^*$ to ${\\cal V}^l(v)$, is called a \n{\\em truncated  colored view} of node $v$.\n\nFor the (truncated) views of a node $v$ we will often omit the node $v$ in the notation,\nthus writing ${\\cal V}$ instead of ${\\cal V} (v)$ and ${\\cal V}^l$ instead of ${\\cal V}^l(v)$, if the node $v$, called\nthe {\\em root} of the view, is clear from the context. The same convention applies to \ncolored (truncated) views. The \\emph{level} $l$ of a view ${\\cal V}$, denoted ${\\textup{lev}_{{l}}({{\\cal V}})}$, is the set of all its nodes at distance $l$ (in ${\\cal V}$) from the root of the view. For nodes $u$ and $v$ in the truncated view ${\\cal V} ^l$, we denote by $P({\\cal V} ^l,u,v)$ the unique path in ${\\cal V} ^l$ from $u$ to $v$,\ndefined as a sequence of nodes in this truncated view. We denote by $P({\\cal V} ^l,v)$ the unique path from the root of the view to $v$. For such a path $P$, we denote by $|P|$ the length of this path,\ndefined as the number of edges in it. For a truncated view ${\\cal V} ^l$ and a node $z$ in this view,\nwe denote by ${\\cal V} ^l[z]$ the subtree of  ${\\cal V} ^l$ rooted at $z$.\n\n\nThe following proposition was proved in \\cite{H}.\n\\begin{proposition}\\label{trunc}\nFor a $n$-node network of diameter $D$,\n${\\cal V}(u)={\\cal V}(v)$, if and only if ${\\cal V}^{h}(u)={\\cal V}^{h}(v)$,\nfor some $h \\in \\Theta(D \\log (n/D))$.\n{\\hfill $\\square$ \\smallbreak}\\end{proposition}\n\nThe following proposition that follows from \\cite{DKP} shows that the truncation level $h$ from Proposition \\ref{trunc}\nis the smallest possible, up to constant factors.\n\n\\begin{proposition}\\label{trunc-lower}\nFor any integers $D\\leq n$, there exists a network $G$ of size $\\Theta(n)$ and diameter $\\Theta(D)$, with nodes $u$ and $v$, both with unique views,\nsuch that ${\\cal V}(u)\\neq {\\cal V}(v)$ but ${\\cal V}^{h'}(u)={\\cal V}^{h'}(v)$,\nfor some $h' \\in \\Theta(D \\log (n/D))$.\nMoreover, there exists a network $G'$ having the same size and diameter as that of $G$, with a node $u'$, such that $\\view[h'](u')=\\view[h'](u)$.\n {\\hfill $\\square$ \\smallbreak}\\end{proposition}\n \nPropositions \\ref{trunc} and \\ref{trunc-lower} remain valid, when views are replaced by colored views.\n\nDefine the following equivalence relations on the set of nodes of a colored network $(G,f)$.\n{Let} $u\\sim v$ if and only if $({\\cal V}(u),f^*)=({\\cal V}(v), f^*)$, and {let also} $u\\sim_t v$ if and only if $({\\cal V}^t(u), f_t)=({\\cal V}^t(v), f_t)$.\nLet $\\Pi$ be the partition of all nodes into equivalence classes of $\\sim$, and $\\Pi_t$ the corresponding partition for  $\\sim_t$.\nIt follows from \\cite{YK3} that all equivalence classes in $\\Pi$ are of equal size $\\sigma$. In view of Proposition \\ref{trunc}\nthis is also the case for $\\Pi_t$, for some $t\\in \\Theta(D \\log (n/D))$. On the other hand, for smaller $t$, equivalence classes in $\\Pi_t$ \nmay be of different sizes.  \nEvery equivalence class in  $\\Pi_t$ is a union of some equivalence classes in  $\\Pi_{t'}$, for $t<t'$.  \nThe following result was proved in \\cite{Norris}. It says that if the sequence of partitions $\\Pi_t$ stops changing at some point, it will never change again. \n\n\\begin{proposition}\\label{stop}\nIf $\\Pi_t=\\Pi_{t+1}$, then $\\Pi_t=\\Pi$.\n{\\hfill $\\square$ \\smallbreak}\\end{proposition}\n\nThe following proposition, easily proved by induction on $T$, implies that if $\\view[T](u)=\\view[T](v)$ for some nodes $u$ and $v$, and all nodes are given the same information about the network, then any algorithm solving ${\\textup{TOP}}$ or ${\\textup{LE}}$ in time at most $T$ must give the same output, when executed by $u$ and by $v$.\n\\begin{proposition} \\label{prop:algoView}\nLet $u$ be a node in a colored network $G$ and $u'$ a node in a colored network $G'$.\nSuppose that initially all nodes of $G$ and $G'$ have the same input.\nLet $T$ be a positive integer and assume that $\\view[T](u)=\\view[T](u')$.\nFor any $t\\leq T$, let $M$ be the message received by $u$ through port $p$ in round $t$.\nThen, message $M$ is received by $u'$ through port $p$ in round $t$.\n{\\hfill $\\square$ \\smallbreak}\n\\end{proposition}\n\nNext, we define the notion of a {\\em colored quotient graph}, which is a generalization of the\nnotion of quotient graph introduced in  \\cite{YK3}. Given a colored network $(G,f)$, its colored quotient\ngraph $(Q,\\overline{f})$ is defined as follows.  Nodes of $Q$ are equivalence classes of the above defined relation $\\sim$. If $a$ and $b$ are two such classes, there is an edge joining $a$ and $b$\nin $Q$, with port number $p$ at $a$ and $q$ at $b$, if and only if there is an edge joining nodes $u$ and\n$v$ in $G$, with port number $p$ at $u$ and $q$ at $v$, where $u$ belongs to the class $a$ and $v$ belongs to the class $b$. (Hence, unlike $G$, the graph $Q$ can have self-loops and multiple\nedges.) The function $\\overline{f}$ is defined on all nodes of $Q$ by the formula\n$\\overline{f}(a)=f(u)$, where $u$ belongs to the class $a$. \n\nFinally, we give the formal definitions of the main problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ considered in this paper. Both these problems are to be solved in an unknown colored graph.\nFor each of these problems, all nodes are given some common input $I$.\nIn order to solve the problem ${\\textup{LE}}$, every node has to output a sequence of port numbers leading from this node to a single node, called the leader, if this task is possible to perform using input $I$;\notherwise, all nodes must output the answer ``unsolvable''. In order to solve the problem ${\\textup{TOP}}$, every node $v$ has to output an isomorphic copy $C_v$ of the underlying graph, with all nodes labeled by distinct identifiers, and the node $v$ correctly marked in $C_v$,  if this task is possible to perform using input $I$;\notherwise, all nodes must output the answer ``unsolvable''.\n\n\n\\section{The algorithm and its analysis}  \\label{sec:algorithm}\n\nIn this section we describe and analyze an algorithm for solving the problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, assuming that some bound $k$ on the size of one of the colors is known.\nThis color will be denoted by ${\\alpha}$.\nRecall that, by definition, there exists at least one node with color ${\\alpha}$ in the network.\n\nThe algorithm aims at computing the colored quotient graph.\nOnce this is achieved, the solutions to ${\\textup{TOP}}$ and ${\\textup{LE}}$ will follow easily.\nThe task of computing the colored quotient graph is divided into three procedures called ${\\textup{\\texttt{TestRepetition}}}$, ${\\textup{\\texttt{ComputeView}}}$ and ${\\textup{\\texttt{ComputeQuotientGraph}}}$.\nProcedure ${\\textup{\\texttt{ComputeView}}}$ computes the truncated colored view of the executing node up to a certain depth $l$.\nThis depth $l$ depends on the answers returned by several calls to ${\\textup{\\texttt{TestRepetition}}}$ in procedure ${\\textup{\\texttt{ComputeView}}}$.\nFinally, procedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ uses the view and, by further extending it to an appropriate depth, obtains the colored quotient graph.\nWe now give the detailed description of the above procedures.\nThey are all formulated for an executing node $w$.\nWe write $\\view$ and $\\view[l]$ instead of $\\view(w)$ and $\\view[l](w)$, respectively.\n\n\\medskip\nProcedure ${\\textup{\\texttt{TestRepetition}}}$ uses the following notion of distance between colors and nodes.\nGiven a truncated colored view $(\\view[l],f)$ and a node $v$ belonging to it, the \\emph{distance from $v$ to color ${\\alpha}$} is the length of the shortest path in $\\view[l][v]$ that connects $v$ with some node with color ${\\alpha}$.\nGiven a view $\\view[l]$ and a node $v$ belonging to it, we say that $v$ has a \\emph{copy in} $\\view[i]$, $i\\leq l$, if there exists $v'$ in $\\view[i]$ such that $v'$ and $v$ represent the same node of the network.\nAdditionally, if $|\\viewPath{\\view[l]}{v'}|<|\\viewPath{\\view[l]}{v}|$, then we say that $v$ has a \\emph{high copy} in $\\view[l]$.\n\nBefore giving the pseudocode of procedure ${\\textup{\\texttt{TestRepetition}}}$, we describe its high-level idea.\nGiven a truncated colored view $(\\view[l],f)$ and a node $v$ in it as an input, the goal of this procedure is to return ${\\texttt{true}}$ if $v$ has a high copy in $\\view[l]$.\nThis is done by exploiting the only tool available to the algorithm: counting nodes in $\\view[l]$ of color ${\\alpha}$.\nNamely, for each node $u$ in $\\viewPath{\\view[l]}{v}$, the procedure computes the distance from $u$ to color ${\\alpha}$ in $\\view[l][u]$ and then it takes the maximum over all such distances, denoted by $d'$.\nIf no node with the color ${\\alpha}$ is observed in $\\view[l][u]$, then $d_u$ is set to $\\infty$ which results in $d'=\\infty$ and the procedure returns ${\\texttt{false}}$.\nAs proven below (cf. Lemma~\\ref{lem:test:bound}) checking whether the distance from the root to $v$ in $\\view[l]$ is at least $2(k+1)(d'+1)$ is sufficient for procedure ${\\textup{\\texttt{TestRepetition}}}$ to return ${\\texttt{true}}$.\nNote that there exist networks such that ${|{\\viewPath{\\view[l]}{v}}|}$ is smaller than $2(k+1)(d'+1)$ but $v$ still has a high copy in $\\view[l]$.\nHowever, in such cases the procedure ${\\textup{\\texttt{TestRepetition}}}$ is unable to certify that and, thanks to later calls to ${\\textup{\\texttt{TestRepetition}}}$ in our algorithm, several descendants of $v$ will be recognized to have high copies.\n\n\n\n\n\n\\begin{algorithm} \\caption{${\\textup{\\texttt{TestRepetition}}}( \\view[l],f,v )$}\n\\begin{algorithmic}\n\\REQUIRE Truncated colored view $(\\view[l],f)$, $l\\geq 1$, a node $v$ in $\\view[l]$.\n\\ENSURE ${\\texttt{true}}$ or ${\\texttt{false}}$.\n\n\\FORALL{$u$ in $\\viewPath{\\view[l]}{v}$}\n   \\STATE $d_u \\leftarrow$ distance from $u$ to color ${\\alpha}$ in $(\\view[l][u],f)$;\n   \\STATE (Possibly $d_u=\\infty$ if ${\\alpha}$ does not appear in $(\\view[l][u],f)$.)\n\\ENDFOR\n\\STATE $d' \\leftarrow \\max\\{d_u {\\hspace{0.1cm}\\bigl|\\bigr.\\hspace{0.1cm}} u\\textup{ in }\\viewPath{\\view[l]}{v}\\}$\n\\IF{ ${|{\\viewPath{\\view[l]}{v}}|} \\geq 2(k+1)(d'+1)$ }\n   \\RETURN ${\\texttt{true}}$\n\\ELSE\n   \\RETURN ${\\texttt{false}}$\n\\ENDIF\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{lemma} \\label{lem:test:bound}\nLet $k$ be an upper bound on the size of the color ${\\alpha}$ in the network {and let $v$ be a node in the network}.\nLet $d'$ be the maximum distance from a node $u$ to color ${\\alpha}$ in $\\view[l](u)$ taken over all nodes $u$ in $\\viewPath{\\view[l]}{v}$.\nIf ${|{\\viewPath{\\view[l]}{v}}|} \\geq 2(k+1)(d'+1)$, then $v$ has a high copy in $\\view[l]$.\n\\end{lemma}\n\n\\begin{proof}\nFind an ancestor $u$ of $v$ in $\\view[l]$ such that the length of the path from the root to $u$ is exactly $2(k+1)(d'+1)$.\nLet $u_0,\\ldots,u_{k+1}$ be such nodes in the path $\\viewPath{\\view[l]}{u}$ that $u_i$ is at distance $2i(d'+1)$ from the root.\nNote that $u_{k+1}=u$.\nFor each $i\\in\\{1,\\ldots,k+1\\}$, let $z_i$ be a node with color ${\\alpha}$ at distance at most $d'$ from $u_i$ in $\\view[l][u_i]$.\nSuch a node $z_i$ exists by definition of $d'$ and by the fact that $d'\\neq\\infty$, {for any} $i\\in\\{1,\\ldots,k+1\\}$.\nThe latter follows from ${|{\\viewPath{\\view[l]}{v}}|} \\geq 2(k+1)(d'+1)$.\n\nSince the size of color ${\\alpha}$ is at most $k$, there exist $i,i'\\in\\{1,\\ldots,k+1\\}$, $i<i'$, such that $z_i$ and $z_{i'}$ represent the same node of the network.\nConsider the sequence of ports that is a concatenation of the sequences of ports of the following paths: $\\viewPath{\\view[l]}{z_i}$ and $\\viewPath[z_{i'}]{\\view[l]}{u_{k+1}}$.\nThis sequence of ports gives a valid path from the root to some node $u'$ in the colored view $\\view$, since $z_i$ and $z_{i'}$ represent the same node of the network.\nWe bound the length $l'$ of $\\viewPath{\\view}{u'}$ as follows.\nNote that the first part of $\\viewPath{\\view}{u'}$ of length $|\\viewPath{\\view}{z_i}|$ equals $\\viewPath{\\view}{z_i}$.\nThus, the length of this first part is at most\n", "index": 1, "text": "\n\\[|\\viewPath{\\view[l]}{u_i}|+|\\viewPath[u_i]{\\view[l]}{z_i}| \\leq 2i(d'+1) + d'.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"|\\viewPath{\\view[l]}{u_{i}}|+|\\viewPath[u_{i}]{\\view[l]}{z_{i}}|\\leq 2i(d^{%&#10;\\prime}+1)+d^{\\prime}.\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>u</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>u</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>\u2264</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msup><mi>d</mi><mo>\u2032</mo></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07790.tex", "nexttext": "\nTherefore, since $i<i'$, we obtain\n", "itemtype": "equation", "pos": 27903, "prevtext": "\nThe length of the second part, i.e., the length of $\\viewPath[z_{i'}]{\\view[l]}{u_{k+1}}$ is {at most}\n", "index": 3, "text": "\n\\[|\\viewPath[z_{i'}]{\\view[l]}{u_{i'}}|+|\\viewPath[u_{i'}]{\\view[l]}{u_{k+1}}| \\leq d' + 2(k+1-i')(d'+1).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"|\\viewPath[z_{i^{\\prime}}]{\\view[l]}{u_{i^{\\prime}}}|+|\\viewPath[u_{i^{\\prime}%&#10;}]{\\view[l]}{u_{k+1}}|\\leq d^{\\prime}+2(k+1-i^{\\prime})(d^{\\prime}+1).\" display=\"block\"><mrow><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>z</mi><msup><mi>i</mi><mo>\u2032</mo></msup></msub><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>u</mi><msup><mi>i</mi><mo>\u2032</mo></msup></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>u</mi><msup><mi>i</mi><mo>\u2032</mo></msup></msub><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>u</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>\u2264</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>-</mo><msup><mi>i</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07790.tex", "nexttext": "\nThus, $u'$ belongs to $\\view[2(k+1)(d'+1)-1]$, or in other words, the node $u$ that belongs to level $2(k+1)(d'+1)$ of $\\view[l]$ has a high copy in $\\view[2(k+1)(d'+1)-1]$.\nSince either $u=v$ or $u$ is an ancestor of $v$, we obtain that $v$ has a high copy in $\\view[l]$, as required.\n\\end{proof}\n\n\\begin{corollary} \\label{cor:test:bound}\nConsider a truncated colored view $(\\view[l],f)$ and a node $v$ in this view.\nIf procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$ for input $\\view[l],f$ and $v$, then $v$ has a high copy in $\\view[l]$.\n{\\hfill $\\square$ \\smallbreak}\n\\end{corollary}\n\nWe have proved that if procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$, then this guarantees that the input node $v$ has a high copy.\nHowever, for the correctness of our final algorithm we need to ensure that each infinite simple path in $\\view$ originating from the root contains a node $v$ that has a high copy, and that this fact will be detected by procedure ${\\textup{\\texttt{TestRepetition}}}$.\nMoreover, in order to bound the time of our final algorithm, we need to estimate the distance from such $v$ to the root, which is done in the next lemma.\n\\begin{lemma} \\label{lem:test:finite}\nLet $(\\view[l],f)$ be a truncated colored view and let $v$ be a node in it.\nIf $l=2(k+1)({D}+1)+{D}$ and $v$ belongs to level $2(k+1)({D}+1)$ of $\\view[l]$, then procedure ${\\textup{\\texttt{TestRepetition}}}$ executed for $\\view[l],f$ and $v$ returns ${\\texttt{true}}$.\n\\end{lemma}\n\\begin{proof}\nFor each node $u$ of the path $\\viewPath{\\view[l]}{v}$, the node of the network represented by it is at distance at most ${D}$ (in the network) from some node with color ${\\alpha}$.\nThis implies that $d_u\\leq{D}$ for each such node $u$.\nThus, $d'\\leq{D}$.\nWe obtain that\n", "itemtype": "equation", "pos": 28046, "prevtext": "\nTherefore, since $i<i'$, we obtain\n", "index": 5, "text": "\n\\[|\\viewPath{\\view}{u'}|\\leq 2d'+2i(d'+1)+2(k+1-i')(d'+1)<2(k+1)(d'+1).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"|\\viewPath{\\view}{u^{\\prime}}|\\leq 2d^{\\prime}+2i(d^{\\prime}+1)+2(k+1-i^{%&#10;\\prime})(d^{\\prime}+1)&lt;2(k+1)(d^{\\prime}+1).\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><msup><mi>u</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>d</mi><mo>\u2032</mo></msup></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo>-</mo><msup><mi>i</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>&lt;</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07790.tex", "nexttext": "\nwhich implies that procedure ${\\textup{\\texttt{TestRepetition}}}$ returns true.\n\\end{proof}\n\n\n\n\n\\medskip\nBefore describing the next procedure, we introduce some more notation.\nA truncated colored view $(\\view[l],f)$ \\emph{covers the network} if, for each node $x$ of the network, there exists a node $u$ of $\\view[l]$ such that $u$ represents $x$.\nWe define procedure ${\\texttt{communicate}}$ which sends the currently acquired truncated colored view $(\\view[t],f)$ to all neighbors and receives the messages containing currently acquired colored views of the same depth $t$ from all neighbors.\nNote that after all nodes have performed ${\\texttt{communicate}}$ $t$ times, each node can compute its truncated colored view $\\view[t]$.\n\nWe now describe procedure ${\\textup{\\texttt{ComputeView}}}$.\nAgain, we start with an informal description.\nIn each iteration, the `while' loop increments the depth of the view currently stored at the executing node.\nThis is done by communicating with each neighbor.\nThe crucial part is to decide when to stop.\nAt some point, procedure ${\\textup{\\texttt{ComputeView}}}$ detects that the currently possessed truncated colored view $(\\view[l],f)$ covers the network and this view is then returned.\nThe above is achieved (see Lemma~\\ref{lem:covered} below for a proof) by maintaining a set $M$, that is initially empty, consisting of nodes having high copies.\nProcedure ${\\textup{\\texttt{ComputeView}}}$ stops when each leaf of $\\view[l]$ is in $M$, which guarantees that $\\view[l]$ covers the network, as required.\n\\begin{algorithm} \\caption{${\\textup{\\texttt{ComputeView}}}$}\n\\begin{algorithmic}\n\\REQUIRE None.\n\\ENSURE Truncated colored view $(\\view[l],f)$.\n\n\\STATE $l \\leftarrow 1$\n\\STATE $M \\leftarrow \\emptyset$\n\\WHILE{there exists a leaf in $\\view[l]$ that is not in $M$}\n   \\FORALL{$v$ in $\\view[l]$}\n      \\IF{${\\textup{\\texttt{TestRepetition}}}( \\view[l],v )$ returns ${\\texttt{true}}$}\n         \\STATE Add to $M$ the node $v$ and all its descendants in $\\view[l]$.\n      \\ENDIF\n   \\ENDFOR\n   \\STATE ${\\texttt{communicate}}$~$\\quad$ \\COMMENT{This extends $(\\view[l],f)$ to $(\\view[l+1],f)$.}\n   \\STATE $l \\leftarrow l+1$\n\\ENDWHILE\n\\RETURN $(\\view[l],f)$\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{lemma} \\label{lem:covered}\nProcedure ${\\textup{\\texttt{ComputeView}}}$ returns the truncated colored view $(\\view[l],f)$ of the executing node, such that $\\view[l]$ covers the network and $l\\leq 2(k+1)({D}+1)+{D}$.\n\\end{lemma}\n\\begin{proof}\nLemma~\\ref{lem:test:finite} implies that there exists $l\\leq 2(k+1)({D}+1)+{D}$ such that all leaves of $\\view[l]$ are in $M$ and hence the number of iterations of the `while' loop of procedure ${\\textup{\\texttt{TestRepetition}}}$ is at most $l$.\nThe latter relies on the fact that if a node having a high copy is detected by procedure ${\\textup{\\texttt{TestRepetition}}}$, then procedure ${\\textup{\\texttt{ComputeView}}}$ adds to $M$ this node with all its descendants in the current truncated view.\n\nConsider the view $\\view$ of the executing node, and let $u$ be any node in $\\view$.\nWe argue that $u$ has a copy in $\\view[l]$.\nSuppose for a contradiction that this is not the case and select $u$ to be a node that does not have a copy in $\\view[l]$ and is closest to the root in $\\view$.\nLet $l'$ be the level of $u$ in $\\view$.\n(Clearly $l'>l$.)\nSince ${\\textup{lev}_{{l}}({\\view[l]})}\\subseteq M$, there exists an ancestor $v$ of $u$ such that $v\\in{\\textup{lev}_{{i}}({\\view[l]})}$, $i\\leq l$, and procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$ when executed for $\\view[l],f$ and $v$.\nBy Corollary~\\ref{cor:test:bound}, $v$ has a copy $v'$ in $\\view[i-1]$.\nThus, $u$ has a copy $u'$ in $\\view[l'-1]$.\nBut then, by the minimality of $l'$, $u'$ has a copy in $\\view[l]$, which is also a copy of $u$.\nThis is a contradiction because, by definition, $u$ and $u'$ represent the same node of the network.\n\\end{proof}\n\n\n\n\\medskip\nProcedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ computes the colored quotient graph $({\\mathcal{Q}},g)$ of the network, provided that a colored view $(\\view[l],f)$ that covers the network is given as an input.\nThis is done by finding the minimum index $i$ such that ${\\Pi_{{i-1}}}={\\Pi_{{i}}}$.\nNote that this requires that each node learn its colored view till depth $l+i$, by exchanging messages with its neighbors.\n\\begin{algorithm} \\caption{${\\textup{\\texttt{ComputeQuotientGraph}}}( \\view[l],f )$}\n\\label{alg:ComputeQuotientGraph}\n\\begin{algorithmic}\n\\REQUIRE Truncated colored view $(\\view[l],f)$, $l\\geq 1$.\n\\ENSURE  The colored quotient graph $({\\mathcal{Q}},g)$.\n\n\\STATE ${\\Pi_{{-1}}} \\leftarrow \\emptyset$\n\\STATE ${\\Pi_{{0}}} \\leftarrow \\{ (\\view[0](v),f) {\\hspace{0.1cm}\\bigl|\\bigr.\\hspace{0.1cm}} v\\in\\view[l] \\}$\n\\STATE $i\\leftarrow 0$\n\\WHILE{${\\Pi_{{i}}}\\neq{\\Pi_{{i-1}}}$}\n   \\STATE $i \\leftarrow i+1$\n   \\STATE ${\\texttt{communicate}}$\n   \\STATE Compute ${\\Pi_{{i}}}$\n\\ENDWHILE\n\\STATE Compute the labeled quotient graph $({\\mathcal{Q}},g)$ using ${\\Pi_{{i}}}$ and $\\view[l+i]$\n\\RETURN $({\\mathcal{Q}},g)$\n\\end{algorithmic}\n\\end{algorithm}\n\nWe prove the following.\n\\begin{lemma} \\label{lem:computeQG}\nLet $(\\view[l],f)$ be the truncated colored view  computed by procedure ${\\textup{\\texttt{ComputeView}}}$.\\\\\nProcedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ called for $(\\view[l],f)$ correctly computes the colored quotient graph of the network.\n\\end{lemma}\n\\begin{proof}\nBy Lemma~\\ref{lem:covered}, $\\view[l]$ covers the network.\nThus, ${\\Pi_{{0}}}$ contains all nodes of the network.\nBy Proposition~\\ref{stop}, the partition ${\\Pi_{{i}}}$ obtained in the last iteration of the `while' loop of procedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ equals ${\\Pi_{{}}}$.\nHence, this partition ${\\Pi_{{i}}}$ is the set of all nodes of the colored quotient graph.\nThis implies that the quotient graph can be computed on the basis of ${\\Pi_{{i}}}$ and $\\view[l]$ as follows.\nThe color of a node of the quotient graph is set to the color of its elements in the truncated colored view.\nThe edges and port numbers are added as in the definition of the quotient graph.\n\\end{proof}\n\n\nIn the formulation of our main algorithm we will use the following integer that each node can compute once it has the colored quotient graph $({\\mathcal{Q}},g)$.\nFor any node $u$ of the quotient graph, let ${\\xi_{{u}}}$ be the sum of running times of procedures ${\\textup{\\texttt{ComputeView}}}$ and ${\\textup{\\texttt{ComputeQuotientGraph}}}(\\view[l],f)$, where $(\\view[l],f)$ is computed by ${\\textup{\\texttt{ComputeView}}}$.\nLet ${\\Xi}$ be the maximum of ${\\xi_{{u}}}$ over all nodes $u$ of the quotient graph.\n\nWe are ready to state our main algorithm for solving the problems ${\\textup{LE}}$ and ${\\textup{TOP}}$.\nWe formulate it as a single procedure, since all steps leading to the computation of the colored quotient graph are identical in both cases.\n\n\\floatname{algorithm}{Algorithm}\n\\begin{algorithm} \\caption{${\\textup{\\texttt{Solve-LE-and-TOP}}}(k,{\\alpha})$}\n\\begin{algorithmic}\n\\REQUIRE An upper bound $k$ on the size of color ${\\alpha}$.\n\\ENSURE  For ${\\textup{LE}}$ --- a sequence of port numbers leading from the executing node to the leader, or ${\\texttt{{unsolvable}}}$, if leader election is impossible.\n         For ${\\textup{TOP}}$ --- the topology of the network, or ${\\texttt{{unsolvable}}}$, if topology recognition is impossible.\n\n\\STATE $(\\view[l],f) \\leftarrow {\\textup{\\texttt{ComputeView}}}$\n\\STATE $({\\mathcal{Q}},g) \\leftarrow {\\textup{\\texttt{ComputeQuotientGraph}}}( \\view[l],f )$\n\\STATE Perform ${\\texttt{communicate}}$ ${\\Xi}$ times.\n\\IF{the number of nodes with color ${\\alpha}$ in $({\\mathcal{Q}},g)$ is at most $\\lfloor k/2\\rfloor$ and ${\\mathcal{Q}}$ is not a tree}\n   \\RETURN ${\\texttt{{unsolvable}}}$\n\\ELSE\n   \\STATE For ${\\textup{LE}}$ --- return a sequence of port numbers of the path $\\viewPath{\\view[l]}{v}$, where $v$ (which is the leader) corresponds to the node of $({\\mathcal{Q}},g)$ whose colored view is lexicographically smallest (if the executing node is the leader, then the path is empty).\n   \\STATE For ${\\textup{TOP}}$ --- return $({\\mathcal{Q}},g)$.\n\\ENDIF\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{theorem} \\label{thm:main}\nIf a bound $k$ on the size of a given color ${\\alpha}$ is provided as an input, then Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly solves problems ${\\textup{LE}}$ and ${\\textup{TOP}}$ in time $O(k{D}+{D}\\log(n/{D}))$, where $n$ is the size of the network and $D$ is its diameter.\n\\end{theorem}\n\\begin{proof}\nFirst note that Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly computes the colored quotient graph.\nIndeed, by Lemma~\\ref{lem:computeQG}, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ obtains the colored quotient graph $({\\mathcal{Q}},g)$ as a result of the call to procedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$.\nThis is ensured by the fact that each node performs at least ${\\Xi}$ calls to ${\\texttt{communicate}}$ and therefore every node $u$ can compute $\\view[{\\xi_{{u}}}]$, which is enough to compute the colored quotient graph, by definition of ${\\xi_{{u}}}$.\n\nOnce the colored quotient graph is computed by all nodes of the network, the correctness of Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ essentially follows from \\cite{YK3}.\nFor completeness we include the short argument.\n\nAssume that the colored quotient graph has at most $\\lfloor k/2\\rfloor$ nodes with color ${\\alpha}$ and it is not a tree (i.e., a graph {that has} cycles, multiple edges or self-loops).\nThen, topology recognition cannot be solved since there exist two non-isomorphic networks of size $2\\lfloor k/2\\rfloor$ having $({\\mathcal{Q}},g)$ as a quotient graph.\nAny potential topology recognition algorithm in these networks must have the same execution for each pair of nodes with the same colored views and thus such an algorithm must be incorrect.\nHence, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly returns ${\\texttt{{unsolvable}}}$ for the problem ${\\textup{TOP}}$.\nFor the problem of leader election, take any network of size $2\\lfloor k/2\\rfloor$ having $({\\mathcal{Q}},g)$ as a quotient graph.\nTwo distinct nodes $u$ and $v$ in this network have the same colored view.\nThus, any potential leader election algorithm incorrectly elects at least two leaders in this network.\nHence, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly returns ${\\texttt{{unsolvable}}}$ for the problem ${\\textup{LE}}$ as well.\n\n\nOtherwise, i.e., if the colored quotient graph has more than $\\lfloor k/2\\rfloor$ nodes with color ${\\alpha}$ or it is a tree, then the network is isomorphic to $({\\mathcal{Q}},g)$ and hence Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ gives a correct solution to the problem ${\\textup{TOP}}$.\nAs for leader election, each node has a unique colored view under this assumption.\nHence, the node with the lexicographically smallest colored view is unambiguously elected as the leader by each node.\n\nIt remains to bound the time of computation.\nIt is at most $l+i+{\\Xi}$, where $l$ and $i$ are the numbers of iterations of the `while' loop of procedure ${\\textup{\\texttt{ComputeView}}}$ and ${\\textup{\\texttt{ComputeQuotientGraph}}}$, respectively.\nBy Lemma~\\ref{lem:test:finite} and the formulation of procedure ${\\textup{\\texttt{ComputeView}}}$, $l\\in O(k{D})$.\nBy Proposition~\\ref{trunc}, $i\\in O({D}\\log(n/{D}))$.\nThus, by definition, ${\\Xi}\\in O(k{D}+{D}\\log(n/{D}))$, which completes the proof.\n\\end{proof}\n\n\n\\begin{corollary} \\label{cor:main}\nLet $(G,f)$ be a colored network and let $k$ be a bound on the size of color ${\\alpha}$.\nIf all nodes of $(G,f)$ have pairwise different colored views and the size of color ${\\alpha}$ is strictly greater than $\\lfloor k/2\\rfloor$, then topology recognition and leader election are possible in $G$.\n{\\hfill $\\square$ \\smallbreak}\n\\end{corollary}\n\n\n\\section{Negative results}\n\nIn this section we present our negative results. The first of them {is an impossibility result indicating} that if no upper bound on the size of any color is given to nodes, then problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ must have answer ``unsolvable'', even if other restrictions on the possible sizes of colors are known. In order to express this result in full generality, we formalize such possible restrictions as a set $R\\subseteq {\\mathbb{N}}^r$, where ${\\mathbb{N}}$ denotes the set of positive integers and $r$ is the number of colors.\nWe translate the property that no upper bound on the size of any color is known, to the statement\nthat for any point $(x_1,x_2,\\dots , x_r)\\in {\\mathbb{N}}^r $ there exists a point $(y_1,y_2,\\dots , y_r)$  in the restriction set $R$, such that $y_i \\geq x_i$, for all $i \\leq r$.\nSuch a set $R$ will be called \\emph{unbounded}.\n(An example of an input defining an unbounded restriction set is: there are three colors and the sizes of all of them are prime integers.)\nTo make the impossibility result even stronger, we prove that it holds even for a very simple class of networks: on rings. \n\n\\begin{proposition}\nLet $(C,g)$ be any colored ring.\nConsider an input $I$ defining an unbounded restriction set $R$.\nThen, problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ must have answer ``unsolvable''.\n\\end{proposition}\n\\begin{proof}\nTake any algorithm, call it $A$, that correctly solves problem ${\\textup{TOP}}$ or problem ${\\textup{LE}}$ in any colored ring under input $I$.\nLet $r$ be the number of different colors that appear in the network, and let $x_i$ be the size of color $i$, $i\\in\\{1,\\ldots,r\\}$.\nDenote the nodes of $C$ by $v_0,\\ldots,v_{n-1}$, where $n=x_1+\\cdots+x_r$ and $v_i$ is adjacent to $v_{(i+1){\\,\\textup{mod}\\,} n}$, for each $i\\in\\{0,\\ldots,n-1\\}$.\n\\begin{figure}[htb]\n\\begin{center}\n\\includegraphics[scale=0.9]{fig-ring.pdf}\n\\caption{(a) an example of a ring $(C,g)$ obtained from $(x_1,x_2,x_3)=(1,2,3)$, $n=6$; (b) the corresponding ring $(C',g')$ constructed for $T\\in\\{7,\\ldots,12\\}$ and $(x_1',x_2',x_3')=(5,11,18)$, $n'=34$.}\n\\label{fig:ring}\n\\end{center}\n\\end{figure}\n\nLet $v_0$ be any node of $C$.\nLet $T$ be the time after which $A$ produces the answer.\nSince the restriction set $R$ is unbounded, there exists $(x_1',\\ldots,x_r')\\in R$ such that $x_i'\\geq 2x_i\\lceil T/n\\rceil+x_i$ for each $i\\in\\{1,\\ldots,r\\}$.\nWe construct a colored ring $(C',g')$ on $n'=x_1'+\\cdots+x_r'$ nodes $v_0',\\ldots,v_{n'-1}'$ such that:\n\\begin{itemize}\n \\item $v_i'$ is adjacent to $v_{(i+1){\\,\\textup{mod}\\,} n'}'$, $i\\in\\{0,\\ldots,n'-1\\}$,\n \\item the port numbers of the edge $\\{v_i',v_{i+1}'\\}$ at $v_i'$ and $v_{i+1}'$ are equal to the port numbers of the edge $\\{v_{i{\\,\\textup{mod}\\,} n},v_{(i+1){\\,\\textup{mod}\\,} n}\\}$ at $v_{i{\\,\\textup{mod}\\,} n}$ and $v_{(i+1){\\,\\textup{mod}\\,} n}$, respectively, $i\\in\\{0,\\ldots,2n\\lceil T/n\\rceil+n-1\\}$, in $C$,\n \\item the port numbers of the remaining edges are set arbitrarily in a way that guarantees proper port labeling.\n\\end{itemize}\nMoreover, the colors are assigned to the nodes of $C'$ as follows:\n", "itemtype": "equation", "pos": 29919, "prevtext": "\nThus, $u'$ belongs to $\\view[2(k+1)(d'+1)-1]$, or in other words, the node $u$ that belongs to level $2(k+1)(d'+1)$ of $\\view[l]$ has a high copy in $\\view[2(k+1)(d'+1)-1]$.\nSince either $u=v$ or $u$ is an ancestor of $v$, we obtain that $v$ has a high copy in $\\view[l]$, as required.\n\\end{proof}\n\n\\begin{corollary} \\label{cor:test:bound}\nConsider a truncated colored view $(\\view[l],f)$ and a node $v$ in this view.\nIf procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$ for input $\\view[l],f$ and $v$, then $v$ has a high copy in $\\view[l]$.\n{\\hfill $\\square$ \\smallbreak}\n\\end{corollary}\n\nWe have proved that if procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$, then this guarantees that the input node $v$ has a high copy.\nHowever, for the correctness of our final algorithm we need to ensure that each infinite simple path in $\\view$ originating from the root contains a node $v$ that has a high copy, and that this fact will be detected by procedure ${\\textup{\\texttt{TestRepetition}}}$.\nMoreover, in order to bound the time of our final algorithm, we need to estimate the distance from such $v$ to the root, which is done in the next lemma.\n\\begin{lemma} \\label{lem:test:finite}\nLet $(\\view[l],f)$ be a truncated colored view and let $v$ be a node in it.\nIf $l=2(k+1)({D}+1)+{D}$ and $v$ belongs to level $2(k+1)({D}+1)$ of $\\view[l]$, then procedure ${\\textup{\\texttt{TestRepetition}}}$ executed for $\\view[l],f$ and $v$ returns ${\\texttt{true}}$.\n\\end{lemma}\n\\begin{proof}\nFor each node $u$ of the path $\\viewPath{\\view[l]}{v}$, the node of the network represented by it is at distance at most ${D}$ (in the network) from some node with color ${\\alpha}$.\nThis implies that $d_u\\leq{D}$ for each such node $u$.\nThus, $d'\\leq{D}$.\nWe obtain that\n", "index": 7, "text": "\n\\[{|{\\viewPath{\\view[l]}{v}}|} = 2(k+1)({D}+1) \\geq 2(k+1)(d'+1),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"{|{\\viewPath{\\view[l]}{v}}|}=2(k+1)({D}+1)\\geq 2(k+1)(d^{\\prime}+1),\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\viewPath</mtext></merror><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\view</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>l</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi>v</mi></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>D</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2265</mo><mrow><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>d</mi><mo>\u2032</mo></msup><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07790.tex", "nexttext": "\nand the remaining nodes, i.e., the ones in $X=\\{v_{2n \\lceil T/n\\rceil+n}',\\ldots,v_{n'}'\\}$, receive colors in any way that ensures that the size of color $j\\in\\{1,\\ldots,r\\}$ in $C'$ is $x_j'$.\nSee Figure~\\ref{fig:ring} for an example of the construction of $(C',g')$.\nThe colored view of depth $T$ of $v_0$ in $(C,g)$ is the same as the colored views of depth $T$ of $v_{n \\lceil T/n\\rceil}'$ and of $v_{n \\lceil T/n\\rceil+n}'$ in $(C',g')$ because $T\\leq n \\lceil T/n\\rceil$.\n\nConsider the problem ${\\textup{TOP}}$.\nIf the answer produced by $A$ in $(C,g)$ is ``unsolvable'', then the lemma follows.\nHence, we may assume that $A$ returns the topology of $(C,g)$.\nBy Proposition \\ref{prop:algoView}, the algorithm $A$ executed by $v_{n \\lceil T/n\\rceil}'$ in $(C',g')$ stops after time $T$ and produces the same answer as for $v_0$ in $(C,g)$.\nThus, $A$ must also return the topology of $(C,g)$ when executed by $v_{n\\lceil T/n\\rceil}'$ in $(C',g')$.\nSince $C$ and $C'$ are of different sizes, we obtain a contradiction, as required.\n\nNext consider the problem ${\\textup{LE}}$.\nIf the answer produced by $A$ in $(C,g)$ is ``unsolvable'', then the lemma follows.\nHence, we may assume that $A$ elects a leader in $(C,g)$.\nBy Proposition \\ref{prop:algoView}, the algorithm $A$ executed by $v_{n \\lceil T/n\\rceil}'$ and $v_{n \\lceil T/n\\rceil+n}'$ in $(C',g')$ stops after time $T$ and produces the same answer as in $(C,g)$.\nThus, these two nodes elect different leaders --- a contradiction.\n\\end{proof}\n\n\nWe next turn attention to the issue of time needed to solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, assuming that an upper bound $k$ on the size of some color is given to all nodes.  We give a lower bound showing that the time\n$O(kD+D\\log(n/D))$ of our algorithm is optimal.\nWe first construct a class of networks, for which\ntime $\\Theta(kD)$ cannot be improved.\n\n \n\\begin{proposition}\\label{first-lb}\nLet $k,D \\leq n$ be arbitrary positive integers.\nThere exists a network of size $\\Theta(n)$ and diameter $\\Theta(D)$, whose nodes, if they are given as input an upper bound $k$ on the size of one color ${\\alpha}$ and have no other information on the network, need time  $\\Omega(kD)$ to solve the problems ${\\textup{TOP}}$ and ${\\textup{LE}}$.\n\\end{proposition}\n\\begin{proof}\nFor any $n'$ and $d<n'/2$, we define a $n'$-node graph $G(n',d)$ (called a chordal ring).\nDenote by $v_{0},\\ldots,v_{n'-1}$ the nodes of $G(n',d)$.\nFor each $i\\in\\{0,\\ldots,n'-1\\}$ and $j\\in\\{1,\\ldots,d\\}$, let $\\{v_{i},v_{i+j}\\}$ be an edge of $G(n',d)$, where the port number of this edge at $v_i$ is $j-1$ and the port number at $v_{i+j}$ is $d+j-1$.\nNote that the diameter of $G(n',d)$ is $\\Theta(n'/d)$.\n\nSince our result {holds asymptotically}, we may assume that $D\\geq 3$ and $k\\geq 12$.\nConsider an algorithm $A$ for solving problem ${\\textup{TOP}}$ or ${\\textup{LE}}$ in any network.\nLet $d=\\lfloor n/D\\rfloor$.\n(Note that $D\\geq 3$ implies $d<n/2$, as required in the construction of $G(n,d)$.)\nLet $u$ be any node of $G(n,d)$.\nLet $(G(n,d),g)$ be the colored network in which $g(u)={\\alpha}$, and all other nodes of $G(n,d)$ have the same color ${\\alpha}'$, different from ${\\alpha}$.\nNote that the diameter of $G(n,d)$ is $\\Theta(D)$.\nWe run the algorithm $A$ in the colored network $(G(n,d),g)$.\nWe argue that $A$ should run for time $\\Omega(kD)$.\nSuppose for a contradiction that $A$ stops and produces an answer in round $T<\\lfloor k/3\\rfloor D$.\n\nConsider the network $G(kn,d)$ on the set of nodes $\\{v_0',\\ldots,v_{kn-1}'\\}$.\nConstruct a network $G'$ by adding a pendant edge to the node $v_0'$ of $G(kn,d)$, i.e., add an extra node of degree $1$ and attach it to $v_0'$.\nLet $u'=v_{\\lfloor k/2\\rfloor n}'$.\nLet $(G',g')$ be a colored network in which $g'(v_{nj}')={\\alpha}$ for each $j\\in\\{0,\\ldots,k-1\\}$, while all other nodes of this network have color ${\\alpha}'$.\nBy construction of $G'$, the distance between $u'$ and $v_0'$ in $G'$ is greater than $T$.\nThus, the truncated colored view $\\view[T](u')$ in $(G',g')$ is the same as the truncated colored view $\\view[T](u)$ in $(G(n,d),g)$.\nNow, we run $A$ in the colored network $(G',g')$.\n\nSuppose that $A$ is an algorithm solving the problem ${\\textup{TOP}}$.\nBy Proposition \\ref{prop:algoView}, $A$ executed on $u$ and $u'$ produces the same answer to problem ${\\textup{TOP}}$ in $G(n,d)$ and $G'$, respectively.\nIf the answer on $u$ is the topology of $G(n,d)$, then we immediately have a contradiction since the two networks are not isomorphic.\nOn the other hand, if the answer is ``unsolvable'', then this answer is incorrect for $G'$.\nThe latter is due to Corollary \\ref{cor:main}.\n\nLet now $A$ be an algorithm solving the problem ${\\textup{LE}}$.\nLet $v'=v_{\\lfloor kn/2\\rfloor+n}'$.\nThe distance from $v'$ to $v_0'$ in $G'$ is at least $(\\lfloor k/2\\rfloor-1)\\lfloor n/d\\rfloor\\geq \\lfloor n/d\\rfloor\\cdot k/3\\geq Dk/3\\geq T$ for $k\\geq 12$.\nThus, $\\view[T](u')=\\view[T](v')$.\nBy Proposition \\ref{prop:algoView}, $A$ produces the same output at $u'$ and $v'$ after time $T$.\nBy Corollary \\ref{cor:main}, the algorithm $A$ cannot output ``unsolvable'' because all nodes of $G'$ have unique views and the size of color ${\\alpha}$ is $k$ in $(G',g')$.\nThus, $u'$ and $v'$ elect different leaders --- a contradiction.\n\\end{proof}\n\nThe other part of our lower bound follows from \\cite{DKP}.\n\\begin{proposition}\\label{second-lb}\nLet $D \\leq n$ be arbitrary positive integers. There exists a network of size $\\Theta(n)$\n and diameter $\\Theta(D)$, whose nodes need time at least $\\Omega(D\\log(n/D))$ to solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, even if all nodes have the same color and they are given the size and the diameter of the \n network.\n\\end{proposition}\n\\begin{proof}\nBy Proposition \\ref{trunc-lower}, there exists a network $G$ of size $\\Theta(n)$ and diameter $\\Theta(D)$, with nodes $u$ and $v$, both with unique views,\nsuch that ${\\cal V}(u)\\neq {\\cal V}(v)$ but ${\\cal V}^{h'}(u)={\\cal V}^{h'}(v)$, for some $h' \\in \\Theta(D \\log (n/D))$.\nThus, by Proposition \\ref{prop:algoView}, any algorithm $A$ that stops after at most $h'$ steps and produces an answer to problem ${\\textup{LE}}$, gives the same answer at $u$ and $v$.\nThus, this answer must be ``unsolvable''.\n(Otherwise, two distinct leaders would be elected.)\nHowever, since the nodes of $G$ have pairwise different views and the size of the network is known, Corollary~\\ref{cor:main} implies that leader election is possible in this network.\nThus, any algorithm solving problem ${\\textup{LE}}$ needs time $\\Omega(D\\log(n/D))$ in $G$.\n\n\nNow consider the problem ${\\textup{TOP}}$ and let $A$ be any algorithm solving this problem.\nSuppose for a contradiction that $A$ stops after at most $h'$ steps. \nBy Proposition~\\ref{trunc-lower}, there exists a network $G'$, different than $G$, with the same size and diameter as $G$, with a node $u'$, such that $\\view[h'](u')=\\view[h'](u)$.\nThus, by Proposition~\\ref{prop:algoView}, $A$ returns the same answer at $u$ and $u'$.\nSince $G$ and $G'$ are different, this answer must be ``unsolvable''.\nSince all nodes in $G$ have pairwise different views, by Proposition~\\ref{prop:algoView} (where $k$ is {taken} to be the size of $G$), ${\\textup{TOP}}$ is possible in $G$ --- a contradiction.\n\\end{proof}\n\nTheorem \\ref{thm:main}, together with Propositions \\ref{first-lb} and \\ref{second-lb}, imply the following corollary showing that our algorithm is time-optimal.\n\n\\begin{corollary}\nThe optimal time to solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ on $n$-node networks with diameter $D$,\nassuming that nodes know only an upper bound $k$ on the size of a given color, is $\\Theta(kD+D\\log(n/D))$.  \n\\end{corollary} \n\n\\section{Conclusion}\n\nWe showed that nodes of a colored network can solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$, if they are given an upper bound on the number of nodes of a given color, and we studied the time\nof solving these problems in the $\\cal{LOCAL}$  model, under this assumption. \n\nNotice that the synchronous behavior of the $\\cal{LOCAL}$  model can be easily reproduced in an asynchronous network, by defining, for each node $u$ separately, an asynchronous round $i$ consisting of the following actions of this node: node $u$ performs local computations, then sends messages stamped with integer $i$ to all its neighbors, and waits for messages stamped $i$ from all neighbors.\nIn order to implement this, every node must send a message with all consecutive stamps, until termination, some of the messages possibly empty.\nOur results concerning time of solving problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ can be translated for asynchronous networks by replacing ``the number of rounds''  by ``the maximum number of asynchronous rounds, over all nodes''.\n\nLet $D$ be the diameter of the network.\nIf nodes have distinct labels, then time $D+1$ in the $\\cal{LOCAL}$  model is enough to solve any problem solvable on a given network, as after this time all nodes solve topology recognition.\nBy contrast, in our scenario of colored nodes, time $D+1$ is often not enough, for example to elect a leader, or to perform topology recognition, even if these tasks are feasible.\nThis is due to the fact that after time $t\\leq D+1$ each node may learn only all colored paths of length $t$ originating at it.\nAcquiring this information does not imply getting a picture of the radius $t$ colored neighborhood of the node.\nThis is because a node $v$ may not know if two paths originating at it have the same other endpoint or not.\nWe showed that these ambiguities may force time much larger than $D$ to solve problems ${\\textup{TOP}}$ and ${\\textup{LE}}$.\n\nAs it is always assumed in the $\\cal{LOCAL}$ model, we allowed arbitrarily large messages to be sent in each round. Bounding the size of messages to logarithmic in the size of the network, as\nit is assumed in the alternative $\\cal{CONGEST}$ model, would likely have an important impact on the time of solving problems ${\\textup{TOP}}$ and ${\\textup{LE}}$. Hence an interesting open question is\nto establish the best time of solving these problems in the latter model.\n\n\n\n\\bibliographystyle{plain}\n\\begin{thebibliography}{99}\n\n\\bibitem{An}\nD.~Angluin, Local and Global Properties in Networks of Processors,\n{\\em Proc. 12th Annual ACM Symposium on Theory of Computing} (STOC 1980), 82--93.\n\n\\bibitem{ABDKPR}\nH. Attiya, A. Bar-Noy, D. Dolev, D. Koller, D. Peleg, R. Reischuk,\nRenaming in an Asynchronous Environment, {\\em Journal of the ACM} 37 (1990), 524--548.\n\n\\bibitem{ASW}\nH. Attiya, M. Snir, M. Warmuth,\nComputing on an Anonymous Ring,\n{\\em Journal of the ACM} 35 (1988), 845-875.\n\n\\bibitem{AtSn}\nH. Attiya, M. Snir,\nBetter Computing on the Anonymous Ring,\n{\\em Journal of Algorithms} 12 (1991), 204-238.\n\n\\bibitem{A}\nB. Awerbuch, Optimal Distributed Algorithms for Minimum Weight Spanning Tree, \nCounting, Leader Election and Related Problems,\n{\\em Proc. 19th Annual ACM Symposium on Theory of Computing} (STOC 1987), 230-240.\n\n\\bibitem{AGPV}\nB. Awerbuch, O. Goldreich, D. Peleg, R. Vainish,\nA Trade-Off between Information and Communication in Broadcast Protocols,\n{\\em J. {ACM}} 37 (1990), 238-256.\n\n\\bibitem{BSVCGS}\nP. Boldi, S. Shammah, S. Vigna, B. Codenotti, P. Gemmell, J. Simon,\nSymmetry Breaking in Anonymous Networks: Characterizations,\n{\\em Proc. 4th Israel Symposium on Theory of Computing and Systems} (ISTCS 1996), 16-26.\n\n\\bibitem{BV}\nP. Boldi, S. Vigna,\nComputing Anonymously with Arbitrary Knowledge,\n{\\em Proc. 18th ACM Symp. on Principles of Distributed Computing} (PODC 1999), 181-188.\n\n\\bibitem{B}\nJ.E. Burns, A Formal Model for Message Passing Systems,\n{\\em Tech. Report TR-91}, Computer Science Department,\nIndiana University, Bloomington, September 1980.\n\n\\bibitem{C}\nJ. Chalopin,\nLocal Computations on Closed Unlabelled Edges: The Election Problem and the Naming Problem,\n{\\em Proc. 31st Conference on Current Trends in Theory and Practice of Computer Science} (SOFSEM 2005), 82-91.\n\n\\bibitem{CDK}\nJ. Chalopin, S. Das, A. Kosowski, \nConstructing a Map of an Anonymous Graph: Applications of Universal Sequences,\n{\\em Proc. 14th International Conference on Principles of Distributed Systems} (OPODIS 2010), 119-134.\n\n\\bibitem{CMM}\nJ. Chalopin, A.W. Mazurkiewicz, Y. M\\'etivier, Labelled (Hyper)Graphs, Negotiations and the Naming Problem,\n{\\em Proc. 4th International Conference on Graph Transformations} (ICGT 2008), 54-68.\n\n\\bibitem{CM}\nJ. Chalopin, Y. M\\'etivier,\nElection and Local Computations on Edges,\n{\\em Proc. Foundations of Software Science and Computation Structures} (FoSSaCS 2004), 90-104.\n\n\\bibitem{DKP}\nD. Dereniowski, A. Kosowski, D. Pajak, Distinguishing Views in Symmetric Networks: A Tight Lower Bound,\n{\\em Theoretical Computer Science} 582 (2015) 27-34.\n\n\\bibitem{DP}\nD. Dereniowski, A. Pelc, Drawing Maps with Advice,  {\\em Journal of Parallel and Distributed Computing} 72 (2012), 132-143. \n\n\\bibitem{DP1}\nD. Dereniowski, A. Pelc, Leader Election for Anonymous Asynchronous Agents in Arbitrary Networks, {\\em Distributed Computing} 27 (2014), 21-38. \n\n\\bibitem{DKMP}\nK. Diks, E. Kranakis A. Malinowski, A. Pelc,\nAnonymous Wireless Rings,\n{\\em Theoretical Computer Science} 145 (1995), 95-109.\n\n\\bibitem{DoPe}\nS. Dobrev, A. Pelc, \nLeader Election in Rings with Nonunique Labels, {\\em Fundamenta Informaticae} 59 (2004), 333-347. \n\n\\bibitem{FKKLS}\nP. Flocchini, E. Kranakis, D. Krizanc, F.L. Luccio, N. Santoro,\nSorting and Election in Anonymous Asynchronous Rings,\n{\\em Journal of Parallel and Distributed Computing} 64 (2004), 254-265.\n\n\\bibitem{FL}\nG.N. Fredrickson, N.A. Lynch,\nElecting a Leader in a Synchronous Ring,\n{\\em Journal of the ACM} 34 (1987), 98-115.\n\n\\bibitem{FP}\nE. Fusco, A. Pelc, How Much Memory is Needed for Leader Election, {\\em Distributed Computing} 24 (2011), 65-78. \n\n\\bibitem{FP1}\nE. Fusco, A. Pelc, Knowledge, Level of Symmetry, and Time of Leader Election,\n{\\em Proc. 20th Annual European Symposium on Algorithms} (ESA 2012), LNCS 7501, 479-490. \n\n\\bibitem{FPR}\nE. Fusco, A. Pelc, R. Petreschi, Use Knowledge to Learn Faster: Topology Recognition with Advice,\n{\\em Proc. 27th International Symposium on Distributed Computing} (DISC 2013), LNCS 8205, 31-45. \n\n\\bibitem{GMP}\nC. Glacet, A. Miller, A. Pelc, Time vs. information tradeoffs for leader election in anonymous trees, Proc. 27th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2016), 600-609.\n\n\n\n\n\\bibitem{HKMMJ}\nM.A. Haddar, A.H. Kacem, Y. M\\'{e}tivier, M. Mosbah, M. Jmaiel, Electing a Leader in the Local Computation Model using Mobile Agents,\n{\\em Proc.  6th ACS/IEEE International Conference on Computer Systems and Applications} (AICCSA 2008), 473-480.\n\n\\bibitem{H}\nJ. Hendrickx, Views in a Graph: To Which Depth Must Equality Be Checked?,\n{\\em IEEE Transactions on Parallel and Distributed Systems} 25 (2014) 1907-1912.\n\n\n\\bibitem{HS}\nD.S. Hirschberg, J.B. Sinclair,\nDecentralized Extrema-Finding in Circular Configurations of Processes,\n{\\em Communications of the ACM} 23 (1980), 627-628.\n\n\\bibitem{JKZ}\nT. Jurdzinski, M. Kutylowski, J. Zatopianski, \nEfficient Algorithms for Leader Election in~Radio Networks,\n {\\em Proc., 21st ACM Symp. on Principles of Distributed Computing} (PODC 2002), 51-57.\n\n\\bibitem{KP}\nD. Kowalski, A. Pelc, Leader Election in Ad Hoc Radio Networks: A Keen Ear Helps, \n{\\em Proc. 36th International Colloquium on Automata, Languages and Programming} (ICALP 2009), LNCS 5556, 521-533. \n\n\n\\bibitem{Kr}\nE. Kranakis,\nSymmetry and Computability in Anonymous Networks: A Brief Survey,\n{\\em Proc. 3rd Int. Conf. on Structural Information and Communication Complexity}, (1997), 1-16.\n\n\\bibitem{KKV}\nE. Kranakis, D. Krizanc, J. van der Berg,\nComputing Boolean Functions on Anonymous Networks,\n{\\em Information and Computation} 114 (1994), 214-236.\n\n\\bibitem{LL}\nG. Le Lann,\nDistributed Systems - Towards a Formal Approach,\n{\\em Proc. IFIP Congress}, North Holland, (1977), 155-160.\n\n\\bibitem{Ly}\nN.A. Lynch, \nDistributed Algorithms,\nMorgan Kaufmann Publ., Inc., 1996.\n\n\n\\bibitem{MP}\nA. Miller, A. Pelc: Election vs. selection: Two ways of finding the largest node in a graph,\nCoRR abs/1411.1319 (2014).\n\n\\bibitem{NO}\nK. Nakano, S. Olariu, Uniform Leader Election Protocols for Radio Networks,\n{\\em IEEE Transactions on Parallel and Distributed Systems} 13\n(2002), 516-526.\n\n\\bibitem{Norris}\nN. Norris, Universal Covers of Graphs: Isomorphism to Depth $N-1$ Implies Isomorphism to All Depths,\n{\\em Discrete Applied Mathematics} 56 (1995), 61-74.\n               \n\\bibitem{Pe}D. Peleg,\nDistributed Computing, A Locality-Sensitive Approach,\nSIAM Monographs on Discrete Mathematics and Applications, Philadelphia 2000.\n\n\\bibitem{P}\nG.L. Peterson, An $O(n \\log n)$ Unidirectional Distributed Algorithm for the Circular Extrema Problem,\n{\\em ACM Transactions on Programming Languages and Systems} 4 (1982), 758-762.\n\n\\bibitem{Saka}\nN. Sakamoto,\nComparison of Initial Conditions for Distributed Algorithms\non Anonymous  Networks,\n{\\em Proc. 18th ACM Symp. on Principles of Distributed Computing} (PODC 1999), 173-179.\n\n\\bibitem{Wil}\nD.E. Willard, \nLog-logarithmic Selection Resolution Protocols in a Multiple Access Channel,\n{\\em SIAM J. on Computing} 15 (1986), 468-477. \n\n\\bibitem{YK}\nM. Yamashita, T. Kameda,\nComputing on Anonymous Networks,\n{\\em Proc. 7th ACM Symp. on Principles of Distributed Computing} (PODC 1988), 117-130.\n\n\\bibitem{YK2}\nM. Yamashita, T. Kameda,\nElecting a Leader when Procesor Identity Numbers are not Distinct,\n{\\em Proc. 3rd Workshop on Distributed Algorithms} (WDAG 1989), LNCS 392, 303-314.\n\n\\bibitem{YK3}\nM. Yamashita and T. Kameda,\nComputing on Anonymous Networks: Part I - Characterizing the Solvable Cases,\n{\\em IEEE Trans. Parallel and Distributed Systems} 7 (1996), 69-89. \n\n\\end{thebibliography}\n\n\n", "itemtype": "equation", "pos": 45007, "prevtext": "\nwhich implies that procedure ${\\textup{\\texttt{TestRepetition}}}$ returns true.\n\\end{proof}\n\n\n\n\n\\medskip\nBefore describing the next procedure, we introduce some more notation.\nA truncated colored view $(\\view[l],f)$ \\emph{covers the network} if, for each node $x$ of the network, there exists a node $u$ of $\\view[l]$ such that $u$ represents $x$.\nWe define procedure ${\\texttt{communicate}}$ which sends the currently acquired truncated colored view $(\\view[t],f)$ to all neighbors and receives the messages containing currently acquired colored views of the same depth $t$ from all neighbors.\nNote that after all nodes have performed ${\\texttt{communicate}}$ $t$ times, each node can compute its truncated colored view $\\view[t]$.\n\nWe now describe procedure ${\\textup{\\texttt{ComputeView}}}$.\nAgain, we start with an informal description.\nIn each iteration, the `while' loop increments the depth of the view currently stored at the executing node.\nThis is done by communicating with each neighbor.\nThe crucial part is to decide when to stop.\nAt some point, procedure ${\\textup{\\texttt{ComputeView}}}$ detects that the currently possessed truncated colored view $(\\view[l],f)$ covers the network and this view is then returned.\nThe above is achieved (see Lemma~\\ref{lem:covered} below for a proof) by maintaining a set $M$, that is initially empty, consisting of nodes having high copies.\nProcedure ${\\textup{\\texttt{ComputeView}}}$ stops when each leaf of $\\view[l]$ is in $M$, which guarantees that $\\view[l]$ covers the network, as required.\n\\begin{algorithm} \\caption{${\\textup{\\texttt{ComputeView}}}$}\n\\begin{algorithmic}\n\\REQUIRE None.\n\\ENSURE Truncated colored view $(\\view[l],f)$.\n\n\\STATE $l \\leftarrow 1$\n\\STATE $M \\leftarrow \\emptyset$\n\\WHILE{there exists a leaf in $\\view[l]$ that is not in $M$}\n   \\FORALL{$v$ in $\\view[l]$}\n      \\IF{${\\textup{\\texttt{TestRepetition}}}( \\view[l],v )$ returns ${\\texttt{true}}$}\n         \\STATE Add to $M$ the node $v$ and all its descendants in $\\view[l]$.\n      \\ENDIF\n   \\ENDFOR\n   \\STATE ${\\texttt{communicate}}$~$\\quad$ \\COMMENT{This extends $(\\view[l],f)$ to $(\\view[l+1],f)$.}\n   \\STATE $l \\leftarrow l+1$\n\\ENDWHILE\n\\RETURN $(\\view[l],f)$\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{lemma} \\label{lem:covered}\nProcedure ${\\textup{\\texttt{ComputeView}}}$ returns the truncated colored view $(\\view[l],f)$ of the executing node, such that $\\view[l]$ covers the network and $l\\leq 2(k+1)({D}+1)+{D}$.\n\\end{lemma}\n\\begin{proof}\nLemma~\\ref{lem:test:finite} implies that there exists $l\\leq 2(k+1)({D}+1)+{D}$ such that all leaves of $\\view[l]$ are in $M$ and hence the number of iterations of the `while' loop of procedure ${\\textup{\\texttt{TestRepetition}}}$ is at most $l$.\nThe latter relies on the fact that if a node having a high copy is detected by procedure ${\\textup{\\texttt{TestRepetition}}}$, then procedure ${\\textup{\\texttt{ComputeView}}}$ adds to $M$ this node with all its descendants in the current truncated view.\n\nConsider the view $\\view$ of the executing node, and let $u$ be any node in $\\view$.\nWe argue that $u$ has a copy in $\\view[l]$.\nSuppose for a contradiction that this is not the case and select $u$ to be a node that does not have a copy in $\\view[l]$ and is closest to the root in $\\view$.\nLet $l'$ be the level of $u$ in $\\view$.\n(Clearly $l'>l$.)\nSince ${\\textup{lev}_{{l}}({\\view[l]})}\\subseteq M$, there exists an ancestor $v$ of $u$ such that $v\\in{\\textup{lev}_{{i}}({\\view[l]})}$, $i\\leq l$, and procedure ${\\textup{\\texttt{TestRepetition}}}$ returns ${\\texttt{true}}$ when executed for $\\view[l],f$ and $v$.\nBy Corollary~\\ref{cor:test:bound}, $v$ has a copy $v'$ in $\\view[i-1]$.\nThus, $u$ has a copy $u'$ in $\\view[l'-1]$.\nBut then, by the minimality of $l'$, $u'$ has a copy in $\\view[l]$, which is also a copy of $u$.\nThis is a contradiction because, by definition, $u$ and $u'$ represent the same node of the network.\n\\end{proof}\n\n\n\n\\medskip\nProcedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ computes the colored quotient graph $({\\mathcal{Q}},g)$ of the network, provided that a colored view $(\\view[l],f)$ that covers the network is given as an input.\nThis is done by finding the minimum index $i$ such that ${\\Pi_{{i-1}}}={\\Pi_{{i}}}$.\nNote that this requires that each node learn its colored view till depth $l+i$, by exchanging messages with its neighbors.\n\\begin{algorithm} \\caption{${\\textup{\\texttt{ComputeQuotientGraph}}}( \\view[l],f )$}\n\\label{alg:ComputeQuotientGraph}\n\\begin{algorithmic}\n\\REQUIRE Truncated colored view $(\\view[l],f)$, $l\\geq 1$.\n\\ENSURE  The colored quotient graph $({\\mathcal{Q}},g)$.\n\n\\STATE ${\\Pi_{{-1}}} \\leftarrow \\emptyset$\n\\STATE ${\\Pi_{{0}}} \\leftarrow \\{ (\\view[0](v),f) {\\hspace{0.1cm}\\bigl|\\bigr.\\hspace{0.1cm}} v\\in\\view[l] \\}$\n\\STATE $i\\leftarrow 0$\n\\WHILE{${\\Pi_{{i}}}\\neq{\\Pi_{{i-1}}}$}\n   \\STATE $i \\leftarrow i+1$\n   \\STATE ${\\texttt{communicate}}$\n   \\STATE Compute ${\\Pi_{{i}}}$\n\\ENDWHILE\n\\STATE Compute the labeled quotient graph $({\\mathcal{Q}},g)$ using ${\\Pi_{{i}}}$ and $\\view[l+i]$\n\\RETURN $({\\mathcal{Q}},g)$\n\\end{algorithmic}\n\\end{algorithm}\n\nWe prove the following.\n\\begin{lemma} \\label{lem:computeQG}\nLet $(\\view[l],f)$ be the truncated colored view  computed by procedure ${\\textup{\\texttt{ComputeView}}}$.\\\\\nProcedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ called for $(\\view[l],f)$ correctly computes the colored quotient graph of the network.\n\\end{lemma}\n\\begin{proof}\nBy Lemma~\\ref{lem:covered}, $\\view[l]$ covers the network.\nThus, ${\\Pi_{{0}}}$ contains all nodes of the network.\nBy Proposition~\\ref{stop}, the partition ${\\Pi_{{i}}}$ obtained in the last iteration of the `while' loop of procedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$ equals ${\\Pi_{{}}}$.\nHence, this partition ${\\Pi_{{i}}}$ is the set of all nodes of the colored quotient graph.\nThis implies that the quotient graph can be computed on the basis of ${\\Pi_{{i}}}$ and $\\view[l]$ as follows.\nThe color of a node of the quotient graph is set to the color of its elements in the truncated colored view.\nThe edges and port numbers are added as in the definition of the quotient graph.\n\\end{proof}\n\n\nIn the formulation of our main algorithm we will use the following integer that each node can compute once it has the colored quotient graph $({\\mathcal{Q}},g)$.\nFor any node $u$ of the quotient graph, let ${\\xi_{{u}}}$ be the sum of running times of procedures ${\\textup{\\texttt{ComputeView}}}$ and ${\\textup{\\texttt{ComputeQuotientGraph}}}(\\view[l],f)$, where $(\\view[l],f)$ is computed by ${\\textup{\\texttt{ComputeView}}}$.\nLet ${\\Xi}$ be the maximum of ${\\xi_{{u}}}$ over all nodes $u$ of the quotient graph.\n\nWe are ready to state our main algorithm for solving the problems ${\\textup{LE}}$ and ${\\textup{TOP}}$.\nWe formulate it as a single procedure, since all steps leading to the computation of the colored quotient graph are identical in both cases.\n\n\\floatname{algorithm}{Algorithm}\n\\begin{algorithm} \\caption{${\\textup{\\texttt{Solve-LE-and-TOP}}}(k,{\\alpha})$}\n\\begin{algorithmic}\n\\REQUIRE An upper bound $k$ on the size of color ${\\alpha}$.\n\\ENSURE  For ${\\textup{LE}}$ --- a sequence of port numbers leading from the executing node to the leader, or ${\\texttt{{unsolvable}}}$, if leader election is impossible.\n         For ${\\textup{TOP}}$ --- the topology of the network, or ${\\texttt{{unsolvable}}}$, if topology recognition is impossible.\n\n\\STATE $(\\view[l],f) \\leftarrow {\\textup{\\texttt{ComputeView}}}$\n\\STATE $({\\mathcal{Q}},g) \\leftarrow {\\textup{\\texttt{ComputeQuotientGraph}}}( \\view[l],f )$\n\\STATE Perform ${\\texttt{communicate}}$ ${\\Xi}$ times.\n\\IF{the number of nodes with color ${\\alpha}$ in $({\\mathcal{Q}},g)$ is at most $\\lfloor k/2\\rfloor$ and ${\\mathcal{Q}}$ is not a tree}\n   \\RETURN ${\\texttt{{unsolvable}}}$\n\\ELSE\n   \\STATE For ${\\textup{LE}}$ --- return a sequence of port numbers of the path $\\viewPath{\\view[l]}{v}$, where $v$ (which is the leader) corresponds to the node of $({\\mathcal{Q}},g)$ whose colored view is lexicographically smallest (if the executing node is the leader, then the path is empty).\n   \\STATE For ${\\textup{TOP}}$ --- return $({\\mathcal{Q}},g)$.\n\\ENDIF\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{theorem} \\label{thm:main}\nIf a bound $k$ on the size of a given color ${\\alpha}$ is provided as an input, then Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly solves problems ${\\textup{LE}}$ and ${\\textup{TOP}}$ in time $O(k{D}+{D}\\log(n/{D}))$, where $n$ is the size of the network and $D$ is its diameter.\n\\end{theorem}\n\\begin{proof}\nFirst note that Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly computes the colored quotient graph.\nIndeed, by Lemma~\\ref{lem:computeQG}, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ obtains the colored quotient graph $({\\mathcal{Q}},g)$ as a result of the call to procedure ${\\textup{\\texttt{ComputeQuotientGraph}}}$.\nThis is ensured by the fact that each node performs at least ${\\Xi}$ calls to ${\\texttt{communicate}}$ and therefore every node $u$ can compute $\\view[{\\xi_{{u}}}]$, which is enough to compute the colored quotient graph, by definition of ${\\xi_{{u}}}$.\n\nOnce the colored quotient graph is computed by all nodes of the network, the correctness of Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ essentially follows from \\cite{YK3}.\nFor completeness we include the short argument.\n\nAssume that the colored quotient graph has at most $\\lfloor k/2\\rfloor$ nodes with color ${\\alpha}$ and it is not a tree (i.e., a graph {that has} cycles, multiple edges or self-loops).\nThen, topology recognition cannot be solved since there exist two non-isomorphic networks of size $2\\lfloor k/2\\rfloor$ having $({\\mathcal{Q}},g)$ as a quotient graph.\nAny potential topology recognition algorithm in these networks must have the same execution for each pair of nodes with the same colored views and thus such an algorithm must be incorrect.\nHence, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly returns ${\\texttt{{unsolvable}}}$ for the problem ${\\textup{TOP}}$.\nFor the problem of leader election, take any network of size $2\\lfloor k/2\\rfloor$ having $({\\mathcal{Q}},g)$ as a quotient graph.\nTwo distinct nodes $u$ and $v$ in this network have the same colored view.\nThus, any potential leader election algorithm incorrectly elects at least two leaders in this network.\nHence, Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ correctly returns ${\\texttt{{unsolvable}}}$ for the problem ${\\textup{LE}}$ as well.\n\n\nOtherwise, i.e., if the colored quotient graph has more than $\\lfloor k/2\\rfloor$ nodes with color ${\\alpha}$ or it is a tree, then the network is isomorphic to $({\\mathcal{Q}},g)$ and hence Algorithm ${\\textup{\\texttt{Solve-LE-and-TOP}}}$ gives a correct solution to the problem ${\\textup{TOP}}$.\nAs for leader election, each node has a unique colored view under this assumption.\nHence, the node with the lexicographically smallest colored view is unambiguously elected as the leader by each node.\n\nIt remains to bound the time of computation.\nIt is at most $l+i+{\\Xi}$, where $l$ and $i$ are the numbers of iterations of the `while' loop of procedure ${\\textup{\\texttt{ComputeView}}}$ and ${\\textup{\\texttt{ComputeQuotientGraph}}}$, respectively.\nBy Lemma~\\ref{lem:test:finite} and the formulation of procedure ${\\textup{\\texttt{ComputeView}}}$, $l\\in O(k{D})$.\nBy Proposition~\\ref{trunc}, $i\\in O({D}\\log(n/{D}))$.\nThus, by definition, ${\\Xi}\\in O(k{D}+{D}\\log(n/{D}))$, which completes the proof.\n\\end{proof}\n\n\n\\begin{corollary} \\label{cor:main}\nLet $(G,f)$ be a colored network and let $k$ be a bound on the size of color ${\\alpha}$.\nIf all nodes of $(G,f)$ have pairwise different colored views and the size of color ${\\alpha}$ is strictly greater than $\\lfloor k/2\\rfloor$, then topology recognition and leader election are possible in $G$.\n{\\hfill $\\square$ \\smallbreak}\n\\end{corollary}\n\n\n\\section{Negative results}\n\nIn this section we present our negative results. The first of them {is an impossibility result indicating} that if no upper bound on the size of any color is given to nodes, then problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ must have answer ``unsolvable'', even if other restrictions on the possible sizes of colors are known. In order to express this result in full generality, we formalize such possible restrictions as a set $R\\subseteq {\\mathbb{N}}^r$, where ${\\mathbb{N}}$ denotes the set of positive integers and $r$ is the number of colors.\nWe translate the property that no upper bound on the size of any color is known, to the statement\nthat for any point $(x_1,x_2,\\dots , x_r)\\in {\\mathbb{N}}^r $ there exists a point $(y_1,y_2,\\dots , y_r)$  in the restriction set $R$, such that $y_i \\geq x_i$, for all $i \\leq r$.\nSuch a set $R$ will be called \\emph{unbounded}.\n(An example of an input defining an unbounded restriction set is: there are three colors and the sizes of all of them are prime integers.)\nTo make the impossibility result even stronger, we prove that it holds even for a very simple class of networks: on rings. \n\n\\begin{proposition}\nLet $(C,g)$ be any colored ring.\nConsider an input $I$ defining an unbounded restriction set $R$.\nThen, problems ${\\textup{TOP}}$ and ${\\textup{LE}}$ must have answer ``unsolvable''.\n\\end{proposition}\n\\begin{proof}\nTake any algorithm, call it $A$, that correctly solves problem ${\\textup{TOP}}$ or problem ${\\textup{LE}}$ in any colored ring under input $I$.\nLet $r$ be the number of different colors that appear in the network, and let $x_i$ be the size of color $i$, $i\\in\\{1,\\ldots,r\\}$.\nDenote the nodes of $C$ by $v_0,\\ldots,v_{n-1}$, where $n=x_1+\\cdots+x_r$ and $v_i$ is adjacent to $v_{(i+1){\\,\\textup{mod}\\,} n}$, for each $i\\in\\{0,\\ldots,n-1\\}$.\n\\begin{figure}[htb]\n\\begin{center}\n\\includegraphics[scale=0.9]{fig-ring.pdf}\n\\caption{(a) an example of a ring $(C,g)$ obtained from $(x_1,x_2,x_3)=(1,2,3)$, $n=6$; (b) the corresponding ring $(C',g')$ constructed for $T\\in\\{7,\\ldots,12\\}$ and $(x_1',x_2',x_3')=(5,11,18)$, $n'=34$.}\n\\label{fig:ring}\n\\end{center}\n\\end{figure}\n\nLet $v_0$ be any node of $C$.\nLet $T$ be the time after which $A$ produces the answer.\nSince the restriction set $R$ is unbounded, there exists $(x_1',\\ldots,x_r')\\in R$ such that $x_i'\\geq 2x_i\\lceil T/n\\rceil+x_i$ for each $i\\in\\{1,\\ldots,r\\}$.\nWe construct a colored ring $(C',g')$ on $n'=x_1'+\\cdots+x_r'$ nodes $v_0',\\ldots,v_{n'-1}'$ such that:\n\\begin{itemize}\n \\item $v_i'$ is adjacent to $v_{(i+1){\\,\\textup{mod}\\,} n'}'$, $i\\in\\{0,\\ldots,n'-1\\}$,\n \\item the port numbers of the edge $\\{v_i',v_{i+1}'\\}$ at $v_i'$ and $v_{i+1}'$ are equal to the port numbers of the edge $\\{v_{i{\\,\\textup{mod}\\,} n},v_{(i+1){\\,\\textup{mod}\\,} n}\\}$ at $v_{i{\\,\\textup{mod}\\,} n}$ and $v_{(i+1){\\,\\textup{mod}\\,} n}$, respectively, $i\\in\\{0,\\ldots,2n\\lceil T/n\\rceil+n-1\\}$, in $C$,\n \\item the port numbers of the remaining edges are set arbitrarily in a way that guarantees proper port labeling.\n\\end{itemize}\nMoreover, the colors are assigned to the nodes of $C'$ as follows:\n", "index": 9, "text": "\n\\[g'(v_{i}')=g(v_{i{\\,\\textup{mod}\\,} n}), \\quad i\\in\\{0,\\ldots,2n \\lceil T/n\\rceil+n-1\\},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"g^{\\prime}(v_{i}^{\\prime})=g(v_{i{\\,\\textup{mod}\\,}n}),\\quad i\\in\\{0,\\ldots,2n%&#10;\\lceil T/n\\rceil+n-1\\},\" display=\"block\"><mrow><mrow><mrow><mrow><msup><mi>g</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>v</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mrow><mpadded width=\"+1.7pt\"><mi>i</mi></mpadded><mo>\u2062</mo><mpadded width=\"+1.7pt\"><mtext>mod</mtext></mpadded><mo>\u2062</mo><mi>n</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi>i</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u2308</mo><mrow><mi>T</mi><mo>/</mo><mi>n</mi></mrow><mo stretchy=\"false\">\u2309</mo></mrow></mrow><mo>+</mo><mi>n</mi></mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]