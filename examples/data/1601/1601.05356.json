[{"file": "1601.05356.tex", "nexttext": "\n\n\\noindent which specify how reactant molecules interact to create product\nmolecules. \n\nFor a reaction $r$, $k_r$ is a constant parameter, known as \\emph{reaction\ncoefficient}, that regulates the relative speed of the reaction ({more}\ndetails later).\n\nParameter $\\alpha_{r,s}$ is the \\emph{stoichiometric reactant coefficient},\nspecifying the number of molecules of a species $s\\in\\mathcal{S}$\nconsumed by reaction $r$. Similarly, parameter $\\beta_{r,s}$ is the\n\\emph{stoichiometric product coefficient}, specifying the number of molecules\nof a species $s\\in\\mathcal{S}$ produced by reaction $r$.\n\nIn simple words, a reaction rule replaces $\\alpha_{r,s}$ amount of molecules\nfrom each species $s\\in\\mathcal{S}$ with $\\beta_{r,s}$ amount of molecules of\neach species $s\\in\\mathcal{S}$ at an average rate controlled by the\n$k_r$-coefficient.\n\n\n\nA simple example that illustrates a chemical traffic control algorithm is shown\nin {Fig.~}\\ref{fig:ChemRateLim}. As we demonstrate in the following, similar to\nthe traditional Token Bucket (TB) scheme, this chemical mechanism can be used\nto control the service process of a queue and rate cap the outgoing traffic up\nto a predefined, adjustable threshold. In contrast with the TB scheme, the\nchemical controller allows shaping the outgoing traffic in order to achieve\nsmooth, burst-free dynamics.\\footnote{{\\color{black}{An additional CA that matches exactly the behaviour of the  TB scheme is discussed in \\cite{danms13}.}}} The service process, {implemented with a} CA, is\ngraphically shown in {Fig.~}\\ref{fig:ChemRateLim}(a) and its logic is formally\ndescribed by reactions $r_1$ and $r_2$ in {Fig.~}\\ref{fig:ChemRateLim}(b). \n\n\\begin{figure}\n \\center\n \n \\begin{minipage}[b]{.52\\linewidth}\n  \\centering\n  \\centerline{\\includegraphics[width =4.5cm]{enzyHost_W.pdf}}\n  \n  \\centerline{(a) System}\n \\end{minipage}\n \n \\begin{minipage}[b]{0.45\\linewidth}\n  \\centering\n  \\begin{subequations}\n  \n", "itemtype": "equation", "pos": 19403, "prevtext": "\n\n\\title{\\huge{Towards Programmable Network Dynamics:\\\\A Chemistry-Inspired Abstraction for Hardware Design}}\n\n\\author{Massimo~Monti, \\emph{Student Member IEEE}, \nManolis Sifalakis, \\emph{Member IEEE},\nChristian~F.~Tschudin, \\emph{Member IEEE},\nand Marco~Luise, \\emph{Fellow IEEE}\n\n\\thanks{M.~Monti, M.~Sifalakis, and C.~Tschudin are with the Department of\nMathematics and Computer Science, University of Basel, Bernoullistrasse 16,\n4056 Basel, Switzerland\n(e-mail:\\{m.monti,sifalakis.manos,christian.tschudin\\}@unibas.ch).}\n\n\\thanks{M.~Luise is with the Information Engineering Department, University of\nPisa, Via Caruso 16, 56126 Pisa, Italy (e-mail:marco.luise@iet.unipi.it).} \n\n\\thanks{This work has been supported in part by Swiss National Science\nFoundation grant \\#132525.}\n\n\n\n\n\n} \\maketitle\n\n\n\n\\begin{abstract} \n\nChemical algorithms are statistical algorithms described and represented as\nchemical reaction networks. They are particularly attractive for traffic\nshaping and general control of network dynamics; they are analytically\ntractable, they reinforce a strict state-to-dynamics relationship, they have\nconfigurable stability properties, and they are directly implemented in\nstate-space using a high-level (graphical) representation.\n\nIn this paper, we present a direct implementation of chemical algorithms on\nFPGA hardware. Besides substantially improving performance, we have achieved\nhardware-level programmability and re-configurability of these algorithms\n\\emph{at runtime} (not interrupting servicing) and \\emph{in realtime} (with\nsub-second latency). This opens an interesting perspective for expanding the\ncurrently limited scope of software defined networking and network\nvirtualisation solutions, to include programmable control of network dynamics.\n\n\\end{abstract}\n\n \n\n\\begin{IEEEkeywords}\nChemical algorithm, \nProgrammable networks,\nSoftware defined networking, \nNetwork dynamics, \nTraffic shaping, \nFPGA.\n\\end{IEEEkeywords}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Introduction}\n\\label{sec:intro}\n\n\\IEEEPARstart{N}{etwork dynamics}\n\n{\\color{black}{as a term describes an important operational aspect of queuing networks and the Internet. It refers to traffic control processes such as (among others) scheduling, shaping, policing, and Active Queue Management (AQM).}} \n\nInitially, network dynamics were controlled end-to-end only, through transport\nprotocol mechanisms such as TCP's flow and congestion control algorithms. Yet\ntoday, also mechanisms at the core of the network play an important role in\nshaping intra/inter-flow dynamics in the Internet. This is effected for example by\nmeans of service differentiation, flow conditioning, (distributed) rate control,\nAQM and other congestion avoidance measures.\n\n{\\color{black}{ Recent developments in network virtualisation for cloud infrastructures and Software Defined Networking (SDN), which explore ways to make network infrastructure runtime-volatile through software, have at large neglected network dynamics. To date, most of efforts have focused on programmability of data paths (functions pertinent to firewalling, packet inspection, header editing, {\\emph{etc.}}) and topology management. In regard to network dynamics on the other hand, while notable advancements are being underway today \\cite{AlKa12}\\nocite{AlGr10,RoSa11,JeAl13,BaCo11,NiJa12,PaNa12}--\\cite{ThBa13}, programmable SDN-like deployments are at best confined to a number of \\emph{pre-packaged} (often ``age-old'') algorithms, typically offered as proprietary manufacturer-provided modules \\cite{SDNet}. A potentially notable exception is the software-switch specification language proposed in~\\cite{BoDa14}. Authors claim that it may be used to create action primitives for congestion control  although they fall short of explaining how (or providing examples). }}\n\nEnabling runtime programmability/configurability of functions to control\nnetwork dynamics is more challenging\n\n\nthan accessing and modifying the router/node fabric to simply extend\npacket parsing and filtering functionalities (e.g., \\cite{JeAl14,BoGi13}) or\nperform topology management (e.g., \\cite{EthSwicth}).\n\n\nFirst of all, it requires solutions that can be deployed close to, or on,\nhardware (for performance and computational speed reasons). Additionally, in contrast to a mere flow-rule pipeline, such\nfunctions are algorithmically complex to implement, with many interdependencies\nto cater for. For example, programming\nor reconfiguring a queueing discipline often requires to modify the actual\nlogic \\cite{NiJa12,PaNa12,Ku13} that functionally binds\ndifferent runtime parameters and components (e.g.  queue-lengths, filter\nthresholds, droppers and markers, averaging coefficients, {\\emph{etc.}}). Next,\nmanagement operations for modifying parameters in these functions (e.g.\nsetting rate cap parameters, meter bands, {\\emph{etc.}}) are likely more frequent than\ntypical topology management tasks. And finally, changes (not only modifications\nbut also the replacement of algorithms) are less tolerant to data-path delays than load\noperations of flow-table rules.\n\n\n\nIn past works~\\cite{hotnet09}--\\nocite{sensorj14, srds12, jsac13,danms13}\\cite{ijcnc13}, we have introduced a class of algorithms founded on\noperational principles of chemical reaction networks, and demonstrated their\nsuitability for (expressible state-space representation) and usefulness in\n(analysability/verification) the design of control functions for various\ntasks pertinent to network dynamics.\n\nIn this paper, we capitalise on, and complete, this work in the context of\nprogrammable networks, and we show that these ``chemical'' algorithms (CAs) are\nfast to deploy and easy to re-program and modify \\emph{at runtime} on FPGA\nhardware.\n\n{\\color{black}{ Specifically the contributions of this work amount to the following:  \\begin{enumerate} \\item Direct expressibility of high level mathematical models of control systems on hardware, based on the simple reaction network abstraction, without resorting to cumbersome hardware description language (HDL) programming.  \\item Effective algorithmic parallelisation without special engineering effort or the need for compiler optimisation. As these models freely describe parallelisable logic in state equations, they do not need to be implemented as finite state automata (i.e.  sequentialised algorithms) so that they can be executed by a CPU (soft- or hard-).   \\item Re-programmability (parameter tuning, partial algorithm rewriting, but also complete algorithm replacement) on hardware, \\emph{at runtime} and \\emph{sub-second latencies}, without need for bitstream re-generation and re-loading on the FPGA. In principle (albeit not experimented) our method should enable re-programmability of such algorithms even on ASICs. \\end{enumerate}  The implementation of CAs on hardware opens an unprecedented possibility in SDN and programmable networks to support customisable network dynamics functions, with fast prototyping, fast deployment, prompt testing and verification. To our knowledge, we have not seen a record of similar or analogous contribution in this field so far. }}\n\n\n{\\color{black}{ The rest of this paper is organised as follows. In the next subsection we motivate our work {and clarify our contributions}.  In section {Sect.}\\ref{sec:AC} we {\\color{black}{summarise}} the basics of CAs to a certain degree of detail as essential to explain our design on hardware. In {Sect.}\\ref{sec:FPGAimplHW} we present our framework design for running CAs on FPGA hardware and in {Sect.}\\ref{sec:expHW} we evaluate an implementation on the Xilinx Spartan-6 XC6SLX9 FPGA device. {Finally in {Sect.}\\ref{sec:discussion} we give examples of CAs for queue management (not previously presented in the literature), we discuss in the context of SDN an integration approach for our framework in the OpenFlow architecture~\\cite{McPa08}, and we provide an account of what performance can one anticipate with the FPGA technology currently available on market.} }}\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Motivation}\n\\label{sec:motivation}\n\n\n\n\n\n\n{\\color{black}{ Research and engineering efforts in SDN and virtualisation for cloud infrastructures have been exploring ways to make network infrastructure run-time volatile through software. The aim is to simplify network management and improve service provisioning in response to fast-changing user demand, mobility, distributed multipoint access, {\\emph{etc.}}. So far, most of research in SDN has focused on defining open protocols and interfaces to create a very generic and flexible switch architecture (capable of accommodating bespoke packet processing functions). In this process, there have often been attempts to bring ideas and solutions from active/programmable networks closer to (FPGA) hardware, so to address concerns on delay performance and processing off-loading (from CPU). Classic examples of projects in this direction have been the NetFPGA large-scale collaborative initiative~\\cite{LoMc07} (among universities and FPGA manufacturers) as well as works taking place in individual labs of IC manufacturers~\\cite{SDNet, EthSwicth}, which develop \\emph{Intellectual Property Cores} (IPCs) for complex networking functions that can be used off-the-shelf in the synthesis of composable data-planes on FPGAs.  In the whole volume of work that exists so far, we are able to identify two important issues. One is the lack of (or limited) attention to the programmability of the parts of the inter-networking fabric that pertains to traffic management and network dynamics in general (we have only seen the topic touched in~\\cite{SDNet, BoDa14, AlteraOpenCL} but not adequately addressed).  The other is that software and hardware programming are in various aspects still incompatible and therefore not well unified/aligned. These aspects include time-scale constraints in algorithm development/deployment, and difficulties/tradeoffs in combining the efficiency offered by hardware with the flexibility provided by software when implementing algorithmic logic. These two issues, although orthogonal, are not independent. Realising hardware mechanisms for network dynamics control, while being able to customise them at very low latency, requires advances both in expressibility as well as deployment time-scales of code on hardware. The herein presented work is a substantial step forward in this respect.  Conventional practice requires the use of a Hardware Description Language (HDL) such as VHDL~\\cite{VHDL} or Verilog~\\cite{verilog}, which in contrast to software programming is a laborious and time consuming task. While HDL is suitable for describing sequential and combinational logic, it is very complex and error-prone when used to implement high-level algorithms (of reasonable complexity), due to limited expressibility and high-level abstractions at the level of algorithm behaviour.  For this reason, complex algorithms are often provided in a toolbox of manufacturer pre-coded IPCs, which can be used by the hardware programmer to compose processing pipelines.  For example in the context of traffic management, Xilinx~Inc.~\\cite{ Po06}, Altera~Corp.~\\cite{Al14}, and Lattice Semiconductors~\\cite{La14} offer IPCs for multi-level hierarchical queueing, round robin scheduling, fair queueing, burst equalisation, random early detection (RED), token/leaky bucket policing, {\\emph{etc.}}. Yet, this means that, on the customer side, prototyping, testing, and deploying of new algorithms are still done in software (e.g.~\\cite{JeAl14,AlAt08, DuGi07,MaRa11}), except for a narrow segment of non-novices in hardware programming (e.g.~\\cite{AlKa12,HaDw11}).  To improve the programmer experience by addressing limitations in algorithmic expressibility, and thereby to bridge the gap between software and hardware programming (which promotes the widespread adoption of FPGAs), a number of projects strive to develop language frameworks that raise the level of abstraction from HDLs (two comprehensive reviews are available in~\\cite{Ch12, BaRaSh13}). Most of these frameworks opt to achieve one or both of the following two objectives: {\\emph{(i)}~}{}automate code synthesizability (functional verification, netlist generation, translation and synthesis, mapping to FPGA resource requirements, place-and-route, timing analysis, bitstream generation) into something that resembles the compilation process in software languages; {\\emph{(ii)}~}{}formalise ways of mapping a high-level algorithm (behavioural description) to some low-level description (register-transfer level or digital circuit). A classification offered by \\cite{BaRaSh13} distinguishes five categories: {\\emph{(i)}~}{}HDL-derived languages enriched with software engineering features such as object-orientation, type-systems, and module hierarchies, e.g.,~\\cite{Bluespec}; {\\emph{(ii)}~}{}C-style language extensions that rely on in-code annotations and confine the programmer to a small subset of the parent language (e.g. no use of pointers), e.g.~\\cite{CaDi09, CouMo08, Vivado}; {\\emph{(iii)}~}{}CUDA/OpenCL-based frameworks, which use intermediate data language representations and library IPCs to compile high-level code into parts that can co-execute on a host CPU and FPGAs (often supporting dynamic linkage as well), e.g.,~\\cite{AlteraOpenCL,JaLa10, PaGu09}; {\\emph{(iv)}~}{}modern high-level (often functional) language-based frameworks, which offer object-orientation, strong typing, support of polymorphism, and automatic memory management, e.g.,~\\cite{Lime, BaVo12, Kiwi, Esterel}; {\\emph{(v)}~}{}model-based frameworks, which provide graphical representations and rely on executable specifications to accelerate design and verification, e.g.,~\\cite{DaFa06}.  While our work shares similarities with the last category in terms of algorithm expressibility and representation, there is an important distinction that differentiates it from all other listed approaches: the time-scale of program/algorithm deployment and modification. In the majority of the aforementioned approaches, a high-level expression of an algorithm is \\emph{compiled} offline into HDL code. The netlist (or bitstream) then needs to be synthesised and ``downloaded'' on the FPGA, requiring an additional delay. Thereafter, code modifications require a re-compilation and re-load of the bitstream on the FPGA (today, a typical delay for downloading a new bitstream into the FPGA is in the time-scale of \\emph{seconds}, thus unacceptable for run-time modifications). These substantial overheads do not exist in our approach, which resembles more runtime interpretation of programs (rather than off-line compilation). Program specifications are loaded ``instantaneously'' (in sub-second speeds) and can be edited while the system is running. This is because CAs have a very simple representation that can be translated into a set of memory-mapped register values (thus not requiring the use of slow electronic design automation -- EDA -- tools). Additionally, the inherently parallel nature of a program in CAs' representation allows different parts of the algorithm to be modified independently of each other.   Before discussing specifically the chemical middleware abstraction for hardware, we need to  briefly introduce CAs in general. For the sake of completeness and contextualisation, in the next section, we summarise main principles and concepts (retrievable in \\cite{hotnet09}--\\nocite{sensorj14, srds12, jsac13,danms13}\\cite{ijcnc13,MeTh}).    }}\n\n\n\n\n\n\n\\section{Chemical Algorithms and control of (network) dynamics} \n\\label{sec:AC}\n\n\nCAs (chemical algorithms, or Chemistry-inspired algorithms) refer to a class of stochastic algorithms\nwhose logic is described and implemented as a chemical reaction network.\nInputs, outputs and internal states are represented by concentrations of\nmolecular species, and their (mathematical) relationships are represented by\nreaction rules. CAs are subject to the kinetics laws of Chemistry (mainly, the\nLaw of Mass Action and conservation laws), which dominate operations and\ninfluence the behavioural characteristics of the algorithm.  Abiding to\nchemical kinetics makes CAs \\emph{robust}, \\emph{deadlock-free}, and\n\\emph{analysable}:\n\n\\begin{itemize}\n\n\\item\\emph{Robustness:} CAs are dynamical systems that continuously process\nevent signals, and are robust to errors or perturbations. Formally, robustness\nis the ability of a system, once perturbed from its current trajectory, to find\nthe attractor (steady-state) that recovers its trajectory.  This happens if,\nduring the perturbation, the system remains within the basin of attraction.\nSteady-state solutions of CAs are attractors with large basins.  In other\nwords, the system moves in ``small steps'', so that perturbations displace the\nsystem only a small distance from the attractor. By contrast, typical\ncomputational systems that implement discrete time algorithms (network\nfunctions among others) exhibit very small basins of attraction. This means\nthat the magnitude of perturbations, which the system can absorb without\ngetting displaced towards a different attractor (error, instability, or\nunpredicted state), is rather limited~\\cite{St12}.\n\n\\item\\emph{Deadlock-free operation:} CAs are statistical algorithms with a\ndeterministic average behaviour. At a ``microscopic'' level, individual\ncomputations (reactions) occur stochastically, independently of each other. \n\nThis means that the algorithm cannot deadlock in some computation or state\n(even when the inputs are not synchronised).  At the same time however, the\nmacroscopic (collective) effects of the entire algorithm have a deterministic\naverage tendency (as the effects of any single computation are minimal).\n\n\\item\\emph{Analysability:} CAs are mathematically tractable.  The behaviour of\na CA can be accurately described by a system of equations directly derived from\nits (graphical) representation as a reaction network. This is possible because\nthe internal operation of the CA and the resulting dynamics are governed by the\nchemical kinetics laws.  This contrasts the traditional practice of\nderiving \\emph{a-posteriori} models to approximate the behaviour of already\nimplemented algorithms.\n\n\\end{itemize}\n\n\n{\\color{black}{ In the last decade, works aimed at establishing and formalising the chemical metaphor as a computational and programming model in general, e.g., \\cite{Di05}-\\nocite{BaFr05, Pa00, BaDi96,GiMi01}\\cite{MaKr11}, and also specifically in networking, e.g., \\cite{sensorj14, danms13,ViCa11, NaGi10}. }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Representation of CAs}\n\\label{sec:CA_representation}\n\n\n\nInstead of state diagrams or pseudocode that describe a sequential logic, the\nlogic of CAs is suitably expressed (and visualised) in \\emph{drawings} of\nchemical reactions among molecular species (e.g., {Fig.~}\\ref{fig:ChemRateLim}(a),\nwhite rounded-corner square).  The species represent the algorithm's inputs,\noutputs, and internal state variables. The reaction network diagram encodes the\nparameters that control the behaviour of the system (reaction coefficients and\nreactant stoichiometric coefficients). A reaction captures a causal\nrelationship between the system's state-variables (reactants and products).\n\nFormally, a reaction network (and therefor a CA) is represented by a set\n$\\mathcal{S}$ of molecular species (variables), and a set $\\mathcal{R}$ of\nreaction rules of the general form\n\n\n", "index": 1, "text": "\\begin{equation}\\label{eq:reaction} r\\in\\mathcal R: \\quad \\sum\\limits_{s \\in\n\\mathcal{S}} \\alpha_{r,s} s \\mathop \\to \\limits^{k_r} \\sum\\limits_{s \\in\n\\mathcal{S}} \\beta_{r,s} s \\;\\; , \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"r\\in\\mathcal{R}:\\quad\\sum\\limits_{s\\in\\mathcal{S}}\\alpha_{r,s}s\\mathop{\\to}%&#10;\\limits^{k_{r}}\\sum\\limits_{s\\in\\mathcal{S}}\\beta_{r,s}s\\;\\;,\" display=\"block\"><mrow><mi>r</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>:</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>s</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi></mrow></munder><msub><mi>\u03b1</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mi>s</mi><mover><mo movablelimits=\"false\">\u2192</mo><msub><mi>k</mi><mi>r</mi></msub></mover><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>s</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi></mrow></munder><msub><mi>\u03b2</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub><mpadded width=\"+5.6pt\"><mi>s</mi></mpadded><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n  \\vspace{0.3in}\n  \\end{subequations}\n  \n  \\centerline{(b) Reactions}\n \\end{minipage}\n \\caption{\\texttt{Rnet1}: The enzymatic reaction network used as a\ntraffic rate controller (pacing and rate capping). CA's input is\nconnected to a queue's arrival process and the CA's output controls the queue's service\nprocess.\n}\n \\label{fig:ChemRateLim}\n\\end{figure}\n\nFor each enqueued packet (or certain amount of bytes), a molecule of species\n{\\ensuremath{\\textrm{{S}}}} is created. The dequeueing and transmission of a packet is authorised\nby the execution of reaction $r_2$, which implies the production of a {\\ensuremath{\\textrm{{P}}}}\nmolecule and the consumption of an {\\ensuremath{\\textrm{{ES}}}} molecule.\n\nThe production of {\\ensuremath{\\textrm{{ES}}}} molecules in turn is controlled by reaction $r_1$,\nand depends on {{\\ensuremath{\\textrm{{S}}}}} molecules (arrivals of packets in the queue) and the\navailability of {{\\ensuremath{\\textrm{{E}}}}} molecules, which embody tokens.  Molecules of species\n{\\ensuremath{\\textrm{{E}}}} (tokens) are replenished from the separation of {\\ensuremath{\\textrm{{ES}}}} molecules at\nthe rate at which reaction $r_2$ occurs.\n\nOverall, the {effective} queue service policy is \\emph{non work-conserving}:\nthe queue is not served as fast as possible; its service is instead regulated\nby {the relationship between rates of reactions $r_1$ and $r_2$ (as shown in\nthe next section)}. \n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Operation and Dynamical aspects}\n\\label{sec:CA_dynamics}\n\n\n\nDynamics of CAs (when and which reaction is executed) are regulated by the\n\\emph{Law of Mass Action} (LoMA). The LoMA~\\cite{HoJa72} states\nthat the average rate $v_r(t)$ of occurrence of a chemical reaction $r\n\\in\\mathcal R$ is proportional to its reactant concentrations:\\footnote{The\nrate value found in \\eqref{eq:LoMA} can be regarded as a simplified value\nquantifying the propensity $a_r$ of a reaction $r$ to occur\n\\cite{WoUl04,MeTh}.}\n\n\n", "itemtype": "equation", "pos": 21535, "prevtext": "\n\n\\noindent which specify how reactant molecules interact to create product\nmolecules. \n\nFor a reaction $r$, $k_r$ is a constant parameter, known as \\emph{reaction\ncoefficient}, that regulates the relative speed of the reaction ({more}\ndetails later).\n\nParameter $\\alpha_{r,s}$ is the \\emph{stoichiometric reactant coefficient},\nspecifying the number of molecules of a species $s\\in\\mathcal{S}$\nconsumed by reaction $r$. Similarly, parameter $\\beta_{r,s}$ is the\n\\emph{stoichiometric product coefficient}, specifying the number of molecules\nof a species $s\\in\\mathcal{S}$ produced by reaction $r$.\n\nIn simple words, a reaction rule replaces $\\alpha_{r,s}$ amount of molecules\nfrom each species $s\\in\\mathcal{S}$ with $\\beta_{r,s}$ amount of molecules of\neach species $s\\in\\mathcal{S}$ at an average rate controlled by the\n$k_r$-coefficient.\n\n\n\nA simple example that illustrates a chemical traffic control algorithm is shown\nin {Fig.~}\\ref{fig:ChemRateLim}. As we demonstrate in the following, similar to\nthe traditional Token Bucket (TB) scheme, this chemical mechanism can be used\nto control the service process of a queue and rate cap the outgoing traffic up\nto a predefined, adjustable threshold. In contrast with the TB scheme, the\nchemical controller allows shaping the outgoing traffic in order to achieve\nsmooth, burst-free dynamics.\\footnote{{\\color{black}{An additional CA that matches exactly the behaviour of the  TB scheme is discussed in \\cite{danms13}.}}} The service process, {implemented with a} CA, is\ngraphically shown in {Fig.~}\\ref{fig:ChemRateLim}(a) and its logic is formally\ndescribed by reactions $r_1$ and $r_2$ in {Fig.~}\\ref{fig:ChemRateLim}(b). \n\n\\begin{figure}\n \\center\n \n \\begin{minipage}[b]{.52\\linewidth}\n  \\centering\n  \\centerline{\\includegraphics[width =4.5cm]{enzyHost_W.pdf}}\n  \n  \\centerline{(a) System}\n \\end{minipage}\n \n \\begin{minipage}[b]{0.45\\linewidth}\n  \\centering\n  \\begin{subequations}\n  \n", "index": 3, "text": "\\begin{align}\n  \t r_{1}:\\,\\,  & {\\ensuremath{\\textrm{{S}}}}+{\\ensuremath{\\textrm{{E}}}}\t \\stackrel{k_1}{\\longrightarrow} {\\ensuremath{\\textrm{{ES}}}}\t\\notag\t\\\\ \n  \t r_{2}:\\,\\, \t& {\\ensuremath{\\textrm{{ES}}}} \t \\stackrel{k_2}{\\longrightarrow}{\\ensuremath{\\textrm{{E}}}} + {\\ensuremath{\\textrm{{P}}}}\\notag\n  \\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{1}:\" display=\"inline\"><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\textrm{{S}}}+{\\textrm{{E}}}\\stackrel{k_{1}}{\\longrightarrow}{%&#10;\\textrm{{ES}}}\" display=\"inline\"><mrow><mrow><mtext>S</mtext><mo>+</mo><mtext>E</mtext></mrow><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mn mathsize=\"140%\">1</mn></msub></mover><mtext>ES</mtext></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{2}:\" display=\"inline\"><mrow><msub><mi>r</mi><mn>2</mn></msub><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\textrm{{ES}}}\\stackrel{k_{2}}{\\longrightarrow}{\\textrm{{E}}}+{%&#10;\\textrm{{P}}}\" display=\"inline\"><mrow><mtext>ES</mtext><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mn mathsize=\"140%\">2</mn></msub></mover><mrow><mtext>E</mtext><mo>+</mo><mtext>P</mtext></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n\n\\noindent where $c_s(t)$ denotes the amount of molecules of species $s\\in\n\\mathcal{S}$ at time $t$ ($c_s(t)$ can also be regarded as a {time-continuous},\ndiscrete-valued signal that the system processes), and $k_r$ is the coefficient\nthat regulates the reaction speed (regulating the relationship between\nmolecular mass and rate).  \n\n{Reactant concentrations affect the speed of the reaction in a non-linear way,\nbased on the stoichiometric reactant coefficients -- the sum of reactant\ncoefficients of a reaction $r$, $\\sum_{s \\in \\mathcal S} \\alpha_{r,s}$, is\nknown as \\emph{reaction order}}.\n\nThe LoMA couples the state and the dynamics of the system, and plays a key role\nin CAs  (as a self-adaptive internal scheduler). For example in the (enzymatic) rate controller in\n{Fig.~}\\ref{fig:ChemRateLim}, the effectiveness of the loop ({\\ensuremath{\\textrm{{E}}}}--{\\ensuremath{\\textrm{{ES}}}}) to\ncontrol the transmissions (generation of {\\ensuremath{\\textrm{{P}}}} molecules) stems from the\nstrict relation that the LoMA imposes between the current state of the system\n(how many transmissions have been authorised and how many packets await in the\nqueue) and the speed along the {\\ensuremath{\\textrm{{E}}}}--{\\ensuremath{\\textrm{{ES}}}} loop. By comparison,\nwork-conserving scheduling disciplines would cause tokens to loop infinitely\nfast, in this way making the mechanism ineffective to shape and limit the\ntraffic.\n\n\n\nThe other operational principle behind the automatism of the control loop is\nthe \\emph{mass-conservation} law \\cite{SaIn04}, which states that the total sum\nof molecule concentrations along a loop remains constant if {\\emph{(i)}~}{}the total\nnumber of molecules consumed by reactions along the loop is equal to the total\nnumber of molecules produced, and {\\emph{(ii)}~}{}all concentrations along the loop are\naltered only by reactions involved in this or another loop. It follows that, in\nthe (enzymatic) rate controller in {Fig.~}\\ref{fig:ChemRateLim}, the number of\ntokens ${\\ensuremath{c_{\\textrm{{E}}}}}+{\\ensuremath{c_{\\textrm{{ES}}}}}=e_0$ is conserved. This limits the maximum number of\n{\\ensuremath{\\textrm{{P}}}} molecules that can be generated per second, and thus enforces a rate\ncap to the packet transmission.\n\n\n\n\n\n\n\n\\subsection{Modeling and Analyzability}\n\\label{sec:CA_analysis}\n\n\n\nIn CAs, the dual relationship between system state and dynamics warrants an\nexact/accurate mathematical description of the system.  This makes signal- and\ncontrol-theory viable tools to analyse the behaviour of the algorithm.\n\n\n\nSpecifically, the behaviour of each CA is {mathematically expressed as} a fluid\nmodel, i.e., a set of Ordinary Differential Equations (ODEs) of the form \n\n\n", "itemtype": "equation", "pos": 23792, "prevtext": "\n  \\vspace{0.3in}\n  \\end{subequations}\n  \n  \\centerline{(b) Reactions}\n \\end{minipage}\n \\caption{\\texttt{Rnet1}: The enzymatic reaction network used as a\ntraffic rate controller (pacing and rate capping). CA's input is\nconnected to a queue's arrival process and the CA's output controls the queue's service\nprocess.\n}\n \\label{fig:ChemRateLim}\n\\end{figure}\n\nFor each enqueued packet (or certain amount of bytes), a molecule of species\n{\\ensuremath{\\textrm{{S}}}} is created. The dequeueing and transmission of a packet is authorised\nby the execution of reaction $r_2$, which implies the production of a {\\ensuremath{\\textrm{{P}}}}\nmolecule and the consumption of an {\\ensuremath{\\textrm{{ES}}}} molecule.\n\nThe production of {\\ensuremath{\\textrm{{ES}}}} molecules in turn is controlled by reaction $r_1$,\nand depends on {{\\ensuremath{\\textrm{{S}}}}} molecules (arrivals of packets in the queue) and the\navailability of {{\\ensuremath{\\textrm{{E}}}}} molecules, which embody tokens.  Molecules of species\n{\\ensuremath{\\textrm{{E}}}} (tokens) are replenished from the separation of {\\ensuremath{\\textrm{{ES}}}} molecules at\nthe rate at which reaction $r_2$ occurs.\n\nOverall, the {effective} queue service policy is \\emph{non work-conserving}:\nthe queue is not served as fast as possible; its service is instead regulated\nby {the relationship between rates of reactions $r_1$ and $r_2$ (as shown in\nthe next section)}. \n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Operation and Dynamical aspects}\n\\label{sec:CA_dynamics}\n\n\n\nDynamics of CAs (when and which reaction is executed) are regulated by the\n\\emph{Law of Mass Action} (LoMA). The LoMA~\\cite{HoJa72} states\nthat the average rate $v_r(t)$ of occurrence of a chemical reaction $r\n\\in\\mathcal R$ is proportional to its reactant concentrations:\\footnote{The\nrate value found in \\eqref{eq:LoMA} can be regarded as a simplified value\nquantifying the propensity $a_r$ of a reaction $r$ to occur\n\\cite{WoUl04,MeTh}.}\n\n\n", "index": 5, "text": "\\begin{equation}\\label{eq:LoMA}\n  v_r(t) = k_r \\prod \\limits_{s \\in \\mathcal S} c_s^{\\alpha_{r,s}}(t) \\;\\; ,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"v_{r}(t)=k_{r}\\prod\\limits_{s\\in\\mathcal{S}}c_{s}^{\\alpha_{r,s}}(t)\\;\\;,\" display=\"block\"><mrow><mrow><mrow><msub><mi>v</mi><mi>r</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>k</mi><mi>r</mi></msub><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>s</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi></mrow></munder><mrow><msubsup><mi>c</mi><mi>s</mi><msub><mi>\u03b1</mi><mrow><mi>r</mi><mo>,</mo><mi>s</mi></mrow></msub></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo rspace=\"8.1pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": " \n\nThe term on the left-hand side represents the vector of state changes\n{(concentration variations)}, whereas the right-hand side {specifies how\nreactions effect these changes.} The stoichiometric matrix ${\\ensuremath{\\mathbf{\\Xi}}}$ captures\nthe {topology of the reaction} network, whereas the reaction rate vector ${\\mathbf{v}}$\n{encodes the speeds of each reaction}, by {combining} reaction coefficients\n${\\mathbf{k}}$ and concentrations~${\\mathbf{c}}$ according to the LoMA in \\eqref{eq:LoMA}.\nFor example, referring back to our rate controller in\n{Fig.~}\\ref{fig:ChemRateLim}, {and given} the reaction set in\n{Fig.~}\\ref{fig:ChemRateLim}(b), the resulting system of ODEs is\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\noindent where $c_s(t)$ denotes the amount of molecules of species $s\\in\n\\mathcal{S}$ at time $t$ ($c_s(t)$ can also be regarded as a {time-continuous},\ndiscrete-valued signal that the system processes), and $k_r$ is the coefficient\nthat regulates the reaction speed (regulating the relationship between\nmolecular mass and rate).  \n\n{Reactant concentrations affect the speed of the reaction in a non-linear way,\nbased on the stoichiometric reactant coefficients -- the sum of reactant\ncoefficients of a reaction $r$, $\\sum_{s \\in \\mathcal S} \\alpha_{r,s}$, is\nknown as \\emph{reaction order}}.\n\nThe LoMA couples the state and the dynamics of the system, and plays a key role\nin CAs  (as a self-adaptive internal scheduler). For example in the (enzymatic) rate controller in\n{Fig.~}\\ref{fig:ChemRateLim}, the effectiveness of the loop ({\\ensuremath{\\textrm{{E}}}}--{\\ensuremath{\\textrm{{ES}}}}) to\ncontrol the transmissions (generation of {\\ensuremath{\\textrm{{P}}}} molecules) stems from the\nstrict relation that the LoMA imposes between the current state of the system\n(how many transmissions have been authorised and how many packets await in the\nqueue) and the speed along the {\\ensuremath{\\textrm{{E}}}}--{\\ensuremath{\\textrm{{ES}}}} loop. By comparison,\nwork-conserving scheduling disciplines would cause tokens to loop infinitely\nfast, in this way making the mechanism ineffective to shape and limit the\ntraffic.\n\n\n\nThe other operational principle behind the automatism of the control loop is\nthe \\emph{mass-conservation} law \\cite{SaIn04}, which states that the total sum\nof molecule concentrations along a loop remains constant if {\\emph{(i)}~}{}the total\nnumber of molecules consumed by reactions along the loop is equal to the total\nnumber of molecules produced, and {\\emph{(ii)}~}{}all concentrations along the loop are\naltered only by reactions involved in this or another loop. It follows that, in\nthe (enzymatic) rate controller in {Fig.~}\\ref{fig:ChemRateLim}, the number of\ntokens ${\\ensuremath{c_{\\textrm{{E}}}}}+{\\ensuremath{c_{\\textrm{{ES}}}}}=e_0$ is conserved. This limits the maximum number of\n{\\ensuremath{\\textrm{{P}}}} molecules that can be generated per second, and thus enforces a rate\ncap to the packet transmission.\n\n\n\n\n\n\n\n\\subsection{Modeling and Analyzability}\n\\label{sec:CA_analysis}\n\n\n\nIn CAs, the dual relationship between system state and dynamics warrants an\nexact/accurate mathematical description of the system.  This makes signal- and\ncontrol-theory viable tools to analyse the behaviour of the algorithm.\n\n\n\nSpecifically, the behaviour of each CA is {mathematically expressed as} a fluid\nmodel, i.e., a set of Ordinary Differential Equations (ODEs) of the form \n\n\n", "index": 7, "text": "\\begin{equation}\\label{genODE} \\dot{{\\mathbf{{c}}}}(t) = {\\ensuremath{\\mathbf{\\Xi}}} \\cdot {\\mathbf{{v}}}({\\mathbf{k}}, {\\mathbf{{c}}}(t)).  \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\dot{{\\mathbf{{c}}}}(t)={\\mathbf{\\Xi}}\\cdot{\\mathbf{{v}}}({\\mathbf{k}},{%&#10;\\mathbf{{c}}}(t)).\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>\ud835\udc1c</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>\ud835\udeb5</mi><mo>\u22c5</mo><mi>\ud835\udc2f</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc24</mi><mo>,</mo><mrow><mi>\ud835\udc1c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n\n\\noindent where the term $k_2{\\ensuremath{c_{\\textrm{{ES}}}}}$ reflects the rate of reaction $r_2$ and\nthus the dequeueing/transmission rate $v_\\textrm{tx}$.\n\nFrom the developer's perspective, the stoichiometric matrix~${\\ensuremath{\\mathbf{\\Xi}}}$ provides the means to program any certain CA, and the reaction\ncoefficient vector ${\\mathbf{k}}$ represents the means to calibrate/tune it.  The\nconcentration vector ${\\mathbf{{c}}}(t)$ then represents changes in the CA's state, as\nthe system evolves over time -- i.e. it is not explicitly controllable.\n\n\nFrom \\eqref{odeChemControl}, it follows (by solving the homogeneous system for\nthe steady state) that so long as $\\lambda<e_0 k_2$, the concentration {\\ensuremath{c_{\\textrm{{S}}}}}\nremains stable and the transmission rate $v_ \\textrm{tx}^*$ follows the packet\narrival rate $\\lambda$ (see \\cite{MoSiTR12} for more details).\n\n\n\nOn the other hand, by applying the mass conservation law\n(${\\ensuremath{c_{\\textrm{{E}}}}}+{\\ensuremath{c_{\\textrm{{ES}}}}}=e_0$), one arrives to the Michaelis-Menten (biochemical)\nequation: \n\n\n", "itemtype": "equation", "pos": 27456, "prevtext": " \n\nThe term on the left-hand side represents the vector of state changes\n{(concentration variations)}, whereas the right-hand side {specifies how\nreactions effect these changes.} The stoichiometric matrix ${\\ensuremath{\\mathbf{\\Xi}}}$ captures\nthe {topology of the reaction} network, whereas the reaction rate vector ${\\mathbf{v}}$\n{encodes the speeds of each reaction}, by {combining} reaction coefficients\n${\\mathbf{k}}$ and concentrations~${\\mathbf{c}}$ according to the LoMA in \\eqref{eq:LoMA}.\nFor example, referring back to our rate controller in\n{Fig.~}\\ref{fig:ChemRateLim}, {and given} the reaction set in\n{Fig.~}\\ref{fig:ChemRateLim}(b), the resulting system of ODEs is\n\n\n", "index": 9, "text": "\\begin{equation} \\label{odeChemControl}\n\t\\begin{bmatrix}\n \t\t\\dot{{\\ensuremath{c_{\\textrm{{S}}}}}}(t) \\\\ \n\t\t\\dot{{\\ensuremath{c_{\\textrm{{E}}}}}}(t)\\\\%E\n\t\t\\dot{{\\ensuremath{c_{\\textrm{{ES}}}}}}(t) \\\\ \n\t\t\\dot{{\\ensuremath{c_{\\textrm{{P}}}}}}(t) \\\\ \n\t\\end{bmatrix}=\n\t\\begin{bmatrix}\n \t\n \t\t-1 & 0 & 1 \\\\ \n\t\t-1 & 1  & 0\\\\%E\n\t\t1 & -1 & 0\\\\ \n\t\t0 & 1 & 0\\\\ \n\t\\end{bmatrix}\n\t\\cdot\n\t[k_1{\\ensuremath{c_{\\textrm{{S}}}}}{\\ensuremath{c_{\\textrm{{E}}}}}\\;\\; \\overbrace{k_2{\\ensuremath{c_{\\textrm{{ES}}}}}}^{v_\\textrm{tx}}\\;\\; \\lambda]^T\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\begin{bmatrix}\\dot{{c_{\\textrm{{S}}}}}(t)\\\\&#10;\\dot{{c_{\\textrm{{E}}}}}(t)\\\\&#10;\\dot{{c_{\\textrm{{ES}}}}}(t)\\\\&#10;\\dot{{c_{\\textrm{{P}}}}}(t)\\\\&#10;\\end{bmatrix}=\\begin{bmatrix}\\par&#10;-1&amp;0&amp;1\\\\&#10;-1&amp;1&amp;0\\\\&#10;1&amp;-1&amp;0\\\\&#10;0&amp;1&amp;0\\\\&#10;\\end{bmatrix}\\cdot[k_{1}{c_{\\textrm{{S}}}}{c_{\\textrm{{E}}}}\\;\\;\\overbrace{k_{%&#10;2}{c_{\\textrm{{ES}}}}}^{v_{\\textrm{tx}}}\\;\\;\\lambda]^{T}\" display=\"block\"><mrow><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mover accent=\"true\"><msub><mi>c</mi><mtext>S</mtext></msub><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mover accent=\"true\"><msub><mi>c</mi><mtext>E</mtext></msub><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mover accent=\"true\"><msub><mi>c</mi><mtext>ES</mtext></msub><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mover accent=\"true\"><msub><mi>c</mi><mtext>P</mtext></msub><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>]</mo></mrow><mo>=</mo><mrow><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u22c5</mo><msup><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>c</mi><mtext>S</mtext></msub><mo>\u2062</mo><mpadded width=\"+5.6pt\"><msub><mi>c</mi><mtext>E</mtext></msub></mpadded><mo>\u2062</mo><mpadded width=\"+5.6pt\"><mover><mover accent=\"true\"><mrow><msub><mi>k</mi><mn>2</mn></msub><mo movablelimits=\"false\">\u2062</mo><msub><mi>c</mi><mtext>ES</mtext></msub></mrow><mo movablelimits=\"false\">\u23de</mo></mover><msub><mi>v</mi><mtext>tx</mtext></msub></mover></mpadded><mo>\u2062</mo><mi>\u03bb</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mi>T</mi></msup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": " \n\nfrom which it draws that when $\\lambda>e_0 k_2$, and thus when {\\ensuremath{c_{\\textrm{{S}}}}} grows\nwithout bounds, the transmission rate $v_\\textrm{tx}^*$ grows asymptotically\ntowards the rate cap of $v_\\textrm{max}$, prescribed in the product of the\nterms $e_0$ and $k_2$.  The ratio $k_2/k_1$ controls how fast the rate limit is\nenforced.\n\n\n\nFrom the transient/sensitivity analysis in \\cite{MoSiTR12}, it stems that the\ncontrol algorithm has a low-pass filtering behaviour. The cut-off frequency is\ndirectly controllable through $k_2$-coefficient (i.e., higher $k_2$ values lead\nto higher cut-off frequencies -- the outgoing traffic from the system is more\nbursty).\n\n\n\n\n\nApart from a fluid-model analysis, one may also study a CA at the\nmicroscopic level with queueing theory (and thus complement\ncontrol/signal theory applied at the macroscopic level) \\cite{MeTh}. A\nmolecular species represents a (virtual) queue and thus, a chemical reaction\ndiagram depicts a network of interacting queues. The queue service process obeys chemical kinetics and has a specific\nmathematical form, which manifests in the system model description and\nanalysis. As a consequence,\nthe relationship between arrival and departure process is not only\npredictable but also exploitable as a design feature in the engineering of the\nalgorithm. Based on this, we are able to design a system ``by queue\ninteractions'' (by applying reaction rules), and prescribe how departure\nprocesses of queues modulate each other.\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Deploying CAs on FPGA technology}\\label{sec:FPGAimplHW}\n{\\color{black}{ After having discussed CAs in general, we now exploit the introduced concepts to describe and implement  a generic programmable hardware platform, particularly suitable for Field Programmable Gate Arrays (FPGAs) technology. }}\n\nFPGAs are the most preferred platform for\nintroducing new network functions close to the hardware. The reasons are the\nfast time-to-market, the low-cost realisation, the extended re-programmability\n(compared to Application Specific Integrated Circuits, ASICs), and the high amount of\navailable logic resources (compared to Complex Programmable Logic Devices, CPLDs).\n\nTo enable a generic programmable deployment of CAs on FPGAs, we sought to provide a\n``chemical engine\" abstraction. This middleware abstraction serves the\nfollowing two key purposes. On one hand, it hides low-level hardware\ndescription in ``chemical\" primitives, which leverage a high-level description of\nCAs through the reaction network representation. On the other hand, it\nconsiderably reduces the programming time of CAs based on a two-level\nconfiguration process.\n\n{\\color{black}{ At low level (level-1), the construction of a chemical engine on the FPGA creates chemical resources and an execution environment. This requires a ``traditional'' slow field-programming process involving synthesis of HDL code and bitstream generation, which is acceptable as a system initialisation (e.g. boot-time) task. The generated execution environment provides all the background functionality for setting up a CA and embodies the chemical kinetics for running it. At high level (level-2), the actual programming of CAs is effected as a configuration task that allocates part of these resources and connects them in the corresponding reaction network. These resources can be re-allocated or modified at any time (through a new level-2 configuration) to implement another CA. That is, the level-2 configuration is the essence of the \\emph{fast runtime} programmability of CAs. }}\n\nFormally, the instantiation of a CA (level-2) within the chemical engine\n(level-1) completes the implementation of a so-called \\emph{Artificial\nChemistry} \\cite{DiZi01}\n\n${\\ensuremath{\\mathcal{AC}}}{}=\\{ \\{ \\mathcal{S}\\},\\{ \\mathcal{R}\\}, \\mathcal{A}\\}$.\n\nThe level-1 generated, chemical engine provides the LoMA reaction scheduling\nlogic $\\mathcal{A}$ in the execution environment. At level-2, configuration\nprovides the structural information (species set $\\{ \\mathcal{S}\\}$ and the\nreaction set $\\{\\mathcal{R}\\}$) for any CA.\n\nIn the following, we present in more detail the key components of this chemical\nmiddleware, and discuss its implementation in an FPGA device by Xilinx.\n\n\n\n\n\n\n\n\n\n\n\\subsection{Chemical Engine Middleware -- Platform Overview} \n\nThe key building blocks (operational modules and functional structures) of the\nengineered chemical middleware platform are shown in the block diagram of\n{Fig.~}\\ref{fig:HW_atGlance}. The runtime operation is divided across three main\nnested modules: \n\n{\\emph{(i)}~}{}the \\texttt{manager} module, \n{\\emph{(ii)}~}{}the {\\ensuremath{\\mathcal{AC}}}{} module that implements one or more\n\\emph{chemical engines} as part of the CA execution environment, and {\\emph{(iii)}~}{} the\n\\texttt{reaction-scheduler} module (LoMA core) that implements the reaction algorithm\n{\\ensuremath{\\mathcal{A}}}{} and schedules reactions for execution.\n\nSpecifically, the \\texttt{manager} module may serve simultaneously (taking\nadvantage of the hardware parallelisation) more than one {\\ensuremath{\\mathcal{AC}}}{} modules, each\nhosting a separate CA. It handles the I/O for each {\\ensuremath{\\mathcal{AC}}}{} module by mapping\ninput and output signals (events such as packet arrivals) to specific species\nof a CA. It also facilitates programming of CA and monitoring of its state by logging\nperiodically the concentration values of selected species. \n\n\n\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[scale=0.22]{HW_atGlance4.pdf}\n\\caption{\n{Block-diagram illustrating the main components of the chemical middleware \nplatform for programming CAs on FPGA hardware.}\n}\n\\label{fig:HW_atGlance}\n\\end{figure}\n\nAn {\\ensuremath{\\mathcal{AC}}}{} module represents the principal component of the implementation of CAs\nin hardware. It hosts in memory the functional data structures (tables) for the\n{structural} representation of a CA -- i.e., species concentrations,\nstoichiometric reactant and product coefficients, and reaction coefficients.\nValues in these structures, which are runtime accessible, {provide} the\ninputs to the hardware logic circuitry embedded in the {\\ensuremath{\\mathcal{AC}}}{} module, which\nimplements the addressing mechanism to inter-wire the CA at runtime.  For\nexample, the values of the stoichiometric memories $\\alpha$ and $\\beta$ decode\nthe addresses of reactant and product concentrations of each reaction.\nSimilarly, the reaction coefficients stored in the $k$ memory affect the\ncomputation of \\emph{next reaction time}.\n\nThe \\texttt{reaction-scheduler} module (LoMA-core) computes the propensity of a reaction\nfrom its reactant concentrations and from the reaction coefficient, and\nproduces as output the time at which a reaction should be executed.  \n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Reaction Network -- CA topology}\n\nThe approach we have adopted to enable runtime programmability of CAs consists\nof two phases: First, during the hardware programming of the FPGA, a ``large\nenough'' grid of chemical resources (in hardware logic circuitry) are reserved.\nSecond, at runtime, these resources are allocated under user-defined\nconfigurations to instantiate different CAs.  {\\color{black}{This involves merely the  setting of values in memory-mapped registers on the FPGA.}}\n\nTo do this, the user defines a number of species, the initial values for their\nconcentrations, and a set of reactions with their coefficients.  This\ninformation ``topologically interconnects'' a\nCA and configures the dynamics of its execution (when reactions occur). In this\nsection, we describe how the reaction network topology is fleshed out on\nhardware following a CA configuration. In the next section, we explain how the\ndynamics of reactions {are} orchestrated.\n\n\n\nEach species is implemented as a register made up of a chain of flip-flops,\nwhose number determines the maximum value (as a power of 2) that a\nconcentration can assume.  \n\n\n\nReaction rule definitions, on the other hand, provide information about\nwhich species engage as reactants, which as products, and in what\nquantities (respective stoichiometric coefficients).\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.126]{StoichMux7.pdf}\n\\caption{\n{Addressing logic for updating reactant concentrations (analogous for product\nconcentrations). (a) 3D organisation of stoichiometric memory of reactants:\nreaction $\\rightarrow$ reactant number $\\rightarrow$ reactant order.  (b)\nCircuitry schematic related to the stoichiometric memory (example for maximum 3\nspecies, 3 reactants per reaction, up to 3rd order reactants).}\n}\n\\label{fig:stoichROM}\n\\end{figure}\n\nThe stoichiometric information of reactants and products is divided in two\nrespective 3D structures, whose top-level index corresponds to each\nindividual reaction ({Fig.~}\\ref{fig:stoichROM}(a)). The size of these tables\n(programmed on the FPGA) defines the maximum resource allocation available to\nthe user for configuring CAs at runtime. The information stored therein is used\nto actuate the \\emph{addressing} and \\emph{computing} logic components of the\nchemical engine, in order to update the species concentrations whenever a\nreaction takes place.  In the following, we will confine our discussion to the\noperations involving the reactants only; analogous description holds for\nproduct species with the sole difference that logic elements for addition\nreplace those for subtraction ({Fig.~}\\ref{fig:stoichROM}(b)).\n\n\n\nThe stoichiometric table $\\alpha$-\\texttt{mem} of reactants ({Fig.~}\\ref{fig:stoichROM}(a)) is\ndimensioned by reaction (1D), by reactant (2D), and by reactant\ncoefficient/order counter (3D).  That is, within each indexed reaction record\nat the 1st-level, there is a sub-indexing of a maximum number of independent\nreactants. In turn, within each indexed reactant at the 2nd-level there is\nanother sub-indexing of records that contains either a reactant species'\naddress (\\emph{active}) or null (\\emph{inactive}). If a reactant\nspecies' address is duplicate in several 3rd-level records, these records\nenumerate the respective reactant coefficient (reactant order). At least one\nactive record implies a 1st-order reactant, which activates the nested\n(2nd-level) indexed reactant position and in turn the outermost (1st-level)\nindexed reaction record.\n\n\n\nAs seen in {Fig.~}\\ref{fig:stoichROM}, the structure of the stoichiometric tables\nreflects the fact that the processing for each indexed reactant (2nd-level)\ntakes place in a separate \\emph{Hardware Logic Slice} (HLS) -- vertical\narrangement.  HLSs can be engaged in parallel in computations of the CA, such\nthat reactions that involve 1st-order reactants (e.g.,\n${\\ensuremath{\\textrm{{S}}}}_1+{\\ensuremath{\\textrm{{S}}}}_2+{\\ensuremath{\\textrm{{S}}}}_3 \\rightarrow \\ldots$) can be processed in\nparallel in a single step. \n\nThe number of \\emph{active} address-records at the 3rd-level (encoding the\nreactant order) enumerates how many processing steps are required to complete\nthe update of reactant state, during the execution of the reaction. 3rd-level\naddress-records directly index a respective number of decoder elements within\neach reactant's HLS. Each decoder is activated in sequence through a step-down\ncounter.  The address stored in each address record of the stoichiometric table\nis input to the decoder so to actuate a subtraction operation on the respective\nspecies concentration.  As a result of this process, a reaction of the sort\n$3{\\ensuremath{\\textrm{{S}}}}_1 \\rightarrow \\ldots$ is computed in a number of steps that reflects\nthe reactant order $({\\ensuremath{\\textrm{{S}}}}_1) + ({\\ensuremath{\\textrm{{S}}}}_1) + ({\\ensuremath{\\textrm{{S}}}}_1) \\rightarrow \\ldots$\n({where} each parenthesis {pair denotes} a single processing step). \n\n\n\nThe \\emph{maximum} number of indexable reactions (1D), reactants-per-reaction (2D) and\nreactant order (3D) records needs to be fixed at the time of programming the\nFPGA. For example, the chemical engine encoding the addressing logic of\n{Fig.~}\\ref{fig:stoichROM}(b) refers to a resource\nreservation (maximum allocations) for 3 species with concentration size up to\n15 molecules, and one indexable reaction with at most 3 reactants/products per\nreaction, and of up to 3rd order each.  \n\nFor 3 species, 2-bit addresses are needed to resolve access to their registers\n(S3, S2, S1), each of which is 4-bit wide (number of flip-flops in each\nregister){, and thus holding} concentration size values $\\leq$ 15. \n\nThe corresponding reactant stoichiometric table (see {Fig.~}\\ref{fig:stoichROM}(a)\nfor reaction $r_1$) indexes reactions (1st-level), each of which {sub-}indexes\nmaximum 3 reactants (2nd-level), each in turn {sub-indexes} maximum 3 address\nrecords (3rd-level) for enumerating the order (maximum of the 3rd order) of a\nreactant.\n\nFor a configured CA that involves a reaction of the form $2{\\ensuremath{\\textrm{{S}}}}_3 +\n{\\ensuremath{\\textrm{{S}}}}_2 \\rightarrow \\ldots$ ({Fig.~}\\ref{fig:stoichROM}), the two reactants\n${\\ensuremath{\\textrm{{S}}}}_2$ and ${\\ensuremath{\\textrm{{S}}}}_3$ occupy two 2nd-level records (out of the three\navailable). The one corresponding to ${\\ensuremath{\\textrm{{S}}}}_3$, which is a 2nd-order\nreactant, has two 3rd-level records (out of three available) filled with the\nspecies address \\texttt{11b} of the ${\\ensuremath{\\textrm{{S}}}}_3$ register. By analogy, for the\n1st-order reactant ${\\ensuremath{\\textrm{{S}}}}_2$, only one 3rd-level record (out of three\navailable) is filled with the species address \\texttt{10b} (refer to\n{Fig.~}\\ref{fig:stoichROM}(a)).\n\nWhen the reaction executes, through the \\texttt{exeReact}-signal, each of\nits reactant species is processed at a different HLS, allowing for their\nparallel computations. I.e., ${\\ensuremath{\\textrm{{S}}}}_3$ will be processed at the frontmost\nHLS, ${\\ensuremath{\\textrm{{S}}}}_2$ at the next, while the last HLS will remain unused since there\nare only two reactants.\n\nWithin each HLS, i.e. for each reactant, the 2-bit species address stored in\neach 3rd-level record of the stoichiometric table is input to one correspondent\ndecoder. For reactant ${\\ensuremath{\\textrm{{S}}}}_3$, its address \\texttt{11b} appears in the\ninputs of two of the three decoders.\n\nThe output of each decoder is read in subsequent steps of the step-down counter\nand activates (\\texttt{EN}-input) a subtracter that decrements by 1\nmolecule (in every step) the contents of the respective species register.  In\neffect, this reduces the concentration of ${\\ensuremath{\\textrm{{S}}}}_3$ by 2 in two steps, and\nrespectively the concentration of ${\\ensuremath{\\textrm{{S}}}}_2$ by 1 in one step.  Overall, the\ndiscussed hardware logic computes\n$2{\\ensuremath{\\textrm{{S}}}}_3 + {\\ensuremath{\\textrm{{S}}}}_2 \\rightarrow \\ldots$~, as $({\\ensuremath{\\textrm{{S}}}}_3 + {\\ensuremath{\\textrm{{S}}}}_2) +\n({\\ensuremath{\\textrm{{S}}}}_3) \\rightarrow \\ldots$~.\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Reaction Scheduling}\n\nReactions are executed in real-time according to a time-schedule that {abides\nto the LoMA} (see {Sect.}\\ref{sec:AC}). Computing the reaction-times schedule is\nthe most costly operation, in terms of hardware logic.\n\n\nAfter a reaction has fired, and the update of species concentrations for\nreactants and products has been performed, a \\emph{{next} reaction-time}\ncomputation is triggered for each dependent reaction (i.e., all reactions whose\nreactant concentrations have been modified).\n\nFor a reaction $r$, this requires to compute the propensity, i.e., the product\nof reactants' concentrations $c_s^{\\alpha_{r,s}}$ and the reaction\ncoefficient~$k_r$, see \\eqref{eq:LoMA}.  The reaction coefficients ${\\mathbf{k}}$\nare stored in a separate bank of registers.\n\n\n\nTo select the (reactant) species needed for {computing the propensity of each\ndependent equation,} we use the hardware logic circuit shown in\n{Fig.~}\\ref{fig:stoichForTime}.\n\n{Just like with the addressing logic for updating the concentrations in the\nprevious section,} we rely on the information from the reactant stoichiometric\ntable to index across HLSs and decoders. {However,} in this case, the output of\neach decoder selects inputs of a chained-up multiplexer. At every\nstep of the counter, one multiplexer outputs the value of the decoded species\nregister (for $s_3\\dots\ns_0=\\texttt{1000}$ it forwards the value of the $S3$-register, for $s_3\\dots\ns_0=\\texttt{0100}$ the value of the $S2$-register, and for $s_3\\dots\ns_0=\\texttt{0010}$ the value of the $S1$-register), or the fixed value\n$\\texttt{1111}$, for the identity element of the multiplication.\n\n\\begin{figure}[!t] \\centering\n\\includegraphics[scale=0.135]{StoichForTime6.pdf} \n\\caption{\n\n{Addressing logic for selecting concentrations to compute reaction\npropensities (example for maximum\n3 species, 3 reactants per reaction, up to 3rd order reactants).}\n}\n\\label{fig:stoichForTime} \n\\end{figure}\n\nOutputs from each HLS {will contribute to the computation of} the power of each\nreactant concentration $c_s^{\\alpha_{r,s}}$ (e.g. $c_{\\textrm S_3}^2$), while\nthe combination of the outputs across HLSs {will} contribute to {the\ncomputation of} the product of reactants' terms $\\prod_{s \\in \\mathcal S}\nc_s^{\\alpha_{r,s}}$ (e.g.  $c_{\\textrm S_3}^2  c_{\\textrm S_2}$).\nTo {complete the computation of} the propensity, these values alongside the\nreaction coefficient $k_r$, are input to a logic module for multiplication.\n\nDepending on the required trade-off {between} logic density and computation\nspeed, this operation can be performed by a single multiplier in as many as $|\\Psi| \\times\n|\\alpha|$ time steps ($|\\Psi|$ being the maximum possible number of reactants,\nand counting in the additional multiplication by $k_r$), or by up to $|\\Psi|$\nparallel scaled-multipliers in as {little} as $|\\alpha|$ time steps.\n\n\nThe computation of the new time schedule thereafter requires {\\emph{(i)}~}{}to compute\nthe reciprocal of the propensity value in order to calculate the next reaction\ntime for the reaction that was just executed, and {\\emph{(ii)}~}{}{possibly to rescale\nthe old propensity value for all dependent reactions, so as to update their\ntime schedules according to new reactant concentrations.}\n\nThis process can be speeded up by parallelising propensity and reaction-time\ncomputations by means of separate \\texttt{reaction-scheduler} modules. The\nnumber of \\texttt{reaction-scheduler} modules (ranging from $1$ to $|\\mathcal\nR|$; from one per {\\ensuremath{\\mathcal{AC}}}{} up to one per reaction) represents the tradeoff between\nspeed and logic utilisation.\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Realisation on Xilinx Spartan-6 FPGA Family}\\label{sec:FPGAimplBoard}\n\nWe have realised the middleware framework for CAs and the chemical engine\nabstraction discussed so far, on a relatively small, low-cost FPGA device: the\nXilinx Spartan-6 XC6SLX9 (see~\\cite{Xi11FPGA} for a general overview on its\nfeatures) mounted on the Avnet Spartan-6 LX9 MicroBoard~\\cite{Av11}.\n\nTo perform computations required in the \\texttt{reaction-scheduler} module, we\nhave used the Xilinx single-precision floating-point IPC~\\cite{Xi12} (compliant\nwith IEEE-754 Standard~\\cite{IE08}), which gives us a wide dynamic range\n($\\sim{\\pm}2^{127}$) and a good resolution (${\\sim}2^{-23}$) for representing\n{floating point} variables during the reaction-time schedule calculations.\n\n\n\nFor the experiments described in the following section, we have programmed the\nchemical middleware platform on the XC6SLX9 FPGA, with resource specifications as shown in\nTable~\\ref{tab1} and Table~\\ref{tab2}.\\footnote{{\\color{black}{Source VHDL codes can be retrieved from the URL http://cn.cs.unibas.ch/projects/HWAC/.}}}  A single\nchemical engine hosts up to 255 species {and} 8 reactions of the {8th} order,\nwith up to 8 reactants {and} products.  For most of the practical applications\nwe have dealt with, reactants/products are of 1st or {2nd} order, and reactions\nrarely involve more than 3-4 reactants and 1-2 products each.\n\nThe $c$-\\texttt{mem}, storing {species} {concentrations}, is 16-bit wide\nallowing concentrations to grow up to $2^{16} - 1$.  Its locations are\ninitialised to $00...0b$, except for the first (reserved) position set to\n$00...1b$.  {Concentrations that are connected to input/output events are\nupdated in batch quantities according to a molecules-per-event ratio.} {The\n$\\alpha$-\\texttt{mem} and $\\beta$-\\texttt{mem} store stoichiometric\ninformation.} The $k$-\\texttt{mem} stores single-precision floating-point\nvalues (32 bits) of reaction coefficients.\n\\begin{table}[t]\n\\centering\n{\\footnotesize\n\\begin{tabular}{c l l}\n\\hline\nparameter           & value  & description \\\\\n\\hline\n\n$|\\mathcal{R}|$  & 8      & max number of reactions \\\\\n\n$|\\Psi|$         &{8}      & max number of reactants/products \\\\\n\n$|\\mathcal{S}|$  & 255    & max number of species \\\\\n\n$|C|$            & 16bit  & max concentration value/size ($2^{|C|} - 1$) \\\\\n\n$|\\alpha|$       &{8}      & max reactant stoichiometric coefficient value\\\\\n\n$|\\beta|$        &{8}      & max product stoichiometric coefficient value\\\\\n\n$|k|$            &{32}bit  & reaction coeff. size (single-precision floating point)\\\\\n\\hline\n\\end{tabular}\n}\n\\caption{\n{Chemical middleware platform resource reservation programmed on the\nXC6SLX9 FPGA for our experiments.}\n}\n\\label{tab1}\n\\end{table} \n\n\n\\begin{table}[t]\n\\centering\n{\\footnotesize\n\\begin{tabular}{c r l}\n\\hline\ntable & &size \\\\\n\\hline\n\n{{$c$}-\\texttt{mem} }  & $|\\mathcal{S}|$ pos &\\texttt{x}\\;\\; $|C|$ bit \\\\\n\n{{$\\alpha$}-\\texttt{mem} }  & ($|\\mathcal{R}|$ \\texttt{x} $|\\Psi|$ \\texttt{x} $|\\alpha|$) pos &\\texttt{x}\\;\\; $log_2(|\\mathcal{S}|$) bit \\\\\n\n{{$\\beta$}-\\texttt{mem} }  & ($|\\mathcal{R}|$ \\texttt{x} $|\\Psi|$ \\texttt{x} $|\\beta|$) pos &\\texttt{x}\\;\\; $log_2(|\\mathcal{S}|$) bit \\\\\n\n{{$k$}-\\texttt{mem} }  & $|\\mathcal{R}|$ pos &\\texttt{x}\\;\\; $|k|$ bit \\\\\n\\hline\n\\end{tabular}\n}\n\\caption{\n{Capacities of CA memories}\n}\n\\label{tab2}\n \\end{table} \n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.8]{reactTimeCompCompact.pdf}\n\\caption{\n{Schematic of the \\texttt{reaction-scheduler} module. It integrates 2 int-to-float and 1 float-to-int converters, 2 multipliers, 2\ndivisors, 2 multiplexers, and 1 counter.}\n}\n\\label{fig:scheme}\n\\end{figure}\n\n\n{Fig.~}\\ref{fig:scheme} shows the hardware logic layout for computing the\nreaction-time schedules. The multiplication of the reactant concentrations is\nperformed iteratively by a single floating-point multiplier only, because of\nrestrictions in the amount of available logic on the XC6SLX9 chip. This\nmeans that we loose in parallelisation because we have limited the number of\nfloating-point operations to two multiplications and two divisions for each\ntime schedule computation. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Evaluation}\\label{sec:expHW}\n\nIn this section, we provide an evaluation of the chemical engine middleware\nplatform based on our prototype implementation in the XILINX Spartan6 FPGA\nfamily. The objectives of this evaluation are \n\n\\begin{itemize}\n\\item to demonstrate the runtime programability on hardware of (chemical)\nalgorithms to control network traffic dynamics \n\\item to quantify the performance gains enabled by running CAs on hardware.\n\\end{itemize} \n\n\\noindent To keep the discussion focused on these evaluation objectives,\n{and avoid introducing new algorithms,} we present the experiments with\nthe exemplary CA that has been used in our discussions until now.\nIn {Sect.}\\ref{sec:discussion}, we briefly report on experiments with\nother CAs and their applications.\n\n\n\n\n\n\n\n\n\n\\subsection{Experiment setup}\\label{sec:expSetup}\n\nWe used CAs to control {the service process of\nthe egress queue of a standard Linux host (Linux, Kernel 3.8.6), and thereby\nshape its outgoing traffic.} \n\n\nWe employ the \\texttt{tc} tool to isolate a class of traffic in a separate FIFO\nqueue. The arrival process of that queue provided the input for the CA: for\neach enqueued packet, an amount of molecules corresponding to the number of\nbytes in the packet was added to an input species {\\ensuremath{\\textrm{{S}}}} in the chemical\nengine. On the other end, an output species {\\ensuremath{\\textrm{{P}}}} was ``connected\" to the\nservice process of the queue: for each {\\ensuremath{\\textrm{{P}}}}-molecule produced, a fixed\nnumber of bytes were allowed to leave the queue; when there were enough\nmolecules to match the byte-size of the packet at the front of the queue, the\npacket was dequeued and transmitted. In both cases, the molecules-to-bytes\nratio was kept fixed at 1 mol/KB. \n\nTo interface the FPGA (LX9) board, where the chemical engine lies, with the\nqueue management subsystem of the linux kernel, we used the \\texttt{Parapin}\nkernel module. \\texttt{Parapin} module allows the use of the PC's parallel port\nas a custom I/O interface (i.e., allows handling interrupts at the port pins,\nand accessing directly the parallel port registers). We then wired one of LX9's\nI/O connectors to the parallel port of the PC. {With such an interfacing, it\nwas possible to produce/process} interrupts every 100~ns.\n\nThe results shown in the graphs that follow concern UDP traffic produced with\nthe \\texttt{iperf} tool (client side running on the controlled node).  {We have\nnot included measurements with TCP traffic because there, effects of the CA\ncontroller are coupled with TCP's control-loop behaviour, and thus are not easy\nto evaluate.}\n\n{{Fig.~}\\ref{fig:HW_enzy_setup} shows the host-to-host topology of the experiment, \nover the high-speed switched network of the university.}\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.25]{HWSetupEnzy3.pdf}\n\\caption[Traffic-rate-controlling experiment -- setup]{\n{Experiment setup to rate control  PC's egress traffic by means of CAs. The\nFPGA hosting the chemical engine was connected to the parallel interface of the\nsender host for facilitating the signalling between the CA and the\nqueue-management subsystem of the linux kernel.}\n}\n\\label{fig:HW_enzy_setup}\n\\end{figure} \n\n\n\n\n\n\n\n\n\n\\subsection{Runtime {programmability on} hardware}\\label{sec:expProgrammability}\n\nTo test and demonstrate the runtime programmability of CAs on {the\nFPGA-embedded} chemical engine, we first instantiated in the system a simple\nCA ({Fig.~}\\ref{fig:LoMARateLim}) that paces packet transmissions by a variable\ntime delay. \n\n{The simple reaction network essentially imposes the LoMA \\eqref{eq:LoMA} as a queue\nservice policy.}\n\nThe CA ``program'' is essentially the following\n{reaction network} specification:\n\n\\begin{figure}[H]\n \\vspace{-0.15in}\n\n\\begin{minipage}[b]{0.99\\linewidth}\n\\footnotesize\n \\centering\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\noindent where the term $k_2{\\ensuremath{c_{\\textrm{{ES}}}}}$ reflects the rate of reaction $r_2$ and\nthus the dequeueing/transmission rate $v_\\textrm{tx}$.\n\nFrom the developer's perspective, the stoichiometric matrix~${\\ensuremath{\\mathbf{\\Xi}}}$ provides the means to program any certain CA, and the reaction\ncoefficient vector ${\\mathbf{k}}$ represents the means to calibrate/tune it.  The\nconcentration vector ${\\mathbf{{c}}}(t)$ then represents changes in the CA's state, as\nthe system evolves over time -- i.e. it is not explicitly controllable.\n\n\nFrom \\eqref{odeChemControl}, it follows (by solving the homogeneous system for\nthe steady state) that so long as $\\lambda<e_0 k_2$, the concentration {\\ensuremath{c_{\\textrm{{S}}}}}\nremains stable and the transmission rate $v_ \\textrm{tx}^*$ follows the packet\narrival rate $\\lambda$ (see \\cite{MoSiTR12} for more details).\n\n\n\nOn the other hand, by applying the mass conservation law\n(${\\ensuremath{c_{\\textrm{{E}}}}}+{\\ensuremath{c_{\\textrm{{ES}}}}}=e_0$), one arrives to the Michaelis-Menten (biochemical)\nequation: \n\n\n", "index": 11, "text": "\\begin{equation*} v_ \\textrm{tx}^* = k_2 {\\ensuremath{c_{\\textrm{{ES}}}}} = \\overbrace{ e_0\nk_2}^{v_\\textrm{max}}\\frac{ {\\ensuremath{c_{\\textrm{{S}}}}}}{(k_2/k_1)+{\\ensuremath{c_{\\textrm{{S}}}}}}\\;\\; , \\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"v_{\\textrm{tx}}^{*}=k_{2}{c_{\\textrm{{ES}}}}=\\overbrace{e_{0}k_{2}}^{v_{%&#10;\\textrm{max}}}\\frac{{c_{\\textrm{{S}}}}}{(k_{2}/k_{1})+{c_{\\textrm{{S}}}}}\\;\\;,\" display=\"block\"><mrow><mrow><msubsup><mi>v</mi><mtext>tx</mtext><mo>*</mo></msubsup><mo>=</mo><mrow><msub><mi>k</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>c</mi><mtext>ES</mtext></msub></mrow><mo>=</mo><mrow><mover><mover accent=\"true\"><mrow><msub><mi>e</mi><mn>0</mn></msub><mo movablelimits=\"false\">\u2062</mo><msub><mi>k</mi><mn>2</mn></msub></mrow><mo movablelimits=\"false\">\u23de</mo></mover><msub><mi>v</mi><mtext>max</mtext></msub></mover><mo>\u2062</mo><mpadded width=\"+5.6pt\"><mfrac><msub><mi>c</mi><mtext>S</mtext></msub><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>k</mi><mn>2</mn></msub><mo>/</mo><msub><mi>k</mi><mn>1</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><msub><mi>c</mi><mtext>S</mtext></msub></mrow></mfrac></mpadded></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": " \n \n", "itemtype": "equation", "pos": -1, "prevtext": " \n\nfrom which it draws that when $\\lambda>e_0 k_2$, and thus when {\\ensuremath{c_{\\textrm{{S}}}}} grows\nwithout bounds, the transmission rate $v_\\textrm{tx}^*$ grows asymptotically\ntowards the rate cap of $v_\\textrm{max}$, prescribed in the product of the\nterms $e_0$ and $k_2$.  The ratio $k_2/k_1$ controls how fast the rate limit is\nenforced.\n\n\n\nFrom the transient/sensitivity analysis in \\cite{MoSiTR12}, it stems that the\ncontrol algorithm has a low-pass filtering behaviour. The cut-off frequency is\ndirectly controllable through $k_2$-coefficient (i.e., higher $k_2$ values lead\nto higher cut-off frequencies -- the outgoing traffic from the system is more\nbursty).\n\n\n\n\n\nApart from a fluid-model analysis, one may also study a CA at the\nmicroscopic level with queueing theory (and thus complement\ncontrol/signal theory applied at the macroscopic level) \\cite{MeTh}. A\nmolecular species represents a (virtual) queue and thus, a chemical reaction\ndiagram depicts a network of interacting queues. The queue service process obeys chemical kinetics and has a specific\nmathematical form, which manifests in the system model description and\nanalysis. As a consequence,\nthe relationship between arrival and departure process is not only\npredictable but also exploitable as a design feature in the engineering of the\nalgorithm. Based on this, we are able to design a system ``by queue\ninteractions'' (by applying reaction rules), and prescribe how departure\nprocesses of queues modulate each other.\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Deploying CAs on FPGA technology}\\label{sec:FPGAimplHW}\n{\\color{black}{ After having discussed CAs in general, we now exploit the introduced concepts to describe and implement  a generic programmable hardware platform, particularly suitable for Field Programmable Gate Arrays (FPGAs) technology. }}\n\nFPGAs are the most preferred platform for\nintroducing new network functions close to the hardware. The reasons are the\nfast time-to-market, the low-cost realisation, the extended re-programmability\n(compared to Application Specific Integrated Circuits, ASICs), and the high amount of\navailable logic resources (compared to Complex Programmable Logic Devices, CPLDs).\n\nTo enable a generic programmable deployment of CAs on FPGAs, we sought to provide a\n``chemical engine\" abstraction. This middleware abstraction serves the\nfollowing two key purposes. On one hand, it hides low-level hardware\ndescription in ``chemical\" primitives, which leverage a high-level description of\nCAs through the reaction network representation. On the other hand, it\nconsiderably reduces the programming time of CAs based on a two-level\nconfiguration process.\n\n{\\color{black}{ At low level (level-1), the construction of a chemical engine on the FPGA creates chemical resources and an execution environment. This requires a ``traditional'' slow field-programming process involving synthesis of HDL code and bitstream generation, which is acceptable as a system initialisation (e.g. boot-time) task. The generated execution environment provides all the background functionality for setting up a CA and embodies the chemical kinetics for running it. At high level (level-2), the actual programming of CAs is effected as a configuration task that allocates part of these resources and connects them in the corresponding reaction network. These resources can be re-allocated or modified at any time (through a new level-2 configuration) to implement another CA. That is, the level-2 configuration is the essence of the \\emph{fast runtime} programmability of CAs. }}\n\nFormally, the instantiation of a CA (level-2) within the chemical engine\n(level-1) completes the implementation of a so-called \\emph{Artificial\nChemistry} \\cite{DiZi01}\n\n${\\ensuremath{\\mathcal{AC}}}{}=\\{ \\{ \\mathcal{S}\\},\\{ \\mathcal{R}\\}, \\mathcal{A}\\}$.\n\nThe level-1 generated, chemical engine provides the LoMA reaction scheduling\nlogic $\\mathcal{A}$ in the execution environment. At level-2, configuration\nprovides the structural information (species set $\\{ \\mathcal{S}\\}$ and the\nreaction set $\\{\\mathcal{R}\\}$) for any CA.\n\nIn the following, we present in more detail the key components of this chemical\nmiddleware, and discuss its implementation in an FPGA device by Xilinx.\n\n\n\n\n\n\n\n\n\n\n\\subsection{Chemical Engine Middleware -- Platform Overview} \n\nThe key building blocks (operational modules and functional structures) of the\nengineered chemical middleware platform are shown in the block diagram of\n{Fig.~}\\ref{fig:HW_atGlance}. The runtime operation is divided across three main\nnested modules: \n\n{\\emph{(i)}~}{}the \\texttt{manager} module, \n{\\emph{(ii)}~}{}the {\\ensuremath{\\mathcal{AC}}}{} module that implements one or more\n\\emph{chemical engines} as part of the CA execution environment, and {\\emph{(iii)}~}{} the\n\\texttt{reaction-scheduler} module (LoMA core) that implements the reaction algorithm\n{\\ensuremath{\\mathcal{A}}}{} and schedules reactions for execution.\n\nSpecifically, the \\texttt{manager} module may serve simultaneously (taking\nadvantage of the hardware parallelisation) more than one {\\ensuremath{\\mathcal{AC}}}{} modules, each\nhosting a separate CA. It handles the I/O for each {\\ensuremath{\\mathcal{AC}}}{} module by mapping\ninput and output signals (events such as packet arrivals) to specific species\nof a CA. It also facilitates programming of CA and monitoring of its state by logging\nperiodically the concentration values of selected species. \n\n\n\n\\begin{figure}[!t]\n\\centering\n\\includegraphics[scale=0.22]{HW_atGlance4.pdf}\n\\caption{\n{Block-diagram illustrating the main components of the chemical middleware \nplatform for programming CAs on FPGA hardware.}\n}\n\\label{fig:HW_atGlance}\n\\end{figure}\n\nAn {\\ensuremath{\\mathcal{AC}}}{} module represents the principal component of the implementation of CAs\nin hardware. It hosts in memory the functional data structures (tables) for the\n{structural} representation of a CA -- i.e., species concentrations,\nstoichiometric reactant and product coefficients, and reaction coefficients.\nValues in these structures, which are runtime accessible, {provide} the\ninputs to the hardware logic circuitry embedded in the {\\ensuremath{\\mathcal{AC}}}{} module, which\nimplements the addressing mechanism to inter-wire the CA at runtime.  For\nexample, the values of the stoichiometric memories $\\alpha$ and $\\beta$ decode\nthe addresses of reactant and product concentrations of each reaction.\nSimilarly, the reaction coefficients stored in the $k$ memory affect the\ncomputation of \\emph{next reaction time}.\n\nThe \\texttt{reaction-scheduler} module (LoMA-core) computes the propensity of a reaction\nfrom its reactant concentrations and from the reaction coefficient, and\nproduces as output the time at which a reaction should be executed.  \n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Reaction Network -- CA topology}\n\nThe approach we have adopted to enable runtime programmability of CAs consists\nof two phases: First, during the hardware programming of the FPGA, a ``large\nenough'' grid of chemical resources (in hardware logic circuitry) are reserved.\nSecond, at runtime, these resources are allocated under user-defined\nconfigurations to instantiate different CAs.  {\\color{black}{This involves merely the  setting of values in memory-mapped registers on the FPGA.}}\n\nTo do this, the user defines a number of species, the initial values for their\nconcentrations, and a set of reactions with their coefficients.  This\ninformation ``topologically interconnects'' a\nCA and configures the dynamics of its execution (when reactions occur). In this\nsection, we describe how the reaction network topology is fleshed out on\nhardware following a CA configuration. In the next section, we explain how the\ndynamics of reactions {are} orchestrated.\n\n\n\nEach species is implemented as a register made up of a chain of flip-flops,\nwhose number determines the maximum value (as a power of 2) that a\nconcentration can assume.  \n\n\n\nReaction rule definitions, on the other hand, provide information about\nwhich species engage as reactants, which as products, and in what\nquantities (respective stoichiometric coefficients).\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.126]{StoichMux7.pdf}\n\\caption{\n{Addressing logic for updating reactant concentrations (analogous for product\nconcentrations). (a) 3D organisation of stoichiometric memory of reactants:\nreaction $\\rightarrow$ reactant number $\\rightarrow$ reactant order.  (b)\nCircuitry schematic related to the stoichiometric memory (example for maximum 3\nspecies, 3 reactants per reaction, up to 3rd order reactants).}\n}\n\\label{fig:stoichROM}\n\\end{figure}\n\nThe stoichiometric information of reactants and products is divided in two\nrespective 3D structures, whose top-level index corresponds to each\nindividual reaction ({Fig.~}\\ref{fig:stoichROM}(a)). The size of these tables\n(programmed on the FPGA) defines the maximum resource allocation available to\nthe user for configuring CAs at runtime. The information stored therein is used\nto actuate the \\emph{addressing} and \\emph{computing} logic components of the\nchemical engine, in order to update the species concentrations whenever a\nreaction takes place.  In the following, we will confine our discussion to the\noperations involving the reactants only; analogous description holds for\nproduct species with the sole difference that logic elements for addition\nreplace those for subtraction ({Fig.~}\\ref{fig:stoichROM}(b)).\n\n\n\nThe stoichiometric table $\\alpha$-\\texttt{mem} of reactants ({Fig.~}\\ref{fig:stoichROM}(a)) is\ndimensioned by reaction (1D), by reactant (2D), and by reactant\ncoefficient/order counter (3D).  That is, within each indexed reaction record\nat the 1st-level, there is a sub-indexing of a maximum number of independent\nreactants. In turn, within each indexed reactant at the 2nd-level there is\nanother sub-indexing of records that contains either a reactant species'\naddress (\\emph{active}) or null (\\emph{inactive}). If a reactant\nspecies' address is duplicate in several 3rd-level records, these records\nenumerate the respective reactant coefficient (reactant order). At least one\nactive record implies a 1st-order reactant, which activates the nested\n(2nd-level) indexed reactant position and in turn the outermost (1st-level)\nindexed reaction record.\n\n\n\nAs seen in {Fig.~}\\ref{fig:stoichROM}, the structure of the stoichiometric tables\nreflects the fact that the processing for each indexed reactant (2nd-level)\ntakes place in a separate \\emph{Hardware Logic Slice} (HLS) -- vertical\narrangement.  HLSs can be engaged in parallel in computations of the CA, such\nthat reactions that involve 1st-order reactants (e.g.,\n${\\ensuremath{\\textrm{{S}}}}_1+{\\ensuremath{\\textrm{{S}}}}_2+{\\ensuremath{\\textrm{{S}}}}_3 \\rightarrow \\ldots$) can be processed in\nparallel in a single step. \n\nThe number of \\emph{active} address-records at the 3rd-level (encoding the\nreactant order) enumerates how many processing steps are required to complete\nthe update of reactant state, during the execution of the reaction. 3rd-level\naddress-records directly index a respective number of decoder elements within\neach reactant's HLS. Each decoder is activated in sequence through a step-down\ncounter.  The address stored in each address record of the stoichiometric table\nis input to the decoder so to actuate a subtraction operation on the respective\nspecies concentration.  As a result of this process, a reaction of the sort\n$3{\\ensuremath{\\textrm{{S}}}}_1 \\rightarrow \\ldots$ is computed in a number of steps that reflects\nthe reactant order $({\\ensuremath{\\textrm{{S}}}}_1) + ({\\ensuremath{\\textrm{{S}}}}_1) + ({\\ensuremath{\\textrm{{S}}}}_1) \\rightarrow \\ldots$\n({where} each parenthesis {pair denotes} a single processing step). \n\n\n\nThe \\emph{maximum} number of indexable reactions (1D), reactants-per-reaction (2D) and\nreactant order (3D) records needs to be fixed at the time of programming the\nFPGA. For example, the chemical engine encoding the addressing logic of\n{Fig.~}\\ref{fig:stoichROM}(b) refers to a resource\nreservation (maximum allocations) for 3 species with concentration size up to\n15 molecules, and one indexable reaction with at most 3 reactants/products per\nreaction, and of up to 3rd order each.  \n\nFor 3 species, 2-bit addresses are needed to resolve access to their registers\n(S3, S2, S1), each of which is 4-bit wide (number of flip-flops in each\nregister){, and thus holding} concentration size values $\\leq$ 15. \n\nThe corresponding reactant stoichiometric table (see {Fig.~}\\ref{fig:stoichROM}(a)\nfor reaction $r_1$) indexes reactions (1st-level), each of which {sub-}indexes\nmaximum 3 reactants (2nd-level), each in turn {sub-indexes} maximum 3 address\nrecords (3rd-level) for enumerating the order (maximum of the 3rd order) of a\nreactant.\n\nFor a configured CA that involves a reaction of the form $2{\\ensuremath{\\textrm{{S}}}}_3 +\n{\\ensuremath{\\textrm{{S}}}}_2 \\rightarrow \\ldots$ ({Fig.~}\\ref{fig:stoichROM}), the two reactants\n${\\ensuremath{\\textrm{{S}}}}_2$ and ${\\ensuremath{\\textrm{{S}}}}_3$ occupy two 2nd-level records (out of the three\navailable). The one corresponding to ${\\ensuremath{\\textrm{{S}}}}_3$, which is a 2nd-order\nreactant, has two 3rd-level records (out of three available) filled with the\nspecies address \\texttt{11b} of the ${\\ensuremath{\\textrm{{S}}}}_3$ register. By analogy, for the\n1st-order reactant ${\\ensuremath{\\textrm{{S}}}}_2$, only one 3rd-level record (out of three\navailable) is filled with the species address \\texttt{10b} (refer to\n{Fig.~}\\ref{fig:stoichROM}(a)).\n\nWhen the reaction executes, through the \\texttt{exeReact}-signal, each of\nits reactant species is processed at a different HLS, allowing for their\nparallel computations. I.e., ${\\ensuremath{\\textrm{{S}}}}_3$ will be processed at the frontmost\nHLS, ${\\ensuremath{\\textrm{{S}}}}_2$ at the next, while the last HLS will remain unused since there\nare only two reactants.\n\nWithin each HLS, i.e. for each reactant, the 2-bit species address stored in\neach 3rd-level record of the stoichiometric table is input to one correspondent\ndecoder. For reactant ${\\ensuremath{\\textrm{{S}}}}_3$, its address \\texttt{11b} appears in the\ninputs of two of the three decoders.\n\nThe output of each decoder is read in subsequent steps of the step-down counter\nand activates (\\texttt{EN}-input) a subtracter that decrements by 1\nmolecule (in every step) the contents of the respective species register.  In\neffect, this reduces the concentration of ${\\ensuremath{\\textrm{{S}}}}_3$ by 2 in two steps, and\nrespectively the concentration of ${\\ensuremath{\\textrm{{S}}}}_2$ by 1 in one step.  Overall, the\ndiscussed hardware logic computes\n$2{\\ensuremath{\\textrm{{S}}}}_3 + {\\ensuremath{\\textrm{{S}}}}_2 \\rightarrow \\ldots$~, as $({\\ensuremath{\\textrm{{S}}}}_3 + {\\ensuremath{\\textrm{{S}}}}_2) +\n({\\ensuremath{\\textrm{{S}}}}_3) \\rightarrow \\ldots$~.\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Reaction Scheduling}\n\nReactions are executed in real-time according to a time-schedule that {abides\nto the LoMA} (see {Sect.}\\ref{sec:AC}). Computing the reaction-times schedule is\nthe most costly operation, in terms of hardware logic.\n\n\nAfter a reaction has fired, and the update of species concentrations for\nreactants and products has been performed, a \\emph{{next} reaction-time}\ncomputation is triggered for each dependent reaction (i.e., all reactions whose\nreactant concentrations have been modified).\n\nFor a reaction $r$, this requires to compute the propensity, i.e., the product\nof reactants' concentrations $c_s^{\\alpha_{r,s}}$ and the reaction\ncoefficient~$k_r$, see \\eqref{eq:LoMA}.  The reaction coefficients ${\\mathbf{k}}$\nare stored in a separate bank of registers.\n\n\n\nTo select the (reactant) species needed for {computing the propensity of each\ndependent equation,} we use the hardware logic circuit shown in\n{Fig.~}\\ref{fig:stoichForTime}.\n\n{Just like with the addressing logic for updating the concentrations in the\nprevious section,} we rely on the information from the reactant stoichiometric\ntable to index across HLSs and decoders. {However,} in this case, the output of\neach decoder selects inputs of a chained-up multiplexer. At every\nstep of the counter, one multiplexer outputs the value of the decoded species\nregister (for $s_3\\dots\ns_0=\\texttt{1000}$ it forwards the value of the $S3$-register, for $s_3\\dots\ns_0=\\texttt{0100}$ the value of the $S2$-register, and for $s_3\\dots\ns_0=\\texttt{0010}$ the value of the $S1$-register), or the fixed value\n$\\texttt{1111}$, for the identity element of the multiplication.\n\n\\begin{figure}[!t] \\centering\n\\includegraphics[scale=0.135]{StoichForTime6.pdf} \n\\caption{\n\n{Addressing logic for selecting concentrations to compute reaction\npropensities (example for maximum\n3 species, 3 reactants per reaction, up to 3rd order reactants).}\n}\n\\label{fig:stoichForTime} \n\\end{figure}\n\nOutputs from each HLS {will contribute to the computation of} the power of each\nreactant concentration $c_s^{\\alpha_{r,s}}$ (e.g. $c_{\\textrm S_3}^2$), while\nthe combination of the outputs across HLSs {will} contribute to {the\ncomputation of} the product of reactants' terms $\\prod_{s \\in \\mathcal S}\nc_s^{\\alpha_{r,s}}$ (e.g.  $c_{\\textrm S_3}^2  c_{\\textrm S_2}$).\nTo {complete the computation of} the propensity, these values alongside the\nreaction coefficient $k_r$, are input to a logic module for multiplication.\n\nDepending on the required trade-off {between} logic density and computation\nspeed, this operation can be performed by a single multiplier in as many as $|\\Psi| \\times\n|\\alpha|$ time steps ($|\\Psi|$ being the maximum possible number of reactants,\nand counting in the additional multiplication by $k_r$), or by up to $|\\Psi|$\nparallel scaled-multipliers in as {little} as $|\\alpha|$ time steps.\n\n\nThe computation of the new time schedule thereafter requires {\\emph{(i)}~}{}to compute\nthe reciprocal of the propensity value in order to calculate the next reaction\ntime for the reaction that was just executed, and {\\emph{(ii)}~}{}{possibly to rescale\nthe old propensity value for all dependent reactions, so as to update their\ntime schedules according to new reactant concentrations.}\n\nThis process can be speeded up by parallelising propensity and reaction-time\ncomputations by means of separate \\texttt{reaction-scheduler} modules. The\nnumber of \\texttt{reaction-scheduler} modules (ranging from $1$ to $|\\mathcal\nR|$; from one per {\\ensuremath{\\mathcal{AC}}}{} up to one per reaction) represents the tradeoff between\nspeed and logic utilisation.\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Realisation on Xilinx Spartan-6 FPGA Family}\\label{sec:FPGAimplBoard}\n\nWe have realised the middleware framework for CAs and the chemical engine\nabstraction discussed so far, on a relatively small, low-cost FPGA device: the\nXilinx Spartan-6 XC6SLX9 (see~\\cite{Xi11FPGA} for a general overview on its\nfeatures) mounted on the Avnet Spartan-6 LX9 MicroBoard~\\cite{Av11}.\n\nTo perform computations required in the \\texttt{reaction-scheduler} module, we\nhave used the Xilinx single-precision floating-point IPC~\\cite{Xi12} (compliant\nwith IEEE-754 Standard~\\cite{IE08}), which gives us a wide dynamic range\n($\\sim{\\pm}2^{127}$) and a good resolution (${\\sim}2^{-23}$) for representing\n{floating point} variables during the reaction-time schedule calculations.\n\n\n\nFor the experiments described in the following section, we have programmed the\nchemical middleware platform on the XC6SLX9 FPGA, with resource specifications as shown in\nTable~\\ref{tab1} and Table~\\ref{tab2}.\\footnote{{\\color{black}{Source VHDL codes can be retrieved from the URL http://cn.cs.unibas.ch/projects/HWAC/.}}}  A single\nchemical engine hosts up to 255 species {and} 8 reactions of the {8th} order,\nwith up to 8 reactants {and} products.  For most of the practical applications\nwe have dealt with, reactants/products are of 1st or {2nd} order, and reactions\nrarely involve more than 3-4 reactants and 1-2 products each.\n\nThe $c$-\\texttt{mem}, storing {species} {concentrations}, is 16-bit wide\nallowing concentrations to grow up to $2^{16} - 1$.  Its locations are\ninitialised to $00...0b$, except for the first (reserved) position set to\n$00...1b$.  {Concentrations that are connected to input/output events are\nupdated in batch quantities according to a molecules-per-event ratio.} {The\n$\\alpha$-\\texttt{mem} and $\\beta$-\\texttt{mem} store stoichiometric\ninformation.} The $k$-\\texttt{mem} stores single-precision floating-point\nvalues (32 bits) of reaction coefficients.\n\\begin{table}[t]\n\\centering\n{\\footnotesize\n\\begin{tabular}{c l l}\n\\hline\nparameter           & value  & description \\\\\n\\hline\n\n$|\\mathcal{R}|$  & 8      & max number of reactions \\\\\n\n$|\\Psi|$         &{8}      & max number of reactants/products \\\\\n\n$|\\mathcal{S}|$  & 255    & max number of species \\\\\n\n$|C|$            & 16bit  & max concentration value/size ($2^{|C|} - 1$) \\\\\n\n$|\\alpha|$       &{8}      & max reactant stoichiometric coefficient value\\\\\n\n$|\\beta|$        &{8}      & max product stoichiometric coefficient value\\\\\n\n$|k|$            &{32}bit  & reaction coeff. size (single-precision floating point)\\\\\n\\hline\n\\end{tabular}\n}\n\\caption{\n{Chemical middleware platform resource reservation programmed on the\nXC6SLX9 FPGA for our experiments.}\n}\n\\label{tab1}\n\\end{table} \n\n\n\\begin{table}[t]\n\\centering\n{\\footnotesize\n\\begin{tabular}{c r l}\n\\hline\ntable & &size \\\\\n\\hline\n\n{{$c$}-\\texttt{mem} }  & $|\\mathcal{S}|$ pos &\\texttt{x}\\;\\; $|C|$ bit \\\\\n\n{{$\\alpha$}-\\texttt{mem} }  & ($|\\mathcal{R}|$ \\texttt{x} $|\\Psi|$ \\texttt{x} $|\\alpha|$) pos &\\texttt{x}\\;\\; $log_2(|\\mathcal{S}|$) bit \\\\\n\n{{$\\beta$}-\\texttt{mem} }  & ($|\\mathcal{R}|$ \\texttt{x} $|\\Psi|$ \\texttt{x} $|\\beta|$) pos &\\texttt{x}\\;\\; $log_2(|\\mathcal{S}|$) bit \\\\\n\n{{$k$}-\\texttt{mem} }  & $|\\mathcal{R}|$ pos &\\texttt{x}\\;\\; $|k|$ bit \\\\\n\\hline\n\\end{tabular}\n}\n\\caption{\n{Capacities of CA memories}\n}\n\\label{tab2}\n \\end{table} \n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.8]{reactTimeCompCompact.pdf}\n\\caption{\n{Schematic of the \\texttt{reaction-scheduler} module. It integrates 2 int-to-float and 1 float-to-int converters, 2 multipliers, 2\ndivisors, 2 multiplexers, and 1 counter.}\n}\n\\label{fig:scheme}\n\\end{figure}\n\n\n{Fig.~}\\ref{fig:scheme} shows the hardware logic layout for computing the\nreaction-time schedules. The multiplication of the reactant concentrations is\nperformed iteratively by a single floating-point multiplier only, because of\nrestrictions in the amount of available logic on the XC6SLX9 chip. This\nmeans that we loose in parallelisation because we have limited the number of\nfloating-point operations to two multiplications and two divisions for each\ntime schedule computation. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Evaluation}\\label{sec:expHW}\n\nIn this section, we provide an evaluation of the chemical engine middleware\nplatform based on our prototype implementation in the XILINX Spartan6 FPGA\nfamily. The objectives of this evaluation are \n\n\\begin{itemize}\n\\item to demonstrate the runtime programability on hardware of (chemical)\nalgorithms to control network traffic dynamics \n\\item to quantify the performance gains enabled by running CAs on hardware.\n\\end{itemize} \n\n\\noindent To keep the discussion focused on these evaluation objectives,\n{and avoid introducing new algorithms,} we present the experiments with\nthe exemplary CA that has been used in our discussions until now.\nIn {Sect.}\\ref{sec:discussion}, we briefly report on experiments with\nother CAs and their applications.\n\n\n\n\n\n\n\n\n\n\\subsection{Experiment setup}\\label{sec:expSetup}\n\nWe used CAs to control {the service process of\nthe egress queue of a standard Linux host (Linux, Kernel 3.8.6), and thereby\nshape its outgoing traffic.} \n\n\nWe employ the \\texttt{tc} tool to isolate a class of traffic in a separate FIFO\nqueue. The arrival process of that queue provided the input for the CA: for\neach enqueued packet, an amount of molecules corresponding to the number of\nbytes in the packet was added to an input species {\\ensuremath{\\textrm{{S}}}} in the chemical\nengine. On the other end, an output species {\\ensuremath{\\textrm{{P}}}} was ``connected\" to the\nservice process of the queue: for each {\\ensuremath{\\textrm{{P}}}}-molecule produced, a fixed\nnumber of bytes were allowed to leave the queue; when there were enough\nmolecules to match the byte-size of the packet at the front of the queue, the\npacket was dequeued and transmitted. In both cases, the molecules-to-bytes\nratio was kept fixed at 1 mol/KB. \n\nTo interface the FPGA (LX9) board, where the chemical engine lies, with the\nqueue management subsystem of the linux kernel, we used the \\texttt{Parapin}\nkernel module. \\texttt{Parapin} module allows the use of the PC's parallel port\nas a custom I/O interface (i.e., allows handling interrupts at the port pins,\nand accessing directly the parallel port registers). We then wired one of LX9's\nI/O connectors to the parallel port of the PC. {With such an interfacing, it\nwas possible to produce/process} interrupts every 100~ns.\n\nThe results shown in the graphs that follow concern UDP traffic produced with\nthe \\texttt{iperf} tool (client side running on the controlled node).  {We have\nnot included measurements with TCP traffic because there, effects of the CA\ncontroller are coupled with TCP's control-loop behaviour, and thus are not easy\nto evaluate.}\n\n{{Fig.~}\\ref{fig:HW_enzy_setup} shows the host-to-host topology of the experiment, \nover the high-speed switched network of the university.}\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale=0.25]{HWSetupEnzy3.pdf}\n\\caption[Traffic-rate-controlling experiment -- setup]{\n{Experiment setup to rate control  PC's egress traffic by means of CAs. The\nFPGA hosting the chemical engine was connected to the parallel interface of the\nsender host for facilitating the signalling between the CA and the\nqueue-management subsystem of the linux kernel.}\n}\n\\label{fig:HW_enzy_setup}\n\\end{figure} \n\n\n\n\n\n\n\n\n\n\\subsection{Runtime {programmability on} hardware}\\label{sec:expProgrammability}\n\nTo test and demonstrate the runtime programmability of CAs on {the\nFPGA-embedded} chemical engine, we first instantiated in the system a simple\nCA ({Fig.~}\\ref{fig:LoMARateLim}) that paces packet transmissions by a variable\ntime delay. \n\n{The simple reaction network essentially imposes the LoMA \\eqref{eq:LoMA} as a queue\nservice policy.}\n\nThe CA ``program'' is essentially the following\n{reaction network} specification:\n\n\\begin{figure}[H]\n \\vspace{-0.15in}\n\n\\begin{minipage}[b]{0.99\\linewidth}\n\\footnotesize\n \\centering\n\n", "index": 13, "text": "\\begin{equation*}\\label{eq:HWlomaAC}\n\\mathcal{S}=\\{{\\ensuremath{\\textrm{{S}}}}, {\\ensuremath{\\textrm{{P}}}}\\}, \n\\,\\,\\,\\,\\mathcal{R}=\n\\{r_0\\}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\mathcal{S}=\\{{\\textrm{{S}}},{\\textrm{{P}}}\\},\\,\\,\\,\\,\\mathcal{R}=\\{r_{0}\\}\" display=\"block\"><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mtext>S</mtext><mo>,</mo><mtext>P</mtext><mo stretchy=\"false\">}</mo></mrow></mrow><mo rspace=\"9.3pt\">,</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>r</mi><mn>0</mn></msub><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n\\end{minipage}\n\n\\label{fig:LoMAHWConfig}\n \\vspace{-0.15in}\n\\end{figure}\n\nIn the first $5~s$ of the experiment (see {Fig.~}\\ref{fig:expHWEnzyControl}), the\noutput rate followed the average load of the queue. At the same time the\nburstiness of the arrival process was smoothed out (filtering of high frequency\ncomponents). The cut-off frequency for such a filtering was set via\n$k_0$-coefficient (=$20$~s$^{-1}$).\n\n\\begin{figure}[t]\n \\center\n \n \\begin{minipage}[b]{.52\\linewidth}\n  \\centering\n  \\centerline{\\includegraphics[width =4.5cm]{lomaHost_W.pdf}}\n  \n  \\centerline{(a) System}\n \\end{minipage}\n \n \\begin{minipage}[b]{0.45\\linewidth}\n  \\centering\n  \n", "itemtype": "equation", "pos": 55958, "prevtext": " \n \n", "index": 15, "text": "\\begin{equation*}\n \\begin{tabular}{ c}\n $c_{\\ensuremath{\\textrm{{S}}}}^0=c_{\\ensuremath{\\textrm{{P}}}}^0=0,\\,\\,\\,\\,\\,k_0=20$~s$^{-1}$\\\\\\\\\n \\end{tabular}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1.m1\" class=\"ltx_Math\" alttext=\"c_{\\textrm{{S}}}^{0}=c_{\\textrm{{P}}}^{0}=0,\\,\\,\\,\\,\\,k_{0}=20\" display=\"inline\"><mrow><mrow><msubsup><mi>c</mi><mtext>S</mtext><mn>0</mn></msubsup><mo>=</mo><msubsup><mi>c</mi><mtext>P</mtext><mn>0</mn></msubsup><mo>=</mo><mn>0</mn></mrow><mo rspace=\"11pt\">,</mo><mrow><msub><mi>k</mi><mn>0</mn></msub><mo>=</mo><mn>20</mn></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1.m2\" class=\"ltx_Math\" alttext=\"{}^{-1}\" display=\"inline\"><msup><mi/><mrow><mo>-</mo><mn>1</mn></mrow></msup></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n  \n  \\centerline{(b) Reaction}\n \\end{minipage}\n \\caption{\n {\\texttt{Rnet2}: Simple reaction network enforcing the LoMA (eq.\\eqref{eq:LoMA}) as a queue service process, so as to implement a traffic pacer.}\n}\n \\label{fig:LoMARateLim}\n\\end{figure}\n\nAfter $t=5~s$, we re-programmed the {\\ensuremath{\\mathcal{AC}}}{} with \\texttt{Rnet1}\n(enzymatic rate controller -- see {{Fig.~}\\ref{fig:ChemRateLim}}), by loading the\nfollowing CA specification:\n\n\\begin{figure}[H]\n \\vspace{-0.15in}\n\n\\begin{minipage}[b]{0.99\\linewidth}\n\\footnotesize\n \\centering\n\n", "itemtype": "equation", "pos": 56779, "prevtext": "\n\\end{minipage}\n\n\\label{fig:LoMAHWConfig}\n \\vspace{-0.15in}\n\\end{figure}\n\nIn the first $5~s$ of the experiment (see {Fig.~}\\ref{fig:expHWEnzyControl}), the\noutput rate followed the average load of the queue. At the same time the\nburstiness of the arrival process was smoothed out (filtering of high frequency\ncomponents). The cut-off frequency for such a filtering was set via\n$k_0$-coefficient (=$20$~s$^{-1}$).\n\n\\begin{figure}[t]\n \\center\n \n \\begin{minipage}[b]{.52\\linewidth}\n  \\centering\n  \\centerline{\\includegraphics[width =4.5cm]{lomaHost_W.pdf}}\n  \n  \\centerline{(a) System}\n \\end{minipage}\n \n \\begin{minipage}[b]{0.45\\linewidth}\n  \\centering\n  \n", "index": 17, "text": "\\begin{equation}\n  \t r_\\textrm{0}:\\,\\,   {\\ensuremath{\\textrm{{S}}}}\t \\stackrel{k_0}{\\longrightarrow} {\\ensuremath{\\textrm{{P}}}}\t\\notag\n  \\vspace{0.3in}\n  \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"r_{\\textrm{0}}:\\,\\,{\\textrm{{S}}}\\stackrel{k_{0}}{\\longrightarrow}{\\textrm{{P}%&#10;}}\\vspace{0.3in}\" display=\"block\"><mrow><msub><mi>r</mi><mtext>0</mtext></msub><mo rspace=\"5.9pt\">:</mo><mrow><mtext>S</mtext><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mn mathsize=\"140%\">0</mn></msub></mover><mtext>P</mtext></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": " \n \n", "itemtype": "equation", "pos": -1, "prevtext": "\n  \n  \\centerline{(b) Reaction}\n \\end{minipage}\n \\caption{\n {\\texttt{Rnet2}: Simple reaction network enforcing the LoMA (eq.\\eqref{eq:LoMA}) as a queue service process, so as to implement a traffic pacer.}\n}\n \\label{fig:LoMARateLim}\n\\end{figure}\n\nAfter $t=5~s$, we re-programmed the {\\ensuremath{\\mathcal{AC}}}{} with \\texttt{Rnet1}\n(enzymatic rate controller -- see {{Fig.~}\\ref{fig:ChemRateLim}}), by loading the\nfollowing CA specification:\n\n\\begin{figure}[H]\n \\vspace{-0.15in}\n\n\\begin{minipage}[b]{0.99\\linewidth}\n\\footnotesize\n \\centering\n\n", "index": 19, "text": "\\begin{equation*}\n\\mathcal{S}=\n\\{{\\ensuremath{\\textrm{{S}}}},{\\ensuremath{\\textrm{{E}}}},{\\ensuremath{\\textrm{{ES}}}},{\\ensuremath{\\textrm{{P}}}}\\}, \\,\\,\\,\\,\n\\mathcal{R}=\\{r_1,r_2\\}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\mathcal{S}=\\{{\\textrm{{S}}},{\\textrm{{E}}},{\\textrm{{ES}}},{\\textrm{{P}}}\\},%&#10;\\,\\,\\,\\,\\mathcal{R}=\\{r_{1},r_{2}\\}\" display=\"block\"><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mtext>S</mtext><mo>,</mo><mtext>E</mtext><mo>,</mo><mtext>ES</mtext><mo>,</mo><mtext>P</mtext><mo stretchy=\"false\">}</mo></mrow></mrow><mo rspace=\"9.3pt\">,</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n\\end{minipage}\n\\label{fig:enzyHWConfig}\n \\vspace{-0.15in}\n\\end{figure}\n\n\n\\noindent{Setting $e_0=c_{\\ensuremath{\\textrm{{E}}}}^0=25Kmol$ and $k_2=20$~s$^{-1}$ fixed}\nthe rate cap at 0.5~Gbps.\n\nIn $t=[6.5,14~s]$ (see {Fig.~}\\ref{fig:expHWEnzyControl}), a new\nround of UDP transmissions increased the load above the predefined rate cap.\nThe output rate ramped-up to the cap rate, and remained at that limit\nuntil the transmission ended. A third round of UDP transmission started at\ntime $t=19$~s. The load still had mixed high-frequency and low-frequency bursts,\nbut this time did not exceed the rate cap. The CA worked as a pacer: the\ntransmission rate followed closely the slow fluctuations of the arrival rate,\nbut very high-frequencies were filtered out.\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale= 0.5]{Rates2.pdf}\n\\caption{\n{Traffic shaping effects of 2 programmed CAs: Between\nt=[0-5s] the chemical engine was programmed with \\texttt{Rnet2}, then between\nt=[5-27s] the chemical engine was re-programmed with \\texttt{Rnet1}. $\\lambda$\nis the input rate (load presented by the network layer), $v_\\textrm{max}$ is\nthe rate limit set by \\texttt{Rnet1}, $v_\\textrm{tx}$ is the output rate\n(actual transmissions authorised by the CAs).}\n}\n\\label{fig:expHWEnzyControl}\n\\end{figure} \n\nFor the last part of the experiment, we updated the {last} CA specification,\n{re-tuning} its parameters so as to filter even more the traffic bursts (medium\nscale frequencies). To do so, we merely modified the values of individual registers \nwithout re-loading the entire specification (or involving changes in the bitstream).\nThe {modified} parameters were $k_2=10$~s$^{-1}$ (to reduce\nthe filtering cut-off frequency), and $e_0=50$~Kmol (to maintain the rate cap\nat 0.5~Gbps, since $e_0=v_\\textrm{max}/k_2$).\n{Fig.~}\\ref{fig:expHWEnzyControlCompare} shows the difference in the output\nbehaviour under the same arrival traffic pattern.  The rate capping remained\nconsistent ($t=[0,8.5~s]$), while the smoothing of burstiness was more\npronounced ($t=[12.5,20~s]$) when $k_2=10$~s$^{-1}$.\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale= 0.5]{controlCompare2.pdf}\n\\caption[Programmable the filtering behaviour]{\n{Traffic shaping effects of a CA under two configurations: The same input\ntraffic pattern $\\lambda$ was the input of\na CA configured as \\texttt{Rnet1}, first with $k_2=10$~s$^{-1}$ and then with\n$k_2=20$~s$^{-1}$. $v_\\textrm{tx}$ shows the filtering effects on the\noutput rate (actual transmissions authorised by the CAs).}\n}\n\\label{fig:expHWEnzyControlCompare}\n\\end{figure} \n\nIn summary this experiment demonstrates both how new algorithms can be\ninstalled in the chemical engine, as well as how a CA can be fine-tuned by\n(re-)configuring its parameters. {Both operations are possible at runtime.}\n\n\n\n\n\n\n\n\n\n\\subsection{Cost-savings from CAs on hardware}\\label{sec:expPerformance}\n\n\n\n\n{\\color{black}{ To quantify the advantage of an on-hardware execution of CAs, we looked at the computational cost involved when executing CAs in the linux kernel. The rationale behind this measurement is that this computational overhead/penalty disappears as soon as we move the CAs on the FPGA, and together with it any delays in packet transmissions due to system load.  We have employed the ChemFlow platform that was used in the experiments of \\cite{jsac13,danms13}, and our metric has been the utilisation of the CPU when engaged in CA (algorithmic) computations only; omitting related management tasks (such as servicing of interrupts for the queue management operations, and monitoring of the chemical engine).  To understand how the CPU load scales, we measured two CAs of different complexity, \\texttt{Rnet1} and \\texttt{Rnet2} (\\texttt{Rnet1} has double amount of species and reactions than \\texttt{Rnet2}), and we also varied for each of them the input rate of events that they processed.  The results for both CAs are plotted in {Fig.~}\\ref{fig:performance}, grouped by the rate of input events. We can see that beyond a certain {rate} (1M mol/s) the cost increases dramatically, eventually stealing the CPU from other (application) tasks in the system. Thus, even simple CAs are  computationally expensive! Doubling the amount of occupied chemical resources does not really double the load, but nevertheless increases it significantly ($\\sim10\\  \\begin{figure}[t] \\centering \\includegraphics[scale= 0.5]{cpu_vs_load.pdf} \\caption[Performance evaluation]{ {CPU utilisation when executing directly on the main CPU (as software task in kernel space of the OS) the CAs in \\texttt{Rnet1} and \\texttt{Rnet2} with  different input loads. Monitored for 20 seconds and then averaged separately for each input load ({\\color{black}{until 1M mol/s load the host CPU utilisation is near zero}}).} } \\label{fig:performance} \\end{figure}   In the case of the on-hardware implementation, there still exists a saturation point where the input rate hits the limit of the FPGA clock. In our implementation, clocking the FPGA at 80~MHz and using 1 mol/KB resolution, this limit is approximately at 800~Mbps when two reactions are involved in the CA, and at 1.6~Gbps when there is one reaction involved. Even with such a low-end FPGA, today these effected speeds are well within norm for edge connectivity, access networks, and corporate LAN infrastructures (where traffic shaping is mostly needed). As we climb up the range of higher-end FPGAs and dedicated OS interfaces (e.g., PCIe bus), there is substantial improvement in performance (see {Sect.}\\ref{sec:FPGAdimensioningHW}) that can serve application needs even deeper in the core of the network.  Finally, the scaling of CAs' complexity is not a problem in the case of on-hardware implementation thanks to parallelisation. The only limitation can be the size of the FPGA (in terms of number of cells). }}\n\n\n\n\n\n\n\n\n\n\n\n\\section{Discussion}\\label{sec:discussion}\n\n{\\color{black}{  To support our initial claim that CAs are well suited to develop a broad range of control functions for network dynamics, we start this section by providing a couple of algorithms related to queue scheduling and AQM (together with others already presented in past literature~\\cite{sensorj14,jsac13,danms13}, they provide a comprehensive account for network dynamics functions that includes queuing disciplines, AQM, rate control, distributed access, traffic conditioning, distributed consensus, and flow control). We then discuss design extensions based on the OpenFlow architecture~\\cite{McPa08}, to illustrate the actual contextualisation in SDN. We finish the discussion with a reference to tradeoffs and performance expectations of running the CA framework on various FPGA devices currently available on market. }}\n\n\n\n\n\n\n\n\n\n\n\\subsection{Chemical controllers for Active Queue Management (AQM)}\n\\label{sec:aqm}\n\n\n{\\color{black}{ A minimal extension of the enzymatic rate controller scheme in {Fig.~}\\ref{fig:ChemRateLim} suffices to turn the CA into an AQM scheme with packet dropping behaviour analogous to RED~\\cite{FlJa93}. As shown in {Fig.~}\\ref{fig:aqmScheme}, the extension involves one additional reaction ($r_{3}$) and one species ({\\ensuremath{\\textrm{{D}}}}), whose concentration regulates the drop process at the head of the queue.   Reaction $r_{3}$ (much slower than $r_{1}$) occasionally ``samples'' the amount of enqueued packets awaiting transmission (i.e., concentration of species {\\ensuremath{\\textrm{{S}}}}). If the queue size starts growing (i.e., packets dequeued at too slow rate or the arrival rate is too high), $r_{3}$ accelerates fast (as a second order function of the queue size) creating drop tokens ({\\ensuremath{\\textrm{{D}}}}) to remove packets from the head of the queue. As the queue size decreases, $r_{3}$ quickly recovers again its low speed and effects on queue drops.   {Fig.~}\\ref{fig:AQMres} validates experimentally this behaviour in a simple scenario where \\texttt{iperf}-generated VBR UDP traffic goes through a queue controlled by this CA. The upper rate limit of the enzymatic controller was set to 0.4~Gbps, representing the maximum desired link utilisation (condition under which no queue is built-up).  The UDP traffic was admitted to the queue initially at 0.2 Gbps and then at 1~Gbps, during different phases of the experiment ($\\sim$2s-13s and $\\sim$14s-25s).  One can see the drop rate (black line) being effectively zero under low-load conditions (first phase). As soon as the rate cap was reached, and the queue started building up (second phase), the drop-mechanism kicked in emptying the queue at a pace synchronised (no phase lag) with the queue size variations.  Note that while the CA operates on the queue size ({\\ensuremath{\\textrm{{S}}}} species), its configuration is in terms of throughput/latency cap (0.4~Gbps) at the queue! In fact, this is an intuitive/automated configuration approach sought in modern AQMs~\\cite{NiJa12,PaNa12}. }}\n\n\\begin{figure}[t]\n   \\center\n   \n   \\begin{minipage}[b]{.52\\linewidth}\n     \\centering\n     \\centerline{\\includegraphics[width =4.5cm]{aqmHost_W.pdf}}\n     \n     \\centerline{(a) System}\n   \\end{minipage}\n   \n   \\begin{minipage}[b]{0.45\\linewidth}\n     \\centering\n     \\begin{subequations}\n       \n", "itemtype": "equation", "pos": 57692, "prevtext": " \n \n", "index": 21, "text": "\\begin{equation*}\n \\begin{tabular}{ c}\n $c_{\\ensuremath{\\textrm{{E}}}}^0=25Kmol,\\,\\,\\,c_{\\ensuremath{\\textrm{{S}}}}^0=c_{\\ensuremath{\\textrm{{ES}}}}^0=c_{\\ensuremath{\\textrm{{P}}}}^0=0,\\,\\,\\,\\,\\,k_1=1$~(mol$\\cdot$s)$^{-1}$,$\\,\\,\\,\\,\\,k_2=20$~s$^{-1}$\\\\\\\\\n \\end{tabular}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1.m1\" class=\"ltx_Math\" alttext=\"c_{\\textrm{{E}}}^{0}=25Kmol,\\,\\,\\,c_{\\textrm{{S}}}^{0}=c_{\\textrm{{ES}}}^{0}=c%&#10;_{\\textrm{{P}}}^{0}=0,\\,\\,\\,\\,\\,k_{1}=1\" display=\"inline\"><mrow><mrow><mrow><msubsup><mi>c</mi><mtext>E</mtext><mn>0</mn></msubsup><mo>=</mo><mrow><mn>25</mn><mo>\u2062</mo><mi>K</mi><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>l</mi></mrow></mrow><mo rspace=\"7.6pt\">,</mo><mrow><msubsup><mi>c</mi><mtext>S</mtext><mn>0</mn></msubsup><mo>=</mo><msubsup><mi>c</mi><mtext>ES</mtext><mn>0</mn></msubsup><mo>=</mo><msubsup><mi>c</mi><mtext>P</mtext><mn>0</mn></msubsup><mo>=</mo><mn>0</mn></mrow></mrow><mo rspace=\"11pt\">,</mo><mrow><msub><mi>k</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1.m2\" class=\"ltx_Math\" alttext=\"\\cdot\" display=\"inline\"><mo>\u22c5</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1.m3\" class=\"ltx_Math\" alttext=\"{}^{-1}\" display=\"inline\"><msup><mi/><mrow><mo>-</mo><mn>1</mn></mrow></msup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1.m4\" class=\"ltx_Math\" alttext=\"\\,\\,\\,\\,\\,k_{2}=20\" display=\"inline\"><mrow><msub><mpadded lspace=\"8.5pt\" width=\"+8.5pt\"><mi>k</mi></mpadded><mn>2</mn></msub><mo>=</mo><mn>20</mn></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1.m5\" class=\"ltx_Math\" alttext=\"{}^{-1}\" display=\"inline\"><msup><mi/><mrow><mo>-</mo><mn>1</mn></mrow></msup></math>", "type": "latex"}, {"file": "1601.05356.tex", "nexttext": "\n       \\vspace{0.3in}\n     \\end{subequations}\n     \n     \\centerline{(b) Reaction set}\n   \\end{minipage}\n   \\caption[Active Queue Management]{\n\n{\\texttt{Rnet3}: The enzymatic reaction network can be extended to be used as a\nAQM scheme. The CA has two outputs: species {\\ensuremath{\\textrm{{P}}}} controls the departure\nprocess, and species {\\ensuremath{\\textrm{{D}}}} regulates the drop process of packets from the\nqueue. The scheme guarantees a maximum transmission rate of packets while\nkeeping the queue size (and therefore queueing latency) low.}\n}\n   \\label{fig:aqmScheme}\n\\end{figure}\n\n\\begin{figure}[t]\n  \\centering\n  \\includegraphics[scale= 0.5]{winaqmRes.pdf}\n  \\caption[]{\n  {Experimental result of an AQM-style chemical controller (\\texttt{Rnet3} in {Fig.~}\\ref{fig:aqmScheme}).}\n}\n  \\label{fig:AQMres}\n\\end{figure} \n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Chemical controllers for traffic prioritisation}\n\\label{sec:wfq}\n\n\n\n{\\color{black}{ By combining the distributed rate control scheme presented in~\\cite{danms13} with the CA for AQM of the previous section, we are able to create a CA for weighted, or proportional, fair-queuing ({Fig.~}\\ref{fig:prioScheme}).  The servers of the participating queues in the scheme (typically corresponding to distinct classes of traffic) are controlled by identical reaction sub-networks, sharing their token/molecular state (aggregate of species ${\\ensuremath{\\textrm{{P}}}}_i$ feeds back to each ${\\ensuremath{\\textrm{{T}}}}_i$). Through coefficients $k_{2,i}$ at each sub-network, one can configure the proportional bandwidth shares for each queue.  The outputs of these queues then aggregate at a single egress queue, which is controlled by the last stage of the CA, a sub-network implementing the AQM in {Sect.}\\ref{sec:aqm}.   Without delving into analytical details due to space limitation,\\footnote{{\\color{black}{The analysis is a straightforward product of the theory in~\\cite{jsac13}}}.} we show an experimental validation in {Fig.~}\\ref{fig:PRIOres}. The service processes of three intermediate queues and the egress queue (where they aggregate) were controlled by the reaction network \\texttt{Rnet4}. {Fig.~}\\ref{fig:PRIOres}(a) shows the CBR admission rates of traffic, in two phases ($t<10$s and $t \\ge 10$s), to the three queues ($\\lambda_1$ and $\\lambda_3$ flows had the same rate). {Fig.~}\\ref{fig:PRIOres}(b/c/d) demonstrate fair-sharing and weighted (proportional) fair-sharing by means of different $k_{2,i}$ setting. In the first phase, the total aggregate admission rate (at the intermediate queues) did not exceed the configured 2Mbps-limit at the egress queue. All flows claimed and received what they needed from the available bandwidth. In the second phase, the total aggregate admission rate exceeded by far the rate limit and prioritisation kicked in. The share each flow received is (statistically) proportional to the weights expressed as $k_{2,i}$ parameters.    It is worth mentioning that CAs of this size become very fast prohibitive for execution in CPU at the host OS. }}\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale= 0.23]{prioHost3_W.pdf}\n\\caption{\n{\\texttt{Rnet4}: The combination of \\texttt{Rnet3} with the distributed rate\ncontroller scheme in~\\cite{danms13} leads to a CA capable of weighted/proportional\nfair-queuing. Priorities are configurable via $k_{2,i}$.}\n}\n\\label{fig:prioScheme}\n\\end{figure} \n\\begin{figure}[t]\n\\centering\n     \\includegraphics[scale=0.5]{genRate.pdf}\n    \\includegraphics[scale=0.5]{txRate1.pdf}\n \t\\includegraphics[scale=0.5]{txRate3.pdf}\n\t     \\includegraphics[scale=0.5]{txRate4.pdf}\n  \\caption{Prioritisation of traffic classes via $k_{2,i}$-values (see CA in\n  {Fig.~}\\ref{fig:prioScheme}). {\\color{black}{Curves $\\lambda_1$ and $\\lambda_3$ overlap   and appear as one.}} }\n  \\label{fig:PRIOres}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{CAs and Software Defined Networking}\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[height= 5.5cm]{cf-of2.pdf}\n\\caption{\n{Integration of CAs in the OpenFlow architecture}\n}\n\\label{fig:sdn}\n\\end{figure} \n\n{\\color{black}{  In the SDN research landscape deployment of CAs on hardware opens a door to programmable network dynamics. Looking at the OpenFlow (OF)~\\cite{McPa08} architecture as one of the reference enabling southbound technologies in SDN,\\footnote{{\\color{black}{We are not bound to OpenFlow as a southbound interface; our choice was driven by its extensibility, broad acceptance by hardware manufacturers, and its evolution as a melting pot for new features and capabilities.}}} {Fig.~}\\ref{fig:sdn} illustrates how the integration of our chemical framework will be effected in an OF controlled switch.  The dark coloured (in blue) switch subsystems are those currently liable for remote configuration and re-programming via an OF controller.\\footnote{{\\color{black}{This holds until current version 1.4 of the OF protocol}}} One can see that the queuing subsystem, although available for reading statistics through the OF protocol, cannot be remotely controlled or modified by an OF controller. Additionally, the only traffic shaping/management feature supported in this architecture is instantaneous per-flow rate policing. However, the OF architecture accounts already for more than 40 counters and meter bands (collecting state information and statistics), which is all a CA requires as inputs.  As shown in {Fig.~}\\ref{fig:sdn}, an FPGA-based ``chemical subsystem'', like the one presented in this paper, can be hosted at any OF switch on NetFPGA or other FPGA-enabled network cards, or on typical manufacturer-provided FPGA boards wired through hardware interrupts to the OS.  Internally (horizontal interface), it should be ``permanently'' interfaced with the queuing subsystem; on one side controlling the enqueue, dequeue (queue server) and head-drop primitives, and on the other side controlling the increment/decrement primitives of dedicated I/O species (registers). In a similar fashion, it can also be ``non-permanently'' (programmatically/on-demand) interfaced with the counter-set of the OF-switch which may be used as additional input species. These are all mere interrupt signals.  Remote access (southbound SDN interface) from an OF controller is effected through the OF protocol's experimental extensions. Very simple primitives as in~\\cite{SiSc03} can provide admission control of the chemical engines, as well as loading and reseting of algorithms by means of reaction network specifications (or partial specifications providing incremental updates and modifications for existing reaction networks).   }}\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Which logic device?}\\label{sec:FPGAdimensioningHW}\n\n\n\nFor our experimentation we have used a low-end FPGA device (XC6SLX9, the 2nd\nsmallest device of the Spartan-6 family), in which we have exhausted most of\nthe available logic (70\\% of slice LUTs)\n\n\n\nYet, we were able to implement a powerful chemical engine that accommodates\nup to 255 species and up to 8 reactions, with a maximum of 8 reactant and\nproduct species (sufficient for a number of practical\nCAs). This implementation uses a single reaction scheduler (LoMA core) for all\n8 reactions, which computes propensities through a linear pipeline of\nmultiplier DSPs.\n\n\n\n{\\color{black}{ By using the XC7K325T FPGA, which is currently mounted on the popular NetFPGA-1G-CML board, any concern on logic resource exhaustion instantly vanishes: the same implementation of the chemical middleware framework with an instantiation of the same amount of chemical resources would utilise barely 1\\ of slice LUTs available.  Indicatively, in Table~\\ref{tab3} we provide summarised reports from the EDA software of Xilinx, for the amount of logic resources required on the XC7K325T FPGA, when instantiating different amounts of chemical resources in the chemical middleware (up to 256 species, $|\\mathcal{R}|$ reactions, 8 reactants and products, and a single LoMA core with a linear pipeline). While the size of the LoMA core is fixed (e.g., 722 Slices, 798 Slice Reg, 2334 LUTs, 79 LUTRAM, and 4 DSP48E1s on the XC7K325T FPGA),  the logic utilisation scales up as a function of the maximum amount of chemical resources one is willing to make available in the system for CAs (e.g., number of reactions, of species, order {\\emph{etc.}}). }}\n\n\\begin{table}[t]\n\\centering\n{\\footnotesize\n\\begin{tabular}{r l l l l}\n\\hline\n           & $|\\mathcal{R}|$ = 2 & $|\\mathcal{R}|$ = 4 & $|\\mathcal{R}|$ = 8  & $|\\mathcal{R}|$=32 \\\\\n\\hline\n\n\\# Slice Registers  &  1'338 & 1'533 & 1'922 & 4'290 \\\\\n\n\\# Slice LUTs           &  3'071& 3'464 & 3'931 & 7'838 \\\\\n\n\\# Occupied Slices    &  1'145 & 1'340 & 1'792 &4'398 \\\\\n\n\n\n\\# DSP48E1s          & 4 & 4 & 4 &4\\\\\n\\hline\n\\end{tabular}\n}\n\\caption\n{\nLogic resource requirements on XC7K325T FPGA for a chemical\nframework with up to $|\\mathcal{R}|$ reactions available.\n}\n\\label{tab3}\n\\end{table} \n\n\n\nNext, our system implementation is optimised for economy in logic resources, at the\ncost of speed. Operationally, it has been tested at 40 and 80 MHz but it can\nalso work at 160 MHz, and with optimising differently the circuitry it would be\npossible to use at 320 MHz.\\footnote{{\\color{black}{The presets of 40, 80, 160 or 320 MHz are the allowed clocking frequencies of the XC6SLX9 FPGA, as specified by the manufacturer.}}} \n\nAt 40 MHz and 80 MHz clock, the system can process external events (e.g. packet\narrivals) that occur every $\\sim$ 10 $\\mu$s and $\\sim$ 5 $\\mu$s respectively\n(and would be capable of handling $\\sim$ 2.5 $\\mu$s with 160 MHz clock and down\nto $\\sim$ 1.2 $\\mu$s with a 320 MHz clock). Moreover, it is able to process\ncorrectly two \\emph{sporadic} events occurring 50~ns apart, so long as they\nlast at least $\\sim 5$~ns each.\n\n{\\color{black}{ FPGAs with higher clocking frequencies would provide even better resolution, e.g. the XC7K325T-2 FPGA with up to 650 MHz clocking frequency would allow down  to 615 ns resolution. Overall, higher clocking frequency means implementing the the LoMA core with faster DSP modules. }}\n\n\n\nGiven a certain FPGA, one can further optimise for speed, at the cost of logic\nresource economy, by improving drastically on parallelisation. First, one can\nemploy multiple LoMA cores (up to dedicating one to each reaction). Second,\none can employ in the design of the LoMA core a logarithmic pipeline of DSPs (for\nthe computation of propensities).\n\n{\\color{black}{ We have experimented with such a design on the XC7K325T-2 FPGA. By dedicating a LoMA core to each reaction in the configuration of column 4 in Table~\\ref{tab3}, the number of clk-cycles for re-scheduling the reactions dropped from $\\sim$1600 to 52, while the logic resource budget increased to 30'055 slice registers, 79'016 slice LUTs, and 128 DSP48E1s. By additionally changing the pipeline of the LoMA core, we attained a further reduction to only 24 clk-cycles, and a further increase in logic consumption to 54'154 slice registers, 113'495 slice LUTs, and 320 DSP48E1s. This is still less than 50\\ resources available on the XC7K325T-2 FPGA, and with a clocking frequency of 400 MHz we have an impressive 60~ns resolution.  At this point however, it is worth noting that these improvements on speed do not necessarily imply better algorithmic performance. Since the hosted CAs are dynamical systems there is always a performance trade-off for each CA between speed of convergence and region of stability, and the choice is application specific (see \\cite{jsac13} for details). }}\n\n\n\n\n\n\n\n\n\n\n\\section{Conclusion}\\label{sec:Conclusion}\n\nWe have introduced, implemented and evaluated a framework that enables run-time\n(re-)programmable algorithms on FPGA hardware.  These algorithms, which are\ninspired and based on laws and principles of Chemistry, are particularly suited\nto functions featuring control of network dynamics. \n\n{\\color{black}{ The very simple high-level representation of these algorithms (as chemical reaction networks)  \\begin{itemize} \\item has allowed the expression of accurate mathematical models directly on hardware without the need for low-level HDL programming or even finite state automata,  \\item leads to fully parallelisable implementations, where parts of an algorithm can be modified separately and independently of the rest of the program,  \\item has enabled their programmability and configurability on hardware at sub-second latencies and without the need to field re-program FPGAs. \\end{itemize}  While functions for network dynamics is merely our playground, these algorithms may describe also user application logic, performing calculations for datasets other than packets in queues. Hence, in our understanding, this work entails a promising prospect for on-demand offloading general numerical logic directly on FPGA hardware, previously only flexibly expressed at the application level and within the overheads of an operating system. This obsoletes the need for the less performance- and power-efficient VonNeumman-architecture-based CPUs and GPUs. }}\n\n\n\n\n\n\n\\bibliographystyle{IEEEtran}\n\\begin{thebibliography}{10}\n\\providecommand{\\url}[1]{#1}\n\\csname url@samestyle\\endcsname\n\\providecommand{\\newblock}{\\relax}\n\\providecommand{\\bibinfo}[2]{#2}\n\\providecommand{\\BIBentrySTDinterwordspacing}{\\spaceskip=0pt\\relax}\n\\providecommand{\\BIBentryALTinterwordstretchfactor}{4}\n\\providecommand{\\BIBentryALTinterwordspacing}{\\spaceskip=\\fontdimen2\\font plus\n\\BIBentryALTinterwordstretchfactor\\fontdimen3\\font minus\n  \\fontdimen4\\font\\relax}\n\\providecommand{\\BIBforeignlanguage}[2]{{\n\\expandafter\\ifx\\csname l@#1\\endcsname\\relax\n\\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}\n\\typeout{** loaded for the language `#1'. Using the pattern for}\n\\typeout{** the default language instead.}\n\\else\n\\language=\\csname l@#1\\endcsname\n\\fi\n#2}}\n\\providecommand{\\BIBdecl}{\\relax}\n\\BIBdecl\n\n\\bibitem{AlKa12}\nM.~Alizadeh, A.~Kabbani, T.~Edsall, B.~Prabhakara, A.~Vahdat, and M.~Yasuda,\n  ``Less is more: Trading a little bandwidth for ultra-low latency in the data\n  center,'' in \\emph{Proc. of the USENIX Conference on Networked Systems Design\n  and Implementation}, San Jose (CA), USA, Apr 2012, pp. 19--19.\n\n\\bibitem{AlGr10}\nM.~Alizadeh, A.~Greenberg, D.~A. Maltz, J.~Padhye, P.~Patel, B.~Prabhakar,\n  S.~Sengupta, and M.~Sridharan, ``Data center {TCP} ({DCTCP}),'' in \\emph{ACM\n  SIGCOMM Computer Comm. Review}, vol.~40, no.~4, Oct 2010, pp. 63--74.\n\n\\bibitem{RoSa11}\nH.~Rodrigues, J.~R. Santos, Y.~Turner, P.~Soares, and D.~Guedes, ``Gatekeeper:\n  Supporting bandwidth guarantees for multi-tenant datacenter networks,'' in\n  \\emph{Proc. of the USENIX Workshop on I/O Virtualization (WIOV)}, Portland\n  (OR), USA, Jun 2011.\n\n\\bibitem{JeAl13}\nV.~Jeyakumar, M.~Alizadeh, D.~Mazi{\\`e}res, B.~Prabhakar, C.~Kim, and\n  A.~Greenberg, ``{EyeQ}: practical network performance isolation at the\n  edge,'' in \\emph{Proc. of the USENIX Conference on Networked Systems Design\n  and Implementation}, Lombard (IL), USA, Apr 2013, pp. 297--312.\n\n\\bibitem{BaCo11}\nH.~Ballani, P.~Costa, T.~Karagiannis, and A.~Rowstron, ``Towards predictable\n  datacenter networks,'' in \\emph{Proc. of the ACM SIGCOMM}, Aug 2011, pp.\n  242--253.\n\n\\bibitem{NiJa12}\nK.~Nichols and V.~Jacobson, ``Controlling queue delay,'' in \\emph{Magazine\n  Communications of the ACM}, vol.~55, no.~7, May 2012, pp. 42--50.\n\n\\bibitem{PaNa12}\nR.~Pan, P.~Natarajan, C.~Piglione, M.~S. Prabhu, V.~Subramanian, F.~Baker, and\n  B.~VerSteeg, ``{PIE}: A lightweight control scheme to address the bufferbloat\n  problem,'' Draft Standard 00 draft-pan-aqm-pie, Internet Engineering Task\n  Force (IETF), Dec 2012.\n\n\\bibitem{ThBa13}\nE.~Thereska, H.~Ballani, G.~{O'S}hea, T.~Karagiannis, A.~Rowstron, T.~Talpey,\n  R.~Black, and T.~Zhu, ``{IOF}low: A software-defined storage architecture,''\n  in \\emph{Proc. of the ACM Symposium on Operating Systems Principles (SOSP)},\n  Farmington (PA), USA, Nov 2013, pp. 182--196.\n\n\\bibitem{SDNet}\n{Xilinx Inc.}, ``Software defined specification environment for networking\n  ({SDNet}),'' White Paper, 2014.\n\n\\bibitem{BoDa14}\nP.~Bosshart, D.~Daly, G.~Gibb, M.~Izzard, N.~McKeown, J.~Rexford,\n  C.~Schlesinger, D.~Talayco, A.~Vahdat, G.~Varghese, and D.~Walker, ``{P4}:\n  Programming protocol-independent packet processors,'' \\emph{ACM SIGCOMM\n  Computer Comm. Review}, vol.~4, no.~3, pp. 87--95, Jul 2014.\n\n\\bibitem{JeAl14}\nV.~Jeyakumar, M.~Alizadeh, Y.~Geng, C.~Kim, and D.~Mazi\\`eres, ``Millions of\n  little minions: using packets for low latency network programming and\n  visibility,'' in \\emph{Proc. of the ACM SIGCOMM}, Chicago (IL), USA, Aug\n  2014, pp. 3--14.\n\n\\bibitem{BoGi13}\nP.~Bosshart, G.~Gibb, H.-S. Kim, G.~Varghese, N.~McKeown, M.~Izzard, F.~Mujica,\n  and M.~Horowitz, ``Forwarding metamorphosis: fast programmable match-action\n  processing in hardware for {SDN},'' in \\emph{Proc. of the ACM SIGCOMM}, Hong\n  Kong, P.R.C., Aug 2013, pp. 99--110.\n\n\\bibitem{EthSwicth}\nR.~Ozdag, ``Intel\\textsuperscript{\\textregistered} {Ethernet} switch {FM6000}\n  series - software defined networking,'' White Paper, 2012.\n\n\\bibitem{Ku13}\nM.~Kuhlewind, D.~Wagner, J.~M.~R. Espinosa, and B.~Briscoe, ``Immediate\n  {ECN},'' IETF-88 TSVAREA, Nov 2013.\n\n\\bibitem{hotnet09}\nT.~Meyer and C.~F. Tschudin, ``Chemical networking protocols,'' in \\emph{Proc.\n  of the ACM Workshop on Hot Topics in Networks (HotNets)}, New York (NY), USA,\n  Oct 2009.\n\n\\bibitem{sensorj14}\nM.~Monti, L.~Sanguinetti, C.~F. Tschudin, and M.~Luise, ``A chemistry-inspired\n  framework for achieving consensus in wireless sensor networks,'' in\n  \\emph{IEEE Sensors Journal}, vol.~14, no.~2, Feb 2014, pp. 371--382.\n\n\\bibitem{srds12}\nT.~Meyer and C.~F. Tschudin, ``A theory of packet flows based on\n  law-of-mass-action scheduling,'' in \\emph{Proc. of the IEEE Int'l Symposium\n  on Reliable Distributed Systems (SRDS)}, Irvine (CA), USA, Oct 2012.\n\n\\bibitem{jsac13}\nM.~Monti, T.~Meyer, C.~F. Tschudin, and M.~Luise, ``Stability and sensitivity\n  analysis of traffic-shaping algorithms inspired by chemical engineering,'' in\n  \\emph{IEEE Journal on Selected Areas of Communications (JSAC)}, vol.~31,\n  no.~6, Jun 2013, pp. 1--11.\n\n\\bibitem{danms13}\nM.~Monti, M.~Sifalakis, T.~Meyer, C.~F. Tschudin, and M.~Luise, ``A\n  chemical-inspired approach to design distributed rate controllers for packet\n  networks,'' in \\emph{Proc. of the IFIP/IEEE-IM Workshop on Distributed\n  Autonomous Network Management Systems (DANMS)}, Ghent, Belgium, May 2013.\n\n\\bibitem{ijcnc13}\nM.~Monti, P.~Imai, and C.~F. Tschudin, ``Designing run-time environments to\n  have predefined global dynamics,'' in \\emph{International Journal of Computer\n  Networks and Communications (IJCNC)}, vol.~5, no.~3, May 2013, pp. 1--16.\n\n\\bibitem{McPa08}\nN.~McKeown, G.~Parulkar, T.~Anderson, L.~Peterson, H.~Balakrishnan, J.~Rexford,\n  S.~Shenker, and J.~Turner, ``{OpenFlow}: Enabling innovation in campus\n  networks,'' ONF White Paper, Mar 2008.\n\n\\bibitem{LoMc07}\nJ.~W. Lockwood, N.~McKeown, G.~Watson, G.~Gibb, P.~Hartke, J.~Naous,\n  R.~Raghuraman, and J.~Luo, ``{NetFPGA} -- an open platform for gigabit-rate\n  network switching and routing,'' in \\emph{Proc. of the IEEE Intl Conference\n  on Microelectronic Systems Education (MSE)}, San Diego (CA), USA, Jun 2007,\n  pp. 160--161.\n\n\\bibitem{AlteraOpenCL}\nJ.~Auerbach, D.~F. Bacon, I.~Burcea, P.~Cheng, S.~J. Fink, R.~Rabbah, and\n  S.~Shukla, ``A compiler and runtime for heterogeneous computing,'' in\n  \\emph{Proc. of ACM/EDAC/IEEE Design Automation Conference (DAC)}, Jun 2012,\n  pp. 271--276.\n\n\\bibitem{VHDL}\n{IEEE Computer Society}, ``{IEEE} standard {VHDL} language reference manual,''\n  IEEE Standard 1076-2008, Jan 2009.\n\n\\bibitem{verilog}\n------, ``{IEEE} standard for {Verilog} hardware description language,'' IEEE\n  Standard 1364-2005, Apr 2006.\n\n\\bibitem{Po06}\nN.~Possley, ``Traffic management in {Xilinx} {FPGAs},'' Xilinx White Paper\n  WP244 (v1.0), Apr 2006.\n\n\\bibitem{Al14}\n{Altera Corp.}, ``Enabling {100G} traffic management,''\n  http://www.altera.com/end-markets/wireline/applications/traffic/wil-traffic.html,\n  Jan 2014.\n\n\\bibitem{La14}\n{Lattice Semiconductor Corporation}, ``Lattice announces low cost programmable\n  {SPI-4.2} solution,''\n  http://ir.latticesemi.com/phoenix.zhtml?c=117422\\&p=irol-newsArticle\\&ID=1472678\\&highlight,\n  Jan 2014.\n\n\\bibitem{AlAt08}\nM.~Alizadeh, B.~Atikoglu, A.~Kabbani, A.~Lakshmikantha, R.~P.~B. Prabhakar, and\n  M.~Seaman, ``Data center transport mechanisms: Congestion control theory and\n  {IEEE} standardization,'' in \\emph{Proc. of the Annual Allerton Conference on\n  Communication, Control, and Computing}, Monticello (IL), USA, Sep 2008, pp.\n  1270--1277.\n\n\\bibitem{DuGi07}\nN.~Dukkipati, G.~Gibb, and J.~Z. Nick~McKeown, ``Building a {RCP} (rate control\n  protocol) test network,'' in \\emph{Proc. of the IEEE Annual Symposium on\n  High-Performance Interconnects}, Stanford (CA), USA, Aug 2007, pp. 91--98.\n\n\\bibitem{MaRa11}\nN.~Malangadan and G.~Raina, ``Rate based feedback: some experimental evaluation\n  with {NetFPGA},'' in \\emph{Proc. of the IEEE International Conference on\n  Communication (ICC)}, Kyoto, Japan, Jun 2011, pp. 1--6.\n\n\\bibitem{HaDw11}\nS.~Y. Hanay, A.~Dwaraki, and T.~Wolf, ``High-performance implementation of\n  in-network traffic pacing,'' in \\emph{Proc. of the IEEE International\n  Conference on High Performance Switching and Routing (HPSR)}, Cartagena,\n  Spain, Jul 2011, pp. 9--15.\n\n\\bibitem{Ch12}\nG.~Chen, ``A short historical survey of functional hardware languages,''\n  \\emph{ISRN Electronics}, vol. 2012, pp. 1--11, 2012.\n\n\\bibitem{BaRaSh13}\nD.~F. Bacon, R.~Rabbah, and S.~Shukla, ``{FPGA} programming for the masses,''\n  \\emph{ACM Queue}, vol.~11, February 2013.\n\n\\bibitem{Bluespec}\nR.~S. Nikhil, ``Abstraction in hardware system design,'' \\emph{ACM Queue},\n  vol.~9, 2011.\n\n\\bibitem{CaDi09}\nJ.~Cardoso and P.~Diniz, \\emph{Compilation techniques for reconfigurable\n  architectures}.\\hskip 1em plus 0.5em minus 0.4em\\relax Springer, 2009.\n\n\\bibitem{CouMo08}\nP.~Coussy and A.~Morawiec, \\emph{High-level synthesis: from algorithm to\n  digital circuit}.\\hskip 1em plus 0.5em minus 0.4em\\relax Springer, 2008.\n\n\\bibitem{Vivado}\nD.~O'Loughlin, A.~Coffey, F.~Callaly, D.~Lyons, and F.~Morgan, ``Xilinx\n  {Vivado} high level synthesis: Case studies,'' in \\emph{Proc. of Irish\n  Signals Systems Conference 2014 and 2014 China-Ireland International\n  Conference on Information and Communications Technologies (ISSC 2014/CIICT\n  2014).}, Jun 2014, pp. 352--356.\n\n\\bibitem{JaLa10}\nP.~J\\:a\\:askel\\:ainen, C.~de~la Lama, P.~Huerta, and J.~Takala, ``{OpenCL} --\n  based design methodology for application-specific processors,'' in\n  \\emph{Proc. of the IEEE International Conference Embedded Computer Systems\n  (SAMOS)}, Samos, Greece, Jul 2010, pp. 223--230.\n\n\\bibitem{PaGu09}\nA.~Papakonstantinou, K.~Gururaj, J.~Stratton, D.~Chen, J.~Cong, and W.-M. Hwu,\n  ``{FCUDA}: Enabling efficient compilation of {CUDA} kernels onto {FPGAs},''\n  in \\emph{Proc. of IEEE Symposium onApplication Specific Processors (SASP),\n  2009}, San Francisco (CA), USA, Jul 2009, pp. 35--42.\n\n\\bibitem{Lime}\nJ.~Auerbach, D.~F. Bacon, P.~Cheng, and R.~Rabbah, ``Lime: A {Java}-compatible\n  and synthesizable language for heterogeneous architectures,'' \\emph{SIGPLAN\n  Not.}, vol.~45, no.~10, pp. 89--108, Oct 2010.\n\n\\bibitem{BaVo12}\nJ.~Bachrach, H.~Vo, B.~Richards, Y.~Lee, A.~Waterman, R.~Avi\\^zienis,\n  J.~Wawrzynek, and K.~Asanovi\\'c, ``{Chisel}: Constructing hardware in a scala\n  embedded language,'' in \\emph{Proc. of the ACM/EDAC/IEEE Design Automation\n  Conference (DAC)}, Jun 2012, pp. 1212 -- 1221.\n\n\\bibitem{Kiwi}\nD.~Greaves and S.~Singh, ``Designing application specific circuits with\n  concurrent {C}\\# programs,'' in \\emph{proc of. IEEE/ACM International\n  Conference on Formal Methods and Models for Codesign (MEMOCODE)}, Grenoble,\n  France, Jul 2010, pp. 21--30.\n\n\\bibitem{Esterel}\nS.~Singh, ``A demonstration of co-design and co-verification in a synchronous\n  language,'' in \\emph{Proc. of the Design, Automation and Test in Europe\n  Conference and Exhibition}, vol.~2, Feb 2004, pp. 1394--1395.\n\n\\bibitem{DaFa06}\nC.~Dase, J.~Falcon, and B.~MacCleery, ``Motorcycle control prototyping using an\n  {FPGA}-based embedded control system,'' \\emph{Control Systems, IEEE},\n  vol.~26, no.~5, pp. 17--21, Oct 2006.\n\n\\bibitem{MeTh}\nT.~Meyer, ``On chemical and self-healing networking protocols,'' Ph.D.\n  Dissertation, Faculty of Computer Science, University of Basel, Switzerland,\n  2011.\n\n\\bibitem{St12}\nS.~Stepney, ``Nonclassical computation -- a dynamical systems perspective,'' in\n  \\emph{Handbook of Natural Computing, Springer}, vol.~4, 2012, pp. 1979--2025.\n\n\\bibitem{Di05}\nP.~Dittrich, ``The bio-chemical information processing metaphor as a\n  programming paradigm for organic computing,'' in \\emph{Proc. of the Workshop\n  Self-Organization and Emergence, Conference on Architecture of Computing\n  Systems (ARCS)}, Innsbruck, Austria, Mar 2005, pp. 95--100.\n\n\\bibitem{BaFr05}\nJ.~Ban\\^atre, P.~Fradet, and Y.~Radenac, ``Principles of chemical\n  programming,'' in \\emph{Electronic Notes in Theoretical Computer Science,\n  Elsevir}, vol. 124, no.~1, Mar 2005, pp. 133--147.\n\n\\bibitem{Pa00}\nG.~Pa\\u{u}n, ``Computing with membranes,'' in \\emph{Journal of Computer and\n  System Sciences}, vol.~61, no.~1, 2000, pp. 108--143.\n\n\\bibitem{BaDi96}\nW.~Banzhaf, P.~Dittrich, and H.~Rauhe, ``Emergent computation by catalytic\n  reactions,'' in \\emph{Nanotechnology 7 (1996) 307--314}, vol.~7, no.~4, Dec\n  1996, pp. 307--314.\n\n\\bibitem{GiMi01}\nJ.~Giavitto and O.~Michel, ``{MGS}: a rule-based programming language for\n  complex objects and collections,'' in \\emph{Electronic Notes in Theoretical\n  Computer Science, Elsevir}, vol.~59, no.~4, Nov 2001, pp. 286--304.\n\n\\bibitem{MaKr11}\nN.~Matsumaru, P.~Kreyssig, and P.~Dittrich, ``Organisation-oriented chemical\n  programming,'' in \\emph{Organic Computing -- A Paradigm Shift for Complex\n  Systems Autonomic Systems}, vol.~1, 2011, pp. 207--220.\n\n\\bibitem{ViCa11}\nM.~Viroli, M.~Casadei, S.~Montagna, and F.~Zambonelli, ``Spatial coordination\n  of pervasive services through chemical-inspired tuple spaces,'' in\n  \\emph{Journal ACM Transactions on Autonomous and Adaptive Systems (TAAS)},\n  vol.~6, no.~2, Jun 2011, pp. 14:1--14:24.\n\n\\bibitem{NaGi10}\nC.~D. Napoli, M.~Giordano, Z.~N\\'emeth, and N.~Tonellotto, ``Using chemical\n  reactions to model service composition,'' in \\emph{Proc. of the ACM\n  International Workshop on Self-Organizing Architectures}, Washington (DC),\n  USA, Jun 2010, pp. 1--8.\n\n\\bibitem{HoJa72}\nF.~Horn and R.~Jackson, ``General mass action kinetics,'' \\emph{Archive for\n  Rational Mechanics and Analysis}, vol.~47, no.~2, pp. 81--116, 1972.\n\n\\bibitem{WoUl04}\nO.~Wolkenhauer, M.~Ullah, W.~Kolch, and K.~Cho, ``Modeling and simulation of\n  intracellular dynamics: Choosing an appropriate framework,'' in \\emph{IEEE\n  Transactions on Nanobioscience}, vol.~3, no.~3, Sep 2004, pp. 200--207.\n\n\\bibitem{SaIn04}\nH.~M. Sauro and B.~Ingalls, ``Conservation analysis in biochemical networks:\n  computational issues for software writers,'' \\emph{Biophys. Chem.}, vol. 109,\n  no.~1, pp. 1--15, Apr 2004.\n\n\\bibitem{MoSiTR12}\nM.~Monti and M.~Sifalakis, ``Extending the artificial chemistry to design\n  networking algorithms with controllable dynamics,'' Technical Report\n  CS-2012-003, Univ. of Basel, Switzerland,\n  http://cn.cs.unibas.ch/pub/doc/cs-2012-003.pdf, Jul 2012.\n\n\\bibitem{DiZi01}\nP.~Dittrich, J.~Ziegler, and W.~Banzhaf, ``Artificial chemistries -- a\n  review,'' in \\emph{Artificial Life}, vol.~7, 2001, pp. 225--275.\n\n\\bibitem{Xi11FPGA}\n{Xilinx Inc.}, ``Spartan-6 family overview,'' Product Specifications DS160\n  (v2.0), Oct 2011.\n\n\\bibitem{Av11}\n{Avnet Inc.}, ``Xilinx {Spartan}-6 {FPGA LX9} microboard,'' User Guide, Rev C,\n  Aug 2011.\n\n\\bibitem{Xi12}\n{Xilinx Inc.}, ``{LogiCORE} {IP} floating-point operator v6.0,'' Application\n  Note DS816, Jan 2012.\n\n\\bibitem{IE08}\n{IEEE}, ``{IEEE} standard for floating-point arithmetic,'' IEEE Std 754 - 2008\n  (revision IEEE Std 754 - 1985), 2008.\n\n\\bibitem{FlJa93}\nS.~Floyd and V.~Jacobson, ``Random early detection gateways for congestion\n  avoidance,'' \\emph{IEEE/ACM Transactions on Networking}, vol.~1, no.~4, pp.\n  397--413, Aug 1993.\n\n\\bibitem{SiSc03}\nM.~Sifalakis, S.~Schmid, T.~Chart, and D.~Hutchison, ``A generic active service\n  deployment protocol,'' in \\emph{Proc. of the International Workshop on Active\n  Network Technologies and Applications}, Osaka, Japan, May 2003, pp. 100--111.\n\n\\end{thebibliography}\n\n\n\n\n", "itemtype": "equation", "pos": 67200, "prevtext": "\n\\end{minipage}\n\\label{fig:enzyHWConfig}\n \\vspace{-0.15in}\n\\end{figure}\n\n\n\\noindent{Setting $e_0=c_{\\ensuremath{\\textrm{{E}}}}^0=25Kmol$ and $k_2=20$~s$^{-1}$ fixed}\nthe rate cap at 0.5~Gbps.\n\nIn $t=[6.5,14~s]$ (see {Fig.~}\\ref{fig:expHWEnzyControl}), a new\nround of UDP transmissions increased the load above the predefined rate cap.\nThe output rate ramped-up to the cap rate, and remained at that limit\nuntil the transmission ended. A third round of UDP transmission started at\ntime $t=19$~s. The load still had mixed high-frequency and low-frequency bursts,\nbut this time did not exceed the rate cap. The CA worked as a pacer: the\ntransmission rate followed closely the slow fluctuations of the arrival rate,\nbut very high-frequencies were filtered out.\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale= 0.5]{Rates2.pdf}\n\\caption{\n{Traffic shaping effects of 2 programmed CAs: Between\nt=[0-5s] the chemical engine was programmed with \\texttt{Rnet2}, then between\nt=[5-27s] the chemical engine was re-programmed with \\texttt{Rnet1}. $\\lambda$\nis the input rate (load presented by the network layer), $v_\\textrm{max}$ is\nthe rate limit set by \\texttt{Rnet1}, $v_\\textrm{tx}$ is the output rate\n(actual transmissions authorised by the CAs).}\n}\n\\label{fig:expHWEnzyControl}\n\\end{figure} \n\nFor the last part of the experiment, we updated the {last} CA specification,\n{re-tuning} its parameters so as to filter even more the traffic bursts (medium\nscale frequencies). To do so, we merely modified the values of individual registers \nwithout re-loading the entire specification (or involving changes in the bitstream).\nThe {modified} parameters were $k_2=10$~s$^{-1}$ (to reduce\nthe filtering cut-off frequency), and $e_0=50$~Kmol (to maintain the rate cap\nat 0.5~Gbps, since $e_0=v_\\textrm{max}/k_2$).\n{Fig.~}\\ref{fig:expHWEnzyControlCompare} shows the difference in the output\nbehaviour under the same arrival traffic pattern.  The rate capping remained\nconsistent ($t=[0,8.5~s]$), while the smoothing of burstiness was more\npronounced ($t=[12.5,20~s]$) when $k_2=10$~s$^{-1}$.\n\n\\begin{figure}[t]\n\\centering\n\\includegraphics[scale= 0.5]{controlCompare2.pdf}\n\\caption[Programmable the filtering behaviour]{\n{Traffic shaping effects of a CA under two configurations: The same input\ntraffic pattern $\\lambda$ was the input of\na CA configured as \\texttt{Rnet1}, first with $k_2=10$~s$^{-1}$ and then with\n$k_2=20$~s$^{-1}$. $v_\\textrm{tx}$ shows the filtering effects on the\noutput rate (actual transmissions authorised by the CAs).}\n}\n\\label{fig:expHWEnzyControlCompare}\n\\end{figure} \n\nIn summary this experiment demonstrates both how new algorithms can be\ninstalled in the chemical engine, as well as how a CA can be fine-tuned by\n(re-)configuring its parameters. {Both operations are possible at runtime.}\n\n\n\n\n\n\n\n\n\n\\subsection{Cost-savings from CAs on hardware}\\label{sec:expPerformance}\n\n\n\n\n{\\color{black}{ To quantify the advantage of an on-hardware execution of CAs, we looked at the computational cost involved when executing CAs in the linux kernel. The rationale behind this measurement is that this computational overhead/penalty disappears as soon as we move the CAs on the FPGA, and together with it any delays in packet transmissions due to system load.  We have employed the ChemFlow platform that was used in the experiments of \\cite{jsac13,danms13}, and our metric has been the utilisation of the CPU when engaged in CA (algorithmic) computations only; omitting related management tasks (such as servicing of interrupts for the queue management operations, and monitoring of the chemical engine).  To understand how the CPU load scales, we measured two CAs of different complexity, \\texttt{Rnet1} and \\texttt{Rnet2} (\\texttt{Rnet1} has double amount of species and reactions than \\texttt{Rnet2}), and we also varied for each of them the input rate of events that they processed.  The results for both CAs are plotted in {Fig.~}\\ref{fig:performance}, grouped by the rate of input events. We can see that beyond a certain {rate} (1M mol/s) the cost increases dramatically, eventually stealing the CPU from other (application) tasks in the system. Thus, even simple CAs are  computationally expensive! Doubling the amount of occupied chemical resources does not really double the load, but nevertheless increases it significantly ($\\sim10\\  \\begin{figure}[t] \\centering \\includegraphics[scale= 0.5]{cpu_vs_load.pdf} \\caption[Performance evaluation]{ {CPU utilisation when executing directly on the main CPU (as software task in kernel space of the OS) the CAs in \\texttt{Rnet1} and \\texttt{Rnet2} with  different input loads. Monitored for 20 seconds and then averaged separately for each input load ({\\color{black}{until 1M mol/s load the host CPU utilisation is near zero}}).} } \\label{fig:performance} \\end{figure}   In the case of the on-hardware implementation, there still exists a saturation point where the input rate hits the limit of the FPGA clock. In our implementation, clocking the FPGA at 80~MHz and using 1 mol/KB resolution, this limit is approximately at 800~Mbps when two reactions are involved in the CA, and at 1.6~Gbps when there is one reaction involved. Even with such a low-end FPGA, today these effected speeds are well within norm for edge connectivity, access networks, and corporate LAN infrastructures (where traffic shaping is mostly needed). As we climb up the range of higher-end FPGAs and dedicated OS interfaces (e.g., PCIe bus), there is substantial improvement in performance (see {Sect.}\\ref{sec:FPGAdimensioningHW}) that can serve application needs even deeper in the core of the network.  Finally, the scaling of CAs' complexity is not a problem in the case of on-hardware implementation thanks to parallelisation. The only limitation can be the size of the FPGA (in terms of number of cells). }}\n\n\n\n\n\n\n\n\n\n\n\n\\section{Discussion}\\label{sec:discussion}\n\n{\\color{black}{  To support our initial claim that CAs are well suited to develop a broad range of control functions for network dynamics, we start this section by providing a couple of algorithms related to queue scheduling and AQM (together with others already presented in past literature~\\cite{sensorj14,jsac13,danms13}, they provide a comprehensive account for network dynamics functions that includes queuing disciplines, AQM, rate control, distributed access, traffic conditioning, distributed consensus, and flow control). We then discuss design extensions based on the OpenFlow architecture~\\cite{McPa08}, to illustrate the actual contextualisation in SDN. We finish the discussion with a reference to tradeoffs and performance expectations of running the CA framework on various FPGA devices currently available on market. }}\n\n\n\n\n\n\n\n\n\n\n\\subsection{Chemical controllers for Active Queue Management (AQM)}\n\\label{sec:aqm}\n\n\n{\\color{black}{ A minimal extension of the enzymatic rate controller scheme in {Fig.~}\\ref{fig:ChemRateLim} suffices to turn the CA into an AQM scheme with packet dropping behaviour analogous to RED~\\cite{FlJa93}. As shown in {Fig.~}\\ref{fig:aqmScheme}, the extension involves one additional reaction ($r_{3}$) and one species ({\\ensuremath{\\textrm{{D}}}}), whose concentration regulates the drop process at the head of the queue.   Reaction $r_{3}$ (much slower than $r_{1}$) occasionally ``samples'' the amount of enqueued packets awaiting transmission (i.e., concentration of species {\\ensuremath{\\textrm{{S}}}}). If the queue size starts growing (i.e., packets dequeued at too slow rate or the arrival rate is too high), $r_{3}$ accelerates fast (as a second order function of the queue size) creating drop tokens ({\\ensuremath{\\textrm{{D}}}}) to remove packets from the head of the queue. As the queue size decreases, $r_{3}$ quickly recovers again its low speed and effects on queue drops.   {Fig.~}\\ref{fig:AQMres} validates experimentally this behaviour in a simple scenario where \\texttt{iperf}-generated VBR UDP traffic goes through a queue controlled by this CA. The upper rate limit of the enzymatic controller was set to 0.4~Gbps, representing the maximum desired link utilisation (condition under which no queue is built-up).  The UDP traffic was admitted to the queue initially at 0.2 Gbps and then at 1~Gbps, during different phases of the experiment ($\\sim$2s-13s and $\\sim$14s-25s).  One can see the drop rate (black line) being effectively zero under low-load conditions (first phase). As soon as the rate cap was reached, and the queue started building up (second phase), the drop-mechanism kicked in emptying the queue at a pace synchronised (no phase lag) with the queue size variations.  Note that while the CA operates on the queue size ({\\ensuremath{\\textrm{{S}}}} species), its configuration is in terms of throughput/latency cap (0.4~Gbps) at the queue! In fact, this is an intuitive/automated configuration approach sought in modern AQMs~\\cite{NiJa12,PaNa12}. }}\n\n\\begin{figure}[t]\n   \\center\n   \n   \\begin{minipage}[b]{.52\\linewidth}\n     \\centering\n     \\centerline{\\includegraphics[width =4.5cm]{aqmHost_W.pdf}}\n     \n     \\centerline{(a) System}\n   \\end{minipage}\n   \n   \\begin{minipage}[b]{0.45\\linewidth}\n     \\centering\n     \\begin{subequations}\n       \n", "index": 23, "text": "\\begin{align}\n  \t r_{1}:\\,\\,  & {\\ensuremath{\\textrm{{S}}}}+{\\ensuremath{\\textrm{{E}}}}\t \\stackrel{k_1}{\\longrightarrow} {\\ensuremath{\\textrm{{ES}}}}\t\\notag\t\\\\ \n  \t r_{2}:\\,\\, \t& {\\ensuremath{\\textrm{{ES}}}} \t \\stackrel{k_2}{\\longrightarrow}{\\ensuremath{\\textrm{{E}}}} + {\\ensuremath{\\textrm{{P}}}}\\notag \\\\\n  \t r_{3}:\\,\\, \t&2\\; {\\ensuremath{\\textrm{{S}}}} \t \\stackrel{k_D}{\\longrightarrow}{\\ensuremath{\\textrm{{S}}}} + {\\ensuremath{\\textrm{{D}}}}\\notag\n       \\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{1}:\" display=\"inline\"><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\textrm{{S}}}+{\\textrm{{E}}}\\stackrel{k_{1}}{\\longrightarrow}{%&#10;\\textrm{{ES}}}\" display=\"inline\"><mrow><mrow><mtext>S</mtext><mo>+</mo><mtext>E</mtext></mrow><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mn mathsize=\"140%\">1</mn></msub></mover><mtext>ES</mtext></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{2}:\" display=\"inline\"><mrow><msub><mi>r</mi><mn>2</mn></msub><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\textrm{{ES}}}\\stackrel{k_{2}}{\\longrightarrow}{\\textrm{{E}}}+{%&#10;\\textrm{{P}}}\" display=\"inline\"><mrow><mtext>ES</mtext><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mn mathsize=\"140%\">2</mn></msub></mover><mrow><mtext>E</mtext><mo>+</mo><mtext>P</mtext></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{3}:\" display=\"inline\"><mrow><msub><mi>r</mi><mn>3</mn></msub><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 2\\;{\\textrm{{S}}}\\stackrel{k_{D}}{\\longrightarrow}{\\textrm{{S}}}%&#10;+{\\textrm{{D}}}\" display=\"inline\"><mrow><mrow><mpadded width=\"+2.8pt\"><mn>2</mn></mpadded><mo>\u2062</mo><mtext>S</mtext></mrow><mover><mo movablelimits=\"false\">\u27f6</mo><msub><mi mathsize=\"142%\">k</mi><mi mathsize=\"140%\">D</mi></msub></mover><mrow><mtext>S</mtext><mo>+</mo><mtext>D</mtext></mrow></mrow></math>", "type": "latex"}]