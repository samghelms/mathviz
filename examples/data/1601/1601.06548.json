[{"file": "1601.06548.tex", "nexttext": "\n From the above described term and formulae language we can provide the inference rules of the \\textbf{LKE}-calculus, essentially the \\textbf{LK}-calculus~\\cite{prooftheory} plus an equational theory $\\varepsilon$ (in our case $\\varepsilon_{\\vee}$ Eq. \\ref{eq:one}). This theory, concerning our particular usage, is a primitive recursive term algebra describing the structure of the defined function (predicate) symbols. The \\textbf{LKE}-calculus is the base calculus for the \\textbf{LKS}-calculus which also includes {\\em proof links}.\n\\begin{definition}[$\\varepsilon$-inference rule]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{prooftree}\n\\AxiomC{$S\\left[ t\\right] $}\n\\RightLabel{$(\\varepsilon)$}\n\\UnaryInfC{$S\\left[ t'\\right] $}\n\\end{prooftree}\nIn the $\\varepsilon$ inference rule, the term $t$ in the sequent $S$ is replaced by a term $t'$ such that, given the equational theory  $\\varepsilon$,  $\\varepsilon \\models t = t'$.\n\\end{definition}\n\nTo extend the \\textbf{LKE}-calculus with  proof links we need a countably infinite set of {\\em proof symbols}  denoted by $\\varphi, \\psi,\\varphi_{i}, \\psi_{j} \\ldots$. Let $S(\\bar{x})$ by a  sequent with a vector of schematic variables $\\bar{x}$, by  $S(\\bar{t})$ we denote the sequent $S(\\bar{x})$ where each of the variables in $\\bar{x}$ is replaced by the terms in the vector $\\bar{t}$ respectively, assuming that they have the appropriate type. Let $\\varphi$ be a proof symbol and $S(\\bar{x})$ a sequent, then the expression \\AxiomC{$(\\varphi(\\bar{t}))$}\n\\dashedLine\n\\UnaryInfC{$S(\\bar{t})$}\n\\DisplayProof\nis called a {\\em proof link} . For a variable $n:\\omega$, proof links\nsuch that the only $\\omega$-variable is $n$ are called {\\em $n$-proof links} \\index{k-proof Link}.\n\n\\begin{definition}[\\textbf{LKE}-calculus~\\cite{CERESS2}]\nThe sequent calculus $\\mathbf{LKS}$\nconsists of the rules of $\\mathbf{LKE}$, where proof links may appear\nat the leaves of a proof.\n\\end{definition}\n\n\\begin{definition}[Proof schemata~\\cite{CERESS2}]\\label{def.proofschema}\n\\index{Proof Schemata}\n  Let $\\psi$ be a proof symbol and $S(n,\\bar{x})$ be a sequent\n  such that $n:\\omega$. Then a {\\em proof schema pair for $\\psi$} is a pair of $\\mathbf{LKS}$-proofs $(\\pi,\\nu(k))$ with end-sequents $S(0,\\bar{x})$ and $S(k+1,\\bar{x})$ respectively such that $\\pi$ may not contain proof links and $\\nu(k)$ may\n  contain only proof links of the form \\AxiomC{$(\\psi(k,\\bar{a}))$}\n  \\dashedLine\n  \\UnaryInfC{$S(k,\\bar{a})$}\n  \\DisplayProof \nand we say that it is a proof link to $\\psi$. We call $S(n,\\bar{x})$ the end sequent of $\\psi$ and assume an identification between the formula occurrences in the end sequents of $\\pi$ and $\\nu(k)$ so that we can speak of occurrences in the end sequent of $\\psi$. Finally a proof schema $\\Psi$ is a tuple of proof schema pairs for $\\psi_1 , \\cdots \\psi_\\alpha$ written as $\\left\\langle \\psi_1 , \\cdots \\psi_\\alpha \\right\\rangle$, such that the $\\mathbf{LKS}$-proofs for $\\psi_{\\beta}$ may also contain $n$-proof links to $\\psi_{\\gamma}$ for $1\\leq \\beta < \\gamma\\leq \\alpha$. We also say that the end sequent of $\\psi_1$ is the end sequent of $\\Psi$. \n\\end{definition}\n\nWe will not delve further into the structure of proof schemata and instead refer the reader to~\\cite{CERESS2}. We now introduce the {\\em characteristic clause set schema}.\n\n\\subsection{Characteristic Clause set Schema}\n\nThe construction of the characteristic clause set as described for the CERES method~\\cite{CERES} required inductively following the formula occurrences of cut formula ancestors up the proof tree to the leaves. However, in the case of proof schemata, the concept of ancestors and formula occurrence is more complex. A formula occurrence might be an ancestor of a cut formula in one recursive call and in another it might not. Additional machinery is necessary to extract the characteristic clause term from proof schemata. A set $\\Omega$ of formula occurrences from the end-sequent of an \\textbf{LKS}-proof $\\pi$ is called {\\em a configuration for $\\pi$}. A configuration $\\Omega$ for $\\pi$ is called relevant w.r.t. a proof schema $\\Psi$ if $\\pi$ is a proof in $\\Psi$ and there is a $\\gamma \\in \\mathbb{N}$ such that $\\pi$ induces a subproof $\\pi\\downarrow \\gamma$ of $\\Psi \\downarrow \\gamma$\nsuch that the occurrences in $\\Omega$ correspond to cut-ancestors below $\\pi\\downarrow \\gamma$~\\cite{thesis2012Tsvetan}. Note that the set of relevant cut-configurations can be computed given a proof schema $\\Psi$. To represent a proof symbol $\\varphi$ and configuration $\\Omega$ pairing in a clause set we assign them a {\\em clause set symbol} $cl^{\\varphi,\\Omega}(a,\\bar{x})$, where $a$ is a term of the $\\omega$ sort. \n\n\\begin{definition}[Characteristic clause term~\\cite{CERESS2}]\\label{def:charterm}\n\\index{Characteristic Term}\nLet $\\pi$ be an $\\mathbf{LKS}$-proof and $\\Omega$ a configuration. In the following, by $\\Gamma_{\\Omega}$ , $\\Delta_{\\Omega}$ and $\\Gamma_{C}$ , $\\Delta_{C}$ we will denote multisets of formulas of $\\Omega$- and $cut$-ancestors respectively. Let $r$ be an inference in $\\pi$. We define the clause-set term $\\Theta_r^{\\pi,\\Omega}$ inductively:\n\\begin{itemize}\n\\item if $r$ is an axiom of the form $\\Gamma_{\\Omega} ,\\Gamma_C , \\Gamma \\vdash \\Delta_{\\Omega} ,\\Delta_C , \\Delta$, then \\\\ $\\Theta_{r}^{\\pi,\\Omega} = \\left\\lbrace \\Gamma_{\\Omega} ,\\Gamma_C  \\vdash \\Delta_{\\Omega} ,\\Delta_C \\right\\rbrace $\n\\item if $r$ is a proof link of the form\n\\AxiomC{$\\psi(a,\\bar{u})$}\n\\dashedLine\n\\UnaryInfC{$\\Gamma_{\\Omega} ,\\Gamma_C , \\Gamma \\vdash \\Delta_{\\Omega} ,\\Delta_C , \\Delta$}\n\\DisplayProof\nthen define $\\Omega'$ as the set of formula occurrences from $\\Gamma_{\\Omega} ,\\Gamma_C  \\vdash \\Delta_{\\Omega} ,\\Delta_C$ and $\\Theta_{r}^{\\pi,\\Omega} = cl^{\\psi,\\Omega}(a,\\bar{u})$\n\\item if $r$ is a unary rule with immediate predecessor \\index{Predecessor} $r'$ , then $\\Theta_{r}^{\\pi,\\Omega} =  \\Theta_{r'}^{\\pi,\\Omega}$\n\n\\item if $r$ is a binary rule with immediate predecessors $r_1 $, $r_2 $, then \n\\begin{itemize}\n\\item if the auxiliary formulas of $r$ are $\\Omega$- or $cut$-ancestors, then\n$\\Theta_{r}^{\\pi,\\Omega} = \\Theta_{r_1}^{\\pi,\\Omega} \\oplus \\Theta_{r_2}^{\\pi,\\Omega}$\n\\item otherwise, $\\Theta_{r}^{\\pi,\\Omega} = \\Theta_{r_1}^{\\pi,\\Omega} \\otimes \\Theta_{r_2}^{\\pi,\\Omega}$\n\\end{itemize}\n\\end{itemize}\nFinally, define $\\Theta^{\\pi,\\Omega} = \\Theta_{r_0}^{\\pi,\\Omega}$ where $r_0$ is the last inference in $\\pi$ and $\\Theta^{\\pi} = \\Theta^{\\pi,\\emptyset}$. We call $\\Theta^{\\pi}$ the characteristic term of $\\pi$. \n\\end{definition}\n\n\nClause terms evaluate to sets of clauses by $|\\Theta| = \\Theta$ for clause sets $\\Theta$, $|\\Theta_1 \\oplus \\Theta_2| = |\\Theta_1| \\cup |\\Theta_2|$, $|\\Theta_1 \\otimes \\Theta_2| = \\{C \\circ D \\mid C \\in |\\Theta_1|, D \\in |\\Theta_2|\\}$.\n\nThe characteristic clause term is extracted for each proof symbol in a given proof schema $\\Psi$, and together they make the {\\em characteristic clause set schema} for $\\Psi$, $CL(\\Psi)$.\n\\begin{definition}[Characteristic Term Schema\\cite{CERESS2}]\nLet $\\Psi = \\left\\langle \\psi_{1},\\cdots, \\psi_{\\alpha} \\right\\rangle $ be a proof schema. We define the rewrite rules for clause-set symbols for all proof symbols $\\psi_{\\beta}$  and configurations $\\Omega$ as $cl^{\\psi_{\\beta},\\Omega}(0,\\overline{u}) \\rightarrow \\Theta^{\\pi_{\\beta},\\Omega}$ and $cl^{\\psi_{\\beta},\\Omega}(k+1,\\overline{u}) \\rightarrow \\Theta^{\\nu_{\\beta},\\Omega}$ where $1\\leq \\beta\\leq \\alpha$. Next, let $\\gamma\\in \\mathbb{N}$ and $cl^{\\psi_{\\beta},\\Omega}\\downarrow_{\\gamma}$ be the normal form of $cl^{\\psi_{\\beta},\\Omega}(\\gamma,\\overline{u})$ under the rewrite system just given extended by rewrite rules for defined function and predicate symbols. Then define $\\Theta^{\\psi_{\\beta},\\Omega} = cl^{\\psi_{\\beta},\\Omega}$ and $\\Theta^{\\Psi,\\Omega} = cl^{\\psi_{1},\\Omega}$ and finally the characteristic term schema $\\Theta^{\\Psi} =  \\Theta^{\\Psi,\\emptyset}$.\n\\end{definition}\n\\subsection{Resolution Proof Schemata} \n\nFrom the characteristic clause set we can construct {\\em clause schemata} which are an essential part of the definition of {\\em resolution terms} and {\\em resolution proof schema }\\cite{CERESS2}. Clause schemata serve as the base for the resolution terms used to construct a resolution proof schema. One additional notion needed for defining resolution proof schema is that of {\\em clause variables}. The idea behind clause variables is that parts of the clauses at the leaves can be passed down a refutation to be used later on. The definition of resolution proof schemata uses clause variables as a way to handle this passage of clauses. Substitutions on clause variables are defined in the usual way. \n\n\\begin{definition}[Clause Schema \\cite{CERESS2}]\nLet $b$ be an numeric term, $\\overline{u}$ a vector\nof schematic variables and $\\overline{X}$  a vector of clause variables. Then $c(b, \\overline{u}, \\overline{X})$ is\na clause schema w.r.t. the rewrite system $R$:\n\\begin{center}\n$c(0, \\overline{u}, \\overline{X}) \\rightarrow C \\circ X$\nand\n$c(k + 1, \\overline{u}, \\overline{X}) \\rightarrow c(k, \\overline{u}, \\overline{X}) \\circ D$\n\\end{center}\nwhere $C$ is a clause with $V(C) \\subseteq \\left\\lbrace \\overline{u} \\right\\rbrace$  and $D$ is a clause with $V(D) \\subseteq \\left\\lbrace k, \\overline{u}\\right\\rbrace $. Clauses and clause variables are clause schemata w.r.t. the empty rewrite system.\n\\end{definition}\n\\begin{definition}[Resolution Term \\cite{CERESS2}]\nClause schemata are resolution terms; if\n$\\rho_1$ and $\\rho_2$  are resolution terms, then $r(\\rho_1 ; \\rho_2 ; P)$ is a resolution term, where $P$ is an atom formula schema.\n\\end{definition}\n\nThe idea behind the resolution terms is that in the term  $r(\\rho_1 ; \\rho_2 ; P)$, $P$ is the resolved atom of the resolvents $\\rho_1, \\rho_2$. The notion of most general unifier has not yet been introduced being that we introduce the concept as a separate schema from the resolution proof schema. \n\n\\begin{definition}[Resolution Proof Schema \\cite{CERESS2}]\nA resolution proof schema $\\mathcal{R}(n)$ is a structure $( \\varrho_1 , \\cdots , \\varrho_\\alpha )$ together with a set of rewrite rules $\\mathcal{R} = \\mathcal{R}_1 \\cup \\cdots \\cup \\mathcal{R}_{\\alpha}$ ,\nwhere the $\\mathcal{R}_i\\ (for \\ 1 \\leq i \\leq \\alpha )$ are pairs of rewrite rules \n\\begin{center}\n$\\varrho_i (0, \\overline{w},\\overline{ u},  \\overline{X} ) \\rightarrow \\eta_i$\\\\\nand\\\\\n$\\varrho_i (k+1,\\overline{w},\\overline{ u},  \\overline{X} ) \\rightarrow \\eta'_i $\n\\end{center}\n\nwhere, $\\overline{w},\\overline{ u},$ and $ \\overline{X}$ are vectors of $\\omega$, schematic, and clause variables respectively, $\\eta_i$ is a resolution term over terms of the form $\\varrho_j(a_j , \\overline{m},\\overline{ t},  \\overline{C})$ for $i<j\\leq \\alpha$, and $\\eta'_i$ is a resolution term over terms of the form $\\varrho_j(a_j , \\overline{m},\\overline{ t},  \\overline{C})$ and $\\varrho_i(k, \\overline{m},\\overline{ t},  \\overline{C})$ for $i < j \\leq \\alpha$; by $a_j$, we denote a term of the  $\\omega$ sort.\n\\end{definition}\n\nThe idea behind the definition of resolution proof schema is that the definition simulates a recursive construction of a resolution derivation tree and can be unfolded into a tree once the free parameter is instantiated. The expected properties of resolution and resolution derivations hold for resolution proof schema, more detail can be found in \\cite{CERESS2}. \n\n\\begin{definition}[Substitution Schema \\cite{CERESS2}]\nLet $u_1 , \\cdots , u_{\\alpha}$ be schematic variable\nsymbols of type $\\omega \\rightarrow \\iota$ and $t_1 , \\cdots , t_{\\alpha}$ be term schemata containing no other $\\omega$-variables than $k$. Then a substitution schema is an expression of the form $\\left[ u_1 /\\lambda k.t_{1} , \\cdots , u_{\\alpha} /\\lambda k.t_{\\alpha} \\right]$.\n\\end{definition}\n\nSemantically, the meaning of the substitution schema is for all $\\gamma\\in \\mathbb{N}$ we have a substitution of the form $\\left[ u_1(\\gamma) /\\lambda k.t_{1}\\downarrow_{\\gamma} , \\cdots , u_{\\alpha}(\\gamma) /\\lambda k.t_{\\alpha}\\downarrow_{\\gamma} \\right]$. For the resolution proof schema the semantic meaning is as follows, Let $R(n) = ( \\varrho_{1}, \\cdots , \\varrho_{\\alpha} )$ be a resolution proof schema, $\\theta$ be a clause substitution, $\\nu$ an $\\omega$-variable substitution, $\\vartheta$ be a substitution schema, and $\\gamma \\in \\mathbb{N}$, then  $R(\\gamma)\\downarrow$ denotes a resolution\nterm which has a normal form of $\\varrho_1 (n,\\overline{w}, \\overline{u} , \\overline{X} )\\theta\\nu\\vartheta[n/\\gamma ]$ w.r.t. $R$ extended by rewrite rules for defined function and predicate symbols.\n\n\n\\subsection{Herbrand Systems}\n\nFrom the resolution proof schema and the substitution schema we can exact a so-called {\\em Herbrand system}. The idea is to generalize the mid sequent theorem of Gentzen to proof schemata \\cite{Baaz:2013:MC:2509679,prooftheory}. This theorem states that a proof (cut-free or with quantifier-free cuts) of a prenex end-sequent can be transformed in a way that there is a midsequent separating quantifier inferences from propositional ones. The mid-sequent is propositionally valid (w.r.t. the axioms) and contains (in general several) instances of the matrices of the prenex formulas; it is also called a {\\em Herbrand sequent}. The aim of this paper is to extract schematic Herbrand sequents from schematic cut-elimination via CERES. We restrict the sequents further to skolemized ones. In the schematization of these sequents we allow only the matrices of the formulas to contain schematic variables (the number of formulas in the sequents and the quantifier prefixes are fixed).  \n\n\\begin{definition}[skolemized prenex sequent schema]\\label{def:sps-schema}\nLet \n\n", "itemtype": "equation", "pos": 10585, "prevtext": "\n\n\\title{Schematic Cut elimination and the Ordered Pigeonhole Principle \\subtitle{[Extended Version]} }\n\n\\author{David Cerna \\inst{1} \\and Alexander Leitsch \\inst{2}}\n\\institute{Research Institute for Symbolic\nComputation (RISC) \\\\ Johannes Kepler University, Linz, Austria \\\\ \\href{mailto:dcerna@risc.uni-linz.ac.at}{dcerna@risc.uni-linz.ac.at}\n\\and\nLogic and Theory Group\\\\ Technical University of Vienna \\\\  \\href{mailto: leitsch@logic.at}{ leitsch@logic.at} }\n\n\\authorrunning{D.\\,M. Cerna & A. Leitsch} \n\n\n\n\n\\maketitle\n\n\\begin{abstract}\nIn previous work, an attempt was made to apply the {\\em schematic CERES method} \\cite{CERESS2} to a formal proof with an arbitrary number of $\\Pi_{2}$ cuts (a recursive proof encapsulating the infinitary pigeonhole principle) \\cite{MeCadePaper2015}. However the derived schematic refutation for the {\\em characteristic clause set} of the proof  could not be expressed in the formal language provided in \\cite{CERESS2}.  Without this formalization a {\\em Herbrand system} cannot be algorithmically extracted. In this work, we provide a restriction of the proof found in \\cite{MeCadePaper2015}, the {\\em ECA-schema (Eventually Constant Assertion), or ordered infinitary pigeonhole principle}, whose analysis can be completely carried out in the framework of \\cite{CERESS2}, this is the first time the framework is used for proof analysis. From the refutation of the clause set and a substitution schema we construct a {\\em Herbrand system}. \n\n\n \\end{abstract}\n\n\\section{Introduction}\n\nFor his famous {\\em Hauptsatz}~\\cite{Gentzen1935}, Gerhard Gentzen developed the sequent calculus \\textbf{LK}. Gentzen went on to show that the {\\em cut} inference rule is redundant and in doing so, was able to show several results on consistency and decidability. The method he developed for eliminating cuts from \\textbf{LK}-derivations works by inductively reducing the cuts in a given \\textbf{LK}-derivation to cuts which either have a reduced {\\em formula complexity} and/or reduced {\\em  rank}~\\cite{prooftheory}. This method of cut elimination is known as {\\em reductive cut elimination}. A useful consequence of cut elimination for the \\textbf{LK}-calculus is that cut-free \\textbf{LK}-derivations have the {\\em subformula property},  i.e. every formula occurring in the derivation is a subformula of some formula in the end sequent. This property admits the construction of {\\em Herbrand sequents} and other objects which are essential in proof analysis. \n\nBy using the technique of cut-elimination, it is also possible to gain mathematical knowledge concerning the connection between different proofs of the same theorem. For example, Jean-Yves Girard's application of cut elimination to the F\\\"{u}rstenberg-Weiss' proof of van der Waerden's theorem~\\cite{ProocomWaerdens1987} resulted in the {\\em analytic} proof of van der Waerden's theorem as found by van der Waerden himself. From the work of Girard, it is apparent that interesting results can be derived from eliminating cuts in ``mathematical'' proofs. \n\nA more recently developed method of cut elimination, the CERES method~\\cite{CERES}, provides the theoretic framework to directly study the cut structure of \\textbf{LK}-derivations, and in the process reduces the computational complexity of deriving a cut-free proof. The cut structure is transformed into a clause set allowing for a clausal analysis of the resulting clause form. Methods of reducing clause set complexity, such as {\\em subsumption} and {\\em tautology elimination} can be applied to the characteristic clause set to increase the efficiency. It was shown by Baaz \\& Leitsch in ``Methods of cut Elimination''~\\cite{Baaz:2013:MC:2509679} that this method of cut elimination has a {\\em non-elementary speed up} over reductive cut elimination.\n\nIn the same spirit of Girard's work, the CERES method was applied to a formalization of  F\\\"{u}rstenberg's proof of the infinitude of primes~\\cite{Baaz:2008:CAF:1401273.1401552}. Instead of formalizing the proof as a single proof (in second-order arithmetic) it was represented as a sequence of first-order proofs enumerated by a single numeric parameter indexing the number of primes assumed to exist (leading to a contradiction). The resulting schema of clause sets was refuted for the first few instances by the system CERES. The general refutation schema, resulting in Euclid's construction of primes, was specified on the mathematical meta-level.  At that time no object-level construction of the resolution refutation schema existed. \n\nA straightforward mathematical formalization of  F\\\"{u}rstenberg's proof requires induction. In higher-order logic, induction is easily formalized via the comprehension principle. However in first-order, an induction rule or induction axioms have to be added to the \\textbf{LK}-calculus. As it was shown in~\\cite{CERESS2}, ordinary reductive cut elimination does not work in the presence of an induction rule in the \\textbf{LK}-calculus. There are, however, other systems~\\cite{Mcdowell97cut-eliminationfor} which provide cut-elimination in the presence of an induction rule; but these systems do not produce proofs with the subformula property, which is necessary for Herbrand system extraction.   \n\nIn ``Cut-Elimination and Proof Schemata''~\\cite{CERESS2}, a version of the \\textbf{LK}-calculus was introduced (\\textbf{LKS}-calculus) allowing for the formalization of sequences of proofs as a single object level construction, i.e. {\\em proof schema}, as well as a framework for performing a CERES-type cut elimination on proof schemata. Cut elimination performed within the framework of~\\cite{CERESS2} results in cut-free proof schemata with the subformula property. \n\nIn previous work, we applied the schematic CERES method of~\\cite{CERESS2} to a proof formalized in the \\textbf{LKS}-calculus\\cite{MeCadePaper2015,MyThesis}. We referred to this formal proof as the {\\em Non-injectivity  Assertion} (NiA) schema. A well known variation of the NiA-schema, of which has been heavily studied in literature, is the {\\em infinitary Pigeonhole Principle} (PHP). Though a resolution refutation schema was found and mathematically specified~\\cite{MeCadePaper2015}, it was not possible to express this refutation schema within the language of~\\cite{CERESS2}.  The main problem  was the specification of a unification and refutation schema. This issue points to a fundamental property of CERES-based schematic cut-elimination, namely that the language for specifying the refutation schema is more complex than that specifying the proof schema.\n\nIn this work we construct a formal proof for a weaker variant of the NiA-schema which we call the {\\em Eventually Constant Assertion schema} (ECA-schema). The ECA is an encapsulation of the infinitary pigeonhole principle where the holes are ordered. For the ECA-schema a specification of the resolution refutation schema within the formalism of~\\cite{CERESS2} turned out successful. In particular, we are able to extract a Herbrand system and complete the proof analysis of the ECA-schema.\n\nThe paper is structured as follows: In Sec. \\ref{sec:SCERES}, we introduce the \\textbf{LKS}-calculus and the essential concepts from~\\cite{CERESS2} concerning the schematic clause set analysis. In Sec. \\ref{sec:MathNiA}, we mathematically prove the  ECA-schema. We leave the formal proof, written in the \\textbf{LKS}-calculus, to Appendix  \\ref{sec:FormECA}. In Sec. \\ref{sec:CCSSE}, we extract the characteristic clause set from the ECA-schema and perform {\\em normalization} and tautology elimination. In Sec. \\ref{sec:refuteset}, we provide a refutation of the extracted characteristic clause set. In Sec. \\ref{sec:Herbrand}, we extract a Herbrand system for the refutation of  Sec. \\ref{sec:refuteset}. In Sec. \\ref{sec:Conclusion}, we conclude the paper and discuss our conjecture. \n\n\n\\section{The \\textbf{LKS}-calculus and Clause set Schema}\\label{sec:SCERES}\n\nIn this section we introduce the \\textbf{LKS}-calculus, which will be used to formalize the ECA-schema, and the schematic CERES method. \n\n\\subsection{Schematic language, proofs, and the \\textbf{LKS}-calculus}\nThe \\textbf{LKS}-calculus is based on the \\textbf{LK}-calculus constructed by Gentzen~\\cite{Gentzen1935}. When one grounds the {\\em parameter} indexing an \\textbf{LKS}-derivation, the result is an  \\textbf{LK}-derivation~\\cite{CERESS2}. The term language used is extended to accommodate  the schematic constructs of  \\textbf{LKS}-derivations. We work in a two-sorted setting containing a {\\em schematic sort} $\\omega$ and an {\\em individual sort} $\\iota$. The schematic sort contains numerals constructed from the constant $0:\\omega$, a monadic function $s(\\cdot):\\omega \\rightarrow \\omega$ as well as $\\omega$-variables $\\mathcal{N}_{v}$, of which one variable, the {\\em free parameter}, will be used to index \\textbf{LKS}-derivations. When it is not clear from context, we will represent numerals as $\\overline{m}$. The free parameter will be represented by $n$ unless otherwise noted. \n\nThe individual sort is constructed in a similar fashion to the standard first order language~\\cite{prooftheory} with the addition of schematic functions. Thus,  $\\iota$ contains countably many constant symbols, countably many {\\em constant function symbols}, and  {\\em defined function symbols}. The constant function symbols are part of the  standard first order language and the defined function symbols are used for schematic terms. Though, defined function symbols can also unroll to numerals and thus can be of type $\\omega^n \\to \\omega$.  The $\\iota$ sort also has {\\em free} and {\\em bound} variables and an additional concept, {\\em extra variables}~\\cite{CERESS2}. These are variables introduced during the unrolling of defined function ({\\em predicate}) symbols. We do not use extra variables in the formalization of the ECA-schema. Also important are the {\\em schematic variable symbols} which are variables of type $\\omega \\rightarrow \\iota$. Essentially second order variables, though, when evaluated with a {\\em ground term} from the $\\omega$ sort we treat them as first order variables. Our terms are built inductively using constants and variables as a base.  \n\nFormulae are constructed inductively using countably many {\\em predicate constants}, logical operators $\\vee$,$\\wedge$,$\\rightarrow$,$\\neg$,$\\forall$, and $\\exists$, as well as  {\\em defined predicate symbols} which are used to construct schematic formulae. In this work {\\em iterated $\\bigvee$} is the only defined predicate symbol used. Its formal specification is:\n\n", "index": 1, "text": "\\begin{equation}\n\\label{eq:one}\n\\varepsilon_{\\vee}= \\bigvee_{i=0}^{s(y)} P(i) \\equiv \\left\\lbrace \\begin{array}{c}\n{\\displaystyle \\bigvee_{i=0}^{s(y)} P(i) \\Rightarrow \\bigvee_{i=0}^{y} P(i) \\vee P(s(y)) }\\\\\n{\\displaystyle \\bigvee_{i=0}^{0} P(i) \\Rightarrow P(0)}\n\\end{array}\\right. \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\varepsilon_{\\vee}=\\bigvee_{i=0}^{s(y)}P(i)\\equiv\\left\\{\\begin{array}[]{c}{%&#10;\\displaystyle\\bigvee_{i=0}^{s(y)}P(i)\\Rightarrow\\bigvee_{i=0}^{y}P(i)\\vee P(s(%&#10;y))}\\\\&#10;{\\displaystyle\\bigvee_{i=0}^{0}P(i)\\Rightarrow P(0)}\\end{array}\\right.\" display=\"block\"><mrow><msub><mi>\u03b5</mi><mo>\u2228</mo></msub><mo>=</mo><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munderover><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2261</mo><mrow><mo>{</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></munderover><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u21d2</mo><mrow><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></munderover><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2228</mo><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>0</mn></munderover><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u21d2</mo><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n\\begin{tabular}{ll}\n$\\varphi_{i}(n) = \\forall x_{1}^{i}\\cdots \\forall x_{\\alpha_{i}}^{i} F_{i}(n,x_{1}^{i},\\cdots, x_{\\alpha_{i}}^{i}),$ \\ \\ &$\\psi_{j}(n) = \\exists x_{1}^{j}\\cdots \\exists y_{\\beta_{j}}^{j} E_{j}(n,y_{1}^{j},\\cdots, y_{\\beta_{j}}^{j}),$\n\\end{tabular}\\\\\n\nfor $\\alpha_{i},\\beta_{j}\\in \\mathbb{N}$, $F_{i}$ and $E_{j}$ are quantifier-free schematic formulas and $\\Delta_n,\\Pi_n$ are multisets of quantifier-free formulas of fixed size; moreover, the only free variable in any of the formulas is $n:\\omega$. Then $S(n)$ is called a skolemized prenex sequent schema (sps-schema).\n\\end{definition}\n\n\\begin{definition}[Herbrand System]\n\\label{def:herbrand}\nLet $S(n)$ be a sps-schema as in Definition~\\ref{def:sps-schema}. Then a Herbrand system for $S(n)$ is a rewrite system ${\\cal R}$ (containing the list constructors and unary function symbols $w_{i}^{x}$, for x $\\in \\left\\lbrace \\varphi, \\psi \\right\\rbrace$), such that  for each $\\gamma \\in \\mathbb{N}$, the normal form of $w_{i}^{x}(\\gamma)$ w.r.t ${\\cal R}$ is a list of list of terms $t_{i,x,\\gamma}$ (of length $m(i,x)$) such that the sequent \n\n\n", "itemtype": "equation", "pos": 24663, "prevtext": "\n From the above described term and formulae language we can provide the inference rules of the \\textbf{LKE}-calculus, essentially the \\textbf{LK}-calculus~\\cite{prooftheory} plus an equational theory $\\varepsilon$ (in our case $\\varepsilon_{\\vee}$ Eq. \\ref{eq:one}). This theory, concerning our particular usage, is a primitive recursive term algebra describing the structure of the defined function (predicate) symbols. The \\textbf{LKE}-calculus is the base calculus for the \\textbf{LKS}-calculus which also includes {\\em proof links}.\n\\begin{definition}[$\\varepsilon$-inference rule]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{prooftree}\n\\AxiomC{$S\\left[ t\\right] $}\n\\RightLabel{$(\\varepsilon)$}\n\\UnaryInfC{$S\\left[ t'\\right] $}\n\\end{prooftree}\nIn the $\\varepsilon$ inference rule, the term $t$ in the sequent $S$ is replaced by a term $t'$ such that, given the equational theory  $\\varepsilon$,  $\\varepsilon \\models t = t'$.\n\\end{definition}\n\nTo extend the \\textbf{LKE}-calculus with  proof links we need a countably infinite set of {\\em proof symbols}  denoted by $\\varphi, \\psi,\\varphi_{i}, \\psi_{j} \\ldots$. Let $S(\\bar{x})$ by a  sequent with a vector of schematic variables $\\bar{x}$, by  $S(\\bar{t})$ we denote the sequent $S(\\bar{x})$ where each of the variables in $\\bar{x}$ is replaced by the terms in the vector $\\bar{t}$ respectively, assuming that they have the appropriate type. Let $\\varphi$ be a proof symbol and $S(\\bar{x})$ a sequent, then the expression \\AxiomC{$(\\varphi(\\bar{t}))$}\n\\dashedLine\n\\UnaryInfC{$S(\\bar{t})$}\n\\DisplayProof\nis called a {\\em proof link} . For a variable $n:\\omega$, proof links\nsuch that the only $\\omega$-variable is $n$ are called {\\em $n$-proof links} \\index{k-proof Link}.\n\n\\begin{definition}[\\textbf{LKE}-calculus~\\cite{CERESS2}]\nThe sequent calculus $\\mathbf{LKS}$\nconsists of the rules of $\\mathbf{LKE}$, where proof links may appear\nat the leaves of a proof.\n\\end{definition}\n\n\\begin{definition}[Proof schemata~\\cite{CERESS2}]\\label{def.proofschema}\n\\index{Proof Schemata}\n  Let $\\psi$ be a proof symbol and $S(n,\\bar{x})$ be a sequent\n  such that $n:\\omega$. Then a {\\em proof schema pair for $\\psi$} is a pair of $\\mathbf{LKS}$-proofs $(\\pi,\\nu(k))$ with end-sequents $S(0,\\bar{x})$ and $S(k+1,\\bar{x})$ respectively such that $\\pi$ may not contain proof links and $\\nu(k)$ may\n  contain only proof links of the form \\AxiomC{$(\\psi(k,\\bar{a}))$}\n  \\dashedLine\n  \\UnaryInfC{$S(k,\\bar{a})$}\n  \\DisplayProof \nand we say that it is a proof link to $\\psi$. We call $S(n,\\bar{x})$ the end sequent of $\\psi$ and assume an identification between the formula occurrences in the end sequents of $\\pi$ and $\\nu(k)$ so that we can speak of occurrences in the end sequent of $\\psi$. Finally a proof schema $\\Psi$ is a tuple of proof schema pairs for $\\psi_1 , \\cdots \\psi_\\alpha$ written as $\\left\\langle \\psi_1 , \\cdots \\psi_\\alpha \\right\\rangle$, such that the $\\mathbf{LKS}$-proofs for $\\psi_{\\beta}$ may also contain $n$-proof links to $\\psi_{\\gamma}$ for $1\\leq \\beta < \\gamma\\leq \\alpha$. We also say that the end sequent of $\\psi_1$ is the end sequent of $\\Psi$. \n\\end{definition}\n\nWe will not delve further into the structure of proof schemata and instead refer the reader to~\\cite{CERESS2}. We now introduce the {\\em characteristic clause set schema}.\n\n\\subsection{Characteristic Clause set Schema}\n\nThe construction of the characteristic clause set as described for the CERES method~\\cite{CERES} required inductively following the formula occurrences of cut formula ancestors up the proof tree to the leaves. However, in the case of proof schemata, the concept of ancestors and formula occurrence is more complex. A formula occurrence might be an ancestor of a cut formula in one recursive call and in another it might not. Additional machinery is necessary to extract the characteristic clause term from proof schemata. A set $\\Omega$ of formula occurrences from the end-sequent of an \\textbf{LKS}-proof $\\pi$ is called {\\em a configuration for $\\pi$}. A configuration $\\Omega$ for $\\pi$ is called relevant w.r.t. a proof schema $\\Psi$ if $\\pi$ is a proof in $\\Psi$ and there is a $\\gamma \\in \\mathbb{N}$ such that $\\pi$ induces a subproof $\\pi\\downarrow \\gamma$ of $\\Psi \\downarrow \\gamma$\nsuch that the occurrences in $\\Omega$ correspond to cut-ancestors below $\\pi\\downarrow \\gamma$~\\cite{thesis2012Tsvetan}. Note that the set of relevant cut-configurations can be computed given a proof schema $\\Psi$. To represent a proof symbol $\\varphi$ and configuration $\\Omega$ pairing in a clause set we assign them a {\\em clause set symbol} $cl^{\\varphi,\\Omega}(a,\\bar{x})$, where $a$ is a term of the $\\omega$ sort. \n\n\\begin{definition}[Characteristic clause term~\\cite{CERESS2}]\\label{def:charterm}\n\\index{Characteristic Term}\nLet $\\pi$ be an $\\mathbf{LKS}$-proof and $\\Omega$ a configuration. In the following, by $\\Gamma_{\\Omega}$ , $\\Delta_{\\Omega}$ and $\\Gamma_{C}$ , $\\Delta_{C}$ we will denote multisets of formulas of $\\Omega$- and $cut$-ancestors respectively. Let $r$ be an inference in $\\pi$. We define the clause-set term $\\Theta_r^{\\pi,\\Omega}$ inductively:\n\\begin{itemize}\n\\item if $r$ is an axiom of the form $\\Gamma_{\\Omega} ,\\Gamma_C , \\Gamma \\vdash \\Delta_{\\Omega} ,\\Delta_C , \\Delta$, then \\\\ $\\Theta_{r}^{\\pi,\\Omega} = \\left\\lbrace \\Gamma_{\\Omega} ,\\Gamma_C  \\vdash \\Delta_{\\Omega} ,\\Delta_C \\right\\rbrace $\n\\item if $r$ is a proof link of the form\n\\AxiomC{$\\psi(a,\\bar{u})$}\n\\dashedLine\n\\UnaryInfC{$\\Gamma_{\\Omega} ,\\Gamma_C , \\Gamma \\vdash \\Delta_{\\Omega} ,\\Delta_C , \\Delta$}\n\\DisplayProof\nthen define $\\Omega'$ as the set of formula occurrences from $\\Gamma_{\\Omega} ,\\Gamma_C  \\vdash \\Delta_{\\Omega} ,\\Delta_C$ and $\\Theta_{r}^{\\pi,\\Omega} = cl^{\\psi,\\Omega}(a,\\bar{u})$\n\\item if $r$ is a unary rule with immediate predecessor \\index{Predecessor} $r'$ , then $\\Theta_{r}^{\\pi,\\Omega} =  \\Theta_{r'}^{\\pi,\\Omega}$\n\n\\item if $r$ is a binary rule with immediate predecessors $r_1 $, $r_2 $, then \n\\begin{itemize}\n\\item if the auxiliary formulas of $r$ are $\\Omega$- or $cut$-ancestors, then\n$\\Theta_{r}^{\\pi,\\Omega} = \\Theta_{r_1}^{\\pi,\\Omega} \\oplus \\Theta_{r_2}^{\\pi,\\Omega}$\n\\item otherwise, $\\Theta_{r}^{\\pi,\\Omega} = \\Theta_{r_1}^{\\pi,\\Omega} \\otimes \\Theta_{r_2}^{\\pi,\\Omega}$\n\\end{itemize}\n\\end{itemize}\nFinally, define $\\Theta^{\\pi,\\Omega} = \\Theta_{r_0}^{\\pi,\\Omega}$ where $r_0$ is the last inference in $\\pi$ and $\\Theta^{\\pi} = \\Theta^{\\pi,\\emptyset}$. We call $\\Theta^{\\pi}$ the characteristic term of $\\pi$. \n\\end{definition}\n\n\nClause terms evaluate to sets of clauses by $|\\Theta| = \\Theta$ for clause sets $\\Theta$, $|\\Theta_1 \\oplus \\Theta_2| = |\\Theta_1| \\cup |\\Theta_2|$, $|\\Theta_1 \\otimes \\Theta_2| = \\{C \\circ D \\mid C \\in |\\Theta_1|, D \\in |\\Theta_2|\\}$.\n\nThe characteristic clause term is extracted for each proof symbol in a given proof schema $\\Psi$, and together they make the {\\em characteristic clause set schema} for $\\Psi$, $CL(\\Psi)$.\n\\begin{definition}[Characteristic Term Schema\\cite{CERESS2}]\nLet $\\Psi = \\left\\langle \\psi_{1},\\cdots, \\psi_{\\alpha} \\right\\rangle $ be a proof schema. We define the rewrite rules for clause-set symbols for all proof symbols $\\psi_{\\beta}$  and configurations $\\Omega$ as $cl^{\\psi_{\\beta},\\Omega}(0,\\overline{u}) \\rightarrow \\Theta^{\\pi_{\\beta},\\Omega}$ and $cl^{\\psi_{\\beta},\\Omega}(k+1,\\overline{u}) \\rightarrow \\Theta^{\\nu_{\\beta},\\Omega}$ where $1\\leq \\beta\\leq \\alpha$. Next, let $\\gamma\\in \\mathbb{N}$ and $cl^{\\psi_{\\beta},\\Omega}\\downarrow_{\\gamma}$ be the normal form of $cl^{\\psi_{\\beta},\\Omega}(\\gamma,\\overline{u})$ under the rewrite system just given extended by rewrite rules for defined function and predicate symbols. Then define $\\Theta^{\\psi_{\\beta},\\Omega} = cl^{\\psi_{\\beta},\\Omega}$ and $\\Theta^{\\Psi,\\Omega} = cl^{\\psi_{1},\\Omega}$ and finally the characteristic term schema $\\Theta^{\\Psi} =  \\Theta^{\\Psi,\\emptyset}$.\n\\end{definition}\n\\subsection{Resolution Proof Schemata} \n\nFrom the characteristic clause set we can construct {\\em clause schemata} which are an essential part of the definition of {\\em resolution terms} and {\\em resolution proof schema }\\cite{CERESS2}. Clause schemata serve as the base for the resolution terms used to construct a resolution proof schema. One additional notion needed for defining resolution proof schema is that of {\\em clause variables}. The idea behind clause variables is that parts of the clauses at the leaves can be passed down a refutation to be used later on. The definition of resolution proof schemata uses clause variables as a way to handle this passage of clauses. Substitutions on clause variables are defined in the usual way. \n\n\\begin{definition}[Clause Schema \\cite{CERESS2}]\nLet $b$ be an numeric term, $\\overline{u}$ a vector\nof schematic variables and $\\overline{X}$  a vector of clause variables. Then $c(b, \\overline{u}, \\overline{X})$ is\na clause schema w.r.t. the rewrite system $R$:\n\\begin{center}\n$c(0, \\overline{u}, \\overline{X}) \\rightarrow C \\circ X$\nand\n$c(k + 1, \\overline{u}, \\overline{X}) \\rightarrow c(k, \\overline{u}, \\overline{X}) \\circ D$\n\\end{center}\nwhere $C$ is a clause with $V(C) \\subseteq \\left\\lbrace \\overline{u} \\right\\rbrace$  and $D$ is a clause with $V(D) \\subseteq \\left\\lbrace k, \\overline{u}\\right\\rbrace $. Clauses and clause variables are clause schemata w.r.t. the empty rewrite system.\n\\end{definition}\n\\begin{definition}[Resolution Term \\cite{CERESS2}]\nClause schemata are resolution terms; if\n$\\rho_1$ and $\\rho_2$  are resolution terms, then $r(\\rho_1 ; \\rho_2 ; P)$ is a resolution term, where $P$ is an atom formula schema.\n\\end{definition}\n\nThe idea behind the resolution terms is that in the term  $r(\\rho_1 ; \\rho_2 ; P)$, $P$ is the resolved atom of the resolvents $\\rho_1, \\rho_2$. The notion of most general unifier has not yet been introduced being that we introduce the concept as a separate schema from the resolution proof schema. \n\n\\begin{definition}[Resolution Proof Schema \\cite{CERESS2}]\nA resolution proof schema $\\mathcal{R}(n)$ is a structure $( \\varrho_1 , \\cdots , \\varrho_\\alpha )$ together with a set of rewrite rules $\\mathcal{R} = \\mathcal{R}_1 \\cup \\cdots \\cup \\mathcal{R}_{\\alpha}$ ,\nwhere the $\\mathcal{R}_i\\ (for \\ 1 \\leq i \\leq \\alpha )$ are pairs of rewrite rules \n\\begin{center}\n$\\varrho_i (0, \\overline{w},\\overline{ u},  \\overline{X} ) \\rightarrow \\eta_i$\\\\\nand\\\\\n$\\varrho_i (k+1,\\overline{w},\\overline{ u},  \\overline{X} ) \\rightarrow \\eta'_i $\n\\end{center}\n\nwhere, $\\overline{w},\\overline{ u},$ and $ \\overline{X}$ are vectors of $\\omega$, schematic, and clause variables respectively, $\\eta_i$ is a resolution term over terms of the form $\\varrho_j(a_j , \\overline{m},\\overline{ t},  \\overline{C})$ for $i<j\\leq \\alpha$, and $\\eta'_i$ is a resolution term over terms of the form $\\varrho_j(a_j , \\overline{m},\\overline{ t},  \\overline{C})$ and $\\varrho_i(k, \\overline{m},\\overline{ t},  \\overline{C})$ for $i < j \\leq \\alpha$; by $a_j$, we denote a term of the  $\\omega$ sort.\n\\end{definition}\n\nThe idea behind the definition of resolution proof schema is that the definition simulates a recursive construction of a resolution derivation tree and can be unfolded into a tree once the free parameter is instantiated. The expected properties of resolution and resolution derivations hold for resolution proof schema, more detail can be found in \\cite{CERESS2}. \n\n\\begin{definition}[Substitution Schema \\cite{CERESS2}]\nLet $u_1 , \\cdots , u_{\\alpha}$ be schematic variable\nsymbols of type $\\omega \\rightarrow \\iota$ and $t_1 , \\cdots , t_{\\alpha}$ be term schemata containing no other $\\omega$-variables than $k$. Then a substitution schema is an expression of the form $\\left[ u_1 /\\lambda k.t_{1} , \\cdots , u_{\\alpha} /\\lambda k.t_{\\alpha} \\right]$.\n\\end{definition}\n\nSemantically, the meaning of the substitution schema is for all $\\gamma\\in \\mathbb{N}$ we have a substitution of the form $\\left[ u_1(\\gamma) /\\lambda k.t_{1}\\downarrow_{\\gamma} , \\cdots , u_{\\alpha}(\\gamma) /\\lambda k.t_{\\alpha}\\downarrow_{\\gamma} \\right]$. For the resolution proof schema the semantic meaning is as follows, Let $R(n) = ( \\varrho_{1}, \\cdots , \\varrho_{\\alpha} )$ be a resolution proof schema, $\\theta$ be a clause substitution, $\\nu$ an $\\omega$-variable substitution, $\\vartheta$ be a substitution schema, and $\\gamma \\in \\mathbb{N}$, then  $R(\\gamma)\\downarrow$ denotes a resolution\nterm which has a normal form of $\\varrho_1 (n,\\overline{w}, \\overline{u} , \\overline{X} )\\theta\\nu\\vartheta[n/\\gamma ]$ w.r.t. $R$ extended by rewrite rules for defined function and predicate symbols.\n\n\n\\subsection{Herbrand Systems}\n\nFrom the resolution proof schema and the substitution schema we can exact a so-called {\\em Herbrand system}. The idea is to generalize the mid sequent theorem of Gentzen to proof schemata \\cite{Baaz:2013:MC:2509679,prooftheory}. This theorem states that a proof (cut-free or with quantifier-free cuts) of a prenex end-sequent can be transformed in a way that there is a midsequent separating quantifier inferences from propositional ones. The mid-sequent is propositionally valid (w.r.t. the axioms) and contains (in general several) instances of the matrices of the prenex formulas; it is also called a {\\em Herbrand sequent}. The aim of this paper is to extract schematic Herbrand sequents from schematic cut-elimination via CERES. We restrict the sequents further to skolemized ones. In the schematization of these sequents we allow only the matrices of the formulas to contain schematic variables (the number of formulas in the sequents and the quantifier prefixes are fixed).  \n\n\\begin{definition}[skolemized prenex sequent schema]\\label{def:sps-schema}\nLet \n\n", "index": 3, "text": "$$S(n) = \\Delta_n, \\varphi_{1}(n), \\cdots, \\varphi_{k}(n) \\vdash \\psi_{1}(n), \\cdots,  \\psi_{l}(n), \\Pi_n, \\mbox{ for }k,l\\in \\mathbb{N} \\mbox{ where}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"S(n)=\\Delta_{n},\\varphi_{1}(n),\\cdots,\\varphi_{k}(n)\\vdash\\psi_{1}(n),\\cdots,%&#10;\\psi_{l}(n),\\Pi_{n},\\mbox{ for }k,l\\in\\mathbb{N}\\mbox{ where}\" display=\"block\"><mrow><mrow><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi mathvariant=\"normal\">\u0394</mi><mi>n</mi></msub><mo>,</mo><mrow><msub><mi>\u03c6</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><mrow><msub><mi>\u03c6</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>\u22a2</mo><mrow><mrow><mrow><msub><mi>\u03c8</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>,</mo><mrow><msub><mi>\u03c8</mi><mi>l</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><msub><mi mathvariant=\"normal\">\u03a0</mi><mi>n</mi></msub><mo>,</mo><mrow><mtext>\u00a0for\u00a0</mtext><mo>\u2062</mo><mi>k</mi></mrow><mo>,</mo><mi>l</mi></mrow><mo>\u2208</mo><mrow><mi>\u2115</mi><mo>\u2062</mo><mtext>\u00a0where</mtext></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\nfor \n\n\\begin{eqnarray*}\n\\Phi_j(\\gamma) &=& \\bigwedge^{m(j,\\varphi)}_{p=1}E_j(\\gamma,t_{j,\\varphi,\\gamma}(p,1),\\ldots,t_{j,\\varphi,\\gamma}(p,\\alpha_j))\\ (j=1,\\ldots,k),\\\\\n\\Psi_j(\\gamma) &=& \\bigvee^{m(j,\\psi)}_{p=1}F_j(\\gamma,t_{j,\\psi,\\gamma}(p,1),\\ldots,t_{j,\\psi,\\gamma}(p,\\beta_j))\\ (j=1,\\ldots,l),\n\\end{eqnarray*}\n\nis \\textbf{LKE}-provable.\n\\end{definition}\n\nThough our definition of a Herbrand system differs from the definition introduced in~\\cite{CERESS2} (where only purely existential schemata are treated), it is only a minor syntactic generalization. All results proven in~\\cite{CERESS2} carry over to this more general form above.\n\n\n\n\\section{``Mathematical'' Proof of the ECA Statement and Discussion of Formal Proof}\\label{sec:MathNiA}\n\nFor lack of space, we will not provide a formal proof of the ECA-schema in the \\textbf{LKS}-calculus (see Appendix \\ref{sec:FormECA}), but rather a mathematical argument proving the statement, of which closely follows the intended formal proof. The ECA-schema can be stated as follows: \n\n\\begin{theorem}[Eventually Constant Assertion]\nGiven a total monotonically decreasing function $f:\\mathbb{N}\\rightarrow \\left\\lbrace 0,\\cdots , n \\right\\rbrace $, for $n \\in \\mathbb{N}$, then there exists an $x \\in \\mathbb{N}$ such that for all $y \\in \\mathbb{N}$, where $x\\leq y$, it is the case that $f(x) = f(y)$.\n\\end{theorem}\n\\begin{proof}\nIf the range only contains $0$ then the theorem trivially holds. Let us assume it holds for a codomain with $n$ elements and show it hold for a codomain with $n+1$ elements. If for all positions $x$, $f(x)=n$ then the theorem holds, else if at some $y$, $f(y)\\not = n$ then from that point on $f$ cannot map to $n$ because the function is monotonically decreasing, thus,  $f$ will only have $n$ elements in its codomain and the theorem holds in this case by the induction hypothesis.\n\\end{proof}\n\nThe cut consists of the case distinction made in the stepcase. When written in the \\textbf{LKS}-calculus, it is as follows: \n\n \n", "itemtype": "equation", "pos": 25934, "prevtext": "\n\n\\begin{tabular}{ll}\n$\\varphi_{i}(n) = \\forall x_{1}^{i}\\cdots \\forall x_{\\alpha_{i}}^{i} F_{i}(n,x_{1}^{i},\\cdots, x_{\\alpha_{i}}^{i}),$ \\ \\ &$\\psi_{j}(n) = \\exists x_{1}^{j}\\cdots \\exists y_{\\beta_{j}}^{j} E_{j}(n,y_{1}^{j},\\cdots, y_{\\beta_{j}}^{j}),$\n\\end{tabular}\\\\\n\nfor $\\alpha_{i},\\beta_{j}\\in \\mathbb{N}$, $F_{i}$ and $E_{j}$ are quantifier-free schematic formulas and $\\Delta_n,\\Pi_n$ are multisets of quantifier-free formulas of fixed size; moreover, the only free variable in any of the formulas is $n:\\omega$. Then $S(n)$ is called a skolemized prenex sequent schema (sps-schema).\n\\end{definition}\n\n\\begin{definition}[Herbrand System]\n\\label{def:herbrand}\nLet $S(n)$ be a sps-schema as in Definition~\\ref{def:sps-schema}. Then a Herbrand system for $S(n)$ is a rewrite system ${\\cal R}$ (containing the list constructors and unary function symbols $w_{i}^{x}$, for x $\\in \\left\\lbrace \\varphi, \\psi \\right\\rbrace$), such that  for each $\\gamma \\in \\mathbb{N}$, the normal form of $w_{i}^{x}(\\gamma)$ w.r.t ${\\cal R}$ is a list of list of terms $t_{i,x,\\gamma}$ (of length $m(i,x)$) such that the sequent \n\n\n", "index": 5, "text": "$$\\Delta_\\gamma,\\Phi_1(\\gamma),\\ldots,\\Phi_k(\\gamma) {\\vdash} \\Psi_1(\\gamma),\\ldots,\\Psi_l(\\gamma)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\Delta_{\\gamma},\\Phi_{1}(\\gamma),\\ldots,\\Phi_{k}(\\gamma){\\vdash}\\Psi_{1}(%&#10;\\gamma),\\ldots,\\Psi_{l}(\\gamma)\" display=\"block\"><mrow><mrow><msub><mi mathvariant=\"normal\">\u0394</mi><mi>\u03b3</mi></msub><mo>,</mo><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><msub><mi mathvariant=\"normal\">\u03a6</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b3</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u22a2</mo><mrow><mrow><msub><mi mathvariant=\"normal\">\u03a8</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><msub><mi mathvariant=\"normal\">\u03a8</mi><mi>l</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b3</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\nNotice that if we are to formalize the statement  in the \\textbf{LKS}-calculus the consequent has a $\\exists \\forall$ quantifier prefix: \n\n", "itemtype": "equation", "pos": 28044, "prevtext": "\n\nfor \n\n\\begin{eqnarray*}\n\\Phi_j(\\gamma) &=& \\bigwedge^{m(j,\\varphi)}_{p=1}E_j(\\gamma,t_{j,\\varphi,\\gamma}(p,1),\\ldots,t_{j,\\varphi,\\gamma}(p,\\alpha_j))\\ (j=1,\\ldots,k),\\\\\n\\Psi_j(\\gamma) &=& \\bigvee^{m(j,\\psi)}_{p=1}F_j(\\gamma,t_{j,\\psi,\\gamma}(p,1),\\ldots,t_{j,\\psi,\\gamma}(p,\\beta_j))\\ (j=1,\\ldots,l),\n\\end{eqnarray*}\n\nis \\textbf{LKE}-provable.\n\\end{definition}\n\nThough our definition of a Herbrand system differs from the definition introduced in~\\cite{CERESS2} (where only purely existential schemata are treated), it is only a minor syntactic generalization. All results proven in~\\cite{CERESS2} carry over to this more general form above.\n\n\n\n\\section{``Mathematical'' Proof of the ECA Statement and Discussion of Formal Proof}\\label{sec:MathNiA}\n\nFor lack of space, we will not provide a formal proof of the ECA-schema in the \\textbf{LKS}-calculus (see Appendix \\ref{sec:FormECA}), but rather a mathematical argument proving the statement, of which closely follows the intended formal proof. The ECA-schema can be stated as follows: \n\n\\begin{theorem}[Eventually Constant Assertion]\nGiven a total monotonically decreasing function $f:\\mathbb{N}\\rightarrow \\left\\lbrace 0,\\cdots , n \\right\\rbrace $, for $n \\in \\mathbb{N}$, then there exists an $x \\in \\mathbb{N}$ such that for all $y \\in \\mathbb{N}$, where $x\\leq y$, it is the case that $f(x) = f(y)$.\n\\end{theorem}\n\\begin{proof}\nIf the range only contains $0$ then the theorem trivially holds. Let us assume it holds for a codomain with $n$ elements and show it hold for a codomain with $n+1$ elements. If for all positions $x$, $f(x)=n$ then the theorem holds, else if at some $y$, $f(y)\\not = n$ then from that point on $f$ cannot map to $n$ because the function is monotonically decreasing, thus,  $f$ will only have $n$ elements in its codomain and the theorem holds in this case by the induction hypothesis.\n\\end{proof}\n\nThe cut consists of the case distinction made in the stepcase. When written in the \\textbf{LKS}-calculus, it is as follows: \n\n \n", "index": 7, "text": "$$\\exists x \\forall y \\left( \\left( \\left( x\\leq y  \\right) \\rightarrow n+1 = f(y) \\right) \\vee f(y) < n+1 \\right)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\exists x\\forall y\\left(\\left(\\left(x\\leq y\\right)\\rightarrow n+1=f(y)\\right)%&#10;\\vee f(y)&lt;n+1\\right)\" display=\"block\"><mrow><mo>\u2203</mo><mi>x</mi><mo>\u2200</mo><mi>y</mi><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mo>(</mo><mi>x</mi><mo>\u2264</mo><mi>y</mi><mo>)</mo></mrow><mo>\u2192</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>\u2228</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\nThe CERES method (as well as the schematic CERES method) was designed for proofs without {\\em strong quantification} in the end sequent. To get around this problem the proofs have to be {\\em skolemized} \\cite{Baaz:2383422}.We will not go into details of proof skolemization in this work, but to note, in the formal proof $g(\\cdot )$, is the introduced skolem symbol. \n\n\n\\section{Extraction of the Characteristic Term Schema}\\label{sec:CCSSE}\n\nEach of the proof schema pairs of the formal proof (see Appendix \\ref{sec:FormECA}) have one cut configuration. In the case of $\\psi$ it is the empty configuration, and in the case of $\\varphi(n)$ it is \n", "itemtype": "equation", "pos": 28300, "prevtext": "\n\nNotice that if we are to formalize the statement  in the \\textbf{LKS}-calculus the consequent has a $\\exists \\forall$ quantifier prefix: \n\n", "index": 9, "text": "$$\\begin{array}{c}\\forall x ( \\bigvee_{i=0}^{n+1} i = f(x)) ,  \\forall x \\forall y \\Big(  x\\leq y \\rightarrow f(y) \\leq f(x) \\Big)  \\vdash   \\exists x \\forall y ( x\\leq y  \\rightarrow f(x) = f(y)  ) \\end{array}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{c}\\forall x(\\bigvee_{i=0}^{n+1}i=f(x)),\\forall x\\forall y\\Big{%&#10;(}x\\leq y\\rightarrow f(y)\\leq f(x)\\Big{)}\\vdash\\exists x\\forall y(x\\leq y%&#10;\\rightarrow f(x)=f(y))\\end{array}\" display=\"block\"><mtable displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mo>\u2200</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mo>\u2200</mo><mi>x</mi><mo>\u2200</mo><mi>y</mi><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mi>x</mi><mo>\u2264</mo><mi>y</mi><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mo>\u22a2</mo><mo>\u2203</mo><mi>x</mi><mo>\u2200</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>\u2264</mo><mi>y</mi><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": " This holds for the basecases as well as the stepcases. Thus, we have the following clause set terms: \n\n\\begin{subequations}\n\\label{seq:charclaset}\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nThe CERES method (as well as the schematic CERES method) was designed for proofs without {\\em strong quantification} in the end sequent. To get around this problem the proofs have to be {\\em skolemized} \\cite{Baaz:2383422}.We will not go into details of proof skolemization in this work, but to note, in the formal proof $g(\\cdot )$, is the introduced skolem symbol. \n\n\n\\section{Extraction of the Characteristic Term Schema}\\label{sec:CCSSE}\n\nEach of the proof schema pairs of the formal proof (see Appendix \\ref{sec:FormECA}) have one cut configuration. In the case of $\\psi$ it is the empty configuration, and in the case of $\\varphi(n)$ it is \n", "index": 11, "text": "$$\\Omega(n)\\equiv \\exists x \\forall y \\left( \\left( \\left( x\\leq y  \\right) \\rightarrow n+1= f(y) \\right)    \\vee f(y) < n+1 \\right).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\Omega(n)\\equiv\\exists x\\forall y\\left(\\left(\\left(x\\leq y\\right)\\rightarrow n%&#10;+1=f(y)\\right)\\vee f(y)&lt;n+1\\right).\" display=\"block\"><mrow><mi mathvariant=\"normal\">\u03a9</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mo>\u2203</mo><mi>x</mi><mo>\u2200</mo><mi>y</mi><mrow><mo>(</mo><mrow><mo>(</mo><mrow><mo>(</mo><mi>x</mi><mo>\u2264</mo><mi>y</mi><mo>)</mo></mrow><mo>\u2192</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>\u2228</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 29442, "prevtext": " This holds for the basecases as well as the stepcases. Thus, we have the following clause set terms: \n\n\\begin{subequations}\n\\label{seq:charclaset}\n\n", "index": 13, "text": "\\begin{equation}\n\\begin{array}{l} CL_{ECA}(0)\\equiv \\Theta^{\\psi,\\emptyset}(0)\\equiv   cl^{\\varphi,\\Omega(0)}(0) \\oplus   \\left(\\left\\lbrace\\vdash f(\\alpha)<0 \\right\\rbrace  \\otimes \\left\\lbrace \\vdash 0=f(\\alpha)\\right\\rbrace  \\otimes  \\right.  \\\\ \\left. \\left\\lbrace  0\\leq \\beta \\vdash \\right\\rbrace \\right)  \\end{array}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{l}CL_{ECA}(0)\\equiv\\Theta^{\\psi,\\emptyset}(0)\\equiv cl^{%&#10;\\varphi,\\Omega(0)}(0)\\oplus\\left(\\left\\{\\vdash f(\\alpha)&lt;0\\right\\}\\otimes\\left%&#10;\\{\\vdash 0=f(\\alpha)\\right\\}\\otimes\\right.\\\\&#10;\\left.\\left\\{0\\leq\\beta\\vdash\\right\\}\\right)\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>C</mi><msub><mi>L</mi><mrow><mi>E</mi><mo>\u2062</mo><mi>C</mi><mo>\u2062</mo><mi>A</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><msup><mi mathvariant=\"normal\">\u0398</mi><mrow><mi>\u03c8</mi><mo>,</mo><mi mathvariant=\"normal\">\u2205</mi></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mi>c</mi><msup><mi>l</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2295</mo><mrow><mo>(</mo><mrow><mo>{</mo><mo>\u22a2</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo>}</mo></mrow><mo>\u2297</mo><mrow><mo>{</mo><mo>\u22a2</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>}</mo></mrow><mo>\u2297</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo>{</mo><mn>0</mn><mo>\u2264</mo><mi>\u03b2</mi><mo>\u22a2</mo><mo>}</mo></mrow><mo>)</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 29781, "prevtext": "\n\n", "index": 15, "text": "\\begin{equation}\n\\begin{array}{l} cl^{\\varphi,\\Omega(0)}(0) \\equiv\\Theta^{\\varphi,\\Omega(0)}(0) \\equiv  \\left\\lbrace  f(\\alpha)<0\\vdash \\right\\rbrace \\oplus\\left\\lbrace  f(g(\\alpha))<0\\vdash \\right\\rbrace  \\oplus \\left\\lbrace  \\vdash \\alpha\\leq\\alpha \\right\\rbrace   \\\\ \\oplus \\left\\lbrace \\vdash \\alpha\\leq g(\\alpha)\\right\\rbrace  \\oplus \\left\\lbrace  0=f(\\alpha), 0=f(g(\\alpha)) \\vdash \\right\\rbrace  \\end{array}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{l}cl^{\\varphi,\\Omega(0)}(0)\\equiv\\Theta^{\\varphi,\\Omega(0)}(0)%&#10;\\equiv\\left\\{f(\\alpha)&lt;0\\vdash\\right\\}\\oplus\\left\\{f(g(\\alpha))&lt;0\\vdash\\right%&#10;\\}\\oplus\\left\\{\\vdash\\alpha\\leq\\alpha\\right\\}\\\\&#10;\\oplus\\left\\{\\vdash\\alpha\\leq g(\\alpha)\\right\\}\\oplus\\left\\{0=f(\\alpha),0=f(g(%&#10;\\alpha))\\vdash\\right\\}\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>c</mi><msup><mi>l</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><msup><mi mathvariant=\"normal\">\u0398</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mrow><mo>{</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo>\u22a2</mo><mo>}</mo></mrow><mo>\u2295</mo><mrow><mo>{</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo>\u22a2</mo><mo>}</mo></mrow><mo>\u2295</mo><mrow><mo>{</mo><mo>\u22a2</mo><mi>\u03b1</mi><mo>\u2264</mo><mi>\u03b1</mi><mo>}</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>\u2295</mo><mrow><mo>{</mo><mo>\u22a2</mo><mi>\u03b1</mi><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>}</mo></mrow><mo>\u2295</mo><mrow><mo>{</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u22a2</mo><mo>}</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": " \n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\n", "index": 17, "text": "\\begin{equation}\n\\begin{array}{l} CL_{ECA}(n+1)\\equiv \\Theta^{\\psi,\\emptyset}(n+1)\\equiv    cl^{\\varphi,\\Omega(n+1)}(n+1)\\oplus   \\left(\\left\\lbrace \\vdash f(\\alpha)<n+1 \\right\\rbrace  \\right.   \\\\  \\left.   \\otimes \\left\\lbrace  \\vdash n+1=f(\\alpha) \\right\\rbrace \\otimes   \\left\\lbrace 0\\leq \\beta \\vdash \\right\\rbrace  \\right)  \\end{array}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{l}CL_{ECA}(n+1)\\equiv\\Theta^{\\psi,\\emptyset}(n+1)\\equiv cl^{%&#10;\\varphi,\\Omega(n+1)}(n+1)\\oplus\\left(\\left\\{\\vdash f(\\alpha)&lt;n+1\\right\\}\\right%&#10;.\\\\&#10;\\left.\\otimes\\left\\{\\vdash n+1=f(\\alpha)\\right\\}\\otimes\\left\\{0\\leq\\beta\\vdash%&#10;\\right\\}\\right)\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>C</mi><msub><mi>L</mi><mrow><mi>E</mi><mo>\u2062</mo><mi>C</mi><mo>\u2062</mo><mi>A</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><msup><mi mathvariant=\"normal\">\u0398</mi><mrow><mi>\u03c8</mi><mo>,</mo><mi mathvariant=\"normal\">\u2205</mi></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mi>c</mi><msup><mi>l</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2295</mo><mrow><mo>(</mo><mrow><mo>{</mo><mo>\u22a2</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>}</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>\u2297</mo><mrow><mo>{</mo><mo>\u22a2</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>}</mo></mrow><mo>\u2297</mo><mrow><mo>{</mo><mn>0</mn><mo>\u2264</mo><mi>\u03b2</mi><mo>\u22a2</mo><mo>}</mo></mrow><mo>)</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\\end{subequations}\nIn the characteristic clause set schema $CL_{ECA}(n+1)$ presented in Eq.\\ref{seq:charclaset}  tautology and subsumption elimination have not been applied. Applying both types of elimination to $CL_{ECA}(n)$ and normalizing the clause set yields the following clause set $C(n)$:\n\n\n", "itemtype": "equation", "pos": 30572, "prevtext": " \n\n\n", "index": 19, "text": "\\begin{equation}\n\\begin{array}{l}  cl^{\\varphi,\\Omega(n+1)}(n+1) \\equiv \\Theta^{\\varphi,\\Omega(n+1)}(n+1)\\equiv  {\\scriptstyle     cl^{\\varphi,\\Omega(n)}(n) \\oplus  \\left\\lbrace n+1=f(\\alpha),n+1=f(g(\\alpha)) \\vdash \\right\\rbrace  \\oplus } \\\\ {\\scriptstyle  \\left\\lbrace \\vdash \\alpha\\leq\\alpha\\right\\rbrace  \\oplus \\left\\lbrace  \\alpha\\leq g(\\alpha)\\right\\rbrace  \\oplus \\left\\lbrace  n+1=f(\\beta)\\vdash n+1=f(\\beta)\\right\\rbrace  \\oplus \\left\\lbrace \\alpha\\leq\\beta \\vdash \\alpha\\leq\\beta \\right\\rbrace \\oplus  \\left\\lbrace f(\\beta)<n+1 \\vdash f(\\beta)<n+1\\right\\rbrace  \\oplus  }  \\\\ {\\scriptstyle  \\left\\lbrace f(\\alpha)<n+1,\\alpha\\leq\\beta \\vdash n=f(\\beta),f(\\beta)<n  \\right\\rbrace   } \\end{array}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{l}cl^{\\varphi,\\Omega(n+1)}(n+1)\\equiv\\Theta^{\\varphi,\\Omega(n+%&#10;1)}(n+1)\\equiv{\\scriptstyle cl^{\\varphi,\\Omega(n)}(n)\\oplus\\left\\{n+1=f(\\alpha%&#10;),n+1=f(g(\\alpha))\\vdash\\right\\}\\oplus}\\\\&#10;{\\scriptstyle\\left\\{\\vdash\\alpha\\leq\\alpha\\right\\}\\oplus\\left\\{\\alpha\\leq g(%&#10;\\alpha)\\right\\}\\oplus\\left\\{n+1=f(\\beta)\\vdash n+1=f(\\beta)\\right\\}\\oplus\\left%&#10;\\{\\alpha\\leq\\beta\\vdash\\alpha\\leq\\beta\\right\\}\\oplus\\left\\{f(\\beta)&lt;n+1\\vdash f%&#10;(\\beta)&lt;n+1\\right\\}\\oplus}\\\\&#10;{\\scriptstyle\\left\\{f(\\alpha)&lt;n+1,\\alpha\\leq\\beta\\vdash n=f(\\beta),f(\\beta)&lt;n%&#10;\\right\\}}\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>c</mi><msup><mi>l</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><msup><mi mathvariant=\"normal\">\u0398</mi><mrow><mi>\u03c6</mi><mo>,</mo><mrow><mi mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mi mathsize=\"70%\">c</mi><msup><mi mathsize=\"70%\">l</mi><mrow><mi mathsize=\"71%\">\u03c6</mi><mo mathsize=\"71%\" stretchy=\"false\">,</mo><mrow><mi mathsize=\"71%\" mathvariant=\"normal\">\u03a9</mi><mo>\u2062</mo><mrow><mo maxsize=\"71%\" minsize=\"71%\">(</mo><mi mathsize=\"71%\">n</mi><mo maxsize=\"71%\" minsize=\"71%\">)</mo></mrow></mrow></mrow></msup><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">n</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo><mrow><mo>{</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo mathsize=\"70%\" stretchy=\"false\">=</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b1</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">,</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo mathsize=\"70%\" stretchy=\"false\">=</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">g</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b1</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo>{</mo><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mi mathsize=\"70%\">\u03b1</mi><mo mathsize=\"70%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"70%\">\u03b1</mi><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo><mrow><mo>{</mo><mi mathsize=\"70%\">\u03b1</mi><mo mathsize=\"70%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"70%\">g</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b1</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo><mrow><mo>{</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo mathsize=\"70%\" stretchy=\"false\">=</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo mathsize=\"70%\" stretchy=\"false\">=</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo><mrow><mo>{</mo><mi mathsize=\"70%\">\u03b1</mi><mo mathsize=\"70%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"70%\">\u03b2</mi><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mi mathsize=\"70%\">\u03b1</mi><mo mathsize=\"70%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"70%\">\u03b2</mi><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo><mrow><mo>{</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">&lt;</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mi mathsize=\"70%\">f</mi><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">&lt;</mo><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn><mo>}</mo></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u2295</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>{</mo><mrow><mrow><mrow><mrow><mi mathsize=\"70%\">f</mi><mo>\u2062</mo><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b1</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow></mrow><mo mathsize=\"70%\" stretchy=\"false\">&lt;</mo><mrow><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">+</mo><mn mathsize=\"70%\">1</mn></mrow></mrow><mo mathsize=\"70%\" stretchy=\"false\">,</mo><mrow><mi mathsize=\"70%\">\u03b1</mi><mo mathsize=\"70%\" stretchy=\"false\">\u2264</mo><mi mathsize=\"70%\">\u03b2</mi></mrow></mrow><mo mathsize=\"70%\" stretchy=\"false\">\u22a2</mo><mrow><mrow><mi mathsize=\"70%\">n</mi><mo mathsize=\"70%\" stretchy=\"false\">=</mo><mrow><mi mathsize=\"70%\">f</mi><mo>\u2062</mo><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow></mrow></mrow><mo mathsize=\"70%\" stretchy=\"false\">,</mo><mrow><mrow><mi mathsize=\"70%\">f</mi><mo>\u2062</mo><mrow><mo maxsize=\"70%\" minsize=\"70%\">(</mo><mi mathsize=\"70%\">\u03b2</mi><mo maxsize=\"70%\" minsize=\"70%\">)</mo></mrow></mrow><mo mathsize=\"70%\" stretchy=\"false\">&lt;</mo><mi mathsize=\"70%\">n</mi></mrow></mrow></mrow><mo>}</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\nWe have introduced clause names, schematic variables, and an additional  $\\omega$-variable which will be used in the refutation of Sec.~\\ref{sec:refuteset}.\n\n\\section{Refutation of the Characteristic Clause set of the ECA-schema} \\label{sec:refuteset}\n\nWe discovered the resolution refutation schema which we present here with the help of the SPASS theorem prover \\cite{SpassProver} in default mode, and with the flags for standard resolution and ordered resolution set. Various other modes of the theorem prover were tested, however, given that we needed to translate the resulting proof into the simple resolution language of \\cite{CERESS2}, the chosen modes provided the easiest proofs for translation. After running the theorem prover on five instances of the clause set, we where able to extract an invariant for the  resolution refutation schema. Essentially, the refutation differentiates between the symbols occurring in the codomain of $f$ and not occurring. This is denoted using the function $g$. The excerpt from the SPASS output in Table \\ref{tabone} indicates the invariant. However, even though SPASS was able to provide a refutation for each instance, we could not use these refutations directly in the resolution refutation schema being that the SPASS output ignores the structural importance of the $\\omega$ sort. Unlike the ordering problem of the NiA-schema \\cite{MeCadePaper2015,MyThesis}, this choice made by SPASS was not necessary to the refutation of the ECA-schema and we were able find a suitable refutation. \n\\begin{table}\n\\begin{tabular}{l|l}\n310[0:MRR:309.0,306.1] &  $\\vdash$ \\ $f(\\alpha) < 3$\\ \\\\ \n311[0:MRR:10.1,310.0] & $\\alpha \\leq \\beta$ $\\vdash$ \\ $2 = f(\\beta)$ \\ \\ $f(\\beta) < 2$\\ \\\\\n312[0:Res:2.0,311.0] &  $\\vdash$ \\ $2 = f(\\alpha)$ \\ \\ $f(\\alpha) < 2$\\\\\n314[0:Res:312.0,6.1] & \\ $2 = f(\\alpha)$ \\ $\\vdash$ \\ $f(g(\\beta)) < 2$\\ \\\\\n315[0:Res:314.1,11.1] & \\ $2 = f(\\alpha)$ \\ \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $1 = f(\\beta)$ \\ \\ $f(\\beta) < 1$\\ \\\\\n316[0:Res:312.0,315.0] & \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(\\beta)$ \\ \\ $f(\\beta) < 1$\\ \\\\\n317[0:Res:2.0,316.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(g(\\alpha))$ \\ \\ $f(g(\\alpha)) < 1$\\ \\\\\n318[0:Res:3.0,316.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(g(g(\\alpha)))$ \\ \\ $f(g(g(\\alpha))) < 1$\\ \\\\\n321[0:Res:318.1,7.1] & \\ $1 = f(g(\\alpha))$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $f(g(g(\\alpha))) < 1$\\ \\\\\n322[0:Res:321.2,14.1] & \\ $1 = f(g(\\alpha))$ \\ \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n325[0:Res:317.1,322.0] & \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n327[0:Obv:325.1] & \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n328[0:Res:2.0,327.0] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(\\alpha)))$ \\\\\n329[0:Res:3.0,327.0] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(g(\\alpha))))$ \\\\\n335[0:Res:329.2,8.1] & \\ $0 = f(g(g(\\alpha)))$ \\ $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\\\\n336[0:MRR:335.0,328.2] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\\\\n337[0:Res:336.0,14.1] & \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n338[0:Res:2.0,337.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(\\alpha))$ \\\\\n339[0:Res:3.0,337.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(\\alpha)))$ \\\\\n344[0:Res:339.1,8.1] & \\ $0 = f(g(\\alpha))$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\\\\n345[0:MRR:344.0,338.1] &  $\\vdash$ \\ $f(\\alpha) < 2$\\\\\n\\end{tabular}\n\\caption{Excerpt from SPASS output for the clause set instance $C(5)$ indicating the invariant.}\\label{tabone}\n\\end{table}\n\nOur resolution refutation schema of the ECA-schema is $\\mathcal{R} = \\left(\\varrho_{1},\\cdots ,\\varrho_{10} \\right)$, where we use one clause variable $Y$, two schematic variables, and one $\\omega$-variable. Our substitution schema is as follows: \n\n", "itemtype": "equation", "pos": 31590, "prevtext": "\n\\end{subequations}\nIn the characteristic clause set schema $CL_{ECA}(n+1)$ presented in Eq.\\ref{seq:charclaset}  tautology and subsumption elimination have not been applied. Applying both types of elimination to $CL_{ECA}(n)$ and normalizing the clause set yields the following clause set $C(n)$:\n\n\n", "index": 21, "text": "$$\\begin{array}{ccc}\nC1(x,k) & \\equiv &\\vdash x(k)  \\leq  x(k) \\\\ \nC2(x,k) &\\equiv &\\vdash x(k) \\leq g(x(k)) \\\\\nC3(x,i,k) &\\equiv & i = f(x(k)) , i = f(g(x(k))) \\vdash \\\\ \nC4(x,y,i,k) & \\equiv & y(k) \\leq x(k) , f(y(k))< i+1 \\vdash\\\\ && f(x(k))< i , i = f(x(k))\\\\\nC4'(x,y,i,k) & \\equiv & y(k) \\leq x(k+1) , f(y(k))< i+1 \\vdash\\\\ && f(x(k+1))< i , i = f(x(k+1))\\\\\nC5(x,k) & \\equiv & f(x(k))< 0\\vdash  \\\\\nC6(x,k) &\\equiv & f(g(x(k)))< 0\\vdash  \\\\\nC7(x,k) & \\equiv & 0\\leq x(k) \\vdash f(x(k))< n , f(x(k)) = n\n\\end{array}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ccc}C1(x,k)&amp;\\equiv&amp;\\vdash x(k)\\leq x(k)\\\\&#10;C2(x,k)&amp;\\equiv&amp;\\vdash x(k)\\leq g(x(k))\\\\&#10;C3(x,i,k)&amp;\\equiv&amp;i=f(x(k)),i=f(g(x(k)))\\vdash\\\\&#10;C4(x,y,i,k)&amp;\\equiv&amp;y(k)\\leq x(k),f(y(k))&lt;i+1\\vdash\\\\&#10;&amp;&amp;f(x(k))&lt;i,i=f(x(k))\\\\&#10;C4^{\\prime}(x,y,i,k)&amp;\\equiv&amp;y(k)\\leq x(k+1),f(y(k))&lt;i+1\\vdash\\\\&#10;&amp;&amp;f(x(k+1))&lt;i,i=f(x(k+1))\\\\&#10;C5(x,k)&amp;\\equiv&amp;f(x(k))&lt;0\\vdash\\\\&#10;C6(x,k)&amp;\\equiv&amp;f(g(x(k)))&lt;0\\vdash\\\\&#10;C7(x,k)&amp;\\equiv&amp;0\\leq x(k)\\vdash f(x(k))&lt;n,f(x(k))=n\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>1</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mi/><mo>\u22a2</mo><mrow><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>2</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mi/><mo>\u22a2</mo><mrow><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>3</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mrow><mi>i</mi><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>\u22a2</mo><mi/></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>4</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mrow><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></mrow><mo>\u22a2</mo><mi/></mrow></mtd></mtr><mtr><mtd/><mtd/><mtd columnalign=\"center\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mi>i</mi></mrow><mo>,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><msup><mn>4</mn><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>i</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mrow><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></mrow></mrow><mo>\u22a2</mo><mi/></mrow></mtd></mtr><mtr><mtd/><mtd/><mtd columnalign=\"center\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mi>i</mi></mrow><mo>,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>5</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>\u22a2</mo><mi/></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>6</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>\u22a2</mo><mi/></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>C</mi><mo>\u2062</mo><mn>7</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mo>\u2261</mo></mtd><mtd columnalign=\"center\"><mrow><mrow><mn>0</mn><mo>\u2264</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u22a2</mo><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mi>n</mi></mrow><mo>,</mo><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>n</mi></mrow></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "  \nwhere $h(\\cdot )$ is defined as  $h(0) \\to 0,\\ h(s(k)) \\to g(h(k))$. The components are as follows:\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe have introduced clause names, schematic variables, and an additional  $\\omega$-variable which will be used in the refutation of Sec.~\\ref{sec:refuteset}.\n\n\\section{Refutation of the Characteristic Clause set of the ECA-schema} \\label{sec:refuteset}\n\nWe discovered the resolution refutation schema which we present here with the help of the SPASS theorem prover \\cite{SpassProver} in default mode, and with the flags for standard resolution and ordered resolution set. Various other modes of the theorem prover were tested, however, given that we needed to translate the resulting proof into the simple resolution language of \\cite{CERESS2}, the chosen modes provided the easiest proofs for translation. After running the theorem prover on five instances of the clause set, we where able to extract an invariant for the  resolution refutation schema. Essentially, the refutation differentiates between the symbols occurring in the codomain of $f$ and not occurring. This is denoted using the function $g$. The excerpt from the SPASS output in Table \\ref{tabone} indicates the invariant. However, even though SPASS was able to provide a refutation for each instance, we could not use these refutations directly in the resolution refutation schema being that the SPASS output ignores the structural importance of the $\\omega$ sort. Unlike the ordering problem of the NiA-schema \\cite{MeCadePaper2015,MyThesis}, this choice made by SPASS was not necessary to the refutation of the ECA-schema and we were able find a suitable refutation. \n\\begin{table}\n\\begin{tabular}{l|l}\n310[0:MRR:309.0,306.1] &  $\\vdash$ \\ $f(\\alpha) < 3$\\ \\\\ \n311[0:MRR:10.1,310.0] & $\\alpha \\leq \\beta$ $\\vdash$ \\ $2 = f(\\beta)$ \\ \\ $f(\\beta) < 2$\\ \\\\\n312[0:Res:2.0,311.0] &  $\\vdash$ \\ $2 = f(\\alpha)$ \\ \\ $f(\\alpha) < 2$\\\\\n314[0:Res:312.0,6.1] & \\ $2 = f(\\alpha)$ \\ $\\vdash$ \\ $f(g(\\beta)) < 2$\\ \\\\\n315[0:Res:314.1,11.1] & \\ $2 = f(\\alpha)$ \\ \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $1 = f(\\beta)$ \\ \\ $f(\\beta) < 1$\\ \\\\\n316[0:Res:312.0,315.0] & \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(\\beta)$ \\ \\ $f(\\beta) < 1$\\ \\\\\n317[0:Res:2.0,316.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(g(\\alpha))$ \\ \\ $f(g(\\alpha)) < 1$\\ \\\\\n318[0:Res:3.0,316.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $1 = f(g(g(\\alpha)))$ \\ \\ $f(g(g(\\alpha))) < 1$\\ \\\\\n321[0:Res:318.1,7.1] & \\ $1 = f(g(\\alpha))$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $f(g(g(\\alpha))) < 1$\\ \\\\\n322[0:Res:321.2,14.1] & \\ $1 = f(g(\\alpha))$ \\ \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n325[0:Res:317.1,322.0] & \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n327[0:Obv:325.1] & \\ $g(g(\\alpha)) \\leq \\beta$ \\ $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n328[0:Res:2.0,327.0] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(\\alpha)))$ \\\\\n329[0:Res:3.0,327.0] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(g(\\alpha))))$ \\\\\n335[0:Res:329.2,8.1] & \\ $0 = f(g(g(\\alpha)))$ \\ $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\\\\n336[0:MRR:335.0,328.2] &  $\\vdash$ \\ $f(g(\\alpha)) < 1$\\  \\ $f(\\alpha) < 2$\\\\\n337[0:Res:336.0,14.1] & \\ $g(\\alpha) \\leq \\beta$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(\\beta)$ \\\\\n338[0:Res:2.0,337.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(\\alpha))$ \\\\\n339[0:Res:3.0,337.0] &  $\\vdash$ \\ $f(\\alpha) < 2$\\ \\ $0 = f(g(g(\\alpha)))$ \\\\\n344[0:Res:339.1,8.1] & \\ $0 = f(g(\\alpha))$ \\ $\\vdash$ \\ $f(\\alpha) < 2$\\\\\n345[0:MRR:344.0,338.1] &  $\\vdash$ \\ $f(\\alpha) < 2$\\\\\n\\end{tabular}\n\\caption{Excerpt from SPASS output for the clause set instance $C(5)$ indicating the invariant.}\\label{tabone}\n\\end{table}\n\nOur resolution refutation schema of the ECA-schema is $\\mathcal{R} = \\left(\\varrho_{1},\\cdots ,\\varrho_{10} \\right)$, where we use one clause variable $Y$, two schematic variables, and one $\\omega$-variable. Our substitution schema is as follows: \n\n", "index": 23, "text": "$$\\vartheta =\\left\\lbrace x(k)\\leftarrow \\lambda k.(h(k)) ,  y(k)\\leftarrow \\lambda k.(h(k)) \\right\\rbrace  $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\vartheta=\\left\\{x(k)\\leftarrow\\lambda k.(h(k)),y(k)\\leftarrow\\lambda k.(h(k))\\right\\}\" display=\"block\"><mrow><mi>\u03d1</mi><mo>=</mo><mrow><mo>{</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mi>\u03bb</mi><mi>k</mi><mo>.</mo><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2190</mo><mi>\u03bb</mi><mi>k</mi><mo>.</mo><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 36291, "prevtext": "  \nwhere $h(\\cdot )$ is defined as  $h(0) \\to 0,\\ h(s(k)) \\to g(h(k))$. The components are as follows:\n\n\n", "index": 25, "text": "\\begin{equation*}\n\\begin{array}{ll} \\varrho_{1}(n+1,k,x,y,Y) \\Rightarrow & r(\\varrho_{2}(n+1,k,x,y,Y); \\varrho_{5}(n,k,x,y,Y\\circ \\\\ & ( f(x(k)) < n + 1\\vdash) );f(x(k)) < n + 1)\\\\\\\\\n\n\\varrho_{1}(0,k,x,y,Y) \\Rightarrow & r(\\varrho_{2}(0,k,x,y,Y);C5(x,k) ;f(x(k)) < 0)\\\\\\\\\n\n\\varrho_{2}(n+1,k,x,y,Y) \\Rightarrow  & r(\\varrho_{3}(n+1,k,x,y,Y);r(C1(x,k);\\\\ \n& C7(x,k);x(k)\\leq x(k));n+1 = f(x(k)))\\\\\\\\\n\n\\varrho_{2}(0,k,x,y,Y) \\Rightarrow &  r(\\varrho_{3}(0,k,x,y,Y);r(C1(x,k);C7(x,k);x(k)\\leq x(k));\\\\ & n+1 = f(x(k)))\\\\\\\\\n\\end{array}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}\\varrho_{1}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{2}(n+1,k,x,y%&#10;,Y);\\varrho_{5}(n,k,x,y,Y\\circ\\\\&#10;&amp;(f(x(k))&lt;n+1\\vdash));f(x(k))&lt;n+1)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{1}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{2}(0,k,x,y,Y);C5(x,k);f(x(k)%&#10;)&lt;0)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{2}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{3}(n+1,k,x,y,Y);r(C1(x,k);%&#10;\\\\&#10;&amp;C7(x,k);x(k)\\leq x(k));n+1=f(x(k)))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{2}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{3}(0,k,x,y,Y);r(C1(x,k);C7(x%&#10;,k);x(k)\\leq x(k));\\\\&#10;&amp;n+1=f(x(k)))\\\\&#10;\\\\&#10;\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><msub><mi>\u03f1</mi><mn>5</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo>\u2218</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>\u22a2</mo><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>5</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>3</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mrow><mi>C</mi><mn>7</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>3</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>7</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 36838, "prevtext": "\n\n", "index": 27, "text": "\\begin{equation*}\n\\begin{array}{ll}\n\\varrho_{3}(n+1,k,x,y,Y) \\Rightarrow & r(\\varrho_{4}(n+1,k,x,y,Y);C3(x,n+1,k); \\\\ & n+1=f(g(x(k))))\\\\\\\\\n\n\\varrho_{3}(0,k,x,y,Y) \\Rightarrow & r(\\varrho_{4}(0,k,x,y,Y);C3(x,0,k);0=f(g(x(k))))\\\\\\\\\n\n\\varrho_{4}(n+1,k,x,y,Y) \\Rightarrow & r(\\varrho_{5}(n,k+1,x,y,Y\\circ f(x(k+1))<n+1\\vdash );\\\\ & r(C2(x,k);C7(x,k+1);f(x(k+1))<n+1) \\\\\\\\\n\n\\varrho_{4}(0,k,x,y,Y) \\Rightarrow &  r(C6(x,k);r(C2(x,k);C7(x,k+1);f(g(x(k)))<0)\n\\end{array}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}\\varrho_{3}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{4}(n+1,k,x,y%&#10;,Y);C3(x,n+1,k);\\\\&#10;&amp;n+1=f(g(x(k))))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{3}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{4}(0,k,x,y,Y);C3(x,0,k);0=f(%&#10;g(x(k))))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{4}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{5}(n,k+1,x,y,Y\\circ f(x(k+%&#10;1))&lt;n+1\\vdash);\\\\&#10;&amp;r(C2(x,k);C7(x,k+1);f(x(k+1))&lt;n+1)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{4}(0,k,x,y,Y)\\Rightarrow&amp;r(C6(x,k);r(C2(x,k);C7(x,k+1);f(g(x(k))%&#10;)&lt;0)\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>4</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>4</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>4</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>5</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo>\u2218</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>\u22a2</mo><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>7</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>4</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>6</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>7</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 37318, "prevtext": "\n\n", "index": 29, "text": "\\begin{equation*}\n\\begin{array}{ll}\n\\varrho_{5}(n+1,k,x,y,Y) \\Rightarrow &  r(\\varrho_{6}(n+1,k,x,y,Y);\\varrho_{5}(n,k,x,y,Y\\circ \\\\ &  ( f(x(k)) < n+1 \\vdash)) ;f(x(k)) < n + 1)\\\\\\\\\n\n\\varrho_{5}(0,k,x,y,Y) \\Rightarrow & r(\\varrho_{6}(0,k,x,y,Y);C5(x,k) ;f(x(k)) < 0)\\\\\\\\\n\n\\varrho_{6}(n+1,k,x,y,Y) \\Rightarrow &  r(\\varrho_{7}(n+1,k,x,y,Y);\\varrho_{8}(n+1,k,x,y,Y)\\\\ & ;n+1 = f(x(k)))\\\\\\\\\n\\varrho_{6}(0,k,x,y,Y) \\Rightarrow & r(\\varrho_{7}(0,k,x,y,Y);\\varrho_{8}(0,k,x,y,Y); 0 = f(x(k))\\\\\\\\\n\\end{array}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}\\varrho_{5}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{6}(n+1,k,x,y%&#10;,Y);\\varrho_{5}(n,k,x,y,Y\\circ\\\\&#10;&amp;(f(x(k))&lt;n+1\\vdash));f(x(k))&lt;n+1)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{5}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{6}(0,k,x,y,Y);C5(x,k);f(x(k)%&#10;)&lt;0)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{6}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{7}(n+1,k,x,y,Y);\\varrho_{8%&#10;}(n+1,k,x,y,Y)\\\\&#10;&amp;;n+1=f(x(k)))\\\\&#10;\\\\&#10;\\varrho_{6}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{7}(0,k,x,y,Y);\\varrho_{8}(0,k,x,y%&#10;,Y);0=f(x(k))\\\\&#10;\\\\&#10;\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>5</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>6</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><msub><mi>\u03f1</mi><mn>5</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo>\u2218</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>\u22a2</mo><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>5</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>6</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>5</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>6</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>7</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><msub><mi>\u03f1</mi><mn>8</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mo>;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>6</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>7</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><msub><mi>\u03f1</mi><mn>8</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 37837, "prevtext": "\n\n", "index": 31, "text": "\\begin{equation*}\n\\begin{array}{ll}\n\\varrho_{7}(n+1,k,x,y,Y) \\Rightarrow & r(\\varrho_{9}(n+1,k,x,y,Y);C3(x,n+1,k);\\\\ &n+1=f(g(x(k))))\\\\\\\\\n\n\\varrho_{7}(0,k,x,y,Y) \\Rightarrow & r(\\varrho_{9}(0,k,x,y,Y);C3(x,0,k);0=f(g(x(k))))\\\\\\\\\n\n\\varrho_{8}(n+1,k,x,Y) \\Rightarrow & r(C1(x,k);Y\\circ C4(x,y,n,k);x(k)\\leq x(k))\\\\\\\\\n\n\\varrho_{8}(0,k,x,y,Y)\\Rightarrow & r(C1(x,k);Y\\circ C4(x,y,0,k);x(k)\\leq x(k))\\\\\\\\\n\\end{array}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}\\varrho_{7}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{9}(n+1,k,x,y%&#10;,Y);C3(x,n+1,k);\\\\&#10;&amp;n+1=f(g(x(k))))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{7}(0,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{9}(0,k,x,y,Y);C3(x,0,k);0=f(%&#10;g(x(k))))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{8}(n+1,k,x,Y)\\Rightarrow&amp;r(C1(x,k);Y\\circ C4(x,y,n,k);x(k)\\leq x%&#10;(k))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{8}(0,k,x,y,Y)\\Rightarrow&amp;r(C1(x,k);Y\\circ C4(x,y,0,k);x(k)\\leq x%&#10;(k))\\\\&#10;\\\\&#10;\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>7</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>9</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>7</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>9</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>C</mi><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mn>0</mn><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>8</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>Y</mi><mo>\u2218</mo><mi>C</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>8</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>Y</mi><mo>\u2218</mo><mi>C</mi><mn>4</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n\\begin{figure}\n\\begin{center}\n$\n\\psmatrix[colsep=1.45cm,rowsep=.45cm,mnode=circle]\n &\\varrho_{4}&&\\varrho_{6}&&\\varrho_{8}\\\\\n\\varrho_{3}\\\\\n &&\\varrho_{5}&&\\varrho_{7}\\\\\n\\varrho_{2}\\\\\n &\\varrho_{1}&&\\varrho_{9}&&\\varrho_{10}\n\\ncline{->}{1,2}{3,3}\n\\lput{:U}{\\rput[r]{0}(.8 ,.2){(n+1,k+1)}}\n\\ncline{->}{5,2}{3,3}\n\\lput{:U}{\\rput[r]{0}(-.1,.2){(n,k)}}\n\\ncline{->}{5,2}{4,1}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{4,1}{2,1}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{2,1}{1,2}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{3,3}{1,4}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{1,4}{3,5}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{3,5}{5,4}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{5,4}{3,3}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m,l+1)}}\n\\ncline{->}{5,4}{5,6}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{1,4}{1,6}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\nccircle[nodesep=0pt,angleA=135]{->}{3,3}{.6cm}\n\\lput{:U}{\\rput[r]{110}(-.9,.7){(m,l)}}\n\\endpsmatrix\n$\n\\end{center}\n\\caption{A graph representation of the resolution refutation. The variable $n$ is the free parameter, $k$ is the $\\omega$-variable used in the refutation and the variables $m$ and $l$ are dependent on the position in the computation.}\n\\label{fig:spaceship}\n\\end{figure}\n\n\n\n\nOne can find a graphical representation of the refutation in Fig.~\\ref{fig:spaceship}. The clause substitution is $\\theta = \\lbrace Y\\leftarrow\\ \\vdash \\rbrace$, the $\\omega$-variable substitution is $\\nu = \\lbrace k\\leftarrow \\overline{\\mu} \\rbrace$ for any $\\overline{\\mu}\\in \\mathbb{N}$.\nThe normal form of the refutation for $\\gamma\\in \\mathbb{N}$ is  \n\n\n", "itemtype": "equation", "pos": 38265, "prevtext": "\n\n", "index": 33, "text": "\\begin{equation*}\n\\begin{array}{ll}\n\\varrho_{9}(n+1,k,x,y,Y) \\Rightarrow & r(\\varrho_{5}(n,k+1,x,y,Y'\\circ f(g(x(k)))<n+1\\vdash );\\\\ & \\varrho_{10}(n+1,x,y,Y);f(g(x(k)))<n+1)\\\\\\\\\n\n\\varrho_{9}(0,k,x,y,Y) \\Rightarrow &  r( C6(x,k) ;\\varrho_{10}(0,k,x,y,Y) ;f(g(x(k)))<0)\\\\\\\\\n\n\\varrho_{10}(n+1,k,x,y,Y) \\Rightarrow & r(C2(x,k);Y\\circ C4'(x,y,n,k);x(k)\\leq g(x(k)))\\\\\\\\\n\n\\varrho_{10}(0,k,x,y,Y) \\Rightarrow & r(C2(x,k);Y\\circ C4'(x,y,0,k);x(k)\\leq g(x(k)))\\end{array}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}\\varrho_{9}(n+1,k,x,y,Y)\\Rightarrow&amp;r(\\varrho_{5}(n,k+1,x,y%&#10;,Y^{\\prime}\\circ f(g(x(k)))&lt;n+1\\vdash);\\\\&#10;&amp;\\varrho_{10}(n+1,x,y,Y);f(g(x(k)))&lt;n+1)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{9}(0,k,x,y,Y)\\Rightarrow&amp;r(C6(x,k);\\varrho_{10}(0,k,x,y,Y);f(g(x%&#10;(k)))&lt;0)\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{10}(n+1,k,x,y,Y)\\Rightarrow&amp;r(C2(x,k);Y\\circ C4^{\\prime}(x,y,n,k%&#10;);x(k)\\leq g(x(k)))\\\\&#10;\\\\&#10;\\par&#10;\\varrho_{10}(0,k,x,y,Y)\\Rightarrow&amp;r(C2(x,k);Y\\circ C4^{\\prime}(x,y,0,k);%&#10;x(k)\\leq g(x(k)))\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>9</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03f1</mi><mn>5</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><msup><mi>Y</mi><mo>\u2032</mo></msup><mo>\u2218</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>\u22a2</mo><mo stretchy=\"false\">)</mo></mrow><mo>;</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><msub><mi>\u03f1</mi><mn>10</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>9</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>6</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><msub><mi>\u03f1</mi><mn>10</mn></msub><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>10</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>Y</mi><mo>\u2218</mo><mi>C</mi><msup><mn>4</mn><mo>\u2032</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03f1</mi><mn>10</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mi/></mrow></mtd><mtd columnalign=\"left\"><mrow><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>C</mi><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>Y</mi><mo>\u2218</mo><mi>C</mi><msup><mn>4</mn><mo>\u2032</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mn>0</mn><mo>,</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>;</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": " \n\nwhere $i_s(0) =0,\\ i_s(s(k)) = s(i_s(k))$. Substitution of the empty clause into $Y$ suffices for every instance, i.e.  $\\lbrace Y\\leftarrow\\ \\vdash \\rbrace$. This property makes extraction of the Herbrand system much easier.\n\n\n\\section{The Herbrand System for the ECA-schema} \\label{sec:Herbrand}\n\nNow we move on to the construction of a  Herbrand system for the sequent\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\n\\begin{figure}\n\\begin{center}\n$\n\\psmatrix[colsep=1.45cm,rowsep=.45cm,mnode=circle]\n &\\varrho_{4}&&\\varrho_{6}&&\\varrho_{8}\\\\\n\\varrho_{3}\\\\\n &&\\varrho_{5}&&\\varrho_{7}\\\\\n\\varrho_{2}\\\\\n &\\varrho_{1}&&\\varrho_{9}&&\\varrho_{10}\n\\ncline{->}{1,2}{3,3}\n\\lput{:U}{\\rput[r]{0}(.8 ,.2){(n+1,k+1)}}\n\\ncline{->}{5,2}{3,3}\n\\lput{:U}{\\rput[r]{0}(-.1,.2){(n,k)}}\n\\ncline{->}{5,2}{4,1}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{4,1}{2,1}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{2,1}{1,2}\n\\lput{:U}{\\rput[r]{0}(.6,.3){(n+1,k)}}\n\\ncline{->}{3,3}{1,4}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{1,4}{3,5}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{3,5}{5,4}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{5,4}{3,3}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m,l+1)}}\n\\ncline{->}{5,4}{5,6}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\ncline{->}{1,4}{1,6}\n\\lput{:U}{\\rput[r]{0}(.6,.2){(m+1,l)}}\n\\nccircle[nodesep=0pt,angleA=135]{->}{3,3}{.6cm}\n\\lput{:U}{\\rput[r]{110}(-.9,.7){(m,l)}}\n\\endpsmatrix\n$\n\\end{center}\n\\caption{A graph representation of the resolution refutation. The variable $n$ is the free parameter, $k$ is the $\\omega$-variable used in the refutation and the variables $m$ and $l$ are dependent on the position in the computation.}\n\\label{fig:spaceship}\n\\end{figure}\n\n\n\n\nOne can find a graphical representation of the refutation in Fig.~\\ref{fig:spaceship}. The clause substitution is $\\theta = \\lbrace Y\\leftarrow\\ \\vdash \\rbrace$, the $\\omega$-variable substitution is $\\nu = \\lbrace k\\leftarrow \\overline{\\mu} \\rbrace$ for any $\\overline{\\mu}\\in \\mathbb{N}$.\nThe normal form of the refutation for $\\gamma\\in \\mathbb{N}$ is  \n\n\n", "index": 35, "text": "$$\\varrho_1 (n,k,x,y, Y)\\theta\\nu\\vartheta\\left[n\\leftarrow \\gamma \\right] = \\varrho_1 (\\gamma,\\overline{\\mu},\\lambda_k.(i_s(k)),\\lambda_k.(h(k)), \\vdash ),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\varrho_{1}(n,k,x,y,Y)\\theta\\nu\\vartheta\\left[n\\leftarrow\\gamma\\right]=\\varrho%&#10;_{1}(\\gamma,\\overline{\\mu},\\lambda_{k}.(i_{s}(k)),\\lambda_{k}.(h(k)),\\vdash),\" display=\"block\"><mrow><msub><mi>\u03f1</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><mi>\u03b8</mi><mi>\u03bd</mi><mi>\u03d1</mi><mrow><mo>[</mo><mi>n</mi><mo>\u2190</mo><mi>\u03b3</mi><mo>]</mo></mrow><mo>=</mo><msub><mi>\u03f1</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>\u03b3</mi><mo>,</mo><mover accent=\"true\"><mi>\u03bc</mi><mo>\u00af</mo></mover><mo>,</mo><msub><mi>\u03bb</mi><mi>k</mi></msub><mo>.</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>i</mi><mi>s</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><msub><mi>\u03bb</mi><mi>k</mi></msub><mo>.</mo><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mo>\u22a2</mo><mo stretchy=\"false\">)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\nbased on our proof analysis. The sequent $S(n)$ is an sps-schema of the form $\\varphi_1(n),\\varphi_2(n)\\vdash \\psi_1(n)$. Note that we dropped one of the quantifiers from the antecedent being that it is obvious from the proof itself what the substitution would be, see Appendix ~\\ref{sec:FormECA}. Each formula in $S(n)$ is derived along with a set of clauses in the proof schemata $\\Psi =\\left\\langle (\\psi(n+1),\\psi(0)), (\\varphi(n+1),\\varphi(0)) \\right\\rangle$. By observing the construction of the \nformulae in Appendix ~\\ref{sec:FormECA}.\\ref{Fig:proofPSIone} and  Appendix ~\\ref{sec:FormECA}.\\ref{Fig:proofPHIone},  one can see that $\\varphi_1(n)$, $\\varphi_2(n)$, and $C7(x,k)$ as constructed together, while $\\psi_1(n)$, $C2(x,k)$, and $C3(x,i,k)$ are constructed together. We will only consider the case when  the $\\omega$-variable substitution is $\\nu = \\lbrace k \\rightarrow 0\\rbrace$ to simplify the derivation. \n\nNotice that $C7(x,k)$ is used at the top of the refutation and only twice. Once as $C7(x,0)$ and once as $C7(x,1)$. On the other hand, $C2(x,k)$ is used in $\\varrho_{10}$ and $C3(x,i,k)$ is use in $\\varrho_{7}$. For every pair $(i,l)$ in the ranges $0\\leq i\\leq n+1$,$0\\leq l< n+1$, the clauses $C2(x,l)$ and  $C3(x,i,l)$, and $C2(x,l+1)$ and  $C3(x,i,l+1)$ are used in the refutation. This implies, by the substitution schema that $\\psi_1(n)$ will have its quantifier replaced by the term derived from $h(i)$, for all  $i\\in \\left[ 0,n\\right] $, in the Herbrand system.  This information can be used to construct the required rewrite system: \n\n\n", "itemtype": "equation", "pos": 40926, "prevtext": " \n\nwhere $i_s(0) =0,\\ i_s(s(k)) = s(i_s(k))$. Substitution of the empty clause into $Y$ suffices for every instance, i.e.  $\\lbrace Y\\leftarrow\\ \\vdash \\rbrace$. This property makes extraction of the Herbrand system much easier.\n\n\n\\section{The Herbrand System for the ECA-schema} \\label{sec:Herbrand}\n\nNow we move on to the construction of a  Herbrand system for the sequent\n\n\n", "index": 37, "text": "$$\\begin{array}{l}S(n) \\equiv \\left( \\forall x \\bigvee_{i=0}^{n} i = f(x),   \\forall y \\left( 0\\leq y \\rightarrow f(y) \\leq f(0)\\right)  \\right)  \\vdash \\\\  \\exists x \\left( x \\leq g(x)  \\rightarrow f(x) = f(g(x)) \\right) \\end{array}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{l}S(n)\\equiv\\left(\\forall x\\bigvee_{i=0}^{n}i=f(x),\\forall y%&#10;\\left(0\\leq y\\rightarrow f(y)\\leq f(0)\\right)\\right)\\vdash\\\\&#10;\\exists x\\left(x\\leq g(x)\\rightarrow f(x)=f(g(x))\\right)\\end{array}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>S</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mrow><mo>(</mo><mo>\u2200</mo><mi>x</mi><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mo>\u2200</mo><mi>y</mi><mrow><mo>(</mo><mn>0</mn><mo>\u2264</mo><mi>y</mi><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>)</mo></mrow><mo>\u22a2</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>\u2203</mo><mi>x</mi><mrow><mo>(</mo><mi>x</mi><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\nTo finish our construction of the Herbrand system using Def. \\ref{def:herbrand} We need to put all of the parts together as a single sequent as follows\n\n\n", "itemtype": "equation", "pos": 42734, "prevtext": "\n\nbased on our proof analysis. The sequent $S(n)$ is an sps-schema of the form $\\varphi_1(n),\\varphi_2(n)\\vdash \\psi_1(n)$. Note that we dropped one of the quantifiers from the antecedent being that it is obvious from the proof itself what the substitution would be, see Appendix ~\\ref{sec:FormECA}. Each formula in $S(n)$ is derived along with a set of clauses in the proof schemata $\\Psi =\\left\\langle (\\psi(n+1),\\psi(0)), (\\varphi(n+1),\\varphi(0)) \\right\\rangle$. By observing the construction of the \nformulae in Appendix ~\\ref{sec:FormECA}.\\ref{Fig:proofPSIone} and  Appendix ~\\ref{sec:FormECA}.\\ref{Fig:proofPHIone},  one can see that $\\varphi_1(n)$, $\\varphi_2(n)$, and $C7(x,k)$ as constructed together, while $\\psi_1(n)$, $C2(x,k)$, and $C3(x,i,k)$ are constructed together. We will only consider the case when  the $\\omega$-variable substitution is $\\nu = \\lbrace k \\rightarrow 0\\rbrace$ to simplify the derivation. \n\nNotice that $C7(x,k)$ is used at the top of the refutation and only twice. Once as $C7(x,0)$ and once as $C7(x,1)$. On the other hand, $C2(x,k)$ is used in $\\varrho_{10}$ and $C3(x,i,k)$ is use in $\\varrho_{7}$. For every pair $(i,l)$ in the ranges $0\\leq i\\leq n+1$,$0\\leq l< n+1$, the clauses $C2(x,l)$ and  $C3(x,i,l)$, and $C2(x,l+1)$ and  $C3(x,i,l+1)$ are used in the refutation. This implies, by the substitution schema that $\\psi_1(n)$ will have its quantifier replaced by the term derived from $h(i)$, for all  $i\\in \\left[ 0,n\\right] $, in the Herbrand system.  This information can be used to construct the required rewrite system: \n\n\n", "index": 39, "text": "$$ \\mathcal{R} = \\left\\lbrace  \\begin{array}{l} w_{1}^{\\varphi}(k+1) \\Rightarrow [[0];[g(0)]] \\\\ w_{1}^{\\varphi}(0) \\Rightarrow [[0];[g(0)]]\\\\\\\\\n w_{2}^{\\varphi}(k+1) \\Rightarrow [[0];[g(0)]] \\\\ w_{2}^{\\varphi}(0) \\Rightarrow [[0];[g(0)]]  \\\\\\\\\n w_{1}^{\\psi}(k+1) \\Rightarrow [[h(k+1)];w_{1}^{\\psi}(k)] \\\\ w_{1}^{\\psi}(0) \\Rightarrow [0]\\end{array}\\right. $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\mathcal{R}=\\left\\{\\begin{array}[]{l}w_{1}^{\\varphi}(k+1)\\Rightarrow[[0];[g(0)%&#10;]]\\\\&#10;w_{1}^{\\varphi}(0)\\Rightarrow[[0];[g(0)]]\\\\&#10;\\\\&#10;w_{2}^{\\varphi}(k+1)\\Rightarrow[[0];[g(0)]]\\\\&#10;w_{2}^{\\varphi}(0)\\Rightarrow[[0];[g(0)]]\\\\&#10;\\\\&#10;w_{1}^{\\psi}(k+1)\\Rightarrow[[h(k+1)];w_{1}^{\\psi}(k)]\\\\&#10;w_{1}^{\\psi}(0)\\Rightarrow[0]\\end{array}\\right.\" display=\"block\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mo>=</mo><mrow><mo>{</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>1</mn><mi>\u03c6</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><mo>;</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>1</mn><mi>\u03c6</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><mo>;</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>2</mn><mi>\u03c6</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><mo>;</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>2</mn><mi>\u03c6</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><mo>;</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>1</mn><mi>\u03c8</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mo>;</mo><mrow><msubsup><mi>w</mi><mn>1</mn><mi>\u03c8</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><msubsup><mi>w</mi><mn>1</mn><mi>\u03c8</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u21d2</mo><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 43246, "prevtext": "\nTo finish our construction of the Herbrand system using Def. \\ref{def:herbrand} We need to put all of the parts together as a single sequent as follows\n\n\n", "index": 41, "text": "$$ \\bigvee_{i=0}^{n} i = f(0),\\bigvee_{i=0}^{n} i = f(g(0)), \\left( 0\\leq 0 \\rightarrow f(0) \\leq f(0)\\right), $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\bigvee_{i=0}^{n}i=f(0),\\bigvee_{i=0}^{n}i=f(g(0)),\\left(0\\leq 0\\rightarrow f(%&#10;0)\\leq f(0)\\right),\" display=\"block\"><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo>(</mo><mn>0</mn><mo>\u2264</mo><mn>0</mn><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\nAt first this does not seem to be \\textbf{LKE} provable, However, one has to remember that for the construction of our cut formula we made an assumption that $f$ is monotonically decreasing and has a codomain consisting of elements in the interval $\\left[0,n \\right]$. These assumptions are represented by the following axiom found in  Appendix ~\\ref{sec:FormECA}:\n\n", "itemtype": "equation", "pos": 43360, "prevtext": "\n\n", "index": 43, "text": "$$  \\left( 0\\leq g(0) \\rightarrow f(g(0)) \\leq f(0)\\right) \\vdash  \\bigvee_{i=0}^{n} \\left( h(i) \\leq g(h(i))  \\rightarrow f(h(i)) = f(g(h(i))) \\right) . $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\left(0\\leq g(0)\\rightarrow f(g(0))\\leq f(0)\\right)\\vdash\\bigvee_{i=0}^{n}%&#10;\\left(h(i)\\leq g(h(i))\\rightarrow f(h(i))=f(g(h(i)))\\right).\" display=\"block\"><mrow><mrow><mo>(</mo><mn>0</mn><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>\u22a2</mo><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mrow><mo>(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\n\nIt is not used in the construction of the end sequent but is used for the construction of the cut formulae. We just need to find a set of axioms which correspond to these semantic assumptions, the following set suffices:\n\n\\begin{center}\n\\begin{tabular}{ll}\n\\multicolumn{2}{l}{$\\begin{array}{c}A1(i):\\  \\bigvee_{i=0}^{j-1} i= f(\\alpha), j =f(g(\\alpha)), f(g(\\alpha)) < f(\\alpha)  \\vdash \\end{array}$}\\\\\n\\multicolumn{2}{l}{$\\begin{array}{cc}A2(i):\\ i= f(\\alpha), \\bigvee_{j=0}^{i-1}  j=f(g(\\alpha)),   \\alpha\\leq g(\\alpha)  \\vdash  \\end{array}$}\\\\\n\\multicolumn{2}{l}{$\\begin{array}{c}A3(i):\\ i= f(\\alpha), i =f(g(\\alpha)) \\vdash f(\\alpha) = f(g(\\alpha))  \\end{array}$} \\\\ \n\\multicolumn{2}{l}{$\\begin{array}{c}A4(i):f(g(\\alpha)) = f(\\alpha)  \\vdash f(\\alpha) = f(g(\\alpha))  \\end{array}$}\\\\\n$\\begin{array}{c}A5(i):\\  \\vdash \\alpha \\leq \\alpha  \\end{array}$ & \\\\ $\\begin{array}{c}A6(i): f(\\alpha) < f(\\alpha)   \\vdash \\end{array}$\n\\end{tabular}\n\\end{center}\n\n\nThe first pair of axioms enforce the required properties of $f$ and $g$, the next pair provide the needed properties of equality, and the last pair provide the needed properties of linear orderings. Interesting enough, using these axioms, we are able to prove the derived Herbrand sequent using only a single nesting of $g$, thus making the majority of the consequent redundant.  This is a result of our usage of the clause $C7(x,k)$. Thus, it turns out that a minimal Herbrand sequent is the following: \n\n", "itemtype": "equation", "pos": 43883, "prevtext": "\n\nAt first this does not seem to be \\textbf{LKE} provable, However, one has to remember that for the construction of our cut formula we made an assumption that $f$ is monotonically decreasing and has a codomain consisting of elements in the interval $\\left[0,n \\right]$. These assumptions are represented by the following axiom found in  Appendix ~\\ref{sec:FormECA}:\n\n", "index": 45, "text": "$$AX\\equiv  f(\\alpha) < n+1 ,  \\alpha\\leq \\beta  \\vdash    n= f(\\beta)  , f(\\beta) < n $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"AX\\equiv f(\\alpha)&lt;n+1,\\alpha\\leq\\beta\\vdash n=f(\\beta),f(\\beta)&lt;n\" display=\"block\"><mrow><mi>A</mi><mi>X</mi><mo>\u2261</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>\u03b1</mi><mo>\u2264</mo><mi>\u03b2</mi><mo>\u22a2</mo><mi>n</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b2</mi><mo stretchy=\"false\">)</mo></mrow><mo>&lt;</mo><mi>n</mi></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": " \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nIt is not used in the construction of the end sequent but is used for the construction of the cut formulae. We just need to find a set of axioms which correspond to these semantic assumptions, the following set suffices:\n\n\\begin{center}\n\\begin{tabular}{ll}\n\\multicolumn{2}{l}{$\\begin{array}{c}A1(i):\\  \\bigvee_{i=0}^{j-1} i= f(\\alpha), j =f(g(\\alpha)), f(g(\\alpha)) < f(\\alpha)  \\vdash \\end{array}$}\\\\\n\\multicolumn{2}{l}{$\\begin{array}{cc}A2(i):\\ i= f(\\alpha), \\bigvee_{j=0}^{i-1}  j=f(g(\\alpha)),   \\alpha\\leq g(\\alpha)  \\vdash  \\end{array}$}\\\\\n\\multicolumn{2}{l}{$\\begin{array}{c}A3(i):\\ i= f(\\alpha), i =f(g(\\alpha)) \\vdash f(\\alpha) = f(g(\\alpha))  \\end{array}$} \\\\ \n\\multicolumn{2}{l}{$\\begin{array}{c}A4(i):f(g(\\alpha)) = f(\\alpha)  \\vdash f(\\alpha) = f(g(\\alpha))  \\end{array}$}\\\\\n$\\begin{array}{c}A5(i):\\  \\vdash \\alpha \\leq \\alpha  \\end{array}$ & \\\\ $\\begin{array}{c}A6(i): f(\\alpha) < f(\\alpha)   \\vdash \\end{array}$\n\\end{tabular}\n\\end{center}\n\n\nThe first pair of axioms enforce the required properties of $f$ and $g$, the next pair provide the needed properties of equality, and the last pair provide the needed properties of linear orderings. Interesting enough, using these axioms, we are able to prove the derived Herbrand sequent using only a single nesting of $g$, thus making the majority of the consequent redundant.  This is a result of our usage of the clause $C7(x,k)$. Thus, it turns out that a minimal Herbrand sequent is the following: \n\n", "index": 47, "text": "$$ \\bigvee_{i=0}^{n} i = f(0),\\bigvee_{i=0}^{n} i = f(g(0)),  \\left( 0\\leq g(0) \\rightarrow f(g(0)) \\leq f(0)\\right),  $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\bigvee_{i=0}^{n}i=f(0),\\bigvee_{i=0}^{n}i=f(g(0)),\\left(0\\leq g(0)\\rightarrow&#10;f%&#10;(g(0))\\leq f(0)\\right),\" display=\"block\"><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c1</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>i</mi><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo>(</mo><mn>0</mn><mo>\u2264</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06548.tex", "nexttext": "\nThe Herbrand sequent can be derived for deeper nestings of $g$ by changing the $\\omega$-variable substitution used.\n\n \n\\section{Conclusion} \\label{sec:Conclusion}\n\nWeakening the NiA-schema of \\cite{MeCadePaper2015} by reducing the complexity of the cuts  allowed for extraction of the Herbrand system using the concepts of \\cite{CERESS2}. As a case study of the schematic CERES method, to the best of our knowledge this is the first one. From the analysis of the ECA-schema there are two issues which seem to influence the applicability  of the  schematic CERES method. The first issue, as we pointed out earlier, is the ordering of the terms in the $\\omega$ sort. However, a second issue arising in this work is the complexity of the terms,  specifically what is the highest arity function symbol allowed. In the case of the NiA-schema, terms were constructed from both an arity two  and an arity one function symbol, but in the case of the ECA-schema only  arity one function symbols where used. When only arity one function symbols are used nesting of the function symbols does not require the addition of {\\em extra variables} in a given term, of which were used in the NiA-schema \\cite{MeCadePaper2015,MyThesis}. This seems to allow for the creation of more complex orderings of the $\\omega$ sort. We conjecture a sufficient condition that proof schema containing only arity one function symbols can be analysed using the schematic CERES method. Also, an open problem we plan to address in future work is a generalization of the resolution refutation calculus of \\cite{CERESS2} which can handle more complex ordering structures\\cite{MyThesis}. It seems necessary to handle more complex ordering structure if one wants to formalize and analyse more complex mathematical arguments such as F\\\"{u}rstenberg's proof of the infinitude of primes. \n \n\n\\bibliography{references}\n\n\\newpage\n\\appendix\n\n\\section{ECA Formalized in the \\textbf{LKS}-calculus}\\label{sec:FormECA}\n\n\nIn our \\textbf{LKS}-calculus, cut ancestors have a $^{*}$ and cut-configuration ancestors have a $^{**}$. The proof has already been skolemized. We will make the following abbreviations to simplify the formal proof:\\\\ $ESC \\equiv \\exists x ( x\\leq g(x)  \\rightarrow f(x) = f(g(x))  ) $,\\\\ $MD \\equiv \\forall x \\forall y \\Big(  x\\leq y \\rightarrow f(y) \\leq f(x) \\Big)$, \\\\ $FD(n)\\equiv \\forall x ( \\bigvee_{i=0}^{n} i = f(x))$ ,\\\\ $CUT \\equiv \\exists x \\forall y \\left(  \\left( x\\leq y  \\right) \\rightarrow n+1= f(y) \\vee f(y) < n+1 \\right)$,\\\\ $ AX\\equiv  f(\\alpha) < n+1^{*} ,  \\alpha\\leq \\beta^{*}  \\vdash    n= f(\\beta)^{*}  , f(\\beta) < n ^{*}$.\\\\ Also, We will remove every inference rule which does not influence the characteristic clause set of the ECA-schema.\n\n\\begin{figure}[H]\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$\\begin{array}{c} \\vdots\\\\\n\\bigvee_{i=0}^{n} i = f(\\beta)    \\vdash \\\\    f(\\beta) < n+1^{*}  \\end{array}$}\n \\UnaryInfC{$\\begin{array}{c} \n\\vdots \\end{array}$}\n \\AxiomC{$\\begin{array}{c} \n n+1= f(\\beta)  \\vdash \\\\  n+1= f(\\beta)^{*} \\end{array}$}\n \\RightLabel{$\\vee:l$}\n \\BinaryInfC{$\\begin{array}{c} \n\\vdots \\end{array}$}\n \\AxiomC{$\\begin{array}{c} \n 0 \\leq \\beta^*  \\vdash \\\\  0 \\leq \\beta \\end{array}$}\n \\RightLabel{$\\rightarrow:l$}\n \\BinaryInfC{$\\vdots$}\n  \\UnaryInfC{$\\begin{array}{c} \nFD(n+1),MD  \\vdash  CUT(n+1)^{*} \\end{array}$}\n\n \\AxiomC{$\\begin{array}{c}  \\varphi(n+1) \\end{array}$}\n\\dottedLine\n \\UnaryInfC{$\\begin{array}{c}  CUT(n+1)^{*} \\vdash ESC \\end{array}$}\n \\RightLabel{$cut$}\n\\BinaryInfC{$\\begin{array}{c}FD(n+1),MD\\vdash ESC \\end{array}$}\n\\end{prooftree}\n\\end{tiny}\n\\caption{Proof symbol $\\psi(n+1)$}\n\\label{Fig:proofPSIone}\n\\end{figure}\n\n\n\\begin{figure}[H]\n\\begin{tiny}\n\\begin{prooftree} \n \\AxiomC{$\\begin{array}{c} \n 0= f(\\alpha)  \\vdash   0= f(\\alpha)^{*} \\end{array}$}\n \\UnaryInfC{$\\begin{array}{c}  \\vdots \\end{array}$}\n \\AxiomC{$\\begin{array}{c} \n 0 \\leq \\alpha^* \\vdash  0 \\leq \\alpha \\end{array}$}\n \\RightLabel{$\\rightarrow:l$}\n \\BinaryInfC{$\\begin{array}{c} \\vdots\\end{array}$}\n \\UnaryInfC{$\\begin{array}{c} \nFD(0) , MD \\vdash CUT(0)^{*} \\end{array}$}\n\\AxiomC{$\\begin{array}{c}  \\varphi(0) \\end{array}$}\n\\dottedLine\n \\UnaryInfC{$\\begin{array}{c}  CUT(0)^{*} \\vdash ESC \\end{array}$}\n \\RightLabel{$cut$}\n\\BinaryInfC{$\\begin{array}{c}FD(0) , MD  \\vdash ESC \\end{array}$}\n\\end{prooftree}\n\\end{tiny}\n\\caption{Proof symbol $\\psi(0)$}\n\\end{figure}\n\n\\begin{figure}[H]\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$\\begin{array}{c}   n+1= f(\\beta)^{**} \\vdash \\\\      n+1 = f(\\beta) ^{*}\\end{array}$}\n\\AxiomC{$\\begin{array}{c} \\alpha\\leq \\beta^{*} \\vdash \\\\      \\alpha\\leq \\beta^{**}\\end{array}$}\n  \\RightLabel{$\\rightarrow:l$}\n\n\\BinaryInfC{$\\begin{array}{c}  \\vdots \\end{array}$}\n \\AxiomC{$\\begin{array}{c}   f(\\beta) < n+1 ^{**} \\vdash \\\\ f(\\beta) < n+1^{*} \\end{array}$}\n  \\RightLabel{$\\vee:l$}\n\\BinaryInfC{$\\begin{array}{c} \\vdots \\end{array}$}\n\n\\AxiomC{$\\begin{array}{c}AX\\end{array}$}\n \\RightLabel{$\\rightarrow:r$}\n \\RightLabel{$cut$}\n \\BinaryInfC{$\\begin{array}{c} (1)\\end{array}$}\n \\end{prooftree}\n\\end{tiny}\n\n\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$\\begin{array}{c}  (1) \\end{array}$}\n\\AxiomC{$\\begin{array}{c}   n+1 = f(\\alpha) ^{*} ,\\\\  n+1 = f(g(\\alpha)) ^{*} \\vdash \\\\     f(\\alpha) = f(g(\\alpha))  \\end{array}$}\n\\AxiomC{$\\begin{array}{c}   \\vdash \\alpha \\leq \\alpha^{*}\\end{array}$}\n\n \\RightLabel{$\\rightarrow:l$}\n\\BinaryInfC{$\\begin{array}{c} \\vdots  \\end{array}$}\n\\AxiomC{$\\begin{array}{c}   \\alpha \\leq g(\\alpha)\\vdash \\\\ \\alpha \\leq g(\\alpha)^{*}\\end{array}$}\n \\RightLabel{$\\rightarrow:l$}\n\\BinaryInfC{$\\begin{array}{c} \\vdots \\end{array}$}\n \\RightLabel{$cut$}\n \\BinaryInfC{$\\begin{array}{c}  CUT(n+1)^{**} \\vdash  CUT(n)^{*}, ESC  \\end{array}$}\n\n\\AxiomC{$\\begin{array}{c}  \\varphi(n) \\end{array}$}\n\\dottedLine\n \\UnaryInfC{$\\begin{array}{c} CUT(n)^{*} \\vdash ESC\\end{array}$}\n \\RightLabel{$cut$}\n \\BinaryInfC{$\\begin{array}{c} CUT(n+1)^{**} \\vdash ESC,ESC \\end{array}$}\n  \\RightLabel{$c:l$}\n \\UnaryInfC{$\\begin{array}{c}   CUT(n+1)^{**} \\vdash ESC \\end{array}$}\n \\end{prooftree}\n\\end{tiny}\n\\caption{Proof symbol $\\varphi(n+1)$}\n\\label{Fig:proofPHIone}\n\\end{figure}\n\n\n\\begin{figure}[H]\n\\begin{tiny}\n\\begin{prooftree}\n\n\\AxiomC{$\\begin{array}{c}   0= f(\\alpha)^{**}, \\\\ 0= f(g(\\alpha)) ^{**}  \\vdash \\\\    f(\\alpha) = f(g(\\alpha))  \\end{array}$}\n\\AxiomC{$\\begin{array}{c}  \\alpha \\leq g(\\alpha)\\vdash  \\\\ \\alpha\\leq g(\\alpha) ^{**}  \\end{array}$}\n\\RightLabel{$\\rightarrow:l$}\n\\BinaryInfC{$\\begin{array}{c}   \\vdots \\end{array}$}\n\\AxiomC{$\\begin{array}{c}  \\vdash  \\alpha\\leq \\alpha  ^{**}  \\end{array}$}\n\\RightLabel{$\\rightarrow:l$}\n\\BinaryInfC{$\\begin{array}{c} \\vdots   \\end{array}$}\n\n\\AxiomC{$\\begin{array}{c}    f(g(\\alpha)) < 0 ^{**} \\vdash  \\end{array}$}\n\\RightLabel{$\\vee:l$}\n\\BinaryInfC{$\\begin{array}{c}  \\vdots \\end{array}$}\n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$\\begin{array}{c}  \\vdots \\end{array}$}\n\\AxiomC{$\\begin{array}{c}    f(\\alpha) < 0 ^{**} \\vdash  \\end{array}$}\n \\RightLabel{$\\vee:l$}\n\\BinaryInfC{$\\begin{array}{c}  \\vdots \\end{array}$}\n \\UnaryInfC{$\\begin{array}{c} CUT(0)^{**} \\vdash  ESC \\end{array}$}\n \\end{prooftree}\n\\end{tiny}\n\\caption{Proof symbol $\\varphi(0)$}\n\\end{figure}\n\n\\section{Example Resolution Refutation}\n\n\\begin{figure}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$ C6(x,0,2)$} \n\\AxiomC{$C2(x,0,2)$} \n\\AxiomC{$C4'(x,y,0,2)$} \n\\BinaryInfC{$f(g(g(0))) < 1 \\vdash 0= f(g(g(g(0)))),  f(g(g(g(0))))<0$} \n\\BinaryInfC{$f(g(g(0))) < 1 \\vdash 0= f(g(g(g(0))))$} \n\\AxiomC{$C3(x,0,2)$} \n\\BinaryInfC{$f(g(g(0))) < 1,0=f(g(g(0)))\\vdash(6)$} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$\\begin{array}{c} f(g(g(0))) < 1,\\\\ 0=f(g(g(0)))\\vdash (6)\\end{array}$} \n\\AxiomC{$C1(x,0,2)$} \n\\AxiomC{$C4(x,0,2)$} \n\\BinaryInfC{$\\begin{array}{c} f(g(g(0))) < 1\\vdash\\\\ 0= f(g(g(0))),  f(g(g(0)))<0 \\end{array}$} \n\\BinaryInfC{$f(g(g(0))) < 1\\vdash  f(g(g(0)))<0$} \n\\AxiomC{$ C5(x,0,2)  $} \n\\BinaryInfC{$f(g(g(0))) < 1\\vdash (D)$}\n\\end{prooftree}\n\\end{tiny}\n\\caption{Resolution refutation for instance $n=2$ and $k=0$ (Part B).}\n\\end{figure}\n\\begin{figure}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$ C6(x,0,1)$} \n\\AxiomC{$C2(x,0,1)$} \n\\AxiomC{$C4'(x,y,0,1)$} \n\\BinaryInfC{$f(g(0)) < 1 \\vdash 0= f(g(g(0))),  f(g(g(0)))<0$} \n\\BinaryInfC{$f(g(0)) < 1 \\vdash 0= f(g(g(0)))$} \n\\AxiomC{$C3(x,0,1)$} \n\\BinaryInfC{$f(g(0)) < 1,0=f(g(0))\\vdash(5)$} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(g(0)) < 1,0=f(g(0))\\vdash (5)$} \n\\AxiomC{$ C1(x,0,1)$} \n\\AxiomC{$C4(x,y,0,1)$} \n\\BinaryInfC{$f(g(0)) < 1\\vdash 0= f(g(0)),  f(g(0))<0 $} \n\\BinaryInfC{$f(g(0)) < 1\\vdash  f(g(0))<0$} \n\\AxiomC{$ C5(x,0,1) $} \n\\BinaryInfC{$f(g(0)) < 1\\vdash (C)$}\n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$ C6(x,0,0) $} \n\\AxiomC{$C2(x,0,0)$} \n\\AxiomC{$C4'(x,y,0,0)$} \n\\BinaryInfC{$f(0) < 1 \\vdash 0= f(g(0)),  f(g(0))<0$} \n\\BinaryInfC{$f(0) < 1 \\vdash 0= f(g(0))$} \n\\AxiomC{$C3(x,0,0)$} \n\\BinaryInfC{$f(x(1,0)) < 1,0=f(x(0,0))\\vdash(4)$} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(0) < 1,0=f(0)\\vdash (4)$} \n\\AxiomC{$C1(x,0,0)$} \n\\AxiomC{$C4(x,y,0,0)$} \n\\BinaryInfC{$f(0) < 1\\vdash 0 = f(0),  f(0)<0 $} \n\\BinaryInfC{$f(0) < 1\\vdash  f(0)<0$} \n\\AxiomC{$C5(x,0,0) $} \n\\BinaryInfC{$f(0) < 1\\vdash (E)$}\n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$ f(g(g(0)))<1\\vdash (D) $} \n\\AxiomC{$C2(x,1,1)$} \n\\AxiomC{$C4'(x,y,1,1)$} \n\\BinaryInfC{$\\begin{array}{c} f(g(0)) < 2\\vdash\\\\ 1 = f(g(g(0))),  f(g(g(0)))<1 \\end{array}$} \n\\BinaryInfC{$f(g(0)) < 2\\vdash 1 = f(g(g(0)))$} \n\\AxiomC{$C3(x,1,1) $} \n\\BinaryInfC{$f(g(0)) < 2,1 = f(g(0))\\vdash (3) $} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(g(0)) < 2, 1 = f(g(0))\\vdash (3) $} \n\\AxiomC{$C1(x,1,1)$} \n\\AxiomC{$C4(x,y,1,1)$} \n\\BinaryInfC{$\\begin{array}{c} f(g(0)) < 2 \\vdash \\\\ 1 = f(g(0)),  f(g(0))<1 \\end{array}$} \n\\BinaryInfC{$ f(g(0)) < 2 \\vdash  f(g(0))<1 $} \n\\AxiomC{$ f(g(0)) < 1 \\vdash (C)$} \n\\BinaryInfC{$f(g(0)) < 2\\vdash (B)$}\n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(g(0))<1\\vdash (C)$} \n\\AxiomC{$C2(x,1,0)$} \n\\AxiomC{$C4'(x,y,1,0)$} \n\\BinaryInfC{$f(0) < 2\\vdash 1 = f(g(0)),  f(g(0))<1$} \n\\BinaryInfC{$f(0) < 2\\vdash 1 = f(g(0))$} \n\\AxiomC{$\\begin{array}{c} C3(x,1,0)\\vdash \\end{array} $} \n\\BinaryInfC{$f(0) < 2,1 = f(0)\\vdash (2) $} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(0) < 2, 1 = f(0)\\vdash (2) $} \n\\AxiomC{$C1(x,1,0) $} \n\\AxiomC{$ C4(x,y,1,0) $} \n\\BinaryInfC{$ f(0) < 2 \\vdash 1 = f(0),  f(0)<1 $} \n\\BinaryInfC{$ f(0) < 2 \\vdash  f(0)<1 $} \n\\AxiomC{$ f(0) < 1 \\vdash (E)$} \n\\BinaryInfC{$f(0) < 2\\vdash (A)$}\n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$f(g(0))<2\\vdash (B)$} \n\\AxiomC{$C2(x,2,0)$} \n\\AxiomC{$C7(x,2,1)$} \n\\BinaryInfC{$\\vdash 2 = f(g(0)),  f(g(0))<2$} \n\\BinaryInfC{$\\vdash 2 = f(g(0))$} \n\\AxiomC{$C3(x,2,0)$} \n\\BinaryInfC{$2=f(0)\\vdash (1) $} \n\\end{prooftree}\n\\end{tiny}\n\\begin{tiny}\n\\begin{prooftree}\n\\AxiomC{$2=f(0)\\vdash (1) $} \n\\AxiomC{$\\vdash C1(x,2,0) $} \n\\AxiomC{$C7(x,2,0)$} \n\\BinaryInfC{$\\vdash 2 = f(0),  f(0)<2$} \n\\BinaryInfC{$\\vdash f(0)<2 $} \n\\AxiomC{$ f(0) < 2\\vdash (A)$} \n\\BinaryInfC{$\\vdash $}\n\\end{prooftree}\n\\end{tiny}\n\\caption{Resolution refutation for instance $n=2$ and $k=0$ (Part A).}\n\\end{figure}\n\n", "itemtype": "equation", "pos": 45557, "prevtext": " \n", "index": 49, "text": "$$ \\left( 0\\leq 0 \\rightarrow f(0) \\leq f(0)\\right) \\vdash  0 \\leq g^{1}(0)  \\rightarrow f(0) = f(g^{1}(0))   . $$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"\\left(0\\leq 0\\rightarrow f(0)\\leq f(0)\\right)\\vdash 0\\leq g^{1}(0)\\rightarrow f%&#10;(0)=f(g^{1}(0)).\" display=\"block\"><mrow><mrow><mo>(</mo><mn>0</mn><mo>\u2264</mo><mn>0</mn><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>\u22a2</mo><mn>0</mn><mo>\u2264</mo><msup><mi>g</mi><mn>1</mn></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mn>1</mn></msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}]