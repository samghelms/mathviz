[{"file": "1601.07446.tex", "nexttext": "\nwhere $E$ is a thermodynamic system, $k$ is Boltzmann's constant, and $T$ means absolute temperature.\n\nIn the metallurgical industry there are several types of that process, for instance homogenizing or plasticizes. The first one involves heating the metal to a temperature of $1000^\\circ C-1200^\\circ C$, then cooling in the air. The advantage of this is reduction of the crystallization effect. This process has been modeled for optimization purposes.\n\n\\subsubsection{Mathematical Model}\\label{sec:annealingmodel}\nSimulated Annealing (SA) algorithm for the first time was presented in $1983$ by Kirkpatrick and others \\cite{Kirkpatrick1983}. In \\cite{Ingber1989} authors presented the possibility of modifying the algorithm by introducing a further annealing which will speed up the algorithm. The algorithm was also used in other areas, authors of \\cite{Dupanloup2002} showed possibility of using SA to define populations models. In \\cite{Svergun1999} the use of SA in quantum chemistry was demonstrated.\n\nThe algorithm assumes that the temperature at the beginning of the process is high, which allows frequent changes in configurations. Choosing a solution depends on a certain probability and that is why there exist possibility of choosing the worst solution. The advantage of this solution is the situation when algorithm is located in local optimum - the choice of worse solution makes it possible to leave the optimum and further searching of the global optimum. If the temperature is lower, the probability of choosing a worse solution is smaller, so it is a criterion for the acceptation of the solution. SA uses a modified \\eqref{eq:thermodynamics1} in the form\n\n", "itemtype": "equation", "pos": 15645, "prevtext": "\n\n\n\n \\begin{titlepage}\n \\begin{center}\n {\\Large \\sc PREPRINT VERSION\\\\}\n  \\vspace{5mm}\n{\\huge A First Attempt to Cloud-Based User Verification in Distributed System\\\\}\n \\vspace{10mm}\n {\\Large M. Wo\\'{z}niak, D. Po{\\l}ap,  G. Borowik and C. Napoli}\\\\~\\\\\n {\\large Email: napoli@dmi.unict.it\\\\}~\\\\\n \\vspace{5mm}\n{\\Large \\sc FINAL VERSION PUBLISHED ON:\\\\~\\\\ \\bf Asia-Pacific Conference on Computer Aided System Engineering (APCASE), pp. 226--231 (2015)}\n \\end{center}\n \\vspace{5mm}\n {\\Large \\sc BIBITEX: \\\\}\n \n@InProceedings\\{Wozniak2015afirst,\\\\\n  author =    \\{Wozniak, M. and Polap, D. and Borowik, G. and Napoli, C.\\},\\\\\n  title =     \\{A First Attempt to Cloud-Based User Verification in Distributed System\\},\\\\\n  booktitle = \\{Asia-Pacific Conference on Computer Aided System Engineering (APCASE)\\},\\\\\n  year =      \\{2015\\},\\\\\n  pages =     \\{226--231\\},\\\\\n  address =   \\{14-16 July, Quito, Ecuador\\},\\\\\n  publisher = \\{IEEE\\},\\\\\n  doi =       \\{10.1109/APCASE.2015.47\\},\\\\\n  url =       \\{http://ieeexplore.ieee.org/xpls/abs\\_all.jsp?arnumber=7287024\\}\\\\\n\\}\\\\\n\n\n \\vspace{5mm}\n \\begin{center}\nPublished version copyright \\copyright~2015 IEEE \\\\\n\\vspace{5mm}\nUPLOADED UNDER SELF-ARCHIVING POLICIES\\\\\nNO COPYRIGHT INFRINGEMENT INTENDED \\\\\n \\end{center}\n\\end{titlepage}\n\n\n\n\n\n\n\\title{A First Attempt to Cloud-Based User Verification \\\\in Distributed System}\n\n\n\n\n\n\\author{\n\\IEEEauthorblockN{Marcin Wo{\\'z}niak\\IEEEauthorrefmark{1}, Dawid Po{\\l}ap\\IEEEauthorrefmark{1}, Grzegorz Borowik\\IEEEauthorrefmark{3}, Christian Napoli\\IEEEauthorrefmark{2}}\n\n\\IEEEauthorblockA{\n\\IEEEauthorrefmark{1}Institute of Mathematics, Silesian University of Technology, Kaszubska 23, 44-100 Gliwice, Poland\\\\ Email: Marcin.Wozniak@polsl.pl, Dawid.Polap@gmail.com}\n\n\\IEEEauthorblockA{\\IEEEauthorrefmark{3}Warsaw University of Technology, Nowowiejska 15/19, 00-665 Warsaw, Poland \\\\\nEmail: G.Borowik@tele.pw.edu.pl}\n\n\\IEEEauthorblockA{\\IEEEauthorrefmark{2}Department of Mathematics and Informatics, University of Catania, Viale A. Doria 6, 95125 Catania, Italy\\\\\nEmail: Napoli@dmi.unict.it}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\maketitle\n\n\n\\begin{abstract}\n\nIn this paper, the idea of client verification in distributed systems is presented. The proposed solution presents a sample system where client verification through cloud resources using input signature is discussed. For different signatures the proposed method has been examined. Research results are presented and discussed to show potential advantages.\n\\end{abstract}\n\n\n\n\n\n\n\n\n\n\\begin{keywords}\nuser verification, distributed system, Cloud-Computing.\n\\end{keywords}\n\n\n\n\n\n\n\n\n\n\n\\IEEEpeerreviewmaketitle\n\n\\section{Introduction}\\label{sec:intro}\nNowadays, signature recognition is one of the most important operations in various agencies. At each step we are required to verify our identity. A few of the most important examples in which we use the signature are financial institutions such as banks or even stores where people use cards or checks that require confirmation of identity. Another example is approving of labor contracts or any other type of transactions. These are real-life examples in which we use signatures. All these systems use distributed computing. When a client sign documents the computer system is using data stored remotely. Therefore intelligent solutions dedicated for this process are required. Confirmation of identity by signature brings the possibility of forgery, which is driving force for many people to create system not only to confirm but also to detect a possible attempt to forge a signature. It is not an easy task because a person can sign at a certain angle, invert the lines, write letters quickly or even with some defects such as trembling hand. \n\nDistributed computing system to signature verification should be able to counter check in each of mentioned situations. This is the main problem of decision support systems, which in some way have to process the input signatures to the format or size that allows correct verification. Moreover, mentioned systems should find some specific features in signatures, which are divided into groups describing local and global features. As a global features, the signature is considered as a whole, so for instance a feature will be time or speed of folding. On the other hand, the local will contain characteristic features due to a person's handwriting. In many cases, it is a difficult problem to ask a person to provide many signatures, so it is important to create more signatures in different configuration by computer application on the assumption of saving the most important characteristic features. In recent years, many new ideas for preprocessing and signature verification were presented \\cite{cpalka2014_1}, \\cite{cpalka2014_2}, \\cite{Wozniak2014_2}.\n\\subsection{Related Works}\nExaminations of distributed systems concern workflow management \\cite{Wozniak2015_1}. This is very important for overall performance of processing data over cloud resources \\cite{napoli2014cloud}, \\cite{capizzi2012aninnovative}, \\cite{GiuntaPT11}, \\cite{Wozniak2014_9}. Another aspect is proper positioning for request management \\cite{Wozniak2015_4}, \\cite{Wozniak2014_8}, \\cite{Wozniak2014_1}, \\cite{Wozniak2014_10}, \\cite{Wozniak2013_3}, which makes the system faster and more reliable. In various aspects of positioning and optimization Computational Intelligence (CI) provides interesting solutions. CI methods are applicable in various complex problems \\cite{Wozniak2015_1}, \\cite{Signal-2013}, \\cite{Borowik-2009}, \\cite{Borowik-2011a}, dynamic systems positioning \\cite{Wozniak2014_13} and image processing \\cite{Wozniak2014_5}, \\cite{Wozniak2014_6}, \\cite{Wozniak2015_3}. Therefore proposed solution of signature verification in distributed system will use CI method for intelligent data aggregation. The importance of the presented solution is to efficiently assist in signature verification in distributed systems. The novel approach is based on Cloud-Computed knowledge for various users machines that are about to verify input signatures form serviced clients.\n\\section{General Idea of Cloud-Computing}\\label{sec:cloudComputing}\nCloud-Computing is becoming more popular in the recent years. It is a widely offered service, which basis is a shift of all IT services to the external provider (server) what creates a permanent, remote access to the services for various users located in remote positions. It may use an agent, which is an encapsulated computer system located in the special environment to serve as a core station for data processing, which role is an automatic operations management \\cite{Wozniak2015_2}. \n \nCloud-Computing is often used by companies in order to provide an efficient service to the clients and the users (workers). Instead of creating an infrastructure in all company branches and hiring employers to manage it, the headquarters use central infrastructure and computing power to offer dedicated service for users and clients. In \\cite{sanaei2014heterogeneity} authors analyzed Mobile Cloud Computing in terms of heterogeneity. In Cloud-Computing an important issue is security \\cite{vollmar2014hypervisor}, \\cite{zissis2012addressing}, because users should not be allowed to integrate activities and their resources should be protected from other, unwanted persons.\n\nComputing power can increase and decrease according to the customer needs in specific time. However tailored system composition and application of dedicated methods can improve the overall efficiency and reduce energy consumption \\cite{bonanno2014optimal}, \\cite{bonanno2012optimal}, \\cite{bonanno2011hybrid}. According to research conducted for the European Commission in $2011$, Cloud-Computing can decrease amount of money spend on IT by $20\\%$ and lower energy consumption. Cloud-Computing is usually used in one of three ways:\n\\begin{itemize}\n\t\\item Infrastructure as a Service (IaaS), model in which a special infrastructure is available to the users.\n\t\\item Platform as a Service (PaaS), model in which a special platform of virtual machines and operation systems is available for users to work in.\n\t\\item Software as a Service (SaaS), where users get an access to applications without integrating into system.\n\\end{itemize}\nHowever mainly some compositions of the mentioned above are most practical. In the article we discuss a combination of IaaS and SaaS applied together to serve as an infrastructure for distributed user requests processing and intelligent software for verification of the processed requests.\n\\subsection{Applied Model of Processing}\\label{sec:distributed}\nIn the proposed solution cloud architecture is composed. There are defined two models: one for verification request processing (as shown in Fig. \\ref{fig:processingmodel}) and the other for knowledge acquisition process (as shown in Fig. \\ref{fig:distributedmodel}).\n\n\\begin{figure*}[!th]\n\\centering\n\\includegraphics[width=0.7\\textwidth]{processing_model.png}\n\\caption{Proposed model of requests processing for client verification in Cloud-Computing system.}\n\\label{fig:processingmodel}\n\\end{figure*}\nRequest processing (Fig. \\ref{fig:processingmodel}) in the system starts when a user of the system wants to verify personality of the client signing documents. The client machine sends the verification request to the processing server. This computing unit is connected to database of signature models. The request is processed (verified) using this knowledge, however recognition goes along with assistance of managing supervisor. This does not mean that all the verified requests must be accepted by the managing unit, but that if the processing server hesitates, i.e. the acceptance ration is under certain limit, the managing supervisor takes action to judge the request using the knowledge stored in the database. After acceptance or rejection of the request, this knowledge is reused again to improve the database for further processing.\n\n\\begin{figure*}[!th]\n\\centering\n\\includegraphics[width=0.7\\textwidth]{distributed_model.png}\n\\caption{Proposed model of knowledge acquisition for future client verification in Cloud-Computing system.}\n\\label{fig:distributedmodel}\n\\end{figure*}\nThe other part of the system is a model of knowledge acquisition for future clients verification (Fig. \\ref{fig:distributedmodel}). The system must have the knowledge proper for verification purposes. Therefore the first operation is to help the system learn about the features to verify. Clients give a set of signatures that are send to processing server as an input sample. This set is processed in intelligent aggregation to establish knowledge stored in database. This knowledge can be improved any time, after each successful client verification the new signature is sent to the processing server as a new input sample to be stored in the database after intelligent aggregation with previous knowledge. That means, each new client verification is an important possibility to extend the knowledge in the distributed system. Therefore the system not only performs verification but also learns all the time. Learning process is supervised by an experienced workers to ensure that only the important information helpful for further verification is stored in the database. The system is equipped in backup server, which is to store backup of the knowledge and control the process in the main server. This type of backup ensures that any operation in the system is easily erased and the knowledge can be restored if any demand can happen. For the verification purposes main role plays intelligent signature aggregation method. It is responsible for analyzing input signatures and composing an aggregated knowledge.\n\\section{Intelligent Aggregation Method}\\label{sec:aggregation}\nGenerally, the signature is a figurative mark containing the name of the signatory. In the electronic version, it is an image made up of black and white pixels where black ones represent the signature. Each pixel can be treated as a given discrete two-dimensional point, and that is why we can use an idea of creating new samples based on set of several samples aggregated into one shape. Proposed system process a few signatures at the same time transforming them into a single form using the method described in \\cite{Wozniak2014_2} and place this aggregation into the database. Aggregated structure is perfect for knowledge transfer over connection in distributed systems due to low size of the knowledge portion. The method is presented in Algorithm \\ref{alg:Model}. Processing model \\cite{Wozniak2014_2} is based on interpolation. At the beginning signature is simplified - for all vertical points one as an arithmetic sum of all them is calculated. After that operation, all created points from simplified signature are subjected to the chosen interpolation method. In the end, graph of the interpolated function is created as a new simplified sample.\n\nNext step is a new approach to create more samples based on existing ones. In the situation, when client is creating a few samples of his/her signatures for the first time, it would be stored in database, and then signatures are to be duplicated in various combinations to improve the knowledge in the database. At first, all samples would be combined to create one sample with a complete area of black pixel. In this area, basis points would be created using Simulated Annealing described in section \\ref{sec:annealing}. Then, according to the position of basic points on the $x$-axis, these points should be connected. As a result of that operation, new aggregated sample is created and added to the database for further verification. The model is presented in in Fig. \\ref{fig:model} and discussed in Algorithm \\ref{alg:Model}. \n\\begin{figure*}[!th]\n\\centering\n\\includegraphics[width=0.65\\textwidth]{aggregation_model.png}\n\\caption{Proposed model of intelligent input data aggregation for the knowledge applied in Cloud-Computing based verification process.}\n\\label{fig:model}\n\\end{figure*}\n\\begin{algorithm}[!ht]\n\\caption{Proposed Signature Processing Model}\n\\label{alg:Model}\n\\begin{algorithmic}[1]\n\\STATE Get several signatures from the client and send it to the processing server in the input sample,\n\\STATE $k$ is the number of signatures in the input sample,\n\\STATE\t$t:=0$,\n\t\\WHILE{$t \\leq k$}\n\t\t\\STATE Simplify the input sample,\n\t\t\\STATE Define a limited area,\n\t\t\\STATE Find basis points using Simulated Annealing presented in Algorithm \\ref{alg:SA},\t\t\t\n\t\t\\STATE Create a new aggregated sample based on these points,\n\t\t\\STATE Add new aggregation to the database for further verification,\n\t\t\\STATE Next iteration $t++$,\n\t\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\\subsection{Simulated Annealing}\\label{sec:annealing}\nAnnealing is a metallurgical process where first metal heating to a high temperature is performed, then instantaneous annealing which means holding the metal at a given temperature and in the end slow cooling. The cooling rate is essential in this process. Supervising cooling keeps the metal state close to thermodynamic equilibrium, i.e. the state in which parameters such as pressure and volume remain constant in time. However to maintain a balance we must be aware of the following components:\n\\begin{enumerate}\n\t\\item thermal equilibrium - the constant temperature with no heat exchange with the environment,\n\t\\item mechanical equilibrium - pressure at any point is constant,\n\t\\item chemical equilibrium - there are no chemical reactions which could change the composition of the metal.\n\\end{enumerate}\nBasic equation which is used to describe the thermodynamics of the process is \n\n", "index": 1, "text": "\\begin{equation}\\label{eq:thermodynamics1}\nP(E)\\approx e^{-\\frac{E}{kT}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"P(E)\\approx e^{-\\frac{E}{kT}},\" display=\"block\"><mrow><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2248</mo><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mi>E</mi><mrow><mi>k</mi><mo>\u2062</mo><mi>T</mi></mrow></mfrac></mrow></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07446.tex", "nexttext": "\nwhere $\\delta$ is the difference between the value of the fitness function of the current solution $\\textbf{x}$ and the new, random solution $\\textbf{x}'$ from neighborhood of $\\textbf{x}$, which is presented in \n\n", "itemtype": "equation", "pos": 17409, "prevtext": "\nwhere $E$ is a thermodynamic system, $k$ is Boltzmann's constant, and $T$ means absolute temperature.\n\nIn the metallurgical industry there are several types of that process, for instance homogenizing or plasticizes. The first one involves heating the metal to a temperature of $1000^\\circ C-1200^\\circ C$, then cooling in the air. The advantage of this is reduction of the crystallization effect. This process has been modeled for optimization purposes.\n\n\\subsubsection{Mathematical Model}\\label{sec:annealingmodel}\nSimulated Annealing (SA) algorithm for the first time was presented in $1983$ by Kirkpatrick and others \\cite{Kirkpatrick1983}. In \\cite{Ingber1989} authors presented the possibility of modifying the algorithm by introducing a further annealing which will speed up the algorithm. The algorithm was also used in other areas, authors of \\cite{Dupanloup2002} showed possibility of using SA to define populations models. In \\cite{Svergun1999} the use of SA in quantum chemistry was demonstrated.\n\nThe algorithm assumes that the temperature at the beginning of the process is high, which allows frequent changes in configurations. Choosing a solution depends on a certain probability and that is why there exist possibility of choosing the worst solution. The advantage of this solution is the situation when algorithm is located in local optimum - the choice of worse solution makes it possible to leave the optimum and further searching of the global optimum. If the temperature is lower, the probability of choosing a worse solution is smaller, so it is a criterion for the acceptation of the solution. SA uses a modified \\eqref{eq:thermodynamics1} in the form\n\n", "index": 3, "text": "\\begin{equation}\\label{eq:termodynamika2}\nP(E)\\approx e^{-\\frac{\\delta}{T}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"P(E)\\approx e^{-\\frac{\\delta}{T}},\" display=\"block\"><mrow><mrow><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2248</mo><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mi>\u03b4</mi><mi>T</mi></mfrac></mrow></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07446.tex", "nexttext": "\nThe criterion of acceptance of the new solution is\n\n", "itemtype": "equation", "pos": 17714, "prevtext": "\nwhere $\\delta$ is the difference between the value of the fitness function of the current solution $\\textbf{x}$ and the new, random solution $\\textbf{x}'$ from neighborhood of $\\textbf{x}$, which is presented in \n\n", "index": 5, "text": "\\begin{equation}\\label{eq:roznica}\n\\delta=f(\\textbf{x}')-f(\\textbf{x}).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\delta=f(\\textbf{x}^{\\prime})-f(\\textbf{x}).\" display=\"block\"><mrow><mrow><mi>\u03b4</mi><mo>=</mo><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mtext>\ud835\udc31</mtext><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mtext>\ud835\udc31</mtext><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.07446.tex", "nexttext": "\nwhere $\\gamma \\in (0,1)$ is random value. Other important aspect of the algorithm is a temperature function and stop criterion. The change in temperature might be defined similarly to authors of \\cite{Corana1987}, \\cite{Svergun1999} by introducing the following equation\n\n", "itemtype": "equation", "pos": 17852, "prevtext": "\nThe criterion of acceptance of the new solution is\n\n", "index": 7, "text": "\\begin{equation}\\label{eq:krytAkcep}\n\\gamma < e^{-\\frac{\\delta}{T}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\gamma&lt;e^{-\\frac{\\delta}{T}},\" display=\"block\"><mrow><mrow><mi>\u03b3</mi><mo>&lt;</mo><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mi>\u03b4</mi><mi>T</mi></mfrac></mrow></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07446.tex", "nexttext": "\nwhere $T_{k}$ means value of the temperature in $k$-th iteration, and $r$ is constant defined before the beginning of the algorithm.\n\nThe presented algorithm is an iterative method so it is important to define a stop criterion - the number of iterations or minimum temperature. These are important parameters, as many iterations will lower probability to find best solution. Simulated Annealing is presented in Algorithm \\ref{alg:SA}.\n\\begin{algorithm}[!ht]\n\\caption{Simulated Annealing}\n\\label{alg:SA}\n\\begin{algorithmic}[1]\n\\STATE Define the value of the initial temperature $T$, the fitness function $f$, the number of iterations $it$ and the temperature change $r$,\n\\STATE Generate a random initial solution $\\textbf{x}$,\n\\STATE k:=0,\t\t\t\n\t\\WHILE{$k \\leq it$}\n\t\t\\STATE i:=0,\n\t\t\\FOR{i \\TO k}\n\t\t\t\\STATE Generate random neighboring solution $\\textbf{x}'$,\n\t\t\t\\STATE Calculate the difference $\\delta$ using \\eqref{eq:roznica},\n\t\t\t\\IF{$\\delta<0$}\n\t\t\t\t\\STATE $\\textbf{x}=\\textbf{x}'$\n\t\t\t\\ELSE\n\t\t\t\t\\STATE Generate a random value $\\gamma$,\n\t\t\t\t\\IF{equation \\eqref{eq:krytAkcep} is compiled}\n\t\t\t\t\t\\STATE $\\textbf{x}=\\textbf{x}'$,\n\t\t\t\t\\ENDIF\n\t\t\t\\ENDIF\n\t\t\\ENDFOR\n\t\t\\STATE Reduce the temperature using \\eqref{eq:temp},\n\t\t\\STATE Increase the iterator variable $k:=k+1$,\n\t\\ENDWHILE\n\\STATE Return $\\textbf{x}$ from the last iteration.\n\\end{algorithmic}\n\\end{algorithm}\n\\section{Discussion}\\label{sec:Discussion}\nMany classifiers are designed to verify signatures, and all of them need a huge database, what is not efficient in Cloud-Computing where the amount of data to be transfered over the network can significantly influence workflow. Presented approach to creating new samples based on existing ones can be a strong advantage for distributed systems. Adding to this process a new technology for computers on which verification software is installed will accelerate operations not burdened by typical workflow restrictions.\n\nThe proposed intelligent method can manage input signature to make it aggregated for recognition over Cloud-Computing, where by the presented method we can only get the aggregated shape of the clients signature. This aggregated shape is then passed to the database, where it serves for on-line verification and further training. In Fig. \\ref{fig:signatureoriginal} a sample set of input signatures is presented, for which proposed intelligent aggregation method evaluated the shape to be passed to the database.\n\\begin{figure}[!th]\n\\centering\n\\includegraphics[width=0.2\\textwidth]{img_org0.png}\n\\includegraphics[width=0.2\\textwidth]{img_org1.png}\n\\includegraphics[width=0.2\\textwidth]{img_org2.png}\n\\includegraphics[width=0.2\\textwidth]{img_org3.png}\n\\caption{Input sample from the client.}\n\\label{fig:signatureoriginal}\n\\end{figure}\n\\begin{figure}[!th]\n\\centering\n\\includegraphics[width=0.2\\textwidth]{img_chart_org0.png}\n\\includegraphics[width=0.2\\textwidth]{img_chart_org1.png}\n\\includegraphics[width=0.2\\textwidth]{img_chart_org2.png}\n\\includegraphics[width=0.2\\textwidth]{img_chart_org3.png}\n\\caption{Input sample processed in the intelligent system.}\n\\label{fig:signatureaggregated}\n\\end{figure}\n\\begin{figure}[!th]\n\\centering\n\\includegraphics[width=0.3\\textwidth]{points1.png}\n\\includegraphics[width=0.3\\textwidth]{points2.png}\n\\caption{Aggregated data with verified important points and the main line for ad-hoc signature verification.}\n\\label{fig:signaturedecision}\n\\end{figure}\nThe input sample is processed using one of the methods presented in \\cite{Wozniak2014_2} what gives a set for simplified signatures shapes presented in Fig. \\ref{fig:signatureaggregated}. These shapes are aggregated in one final shape that is to present the possible way the client sign documents. This aggregated shape is used for verification, where the SA method shows points crucial for verification. This knowledge goes to database and is used whenever a client has signed a document and system user requests verification. In verification the signature is simplified using methods examined in \\cite{Wozniak2014_2} to obtain simplified shape which is compared with important points showed by SA over the aggregated shape. \n\\section{Final Remarks}\n\\label{sec:Conclusion}\nIn the article we present a novel approach to creating aggregated knowledge for distributed systems. Proposed novel recognition method is easy to implement with possibility to improve. Moreover it can be implemented in Cloud-Computing where low data packages influence workflow stability and performance. Because of that it will make it easier and cheaper for many small companies to use. Since the data package for client verification is aggregated transfer over the network will be fast even for slow connections. \n\nFuture research will lead to define improvements of discussed approach leading to create fast and efficient signature verification system for large distributed systems. \n\n\\section*{Acknowledgements}\nThis work has been partially supported by project PRISMA PON04a2 A/F funded by the Italian Ministry of University and Research within PON 2007-2013 framework.\n\n\n\\IEEEtriggeratref{99}\n\\bibliographystyle{IEEEtran}\n\n\\bibliography{wozniak_publications_daty,annealing,apcase3}\n\n\n", "itemtype": "equation", "pos": 18207, "prevtext": "\nwhere $\\gamma \\in (0,1)$ is random value. Other important aspect of the algorithm is a temperature function and stop criterion. The change in temperature might be defined similarly to authors of \\cite{Corana1987}, \\cite{Svergun1999} by introducing the following equation\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:temp}\nT_{k+1}=r*T_k,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"T_{k+1}=r*T_{k},\" display=\"block\"><mrow><mrow><msub><mi>T</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>r</mi><mo>*</mo><msub><mi>T</mi><mi>k</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]