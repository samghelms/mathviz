[{"file": "1601.01799.tex", "nexttext": "\nwhere $G(t,\\sigma)$ is defined as\n\n", "itemtype": "equation", "pos": 12979, "prevtext": "\n\n\\title{Dense Bag-of-Temporal-SIFT-Words\\\\ for Time Series Classification}\n\n\\author{Adeline Bailly\\inst{1,4} \\and Simon Malinowski\\inst{2} \\and\nRomain Tavenard\\inst{1} \\and \\\\ Laetitia Chapel\\inst{3} \\and Thomas Guyet\\inst{4}\n}\n\n\\institute{Universit{\\'e} de Rennes 2, IRISA, LETG-Rennes COSTEL, Rennes, France \n\\and Universit{\\'e} de Rennes 1, IRISA, Rennes, France\n\\and Universit{\\'e} de Bretagne-Sud, IRISA, Vannes, France\n\\and Agrocampus Ouest, IRISA, Rennes, France\n}\n\n\\maketitle\n\n\\setcounter{footnote}{0}\n \n\n\\begin{abstract}\nThe SIFT framework has shown to be accurate in the image classification context. In~\\cite{botsw15}, we designed a Bag-of-Words approach based on an adaptation of this framework to time series classification. It relies on two steps: SIFT-based features are first extracted and quantized into words; histograms of occurrences of each word are then fed into a classifier. In this paper, we investigate techniques to improve the performance of Bag-of-Temporal-SIFT-Words: dense extraction of keypoints and normalization of Bag-of-Words histograms. Extensive experiments show that our method significantly outperforms most state-of-the-art techniques for time series classification.\n\\keywords{time series classification, Bag-of-Words, SIFT, dense features, BoTSW, D-BoTSW}\n\\end{abstract}\n\n\n\\section{Introduction \\label{sec:intro} }\n\nClassification of time series has received an important amount of interest over the past years due to many real-life applications, such as medicine~\\cite{wang2012bowbiomedical}, environmental modeling~\\cite{dusseux13}, speech recognition~\\cite{lecun95}. \n\n\n\n\n\nA wide range of algorithms have been proposed to solve this problem.\nOne simple classifier is the $k$-nearest-neighbor ($k$NN), which is usually combined with Euclidean Distance (ED) or Dynamic Time Warping (DTW) similarity measure. The combination of the $k$NN classifier with DTW\n\nis one of the most popular method since it achieves high classification accuracy~\\cite{ratanamahatana2004everything}. However, this method has a high computation cost which makes its use difficult for large-scale real-life applications.\n\nAbove-mentioned techniques compute similarity between time series based on point-to-point comparisons. \nClassification techniques based on higher level structures (\\emph{e.g.} feature vectors) are most of the time faster, while being at least as accurate as DTW-based classifiers. Hence, various works have investigated the extraction of local and global features in time series. \nAmong these works, the Bag-of-Words (BoW) approach (also called Bag-of-Features) \nconsists in representing documents using a histogram of word occurrences.\nIt is a very common technique in text mining, information retrieval and content-based image retrieval because of its simplicity and performance. For these reasons, it has been adapted to time series data in some recent works~\\cite{Bay15,baydogan2013bof,lin2012bop,senin2013saxsvm,wang2012bowbiomedical}. Different kinds of features based on simple statistics, computed at a local scale, are used to create the words.\n\nIn the context of image retrieval and classification, scale-invariant descriptors have proved their accuracy.\n\nParticularly, the Scale-Invariant Feature Transform (SIFT) framework has led to widely used descriptors~\\cite{lowe2004distinctive}.\nThese descriptors are scale and rotation invariant while being robust to noise.\nIn~\\cite{botsw15}, we built on this framework to design a BoW approach for time series classification where words correspond to quantized versions of local features. Features \nare built using the SIFT framework for both detection and description of the keypoints. \nThis approach can be seen as an adaptation of~\\cite{sivic2003video}, which uses SIFT features associated with visual words, to time series. \nIn this paper, we improve our previous work by applying enhancement techniques for BoW approaches, such as dense extraction and BoW normalization. \nTo  validate this, we conduct extensive experiments on a wide range of datasets.\n\nThis paper is organized as follows. Section~\\ref{sec:related} summarizes related work, Section~\\ref{sec:proposed} describes the proposed Bag-of-Temporal-SIFT-Words (BoTSW) method and its improved version (dense extraction and BoW normalization, D-BoTSW), and Section~\\ref{sec:xp} reports experimental results. Finally, Section~\\ref{sec:ccl} concludes and discusses future work.\n\n\\section{Related work \\label{sec:related} }\n\nOur approach for time series classification builds on two well-known methods in computer vision: local features are extracted from time series using a SIFT-based approach and a global representation of time series is produced using Bag-of-Words.\nThis section first introduces state-of-the-art distance-based methods in time series classification and then presents previous works that make use of Bag-of-Words approaches for time series classification.\n\n\\subsection{Distance-based time series classification}\n\nData mining community has, for long, investigated the field of time series classification. Early works focus on the use of dedicated similarity measures to assess similarity between time series. In~\\cite{ratanamahatana2004everything}, Ratanamahatana and Keogh compare Dynamic Time Warping to Euclidean Distance when used with a simple $k$NN classifier. While the former benefits from its robustness to temporal distortions to achieve high accuracy, ED is known to have much lower computational cost.\nCuturi~\\cite{cuturi2011fast} shows that, although DTW is well-suited to retrieval tasks since it focuses on the best possible alignment between time series, it fails at precisely quantifying dissimilarity between non-matching sequences (which is backed by the fact that DTW-derived kernel is not positive definite).\nHence, he introduces the Global Alignment Kernel that takes into account all possible alignments in order to produce a reliable similarity measure to be used at the core of standard kernel methods such as Support Vector Machines (SVM).\nLines and Bagnall~\\cite{lines14} propose an ensemble classifier based on elastic distance measures (including DTW), named Proportional Elastic Ensemble (PROP). \nInstead of building classification decision on similarities between time series, Ye and Keogh~\\cite{ye2009time} use a decision tree in which the partitioning of time series is performed with respect to the presence (or absence) of discriminant sub-sequences (named shapelets) in the series. Though accurate, the method is very computational demanding as building the decision tree requires one to check for all candidate shapelets. Douzal and Amblard~\\cite{douzal2010pr} define a dedicated similarity measure for time series which is then used in a classification tree.\n\n\n\n\n\\subsection{Bag-of-Words for time series classification}\n\n\n\nInspired by text mining, information retrieval and computer vision communities, recent works have investigated the use of Bag-of-Words for time series classification~\\cite{Bay15,baydogan2013bof,lin2012bop,senin2013saxsvm,wang2012bowbiomedical}.\nThese works are based on two main operations: converting time series into Bag-of-Words, and building a classifier upon this BoW representation.\nUsually, standard techniques such as random forests, SVM, neural networks or $k$NN are used for the classification step. \n\nYet, many different ways of converting time series into Bag-of-Words have been introduced. Among them, Baydogan \\emph{et al.} ~\\cite{baydogan2013bof} propose a framework to classify time series \ndenoted TSBF where local features such as mean, variance and extremum values are computed on sliding windows. These features are then quantized into words using a codebook learned by a class probability estimate distribution. \nIn~\\cite{wang2012bowbiomedical}, discrete wavelet coefficients are extracted on sliding windows and then quantized into words using $k$-means. \nIn~\\cite{lin2012bop,senin2013saxsvm}, words are constructed using the Symbolic Aggregate approXimation (SAX) representation~\\cite{Lin03} of time series. SAX symbols are extracted from time series and histograms of $n$-grams of these symbols are computed to form a Bag-of-Patterns (BoP). In \\cite{senin2013saxsvm}, Senin and Malinchik combine SAX with Vector Space Model to form the SAX-VSM method. In~\\cite{Bay15}, Baydogan and Runger design a symbolic representation of multivariate time series (MTS), called SMTS, where MTS are transformed into a feature matrix, whose rows are feature vectors containing a time index, the values and the gradient of time series at this time index (on all dimensions). Random samples of this matrix are given to decision trees whose leaves are seen as words. A histogram of words is output when the different trees are learned.\n\n\nLocal feature extraction has been investigated for long in the computer vision community.\nOne of the most powerful local feature for image is SIFT~\\cite{lowe2004distinctive}.\nIt consists in detecting keypoints as extremum values of the the Difference-of-Gaussians (DoG) function and describing their neighborhoods using histograms of gradients.\n\n\nXie and Beigi~\\cite{Xie09} use similar keypoint detection for time series. \n\nKeypoints are then described by scale-invariant features that characterize the shapes surrounding the extremum.\nIn~\\cite{Can12}, extraction and description of time series keypoints in a SIFT-like framework is used to reduce the complexity of DTW: features are used to match anchor points from two different time series and prune the search space when searching for the optimal path for DTW.\n\n\n\n\n\n\n\n\n\n\n\nIn this paper, we build upon BoW of SIFT-based descriptors.\nWe propose an adaptation of SIFT to mono-dimensional signals that preserves their robustness to noise \nand their scale invariance.\nWe then use BoW to gather information from many local features into a single global one.\n \n\\section{Bag-of-Temporal-SIFT-Words (BoTSW) method\n\\label{sec:proposed} }\n\nThe proposed method is \nbased on three main steps: (i) extraction of keypoints in time series, (ii) description of these keypoints by gradient magnitude at a specific scale and (iii) representation of time series by a BoW, where words correspond to quantized version of the description of keypoints.\nThese steps are depicted in \\figurename~\\ref{fig:overview} and detailed below.\n\n\\begin{figure}[t]\n\\centering\n\\begin{multicols}{2}\n\\begin{subfigure}[b]{0.48\\textwidth}\n\t\\includegraphics[height=18mm,width=\\textwidth]{fig/dog_b_time_series.pdf}\n\t\\includegraphics[height=9mm,width=\\textwidth]{fig/color_keyp_50w.pdf}\n    \\caption{Dense extraction $(\\tau_\\text{step}=15, 9$ scales)}\n\\end{subfigure}\n\\par\n\\begin{subfigure}[b]{0.48\\textwidth}\n\t\\centering\n\t\\includegraphics[height=22mm,width=0.32\\textwidth]{fig/description_keyp_1.pdf}\n\t\\includegraphics[height=22mm,width=0.32\\textwidth]{fig/description_keyp_2.pdf}\n\t\\includegraphics[height=22mm,width=0.32\\textwidth]{fig/description_keyp_3.pdf}\n    \\caption{Keypoint description $(n_b=4, a=2)$}\n\\end{subfigure}\n\\par\n\\begin{subfigure}[b]{0.48\\textwidth}\n\t\\centering\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_1.pdf}\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_2.pdf}\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_3.pdf}\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_4.pdf}\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_5.pdf}\n\t\\includegraphics[height=9mm,width=0.45\\textwidth]{fig/c_50w_6.pdf}\n    \\caption{$k$-means generated codebook $(k=6)$}\n\\end{subfigure}\n\\par\n\\begin{subfigure}[b]{0.48\\textwidth}\n\t\\centering\n\t\\includegraphics[height=22mm,width=\\textwidth]{fig/histogram.pdf}\n    \\caption{Resulting $k$-dimensional histogram}\n\\end{subfigure}\n\\end{multicols}\n\\caption{\nApproach overview: (a) A time series and its dense-extracted keypoints. (b) Keypoint description is based on the time series filtered at the scale at which the keypoint is extracted. Descriptors are quantized into words. \n(c) Codewords obtained \\emph{via} $k$-means, \nthe color is associated with the dots under each keypoint in (a). (d) Histograms of word occurrences are given to a classifier (linear SVM) that learns boundaries between \nclasses. Best viewed in color.\\label{fig:overview}}\n\\end{figure}\n\n\\subsection{Keypoints extraction in time series}\n\nThe first step of our method consists in extracting keypoints in time series. Two approaches are described here: the first one is based on scale-space extrema detection (as in~\\cite{botsw15}) and the second one proposes a dense extraction scheme. \n\n\\subsubsection{Scale-space extrema detection.}\nFollowing the SIFT framework, keypoints in time series are detected as local extrema in terms of both scale and (temporal) location. These scale-space extrema are identified using a DoG function, and form a list of scale-invariant keypoints.\n\nLet $L(t,\\sigma)$ be the convolution ($\\ast$) of a Gaussian function $G(t,\\sigma)$ of width $\\sigma$ with a time series $S(t)$:\n\n", "index": 1, "text": "\\begin{equation}\nL(t,\\sigma) = G(t,\\sigma) \\ast S(t)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"L(t,\\sigma)=G(t,\\sigma)\\ast S(t)\" display=\"block\"><mrow><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mi>\u03c3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mi>\u03c3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2217</mo><mi>S</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01799.tex", "nexttext": "\n\nLowe~\\cite{lowe1999objectrecognition} proposes the Difference-of-Gaussians (DoG) function to detect scale-space extrema in images. Adapted to time series, a DoG function is obtained by subtracting two time series filtered at consecutive scales:\n\n", "itemtype": "equation", "pos": 13081, "prevtext": "\nwhere $G(t,\\sigma)$ is defined as\n\n", "index": 3, "text": "\\begin{equation}\nG(t,\\sigma) = \\frac{1}{\\sqrt{2\\pi}~\\sigma}~e^{- t^2 / 2\\sigma^2}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"G(t,\\sigma)=\\frac{1}{\\sqrt{2\\pi}~{}\\sigma}~{}e^{-t^{2}/2\\sigma^{2}}.\" display=\"block\"><mrow><mrow><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mi>\u03c3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mpadded width=\"+3.3pt\"><mfrac><mn>1</mn><mrow><mpadded width=\"+3.3pt\"><msqrt><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03c0</mi></mrow></msqrt></mpadded><mo>\u2062</mo><mi>\u03c3</mi></mrow></mfrac></mpadded><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mrow><msup><mi>t</mi><mn>2</mn></msup><mo>/</mo><mn>2</mn></mrow><mo>\u2062</mo><msup><mi>\u03c3</mi><mn>2</mn></msup></mrow></mrow></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01799.tex", "nexttext": "\nwhere $k_\\text{sc}$ is a parameter of the method that controls the scale ratio between two  consecutive scales.\n\n\n\nKeypoints are then detected at time index $t$ in scale $j$ if they correspond to extrema of $D(t, k_\\text{sc}^j\\sigma_0)$ in both time and scale, where $\\sigma_0$ is the width of the Gaussian corresponding to the reference scale.\nAt a given scale, each point has two neighbors: one at the previous and one at the following time instant. \nPoints also have neighbors one scale up and one scale down at the previous, same and next time instants, leading to a total of eight neighbors.\nIf a point is higher (or lower) than all of its neighbors, it is considered as an extremum in the scale-space domain and hence a keypoint of $S$. \n\n\\subsubsection{Dense extraction.}\nPrevious researches have shown that accurate classification could be achieved by using densely extracted local features~\\cite{jurie05,wang09}. \nIn this section, we present the adaptation of this setup to our BoTSW scheme.\nKeypoints selected with dense extraction no longer correspond to extrema but are rather systematically extracted at all scales every $\\tau_\\text{step}$ time steps on Gaussian-filtered time series $L(\\cdot{},k_\\text{sc}^j\\sigma_0)$. \n\nUnlike scale-space extrema detection, regular sampling guarantees a minimal amount of keypoints per time series. \nThis is especially crucial for smooth time series from which very few keypoints are detected when using scale-space extrema detection. In addition, even if the densely extracted keypoints are not scale-space extrema, description of these keypoints (cf. Section~\\ref{ssec:desc}) covers the description of scale-space extrema if $\\tau_\\text{step}$ is not too large.\n\n\n\n\n\nThis usually leads to more robust global descriptors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA dense extraction scheme is represented in~\\figurename~\\ref{fig:overview}, where we consider a step of $\\tau_\\text{step} = 15$ for the sake of readability. \n\nIn the following, when dense extraction is performed, we will refer to our method as D-BoTSW (for dense BoTSW).\n\n\\subsection{Description of the extracted keypoints}\n\\label{ssec:desc}\n\nNext step in our process is the description of keypoints. \nA keypoint at time index $t$ and scale $j$ is described by gradient magnitudes of $L(\\cdot{}, k_\\text{sc}^j\\sigma_0)$ around $t$. \nTo do so, $n_b$ blocks of size $a$ are selected around the keypoint. Gradients are computed at each point of each block and weighted using a Gaussian window of standard deviation $\\frac{a \\times n_b}{2}$ so that points that are farther in time from the detected keypoint have lower influence. \nThen, each block is described by two values: the sum of positive gradients and the sum of negative gradients. \nResulting feature vector is hence of dimension $2 \\times n_b$.\n\n\\subsection{Bag-of-Temporal-SIFT-Words for time series classification}\n\\label{botsw_v_features}\n\nThe set of all training features is used to learn a codebook of $k$ words using $k$-means clustering. \nWords represent different local behaviors in time series.\nThen, for a given time series, each feature vector is assigned the closest word in the codebook.\nThe number of occurrences of each word in a time series is computed. \n(D-)BoTSW representation of a time series is the $\\ell_2$-normalized histogram (\\emph{i.e.} frequency vector) of word occurrences. \n\n\\subsubsection{Bag-of-Words normalization.}\nDense sampling on multiple Gaussian-filtered time series provides considerable information to process.\nIt also tends to generate words with little informative power, as stop words do in text mining applications.\nIn order to reduce the impact of those words, we compare two normalization schemes for BoW: Signed Square Root normalization (SSR) and Inverse Document Frequency normalization (IDF). These normalizations are commonly used in image retrieval and classification based on histograms~\\cite{jegou12,jegou2010aggregating,perronin10,sivic2003video}.\n\nJ{\\'e}gou \\emph{et al.}~\\cite{jegou2010aggregating} and Perronin \\emph{et al.}~\\cite{perronin10} show that reducing the influence of frequent codewords before $\\ell_2$ normalization could be profitable. \nThey apply a power $\\alpha \\in [0,1]$ on their global representation. SSR normalization corresponds to the case where $\\alpha = 0.5$, which leads to near-optimal results~\\cite{jegou2010aggregating,perronin10}.\n\n\nIDF normalization also tends to lower the influence of frequent codewords. \nTo do so, document frequency of words is computed as the number of training time series in which the word occurs.\nBoW are then updated by diving each component by its associated document frequency.\n\n\nSSR and IDF normalizations both reduce the influence of frequent codewords in the codebook, and are applied before  $\\ell_2$ normalization. \nWe show in the experimental part of this paper that using BoW normalization improves the accuracy of our method.\n\n\nNormalized histograms are finally given to a classifier that learns how to discriminate classes from this D-BoTSW representation.\n\n\n\\section{Experiments and results}\n\\label{sec:xp}\n\nIn this section, we investigate the impact of both dense extraction of the keypoints and normalization of the Bag-of-Words on classification performance. We then compare our results to the ones obtained with standard time series classification techniques.\n\nFor the sake of reproducibility, C++ source code used for (D-)BoTSW in these experiments is made available for download\\footnote{ \\url{http://people.irisa.fr/Adeline.Bailly/code.html}}.\n\n\n\n\n\nTo provide illustrative timings for our methods, we ran it on a personal computer, for a given set of parameters, using dataset \\emph{Cricket\\_X}~\\cite{ucr} that is made of 390 training time series and 390 test ones.\nEach time series in the dataset is of length 300.\nExtraction and description of dense keypoints takes around 1 second for all time series in the dataset.\nThen, 35 seconds are necessary to learn a $k$-means and fit a linear SVM classifier using training data only.\nFinally, classification of all D-BoTSW corresponding to test time series takes less than 1 second.\n\n\n\n\n\n\\subsection{Experimental setup}\n\\label{sec:xp_setup}\n\nExperiments are conducted on the 86 currently available datasets from the UCR repository~\\cite{ucr}, the largest online database for time series classification. It includes a wide variety of problems, such as sensor reading (\\emph{ECG}), image outline (\\emph{ArrowHead}), human motion (\\emph{GunPoint}), as well as simulated problems (\\emph{TwoPatterns}). All datasets are split into a training and a test set, whose size varies between less than 20 and more than 8000 time series. \nFor a given dataset, all time series have the same length, ranging from 24 to more than 2500 points. \n\n\nParameters $a$, $n_b$, $k$ and $C_{SVM}$ of (D-)BoTSW are learned, while we set $\\sigma_0 = 1.6$ and $k_\\text{sc} = 2^{1/3}$, as these values have shown to produce stable results~\\cite{lowe2004distinctive}.\nParameters $a$, $n_b$, $k$ and $C_{SVM}$ vary inside the following sets: $\\{4, 8\\}$, $\\{4, 8, 12, 16, 20\\}$, $\\left\\{2^i, \\forall i \\in \\{5..10\\}\\right\\}$ and $\\{1, 10, 100\\}$ respectively.\nCodebooks are obtained \\emph{via} $k$-means quantization and a linear SVM is used to classify time series represented as (D-)BoTSW. \n\n\nFor our approach, the best sets (in terms of accuracy) of $(a, n_b, k, C_{SVM})$ parameters are selected by performing cross-validation on the training set. \nDue to the heterogeneity of the datasets, leave-one-out cross-validation is performed on datasets where the training set contains less than 300 time series, and $10$-fold cross-validation is used otherwise. \nThese best sets of parameters are then used to build the classifier on the training set and evaluate it on the test set.\nFor datasets with little training data, it is likely that several sets of parameters yield best performance during the cross-validation process.\nFor example, when using \\emph{DiatomSizeReduction} dataset, BoTSW has 150 out of 180 parameter sets yielding best performance, while there are 42 such sets for D-BoTSW with SSR normalization.\nIn both cases, the number of \\emph{best} parameter sets is too high to allow a fair parameter selection.\nWhen this happens, we keep all parameter sets with best performance at training and perform a majority voting between their outputs at test time.\n\n\n\nParameters $a$ and $n_b$ both influence the descriptions of the keypoints; their optimal values vary between sets so that the description of keypoints can fit the shape of the data. \nIf the data contains sharp peaks, the size of the neighborhood on which features are computed (equal to $a\\times{}n_b$) should be small.\nOn the contrary, if it contains smooth peaks, descriptions should take more points into account.\nParameter $k$ of the $k$-means needs to be large enough to precisely represent the different features.\nHowever, it needs to be small enough in order to avoid overfitting.\nWe consequently allow a large range of values for $k$. \n\n\n\nIn the following, BoTSW denotes the approach where keypoints are selected as scale-space extrema and BoW histograms are $\\ell_2$-normalized.\n\nFor all experiments with dense extraction, we set $\\tau_\\text{step} = 10$, and we extract keypoints at all scales. Using such a value for $\\tau_\\text{step}$ enables one to have a sufficient number of keypoints even for small time series, and guarantees that keypoint neighborhoods overlap so that all subparts of the time series are described.\n\n\n\\subsection{Experiments on dense extraction}\n\\label{sec:xp_dense}\n\n\\begin{figure}[!ht]\n\\centering\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_2_8.pdf}\n\\caption{\\label{fig:errorrate_basic_dense}\nError rates of BoTSW compared to D-BoTSW.\n\n}\n\n\\end{figure}\n\n\\figurename~\\ref{fig:errorrate_basic_dense} shows a pairwise comparison of error rates between BoTSW and its dense counterpart D-BoTSW for all datasets in the UCR repository. \nA point on the diagonal means that obtained error rates are equals. A point above the diagonal illustrates a case where D-BoTSW has a smaller error rate than BoTSW.\nWilcoxon signed rank test's $p$-value and Win/Tie/Lose scores are given in the bottom-right corner of the figure.\n\nWin/Tie/Lose scores indicate that D-BoTSW reaches better performance than BoTSW on 61 datasets, equivalent performance on 4 datasets and worse on 21 datasets.\nWilcoxon test shows that this difference is significant (in the following, we will use a significance level of 10\\% for all statistical tests).\n\nD-BoTSW improves classification on a large majority of the datasets.\nHowever, most points are close to the diagonal, which means that the improvement is of little magnitude. \nIn the following, we show how to further improve these results thanks to D-BoTSW normalization.\n\n\\subsection{Experiments on BoW normalization}\n\\label{sec:xp_norm}\n\n\\begin{figure}[!ht]\n\\centering\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_8_19.pdf}\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_8_20.pdf}\n\\caption{\\label{fig:errorrate_dense_norm}\nError rates of D-BoTSW with and without normalization.\n\n}\n\\end{figure}\n\nIn image retrieval and classification, Bag-of-Words normalizations have been shown to improve classification rates with dense extracted keypoints. We investigate here the impact of SSR and IDF normalizations on D-BoTSW for time series classification.\n\nAs it can be seen in~\\figurename~\\ref{fig:errorrate_dense_norm}, both SSR and IDF normalizations improve classification performance (though the improvement of using IDF is not statistically significant). Lowering the influence of largely-represented codewords hence leads to more accurate classification with D-BoTSW.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIDF normalization only leads to a small improvement in classification accuracy: Win/Tie/Lose score against non-normalized D-BoSTW is 38/14/34. \nOn the contrary, SSR normalization significantly improves the classification accuracy, with a Win/Tie/Lose score of 61/10/15 over non-normalized D-BoSTW.\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[t]\n\\centering\n\\begin{subfigure}[b]{0.8\\textwidth}\n\t\\centering\n\t\\includegraphics[width=\\linewidth]{fig/bow_nonorm_shapesall.pdf}\n    \\caption{$\\ell_2$ normalized D-BoTSW}\n\\end{subfigure}\n\\begin{subfigure}[b]{0.8\\textwidth}\n\t\\centering\n\t\\includegraphics[width=\\linewidth]{fig/bow_idf_shapesall.pdf}\n    \\caption{IDF+$\\ell_2$ normalized D-BoTSW}\n\\end{subfigure}\n\\begin{subfigure}[b]{0.8\\textwidth}\n\t\\centering\n\t\\includegraphics[width=\\linewidth]{fig/bow_ssr_shapesall.pdf}\n    \\caption{SSR+$\\ell_2$ normalized D-BoTSW}\n\\end{subfigure}\n\\caption{Per-dimension energy of D-BoTSW vectors extracted from dataset \\emph{ShapesAll}. The same codebook is used for all normalization schemes so that dimensions are comparable across all three sub-figures. \\label{fig:var_dense_norm}}\n\\end{figure}\n\nThis is backed by~\\figurename~\\ref{fig:var_dense_norm}, in which one can see that when using SSR normalization, variance (\\emph{i.e.} energy) is spread across all dimensions of the BoW, leading to a more balanced representation than with other two normalization schemes. \n\n\\subsection{Comparison with state-of-the-art methods}\n\nIn the following, we will refer to dense SSR-normalized BoTSW as D-BoTSW, since this setup is the one providing the best classification performance. \nWe now compare D-BoTSW to the most popular state-of-the-art methods for time series classification. \nThe UCR repository provides error rates for the 86 datasets with Euclidean distance 1NN (EDNN) and Dynamic Time Warping 1NN (DTWNN)~\\cite{ratanamahatana2004everything}. \nWe use published error rates for TSBF (45 datasets)~\\cite{baydogan2013bof}, SAX-VSM (51 datasets)~\\cite{senin2013saxsvm}, SMTS (45 datasets)~\\cite{Bay15}, PROP (46 datasets)~\\cite{lines14} and BoP (20 datasets).\n\nAs BoP~\\cite{lin2012bop} only provides classification performance for 20 datasets, we decided not to plot pairwise comparison of error rates between D-BoTSW and BoP.\nNote however that the Win/Tie/Lose score is 17/1/2 in favor of D-BoTSW and this difference is statistically significant ($p<0.001$). BoP has smaller error rate than D-BoTSW on \\emph{wafer} (0.003 \\emph{vs.} 0.004) and \\emph{Olive Oil} (0.133 \\emph{vs.} 0.167) data sets. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!p]\n\\centering\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_ed.pdf}\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_dtw.pdf}\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_tsbf.pdf}\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_saxvsm.pdf}\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_smts.pdf}\n\n\t\\includegraphics[width=0.48\\textwidth]{fig/graph_igrida_19_prop.pdf}\n\\caption{\\label{fig:errorrate_baselines}\nError rates for D-BoTSW with SSR normalization versus baselines (ED-NN, DTW-NN, TSBF, SAX-VSM, SMTS, PROP).  \n}\n\n\\end{figure}\n\n\n\n\n\n\n\n\n\\begin{table}[!p]\n\t\\centering\n\t\t\\input{erate_table.tex}\n\t\\caption{\\label{tab:errorrate}\n\tClassification error rates for D-BoTSW with SSR normalization (for each dataset, best performance is written as bold text).}\n\\end{table}\n\n\\figurename~\\ref{fig:errorrate_baselines} shows that D-BoTSW performs better than 1NN combined with ED (EDNN) or DTW (DTWNN), TSBF, SAX-VSM and SMTS. \nThough relying on a single similarity measure that has linear time complexity in the length of time series, D-BoTSW slightly outperforms PROP, which relies on outputs from several similarity measures with quadratic time complexity.\n\nIn~\\figurename~\\ref{fig:errorrate_baselines}, it is striking to realize that D-BoTSW not only improves the classification, but might improve it considerably. Error rate on \\emph{Shapelet Sim} dataset drops from 0.461 (EDNN) and 0.35 (DTWNN) to 0 (D-BoTSW), for example.\nPairwise comparisons of methods \nshow that all observed differences between D-BoTSW and state-of-the-art methods are statistically significant, except for PROP.\n\nError rates (ER) obtained with D-BoTSW are reported in~\\tablename~\\ref{tab:errorrate}, together with baseline scores publicly available at~\\cite{ucr}. \n\nThis set of experiments, conducted on a wide variety of time series datasets, shows that D-BoTSW significantly outperforms most state-of-the-art methods.\n\n\n\\section{Conclusion}\n\\label{sec:ccl}\n\nIn this paper, we presented the D-BoTSW technique, which transforms time series into histograms of quantized local features. \nThe association of SIFT keypoints and Bag-of-Words has been widely used and is considered as a standard technique in image domain, however it has never been investigated for time series classification.\nWe carried out extensive experiments and showed that dense keypoint extraction and SSR normalization of Bag-of-Words lead to the best performance for our method.\nWe compared the results with standard techniques for time series classification: D-BoTSW has comparable performance to PROP with lower time complexity and significantly outperforms all other techniques.\n\nWe believe that classification performance could be further improved by taking more time information into account, as well as reducing the impact of quantization losses in our representation. \nIndeed, only local temporal information is embedded in our model and the global structure of time series is ignored.\nMoreover, more detailed global representations for sets of features than the standard BoW have been proposed in the computer vision community~\\cite{jegou2010aggregating,perronnin2007fisher}, and such global features could be used in our framework.\n\n\n\\section*{Acknowledgments}\n\nThis work has been partly funded by ANR project ASTERIX (ANR-13-JS02-0005-01), R{\\'e}gion Bretagne and CNES-TOSCA project VEGIDAR.\n\n\\bibliography{main}{}\n\\bibliographystyle{plain}\n\n", "itemtype": "equation", "pos": 13425, "prevtext": "\n\nLowe~\\cite{lowe1999objectrecognition} proposes the Difference-of-Gaussians (DoG) function to detect scale-space extrema in images. Adapted to time series, a DoG function is obtained by subtracting two time series filtered at consecutive scales:\n\n", "index": 5, "text": "\\begin{equation}\nD(t,\\sigma) = L(t, k_\\text{sc}\\sigma) - L(t,\\sigma),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"D(t,\\sigma)=L(t,k_{\\text{sc}}\\sigma)-L(t,\\sigma),\" display=\"block\"><mrow><mrow><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mi>\u03c3</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mrow><msub><mi>k</mi><mtext>sc</mtext></msub><mo>\u2062</mo><mi>\u03c3</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo>,</mo><mi>\u03c3</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]