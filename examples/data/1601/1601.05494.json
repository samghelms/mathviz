[{"file": "1601.05494.tex", "nexttext": " where $G \\in {\\ensuremath{\\mathrm{NP}}}$ and\n${\\dot\\cup}$ is disjoint union. Then $C$ is 2-T-complete for ${\\ensuremath{\\mathrm{NP}}}$, and\nif $G$ is {$\\p$-generic\\xspace}, $C$ is not 2-tt-complete\n\\cite{Lutz:CvKL,AmbBen00}. There is a straightforward 3-T (also 5-tt)\nautoreduction of $C$ based on padding ${\\rm SAT}$.\\footnote{Given an\n  instance $x$ of $C$, pad $x$ to an instance $y$ such that\n  ${\\rm SAT}[x]={\\rm SAT}[y]$. We query $G[y]$ and then query either $G \\cap\n  {\\rm SAT}[y]$ if $G[y] = 1$ or $G \\cup {\\rm SAT}[y]$ if $G[y]=0$ to learn\n  ${\\rm SAT}[y]$. Finally, if our instance is $G[x]$ the answer is obtained\n  by querying $G\\cap{\\rm SAT}[x]$ if ${\\rm SAT}[y]=1$ or by querying\n  $G\\cup{\\rm SAT}[x]$ if ${\\rm SAT}[y]=0$. If our instance is $G\\cup{\\rm SAT}[x]$ or\n  $G\\cap{\\rm SAT}[x]$, we query $G[x]$ and combine that answer with\n  ${\\rm SAT}[y]$.}  However, since $C$ is 2-T-honest-complete, we\nindirectly obtain a 2-T (also 3-tt) autoreduction by first reducing\nthrough ${\\rm SAT}$ (Lemma \\ref{le:honest auto}). In Theorem \\ref{th:2T vs\n  2tt} we show $C$ is not 2tt-autoreducible.\n\n\nIt turns out this idea works in general. We show that many sets which\nseparate completeness notions also separate autoreducibility\nnotions. Ambos-Spies and Bentzien \\cite{AmbBen00} also separated both\n$k$-T-completeness and $(k+1)$-tt-completeness from both\n$k$-tt-completeness and $(k-1)$-T-completeness for every $k \\geq 3$\nunder the Genericity Hypothesis. We show that the same sets also\nseparate $k$-T-autoreducibility and $(k+1)$-tt-autoreducibility from\n$k$-tt-autoreducibility and $(k-1)$-T-autoreducibility (Theorems\n\\ref{th:k-tt} and \\ref{th:k-1-T}).  We also obtain that there is a\ntt-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is tt-autoreducible and not\nbtt-autoreducible (Theorem \\ref{th:btt vs tt}), again using a\nconstruction of Ambos-Spies and Bentzien.\n\nIn the aforementioned results, there is a gap -- we only separate\n$k$-tt-autoreducibility from $(k-2)$-T-autoreducibility (for $k \\geq\n3$), where we can hope for a separation from\n$(k-1)$-T-autoreducibility. The separation of $k$-tt from $(k-1)$-T is\nalso open for completeness under the Genericity Hypothesis (or the\nMeasure Hypothesis). To address this gap, we use a stronger hypothesis\non the class ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$.  Pavan and Selman \\cite{PavSel04}\nshowed that if ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a\n${\\mathrm{DTIME}}(2^{n^\\epsilon})$-bi-immune set, then 2-tt-completeness is\ndifferent from 1-tt-completeness for ${\\ensuremath{\\mathrm{NP}}}$. We show that if ${\\ensuremath{\\mathrm{NP}}} \\cap\n{\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then $k$-tt-completeness is different\nfrom $(k-1)$-T-completeness for all $k \\geq 3$ (Theorem \\ref{th:k-tt\n  vs (k-1)-T complete}). We then show these constructions also\nseparate autoreducibility: if there is a {$\\p$-generic\\xspace} set in\n${\\ensuremath{\\mathrm{NP}}}\\cap{\\co{{\\ensuremath{\\mathrm{NP}}}}}$, then for every $k \\geq 2$, there is a $k$-tt-complete\nset for ${\\ensuremath{\\mathrm{NP}}}$ that is $k$-tt autoreducible, but is not $(k-1)$-T\nautoreducible (Theorems \\ref{th:2tt vs 1tt} and \\ref{th:k-tt vs (k-1)-T autored}).\n\nThis paper is organized as follows. Preliminaries are in Section\n\\ref{sec:prelim}. The results using the Genericity Hypothesis are\npresented in Section \\ref{sec:genericity}. We use the stronger\nhypothesis on ${\\ensuremath{\\mathrm{NP}}}\\cap{\\co{{\\ensuremath{\\mathrm{NP}}}}}$ in Section \\ref{sec:stronger}. Section\n\\ref{sec:conclusion} concludes with some open problems. \n\n\n\n\\begin{table}[ht!]\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n${\\cal C}$ & ${\\mathcal{S}}$ & ${\\cal R}$ & notes \\\\\n\\hline\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-T & $k$-tt & \nTheorem \\ref{th:2T vs 2tt} ($k=2$), Theorem\n\\ref{th:k-tt} ($k \\geq 3)$\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-T & $(k-1)$-T & \nTheorem \\ref{th:2T vs 2tt} ($k=2$), Theorem\n\\ref{th:k-1-T} ($k \\geq 3)$\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-tt & $(k-1)$-tt & Corollary \\ref{co:3tt vs 2tt} ($k=3$), Theorem \\ref{th:k-tt} ($k \\geq 4$)\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-tt & $(k-2)$-T & Corollary \\ref{co:3tt vs 1T} ($k=3$), Theorem \\ref{th:k-1-T} ($k \\geq 4$)\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & tt & btt & Theorem \\ref{th:btt vs tt}\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ & $k$-tt & $(k-1)$-T & Theorem \\ref{th:2tt vs 1tt}\n($k = 2$), Theorem \\ref{th:k-tt vs (k-1)-T autored} ($k \\geq 3$) \\\\\n\\hline\n\\end{tabular}\n\\caption{If ${\\cal C}$ contains a {$\\p$-generic\\xspace} set, then there is a ${\\mathcal{S}}$-complete\nset in ${\\ensuremath{\\mathrm{NP}}}$ that is ${\\mathcal{S}}$-autoreducible but not ${\\cal R}$-autoreducible.}\n\\label{table:results}\\end{center}\n\\end{table}\n\n\\section{Preliminaries}\\label{sec:prelim}\n\nWe use the standard enumeration of binary strings, i.e $s_0 = \\lambda,\ns_1 = 0, s_2 = 1,s_3 = 00,...$ as an order on binary strings. All\nlanguages in this paper are subsets of $\\{0,1\\}^*$ identified with\ntheir characteristic sequences. In other words, every language $A \\in\n\\{0,1\\}^*$ is identified with $\\chi_A = A[s_0]A[s_1]A[s_2]...$. If $X$\nis a set, equivalently a binary sequence, and $x \\in \\{0,1\\}^*$ then\n$X\\upharpoonright x$ is the initial segment of $X$ for all strings\nbefore $x$, i.e the subset of $X$ that contains every $y \\in X$ that\n$y < x$.\n\nAll reductions in this paper are polynomial-time reductions, therefore\nwe may not emphasize this every time we define a reduction. \nWe use standard notions of reducibilities \\cite{LaLySe75}.\n\nGiven $A$, $B$, and ${\\cal R} \\in\n\\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}}\\}$, $A$ is {\\em\n  polynomial-time ${\\cal R}$-honest reducible} to $B$ ($A\n\\le_{{\\cal R}\\text{-}h}^{\\mathrm{p}}$) if $A \\le_{\\cal R}^{\\mathrm{p}}$ and there exist a\nconstant $c$ such that for every input $x$, every query $q$ asked from\n$B$ has the property $|x|^{1/c} < |q|$. In particular, a reduction\n${\\cal R}$ is called {\\em length-increasing} if on every input the\nqueries asked from the oracle are all longer than the input.\n\nFor any reduction ${\\cal R} \\in \\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}}\\}$ a \nlanguage $A$ is ${\\cal R}$-{\\em autoreducible} if $A \\leq^{\\mathrm{p}}_{\\cal R}$ via a\nreduction where on every instance $x$, $x$ is not queried.\n\n\nThe following lemma states that any honest-complete set for ${\\ensuremath{\\mathrm{NP}}}$ is\nalso autoreducible under the same type of reduction. This follows\nbecause ${\\ensuremath{\\mathrm{NP}}}$ has a paddable, length-increasing complete set.\n\n\\begin{lemma}\n\\label{le:honest auto}\nLet ${\\cal R} \\in \\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}},\\ \\ldots\\}$\nbe a reducibility. Then every ${\\cal R}$-honest-complete set for ${\\ensuremath{\\mathrm{NP}}}$\n is ${\\cal R}$-autoreducible.\n\\end{lemma}\n\\begin{proof}\nLet $A \\in {\\ensuremath{\\mathrm{NP}}}$ be ${\\cal R}$-honest-complete. Then there is an ${\\cal R}$-honest\nreduction $M$ from ${\\rm SAT}$ to $A$. There exists $m \\geq 1$ such that every\nquery $q$ output by $M$ on an instance $x$ satisfies $|q| \\geq\n|x|^{\\tfrac{1}{m}}$.\n\nSince ${\\rm SAT}$ is ${\\ensuremath{\\mathrm{NP}}}$-complete via length-increasing many-one\nreductions, $A {\\leqp_\\mathrm{m}} {\\rm SAT}$ via a length-increasing reduction $g$.\nSince ${\\rm SAT}$ is paddable, there is a polynomial-time function $h$ such\nthat for any $y$, ${\\rm SAT}[h(y)] = {\\rm SAT}[y]$ and $|h(y)| > |y|^m$.\n\nTo obtain our ${\\cal R}$-autoreduction of $A$, we combine $g$, $h$, and $M$. \nOn instance $x$ of $A$, compute the instance $h(g(x))$ of ${\\rm SAT}$ and use $M$ to reduce $h(g(x))$ to\n$A$. Since $|h(g(x))| > |g(x)|^m > |x|^m$, every query $q$ of $M$\nhas $|q| > |h(g(x))|^{\\tfrac{1}{m}} > |x|$. Therefore all queries are different\nthan $x$ and this is an autoreduction.\n\\end{proof}\n\n\nMost of the results in this paper are based on a non-smallness\nhypothesis for ${\\ensuremath{\\mathrm{NP}}}$ called the {\\em Genericity Hypothesis} that ${\\ensuremath{\\mathrm{NP}}}$\ncontains a ${\\mathrm{p}}$-generic set \\cite{AmFlHu87,AmbBen00}. In order to define genericity first we need to define what a \n{\\em simple extension function} is.\n For any $k$, a simple $n^k$-extension function is a partial function from \n$\\{0,1\\}^*$ to $\\{0,1\\}$ that is computable in $O(n^k)$. Given a set $A$ and an extension function $f$ \nwe say that $f$ is {\\em dense along} $A$ if $f$ is defined on infinitely many initial segments of $A$. \nA set $A$ {\\em meets} a simple extension function $f$ at $x$ if $f (A \\upharpoonright x)$ is defined and\nequal to $A[x]$. We say $A$ meets $f$ if $A$ meets $f$ at some $x$.\nA set $G$ is called {\\em {$\\p$-generic\\xspace}} if it meets every simple $n^k$-extension function for any $k \\geq 1$ \\cite{AmbBen00}. \nA partial function $f:\\{0,1\\}^* \\rightarrow (\\{0,1\\}^* \\times\n\\{0,1\\})^*$ is called a {\\em k-bounded extension function} if whenever $f(X \\upharpoonright x)$ is defined, \n$f(X \\upharpoonright x) = (y_0,i_0)...(y_m,i_m)$ for some $m < k$, and $x \\le y_0 < y_1<...<y_m$, \nwhere $y_j$'s are strings and $i_j$'s are either $0$ or $1$. A set $A$ meets $f$ at $x$ if \n$f(A \\upharpoonright x)$ is defined, and $A$ agrees with $f$ on all  $y_j$'s, i.e. \nif $f(A \\upharpoonright x) = (y_0,i_0)...(y_m,i_m)$ then $A[y_j] = i_j$ for all $j \\le m$ \\cite{AmbBen00}.\n\nWe will use the following routine extension of a lemma in \\cite{AmbBen00}.\n\n\\begin{lemma}\\label{extension function revised}\nLet $l,c \\geq 1$ and let $f$ be an $l$-bounded partial extension function defined on initial segments \n$\\alpha = X \\upharpoonright 0^n$ of length $2^n$ $(n \\geq 1)$. Whenever $f(\\alpha)$ is defined we have\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\maketitle\n\n\\begin{abstract}\n\n  We study the polynomial-time autoreducibility of ${\\ensuremath{\\mathrm{NP}}}$-complete sets\n  and obtain separations under strong hypotheses for ${\\ensuremath{\\mathrm{NP}}}$. Assuming\n  there is a {$\\p$-generic\\xspace} set in ${\\ensuremath{\\mathrm{NP}}}$, we show the following:\n  \\begin{itemize}\n    \\item For every $k \\geq 2$, there is a $k$-T-complete set for\n      ${\\ensuremath{\\mathrm{NP}}}$ that is\n      $k$-T autoreducible, but is not $k$-tt autoreducible or $(k-1)$-T\n      autoreducible.\n      \\item For every $k \\geq 3$, there is a $k$-tt-complete set for\n        ${\\ensuremath{\\mathrm{NP}}}$ that\n        is $k$-tt autoreducible, but is not $(k-1)$-tt autoreducible\n        or $(k-2)$-T autoreducible.\n    \\item There is a tt-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is tt-autoreducible,\n        but is not btt-autoreducible.\n  \\end{itemize}\n  \n\\noindent\n  Under the stronger assumption that there is a {$\\p$-generic\\xspace} set in\n  ${\\ensuremath{\\mathrm{NP}}}\\cap{\\co{{\\ensuremath{\\mathrm{NP}}}}}$, we show:\n  \\begin{itemize}\n    \\item For every $k \\geq 2$, there is a $k$-tt-complete set for\n      ${\\ensuremath{\\mathrm{NP}}}$ that is $k$-tt autoreducible, but is not $(k-1)$-T\n      autoreducible.\n  \\end{itemize}\n  \n\\noindent\nOur proofs are based on constructions from separating NP-completeness\nnotions. For example, the construction of a 2-T-complete set for\n${\\ensuremath{\\mathrm{NP}}}$ that is not 2-tt-complete also separates 2-T-autoreducibility\nfrom 2-tt-autoreducibility.\n\n\\end{abstract}\n\n\\section{Introduction}\n\nAutoreducibility measures the redundancy of a set. \nFor a reducibility ${\\cal R}$, a set $A$ is ${\\cal R}$-autoreducible if\nthere is a ${\\cal R}$-reduction from $A$ to $A$ where the instance is\nnever queried \\cite{Tra70}.  Understanding the autoreducibility of\ncomplete sets is important because of applications to separating\ncomplexity classes \\cite{BFvMT00}. We study the polynomial-time\nautoreducibility \\cite{Amb83} of ${\\ensuremath{\\mathrm{NP}}}$-complete sets.\n\nNatural problems are paddable and easily shown to be\nm-autoreducible. In fact, Gla{\\ss}er et\nal. \\cite{Glasser07} showed that all nontrivial m-complete sets for ${\\ensuremath{\\mathrm{NP}}}$\nand many other complexity classes are m-autoreducible.  Beigel and\nFeigenbaum \\cite{BeiFei92} showed that T-complete sets for ${\\ensuremath{\\mathrm{NP}}}$ and\nthe levels of the polynomial-time hierarchy are T-autoreducible.\nWe focus on intermediate reducibilities between many-one and Turing.\n\nPrevious work has studied separations of these autoreducibility\nnotions for larger complexity classes. Buhrman et al. \\cite{BFvMT00}\nshowed there is a 3-tt-complete set for ${\\rm EXP}$ that is not\nbtt-autoreducible. For ${\\rm NEXP}$, Nguyen and Selman\n\\cite{NguyenSelman:STACS14} showed there is a 2-T-complete set that is\nnot 2-tt-autoreducible and a tt-complete set that is not\nbtt-autoreducible.  We investigate whether similar separations hold\nfor ${\\ensuremath{\\mathrm{NP}}}$.\n\nSince all ${\\ensuremath{\\mathrm{NP}}}$ sets are 1-tt-autoreducible if ${\\ensuremath{{\\mathrm P}}} = {\\ensuremath{\\mathrm{NP}}}$, it\nis necessary to use a hypothesis at least as strong as ${\\ensuremath{{\\mathrm P}}} \\neq {\\ensuremath{\\mathrm{NP}}}$\nto separate autoreducibility notions.  We work with the {\\em\n  Genericity Hypothesis} that there is a {$\\p$-generic\\xspace} set in ${\\ensuremath{\\mathrm{NP}}}$\n\\cite{AmFlHu87,AmbBen00}. This is stronger than ${\\ensuremath{{\\mathrm P}}} \\neq {\\ensuremath{\\mathrm{NP}}}$, but weaker\nthan the {\\em Measure Hypothesis} \\cite{Lutz:CvKL,Hitchcock:HHDCC}\nthat there is a p-random set in ${\\ensuremath{\\mathrm{NP}}}$. Under the Genericity\nHypothesis, we separate many autoreducibility notions for\n${\\ensuremath{\\mathrm{NP}}}$-complete sets. Our main results are summarized in Table \\ref{table:results}.\n\nPrevious work has used the measure and genericity hypotheses to\nseparate completeness notions for ${\\ensuremath{\\mathrm{NP}}}$. Consider the set \n", "index": 1, "text": "$$C = G\n\\dot\\cup (G \\cap {\\rm SAT}) \\dot\\cup (G \\cup {\\rm SAT}),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"C=G\\dot{\\cup}(G\\cap{\\rm SAT})\\dot{\\cup}(G\\cup{\\rm SAT}),\" display=\"block\"><mrow><mrow><mi>C</mi><mo>=</mo><mrow><mi>G</mi><mo>\u2062</mo><mover accent=\"true\"><mo>\u222a</mo><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>G</mi><mo>\u2229</mo><mi>SAT</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mover accent=\"true\"><mo>\u222a</mo><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>G</mi><mo>\u222a</mo><mi>SAT</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nwhere $l_{\\alpha} \\leq l$, $pos(\\alpha) = (y_{\\alpha , 1},...,y_{\\alpha,l_{\\alpha}})$ is computable in \n$2^{cn}$ steps and $i_{\\alpha , j}$ is computable in $2^{c|y_{\\alpha , j}|}$ steps. \nThen for every {$\\p$-generic\\xspace} set $G$, if $f$ is dense along $G$ then $G$ meets $f$.\n\\end{lemma}\n\n\\section{Autoreducibility Under the Genericity Hypothesis}\\label{sec:genericity}\n\n\nWe begin by showing the Genericity Hypothesis implies there is a\n$2$-${\\mathrm{T}}$-complete set that separates $2$-${\\mathrm{T}}$-autoreducibility from\n$2$-${\\mathrm{tt}}$-autoreducibility. The proof utilizes the construction of\n\\cite{Lutz:CvKL,AmbBen00} that of a set that separates\n$2$-${\\mathrm{T}}$-completeness from $2$-${\\mathrm{tt}}$-completeness.\n\n\\begin{theorem}\n\\label{th:2T vs 2tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a $2$-${\\mathrm{T}}$-complete set in ${\\ensuremath{\\mathrm{NP}}}$ that is $2$-${\\mathrm{T}}$-autoreducible, but not $2$-${\\mathrm{tt}}$-autoreducible.\n\\end{theorem}\n\n\\begin{proof}\nLet $G \\in {\\ensuremath{\\mathrm{NP}}}$ be {$\\p$-generic\\xspace} and define $C = G \\;\\dot\\cup \\;(G \\cap {\\rm SAT})\n\\;\\dot\\cup \\;(G \\cup {\\rm SAT})$, where $\\dot\\cup$ stands for disjoint union\n\\cite{Lutz:CvKL,AmbBen00}. Disjoint union can be implemented by adding\na unique prefix to each set and taking their union. To be more clear,\nlet $C = 0G \\;\\cup\\;10(G\\cap {\\rm SAT})\\;\\cup\\;11(G\\cup {\\rm SAT})$. It follows\nfrom closure properties of ${\\ensuremath{\\mathrm{NP}}}$ that $C \\in {\\ensuremath{\\mathrm{NP}}}$.\n\nTo see that $C$ is $2$-${\\mathrm{T}}$-complete, consider an oracle Turing machine\n$M$ that on input $x$ first queries $0x$ from $C$. If the answer is\npositive, i.e. $x \\in G$, $M$ queries $10x$ from $C$, and outputs the\nresult. Otherwise, $M$ queries $11x$ from $C$, and outputs the\nanswer. This Turing machine always makes two queries from $C$, runs in\npolynomial time, and $M^C(x) = {\\rm SAT}[x]$. This completes the proof that\n$C$ is also $2$-${\\mathrm{T}}$-completeness.  Since all queries from ${\\rm SAT}$ to $C$\nare length-increasing, it follows from Lemma \\ref{le:honest auto} that\n$C$ is $2$-${\\mathrm{T}}$-autoreducible.\n\nThe more involved part of the proof is to show that $C$ is not $2$-${\\mathrm{tt}}$-autoreducible. To get a\ncontradiction assume that $C$ is $2$-${\\mathrm{tt}}$-autoreducible. This means there exist polynomial-time \ncomputable functions $h$, $g_1$, and $g_2$ such that for every $x \\in \\{0, 1\\}^*$,\n", "itemtype": "equation", "pos": 13973, "prevtext": " where $G \\in {\\ensuremath{\\mathrm{NP}}}$ and\n${\\dot\\cup}$ is disjoint union. Then $C$ is 2-T-complete for ${\\ensuremath{\\mathrm{NP}}}$, and\nif $G$ is {$\\p$-generic\\xspace}, $C$ is not 2-tt-complete\n\\cite{Lutz:CvKL,AmbBen00}. There is a straightforward 3-T (also 5-tt)\nautoreduction of $C$ based on padding ${\\rm SAT}$.\\footnote{Given an\n  instance $x$ of $C$, pad $x$ to an instance $y$ such that\n  ${\\rm SAT}[x]={\\rm SAT}[y]$. We query $G[y]$ and then query either $G \\cap\n  {\\rm SAT}[y]$ if $G[y] = 1$ or $G \\cup {\\rm SAT}[y]$ if $G[y]=0$ to learn\n  ${\\rm SAT}[y]$. Finally, if our instance is $G[x]$ the answer is obtained\n  by querying $G\\cap{\\rm SAT}[x]$ if ${\\rm SAT}[y]=1$ or by querying\n  $G\\cup{\\rm SAT}[x]$ if ${\\rm SAT}[y]=0$. If our instance is $G\\cup{\\rm SAT}[x]$ or\n  $G\\cap{\\rm SAT}[x]$, we query $G[x]$ and combine that answer with\n  ${\\rm SAT}[y]$.}  However, since $C$ is 2-T-honest-complete, we\nindirectly obtain a 2-T (also 3-tt) autoreduction by first reducing\nthrough ${\\rm SAT}$ (Lemma \\ref{le:honest auto}). In Theorem \\ref{th:2T vs\n  2tt} we show $C$ is not 2tt-autoreducible.\n\n\nIt turns out this idea works in general. We show that many sets which\nseparate completeness notions also separate autoreducibility\nnotions. Ambos-Spies and Bentzien \\cite{AmbBen00} also separated both\n$k$-T-completeness and $(k+1)$-tt-completeness from both\n$k$-tt-completeness and $(k-1)$-T-completeness for every $k \\geq 3$\nunder the Genericity Hypothesis. We show that the same sets also\nseparate $k$-T-autoreducibility and $(k+1)$-tt-autoreducibility from\n$k$-tt-autoreducibility and $(k-1)$-T-autoreducibility (Theorems\n\\ref{th:k-tt} and \\ref{th:k-1-T}).  We also obtain that there is a\ntt-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is tt-autoreducible and not\nbtt-autoreducible (Theorem \\ref{th:btt vs tt}), again using a\nconstruction of Ambos-Spies and Bentzien.\n\nIn the aforementioned results, there is a gap -- we only separate\n$k$-tt-autoreducibility from $(k-2)$-T-autoreducibility (for $k \\geq\n3$), where we can hope for a separation from\n$(k-1)$-T-autoreducibility. The separation of $k$-tt from $(k-1)$-T is\nalso open for completeness under the Genericity Hypothesis (or the\nMeasure Hypothesis). To address this gap, we use a stronger hypothesis\non the class ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$.  Pavan and Selman \\cite{PavSel04}\nshowed that if ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a\n${\\mathrm{DTIME}}(2^{n^\\epsilon})$-bi-immune set, then 2-tt-completeness is\ndifferent from 1-tt-completeness for ${\\ensuremath{\\mathrm{NP}}}$. We show that if ${\\ensuremath{\\mathrm{NP}}} \\cap\n{\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then $k$-tt-completeness is different\nfrom $(k-1)$-T-completeness for all $k \\geq 3$ (Theorem \\ref{th:k-tt\n  vs (k-1)-T complete}). We then show these constructions also\nseparate autoreducibility: if there is a {$\\p$-generic\\xspace} set in\n${\\ensuremath{\\mathrm{NP}}}\\cap{\\co{{\\ensuremath{\\mathrm{NP}}}}}$, then for every $k \\geq 2$, there is a $k$-tt-complete\nset for ${\\ensuremath{\\mathrm{NP}}}$ that is $k$-tt autoreducible, but is not $(k-1)$-T\nautoreducible (Theorems \\ref{th:2tt vs 1tt} and \\ref{th:k-tt vs (k-1)-T autored}).\n\nThis paper is organized as follows. Preliminaries are in Section\n\\ref{sec:prelim}. The results using the Genericity Hypothesis are\npresented in Section \\ref{sec:genericity}. We use the stronger\nhypothesis on ${\\ensuremath{\\mathrm{NP}}}\\cap{\\co{{\\ensuremath{\\mathrm{NP}}}}}$ in Section \\ref{sec:stronger}. Section\n\\ref{sec:conclusion} concludes with some open problems. \n\n\n\n\\begin{table}[ht!]\n\\begin{center}\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n${\\cal C}$ & ${\\mathcal{S}}$ & ${\\cal R}$ & notes \\\\\n\\hline\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-T & $k$-tt & \nTheorem \\ref{th:2T vs 2tt} ($k=2$), Theorem\n\\ref{th:k-tt} ($k \\geq 3)$\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-T & $(k-1)$-T & \nTheorem \\ref{th:2T vs 2tt} ($k=2$), Theorem\n\\ref{th:k-1-T} ($k \\geq 3)$\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-tt & $(k-1)$-tt & Corollary \\ref{co:3tt vs 2tt} ($k=3$), Theorem \\ref{th:k-tt} ($k \\geq 4$)\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & $k$-tt & $(k-2)$-T & Corollary \\ref{co:3tt vs 1T} ($k=3$), Theorem \\ref{th:k-1-T} ($k \\geq 4$)\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}}$ & tt & btt & Theorem \\ref{th:btt vs tt}\\\\\n\\hline\n${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ & $k$-tt & $(k-1)$-T & Theorem \\ref{th:2tt vs 1tt}\n($k = 2$), Theorem \\ref{th:k-tt vs (k-1)-T autored} ($k \\geq 3$) \\\\\n\\hline\n\\end{tabular}\n\\caption{If ${\\cal C}$ contains a {$\\p$-generic\\xspace} set, then there is a ${\\mathcal{S}}$-complete\nset in ${\\ensuremath{\\mathrm{NP}}}$ that is ${\\mathcal{S}}$-autoreducible but not ${\\cal R}$-autoreducible.}\n\\label{table:results}\\end{center}\n\\end{table}\n\n\\section{Preliminaries}\\label{sec:prelim}\n\nWe use the standard enumeration of binary strings, i.e $s_0 = \\lambda,\ns_1 = 0, s_2 = 1,s_3 = 00,...$ as an order on binary strings. All\nlanguages in this paper are subsets of $\\{0,1\\}^*$ identified with\ntheir characteristic sequences. In other words, every language $A \\in\n\\{0,1\\}^*$ is identified with $\\chi_A = A[s_0]A[s_1]A[s_2]...$. If $X$\nis a set, equivalently a binary sequence, and $x \\in \\{0,1\\}^*$ then\n$X\\upharpoonright x$ is the initial segment of $X$ for all strings\nbefore $x$, i.e the subset of $X$ that contains every $y \\in X$ that\n$y < x$.\n\nAll reductions in this paper are polynomial-time reductions, therefore\nwe may not emphasize this every time we define a reduction. \nWe use standard notions of reducibilities \\cite{LaLySe75}.\n\nGiven $A$, $B$, and ${\\cal R} \\in\n\\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}}\\}$, $A$ is {\\em\n  polynomial-time ${\\cal R}$-honest reducible} to $B$ ($A\n\\le_{{\\cal R}\\text{-}h}^{\\mathrm{p}}$) if $A \\le_{\\cal R}^{\\mathrm{p}}$ and there exist a\nconstant $c$ such that for every input $x$, every query $q$ asked from\n$B$ has the property $|x|^{1/c} < |q|$. In particular, a reduction\n${\\cal R}$ is called {\\em length-increasing} if on every input the\nqueries asked from the oracle are all longer than the input.\n\nFor any reduction ${\\cal R} \\in \\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}}\\}$ a \nlanguage $A$ is ${\\cal R}$-{\\em autoreducible} if $A \\leq^{\\mathrm{p}}_{\\cal R}$ via a\nreduction where on every instance $x$, $x$ is not queried.\n\n\nThe following lemma states that any honest-complete set for ${\\ensuremath{\\mathrm{NP}}}$ is\nalso autoreducible under the same type of reduction. This follows\nbecause ${\\ensuremath{\\mathrm{NP}}}$ has a paddable, length-increasing complete set.\n\n\\begin{lemma}\n\\label{le:honest auto}\nLet ${\\cal R} \\in \\{{\\mathrm{m}},\\;{\\mathrm{T}},\\;{\\mathrm{tt}},\\;k\\text{-}{\\mathrm{T}},\\;k\\text{-}{\\mathrm{tt}},\\;{\\mathrm{btt}},\\ \\ldots\\}$\nbe a reducibility. Then every ${\\cal R}$-honest-complete set for ${\\ensuremath{\\mathrm{NP}}}$\n is ${\\cal R}$-autoreducible.\n\\end{lemma}\n\\begin{proof}\nLet $A \\in {\\ensuremath{\\mathrm{NP}}}$ be ${\\cal R}$-honest-complete. Then there is an ${\\cal R}$-honest\nreduction $M$ from ${\\rm SAT}$ to $A$. There exists $m \\geq 1$ such that every\nquery $q$ output by $M$ on an instance $x$ satisfies $|q| \\geq\n|x|^{\\tfrac{1}{m}}$.\n\nSince ${\\rm SAT}$ is ${\\ensuremath{\\mathrm{NP}}}$-complete via length-increasing many-one\nreductions, $A {\\leqp_\\mathrm{m}} {\\rm SAT}$ via a length-increasing reduction $g$.\nSince ${\\rm SAT}$ is paddable, there is a polynomial-time function $h$ such\nthat for any $y$, ${\\rm SAT}[h(y)] = {\\rm SAT}[y]$ and $|h(y)| > |y|^m$.\n\nTo obtain our ${\\cal R}$-autoreduction of $A$, we combine $g$, $h$, and $M$. \nOn instance $x$ of $A$, compute the instance $h(g(x))$ of ${\\rm SAT}$ and use $M$ to reduce $h(g(x))$ to\n$A$. Since $|h(g(x))| > |g(x)|^m > |x|^m$, every query $q$ of $M$\nhas $|q| > |h(g(x))|^{\\tfrac{1}{m}} > |x|$. Therefore all queries are different\nthan $x$ and this is an autoreduction.\n\\end{proof}\n\n\nMost of the results in this paper are based on a non-smallness\nhypothesis for ${\\ensuremath{\\mathrm{NP}}}$ called the {\\em Genericity Hypothesis} that ${\\ensuremath{\\mathrm{NP}}}$\ncontains a ${\\mathrm{p}}$-generic set \\cite{AmFlHu87,AmbBen00}. In order to define genericity first we need to define what a \n{\\em simple extension function} is.\n For any $k$, a simple $n^k$-extension function is a partial function from \n$\\{0,1\\}^*$ to $\\{0,1\\}$ that is computable in $O(n^k)$. Given a set $A$ and an extension function $f$ \nwe say that $f$ is {\\em dense along} $A$ if $f$ is defined on infinitely many initial segments of $A$. \nA set $A$ {\\em meets} a simple extension function $f$ at $x$ if $f (A \\upharpoonright x)$ is defined and\nequal to $A[x]$. We say $A$ meets $f$ if $A$ meets $f$ at some $x$.\nA set $G$ is called {\\em {$\\p$-generic\\xspace}} if it meets every simple $n^k$-extension function for any $k \\geq 1$ \\cite{AmbBen00}. \nA partial function $f:\\{0,1\\}^* \\rightarrow (\\{0,1\\}^* \\times\n\\{0,1\\})^*$ is called a {\\em k-bounded extension function} if whenever $f(X \\upharpoonright x)$ is defined, \n$f(X \\upharpoonright x) = (y_0,i_0)...(y_m,i_m)$ for some $m < k$, and $x \\le y_0 < y_1<...<y_m$, \nwhere $y_j$'s are strings and $i_j$'s are either $0$ or $1$. A set $A$ meets $f$ at $x$ if \n$f(A \\upharpoonright x)$ is defined, and $A$ agrees with $f$ on all  $y_j$'s, i.e. \nif $f(A \\upharpoonright x) = (y_0,i_0)...(y_m,i_m)$ then $A[y_j] = i_j$ for all $j \\le m$ \\cite{AmbBen00}.\n\nWe will use the following routine extension of a lemma in \\cite{AmbBen00}.\n\n\\begin{lemma}\\label{extension function revised}\nLet $l,c \\geq 1$ and let $f$ be an $l$-bounded partial extension function defined on initial segments \n$\\alpha = X \\upharpoonright 0^n$ of length $2^n$ $(n \\geq 1)$. Whenever $f(\\alpha)$ is defined we have\n", "index": 3, "text": "\n\\[ \nf(\\alpha) = (y_{\\alpha , 1} , i_{\\alpha , 1}),...,(y_{\\alpha , l_{\\alpha}} , i_{\\alpha , l{\\alpha}}),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"f(\\alpha)=(y_{\\alpha,1},i_{\\alpha,1}),...,(y_{\\alpha,l_{\\alpha}},i_{\\alpha,l{%&#10;\\alpha}}),\" display=\"block\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow><mi>\u03b1</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>i</mi><mrow><mi>\u03b1</mi><mo>,</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow><mi>\u03b1</mi><mo>,</mo><msub><mi>l</mi><mi>\u03b1</mi></msub></mrow></msub><mo>,</mo><msub><mi>i</mi><mrow><mi>\u03b1</mi><mo>,</mo><mrow><mi>l</mi><mo>\u2062</mo><mi>\u03b1</mi></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": " \nand moreover $g_i(x) \\neq x$ for $i = 1, 2$. Note that W.L.O.G. we can assume that $g_1(x) < g_2(x)$. \\\\\nFor $x = 0z$, $10z$, or $11z$ define the value of $x$ to be $z$, and let $x = 0z$ for some string $z$.\nWe have:\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere $l_{\\alpha} \\leq l$, $pos(\\alpha) = (y_{\\alpha , 1},...,y_{\\alpha,l_{\\alpha}})$ is computable in \n$2^{cn}$ steps and $i_{\\alpha , j}$ is computable in $2^{c|y_{\\alpha , j}|}$ steps. \nThen for every {$\\p$-generic\\xspace} set $G$, if $f$ is dense along $G$ then $G$ meets $f$.\n\\end{lemma}\n\n\\section{Autoreducibility Under the Genericity Hypothesis}\\label{sec:genericity}\n\n\nWe begin by showing the Genericity Hypothesis implies there is a\n$2$-${\\mathrm{T}}$-complete set that separates $2$-${\\mathrm{T}}$-autoreducibility from\n$2$-${\\mathrm{tt}}$-autoreducibility. The proof utilizes the construction of\n\\cite{Lutz:CvKL,AmbBen00} that of a set that separates\n$2$-${\\mathrm{T}}$-completeness from $2$-${\\mathrm{tt}}$-completeness.\n\n\\begin{theorem}\n\\label{th:2T vs 2tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a $2$-${\\mathrm{T}}$-complete set in ${\\ensuremath{\\mathrm{NP}}}$ that is $2$-${\\mathrm{T}}$-autoreducible, but not $2$-${\\mathrm{tt}}$-autoreducible.\n\\end{theorem}\n\n\\begin{proof}\nLet $G \\in {\\ensuremath{\\mathrm{NP}}}$ be {$\\p$-generic\\xspace} and define $C = G \\;\\dot\\cup \\;(G \\cap {\\rm SAT})\n\\;\\dot\\cup \\;(G \\cup {\\rm SAT})$, where $\\dot\\cup$ stands for disjoint union\n\\cite{Lutz:CvKL,AmbBen00}. Disjoint union can be implemented by adding\na unique prefix to each set and taking their union. To be more clear,\nlet $C = 0G \\;\\cup\\;10(G\\cap {\\rm SAT})\\;\\cup\\;11(G\\cup {\\rm SAT})$. It follows\nfrom closure properties of ${\\ensuremath{\\mathrm{NP}}}$ that $C \\in {\\ensuremath{\\mathrm{NP}}}$.\n\nTo see that $C$ is $2$-${\\mathrm{T}}$-complete, consider an oracle Turing machine\n$M$ that on input $x$ first queries $0x$ from $C$. If the answer is\npositive, i.e. $x \\in G$, $M$ queries $10x$ from $C$, and outputs the\nresult. Otherwise, $M$ queries $11x$ from $C$, and outputs the\nanswer. This Turing machine always makes two queries from $C$, runs in\npolynomial time, and $M^C(x) = {\\rm SAT}[x]$. This completes the proof that\n$C$ is also $2$-${\\mathrm{T}}$-completeness.  Since all queries from ${\\rm SAT}$ to $C$\nare length-increasing, it follows from Lemma \\ref{le:honest auto} that\n$C$ is $2$-${\\mathrm{T}}$-autoreducible.\n\nThe more involved part of the proof is to show that $C$ is not $2$-${\\mathrm{tt}}$-autoreducible. To get a\ncontradiction assume that $C$ is $2$-${\\mathrm{tt}}$-autoreducible. This means there exist polynomial-time \ncomputable functions $h$, $g_1$, and $g_2$ such that for every $x \\in \\{0, 1\\}^*$,\n", "index": 5, "text": "\n\\[ C[x] = h(x , C[g_1(x)], C[g_2(x)]) \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"C[x]=h(x,C[g_{1}(x)],C[g_{2}(x)])\" display=\"block\"><mrow><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nTo get a contradiction, we consider different cases depending on\nwhether some of  the queries have the same value as $x$ or not, and\nthe Boolean function $h(x,.,.)$. For some of these cases we show they\ncan happen only for finitely many $z$'s, and for the rest we show that\n${\\rm SAT}[z]$ can be decided in polynomial time.\nAs a result ${\\rm SAT}$ is decidable in polynomial time a.e., which contradicts the assumption that ${\\ensuremath{\\mathrm{NP}}}$\ncontains a {$\\p$-generic\\xspace} language.\n\n  \\begin{itemize}\n\\item The first case is when values of $g_1(x)$ and $g_2(x)$ are different from $z$, and also different from each other. Assume this happens for infinitely many $z$'s. We define an extension function $f$\nthat is dense along $G$, so $G$ has to meet it, but $f$ is defined in a way that if $G$ meets $f$, the autoreduction will be refuted. In order to define the value that $f$ forces to $G[z]$ on the right\nhand side of the reduction, we define a function $\\alpha$ that assigns $0$ or $1$ to queries of our autoreduction. The idea behind defining $\\alpha$ is that its value on queries $q_i$ is equal to $C[q_i]$\nafter we forced appropriate values into $G$, but computation of\n$\\alpha$ can be done in at most $2^{2n}$ steps (given access to the\npartial characteristic sequence of $G$).\\\\\n", "itemtype": "equation", "pos": 16824, "prevtext": " \nand moreover $g_i(x) \\neq x$ for $i = 1, 2$. Note that W.L.O.G. we can assume that $g_1(x) < g_2(x)$. \\\\\nFor $x = 0z$, $10z$, or $11z$ define the value of $x$ to be $z$, and let $x = 0z$ for some string $z$.\nWe have:\n", "index": 7, "text": "\n\\[ C[x]= G[z] = h(x , C[g_1(x)], C[g_2(x)]) \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"C[x]=G[z]=h(x,C[g_{1}(x)],C[g_{2}(x)])\" display=\"block\"><mrow><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>z</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nNote that in the first case, since $w < x$, the value of $C[w]$ is computable in $2^{2n}$ steps. Let \n$j = h(x , \\alpha (g_1(x)) , \\alpha (g_2(x)))$. Later, when defining the extension function, we force \nthe value of $C[x] = G[z]$ to be $1-j$, hence refuting the autoreduction.\\\\\nThe extension function $f$ is defined whenever this case happens, and it forces three values into $G$.\nIf $g_i(x) = 0v$ or $10v$ for some $v$, then $f(x)$ forces $G[v] = 0$. If $g_i(x) = 11v$ for some string $v$ then $f(x)$ forces $G[v] = 1$. Finally, $f(x)$ forces $G[z] = 1 - j$. Since we assumed that this case happens for infinitely many $x$'s, $f$ is dense along $G$. Therefore $G$ must meet $f$ at some string $x = 0z$. But by the very definition of $f$ this refutes the autoreduction. Hence this case can happen only for finitely many $x$'s.\n\n\\item In this case we consider the situation that $g_1(x)$ and $g_2(x)$ have the same value, say $y$, but $y \\neq z$. If $y < z$ we can compute $C[g_1(x)]$ and $C[g_2(x)]$ and force \n$G[z] = 1 - h(x, C[g_1(x)], C[g_2(x)]$, which refutes the autoreduction. Therefore this cannot happen i.o.\nNow based on the prefixes of $g_1(x)$ and $g_2(x)$ we consider the following cases:\n\\begin{enumerate}\n\\item If $g_1(x) = 0v$ and $g_2(x) = 10v$ we force $G[v] = 0$ and $G[x] = 1 - h(x, 0 , 0)$. This refutes the autoreduction, therefore this case can happen only finitely many times.\n\\item If $g_1(x) = 0v$ and $g_2(x) = 11v$ we force $G[v] = 1$ and $G[x] = 1 - h(x, 1 , 1)$. This also refutes the autoreduction, so it cannot happen i.o.\n\\end{enumerate}\nThe only possibility that remains in this case is $g_1(x) = 10v$ and $g_2(x) = 11v$. In this case the autoreduction equality can be stated as:\n", "itemtype": "equation", "pos": 18172, "prevtext": "\nTo get a contradiction, we consider different cases depending on\nwhether some of  the queries have the same value as $x$ or not, and\nthe Boolean function $h(x,.,.)$. For some of these cases we show they\ncan happen only for finitely many $z$'s, and for the rest we show that\n${\\rm SAT}[z]$ can be decided in polynomial time.\nAs a result ${\\rm SAT}$ is decidable in polynomial time a.e., which contradicts the assumption that ${\\ensuremath{\\mathrm{NP}}}$\ncontains a {$\\p$-generic\\xspace} language.\n\n  \\begin{itemize}\n\\item The first case is when values of $g_1(x)$ and $g_2(x)$ are different from $z$, and also different from each other. Assume this happens for infinitely many $z$'s. We define an extension function $f$\nthat is dense along $G$, so $G$ has to meet it, but $f$ is defined in a way that if $G$ meets $f$, the autoreduction will be refuted. In order to define the value that $f$ forces to $G[z]$ on the right\nhand side of the reduction, we define a function $\\alpha$ that assigns $0$ or $1$ to queries of our autoreduction. The idea behind defining $\\alpha$ is that its value on queries $q_i$ is equal to $C[q_i]$\nafter we forced appropriate values into $G$, but computation of\n$\\alpha$ can be done in at most $2^{2n}$ steps (given access to the\npartial characteristic sequence of $G$).\\\\\n", "index": 9, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      C[w] & \\textrm{ if $w < x$} \\\\\n      0 & \\textrm{ if $w > x$ and $w$ = 0y or 10y for some y} \\\\\n      1 & \\textrm{ if $w > x$ and $w$ = 11y for some y}\\\\  \n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}C[w]&amp;\\textrm{ if $w&lt;x$}\\\\&#10;0&amp;\\textrm{ if $w&gt;x$ and $w$ = 0y or 10y for some y}\\\\&#10;1&amp;\\textrm{ if $w&gt;x$ and $w$ = 11y for some y}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>w</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>w</mi><mo>&lt;</mo><mi>x</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>w</mi><mo>&gt;</mo><mi>x</mi></mrow><mtext>\u00a0and\u00a0</mtext><mi>w</mi><mtext>\u00a0= 0y or 10y for some y</mtext></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>w</mi><mo>&gt;</mo><mi>x</mi></mrow><mtext>\u00a0and\u00a0</mtext><mi>w</mi><mtext>\u00a0= 11y for some y</mtext></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nTo show that this also cannot happen i.o. we need to look into different cases of the Boolean function\n$h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item If $h(x , a, b) = 0$, or $1$, then force $G[z] = 1$ or $0$ respectively. Therefore this Boolean function can occur only finitely many times.\n\n\\item If $h(x, a, b) = a$, in other words $G[z] = G \\cap {\\rm SAT}[v]$, force $G[z] = 1$ and $G[v] = 0$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = \\neg a$, in other words $G[z] = \\neg G \\cap {\\rm SAT}[v]$, force $G[z] = 0$ and $G[v] = 0$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = b$, in other words $G[z] = G \\cup {\\rm SAT}[v]$, force $G[z] = 0$ and $G[v] = 1$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = \\neg b$, in other words $G[z] = \\neg G \\cup {\\rm SAT}[v]$, force $G[z] = 1$ and $G[v] = 1$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = a \\wedge b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\wedge (G \\cup {\\rm SAT}[v])$, but this is equal to $G \\cap {\\rm SAT}[v]$. Therefore this case is similar to the second case.\n\n\\item If $h(x, a, b) =\\neg a \\wedge b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\wedge (G \\cup {\\rm SAT}[v])$. Force $G[z] = 1$ and $G[v] = {\\rm SAT}[v]$. This contradicts the autoreduction equality. Therefore this case can happen only finitely many times.\n\n\\item If $h(x, a, b) = a \\wedge \\neg b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\wedge \\neg(G \\cup {\\rm SAT}[v])$, forcing $G[z] = 1$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\wedge \\neg b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\wedge \\neg (G \\cup {\\rm SAT}[v])$, but this is equal to $\\neg G \\cup {\\rm SAT}[v]$. Therefore this case is similar to the fifth case.\n\n\\item If $h(x, a, b) = a \\vee b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\vee (G \\cup {\\rm SAT}[v])$, but this is equal to $G \\cup {\\rm SAT}[v]$. Therefore this case is similar to the fourth case.\n\n\\item If $h(x, a, b) = \\neg a \\vee b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\vee (G \\cup {\\rm SAT}[v])$. In this case forcing $G[z] = 0$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = a \\vee \\neg b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\vee \\neg(G \\cup {\\rm SAT}[v])$. In this case forcing $G[z] = 0$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\vee \\neg b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\vee \\neg(G \\cup {\\rm SAT}[v])$, but this is equal to $\\neg(G \\cap {\\rm SAT}[v])$. Therefore this case is similar to the third case.\n\n\\item If $h(x, a, b) = a \\leftrightarrow b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\leftrightarrow (G \\cup {\\rm SAT}[v])$. In this case $G[z] = 0$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\leftrightarrow b$, in other words $G[z] = \\neg (G \\cap {\\rm SAT}[v]) \\leftrightarrow (G \\cup {\\rm SAT}[v])$. In this case $G[z] = 1$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\end{enumerate}\nWe exhaustively went through all possible Boolean functions for the case where both queries have the same value which is different from the value of $x$, and showed that each one of them can happen only for finitely many $x$'s. As a result this case can happen only for finitely many $x$'s.\n\n\\item This is the case when one of the queries, say $g_1(x)$ has the same value as $x$, but the other query has a different value. We only consider the case where $g_1(x) = 10z$. The other case, i.e. $g_1(x) = 11z$ can be done in a similar way. Again, we need to look at different possibilities for the Boolean function $h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item $h(x, a, b) = 0$ or $1$. Forcing $G[z] = 1$ or $0$ respectively refutes the autoreduction.\n\n\\item $h(x, a, b) = a$, i.e. $G[z] = G \\cap {\\rm SAT} [z]$. If this happens i.o with ${\\rm SAT}[z] = 0$ then we can refute the autoreduction by forcing $G[z] = 0$. Therefore in this case ${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) = \\neg a$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT} [z])$. By forcing $G[z] = 0$ we can refute the reduction. Therefore this case cannot happen i.o.\n\n\\item $h(x, a, b) = b$ or $\\neg b$. Similar to previous cases.\n\n\\item $h(x, a, b) = a \\wedge b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge C[g_2(x)]$. In this case ${\\rm SAT}[z]$ has to be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\wedge b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge C[g_2(x)]$. If $g_2(x) = 0y$ or $10y$ for some $y$, then forcing $G[z] = 1$ and $G[v] = 0$ refutes the reduction. If $g_2(x) = 11y$ then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge (G \\cup {\\rm SAT}[y]$. Here we force $G[z] = 0$ and $G[y] = 1$.\n\n\\item $h(x, a, b) = a \\wedge \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge \\neg C[g_2(x)]$. In this case \n${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\wedge \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some $y$, then forcing $G[z] = 1$ and $G[v] = 1$ refutes the reduction. If $g_2(x) = 10y$ then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg (G \\cap {\\rm SAT}[y])$. Here we force $G[z] = 0$ and $G[y] = 0$.\n\n\\item $h(x, a, b) = a \\vee b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some $y$, then forcing $G[z] = 0$ and $G[v] = 1$ refutes the reduction. If $g_2(x) = 10y$ then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\vee (G \\cap {\\rm SAT}[y]$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\vee b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee C[g_2(x)]$. In this case forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\vee \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg C[g_2(x)]$. If $g_2(x) = 0y$ or $10y$ for some $y$, then forcing $G[z] = 0$ and $G[v] = 0$ refutes the reduction. If $g_2(x) = 11y$ then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg(G \\cup {\\rm SAT}[y]$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\vee \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee \\neg C[g_2(x)]$. In this case forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\leftrightarrow b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow C[g_2(x)]$.\nIf $g_2(x) = 0y$ or $10y$ for some string $y$, then by forcing $G[z] = 0$ and $G[y] = 0$ we can refute the autoreduction. If $g_2(x) = 11y$, then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[y])$. This implies that ${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\leftrightarrow b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some string $y$, then by forcing $G[z] = 0$ and $G[y] = 1$ we can refute the autoreduction. If $g_2(x) = 10y$, then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[y])$. This implies that ${\\rm SAT}[z] = 1$ a.e.\n\n\\end{enumerate}\n\n\\item In this case we consider the situation where both queries $g_1(x)$ and $g_2(x)$ have the same value as $x$. In other words, in this case we have $g_1(x) = 10z$ and $g_2(x) = 11z$. Therefore we have:\n", "itemtype": "equation", "pos": 20099, "prevtext": "\nNote that in the first case, since $w < x$, the value of $C[w]$ is computable in $2^{2n}$ steps. Let \n$j = h(x , \\alpha (g_1(x)) , \\alpha (g_2(x)))$. Later, when defining the extension function, we force \nthe value of $C[x] = G[z]$ to be $1-j$, hence refuting the autoreduction.\\\\\nThe extension function $f$ is defined whenever this case happens, and it forces three values into $G$.\nIf $g_i(x) = 0v$ or $10v$ for some $v$, then $f(x)$ forces $G[v] = 0$. If $g_i(x) = 11v$ for some string $v$ then $f(x)$ forces $G[v] = 1$. Finally, $f(x)$ forces $G[z] = 1 - j$. Since we assumed that this case happens for infinitely many $x$'s, $f$ is dense along $G$. Therefore $G$ must meet $f$ at some string $x = 0z$. But by the very definition of $f$ this refutes the autoreduction. Hence this case can happen only for finitely many $x$'s.\n\n\\item In this case we consider the situation that $g_1(x)$ and $g_2(x)$ have the same value, say $y$, but $y \\neq z$. If $y < z$ we can compute $C[g_1(x)]$ and $C[g_2(x)]$ and force \n$G[z] = 1 - h(x, C[g_1(x)], C[g_2(x)]$, which refutes the autoreduction. Therefore this cannot happen i.o.\nNow based on the prefixes of $g_1(x)$ and $g_2(x)$ we consider the following cases:\n\\begin{enumerate}\n\\item If $g_1(x) = 0v$ and $g_2(x) = 10v$ we force $G[v] = 0$ and $G[x] = 1 - h(x, 0 , 0)$. This refutes the autoreduction, therefore this case can happen only finitely many times.\n\\item If $g_1(x) = 0v$ and $g_2(x) = 11v$ we force $G[v] = 1$ and $G[x] = 1 - h(x, 1 , 1)$. This also refutes the autoreduction, so it cannot happen i.o.\n\\end{enumerate}\nThe only possibility that remains in this case is $g_1(x) = 10v$ and $g_2(x) = 11v$. In this case the autoreduction equality can be stated as:\n", "index": 11, "text": "\n\\[G[z] = h(x , G \\cap {\\rm SAT}[v] , G \\cup {\\rm SAT}[v]) \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"G[z]=h(x,G\\cap{\\rm SAT}[v],G\\cup{\\rm SAT}[v])\" display=\"block\"><mrow><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>z</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>G</mi><mo>\u2229</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>,</mo><mrow><mi>G</mi><mo>\u222a</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nTo investigate this case we need to look at different Boolean functions for $h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item $h(x, a, b) = 0$, $1$, $a$, $\\neg a$, $b$, or $\\neg b$. Each of these cases is similar to one of the cases discussed previously.\n\n\\item $h(x, a, b) = a \\wedge b$, i.e. $G[z] = G \\cap {\\rm SAT}[z]$. This is also similar to one of the cases that we discussed previously.\n\n\\item $h(x, a, b) = \\neg a \\wedge b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge (G \\cup {\\rm SAT}[z])$. In this case ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = a \\wedge \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge \\neg(G \\cup {\\rm SAT}[z])$. Forcing $G[z] = 1$ refutes the reduction.\n\n\\item $h(x, a, b) = \\neg a \\wedge \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg(G \\cup {\\rm SAT}[z])$.\nThis is equal to $\\neg(G \\cup {\\rm SAT}[z])$. Therefore forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\vee b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee (G \\cup {\\rm SAT}[z])$, which is equal to \n$G \\cup {\\rm SAT}[z]$. Therefore ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\vee b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee (G \\cup {\\rm SAT}[z])$. In this case ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = a \\vee \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg(G \\cup {\\rm SAT}[z])$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\vee \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee \\neg (G \\cup {\\rm SAT}[z])$, which is equal to $\\neg (G \\cap {\\rm SAT}[z])$. Therefore forcing $G[z] = 0$ refutes the autoreduction.\n\n\\item $h(x, a, b) = a \\leftrightarrow b$, i.e.  $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[z])$.\nIn this case ${\\rm SAT}[z]$ has to be $1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\leftrightarrow b$, i.e.  $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[z])$. This implies that ${\\rm SAT}[z]$ has to be $0$ a.e.\n\\end{enumerate}\n\\end{itemize}\n\n\\end{proof}\n\n\\begin{corollary}\\label{co:3tt vs 2tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a\n$3$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is $3$-${\\mathrm{tt}}$-autoreducible, but not $2$-${\\mathrm{tt}}$-autoreducible. \n\\end{corollary}\n\\begin{proof}\nThis follows immediately from Theorem \\ref{th:2T vs 2tt} and the fact\nthat every 2-${\\mathrm{T}}$ reduction is a 3-${\\mathrm{tt}}$ reduction.\n\\end{proof}\n\n\\begin{corollary}\\label{co:3tt vs 1T}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a\n$3$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is $3$-${\\mathrm{tt}}$-autoreducible, but not $1$-${\\mathrm{T}}$-autoreducible. \n\\end{corollary}\n\nOur next theorem separates $(k+1)$-tt-autoreducibility from\n$k$-tt-autoreducibility and $k$-T-autoreducibility from\n$k$-tt-autoreducibility under the Genericity Hypothesis. The proof\nuses the construction of Ambos-Spies and Bentzien \\cite{AmbBen00} that\nseparates the corresponding completeness notions.\n\n\\begin{theorem}\\label{th:k-tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then for every $k \\geq 3$\nthere exists a set that is\n\\begin{itemize}\n\\item $(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $(k+1)$-${\\mathrm{tt}}$-autoreducible,\n\\item $k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $k$-${\\mathrm{T}}$-autoreducible, and\n\\item not $k$-${\\mathrm{tt}}$-autoreducible.\n\\end{itemize}\n\\end{theorem}\n\\begin{proof}\nLet $G \\in {\\ensuremath{\\mathrm{NP}}}$ be a {$\\p$-generic\\xspace} language, and $z_1,...,z_{(k+1)}$ be the first $k+1$ strings of length $k$.\nFor $m = 1,...,k-1$ define\n\n", "itemtype": "equation", "pos": 27413, "prevtext": "\nTo show that this also cannot happen i.o. we need to look into different cases of the Boolean function\n$h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item If $h(x , a, b) = 0$, or $1$, then force $G[z] = 1$ or $0$ respectively. Therefore this Boolean function can occur only finitely many times.\n\n\\item If $h(x, a, b) = a$, in other words $G[z] = G \\cap {\\rm SAT}[v]$, force $G[z] = 1$ and $G[v] = 0$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = \\neg a$, in other words $G[z] = \\neg G \\cap {\\rm SAT}[v]$, force $G[z] = 0$ and $G[v] = 0$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = b$, in other words $G[z] = G \\cup {\\rm SAT}[v]$, force $G[z] = 0$ and $G[v] = 1$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = \\neg b$, in other words $G[z] = \\neg G \\cup {\\rm SAT}[v]$, force $G[z] = 1$ and $G[v] = 1$. This refutes the autoreduction,  so this Boolean function cannot happen i.o.\n\n\\item If $h(x, a, b) = a \\wedge b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\wedge (G \\cup {\\rm SAT}[v])$, but this is equal to $G \\cap {\\rm SAT}[v]$. Therefore this case is similar to the second case.\n\n\\item If $h(x, a, b) =\\neg a \\wedge b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\wedge (G \\cup {\\rm SAT}[v])$. Force $G[z] = 1$ and $G[v] = {\\rm SAT}[v]$. This contradicts the autoreduction equality. Therefore this case can happen only finitely many times.\n\n\\item If $h(x, a, b) = a \\wedge \\neg b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\wedge \\neg(G \\cup {\\rm SAT}[v])$, forcing $G[z] = 1$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\wedge \\neg b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\wedge \\neg (G \\cup {\\rm SAT}[v])$, but this is equal to $\\neg G \\cup {\\rm SAT}[v]$. Therefore this case is similar to the fifth case.\n\n\\item If $h(x, a, b) = a \\vee b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\vee (G \\cup {\\rm SAT}[v])$, but this is equal to $G \\cup {\\rm SAT}[v]$. Therefore this case is similar to the fourth case.\n\n\\item If $h(x, a, b) = \\neg a \\vee b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\vee (G \\cup {\\rm SAT}[v])$. In this case forcing $G[z] = 0$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = a \\vee \\neg b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\vee \\neg(G \\cup {\\rm SAT}[v])$. In this case forcing $G[z] = 0$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\vee \\neg b$, in other words $G[z] = \\neg(G \\cap {\\rm SAT}[v]) \\vee \\neg(G \\cup {\\rm SAT}[v])$, but this is equal to $\\neg(G \\cap {\\rm SAT}[v])$. Therefore this case is similar to the third case.\n\n\\item If $h(x, a, b) = a \\leftrightarrow b$, in other words $G[z] = (G \\cap {\\rm SAT}[v]) \\leftrightarrow (G \\cup {\\rm SAT}[v])$. In this case $G[z] = 0$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\item If $h(x, a, b) = \\neg a \\leftrightarrow b$, in other words $G[z] = \\neg (G \\cap {\\rm SAT}[v]) \\leftrightarrow (G \\cup {\\rm SAT}[v])$. In this case $G[z] = 1$ and $G[v] = {\\rm SAT}[v]$ refutes the autoreduction.\n\n\\end{enumerate}\nWe exhaustively went through all possible Boolean functions for the case where both queries have the same value which is different from the value of $x$, and showed that each one of them can happen only for finitely many $x$'s. As a result this case can happen only for finitely many $x$'s.\n\n\\item This is the case when one of the queries, say $g_1(x)$ has the same value as $x$, but the other query has a different value. We only consider the case where $g_1(x) = 10z$. The other case, i.e. $g_1(x) = 11z$ can be done in a similar way. Again, we need to look at different possibilities for the Boolean function $h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item $h(x, a, b) = 0$ or $1$. Forcing $G[z] = 1$ or $0$ respectively refutes the autoreduction.\n\n\\item $h(x, a, b) = a$, i.e. $G[z] = G \\cap {\\rm SAT} [z]$. If this happens i.o with ${\\rm SAT}[z] = 0$ then we can refute the autoreduction by forcing $G[z] = 0$. Therefore in this case ${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) = \\neg a$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT} [z])$. By forcing $G[z] = 0$ we can refute the reduction. Therefore this case cannot happen i.o.\n\n\\item $h(x, a, b) = b$ or $\\neg b$. Similar to previous cases.\n\n\\item $h(x, a, b) = a \\wedge b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge C[g_2(x)]$. In this case ${\\rm SAT}[z]$ has to be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\wedge b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge C[g_2(x)]$. If $g_2(x) = 0y$ or $10y$ for some $y$, then forcing $G[z] = 1$ and $G[v] = 0$ refutes the reduction. If $g_2(x) = 11y$ then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge (G \\cup {\\rm SAT}[y]$. Here we force $G[z] = 0$ and $G[y] = 1$.\n\n\\item $h(x, a, b) = a \\wedge \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge \\neg C[g_2(x)]$. In this case \n${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\wedge \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some $y$, then forcing $G[z] = 1$ and $G[v] = 1$ refutes the reduction. If $g_2(x) = 10y$ then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg (G \\cap {\\rm SAT}[y])$. Here we force $G[z] = 0$ and $G[y] = 0$.\n\n\\item $h(x, a, b) = a \\vee b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some $y$, then forcing $G[z] = 0$ and $G[v] = 1$ refutes the reduction. If $g_2(x) = 10y$ then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\vee (G \\cap {\\rm SAT}[y]$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\vee b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee C[g_2(x)]$. In this case forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\vee \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg C[g_2(x)]$. If $g_2(x) = 0y$ or $10y$ for some $y$, then forcing $G[z] = 0$ and $G[v] = 0$ refutes the reduction. If $g_2(x) = 11y$ then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg(G \\cup {\\rm SAT}[y]$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) =\\neg a \\vee \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee \\neg C[g_2(x)]$. In this case forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\leftrightarrow b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow C[g_2(x)]$.\nIf $g_2(x) = 0y$ or $10y$ for some string $y$, then by forcing $G[z] = 0$ and $G[y] = 0$ we can refute the autoreduction. If $g_2(x) = 11y$, then we have $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[y])$. This implies that ${\\rm SAT}[z] = 1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\leftrightarrow b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow C[g_2(x)]$. If $g_2(x) = 0y$ or $11y$ for some string $y$, then by forcing $G[z] = 0$ and $G[y] = 1$ we can refute the autoreduction. If $g_2(x) = 10y$, then we have $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[y])$. This implies that ${\\rm SAT}[z] = 1$ a.e.\n\n\\end{enumerate}\n\n\\item In this case we consider the situation where both queries $g_1(x)$ and $g_2(x)$ have the same value as $x$. In other words, in this case we have $g_1(x) = 10z$ and $g_2(x) = 11z$. Therefore we have:\n", "index": 13, "text": "\n\\[G[z] = h(x, G \\cap {\\rm SAT}[z], G \\cup {\\rm SAT}[z]) \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"G[z]=h(x,G\\cap{\\rm SAT}[z],G\\cup{\\rm SAT}[z])\" display=\"block\"><mrow><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>z</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>G</mi><mo>\u2229</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>z</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>,</mo><mrow><mi>G</mi><mo>\u222a</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>z</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nHere are some properties of the sets defined above:\n\\begin{itemize}\n\n\\item For every $x$, $x \\in \\hat{G} \\Leftrightarrow \\exists 1 \\le i \\le k-1.\\; xz_i \\in G$. \n\\item $A$ contains strings in $G$ that end with $z_1,...$, or $z_{(k-1)}$, i.e. $A(xz_i) = G(xz_i)$ for every $x$ and $1 \\le i \\le k-1$.\n\\item $xz_k \\in A $ if and only if $x \\in {\\rm SAT} \\wedge (\\exists 1 \\le i \\le k-1. xz_i \\in G)$.\n\\item $xz_{(k+1)} \\in A $ if and only if $x \\in {\\rm SAT} \\vee (\\exists 1 \\le i \\le k-1. xz_i \\in G)$.\n\\item $xz_j \\notin A$ for $j > k+1$.\n\\end{itemize}\nIt is easy to show that ${\\rm SAT} \\le_{(k+1)-{\\mathrm{tt}}}^{\\mathrm{p}} A$. On input $x$, make\nqueries $xz_1,...,xz_{(k+1)}$ from $A$.  If at least one of the\nanswers to the first $k-1$ queries is positive, then ${\\rm SAT}[x]$ is\nequal to the $k$th query, i.e. ${\\rm SAT}[x] = A[xz_k]$. Otherwise\n${\\rm SAT}[x]$ is equal to $A[xz_{(k+1)}]$. As a result, $A$ is\n$(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. If the queries are allowed to be\ndependent, we can choose between $xz_k$ and $xz_{(k+1)}$ based on the\nanswers to the first $(k-1)$ queries. Therefore $A$ is also\n$k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. Since all these queries are honest, in\nfact length-increasing, it follows from Lemma \\ref{le:honest auto} that $A$\nis both $(k+1)$-${\\mathrm{tt}}$-autoreducible and $k$-${\\mathrm{T}}$-autoreducible.\n\nTo get a contradiction, assume $A$ is $k$-${\\mathrm{tt}}$-autoreducible via $h,\ng_1, ...,g_k$. In other words, assume that for every $x$:\n\n", "itemtype": "equation", "pos": 31210, "prevtext": "\nTo investigate this case we need to look at different Boolean functions for $h(x,.,.)$.\n\n\\begin{enumerate}\n\n\\item $h(x, a, b) = 0$, $1$, $a$, $\\neg a$, $b$, or $\\neg b$. Each of these cases is similar to one of the cases discussed previously.\n\n\\item $h(x, a, b) = a \\wedge b$, i.e. $G[z] = G \\cap {\\rm SAT}[z]$. This is also similar to one of the cases that we discussed previously.\n\n\\item $h(x, a, b) = \\neg a \\wedge b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge (G \\cup {\\rm SAT}[z])$. In this case ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = a \\wedge \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\wedge \\neg(G \\cup {\\rm SAT}[z])$. Forcing $G[z] = 1$ refutes the reduction.\n\n\\item $h(x, a, b) = \\neg a \\wedge \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\wedge \\neg(G \\cup {\\rm SAT}[z])$.\nThis is equal to $\\neg(G \\cup {\\rm SAT}[z])$. Therefore forcing $G[z] = 0$ refutes the reduction.\n\n\\item $h(x, a, b) = a \\vee b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee (G \\cup {\\rm SAT}[z])$, which is equal to \n$G \\cup {\\rm SAT}[z]$. Therefore ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\vee b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee (G \\cup {\\rm SAT}[z])$. In this case ${\\rm SAT}[z]$ must be $0$ a.e.\n\n\\item $h(x, a, b) = a \\vee \\neg b$, i.e. $G[z] = (G \\cap {\\rm SAT}[z]) \\vee \\neg(G \\cup {\\rm SAT}[z])$. This implies that ${\\rm SAT}[z]$ must be $1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\vee \\neg b$, i.e. $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\vee \\neg (G \\cup {\\rm SAT}[z])$, which is equal to $\\neg (G \\cap {\\rm SAT}[z])$. Therefore forcing $G[z] = 0$ refutes the autoreduction.\n\n\\item $h(x, a, b) = a \\leftrightarrow b$, i.e.  $G[z] = (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[z])$.\nIn this case ${\\rm SAT}[z]$ has to be $1$ a.e.\n\n\\item $h(x, a, b) = \\neg a \\leftrightarrow b$, i.e.  $G[z] = \\neg (G \\cap {\\rm SAT}[z]) \\leftrightarrow (G \\cup {\\rm SAT}[z])$. This implies that ${\\rm SAT}[z]$ has to be $0$ a.e.\n\\end{enumerate}\n\\end{itemize}\n\n\\end{proof}\n\n\\begin{corollary}\\label{co:3tt vs 2tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a\n$3$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is $3$-${\\mathrm{tt}}$-autoreducible, but not $2$-${\\mathrm{tt}}$-autoreducible. \n\\end{corollary}\n\\begin{proof}\nThis follows immediately from Theorem \\ref{th:2T vs 2tt} and the fact\nthat every 2-${\\mathrm{T}}$ reduction is a 3-${\\mathrm{tt}}$ reduction.\n\\end{proof}\n\n\\begin{corollary}\\label{co:3tt vs 1T}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then there exists a\n$3$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is $3$-${\\mathrm{tt}}$-autoreducible, but not $1$-${\\mathrm{T}}$-autoreducible. \n\\end{corollary}\n\nOur next theorem separates $(k+1)$-tt-autoreducibility from\n$k$-tt-autoreducibility and $k$-T-autoreducibility from\n$k$-tt-autoreducibility under the Genericity Hypothesis. The proof\nuses the construction of Ambos-Spies and Bentzien \\cite{AmbBen00} that\nseparates the corresponding completeness notions.\n\n\\begin{theorem}\\label{th:k-tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then for every $k \\geq 3$\nthere exists a set that is\n\\begin{itemize}\n\\item $(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $(k+1)$-${\\mathrm{tt}}$-autoreducible,\n\\item $k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $k$-${\\mathrm{T}}$-autoreducible, and\n\\item not $k$-${\\mathrm{tt}}$-autoreducible.\n\\end{itemize}\n\\end{theorem}\n\\begin{proof}\nLet $G \\in {\\ensuremath{\\mathrm{NP}}}$ be a {$\\p$-generic\\xspace} language, and $z_1,...,z_{(k+1)}$ be the first $k+1$ strings of length $k$.\nFor $m = 1,...,k-1$ define\n\n", "index": 15, "text": "\\begin{align}\n  &  \\hat{G_m}  = \\{x \\;|\\; xz_m \\in G \\} \\\\\n  & \\hat{G}  = \\bigcup\\limits_{m=1}^{k-1} \\hat{G_m} \\\\\n  &  A  = \\bigcup\\limits_{m=1}^{k-1}\\{xz_m \\;|\\; x \\in \\hat{G_m} \\} \n          \\bigcup \\{xz_k \\;|\\; x \\in \\hat{G} \\cap {\\rm SAT} \\}\n          \\bigcup \\{xz_{k+1}\\;|\\; x \\in \\hat{G} \\cup {\\rm SAT}\\}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\hat{G_{m}}=\\{x\\;|\\;xz_{m}\\in G\\}\" display=\"inline\"><mrow><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo stretchy=\"false\">^</mo></mover><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mpadded width=\"+2.8pt\"><mi>x</mi></mpadded><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mrow><mi>x</mi><mo>\u2062</mo><msub><mi>z</mi><mi>m</mi></msub></mrow><mo>\u2208</mo><mi>G</mi></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\hat{G}=\\bigcup\\limits_{m=1}^{k-1}\\hat{G_{m}}\" display=\"inline\"><mrow><mover accent=\"true\"><mi>G</mi><mo stretchy=\"false\">^</mo></mover><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo stretchy=\"false\">^</mo></mover></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle A=\\bigcup\\limits_{m=1}^{k-1}\\{xz_{m}\\;|\\;x\\in\\hat{G_{m}}\\}%&#10;\\bigcup\\{xz_{k}\\;|\\;x\\in\\hat{G}\\cap{\\rm SAT}\\}\\bigcup\\{xz_{k+1}\\;|\\;x\\in\\hat{G%&#10;}\\cup{\\rm SAT}\\}\" display=\"inline\"><mrow><mi>A</mi><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>m</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo stretchy=\"false\">^</mo></mover></mrow><mo stretchy=\"false\">}</mo></mrow><mo>\u2062</mo><mstyle displaystyle=\"true\"><mrow><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>k</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mover accent=\"true\"><mi>G</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2229</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow><mo>\u2062</mo><mrow><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mover accent=\"true\"><mi>G</mi><mo stretchy=\"false\">^</mo></mover><mo>\u222a</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></mrow></mstyle></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nand $\\forall 1 \\le i \\le k.\\; g_i(x) \\neq x$.\nIn particular, we are interested in the case where $x = 0^nz_1 = 0^{n+k}$, and we have:\n\n", "itemtype": "equation", "pos": 33078, "prevtext": "\nHere are some properties of the sets defined above:\n\\begin{itemize}\n\n\\item For every $x$, $x \\in \\hat{G} \\Leftrightarrow \\exists 1 \\le i \\le k-1.\\; xz_i \\in G$. \n\\item $A$ contains strings in $G$ that end with $z_1,...$, or $z_{(k-1)}$, i.e. $A(xz_i) = G(xz_i)$ for every $x$ and $1 \\le i \\le k-1$.\n\\item $xz_k \\in A $ if and only if $x \\in {\\rm SAT} \\wedge (\\exists 1 \\le i \\le k-1. xz_i \\in G)$.\n\\item $xz_{(k+1)} \\in A $ if and only if $x \\in {\\rm SAT} \\vee (\\exists 1 \\le i \\le k-1. xz_i \\in G)$.\n\\item $xz_j \\notin A$ for $j > k+1$.\n\\end{itemize}\nIt is easy to show that ${\\rm SAT} \\le_{(k+1)-{\\mathrm{tt}}}^{\\mathrm{p}} A$. On input $x$, make\nqueries $xz_1,...,xz_{(k+1)}$ from $A$.  If at least one of the\nanswers to the first $k-1$ queries is positive, then ${\\rm SAT}[x]$ is\nequal to the $k$th query, i.e. ${\\rm SAT}[x] = A[xz_k]$. Otherwise\n${\\rm SAT}[x]$ is equal to $A[xz_{(k+1)}]$. As a result, $A$ is\n$(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. If the queries are allowed to be\ndependent, we can choose between $xz_k$ and $xz_{(k+1)}$ based on the\nanswers to the first $(k-1)$ queries. Therefore $A$ is also\n$k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. Since all these queries are honest, in\nfact length-increasing, it follows from Lemma \\ref{le:honest auto} that $A$\nis both $(k+1)$-${\\mathrm{tt}}$-autoreducible and $k$-${\\mathrm{T}}$-autoreducible.\n\nTo get a contradiction, assume $A$ is $k$-${\\mathrm{tt}}$-autoreducible via $h,\ng_1, ...,g_k$. In other words, assume that for every $x$:\n\n", "index": 17, "text": "\\begin{equation}\nA[x] = h(x, A[g_1(x)],...,A[g_k(x)])\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"A[x]=h(x,A[g_{1}(x)],...,A[g_{k}(x)])\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nand all $g_i(0^{n+k})$'s are different from $0^{n+k}$ itself.\n\nIn the following we will define a bounded extension function $f$ that satisfies the condition in Lemma \n\\ref{extension function revised} such that if $G$ meets $f$ at $0^{n+k}$ then \\eqref{auto-eq} will fail.\nWe use the {$\\p$-genericity\\xspace} of $G$ to show that $G$ has to meet $f$ at $0^{n+k}$ for some $n$ which completes the proof. In other words, we define a bounded extension function $f$ such that \ngiven $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n) = (y_0,i_0)...(y_m,i_m)$ and if\n\n", "itemtype": "equation", "pos": 33281, "prevtext": "\nand $\\forall 1 \\le i \\le k.\\; g_i(x) \\neq x$.\nIn particular, we are interested in the case where $x = 0^nz_1 = 0^{n+k}$, and we have:\n\n", "index": 19, "text": "\\begin{equation}\\label{auto-eq}\nA(0^{n+k}) = h(0^{n+k}, A[g_1(0^{n+k})],...,A[g_k(0^{n+k})])\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"A(0^{n+k})=h(0^{n+k},A[g_{1}(0^{n+k})],...,A[g_{k}(0^{n+k})])\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nthen\n\n", "itemtype": "equation", "pos": 33957, "prevtext": "\nand all $g_i(0^{n+k})$'s are different from $0^{n+k}$ itself.\n\nIn the following we will define a bounded extension function $f$ that satisfies the condition in Lemma \n\\ref{extension function revised} such that if $G$ meets $f$ at $0^{n+k}$ then \\eqref{auto-eq} will fail.\nWe use the {$\\p$-genericity\\xspace} of $G$ to show that $G$ has to meet $f$ at $0^{n+k}$ for some $n$ which completes the proof. In other words, we define a bounded extension function $f$ such that \ngiven $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n) = (y_0,i_0)...(y_m,i_m)$ and if\n\n", "index": 21, "text": "\\begin{equation}\\label{meeting conditions}\n\\begin{aligned}\n& G \\upharpoonright 0^n = X \\upharpoonright 0^n \\;\\;\\textrm{and}\\\\\n&\\forall 0 \\le j \\le m.\\;G(y_j)=i_j\n\\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle G\\upharpoonright 0^{n}=X\\upharpoonright 0^{n}\\;\\;\\textrm{and}\" display=\"inline\"><mrow><mi>G</mi><mo>\u21be</mo><msup><mn>0</mn><mi>n</mi></msup><mo>=</mo><mi>X</mi><mo>\u21be</mo><mrow><mpadded width=\"+5.6pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo>\u2062</mo><mtext>and</mtext></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6Xa.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\forall 0\\leq j\\leq m.\\;G(y_{j})=i_{j}\" display=\"inline\"><mrow><mrow><mrow><mo>\u2200</mo><mn>0</mn></mrow><mo>\u2264</mo><mi>j</mi><mo>\u2264</mo><mi>m</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>G</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mi>i</mi><mi>j</mi></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nMoreover, $m$ is bounded by some constant that does not depend on $n$ and $X \\upharpoonright 0^n$.\nNote that we want $f$ to satisfy the conditions in Lemma \\ref{extension function revised}, so \n$y_j$'s and $i_j$'s must be computable in $O(2^n)$ and $O(2^{|y_j|})$ steps respectively. After defining such $f$, by Lemma \\ref{extension function revised} $G$ must meet $f$ at $0^{n+k}$ for some $n$. This means\n\\eqref{meeting conditions} must hold. As a result, \\eqref{refuting auto-red} must happen for some $n$, \nwhich is a contradiction.\\\\\n$f$ can force values of $G[y_i]$'s for a constant number of $y_i$'s. Because of the dependency between $G$ and $A$ we can force values for $A[w]$, where $w$ is a query, by using $f$ to force values in $G$. This is done based on the strings that have been queried, and their indices as follows. \n\\begin{itemize}\n\\item If $w = vz_i$ for some $1 \\le i \\le k-1$ then $A[w] = G[w]$. Therefore we can force $A[w]$ to $0$ or $1$ by forcing the same value for $G[w]$.\n\\item If $w = vz_k$ then $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l=1}^{k-1}{G[vz_l]})$, so by forcing all\n$G[vz_l]$'s to $0$ we can make $A[w] = 0$.\n\\item If $w = vz_{k+1}$ then $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l=1}^{k-1}{G[vz_l]})$. In this case by forcing one of the $G[vz_l]$'s to $1$ we can make $A[w] = 1$.\n\\end{itemize}\nWe will use these facts to force the value of $A$ on queries on input $0^{n+k}$ on the left hand side of\n\\eqref{auto-eq}, and then force a value for $A[0^{n+k}]$ such that \\eqref{auto-eq} fails. The first problem that we encounter is the case where we have both $vz_k$ and $vz_{k+1}$ among our queries. If this happens\nfor some $v$ then the strategy described above does not work. To force $A[vz_k]$ and $A[vz_{k+1}]$ to \n$0$ and $1$ respectively, we need to compute ${\\rm SAT}[v]$. If ${\\rm SAT}[v] = 0$ then $A[vz_k] = 0$, \nand $A[vz_{k+1}]$ can be forced to $1$ by forcing $G[vz_l] = 1$ for some $1 \\le l \\le k-1$. \nOn the other hand, if ${\\rm SAT}[v] = 1$ then $A[vz_{k+1}] = 1$, and forcing all $G[vz_l]$'s to $0$ makes \n$A[vz_k] = 0$. This process depends on the value of ${\\rm SAT}[v]$, and $v$ can be much longer that $0^{n+k}$. \nBecause of the time bounds in Lemma \\ref{extension function revised} the value forced for $A[0^{n+k}]$ cannot depend on ${\\rm SAT}[v]$. But note that we have $k$ queries, and two of them are $vz_k$ and $vz_{k+1}$. Therefore at least one of the strings $vz_1,...,vz_{k-1}$ is not among the queries. We use this \nstring as $vz_l$, and make $G[vz_l] = 1$ when ${\\rm SAT}[v] = 0$.\n\nNow we define an auxiliary function $\\alpha$ from the set of queries, called ${\\mathrm{QUERY}}$, to $0$ or $1$. The idea is that \n$\\alpha$ computes the value of $A$ on queries without computing $G[v]$, given that $G$ meets the extension function. $\\alpha$ is defined in two parts based on the length of the queries.\nFor queries $w = vz_p$ that are shorter than $0^{n+k}$, i.e. $|w| < n+k$, we define:\n", "itemtype": "equation", "pos": 34153, "prevtext": "\nthen\n\n", "index": 23, "text": "\\begin{equation}\\label{refuting auto-red}\nA(0^{n+k}) \\neq h(0^{n+k}, A[g_1(0^{n+k})],...,A[g_k(0^{n+k})])\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"A(0^{n+k})\\neq h(0^{n+k},A[g_{1}(0^{n+k})],...,A[g_{k}(0^{n+k})])\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2260</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>g</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nThis means that if $X \\upharpoonright 0^{n+k} = G \\upharpoonright 0^{n+k}$ then $\\alpha (w) = A(w)$ for\nevery query $w = vz_p$ with $|w| < n+k$.\\\\\nOn the other hand, for queries $w = vz_p$ that $|w| \\geq n+k$, $\\alpha$ is defined as:\n  \n", "itemtype": "equation", "pos": 37216, "prevtext": "\nMoreover, $m$ is bounded by some constant that does not depend on $n$ and $X \\upharpoonright 0^n$.\nNote that we want $f$ to satisfy the conditions in Lemma \\ref{extension function revised}, so \n$y_j$'s and $i_j$'s must be computable in $O(2^n)$ and $O(2^{|y_j|})$ steps respectively. After defining such $f$, by Lemma \\ref{extension function revised} $G$ must meet $f$ at $0^{n+k}$ for some $n$. This means\n\\eqref{meeting conditions} must hold. As a result, \\eqref{refuting auto-red} must happen for some $n$, \nwhich is a contradiction.\\\\\n$f$ can force values of $G[y_i]$'s for a constant number of $y_i$'s. Because of the dependency between $G$ and $A$ we can force values for $A[w]$, where $w$ is a query, by using $f$ to force values in $G$. This is done based on the strings that have been queried, and their indices as follows. \n\\begin{itemize}\n\\item If $w = vz_i$ for some $1 \\le i \\le k-1$ then $A[w] = G[w]$. Therefore we can force $A[w]$ to $0$ or $1$ by forcing the same value for $G[w]$.\n\\item If $w = vz_k$ then $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l=1}^{k-1}{G[vz_l]})$, so by forcing all\n$G[vz_l]$'s to $0$ we can make $A[w] = 0$.\n\\item If $w = vz_{k+1}$ then $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l=1}^{k-1}{G[vz_l]})$. In this case by forcing one of the $G[vz_l]$'s to $1$ we can make $A[w] = 1$.\n\\end{itemize}\nWe will use these facts to force the value of $A$ on queries on input $0^{n+k}$ on the left hand side of\n\\eqref{auto-eq}, and then force a value for $A[0^{n+k}]$ such that \\eqref{auto-eq} fails. The first problem that we encounter is the case where we have both $vz_k$ and $vz_{k+1}$ among our queries. If this happens\nfor some $v$ then the strategy described above does not work. To force $A[vz_k]$ and $A[vz_{k+1}]$ to \n$0$ and $1$ respectively, we need to compute ${\\rm SAT}[v]$. If ${\\rm SAT}[v] = 0$ then $A[vz_k] = 0$, \nand $A[vz_{k+1}]$ can be forced to $1$ by forcing $G[vz_l] = 1$ for some $1 \\le l \\le k-1$. \nOn the other hand, if ${\\rm SAT}[v] = 1$ then $A[vz_{k+1}] = 1$, and forcing all $G[vz_l]$'s to $0$ makes \n$A[vz_k] = 0$. This process depends on the value of ${\\rm SAT}[v]$, and $v$ can be much longer that $0^{n+k}$. \nBecause of the time bounds in Lemma \\ref{extension function revised} the value forced for $A[0^{n+k}]$ cannot depend on ${\\rm SAT}[v]$. But note that we have $k$ queries, and two of them are $vz_k$ and $vz_{k+1}$. Therefore at least one of the strings $vz_1,...,vz_{k-1}$ is not among the queries. We use this \nstring as $vz_l$, and make $G[vz_l] = 1$ when ${\\rm SAT}[v] = 0$.\n\nNow we define an auxiliary function $\\alpha$ from the set of queries, called ${\\mathrm{QUERY}}$, to $0$ or $1$. The idea is that \n$\\alpha$ computes the value of $A$ on queries without computing $G[v]$, given that $G$ meets the extension function. $\\alpha$ is defined in two parts based on the length of the queries.\nFor queries $w = vz_p$ that are shorter than $0^{n+k}$, i.e. $|w| < n+k$, we define:\n", "index": 25, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      X[w] & \\textrm{if $1 \\le p \\le k-1$} \\\\\n      1 & \\textrm{if $p = k \\;\\wedge \\; v \\in {\\rm SAT} \\;\\wedge \\; \\exists 1 \\le l \\le k-1. \\; vz_l \\in X$} \\\\\n      1 & \\textrm{if $p= k+1 \\;\\wedge \\;( v \\in {\\rm SAT} \\;\\vee \\; \\exists 1 \\le l \\le k-1. \\; vz_l \\in X)$} \\\\  \n      0 & \\textrm{otherwise}\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}X[w]&amp;\\textrm{if $1\\leq p\\leq k-1$}\\\\&#10;1&amp;\\textrm{if $p=k\\;\\wedge\\;v\\in{\\rm SAT}\\;\\wedge\\;\\exists 1\\leq l\\leq k-1.\\;vz%&#10;_{l}\\in X$}\\\\&#10;1&amp;\\textrm{if $p=k+1\\;\\wedge\\;(v\\in{\\rm SAT}\\;\\vee\\;\\exists 1\\leq l\\leq k-1.\\;%&#10;vz_{l}\\in X)$}\\\\&#10;0&amp;\\textrm{otherwise}\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>w</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mn>1</mn><mo>\u2264</mo><mi>p</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mrow><mi>p</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><mi>k</mi></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mi>v</mi></mrow><mo>\u2208</mo><mrow><mpadded width=\"+2.8pt\"><mi>SAT</mi></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mrow><mo>\u2203</mo><mn>1</mn></mrow></mrow><mo>\u2264</mo><mi>l</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo>\u2208</mo><mi>X</mi></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>p</mi><mo>=</mo><mrow><mrow><mi>k</mi><mo>+</mo><mpadded width=\"+2.8pt\"><mn>1</mn></mpadded></mrow><mo rspace=\"5.3pt\">\u2227</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>v</mi><mo>\u2208</mo><mrow><mpadded width=\"+2.8pt\"><mi>SAT</mi></mpadded><mo rspace=\"5.3pt\">\u2228</mo><mrow><mo>\u2203</mo><mn>1</mn></mrow></mrow><mo>\u2264</mo><mi>l</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo>\u2208</mo><mi>X</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nFor this part of $\\alpha$, our definition of the extension function, which is provided below, guarantees that $\\alpha(w) = A[w]$ if \\eqref{meeting conditions} holds. Note that the first case in the definition above implies that $k$ must be greater than or equal to $3$, and that is the reason this proof does not work for separating \n$3$-${\\mathrm{tt}}$-autoreducibility from $2$-${\\mathrm{tt}}$-autoreducibility.\n\nNow we are ready to define the extension function $f$. For any string $v$ which is the value for \nsome query, i.e. $\\exists 1 \\le p \\le k+1. vz_p \\in {\\mathrm{QUERY}}$, we define pairs of strings and $0$ or $1$'s. These pairs will be part of our extension function. Fix some value $v$, and let $r$ be the smallest index \nthat $vz_r \\notin {\\mathrm{QUERY}}$, or $k-1$ if such index does not exist, i.e.\n\n", "itemtype": "equation", "pos": 37804, "prevtext": "\nThis means that if $X \\upharpoonright 0^{n+k} = G \\upharpoonright 0^{n+k}$ then $\\alpha (w) = A(w)$ for\nevery query $w = vz_p$ with $|w| < n+k$.\\\\\nOn the other hand, for queries $w = vz_p$ that $|w| \\geq n+k$, $\\alpha$ is defined as:\n  \n", "index": 27, "text": "\\[ \\alpha(w) = \\begin{cases} \n      1 & \\textrm{ if $v = 0^n \\;\\wedge  p = 2$} \\\\\n      {\\rm SAT}[v] & \\textrm{ if $v = 0^n \\;\\wedge \\; p = k$} \\\\\n      1 &  \\textrm{if $v = 0^n \\;\\wedge \\; p = k+1$} \\\\  \n      1 & \\textrm{if $ v \\neq 0^n \\wedge p = k+1$}\\\\\n      1 & \\textrm{if $v \\neq 0^n \\wedge p = k-1 \\wedge \n      \\forall l \\in \\{1,...,k-1,k+1\\}.\\; vz_l \\in {\\mathrm{QUERY}}$}\\\\\n      0 & \\textrm{otherwise}\\\\\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}1&amp;\\textrm{ if $v=0^{n}\\;\\wedge p=2$}\\\\&#10;{\\rm SAT}[v]&amp;\\textrm{ if $v=0^{n}\\;\\wedge\\;p=k$}\\\\&#10;1&amp;\\textrm{if $v=0^{n}\\;\\wedge\\;p=k+1$}\\\\&#10;1&amp;\\textrm{if $v\\neq 0^{n}\\wedge p=k+1$}\\\\&#10;1&amp;\\textrm{if $v\\neq 0^{n}\\wedge p=k-1\\wedge\\forall l\\in\\{1,...,k-1,k+1\\}.\\;vz_%&#10;{l}\\in{\\mathrm{QUERY}}$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo>\u2227</mo><mi>p</mi></mrow><mo>=</mo><mn>2</mn></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mi>p</mi></mrow><mo>=</mo><mi>k</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mi>p</mi></mrow><mo>=</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>v</mi><mo>\u2260</mo><mrow><msup><mn>0</mn><mi>n</mi></msup><mo>\u2227</mo><mi>p</mi></mrow><mo>=</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mrow><mi>v</mi><mo>\u2260</mo><mrow><msup><mn>0</mn><mi>n</mi></msup><mo>\u2227</mo><mi>p</mi></mrow><mo>=</mo><mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo>\u2227</mo><mrow><mo>\u2200</mo><mi>l</mi></mrow></mrow><mo>\u2208</mo><mrow><mo stretchy=\"false\">{</mo><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo>\u2208</mo><mi>QUERY</mi></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nWe will have one of the following cases:\n\\begin{enumerate}\n\\item If $v = 0^n$ then pairs $(vz_2,1),(vz_3,0),...,(vz_{k-1},0)$ must be added to $f$.\n\\item If $v \\neq 0^n$ and $vz_{k+1} \\notin {\\mathrm{QUERY}}$ then add pairs \n$(vz_1,0)$,...,$(vz_{k-1},0)$ to $f$.\n\\item If $v \\neq 0^n$, $vz_{k+1} \\in {\\mathrm{QUERY}}$ and $vz_k \\notin {\\mathrm{QUERY}}$ add pairs $(vz_i,j)$ for \n$1 \\le i \\le k-1$ where $j = 0$ for all $i$'s except $i = r$ where $j = 1$.\n\\item If $v \\neq 0^n$, $vz_{k+1} \\in {\\mathrm{QUERY}}$ and $vz_k \\in {\\mathrm{QUERY}}$ add pairs \n$(vz_i,j)$ for $1 \\le i \\le k-1$ where $j = 0$ for all $i$'s except $i = r$ where $j = 1 - {\\rm SAT}[v]$.\n\\end{enumerate}\nThis process must be repeated for every $v$ that is the value of some query. Finally, we add \n $(0^{n+k}, 1 - h(0^{n+k}, \\alpha(g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$ to $f$ in order to\n refute the autoreduction.\nIt is worth mentioning that in the fourth case above, since both $vz_k$ and $vz_{k+1}$ are among queries,\nat least one of the strings $vz_1$,...,$vz_{k-1}$is not queried. Therefore by definition of $r$, \n$vz_r \\notin {\\mathrm{QUERY}}$. This is important, as we describe in more detail later, because we forced\n$G[vz_r] = 1 - {\\rm SAT}[v]$, and if $vz_r \\in {\\mathrm{QUERY}}$ then $\\alpha(vz_r) = G[vz_r] = 1 - {\\rm SAT}[v]$. \nBut $\\alpha$ must be compuatable in $O(2^n)$ steps, which is not possible if $v$ is much longer\nthan $0^{n+k}$.\n\nNow that the extension function is defined completely, we need to show that it has the desired properties.\nFirst, we will show that if $G$ meets $f$ at $0^{n+k}$, i.e. \\eqref{meeting conditions} holds, then \n$\\alpha$ and $A$ agree on every query $w$ with $|w| \\geq n+k$, i.e. $\\alpha(w) = A[w]$.\\\\\nLet $w = vz_p$, and $|w| \\geq n+k$.\n\\begin{itemize}\n\\item If $v = 0^n$ and $p = 2$ then $\\alpha(w) = 1$ and $A[w] = G[w] = 1$.\n\\item If $v = 0^n$ and $p = k$ then $\\alpha(w) = {\\rm SAT}[v]$ and \n$A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]})$. Since $G[vz_2] = 1$ is forced, $A[w] = {\\rm SAT}[v]$.\n\\item If $v = 0^n$ and $p = k+1$ then $\\alpha(w) = 1$ and $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$ since $G[vz_2] = 1$.\n\\item If $v = 0^n$ and $p \\neq 2,k,k+1$ then $\\alpha(w) = A[w] = 0$.\n\\item If $v \\neq 0^n$ and $ p < k-1$ then $\\alpha(w) = 0$. Since $p < k-1$, and $vz_p \\in {\\mathrm{QUERY}}$, \nby definition of $r$, $r \\neq p$. Therefore $G[vz_p]$ is forced to $0$ by $f$. As a result,\n $A[w] = A[vz_p] = G[vz_p] = 0 = \\alpha (w)$.\n\\item If $v \\neq 0^n$, $p = k-1$, and $vz_1$,...,$vz_{k-1}$,$vz_{k+1} \\in {\\mathrm{QUERY}}$ then\n$\\alpha (w) = 1$. In this case $r = k-1$, so it follows from definition of $f$ that $G[vz_{k-1}] = 1$.\nAs a result, $A[w] = A[vz_{k-1}] = G[vz_{k-1}] = 1 = \\alpha(w)$.\n\\item If $v \\neq 0^n$, $p = k-1$, and at least one of the strings $vz_1$,...,$vz_{k-1}$,$vz_{k+1}$ \nis not queried then we consider two cases. If $vz_{k+1} \\notin {\\mathrm{QUERY}}$ then $f$ forces $G[vz_{k-1}]$ to\n$0$. On the other hand, if $vz_{k=1} \\in {\\mathrm{QUERY}}$, then at least one of $vz_1$,...,$vz_{k-1}$ \nis not a query. Therefore by definition of $r$, $r \\neq k-1$. This implies that $G[vz_{k-1}] = 0$ by $f$.\n\\item If $v \\neq 0^n$, $p = k$ then $\\alpha (w) = 0$. Consider two cases. If $vz_{k+1} \\notin {\\mathrm{QUERY}}$\nthen $G[vz_i] = 0$ for every $1 \\le i \\le k-1$. \nTherefore $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 0$.\nOtherwise, when $vz_{k+1} \\in {\\mathrm{QUERY}}$, since we know that $vz_k$ also belongs to ${\\mathrm{QUERY}}$, $f$ forces $G[vz_r] = 1 - {\\rm SAT}[v]$, and $G[vz_i] = 0$ for every other $1 \\le i \\le k-1$. \nTherefore $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = {\\rm SAT}[v] \\wedge (1-{\\rm SAT}[v]) = 0$.\n\\item If $v \\neq 0^n$, $p = k + 1$ then $\\alpha (w) = 1$. If $vz_k \\notin {\\mathrm{QUERY}}$\nthen $G[vz_r] = 1$ by $f$. Therefore $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$.\nOn the other hand, if $vz_k \\in {\\mathrm{QUERY}}$ then $f$ forces $G[vz_r] = 1 - {\\rm SAT}[v]$. As a result, \n$A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$.\n\\end{itemize}\nThis shows that in any case, $\\alpha (w) = A[w]$ for $w \\in {\\mathrm{QUERY}}$, given that \\eqref{meeting conditions}\nholds, i.e $G$ meets $f$. By combining this with \\eqref{auto-eq} we have\n\n", "itemtype": "equation", "pos": 39055, "prevtext": "\nFor this part of $\\alpha$, our definition of the extension function, which is provided below, guarantees that $\\alpha(w) = A[w]$ if \\eqref{meeting conditions} holds. Note that the first case in the definition above implies that $k$ must be greater than or equal to $3$, and that is the reason this proof does not work for separating \n$3$-${\\mathrm{tt}}$-autoreducibility from $2$-${\\mathrm{tt}}$-autoreducibility.\n\nNow we are ready to define the extension function $f$. For any string $v$ which is the value for \nsome query, i.e. $\\exists 1 \\le p \\le k+1. vz_p \\in {\\mathrm{QUERY}}$, we define pairs of strings and $0$ or $1$'s. These pairs will be part of our extension function. Fix some value $v$, and let $r$ be the smallest index \nthat $vz_r \\notin {\\mathrm{QUERY}}$, or $k-1$ if such index does not exist, i.e.\n\n", "index": 29, "text": "\\begin{equation}\nr = min \\{s \\geq 1 | vz_s \\notin {\\mathrm{QUERY}} \\vee s = k-1 \\}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"r=min\\{s\\geq 1|vz_{s}\\notin{\\mathrm{QUERY}}\\vee s=k-1\\}\" display=\"block\"><mrow><mi>r</mi><mo>=</mo><mrow><mi>m</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>s</mi><mo>\u2265</mo><mn>1</mn></mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>s</mi></msub></mrow><mo>\u2209</mo><mrow><mi>QUERY</mi><mo>\u2228</mo><mi>s</mi></mrow><mo>=</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nOn the other hand, we forced \n$A[0^{n+k}] = 1 - h(0^{n+k},\\alpha (g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$\nwhich gives us the desired contradiction.\n\nThe last part of our proof is to show that $f$ satisfies the\nconditions in Lemma \\ref{extension function revised}.  For every value $v$\nwhich is the value of some query we added $k-1$ pairs to $f$, and\nthere are $k$ queries, which means at most $k$ different\nvalues. Therefore, the number of pairs in $f$ is bounded by $k^2$,\ni.e. $f$ is a bounded extension function.\n\nIf $f(X \\upharpoonright\n0^{n+k}) = (y_0,j_0),...,(y_m,j_m)$ then $y_i$'s are computable in\npolynomial ime in $n$, and $j_i$'s are computable in $O(2^{|y_i|})$\nbecause the most time consuming situation is when we need to compute\n${\\rm SAT}[v]$ which is doable in $O(2^n)$. For the condition forced to the\nleft hand side of \\eqref{auto-eq}, i.e $G[0^{n+k}] = 1 -\nh(0^{n+k},\\alpha (g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$, note that\n$\\alpha (w)$ can be computed in at most $O(2^n)$ steps for $w \\in\n{\\mathrm{QUERY}}$, and $h$ is computable in polynomial time.\n\\end{proof}\n\n\n\n\nNext we separate $(k+1)$-${\\mathrm{tt}}$-autoreducibility and\n$k$-${\\mathrm{T}}$-autoreducibility from $(k-1)$-${\\mathrm{T}}$-autoreducibility. The\nproof uses the same construction from the previous theorem, which\nAmbos-Spies and Bentzien \\cite{AmbBen00} showed separates these\ncompleteness notions.\n\\begin{theorem}\\label{th:k-1-T}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then for every $k \\geq 3$\nthere exists a set that is\n\\begin{itemize}\n\\item $(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $(k+1)$-${\\mathrm{tt}}$-autoreducible,\n\\item $k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $k$-${\\mathrm{T}}$-autoreducible, and\n\\item not $(k-1)$-${\\mathrm{T}}$-autoreducible.\n\\end{itemize}\n\\end{theorem}\n\\begin{proof}\nWe use the same sets $G$ and $A$ as defined in the proof of Theorem\n\\ref{th:k-tt}. We proved that $A$ is $(k+1)$-${\\mathrm{tt}}$-complete,\n$k$-${\\mathrm{T}}$-complete, $(k+1)$-${\\mathrm{tt}}$-autoreducible, and\n$k$-${\\mathrm{T}}$-autoreducible.  What remains is to show that it is not\n$(k-1)$-${\\mathrm{T}}$-autoreducible. The proof is very similar to what we did in\nthe previous theorem, so we will not go through every detail\nhere. Assume $A$ is $k$-${\\mathrm{T}}$-autoreducible via an oracle Turing machine\n$M$. In other words,\n\n", "itemtype": "equation", "pos": 43474, "prevtext": "\nWe will have one of the following cases:\n\\begin{enumerate}\n\\item If $v = 0^n$ then pairs $(vz_2,1),(vz_3,0),...,(vz_{k-1},0)$ must be added to $f$.\n\\item If $v \\neq 0^n$ and $vz_{k+1} \\notin {\\mathrm{QUERY}}$ then add pairs \n$(vz_1,0)$,...,$(vz_{k-1},0)$ to $f$.\n\\item If $v \\neq 0^n$, $vz_{k+1} \\in {\\mathrm{QUERY}}$ and $vz_k \\notin {\\mathrm{QUERY}}$ add pairs $(vz_i,j)$ for \n$1 \\le i \\le k-1$ where $j = 0$ for all $i$'s except $i = r$ where $j = 1$.\n\\item If $v \\neq 0^n$, $vz_{k+1} \\in {\\mathrm{QUERY}}$ and $vz_k \\in {\\mathrm{QUERY}}$ add pairs \n$(vz_i,j)$ for $1 \\le i \\le k-1$ where $j = 0$ for all $i$'s except $i = r$ where $j = 1 - {\\rm SAT}[v]$.\n\\end{enumerate}\nThis process must be repeated for every $v$ that is the value of some query. Finally, we add \n $(0^{n+k}, 1 - h(0^{n+k}, \\alpha(g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$ to $f$ in order to\n refute the autoreduction.\nIt is worth mentioning that in the fourth case above, since both $vz_k$ and $vz_{k+1}$ are among queries,\nat least one of the strings $vz_1$,...,$vz_{k-1}$is not queried. Therefore by definition of $r$, \n$vz_r \\notin {\\mathrm{QUERY}}$. This is important, as we describe in more detail later, because we forced\n$G[vz_r] = 1 - {\\rm SAT}[v]$, and if $vz_r \\in {\\mathrm{QUERY}}$ then $\\alpha(vz_r) = G[vz_r] = 1 - {\\rm SAT}[v]$. \nBut $\\alpha$ must be compuatable in $O(2^n)$ steps, which is not possible if $v$ is much longer\nthan $0^{n+k}$.\n\nNow that the extension function is defined completely, we need to show that it has the desired properties.\nFirst, we will show that if $G$ meets $f$ at $0^{n+k}$, i.e. \\eqref{meeting conditions} holds, then \n$\\alpha$ and $A$ agree on every query $w$ with $|w| \\geq n+k$, i.e. $\\alpha(w) = A[w]$.\\\\\nLet $w = vz_p$, and $|w| \\geq n+k$.\n\\begin{itemize}\n\\item If $v = 0^n$ and $p = 2$ then $\\alpha(w) = 1$ and $A[w] = G[w] = 1$.\n\\item If $v = 0^n$ and $p = k$ then $\\alpha(w) = {\\rm SAT}[v]$ and \n$A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]})$. Since $G[vz_2] = 1$ is forced, $A[w] = {\\rm SAT}[v]$.\n\\item If $v = 0^n$ and $p = k+1$ then $\\alpha(w) = 1$ and $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$ since $G[vz_2] = 1$.\n\\item If $v = 0^n$ and $p \\neq 2,k,k+1$ then $\\alpha(w) = A[w] = 0$.\n\\item If $v \\neq 0^n$ and $ p < k-1$ then $\\alpha(w) = 0$. Since $p < k-1$, and $vz_p \\in {\\mathrm{QUERY}}$, \nby definition of $r$, $r \\neq p$. Therefore $G[vz_p]$ is forced to $0$ by $f$. As a result,\n $A[w] = A[vz_p] = G[vz_p] = 0 = \\alpha (w)$.\n\\item If $v \\neq 0^n$, $p = k-1$, and $vz_1$,...,$vz_{k-1}$,$vz_{k+1} \\in {\\mathrm{QUERY}}$ then\n$\\alpha (w) = 1$. In this case $r = k-1$, so it follows from definition of $f$ that $G[vz_{k-1}] = 1$.\nAs a result, $A[w] = A[vz_{k-1}] = G[vz_{k-1}] = 1 = \\alpha(w)$.\n\\item If $v \\neq 0^n$, $p = k-1$, and at least one of the strings $vz_1$,...,$vz_{k-1}$,$vz_{k+1}$ \nis not queried then we consider two cases. If $vz_{k+1} \\notin {\\mathrm{QUERY}}$ then $f$ forces $G[vz_{k-1}]$ to\n$0$. On the other hand, if $vz_{k=1} \\in {\\mathrm{QUERY}}$, then at least one of $vz_1$,...,$vz_{k-1}$ \nis not a query. Therefore by definition of $r$, $r \\neq k-1$. This implies that $G[vz_{k-1}] = 0$ by $f$.\n\\item If $v \\neq 0^n$, $p = k$ then $\\alpha (w) = 0$. Consider two cases. If $vz_{k+1} \\notin {\\mathrm{QUERY}}$\nthen $G[vz_i] = 0$ for every $1 \\le i \\le k-1$. \nTherefore $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 0$.\nOtherwise, when $vz_{k+1} \\in {\\mathrm{QUERY}}$, since we know that $vz_k$ also belongs to ${\\mathrm{QUERY}}$, $f$ forces $G[vz_r] = 1 - {\\rm SAT}[v]$, and $G[vz_i] = 0$ for every other $1 \\le i \\le k-1$. \nTherefore $A[w] = {\\rm SAT}[v] \\wedge (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = {\\rm SAT}[v] \\wedge (1-{\\rm SAT}[v]) = 0$.\n\\item If $v \\neq 0^n$, $p = k + 1$ then $\\alpha (w) = 1$. If $vz_k \\notin {\\mathrm{QUERY}}$\nthen $G[vz_r] = 1$ by $f$. Therefore $A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$.\nOn the other hand, if $vz_k \\in {\\mathrm{QUERY}}$ then $f$ forces $G[vz_r] = 1 - {\\rm SAT}[v]$. As a result, \n$A[w] = {\\rm SAT}[v] \\vee (\\bigvee_{l = 1}^{k-1}{G[vz_l]}) = 1$.\n\\end{itemize}\nThis shows that in any case, $\\alpha (w) = A[w]$ for $w \\in {\\mathrm{QUERY}}$, given that \\eqref{meeting conditions}\nholds, i.e $G$ meets $f$. By combining this with \\eqref{auto-eq} we have\n\n", "index": 31, "text": "\\begin{equation*}\n\\begin{aligned}\nA(0^{n+k}) = & h(0^{n+k}),A(g_1(0^{n+k})),...,A(g_k(0^{n+k}))) \\\\\n=& h(0^{n+k},\\alpha (g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))\n\\end{aligned}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle A(0^{n+k})=\" display=\"inline\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10X.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle h(0^{n+k}),A(g_{1}(0^{n+k})),...,A(g_{k}(0^{n+k})))\" display=\"inline\"><mrow><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>g</mi><mi>k</mi></msub><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10Xa.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\" display=\"inline\"><mo>=</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10Xa.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle h(0^{n+k},\\alpha(g_{1}(0^{n+k})),...,\\alpha(g_{k}(0^{n+k})))\" display=\"inline\"><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo>,</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>g</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nand we assume that on input $x$, $M$ will not query $x$ itself. By using {$\\p$-genericity\\xspace} of $G$ we will show that there exists some $n$ such that \\ref{T-auto-red-eq} fails for $x = 0^{n+k}$. In other words,\n\n", "itemtype": "equation", "pos": 46079, "prevtext": "\nOn the other hand, we forced \n$A[0^{n+k}] = 1 - h(0^{n+k},\\alpha (g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$\nwhich gives us the desired contradiction.\n\nThe last part of our proof is to show that $f$ satisfies the\nconditions in Lemma \\ref{extension function revised}.  For every value $v$\nwhich is the value of some query we added $k-1$ pairs to $f$, and\nthere are $k$ queries, which means at most $k$ different\nvalues. Therefore, the number of pairs in $f$ is bounded by $k^2$,\ni.e. $f$ is a bounded extension function.\n\nIf $f(X \\upharpoonright\n0^{n+k}) = (y_0,j_0),...,(y_m,j_m)$ then $y_i$'s are computable in\npolynomial ime in $n$, and $j_i$'s are computable in $O(2^{|y_i|})$\nbecause the most time consuming situation is when we need to compute\n${\\rm SAT}[v]$ which is doable in $O(2^n)$. For the condition forced to the\nleft hand side of \\eqref{auto-eq}, i.e $G[0^{n+k}] = 1 -\nh(0^{n+k},\\alpha (g_1(0^{n+k})),...,\\alpha(g_k(0^{n+k})))$, note that\n$\\alpha (w)$ can be computed in at most $O(2^n)$ steps for $w \\in\n{\\mathrm{QUERY}}$, and $h$ is computable in polynomial time.\n\\end{proof}\n\n\n\n\nNext we separate $(k+1)$-${\\mathrm{tt}}$-autoreducibility and\n$k$-${\\mathrm{T}}$-autoreducibility from $(k-1)$-${\\mathrm{T}}$-autoreducibility. The\nproof uses the same construction from the previous theorem, which\nAmbos-Spies and Bentzien \\cite{AmbBen00} showed separates these\ncompleteness notions.\n\\begin{theorem}\\label{th:k-1-T}\nIf ${\\ensuremath{\\mathrm{NP}}}$ contains a {$\\p$-generic\\xspace} language, then for every $k \\geq 3$\nthere exists a set that is\n\\begin{itemize}\n\\item $(k+1)$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $(k+1)$-${\\mathrm{tt}}$-autoreducible,\n\\item $k$-${\\mathrm{T}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$ and $k$-${\\mathrm{T}}$-autoreducible, and\n\\item not $(k-1)$-${\\mathrm{T}}$-autoreducible.\n\\end{itemize}\n\\end{theorem}\n\\begin{proof}\nWe use the same sets $G$ and $A$ as defined in the proof of Theorem\n\\ref{th:k-tt}. We proved that $A$ is $(k+1)$-${\\mathrm{tt}}$-complete,\n$k$-${\\mathrm{T}}$-complete, $(k+1)$-${\\mathrm{tt}}$-autoreducible, and\n$k$-${\\mathrm{T}}$-autoreducible.  What remains is to show that it is not\n$(k-1)$-${\\mathrm{T}}$-autoreducible. The proof is very similar to what we did in\nthe previous theorem, so we will not go through every detail\nhere. Assume $A$ is $k$-${\\mathrm{T}}$-autoreducible via an oracle Turing machine\n$M$. In other words,\n\n", "index": 33, "text": "\\begin{equation}\\label{T-auto-red-eq}\n\\forall x.\\;A[x] = M^A(x)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\forall x.\\;A[x]=M^{A}(x)\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mi>x</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>M</mi><mi>A</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nSimilar to what we did in the previous theorem, we define a bounded extension function $f$\nsuch that given $n$ and an initial segment $X\\upharpoonright 0^n$, $f$ returns a set of\npairs $(y_i,j_i)$ for $0 \\le i \\le m$. $y_i$'s are the positions, and must be computable \nin $O(2^n)$ steps, and $j_i$'s are the values that $f$ forces to $y_i$'s. Each $j_i$ must be \ncomputable in $O(2^{|y_i|})$. Then we will show that if $G$ meets $f$ at $0^{n+k}$, i.e. if \n\\ref{meeting conditions} holds, then \\ref{T-auto-red-eq} fails for $x = 0^{n+k}$. We will define a function $\\alpha$ that under the right conditions simulates $A$ on queries. We use $\\alpha$ \ninstead of $A$, as the oracle, in the computation of $M$ on input $0^{n+k}$. Similar to the previous theorem, $\\alpha$ must be computable in $O(2^n)$ steps. Since in a Turing reduction each query may depend on the answers to the previous queries, we cannot know which queries will be asked in the computation \nof $M^A(0^{n+k})$ in $O(2^n)$ steps. Therefore we define $\\alpha$ on every string rather than \njust on the set of queries.\n\nLet $w = vz_p$ be some string. If $|w| < n+k$, then $\\alpha$ is defined as:\n", "itemtype": "equation", "pos": 46374, "prevtext": "\nand we assume that on input $x$, $M$ will not query $x$ itself. By using {$\\p$-genericity\\xspace} of $G$ we will show that there exists some $n$ such that \\ref{T-auto-red-eq} fails for $x = 0^{n+k}$. In other words,\n\n", "index": 35, "text": "\\begin{equation}\n\\exists n.\\;A[0^{n+k}] = M^A(0^{n+k})\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\exists n.\\;A[0^{n+k}]=M^{A}(0^{n+k})\" display=\"block\"><mrow><mrow><mo>\u2203</mo><mi>n</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>M</mi><mi>A</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nand if $|w| \\geq n+k$ then:\n", "itemtype": "equation", "pos": 47601, "prevtext": "\nSimilar to what we did in the previous theorem, we define a bounded extension function $f$\nsuch that given $n$ and an initial segment $X\\upharpoonright 0^n$, $f$ returns a set of\npairs $(y_i,j_i)$ for $0 \\le i \\le m$. $y_i$'s are the positions, and must be computable \nin $O(2^n)$ steps, and $j_i$'s are the values that $f$ forces to $y_i$'s. Each $j_i$ must be \ncomputable in $O(2^{|y_i|})$. Then we will show that if $G$ meets $f$ at $0^{n+k}$, i.e. if \n\\ref{meeting conditions} holds, then \\ref{T-auto-red-eq} fails for $x = 0^{n+k}$. We will define a function $\\alpha$ that under the right conditions simulates $A$ on queries. We use $\\alpha$ \ninstead of $A$, as the oracle, in the computation of $M$ on input $0^{n+k}$. Similar to the previous theorem, $\\alpha$ must be computable in $O(2^n)$ steps. Since in a Turing reduction each query may depend on the answers to the previous queries, we cannot know which queries will be asked in the computation \nof $M^A(0^{n+k})$ in $O(2^n)$ steps. Therefore we define $\\alpha$ on every string rather than \njust on the set of queries.\n\nLet $w = vz_p$ be some string. If $|w| < n+k$, then $\\alpha$ is defined as:\n", "index": 37, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      X[w] & \\textrm{ if $1 \\le p \\le k-1$} \\\\\n      1 & \\textrm{ if $p = k \\;\\wedge \\; v \\in {\\rm SAT} \\;\\wedge \\; \\exists 1 \\le l \\le k-1. \\; vz_l \\in X$} \\\\\n      1 & \\textrm{if $p= k+1 \\;\\wedge \\;( v \\in {\\rm SAT} \\;\\vee \\; \\exists 1 \\le l \\le k-1. \\; vz_l \\in X)$} \\\\  \n      0 & \\textrm{otherwise}\\\\\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}X[w]&amp;\\textrm{ if $1\\leq p\\leq k-1$}\\\\&#10;1&amp;\\textrm{ if $p=k\\;\\wedge\\;v\\in{\\rm SAT}\\;\\wedge\\;\\exists 1\\leq l\\leq k-1.\\;%&#10;vz_{l}\\in X$}\\\\&#10;1&amp;\\textrm{if $p=k+1\\;\\wedge\\;(v\\in{\\rm SAT}\\;\\vee\\;\\exists 1\\leq l\\leq k-1.\\;%&#10;vz_{l}\\in X)$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>w</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mn>1</mn><mo>\u2264</mo><mi>p</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mrow><mi>p</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><mi>k</mi></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mi>v</mi></mrow><mo>\u2208</mo><mrow><mpadded width=\"+2.8pt\"><mi>SAT</mi></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mrow><mo>\u2203</mo><mn>1</mn></mrow></mrow><mo>\u2264</mo><mi>l</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo>\u2208</mo><mi>X</mi></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>p</mi><mo>=</mo><mrow><mrow><mi>k</mi><mo>+</mo><mpadded width=\"+2.8pt\"><mn>1</mn></mpadded></mrow><mo rspace=\"5.3pt\">\u2227</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>v</mi><mo>\u2208</mo><mrow><mpadded width=\"+2.8pt\"><mi>SAT</mi></mpadded><mo rspace=\"5.3pt\">\u2228</mo><mrow><mo>\u2203</mo><mn>1</mn></mrow></mrow><mo>\u2264</mo><mi>l</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo>\u2208</mo><mi>X</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nNow we run the same oracle Turing machine $M$, but we use $\\alpha$ as the oracle instead of $A$. Let\n${\\mathrm{QUERY}}$ be the set of queries asked in this process. $f$ will be defined in a similar fashion, except\nthat the final pair which completes the diagonalization would be $(0^{n+k}, 1 - M^{\\alpha}(0^{n+k}))$.\nNote that because there are at most $k-1$ queries in both cases $3$ and $4$ in the definition of $f$,\n$vz_r \\notin {\\mathrm{QUERY}}$. In other words, the string we are forcing into $G$ (hence into $A$) will never be queried.\n\nSimilar to the previous theorem, it can be verified that $\\alpha$ and\n$A$ agree on all queries, i.e.  $M^A(0^{n+k}) = M^{\\alpha}(0^{n+k})$,\nif \\ref{meeting conditions} holds. It is also easy to prove that\n$\\alpha$ is computable in $O(2^n)$ steps, therefore $f$ satisfies the\ntime bounds in Lemma \\ref{extension function revised}.\n\\end{proof}\n\nWe now separate unbounded truth-table autoreducibility from bounded\ntruth-table \n\\\\ autoreducibility under the Genericity Hypothesis. This is\nbased on the technique of Ambos-Spies and Bentzien \\cite{AmbBen00}\nseparating the corresponding completeness notions.\n\n\\begin{theorem}\\label{th:btt vs tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ has a {$\\p$-generic\\xspace} language, then there exists a ${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is \n${\\mathrm{tt}}$-autoreducible, but not ${\\mathrm{btt}}$-autoreducible.\n\\end{theorem}\nBefore proving Theorem \\ref{th:btt vs tt}, we need a few definitions\nand two lemmas.\n\nA complexity class $C$ is {\\em computably presentable} if there is a\ncomputable function $f : {\\mathbb{N}} \\to {\\mathbb{N}}$ such that $C = \\{ L(M_{f(i)}) \\mid\ni \\in {\\mathbb{N}} \\}$. A sequence of classes $C_0,C_1,\\ldots$ is {\\em uniformly\n  computably presentable} if there is a computable function $f : {\\mathbb{N}}\n\\times {\\mathbb{N}} \\to {\\mathbb{N}}$ such that $C_j = \\{ L(M_{f(j,i)}) \\mid i \\in {\\mathbb{N}} \\}$\nfor all $j \\in {\\mathbb{N}}$. A reducibility ${\\cal R}$ is {\\em computably\n  presentable} if there is a computable function $f : {\\mathbb{N}} \\to {\\mathbb{N}}$ such\nthat $M_{f(1)},M_{f(2)},\\ldots$ is an enumeration of all ${\\cal R}$-reductions.\n\n\n\n\n\\begin{lemma}\\label{enumeration}\nIf $C$ is a computably presentable class which is closed under finite\nvariants and ${\\cal R}$ is a computably presentable reducibility, then \n$C_{{\\cal R}\\text{-}auto} = \\{B \\in C \\;|\\; B \\; is \\; {\\cal R}$-$autoreducible \\}$ is also computably presentable.\n\\end{lemma}\n\\begin{proof}\nWe prove the lemma for polynomial-time Turing autoreducibility, but similar proofs can be constructed for \nany kind of autoreduction that is computably presentable. For simplicity, we use $C_{auto}$ for \n$C_{poly \\text{-}T\\text{-}auto}$ in the rest of the proof. If\n$C_{auto} = \\emptyset$ then it is computably presentable by\nconvention. Assume $C_{auto} \\neq \\emptyset$, and fix some set $A \\in\nC_{auto}$. Since $C$ is closed under finite variants, any finite\nvariation of $A$ must also belong to $C_{auto}$.\n\nLet $N_1$,$N_2$,... be a presentation of $C$, and $T_1$,$T_2$,... be an enumeration of deterministic polynomial-time oracle Turing machines. For every pair $n = {\\langle {i,j} \\rangle}$ where $i,j \\geq 1$ we define a Turing machine $M_n$ as follows:\\\\\n\n\n\\begin{tabular}{lll}\n\\toprule\n$M_n$ &    &\\\\\n\\midrule\ninput $x$ &     & \\\\\nfor each y with $y < x$ do & &\\\\\n& test that $y \\in L[N_i] \\Leftrightarrow y \\in L(T_j,L(N_i))$, & \\\\\n& and $y$ itself has not been queried by $T_j$ &\\\\\nif tests are true & &\\\\\n& then accept $x$ iff $x \\in L(N_i)$ & \\\\\n& else accept $x$ iff $x \\in A$ & \n\\end{tabular}\\\\\n\n\n\nLet $L$ be an arbitrary language in $C_{auto}$. There must be some $i,j \\geq 1$ such that $L = L(N_i)$ \nand $T_j$ computes an ${\\cal R}$-autoreduction on $L$. Therefore $M_n$ computes $L$ when $n = {\\langle {i,j} \\rangle}$.\nThis means that every language in $C_{auto}$ is accepted by some\nTuring machine $M_n$. On the other hand, for every $n={\\langle {i,j} \\rangle}$, \n if $T_j$ does not compute an ${\\cal R}$-autoreduction on $L(N_i)$, then\n $L(M_n)$ is a finite variant of $A$. Since $C$ is assumed to be closed under finite variants, $L(M_n) \\in C_{auto}$. \n\\end{proof}\n\\begin{lemma_cite}{Ambos-Spies and Bentzien \\cite{AmbBen00}}\\label{diagonalization-lemma}\nLet $C_0,C_1,\\ldots$ be classes such that,\\\\\n$(1)$. $C_0,C_1,\\ldots$ is uniformly computably presentable.\\\\\n$(2)$. Each $C_i$ is closed under finite variants.\\\\\n$(3)$. There is a decidable set $D$ such that $D \\subseteq \\{0\\}^* \\times \\Sigma ^*$ , \\\\\nand $D^{[n]} = \\{x | <0^n,x> \\in D \\} \\notin C_n$.\\\\\n$(4)$. $f : N \\rightarrow N$ is a non-decreasing unbounded computable function.\\\\\nThen there exists a set $A$ and a function $g : N \\rightarrow N$ such that:\\\\\n$(5)$. $A \\notin \\bigcup_{n = 0}^{\\infty}{C_n}$.\\\\\n$(6)$. $\\forall n.\\; A_{=n} = D_{=n}^{[g(n)]}$.\\\\\n$(7)$. $g$ is polynomial-time computable with respect to the unary representation of numbers.\\\\\n$(8)$. $\\forall n.\\; g(n) \\leq f(n)$.\n\\end{lemma_cite}\n\n\n\n\n\n\n\\begin{proof}[Proof of Theorem \\ref{th:btt vs tt}]\nLet $\\widetilde {{\\rm SAT}} = \\{ 0^n1x \\;|\\; n \\geq 0 \\;\\textrm{ and }\\; x \\in {\\rm SAT} \\} $. It is easy to see that \n$\\widetilde {{\\rm SAT}}$ is ${\\ensuremath{\\mathrm{NP}}}$-complete, and $\\widetilde{{\\rm SAT}} \\in {\\mathrm{DTIME}}(2^n)$. For every $k \\geq 0$, let $A_k$ \nbe a $(k+3)$-${\\mathrm{tt}}$-complete set constructed as before, by using $\\widetilde {{\\rm SAT}}$ instead of ${\\rm SAT}$, \nand fix a {$\\p$-generic\\xspace} set $G \\in {\\ensuremath{\\mathrm{NP}}}$ for the rest of the proof. Note that $A_k$ is also \n$(k+3)$-${\\mathrm{tt}}$-autoreducible, but not $(k+2)$-${\\mathrm{tt}}$-complete or $(k+2)$-${\\mathrm{tt}}$-autoreducible. \nDefine $D = \\{<0^k,x> \\; | \\; k \\geq 0 \\; and \\; x \\in A_k \\}$. Since $A_k \\in {\\ensuremath{\\mathrm{NP}}}$ uniformly in $k$, \n$D \\in {\\ensuremath{\\mathrm{NP}}}$. Let $C_k = \\{ B \\in {\\ensuremath{\\mathrm{NP}}} \\; | \\; B \\; \\text{is} \\; k\\text{-}{\\mathrm{tt}}\\text{-autoreducible} \\}$ for\n$k \\geq 1$ and $C_0 = C_1$. ${\\ensuremath{\\mathrm{NP}}}$ is computably presentable and\nclosed under finite variants, therefore by Lemma \\ref{enumeration},\n$C_k$'s are computably presentable. In fact, they are uniformly\ncomputably presentable by applying the proof of Lemma\n\\ref{enumeration} uniformly. It is also easy to see that each $C_k$ is closed under finite variants. Therefore $C_k$'s satisfy the conditions of Lemma \\ref{diagonalization-lemma}. It follows from the definition of $D$ that $D^{[k]} = A_k$, and we know that $A_k \\notin C_k$ by construction of $A_k$. Therefore, if we take $f(n) = min \\{m\\;|\\; 2m+3 \\geq n\\}$, by Lemma \\ref{diagonalization-lemma} there exist $A$ and $g$ such that properties $(5)$-$(8)$ \nfrom the lemma hold.\\\\\nIt follows from $(6)$ and $(7)$ that $\\forall n.\\; A_{=n} = D_{=n}^{[g(n)]}$, and $g$ is polynomial time \ncomputable with respect to unary representation of numbers. This implies that $A \\le_{\\mathrm{m}}^{\\mathrm{p}} D$, therefore \n$A \\in {\\ensuremath{\\mathrm{NP}}}$. Moreover, by $(5)$ from the lemma, $A \\notin \\bigcup_{n \\geq 0} {C_n}$, which means for \nevery $k \\geq 1$, $A$ is not $k$-${\\mathrm{tt}}$-autoreducible. In other words $A$ is not ${\\mathrm{btt}}$-autoreducible.\n\nTo show that $A$ is ${\\mathrm{tt}}$-autoreducible, we will show that ${\\rm SAT} \\le_{{\\mathrm{tt}}}^{\\mathrm{p}} A$ via honest reductions, and then it follows from Lemma \\ref{le:honest auto} that $A$ is ${\\mathrm{tt}}$-autoreducible. To define the truth-table reduction from ${\\rm SAT}$ to $A$, fix $x$ with $|x| = n$. For every $k,m \\geq 0$ we have ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$,\n and $\\widetilde {{\\rm SAT}}[0^m1x]$ can be computed by making $(k+3)$ independent queries from \n $(A_k)_{=m+1+n+k+2}$ in polynomial time, uniformly in $x$, $k$, and $m$(This follows from \n $(k+3)$-${\\mathrm{tt}}$-completeness of $A_k$, and the way $A_k$ is defined using $\\widetilde {{\\rm SAT}}$. \n $(7)$ from Lemma \\ref{diagonalization-lemma} implies that:\n \n", "itemtype": "equation", "pos": 47983, "prevtext": "\nand if $|w| \\geq n+k$ then:\n", "index": 39, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      1 & \\textrm{ if $v = 0^n \\;\\wedge  p = 2$} \\\\\n     {\\rm SAT}[v] & \\textrm{ if $v = 0^n \\;\\wedge \\; p = k$} \\\\\n     1 &  \\textrm{if $p = k+1$} \\\\  \n     0 & \\textrm{otherwise}\\\\\n\\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}1&amp;\\textrm{ if $v=0^{n}\\;\\wedge p=2$}\\\\&#10;{\\rm SAT}[v]&amp;\\textrm{ if $v=0^{n}\\;\\wedge\\;p=k$}\\\\&#10;1&amp;\\textrm{if $p=k+1$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo>\u2227</mo><mi>p</mi></mrow><mo>=</mo><mn>2</mn></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><mpadded width=\"+2.8pt\"><msup><mn>0</mn><mi>n</mi></msup></mpadded><mo rspace=\"5.3pt\">\u2227</mo><mi>p</mi></mrow><mo>=</mo><mi>k</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>p</mi><mo>=</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nWe also know that $g(2n+3) \\le f(2n+3) \\le n$ for all $n$. Using all these facts, here is the truth-table \nreduction from ${\\rm SAT}$ to $A$:\\\\\nFor $x$ with $|x| = n$, compute $g(2n+3)$, and let $k = g(2n+3)$ and $m = n - k$. Therefore:\n\n", "itemtype": "equation", "pos": 56181, "prevtext": "\nNow we run the same oracle Turing machine $M$, but we use $\\alpha$ as the oracle instead of $A$. Let\n${\\mathrm{QUERY}}$ be the set of queries asked in this process. $f$ will be defined in a similar fashion, except\nthat the final pair which completes the diagonalization would be $(0^{n+k}, 1 - M^{\\alpha}(0^{n+k}))$.\nNote that because there are at most $k-1$ queries in both cases $3$ and $4$ in the definition of $f$,\n$vz_r \\notin {\\mathrm{QUERY}}$. In other words, the string we are forcing into $G$ (hence into $A$) will never be queried.\n\nSimilar to the previous theorem, it can be verified that $\\alpha$ and\n$A$ agree on all queries, i.e.  $M^A(0^{n+k}) = M^{\\alpha}(0^{n+k})$,\nif \\ref{meeting conditions} holds. It is also easy to prove that\n$\\alpha$ is computable in $O(2^n)$ steps, therefore $f$ satisfies the\ntime bounds in Lemma \\ref{extension function revised}.\n\\end{proof}\n\nWe now separate unbounded truth-table autoreducibility from bounded\ntruth-table \n\\\\ autoreducibility under the Genericity Hypothesis. This is\nbased on the technique of Ambos-Spies and Bentzien \\cite{AmbBen00}\nseparating the corresponding completeness notions.\n\n\\begin{theorem}\\label{th:btt vs tt}\nIf ${\\ensuremath{\\mathrm{NP}}}$ has a {$\\p$-generic\\xspace} language, then there exists a ${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is \n${\\mathrm{tt}}$-autoreducible, but not ${\\mathrm{btt}}$-autoreducible.\n\\end{theorem}\nBefore proving Theorem \\ref{th:btt vs tt}, we need a few definitions\nand two lemmas.\n\nA complexity class $C$ is {\\em computably presentable} if there is a\ncomputable function $f : {\\mathbb{N}} \\to {\\mathbb{N}}$ such that $C = \\{ L(M_{f(i)}) \\mid\ni \\in {\\mathbb{N}} \\}$. A sequence of classes $C_0,C_1,\\ldots$ is {\\em uniformly\n  computably presentable} if there is a computable function $f : {\\mathbb{N}}\n\\times {\\mathbb{N}} \\to {\\mathbb{N}}$ such that $C_j = \\{ L(M_{f(j,i)}) \\mid i \\in {\\mathbb{N}} \\}$\nfor all $j \\in {\\mathbb{N}}$. A reducibility ${\\cal R}$ is {\\em computably\n  presentable} if there is a computable function $f : {\\mathbb{N}} \\to {\\mathbb{N}}$ such\nthat $M_{f(1)},M_{f(2)},\\ldots$ is an enumeration of all ${\\cal R}$-reductions.\n\n\n\n\n\\begin{lemma}\\label{enumeration}\nIf $C$ is a computably presentable class which is closed under finite\nvariants and ${\\cal R}$ is a computably presentable reducibility, then \n$C_{{\\cal R}\\text{-}auto} = \\{B \\in C \\;|\\; B \\; is \\; {\\cal R}$-$autoreducible \\}$ is also computably presentable.\n\\end{lemma}\n\\begin{proof}\nWe prove the lemma for polynomial-time Turing autoreducibility, but similar proofs can be constructed for \nany kind of autoreduction that is computably presentable. For simplicity, we use $C_{auto}$ for \n$C_{poly \\text{-}T\\text{-}auto}$ in the rest of the proof. If\n$C_{auto} = \\emptyset$ then it is computably presentable by\nconvention. Assume $C_{auto} \\neq \\emptyset$, and fix some set $A \\in\nC_{auto}$. Since $C$ is closed under finite variants, any finite\nvariation of $A$ must also belong to $C_{auto}$.\n\nLet $N_1$,$N_2$,... be a presentation of $C$, and $T_1$,$T_2$,... be an enumeration of deterministic polynomial-time oracle Turing machines. For every pair $n = {\\langle {i,j} \\rangle}$ where $i,j \\geq 1$ we define a Turing machine $M_n$ as follows:\\\\\n\n\n\\begin{tabular}{lll}\n\\toprule\n$M_n$ &    &\\\\\n\\midrule\ninput $x$ &     & \\\\\nfor each y with $y < x$ do & &\\\\\n& test that $y \\in L[N_i] \\Leftrightarrow y \\in L(T_j,L(N_i))$, & \\\\\n& and $y$ itself has not been queried by $T_j$ &\\\\\nif tests are true & &\\\\\n& then accept $x$ iff $x \\in L(N_i)$ & \\\\\n& else accept $x$ iff $x \\in A$ & \n\\end{tabular}\\\\\n\n\n\nLet $L$ be an arbitrary language in $C_{auto}$. There must be some $i,j \\geq 1$ such that $L = L(N_i)$ \nand $T_j$ computes an ${\\cal R}$-autoreduction on $L$. Therefore $M_n$ computes $L$ when $n = {\\langle {i,j} \\rangle}$.\nThis means that every language in $C_{auto}$ is accepted by some\nTuring machine $M_n$. On the other hand, for every $n={\\langle {i,j} \\rangle}$, \n if $T_j$ does not compute an ${\\cal R}$-autoreduction on $L(N_i)$, then\n $L(M_n)$ is a finite variant of $A$. Since $C$ is assumed to be closed under finite variants, $L(M_n) \\in C_{auto}$. \n\\end{proof}\n\\begin{lemma_cite}{Ambos-Spies and Bentzien \\cite{AmbBen00}}\\label{diagonalization-lemma}\nLet $C_0,C_1,\\ldots$ be classes such that,\\\\\n$(1)$. $C_0,C_1,\\ldots$ is uniformly computably presentable.\\\\\n$(2)$. Each $C_i$ is closed under finite variants.\\\\\n$(3)$. There is a decidable set $D$ such that $D \\subseteq \\{0\\}^* \\times \\Sigma ^*$ , \\\\\nand $D^{[n]} = \\{x | <0^n,x> \\in D \\} \\notin C_n$.\\\\\n$(4)$. $f : N \\rightarrow N$ is a non-decreasing unbounded computable function.\\\\\nThen there exists a set $A$ and a function $g : N \\rightarrow N$ such that:\\\\\n$(5)$. $A \\notin \\bigcup_{n = 0}^{\\infty}{C_n}$.\\\\\n$(6)$. $\\forall n.\\; A_{=n} = D_{=n}^{[g(n)]}$.\\\\\n$(7)$. $g$ is polynomial-time computable with respect to the unary representation of numbers.\\\\\n$(8)$. $\\forall n.\\; g(n) \\leq f(n)$.\n\\end{lemma_cite}\n\n\n\n\n\n\n\\begin{proof}[Proof of Theorem \\ref{th:btt vs tt}]\nLet $\\widetilde {{\\rm SAT}} = \\{ 0^n1x \\;|\\; n \\geq 0 \\;\\textrm{ and }\\; x \\in {\\rm SAT} \\} $. It is easy to see that \n$\\widetilde {{\\rm SAT}}$ is ${\\ensuremath{\\mathrm{NP}}}$-complete, and $\\widetilde{{\\rm SAT}} \\in {\\mathrm{DTIME}}(2^n)$. For every $k \\geq 0$, let $A_k$ \nbe a $(k+3)$-${\\mathrm{tt}}$-complete set constructed as before, by using $\\widetilde {{\\rm SAT}}$ instead of ${\\rm SAT}$, \nand fix a {$\\p$-generic\\xspace} set $G \\in {\\ensuremath{\\mathrm{NP}}}$ for the rest of the proof. Note that $A_k$ is also \n$(k+3)$-${\\mathrm{tt}}$-autoreducible, but not $(k+2)$-${\\mathrm{tt}}$-complete or $(k+2)$-${\\mathrm{tt}}$-autoreducible. \nDefine $D = \\{<0^k,x> \\; | \\; k \\geq 0 \\; and \\; x \\in A_k \\}$. Since $A_k \\in {\\ensuremath{\\mathrm{NP}}}$ uniformly in $k$, \n$D \\in {\\ensuremath{\\mathrm{NP}}}$. Let $C_k = \\{ B \\in {\\ensuremath{\\mathrm{NP}}} \\; | \\; B \\; \\text{is} \\; k\\text{-}{\\mathrm{tt}}\\text{-autoreducible} \\}$ for\n$k \\geq 1$ and $C_0 = C_1$. ${\\ensuremath{\\mathrm{NP}}}$ is computably presentable and\nclosed under finite variants, therefore by Lemma \\ref{enumeration},\n$C_k$'s are computably presentable. In fact, they are uniformly\ncomputably presentable by applying the proof of Lemma\n\\ref{enumeration} uniformly. It is also easy to see that each $C_k$ is closed under finite variants. Therefore $C_k$'s satisfy the conditions of Lemma \\ref{diagonalization-lemma}. It follows from the definition of $D$ that $D^{[k]} = A_k$, and we know that $A_k \\notin C_k$ by construction of $A_k$. Therefore, if we take $f(n) = min \\{m\\;|\\; 2m+3 \\geq n\\}$, by Lemma \\ref{diagonalization-lemma} there exist $A$ and $g$ such that properties $(5)$-$(8)$ \nfrom the lemma hold.\\\\\nIt follows from $(6)$ and $(7)$ that $\\forall n.\\; A_{=n} = D_{=n}^{[g(n)]}$, and $g$ is polynomial time \ncomputable with respect to unary representation of numbers. This implies that $A \\le_{\\mathrm{m}}^{\\mathrm{p}} D$, therefore \n$A \\in {\\ensuremath{\\mathrm{NP}}}$. Moreover, by $(5)$ from the lemma, $A \\notin \\bigcup_{n \\geq 0} {C_n}$, which means for \nevery $k \\geq 1$, $A$ is not $k$-${\\mathrm{tt}}$-autoreducible. In other words $A$ is not ${\\mathrm{btt}}$-autoreducible.\n\nTo show that $A$ is ${\\mathrm{tt}}$-autoreducible, we will show that ${\\rm SAT} \\le_{{\\mathrm{tt}}}^{\\mathrm{p}} A$ via honest reductions, and then it follows from Lemma \\ref{le:honest auto} that $A$ is ${\\mathrm{tt}}$-autoreducible. To define the truth-table reduction from ${\\rm SAT}$ to $A$, fix $x$ with $|x| = n$. For every $k,m \\geq 0$ we have ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$,\n and $\\widetilde {{\\rm SAT}}[0^m1x]$ can be computed by making $(k+3)$ independent queries from \n $(A_k)_{=m+1+n+k+2}$ in polynomial time, uniformly in $x$, $k$, and $m$(This follows from \n $(k+3)$-${\\mathrm{tt}}$-completeness of $A_k$, and the way $A_k$ is defined using $\\widetilde {{\\rm SAT}}$. \n $(7)$ from Lemma \\ref{diagonalization-lemma} implies that:\n \n", "index": 41, "text": "\\begin{equation}\n A_{=2n+3} = (D^{[g(2n+3)]})_{=2n+3} = (A_{g(2n+3)})_{=2n+3}\n \\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"A_{=2n+3}=(D^{[g(2n+3)]})_{=2n+3}=(A_{g(2n+3)})_{=2n+3}\" display=\"block\"><mrow><msub><mi>A</mi><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow></mrow></msub><mo>=</mo><msub><mrow><mo stretchy=\"false\">(</mo><msup><mi>D</mi><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></msup><mo stretchy=\"false\">)</mo></mrow><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow></mrow></msub><mo>=</mo><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>A</mi><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow></mrow></msub></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nWe know that ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$ can be computed by making $(k+3)$ independent queries from \n$(A_k)_{=m+1+n+k+2}$. This means ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$ can be recovered by making $g(2n+3)$ \nqueries from $A_{=2n+3}$.\\\\\nNote that all these queries are longer than $x$. Therefore, by Lemma\n\\ref{le:honest auto}, $A$ is ${\\mathrm{tt}}$-autoreducible. \n\\end{proof}\n\\section{Stronger Separations Under a Stronger Hypothesis}\\label{sec:stronger}\nOur results so far only separate $k$-tt-autoreducibility from\n$(k-2)$-T-autoreducibility for $k \\geq 3$ under the genericity\nhypothesis. In this section we show that a stronger hypothesis\nseparates $k$-tt-autoreducibility from $(k-1)$-T-autoreducibility, for\nall $k \\geq 2$. We note that separating $k$ nonadaptive queries from\n$k-1$ adaptive queries is an optimal separation of bounded query\nreducibilities.\n\nFirst we consider $2$-${\\mathrm{tt}}$-autoreducibility versus\n$1$-${\\mathrm{tt}}$-autoreducibility (equivalently,\n$1$-${\\mathrm{T}}$-autoreducibility). Pavan and Selman \\cite{PavSel04} showed\nthat if ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a ${\\mathrm{DTIME}}(2^{n^\\epsilon})$-bi-immune set, then\n$2$-${\\mathrm{tt}}$-completeness is different from $1$-${\\mathrm{tt}}$-completeness for\n${\\ensuremath{\\mathrm{NP}}}$. We show under the stronger hypothesis that ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$\ncontains a {$\\p$-generic\\xspace} set, we can separate the autoreducibility\nnotions.\n\n\\begin{theorem}\\label{th:2tt vs 1tt}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ has a {$\\p$-generic\\xspace} language, then there exists a $2$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is \n$2$-${\\mathrm{tt}}$-autoreducible, but neither $1$-${\\mathrm{tt}}$-complete nor $1$-${\\mathrm{tt}}$-autoreducible.\n\\end{theorem}\n\\begin{proof}\nAssume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $A = (G \\cap {\\rm SAT}) \\dot\\cup (\\overline{G} \\cap {\\rm SAT})$, where \n$\\overline{G}$ is $G$'s complement, and $\\dot\\cup$ stands for disjoint union. We implement  disjoint union as \n $A = (G \\cap {\\rm SAT})0 \\; \\dot\\cup \\;(\\overline{G} \\cap {\\rm SAT})1$. It follows from closure properties of ${\\ensuremath{\\mathrm{NP}}}$ and the fact that $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ that $A \\in {\\ensuremath{\\mathrm{NP}}}$. It follows from definition of $A$ that for every $x$,\n $x \\in {\\rm SAT} \\leftrightarrow (x0 \\in A \\vee x1 \\in A)$. This means ${\\rm SAT} \\le_{2{\\mathrm{tt}}}^{\\mathrm{p}} A$. Therefore\n  $A$ is $2$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. Since both queries in the above reduction are honest, in fact length increasing, it follows from Lemma \\ref{le:honest auto} that $A$ is $2$-${\\mathrm{tt}}$-autoreducible. To get a contradiction assume that $A$ is $1$-${\\mathrm{tt}}$-autoreducible via polynomial-time computable functions $h$ and $g$. In other words,\n\n", "itemtype": "equation", "pos": 56512, "prevtext": "\nWe also know that $g(2n+3) \\le f(2n+3) \\le n$ for all $n$. Using all these facts, here is the truth-table \nreduction from ${\\rm SAT}$ to $A$:\\\\\nFor $x$ with $|x| = n$, compute $g(2n+3)$, and let $k = g(2n+3)$ and $m = n - k$. Therefore:\n\n", "index": 43, "text": "\\begin{equation}\n(A_k)_{=m+1+n+k+2} = (A_{g(2n+3)})_{=2n+3} = A_{=2n+3}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"(A_{k})_{=m+1+n+k+2}=(A_{g(2n+3)})_{=2n+3}=A_{=2n+3}\" display=\"block\"><mrow><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>A</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi/><mo>=</mo><mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>2</mn></mrow></mrow></msub><mo>=</mo><msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>A</mi><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow></mrow></msub><mo>=</mo><msub><mi>A</mi><mrow><mi/><mo>=</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>n</mi></mrow><mo>+</mo><mn>3</mn></mrow></mrow></msub></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "  \nand $g(x) \\neq x$. Let $x = y0$ for some string $y$, then \\eqref{1tt-autored} turns into\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe know that ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$ can be computed by making $(k+3)$ independent queries from \n$(A_k)_{=m+1+n+k+2}$. This means ${\\rm SAT}[x] = \\widetilde {{\\rm SAT}}[0^m1x]$ can be recovered by making $g(2n+3)$ \nqueries from $A_{=2n+3}$.\\\\\nNote that all these queries are longer than $x$. Therefore, by Lemma\n\\ref{le:honest auto}, $A$ is ${\\mathrm{tt}}$-autoreducible. \n\\end{proof}\n\\section{Stronger Separations Under a Stronger Hypothesis}\\label{sec:stronger}\nOur results so far only separate $k$-tt-autoreducibility from\n$(k-2)$-T-autoreducibility for $k \\geq 3$ under the genericity\nhypothesis. In this section we show that a stronger hypothesis\nseparates $k$-tt-autoreducibility from $(k-1)$-T-autoreducibility, for\nall $k \\geq 2$. We note that separating $k$ nonadaptive queries from\n$k-1$ adaptive queries is an optimal separation of bounded query\nreducibilities.\n\nFirst we consider $2$-${\\mathrm{tt}}$-autoreducibility versus\n$1$-${\\mathrm{tt}}$-autoreducibility (equivalently,\n$1$-${\\mathrm{T}}$-autoreducibility). Pavan and Selman \\cite{PavSel04} showed\nthat if ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a ${\\mathrm{DTIME}}(2^{n^\\epsilon})$-bi-immune set, then\n$2$-${\\mathrm{tt}}$-completeness is different from $1$-${\\mathrm{tt}}$-completeness for\n${\\ensuremath{\\mathrm{NP}}}$. We show under the stronger hypothesis that ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$\ncontains a {$\\p$-generic\\xspace} set, we can separate the autoreducibility\nnotions.\n\n\\begin{theorem}\\label{th:2tt vs 1tt}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ has a {$\\p$-generic\\xspace} language, then there exists a $2$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is \n$2$-${\\mathrm{tt}}$-autoreducible, but neither $1$-${\\mathrm{tt}}$-complete nor $1$-${\\mathrm{tt}}$-autoreducible.\n\\end{theorem}\n\\begin{proof}\nAssume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $A = (G \\cap {\\rm SAT}) \\dot\\cup (\\overline{G} \\cap {\\rm SAT})$, where \n$\\overline{G}$ is $G$'s complement, and $\\dot\\cup$ stands for disjoint union. We implement  disjoint union as \n $A = (G \\cap {\\rm SAT})0 \\; \\dot\\cup \\;(\\overline{G} \\cap {\\rm SAT})1$. It follows from closure properties of ${\\ensuremath{\\mathrm{NP}}}$ and the fact that $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ that $A \\in {\\ensuremath{\\mathrm{NP}}}$. It follows from definition of $A$ that for every $x$,\n $x \\in {\\rm SAT} \\leftrightarrow (x0 \\in A \\vee x1 \\in A)$. This means ${\\rm SAT} \\le_{2{\\mathrm{tt}}}^{\\mathrm{p}} A$. Therefore\n  $A$ is $2$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$. Since both queries in the above reduction are honest, in fact length increasing, it follows from Lemma \\ref{le:honest auto} that $A$ is $2$-${\\mathrm{tt}}$-autoreducible. To get a contradiction assume that $A$ is $1$-${\\mathrm{tt}}$-autoreducible via polynomial-time computable functions $h$ and $g$. In other words,\n\n", "index": 45, "text": "\\begin{equation}\\label{1tt-autored}\n \\forall x.\\; A(x) = h(x , A[g(x)])\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\forall x.\\;A(x)=h(x,A[g(x)])\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mi>x</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nand $g(y0) \\neq y0$.\nWe define a bounded extension function $f$ whenever ${\\rm SAT}[y] = 1$ as follows.\n\\begin{itemize}\n  \\item Consider the case where $g(y0) = z0$ or $z1$ and\n$z > y$.\nIf $g(y0) = z0$ then $f$ forces\n$G[z] = 0$, and if $g(y0) = z1$ then $f$ forces $G[z] = 1$. $f$ also\nforces $G[y] = 1 - h(y0 , 0)$. Since $g$ and $h$ are computable in\npolynomial time, so is $f$.\n\\item On the other hand, if $g(y0) = z0$ or $z1$ and $z < y$ then\n  define $f$ such that it forces $G[y] = 1 - h(y0, A[g(y0)])$.  Then\n  $f$ polynomial-time computable in this case as well because $A$ may\n  be computed on $g(y0)$ by looking up $G[z]$ from the partial\n  characteristic sequence and deciding ${\\rm SAT}[z]$ in $2^{O(|z|)}$ time.\n\\item If $g(y0) = y1$ and $h(y0,.) = c$ is a constant function, \n  then define $f$ such that it forces $G[y] = 1 - c$.   \n\\end{itemize}\nIf $g(y0) \\neq y1 \\wedge {\\rm SAT}[y] = 1$ for infinitely many $y$, it follows\nfrom the {$\\p$-genericity\\xspace} of $G$ that $G$ has to meet $f$, but this refutes the autoreduction.\nSimilarly, $g(y0) = y1 \\wedge h(y0,.) = const \\wedge {\\rm SAT}[y] = 1$ cannot happen for \ninfinitely many $y$'s.\nAs a result, $(g(y0) = y1 \\vee {\\rm SAT}[y] = 0)$ and $h(y0,.)$ is not constant\n for all but finitely many $y$'s. \nIf $g(y0) = y1$ then $h$ says either $G \\cap {\\rm SAT}[y] = \\overline{G} \\cap {\\rm SAT} [y]$ or \n$G \\cap {\\rm SAT}[y] = \\neg ( \\overline{G} \\cap {\\rm SAT} [y])$. It is easy to see\nthis implies ${\\rm SAT}[y]$ has to be $0$ or $1$, respectively. \nBased on the facts above, we define Algorithm \\ref{alg:1tt} that\ndecides ${\\rm SAT}$ in polynomial time. This contradicts the assumption\nthat ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ has a ${\\mathrm{p}}$-generic language.\n\\begin{figure}[h!]\n\\begin{algorithm}[H]\n input y\\;\n  \\eIf{$g(y0) \\neq y1 \\vee h(y0,.)\\textrm{ is constant}$}{\n   Output NO\\;\n   }{\n   \\eIf{$h(y0,.)\\textrm{ is the identity function}$}{\n   Output YES\\;\n   }{\n   Output NO\\;}\n }\n\\caption{A polynomial-time algorithm for ${\\rm SAT}$}\\label{alg:1tt}\n\\end{algorithm}\n\\end{figure}\n\nIt is proved in \\cite{Glasser07} that every nontrival\n$1$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ is $1$-${\\mathrm{tt}}$-autoreducible, so it follows that $A$ is not $1$-${\\mathrm{tt}}$-complete.\n\\end{proof}\n\n\nWe will show the same hypothesis on ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ separates\n$k$-${\\mathrm{tt}}$-autoreducibilty from $(k-1)$-${\\mathrm{T}}$-autoreducibility for all\n$k \\geq 3$. First, we show the corresponding separation of\ncompleteness notions.\n\n\\begin{theorem}\\label{th:k-tt vs (k-1)-T complete}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then for every $k \\geq 3$ there exists a $k$-${\\mathrm{tt}}$-complete \nset for ${\\ensuremath{\\mathrm{NP}}}$ that is not $(k-1)$-${\\mathrm{T}}$-complete.\n\\end{theorem}\n\\begin{proof}\nAssume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $G_m = \\{x \\;|\\; xz_m \\in G \\}$ \nfor $1 \\le m \\le k$ where $z_1,...,z_k$ are the first $k$ strings of length $k$ as before.\nDefine \n\n", "itemtype": "equation", "pos": 59851, "prevtext": "  \nand $g(x) \\neq x$. Let $x = y0$ for some string $y$, then \\eqref{1tt-autored} turns into\n\n", "index": 47, "text": "\\begin{equation}\n \\forall y.\\; G \\cap {\\rm SAT}[y] = h(y0 , A[g(y0)])\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"\\forall y.\\;G\\cap{\\rm SAT}[y]=h(y0,A[g(y0)])\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mi>y</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>G</mi><mo>\u2229</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>y</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>y</mi><mo>\u2062</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>y</mi><mo>\u2062</mo><mn>0</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nIt is easy to check that $x \\in {\\rm SAT} \\Leftrightarrow \\bigvee _{m =1}^{k} ({xz_m \\in A})$, therefore\n${\\rm SAT} \\le _{k-{\\mathrm{tt}}}^{p} A$. It also follows from the fact that $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ and the closure\nproperties of ${\\ensuremath{\\mathrm{NP}}}$ that $A \\in {\\ensuremath{\\mathrm{NP}}}$, so $A$ is $k$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$, in fact $k$-${\\mathrm{dtt}}$-complete.\n\nWe claim that $A$ is not $(k-1)$-${\\mathrm{T}}$-hard for ${\\ensuremath{\\mathrm{NP}}}$. For a contradiction, assume that\n$G_k \\le_{(k-1)-{\\mathrm{T}}}^{p} A$. In other words, assume that there exists an oracle Turing machine $M$ \nsuch that \n\n", "itemtype": "equation", "pos": 63132, "prevtext": "\nand $g(y0) \\neq y0$.\nWe define a bounded extension function $f$ whenever ${\\rm SAT}[y] = 1$ as follows.\n\\begin{itemize}\n  \\item Consider the case where $g(y0) = z0$ or $z1$ and\n$z > y$.\nIf $g(y0) = z0$ then $f$ forces\n$G[z] = 0$, and if $g(y0) = z1$ then $f$ forces $G[z] = 1$. $f$ also\nforces $G[y] = 1 - h(y0 , 0)$. Since $g$ and $h$ are computable in\npolynomial time, so is $f$.\n\\item On the other hand, if $g(y0) = z0$ or $z1$ and $z < y$ then\n  define $f$ such that it forces $G[y] = 1 - h(y0, A[g(y0)])$.  Then\n  $f$ polynomial-time computable in this case as well because $A$ may\n  be computed on $g(y0)$ by looking up $G[z]$ from the partial\n  characteristic sequence and deciding ${\\rm SAT}[z]$ in $2^{O(|z|)}$ time.\n\\item If $g(y0) = y1$ and $h(y0,.) = c$ is a constant function, \n  then define $f$ such that it forces $G[y] = 1 - c$.   \n\\end{itemize}\nIf $g(y0) \\neq y1 \\wedge {\\rm SAT}[y] = 1$ for infinitely many $y$, it follows\nfrom the {$\\p$-genericity\\xspace} of $G$ that $G$ has to meet $f$, but this refutes the autoreduction.\nSimilarly, $g(y0) = y1 \\wedge h(y0,.) = const \\wedge {\\rm SAT}[y] = 1$ cannot happen for \ninfinitely many $y$'s.\nAs a result, $(g(y0) = y1 \\vee {\\rm SAT}[y] = 0)$ and $h(y0,.)$ is not constant\n for all but finitely many $y$'s. \nIf $g(y0) = y1$ then $h$ says either $G \\cap {\\rm SAT}[y] = \\overline{G} \\cap {\\rm SAT} [y]$ or \n$G \\cap {\\rm SAT}[y] = \\neg ( \\overline{G} \\cap {\\rm SAT} [y])$. It is easy to see\nthis implies ${\\rm SAT}[y]$ has to be $0$ or $1$, respectively. \nBased on the facts above, we define Algorithm \\ref{alg:1tt} that\ndecides ${\\rm SAT}$ in polynomial time. This contradicts the assumption\nthat ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ has a ${\\mathrm{p}}$-generic language.\n\\begin{figure}[h!]\n\\begin{algorithm}[H]\n input y\\;\n  \\eIf{$g(y0) \\neq y1 \\vee h(y0,.)\\textrm{ is constant}$}{\n   Output NO\\;\n   }{\n   \\eIf{$h(y0,.)\\textrm{ is the identity function}$}{\n   Output YES\\;\n   }{\n   Output NO\\;}\n }\n\\caption{A polynomial-time algorithm for ${\\rm SAT}$}\\label{alg:1tt}\n\\end{algorithm}\n\\end{figure}\n\nIt is proved in \\cite{Glasser07} that every nontrival\n$1$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ is $1$-${\\mathrm{tt}}$-autoreducible, so it follows that $A$ is not $1$-${\\mathrm{tt}}$-complete.\n\\end{proof}\n\n\nWe will show the same hypothesis on ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ separates\n$k$-${\\mathrm{tt}}$-autoreducibilty from $(k-1)$-${\\mathrm{T}}$-autoreducibility for all\n$k \\geq 3$. First, we show the corresponding separation of\ncompleteness notions.\n\n\\begin{theorem}\\label{th:k-tt vs (k-1)-T complete}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then for every $k \\geq 3$ there exists a $k$-${\\mathrm{tt}}$-complete \nset for ${\\ensuremath{\\mathrm{NP}}}$ that is not $(k-1)$-${\\mathrm{T}}$-complete.\n\\end{theorem}\n\\begin{proof}\nAssume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $G_m = \\{x \\;|\\; xz_m \\in G \\}$ \nfor $1 \\le m \\le k$ where $z_1,...,z_k$ are the first $k$ strings of length $k$ as before.\nDefine \n\n", "index": 49, "text": "\\begin{equation}\nA = \\Big[\\bigcup _{m = 1}^{k-1} {\\{xz_m \\;|\\; x \\in G_m \\cap {\\rm SAT} \\}}\\Big] \\cup \n    \\{xz_k \\;|\\; x \\in \\big[ \\cap _{m = 1}^{k-1}{\\overline{G_m}} \\big] \\cap {\\rm SAT} \\}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"A=\\Big{[}\\bigcup_{m=1}^{k-1}{\\{xz_{m}\\;|\\;x\\in G_{m}\\cap{\\rm SAT}\\}}\\Big{]}%&#10;\\cup\\{xz_{k}\\;|\\;x\\in\\big{[}\\cap_{m=1}^{k-1}{\\overline{G_{m}}}\\big{]}\\cap{\\rm&#10;SAT}\\}\" display=\"block\"><mrow><mi>A</mi><mo>=</mo><mrow><mrow><mo maxsize=\"160%\" minsize=\"160%\">[</mo><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>m</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><msub><mi>G</mi><mi>m</mi></msub><mo>\u2229</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">]</mo></mrow><mo>\u222a</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>k</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mrow><mo maxsize=\"120%\" minsize=\"120%\">[</mo><mrow><msubsup><mo>\u2229</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo>\u00af</mo></mover></mrow><mo maxsize=\"120%\" minsize=\"120%\">]</mo></mrow><mo>\u2229</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nwhere $M$ runs in polynomial time, and makes at most $(k-1)$ queries on every input. Given $n$ and \n$X \\upharpoonright 0^n$, we define a function $\\alpha$ as follows.\\\\\nIf $w = vz_p$ and $|w| < n+k$ then\n", "itemtype": "equation", "pos": 64048, "prevtext": "\nIt is easy to check that $x \\in {\\rm SAT} \\Leftrightarrow \\bigvee _{m =1}^{k} ({xz_m \\in A})$, therefore\n${\\rm SAT} \\le _{k-{\\mathrm{tt}}}^{p} A$. It also follows from the fact that $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ and the closure\nproperties of ${\\ensuremath{\\mathrm{NP}}}$ that $A \\in {\\ensuremath{\\mathrm{NP}}}$, so $A$ is $k$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$, in fact $k$-${\\mathrm{dtt}}$-complete.\n\nWe claim that $A$ is not $(k-1)$-${\\mathrm{T}}$-hard for ${\\ensuremath{\\mathrm{NP}}}$. For a contradiction, assume that\n$G_k \\le_{(k-1)-{\\mathrm{T}}}^{p} A$. In other words, assume that there exists an oracle Turing machine $M$ \nsuch that \n\n", "index": 51, "text": "\\begin{equation}\n\\forall x. \\; G_k [X] = M^A[x]\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"\\forall x.\\;G_{k}[X]=M^{A}[x]\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mi>x</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><msub><mi>G</mi><mi>k</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>M</mi><mi>A</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nIt is easy to see that $\\alpha$ is defined in a way that if \n$X \\upharpoonright 0^n = G \\upharpoonright 0^n$ then $\\alpha (w) = A[w]$.\\\\\nOn the other hand, if $|w| \\geq n+k$ then $\\alpha (w) =  0$ all the time. Later when we define the \nextension function we guarantee that $A[w] = 0$ for all long queries, by forcing the right\nvalues into $G$, which implies $A[w] = \\alpha (w)$ for all queries. But before doing that, we run\n$M$ on input $0^n$ with $\\alpha$ as the oracle, and define ${\\mathrm{QUERY}}$ to be the set of all queries\nmade in this computation. We know that $|{\\mathrm{QUERY}}| \\le k-1$ therefore one of the following \ncases must happen:\n\\begin{enumerate}\n\\item $xz_k \\notin {\\mathrm{QUERY}}$.\n\\item $xz_k \\in {\\mathrm{QUERY}}$, and $\\exists 1 \\le l \\le k-1. \\; xz_l \\notin {\\mathrm{QUERY}}$.\n\\end{enumerate}\nDefine a bounded extension function $f$ based on the above cases. Given $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n)$ contains the pairs described below. For every $v$ which is the value of some element of ${\\mathrm{QUERY}}$, \n\\begin{enumerate}\n\\item If $vz_k \\notin {\\mathrm{QUERY}}$, then put $(vz_1 , 0)$,...,$(vz_{(k-1)} , 0)$ into $f$. In other words,\n$f$ forces $G[vz_l]$ to $0$ for every $1 \\le l \\le k-1$.\n\\item If $vz_k \\in {\\mathrm{QUERY}}$ then there must be some $1 \\le l \\le k-1$ such that $vz_l \\notin {\\mathrm{QUERY}}$. \nIn this case $f$ forces $G[vz_i] = 0$ for every $1 \\le i \\le k-1$ except for $i = l$ for which $G[vz_l] = 1$.\n\\end{enumerate}\nIt can be shown that if $G$ meets $f$ at $0^n$, i.e. if \\eqref{meeting conditions} holds, then \n$\\alpha (w) = A[w]$ for every $w \\in {\\mathrm{QUERY}}$. As a result, \n\n", "itemtype": "equation", "pos": 64314, "prevtext": "\nwhere $M$ runs in polynomial time, and makes at most $(k-1)$ queries on every input. Given $n$ and \n$X \\upharpoonright 0^n$, we define a function $\\alpha$ as follows.\\\\\nIf $w = vz_p$ and $|w| < n+k$ then\n", "index": 53, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      X[w] \\wedge {\\rm SAT}[v] & \\textrm{ if $1 \\le p \\le k-1$} \\\\\n      \\big[\\bigwedge_{l=1}^{k-1} {(1 - X[vz_l])} \\big] \\wedge {\\rm SAT}[v] & \n      \\textrm{ if $p = k$} \\\\\n      0 & \\textrm{otherwise}\\\\\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}X[w]\\wedge{\\rm SAT}[v]&amp;\\textrm{ if $1\\leq p\\leq k-1$}\\\\&#10;\\big{[}\\bigwedge_{l=1}^{k-1}{(1-X[vz_{l}])}\\big{]}\\wedge{\\rm SAT}[v]&amp;\\textrm{ %&#10;if $p=k$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>w</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mn>1</mn><mo>\u2264</mo><mi>p</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo maxsize=\"120%\" minsize=\"120%\">[</mo><mrow><mstyle displaystyle=\"false\"><msubsup><mo largeop=\"true\" mathsize=\"160%\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mstyle><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo maxsize=\"120%\" minsize=\"120%\">]</mo></mrow><mo>\u2227</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>p</mi><mo>=</mo><mi>k</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nTo complete the diagonalization, we add one more pair to $f$ that forces the value of $G_k[0^n] = G[0^{n+k}]$ to $1 - M^{\\alpha} (0^n)$, i.e. $(0^{n+k} , 1 - M^{\\alpha} (0^n))$. Then it follows from \\eqref{last}\n that the reduction from $G_k$ to $A$ fails. The last part of the proof, is to show that $G$ has to meet $f$ at $0^n$ for some $n$. $\\alpha$ is computable in $O(2^n)$ steps for short queries, and constant time for long queries, and $M$ is a polynomial time Turing machine, which implies $f$ can be computed in \n at most $O(2^{2n})$ steps. It is also easy to see that the number of\n pairs in $f$ is bounded by $k^2$, which means $f$ is a bounded\n extension function. As a result $f$ satisfies the conditions of Lemma\n \\ref{extension function revised}, hence $G$ has to meet $f$ at $0^n$ for some $n$, which completes the proof.\n\\end{proof}\n\nNow we show the same sets separate $k$-${\\mathrm{tt}}$-autoreducibility from $(k-1)$-${\\mathrm{T}}$-autoreducibility.\n\n\\begin{theorem}\\label{th:k-tt vs (k-1)-T autored}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then for every $k \\geq 3$ there exists a $k$-${\\mathrm{tt}}$-complete \nset for ${\\ensuremath{\\mathrm{NP}}}$ that is $k$-${\\mathrm{tt}}$-autoreducible, but is not $(k-1)$-${\\mathrm{T}}$-autoreducible.\n\\end{theorem}\n\\begin{proof}\n Assume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $G_m = \\{x \\;|\\; xz_m \\in G \\}$ \nfor $1 \\le m \\le k$ where $z_1,...,z_k$ are the first $k$ strings of length $k$ as before.\nDefine \n\n", "itemtype": "equation", "pos": 66234, "prevtext": "\nIt is easy to see that $\\alpha$ is defined in a way that if \n$X \\upharpoonright 0^n = G \\upharpoonright 0^n$ then $\\alpha (w) = A[w]$.\\\\\nOn the other hand, if $|w| \\geq n+k$ then $\\alpha (w) =  0$ all the time. Later when we define the \nextension function we guarantee that $A[w] = 0$ for all long queries, by forcing the right\nvalues into $G$, which implies $A[w] = \\alpha (w)$ for all queries. But before doing that, we run\n$M$ on input $0^n$ with $\\alpha$ as the oracle, and define ${\\mathrm{QUERY}}$ to be the set of all queries\nmade in this computation. We know that $|{\\mathrm{QUERY}}| \\le k-1$ therefore one of the following \ncases must happen:\n\\begin{enumerate}\n\\item $xz_k \\notin {\\mathrm{QUERY}}$.\n\\item $xz_k \\in {\\mathrm{QUERY}}$, and $\\exists 1 \\le l \\le k-1. \\; xz_l \\notin {\\mathrm{QUERY}}$.\n\\end{enumerate}\nDefine a bounded extension function $f$ based on the above cases. Given $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n)$ contains the pairs described below. For every $v$ which is the value of some element of ${\\mathrm{QUERY}}$, \n\\begin{enumerate}\n\\item If $vz_k \\notin {\\mathrm{QUERY}}$, then put $(vz_1 , 0)$,...,$(vz_{(k-1)} , 0)$ into $f$. In other words,\n$f$ forces $G[vz_l]$ to $0$ for every $1 \\le l \\le k-1$.\n\\item If $vz_k \\in {\\mathrm{QUERY}}$ then there must be some $1 \\le l \\le k-1$ such that $vz_l \\notin {\\mathrm{QUERY}}$. \nIn this case $f$ forces $G[vz_i] = 0$ for every $1 \\le i \\le k-1$ except for $i = l$ for which $G[vz_l] = 1$.\n\\end{enumerate}\nIt can be shown that if $G$ meets $f$ at $0^n$, i.e. if \\eqref{meeting conditions} holds, then \n$\\alpha (w) = A[w]$ for every $w \\in {\\mathrm{QUERY}}$. As a result, \n\n", "index": 55, "text": "\\begin{equation}\\label{last}\nM^{\\alpha} (0^n) = M^A (0^n)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"M^{\\alpha}(0^{n})=M^{A}(0^{n})\" display=\"block\"><mrow><mrow><msup><mi>M</mi><mi>\u03b1</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>M</mi><mi>A</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mn>0</mn><mi>n</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nIt is easy to check that $x \\in {\\rm SAT} \\Leftrightarrow \\bigvee _{m =1}^{k} ({xz_m \\in A})$, therefore\n${\\rm SAT} \\le _{k-{\\mathrm{tt}}}^{p} A$. It also follows from the fact that $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ and the closure\nproperties of ${\\ensuremath{\\mathrm{NP}}}$ that $A \\in {\\ensuremath{\\mathrm{NP}}}$, so $A$ is $k$-${\\mathrm{tt}}$-complete for ${\\ensuremath{\\mathrm{NP}}}$, in fact $k$-${\\mathrm{dtt}}$-complete.\n\nWe claim that $A$ is not $(k-1)$-${\\mathrm{T}}$-hard for ${\\ensuremath{\\mathrm{NP}}}$. For a contradiction, assume that\n$G_k \\le_{(k-1)-{\\mathrm{T}}}^{p} A$. In other words, assume that there exists an oracle Turing machine $M$ \nsuch that \n\n", "itemtype": "equation", "pos": 63132, "prevtext": "\nand $g(y0) \\neq y0$.\nWe define a bounded extension function $f$ whenever ${\\rm SAT}[y] = 1$ as follows.\n\\begin{itemize}\n  \\item Consider the case where $g(y0) = z0$ or $z1$ and\n$z > y$.\nIf $g(y0) = z0$ then $f$ forces\n$G[z] = 0$, and if $g(y0) = z1$ then $f$ forces $G[z] = 1$. $f$ also\nforces $G[y] = 1 - h(y0 , 0)$. Since $g$ and $h$ are computable in\npolynomial time, so is $f$.\n\\item On the other hand, if $g(y0) = z0$ or $z1$ and $z < y$ then\n  define $f$ such that it forces $G[y] = 1 - h(y0, A[g(y0)])$.  Then\n  $f$ polynomial-time computable in this case as well because $A$ may\n  be computed on $g(y0)$ by looking up $G[z]$ from the partial\n  characteristic sequence and deciding ${\\rm SAT}[z]$ in $2^{O(|z|)}$ time.\n\\item If $g(y0) = y1$ and $h(y0,.) = c$ is a constant function, \n  then define $f$ such that it forces $G[y] = 1 - c$.   \n\\end{itemize}\nIf $g(y0) \\neq y1 \\wedge {\\rm SAT}[y] = 1$ for infinitely many $y$, it follows\nfrom the {$\\p$-genericity\\xspace} of $G$ that $G$ has to meet $f$, but this refutes the autoreduction.\nSimilarly, $g(y0) = y1 \\wedge h(y0,.) = const \\wedge {\\rm SAT}[y] = 1$ cannot happen for \ninfinitely many $y$'s.\nAs a result, $(g(y0) = y1 \\vee {\\rm SAT}[y] = 0)$ and $h(y0,.)$ is not constant\n for all but finitely many $y$'s. \nIf $g(y0) = y1$ then $h$ says either $G \\cap {\\rm SAT}[y] = \\overline{G} \\cap {\\rm SAT} [y]$ or \n$G \\cap {\\rm SAT}[y] = \\neg ( \\overline{G} \\cap {\\rm SAT} [y])$. It is easy to see\nthis implies ${\\rm SAT}[y]$ has to be $0$ or $1$, respectively. \nBased on the facts above, we define Algorithm \\ref{alg:1tt} that\ndecides ${\\rm SAT}$ in polynomial time. This contradicts the assumption\nthat ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ has a ${\\mathrm{p}}$-generic language.\n\\begin{figure}[h!]\n\\begin{algorithm}[H]\n input y\\;\n  \\eIf{$g(y0) \\neq y1 \\vee h(y0,.)\\textrm{ is constant}$}{\n   Output NO\\;\n   }{\n   \\eIf{$h(y0,.)\\textrm{ is the identity function}$}{\n   Output YES\\;\n   }{\n   Output NO\\;}\n }\n\\caption{A polynomial-time algorithm for ${\\rm SAT}$}\\label{alg:1tt}\n\\end{algorithm}\n\\end{figure}\n\nIt is proved in \\cite{Glasser07} that every nontrival\n$1$-${\\mathrm{tt}}$-complete set for ${\\ensuremath{\\mathrm{NP}}}$ is $1$-${\\mathrm{tt}}$-autoreducible, so it follows that $A$ is not $1$-${\\mathrm{tt}}$-complete.\n\\end{proof}\n\n\nWe will show the same hypothesis on ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ separates\n$k$-${\\mathrm{tt}}$-autoreducibilty from $(k-1)$-${\\mathrm{T}}$-autoreducibility for all\n$k \\geq 3$. First, we show the corresponding separation of\ncompleteness notions.\n\n\\begin{theorem}\\label{th:k-tt vs (k-1)-T complete}\nIf ${\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ contains a {$\\p$-generic\\xspace} set, then for every $k \\geq 3$ there exists a $k$-${\\mathrm{tt}}$-complete \nset for ${\\ensuremath{\\mathrm{NP}}}$ that is not $(k-1)$-${\\mathrm{T}}$-complete.\n\\end{theorem}\n\\begin{proof}\nAssume $G \\in {\\ensuremath{\\mathrm{NP}}} \\cap {\\co{{\\ensuremath{\\mathrm{NP}}}}}$ is {$\\p$-generic\\xspace}, and let $G_m = \\{x \\;|\\; xz_m \\in G \\}$ \nfor $1 \\le m \\le k$ where $z_1,...,z_k$ are the first $k$ strings of length $k$ as before.\nDefine \n\n", "index": 49, "text": "\\begin{equation}\nA = \\Big[\\bigcup _{m = 1}^{k-1} {\\{xz_m \\;|\\; x \\in G_m \\cap {\\rm SAT} \\}}\\Big] \\cup \n    \\{xz_k \\;|\\; x \\in \\big[ \\cap _{m = 1}^{k-1}{\\overline{G_m}} \\big] \\cap {\\rm SAT} \\}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"A=\\Big{[}\\bigcup_{m=1}^{k-1}{\\{xz_{m}\\;|\\;x\\in G_{m}\\cap{\\rm SAT}\\}}\\Big{]}%&#10;\\cup\\{xz_{k}\\;|\\;x\\in\\big{[}\\cap_{m=1}^{k-1}{\\overline{G_{m}}}\\big{]}\\cap{\\rm&#10;SAT}\\}\" display=\"block\"><mrow><mi>A</mi><mo>=</mo><mrow><mrow><mo maxsize=\"160%\" minsize=\"160%\">[</mo><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>m</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><msub><mi>G</mi><mi>m</mi></msub><mo>\u2229</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">]</mo></mrow><mo>\u222a</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>k</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mrow><mo maxsize=\"120%\" minsize=\"120%\">[</mo><mrow><msubsup><mo>\u2229</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo>\u00af</mo></mover></mrow><mo maxsize=\"120%\" minsize=\"120%\">]</mo></mrow><mo>\u2229</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\n$M$ runs in polynomial time, and on every input $x$ makes at most\n$k-1$ queries, none of which is $x$. Given $n$ and \n$X \\upharpoonright 0^n$, we define a function $\\alpha$ as follows.\\\\\nIf $w = vz_p$ and $|w| < n+k$ then\n", "itemtype": "equation", "pos": 68439, "prevtext": "\nWe showed that ${\\rm SAT} \\le_{k-{\\mathrm{tt}}}^{\\mathrm{p}} A$ via length-increasing queries, therefore by Lemma \\ref{le:honest auto} $A$ is $k$-${\\mathrm{tt}}$-autoreducible.\nFor a contradiction, assume that $A$ is $(k-1)$-${\\mathrm{T}}$-autoreducible. This means there exists an oracle Turing machine $M$ such that \n\n", "index": 59, "text": "\\begin{equation}\n\\forall x.\\; A[x] = M^A(x)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"\\forall x.\\;A[x]=M^{A}(x)\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mi>x</mi></mrow><mo rspace=\"5.3pt\">.</mo><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>M</mi><mi>A</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nIt is easy to see that $\\alpha$ is defined in a way that if \n$X \\upharpoonright 0^n = G \\upharpoonright 0^n$ then $\\alpha (w) = A[w]$.\\\\\nOn the other hand, if $|w| \\geq n+k$ then $\\alpha (w) =  0$ all the time. Later when we define the \nextension function we guarantee that $A[w] = 0$ for all long queries, by forcing the right\nvalues into $G$, which implies $A[w] = \\alpha (w)$ for all queries. But before doing that, we run\n$M$ on input $0^n$ with $\\alpha$ as the oracle, and define ${\\mathrm{QUERY}}$ to be the set of all queries\nmade in this computation. We know that $|{\\mathrm{QUERY}}| \\le k-1$ therefore one of the following \ncases must happen:\n\\begin{enumerate}\n\\item $xz_k \\notin {\\mathrm{QUERY}}$.\n\\item $xz_k \\in {\\mathrm{QUERY}}$, and $\\exists 1 \\le l \\le k-1. \\; xz_l \\notin {\\mathrm{QUERY}}$.\n\\end{enumerate}\nDefine a bounded extension function $f$ based on the above cases. Given $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n)$ contains the pairs described below. For every $v$ which is the value of some element of ${\\mathrm{QUERY}}$, \n\\begin{enumerate}\n\\item If $vz_k \\notin {\\mathrm{QUERY}}$, then put $(vz_1 , 0)$,...,$(vz_{(k-1)} , 0)$ into $f$. In other words,\n$f$ forces $G[vz_l]$ to $0$ for every $1 \\le l \\le k-1$.\n\\item If $vz_k \\in {\\mathrm{QUERY}}$ then there must be some $1 \\le l \\le k-1$ such that $vz_l \\notin {\\mathrm{QUERY}}$. \nIn this case $f$ forces $G[vz_i] = 0$ for every $1 \\le i \\le k-1$ except for $i = l$ for which $G[vz_l] = 1$.\n\\end{enumerate}\nIt can be shown that if $G$ meets $f$ at $0^n$, i.e. if \\eqref{meeting conditions} holds, then \n$\\alpha (w) = A[w]$ for every $w \\in {\\mathrm{QUERY}}$. As a result, \n\n", "itemtype": "equation", "pos": 64314, "prevtext": "\nwhere $M$ runs in polynomial time, and makes at most $(k-1)$ queries on every input. Given $n$ and \n$X \\upharpoonright 0^n$, we define a function $\\alpha$ as follows.\\\\\nIf $w = vz_p$ and $|w| < n+k$ then\n", "index": 53, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      X[w] \\wedge {\\rm SAT}[v] & \\textrm{ if $1 \\le p \\le k-1$} \\\\\n      \\big[\\bigwedge_{l=1}^{k-1} {(1 - X[vz_l])} \\big] \\wedge {\\rm SAT}[v] & \n      \\textrm{ if $p = k$} \\\\\n      0 & \\textrm{otherwise}\\\\\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}X[w]\\wedge{\\rm SAT}[v]&amp;\\textrm{ if $1\\leq p\\leq k-1$}\\\\&#10;\\big{[}\\bigwedge_{l=1}^{k-1}{(1-X[vz_{l}])}\\big{]}\\wedge{\\rm SAT}[v]&amp;\\textrm{ %&#10;if $p=k$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>w</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mn>1</mn><mo>\u2264</mo><mi>p</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo maxsize=\"120%\" minsize=\"120%\">[</mo><mrow><mstyle displaystyle=\"false\"><msubsup><mo largeop=\"true\" mathsize=\"160%\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mstyle><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>X</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>v</mi><mo>\u2062</mo><msub><mi>z</mi><mi>l</mi></msub></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo maxsize=\"120%\" minsize=\"120%\">]</mo></mrow><mo>\u2227</mo><mrow><mi>SAT</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>p</mi><mo>=</mo><mi>k</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nNote that $\\alpha$ is not defined on $0^{n+k}$, but that is fine because we are using $\\alpha$ to compute \n$A[w]$ for $w$'s that are queried when the input is $0^{n+k}$, therefore $0^{n+k}$ will not be queried. Later we will define the extension function $f$ in a way that if $G$ meets $f$ at $0^n$ then $\\alpha(w) = A[w]$ for all queries.\\\\\nBefore defining $f$, we run $M$ on input $0^{n+k}$ with $\\alpha$ as the oracle instead of $A$, and define ${\\mathrm{QUERY}}$ \nto be the set of all queries made in this computation. We know that $M$ makes at most $k-1$ queries, therefore \n$|{\\mathrm{QUERY}}| \\le k-1$. This implies that for every $v \\neq 0^n$ which is the value of some element of ${\\mathrm{QUERY}}$ one of the following cases must happen:\n\\begin{enumerate}\n\\item $vz_k \\notin {\\mathrm{QUERY}}$\n\\item $vz_k \\in {\\mathrm{QUERY}}$ and $\\exists 1 \\le l \\le k-1 \\;.\\; vz_l \\notin {\\mathrm{QUERY}}$\n\\end{enumerate}\nGiven $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n)$ is defined as follows if ${\\rm SAT}[0^n] = 1$.\\\\\nFor every $v$ which is the value of some element of ${\\mathrm{QUERY}}$,\n\\begin{enumerate}\n\\item If $v = 0^n$, then add $(vz_2,1),...,(vz_{k-1},1)$ to $f$. In other words, $f$ forces $G[0^nz_i] = 1$ for $2 \\le i \\le k-1$.\n\\item If $v \\neq 0^n$ and $vz_k \\notin {\\mathrm{QUERY}}$, then add $(vz_1,0),...,(vz_{k-1},0)$ to $f$.\n\\item If $v \\neq 0^n$ and $vz_k \\in {\\mathrm{QUERY}}$, then there must be some $1 \\le l \\le k-1$ such that $vz_l \\notin {\\mathrm{QUERY}}$.\nIn this case $f$ forces $G[vz_i] = 0$ for every $1 \\le i \\le k-1$ except when $i = l$ for which we force $G[vz_l] = 1$.\n\\end{enumerate} \nTo complete the diagonalization we add one more pair to $f$ which is $(0^{n+k} , 1 - M^{\\alpha}(0^n))$. It is straightforward, and similar to what has been done in the previous theorem, to show that if $G$ meets $f$ at $0^n$ for some $n$ then $\\alpha$ and $A$ agree on every element of ${\\mathrm{QUERY}}$. Therefore $M^{\\alpha}(0^n) = M^A(0^n)$, which results in a contradiction. \nIt only remains to show that $G$ meets $f$ at $0^n$ for some $n$. This\ndepends on the details of the encoding used for ${\\rm SAT}$. If ${\\rm SAT}[0^n] = 1$ for infinitely many $n$'s, then $f$ satisfies the conditions in Lemma \\ref{extension function revised}. Therefore $G$ has to meet $f$ at $0^n$ for some $n$. On the other hand, \nif ${\\rm SAT}[0^n] = 0$ for almost all $n$, then we redefine $A$ as:\n\n", "itemtype": "equation", "pos": 69133, "prevtext": "\nIt is easy to see that if $X \\upharpoonright 0^n = G \\upharpoonright 0^n$ then $\\alpha (w) = A[w]$.\\\\\nIf $w = vz_p$ and $|w| \\geq n+k$, $\\alpha$ is defined as:\n", "index": 63, "text": "\n\\[ \\alpha(w) = \\begin{cases} \n      1 & \\textrm{ if $v = 0^n \\wedge 2 \\le p \\le k-1$} \\\\\n      0 & \\textrm{ if $v = 0^n \\wedge p = k$} \\\\\n      0 & \\textrm{otherwise}\\\\\n   \\end{cases} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\alpha(w)=\\begin{cases}1&amp;\\textrm{ if $v=0^{n}\\wedge 2\\leq p\\leq k-1$}\\\\&#10;0&amp;\\textrm{ if $v=0^{n}\\wedge p=k$}\\\\&#10;0&amp;\\textrm{otherwise}\\\\&#10;\\end{cases}\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><msup><mn>0</mn><mi>n</mi></msup><mo>\u2227</mo><mn>2</mn></mrow><mo>\u2264</mo><mi>p</mi><mo>\u2264</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>\u00a0if\u00a0</mtext><mrow><mi>v</mi><mo>=</mo><mrow><msup><mn>0</mn><mi>n</mi></msup><mo>\u2227</mo><mi>p</mi></mrow><mo>=</mo><mi>k</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05494.tex", "nexttext": "\nIt can be proved, in a similar way and by using the assumption that ${\\rm SAT}[0^n] = 0$ for almost all $n$, that $A$ is $k$-${\\mathrm{tt}}$-complete, $k$-${\\mathrm{tt}}$-autoreducible, but not $(k-1)$-${\\mathrm{T}}$-autoreducible. \n\\end{proof}\n\n\\section{Conclusion}\\label{sec:conclusion}\n\nWe conclude with a few open questions. \n\nFor some $k$, is there a $k$-tt-complete set for ${\\ensuremath{\\mathrm{NP}}}$ that is not\nbtt-autoreducible? We know this is true for ${\\rm EXP}$ \\cite{BFvMT00}, so\nit may be possible to show under a strong hypothesis on ${\\ensuremath{\\mathrm{NP}}}$.  We\nnote that by Lemma \\ref{le:honest auto} any construction of a\n$k$-tt-complete set that is not $k$-tt-autoreducible must not be\nhonest $k$-tt-complete. In fact, the set must be complete under\nreductions that are neither honest nor dishonest. On the other hand,\nfor any $k \\geq 3$, proving that all $k$-tt-complete sets for ${\\ensuremath{\\mathrm{NP}}}$\nare btt-autoreducible would separate ${\\ensuremath{\\mathrm{NP}}} \\neq {\\rm EXP}$.\n\nAre the 2-tt-complete sets for ${\\ensuremath{\\mathrm{NP}}}$ 2-tt-autoreducible? The answer to\nthis question is yes for ${\\rm EXP}$ \\cite{BuhTor05}, so in this case a\nnegative answer for ${\\ensuremath{\\mathrm{NP}}}$ would imply ${\\ensuremath{\\mathrm{NP}}} \\neq {\\rm EXP}$. We believe that\nit may be possible to show the 2-tt-complete sets are nonuniformly\n2-tt-autoreducible under the Measure Hypothesis -- first show they are\nnonuniformly 2-tt-honest complete as an extension of\n\\cite{Hitchcock:CRNPCS,BuhrmanHescottHomerTorenvliet:NonuniformReductions}.\n\nNguyen and Selman \\cite{NguyenSelman:STACS14} showed there is\nT-complete set for ${\\rm NEXP}$ that is not tt-autoreducible. Can we do\nthis for ${\\ensuremath{\\mathrm{NP}}}$ as well? Note that Hitchcock and Pavan\n\\cite{Hitchcock:CRNPCS} showed there is a T-complete set for ${\\ensuremath{\\mathrm{NP}}}$\nthat is not tt-complete.\n\n{\\bf Acknowledgment.} We thank A. Pavan for extremely helpful discussions.\n\n\\bibliographystyle{plain} \n\\bibliography{{} final}\n \n\n\n\n\n\n", "itemtype": "equation", "pos": 71737, "prevtext": "\nNote that $\\alpha$ is not defined on $0^{n+k}$, but that is fine because we are using $\\alpha$ to compute \n$A[w]$ for $w$'s that are queried when the input is $0^{n+k}$, therefore $0^{n+k}$ will not be queried. Later we will define the extension function $f$ in a way that if $G$ meets $f$ at $0^n$ then $\\alpha(w) = A[w]$ for all queries.\\\\\nBefore defining $f$, we run $M$ on input $0^{n+k}$ with $\\alpha$ as the oracle instead of $A$, and define ${\\mathrm{QUERY}}$ \nto be the set of all queries made in this computation. We know that $M$ makes at most $k-1$ queries, therefore \n$|{\\mathrm{QUERY}}| \\le k-1$. This implies that for every $v \\neq 0^n$ which is the value of some element of ${\\mathrm{QUERY}}$ one of the following cases must happen:\n\\begin{enumerate}\n\\item $vz_k \\notin {\\mathrm{QUERY}}$\n\\item $vz_k \\in {\\mathrm{QUERY}}$ and $\\exists 1 \\le l \\le k-1 \\;.\\; vz_l \\notin {\\mathrm{QUERY}}$\n\\end{enumerate}\nGiven $n$ and $X \\upharpoonright 0^n$, $f(X \\upharpoonright 0^n)$ is defined as follows if ${\\rm SAT}[0^n] = 1$.\\\\\nFor every $v$ which is the value of some element of ${\\mathrm{QUERY}}$,\n\\begin{enumerate}\n\\item If $v = 0^n$, then add $(vz_2,1),...,(vz_{k-1},1)$ to $f$. In other words, $f$ forces $G[0^nz_i] = 1$ for $2 \\le i \\le k-1$.\n\\item If $v \\neq 0^n$ and $vz_k \\notin {\\mathrm{QUERY}}$, then add $(vz_1,0),...,(vz_{k-1},0)$ to $f$.\n\\item If $v \\neq 0^n$ and $vz_k \\in {\\mathrm{QUERY}}$, then there must be some $1 \\le l \\le k-1$ such that $vz_l \\notin {\\mathrm{QUERY}}$.\nIn this case $f$ forces $G[vz_i] = 0$ for every $1 \\le i \\le k-1$ except when $i = l$ for which we force $G[vz_l] = 1$.\n\\end{enumerate} \nTo complete the diagonalization we add one more pair to $f$ which is $(0^{n+k} , 1 - M^{\\alpha}(0^n))$. It is straightforward, and similar to what has been done in the previous theorem, to show that if $G$ meets $f$ at $0^n$ for some $n$ then $\\alpha$ and $A$ agree on every element of ${\\mathrm{QUERY}}$. Therefore $M^{\\alpha}(0^n) = M^A(0^n)$, which results in a contradiction. \nIt only remains to show that $G$ meets $f$ at $0^n$ for some $n$. This\ndepends on the details of the encoding used for ${\\rm SAT}$. If ${\\rm SAT}[0^n] = 1$ for infinitely many $n$'s, then $f$ satisfies the conditions in Lemma \\ref{extension function revised}. Therefore $G$ has to meet $f$ at $0^n$ for some $n$. On the other hand, \nif ${\\rm SAT}[0^n] = 0$ for almost all $n$, then we redefine $A$ as:\n\n", "index": 65, "text": "\\begin{equation}\nA = \\Big[\\bigcup _{m = 1}^{k-1} {\\{xz_m \\;|\\; x \\in G_m \\cup {\\rm SAT} \\}}\\Big] \\cup \n    \\{xz_k \\;|\\; x \\in \\big[ \\cup _{m = 1}^{k-1}{\\overline{G_m}} \\big] \\cup {\\rm SAT} \\}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"A=\\Big{[}\\bigcup_{m=1}^{k-1}{\\{xz_{m}\\;|\\;x\\in G_{m}\\cup{\\rm SAT}\\}}\\Big{]}%&#10;\\cup\\{xz_{k}\\;|\\;x\\in\\big{[}\\cup_{m=1}^{k-1}{\\overline{G_{m}}}\\big{]}\\cup{\\rm&#10;SAT}\\}\" display=\"block\"><mrow><mi>A</mi><mo>=</mo><mrow><mrow><mo maxsize=\"160%\" minsize=\"160%\">[</mo><mrow><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>m</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><msub><mi>G</mi><mi>m</mi></msub><mo>\u222a</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">]</mo></mrow><mo>\u222a</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>x</mi><mo>\u2062</mo><mpadded width=\"+2.8pt\"><msub><mi>z</mi><mi>k</mi></msub></mpadded></mrow><mo rspace=\"5.3pt\" stretchy=\"false\">|</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mrow><mo maxsize=\"120%\" minsize=\"120%\">[</mo><mrow><msubsup><mo>\u222a</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mover accent=\"true\"><msub><mi>G</mi><mi>m</mi></msub><mo>\u00af</mo></mover></mrow><mo maxsize=\"120%\" minsize=\"120%\">]</mo></mrow><mo>\u222a</mo><mi>SAT</mi></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}]