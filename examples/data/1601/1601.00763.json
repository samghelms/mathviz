[{"file": "1601.00763.tex", "nexttext": "\n}\nClauses with the same name and the same number of arguments define a relation, namely a \\emph{predicate}.\nWith facts and rules defined, programmers can issue \\emph{queries}, which are formulas for the Prolog\nresolution system to solve. In accordance with our previous examples, a query could be \\texttt{grandparent(G,bill)}\nwhich is basically asking ``who are bill's grandparents?'' \n\nA Prolog program is a set of terms.\nThe Prolog resolution engine maintains an internal database of terms throughout program execution,\ntrying to resolve queries with facts and rules by logical inference. Essentially, computation in\nProlog is reduced to a searching problem. This is different from the commonly seen Turing machine\ncomputation model but the theoretical foundation of logic programming guarantees that Prolog is\nTuring complete~\\cite{tarnlund1977horn}.\n\n\\subsection{Obfuscation-Contributing Features}\\label{sec:oc-features}\n\\ignore{There are numerous language features of Prolog that provide obfuscation effects, e.g.,\nunification, backtracking, term indexing, tabling, and multi-stack, etc.\nIn {translingual obfuscation}\\ we elaborate the two most salient ones: \\textit{unification} and \\textit{backtracking}.\nConceptually these two features are part of the foundations of logic programming.}\n\n\\subsubsection{Unification}\nOne of the core concepts in automated logic resolution, hence in logic programming, is unification.\nEssentially it is a pattern-matching technique.\nTwo first-order terms $t_1$ and $t_2$ can be unified if there exists\na substitution $\\sigma$ making them identical, i.e., $t_1^\\sigma=t_2^\\sigma$.\nFor example, \\ignore{a logical variable $X$ can be unified with a constant $c$;}\ntwo terms $k(s(g),Y)$ and $k(X,t(k))$ are unified when\n$X$ is substituted by $s(g)$ and $Y$ is substituted by $t(k)$.\n\nUnification is one of the basises of Prolog's computation model.\nWe show this by example.\nThe following clause defines a simple ``increment-by-one'' procedure:\n\\begin{lstlisting}[language=Prolog]\ninc(Input,Output):-Output is Input+1.\n\\end{lstlisting}\nNow for a query \\texttt{inc(1,R)}, the Prolog resolution engine will first try to unify \\texttt{inc(1,R)} with \\texttt{inc(Input,Output)},\nwhich means \\texttt{Input} should be unified with \\texttt{1} and \\texttt{Output} should be unified with \\texttt{R}.\nOnce this unification succeeds, the original query is reduced to a subgoal \\texttt{Output is Input+1}. Since \\texttt{Input} is now unified\nwith \\texttt{1}, \\texttt{Input+1} is evaluated as \\texttt{2}. \nFinally \\texttt{Output} gets unified with \\texttt{2} (\\texttt{is/2} is the evaluate-and-unify operator predicate),\nmaking \\texttt{R} unified with \\texttt{2} as well.\n\nTo support unification, Prolog implements terms as vertices in directed acyclic graphs.\nEach term is represented by a \\texttt{<tag,content>} tuple, \nwhere \\texttt{tag} indicates whether the type of the term\nand \\texttt{content} is either the value of a constant or the address of\nthe term the variable is unified with.\n{Fig.}~\\ref{fig:uni-imp} is an example showing how Prolog may represent a term in memory~\\cite{ait-kaci_warrens_1991}.\n\\begin{figure}[t]\n  \\begin{tikzpicture}\n    \\tt\n    \\node[rectangle split, rectangle split parts=5, \n      draw, minimum width=6em,font=\\small,\n      rectangle split part align={left}] (t1)\n         {             \n           STR\\hspace*{1.5em}f/4\n           \\nodepart{two}\n           REF\n           \\nodepart{three}\n           REF\n           \\nodepart{four}\n           INT\\hspace*{2.1em}1\n           \\nodepart{five}\n           REF\n         };\n         \\coordinate[left=.75em of t1.north] (north1);\n         \\coordinate[left=.75em of t1.south] (south1);\n    \\draw (north1) -- (south1);\n    \\coordinate[right=1.05em of t1.north, yshift=-1.98em] (ref1start);\n    \\node[draw,circle,inner sep=1pt,fill] at (ref1start) {};\n    \\node[draw,circle,inner sep=1pt,fill,below=1.1em of ref1start] (ref3start) {};\n\n    \\coordinate[right=1.05em of t1.south, yshift=.62em] (ref2start);\n    \\node[draw,circle,inner sep=1pt,fill] at (ref2start) {};\n\n    \\node[rectangle split, rectangle split parts=1, \n      draw, minimum width=6em, font=\\small, \n      right=4em of ref1start, yshift=-.62em,\n      rectangle split part align={left}] (t2)\n         { REF\\hspace*{4em} };\n         \\coordinate[left=.75em of t2.north] (north2);\n         \\coordinate[left=.75em of t2.south] (south2);\n    \\draw (north2) -- (south2);\n    \\draw[->] (ref1start) to [out=0,in=180] (t2.west);\n    \\draw[->] (ref3start) to [out=0,in=180] (t2.west);\n\n    \\node[rectangle split, rectangle split parts=2, \n      draw, minimum width=6em, font=\\small, \n      right=4em of ref2start, yshift=.64em,\n      rectangle split part align={left}] (t3)\n         { \n           STR\\hspace*{1.5em}g/1\n           \\nodepart{two}\n           FLT\\hspace*{1.5em}3.2\n         };\n         \\coordinate[left=.75em of t3.north] (north3);\n         \\coordinate[left=.75em of t3.south] (south3);\n    \\draw (north3) -- (south3);\n    \\coordinate[yshift=.62em] (ref2end) at (t3.west);\n    \\draw[->] (ref2start) to [out=0,in=180] (ref2end);\n\n    \\node[rectangle split, rectangle split parts=5, \n      font=\\small,\n      right=.5em of t2,\n      rectangle split part align={left}] (t4)\n         {             \n           \\textrm{Meaning of the tags}\n           \\nodepart{two}\n           REF: \\textrm{reference (variable)}\n           \\nodepart{three}\n           STR: \\textrm{structure}\n           \\nodepart{four}\n           INT: \\textrm{integer}\n           \\nodepart{five}\n           FLT: \\textrm{floating point}\n         };\n    \n  \\end{tikzpicture}\n  \\caption{An example memory representation of term \\texttt{f(X,Y,1,g(3.2))} in Prolog, where both \\texttt{X} and \\texttt{Y} are unified with another variable which itself is un-unified.}\n  \\label{fig:uni-imp}\n\\end{figure}\n\n\n\n\nUnification makes data shapes in Prolog program memory dramatically different from C and much more obscure. \nThe graph-like implementation of unification \nposes great challenges to binary data shape analyses which\naim to recover high-level data structures from binary program \nimages~\\cite{Jones:1982:FAI:582153.582161,Ghiya:1996:TDC:237721.237724,Sagiv:1998:SSP:271510.271517,Cozzie:2008:DDS:1855741.1855759}. \nEven if some of the graph structures can be identified,\nthere is still a gap between this low-level representation and the logical organization of original data,\nwhich harshly tests attackers' reverse engineering abilities.\nUnification also complicates data access. \nTo retrieve the true value of a variable, the Prolog engine has to iterate the entire \nunification list. It is well known that static analysis is weak against loops and indirect memory access.\nAlso, the tags in the term tuples are encoded as bit fields, meaning that\nbit-level analysis algorithms are required to reveal the semantics of a binary compiled from Prolog code.\nHowever, achieving bit-level precision is another great technical challenge for both static and\ndynamic program analyses, mainly because of scalability issues~\\cite{sepp2011,Kettle:2008:BRA:1512464.1512474,Drewry:2007:FEA:1323276.1323277,yadegari2014}.\n\n\\subsubsection{Backtracking}\n\\begin{figure*}[!t]\n  \\centering\n  \\begin{minipage}[b][][t]{.45\\textwidth}\n    \\begin{minipage}[b][3.2cm][t]{.46\\textwidth}\n      \\begin{lstlisting}[basicstyle=\\ttfamily\\footnotesize]\nint foo(int sel, \n        int x, int y)\n{\n  int ret;\n  if(sel==1) \n    ret=x;\n  else\n    ret=y;\n  return ret;\n}\n      \\end{lstlisting}\n    \\end{minipage}\n    \\begin{minipage}[b]{.53\\textwidth}\n      \\centering\n      \\scalebox{.65}{\n        \\begin{tikzpicture}[node distance=1.9cm]\n          \\tt\n          \\tikzstyle{block} = [rectangle, draw, text width=6.7em, text centered]\n          \\tikzstyle{line} = [draw, -latex',line width=1pt]\n          \\node [block, text width=9em] (init) {foo(sel,x,y)};\n          \\node [block, below of=init, yshift=.5cm, text width=8em] (if) {if(sel == 1)};\n          \\node [block, below left of=if, xshift=-1em] (true) {ret = x};\n          \\node [block, below right of=if,xshift=1em] (false) {ret = y};\n          \\node [block, below left of=false,xshift=-1em] (ret) {return ret};\n          \\path [line] (init) -- (if);\n          \\path [line] (if) -- (true) node [near end, above, fill=white, inner sep=0em, yshift=.3em, xshift=-.6em] {\\sf true};\n          \\path [line] (if) -- (false) node [near end, above, fill=white, inner sep=0em, yshift=.3em, xshift=.6em] {\\sf false};\n          \\path [line] (true) -- (ret);\n          \\path [line] (false) -- (ret);\n          \\node [right of=ret, xshift=.5cm] {}; \n        \\end{tikzpicture}\n      }\n    \\end{minipage}\n  \\end{minipage}\\vrule\\hfill\n  \\begin{minipage}[b][][t]{.53\\textwidth}\n    \\begin{minipage}[b][2.5cm][t]{.25\\textwidth}\n      \\begin{lstlisting}[basicstyle=\\ttfamily\\footnotesize]\npfoo(Sel,X,Y,R) :-\n  (Sel =:= 1 ->\n     R is X);\n  (R is Y).\n      \\end{lstlisting}\n    \\end{minipage}\\hfill\n    \\begin{minipage}[b]{.75\\textwidth}\n      \\centering\n      \\scalebox{.65}{\n        \\begin{tikzpicture}[node distance=1.9cm]\n          \\tt\n          \\tikzstyle{block} = [rectangle, draw, text width=6.7em, text centered,]\n          \\tikzstyle{line} = [draw, -latex',line width=1pt]\n          \\node [block, text width=9.8em] (init) {pfoo(Sel,X,Y,R)};\n          \\node [block, right = 2.5cm of init] (lt5) {Sel =:= 1};\n          \\node [block, below of = init,yshift=0cm] (sr1) {{\\sf Unification:}\\\\R is X};\n          \\node [block, below of = sr1,xshift=-3em] (end) {\\sf Next Clause};\n          \\node [block, below of =lt5 ,yshift=0cm, text width=7em] (re) {\\sf Resolution\\\\Failure Handler};\n          \\node [block, right = of end, xshift=0em] (sr2) {{\\sf Unification:}\\\\R is Y};\n          \\node [block, right = of sr2,xshift=-2.5em,text width=5em] (fail) {\\sf Fail};\n\n          \\path [line] (init) -- (lt5);\n          \\path [line] (lt5) to node [fill=white, inner sep=0,above,yshift=1ex] {\\sf true} (sr1);\n          \\path [line,arrows=->>] (sr1) to node [fill=white, inner sep=0,above,yshift=1ex,text=black] {\\sf fail} (re);\n          \\path [line] (lt5) to node [fill=white, inner sep=0,above,text=black,xshift=1.2em] {\\sf false} (re);\n          \\path [line, dashed, arrows=->>] (re) to [bend left=20] node {} (sr2);\n          \\path [line, dashed] (re) to node {} (fail);\n          \\path [line, dashed] (sr1) to node [fill=white, inner sep=0,above,] {\\sf succeed} (end);\n          \\path [line, dashed] (sr2) to node [fill=white, inner sep=0,above,yshift=.5ex] {\\sf succeed} (end);\n          \\path [line,arrows=->>] (sr2) to [bend left=20] node [fill=white, inner sep=0,xshift=-1em,text=black] {\\sf fail} (re);\n        \\end{tikzpicture}\n      }\n    \\end{minipage}\n  \\end{minipage}\n  \\caption{Different control flows of C and Prolog binaries implementing the same algorithm, due to different execution models.\nIn the Prolog graph, dashed lines indicate indirect jumps and arrows with the same pattern indicate feasible paths through the resolution failure handler. Both control flow graphs are summarized from post-compilation binaries.}\\label{fig:example}\n\\end{figure*}\n\nDifferent from Prolog unification which mainly obfuscates program data,\nthe backtracking feature obfuscates the control flow.\nBacktracking is part of the resolution mechanism in Prolog.\nAs explained earlier, finding a solution for a resolvable formula is essentially\nsearching for a proper unifier, namely a substitution,\nso that the substituted formula can be expanded to consist of only facts\nand other formulas known to be true. \nSince there may be more than one solution for a unification problem instance, \nit is possible that the resolution process will unify two terms\nin the way that it makes resolving the formula later unfeasible. \nAs a consequence,\nProlog needs a mechanism to roll back from an incorrect proof path, which is called\nbacktracking.\n\nTo make backtracking possible, Prolog saves the program state before taking one\nof the search branches. This saved state is called a ``choice-point'' by Prolog\nand is similar to the concept of ``continuation'' in functional programming.\nWhen searching along one path fails, the resolution engine will restore the \nlatest choice-point and continue to search through one of the untried branches.\n\nThis \\emph{search-and-backtrack} execution model leads to a totally different control flow scheme in\nProlog programs at the low level, compared to programs in the same logic written by C.\n{Fig.}~\\ref{fig:example} is an example where a C function is transformed into a Prolog clause by our tool \n{\\textsc{Babel}}\\ (with manual edits to make the code more readable), along with\nthe program execution flows before and after {\\textsc{Babel}}\\ transformation. \nThe real control flow of the Prolog version of the function is much more complicated than presented,\nand we have greatly simplified the flow chart for readability.\nIn the Prolog part of {Fig.}~\\ref{fig:example}, a choice point is created\nright after the execution flow enters the predicate \\texttt{pfoo}\nwhich is a disjunction of two subclauses. \nThe Prolog resolution routine will first try to satisfy the first subclause.\nIf it fails, the engine will backtrack to the last choice-point\nand try the second subclause.\n\nDue to the complicated backtracking model, a large portion of control flow transfers in\nProlog are indirect.\nThe implementation of backtracking also involves techniques such as\nlong jump and stack unwinding. \nClearly, Prolog has a much more obscure low-level execution model compared to C, and\nimperative programming in general, from\nthe perspective of static analysis.\nDifferent from some other control flow obfuscation techniques that inject fake control flows \nwhich are never feasible at run time,\nProlog's backtracking actually happens during program execution,\nmaking {translingual obfuscation}\\ also resilient to dynamic analysis.\nMost importantly, after the C-to-Prolog translation\nthe original C control flows are reformed with a completely different programming paradigm,\nwhich is fundamentally different from existing control-flow based obfuscation techniques.\n\n\\section{Technical Challenges}\n\\label{sec:cpob}\nTo make use of Prolog's execution model for obfuscating C programs,\nwe need a translation technique to forge the Prolog counterpart of a C function.\nAt this point, there are various challenges to resolve. \n\n\\subsection{Control Flow}\nAs an imperative programming language,\nC provides much flexibility of crafting program control \nflows almost with language key words such as continue, break, and return. \nProlog programs, however, have to follow the general evaluation procedure of logical \nformulas, which inherently forbids some ``fancy'' control flows allowed by C. \n\n\\subsection{Memory Model}\nIn C programming, many low-level details are not opaque to programmers.\nAs for memory manipulation, C programmers can access almost arbitrary memory locations via pointers.\nProlog lacks the semantics to express direct memory access. \nMoreover, the C memory model is closely coupled with other sub-structures of the language, \ne.g., the type system. C types are not only logical abstractions but are also implications on\nlow-level memory layouts of the data.\nFor instance, logically adjacent elements in a C array and fields in a C struct are \nalso physically adjacent in memory. \nTherefore, some logical operations on C data structures can be implemented as direct memory \naccesses which are semantically equivalent only with the C memory modeling. \nBelow is an example.\n\\begin{lstlisting}\nstruct ty { \n int a;\n int b; \n} s[2];\n\n/* Equivalent to s[0].a=s[0].b=s[1].a=0;\n * with many compilers and architectures */\nmemset((void*)s, 0, 3*sizeof(int));\n\\end{lstlisting}\nTranslating the code snippet above into pure Prolog could be difficult\nbecause the translator will have to infer the logic effects of the \\texttt{memset} statement. \n\n\\subsection{Type Casting}\nC type casting is of full flexibility in the sense that a C programmer can cast any type to any other type,\nno matter the conversion makes sense or not.\nThis can be realized by violating the \\textit{load-store consistency}, \nnamely storing a variable of some type into a memory location and later loading the content of the same chunk of memory into a variable of another type. \nThe C union type is a high-level support for type castings that breaks the load-store consistency,\nbut C programmers can choose to use pointers to directly achieve the same effect.\nImitating this type casting system could be a notable challenge for other languages.\n\n\\section{C-to-Prolog Translation}\\label{sec:design}\nThis section explains how we address the challenges mentioned in the\nprevious section.\n{\\shortlong{}{{Considering the many obstacles for developing a complete translation from  C to Prolog, we do not seek to obtain a pure Prolog version  of the original C program. The section explains how we address the challenges mentioned in the previous section and how we develop a partial C-to-Prolog translation method, which is suitable for {translingual obfuscation}.}}}\n\n\\subsection{Control Flow Regularization}\\label{sec:cfr}\nThere has been a large amount of research on refining C program control flows,\nespecially on eliminating goto statements~\\cite{knuth1971notes,ramshaw1988eliminating,williams1985restructuring}.\nFor now, we consider that goto elimination is a solved problem and assume\nthe C programs to be protected do not contain goto statements.\nGiven a C function without goto statements,\nthere are two control flow patterns that cannot be directly\nadopted by Prolog programming, i.e., control flow cuts and loops. \nWe call these patterns \\emph{irregular} control flows.\n\n\\subsubsection{Control Flow Cuts}\nControl flow cuts refer to the termination of control flows in the middle of a C function,\nfor example:\n\\begin{lstlisting}\nint foo (int m, int n) {\n if(m) \n  return n; // Flow of if branch ends\n else\n  n=n+1;\n n=n+2;\n return n;  // Flow of else branch ends\n}\n\\end{lstlisting}\n\nThe C language grants programmers much freedom in building control flows,\neven without using goto statements.\nIn Prolog, however, control flows have to be routed based on the short-circuit rules in evaluating logical expressions.\nWith short-circuit effects,\nparallel statements can be connected by disjunction and sequential statements\ncan be connected by conjunction.\nTo show why the control flow pattern in the C code above cannot be implemented by only adopting short-circuit rules,\nconsider a C function with body \\mbox{\\texttt{\\{if(e) \\{a;\\} else \\{b;\\} c;\\}}}.\nNaturally, it should be translated into a Prolog sentence \\texttt{(((e->a);b),c)},\nwhere \\texttt{->} denotes implication, \n\\texttt{;} denotes disjunction, \nand \\texttt{,} denotes conjunction.\nHowever, this translation is not semantics-preserving when \\texttt{a} is a return statement,\nbecause if the clause \\texttt{a} is evaluated, at least one of \\texttt{b} and \\texttt{c} has to be evaluated \nto decide the truth of the whole logic formula.\n\nWe fix control flow cuts by\nreplicating and/or reordering basic blocks syntactically subsequent to the cuts.\nFor example, we rewrite the previously shown C function into the following structure:\n\\begin{lstlisting}\nint foo (int m, int n) {\n if(m)\n  return n;\n else {\n  n=n+1;\n  { n=n+2; return n; }\n }\n}\n\\end{lstlisting}\nAfter the revision, the C code is naturally translated into a new Prolog clause\n\\texttt{(e->a);(b,c)}, which is consistent with the original C semantics.\n\n\\subsubsection{Loops}\nMost loops cannot be directly implemented in Prolog.\nThe fundamental reason is that Prolog does not allow\nunifying a variable more than once.\nWe can address this problem by transforming loops into recursive functions,\nbut in-loop irregular control flows complicate the situation.\nThe irregularity comes from the use of keywords ``continue'' and ``return.'' \nA continue statement cuts the control flow in the middle of a loop, \nbringing up a problem similar to the aforementioned asymmetric returns in functions.\nAs such, irregular control flows resulting from continue statements can be regularized in the same way,\ni.e., replicating and/or reordering basic blocks syntactically subsequent to continue statements.\n\nLike a continue statement, a return statement also cuts the control flow in a loop, but its impact\nreaches outside because it cuts the control flow of the function enclosing the loop.\nHence, a recursive Prolog predicate transformed from a loop needs an extra argument to carry \na flag indicating whether an in-loop return has occurred.\n\n\\subsection{C Memory Model Simulation}\nAs stated in \\S\\ref{sec:cpob}, the C memory model is closely coupled\nwith other parts of the language and it is hard to separate them.\nHowever, {translingual obfuscation}\\ keeps the original C memory model,\nmaking preserving semantic equivalence much easier.\nIn our design, the Prolog runtime is embedded in the C execution environment,\nso it is possible for Prolog code to directly operate memories within a program's address space. \n\nThe way we handle C memory simulation illustrates the advantage of developing language \ntranslations for obfuscation purposes.\nUnlike tools seeking complete translation from C to other languages,\n{translingual obfuscation}\\ does not have to mimic C memory completely with target language features (e.g., converting C pointers to Java references~\\cite{demaine1998c}),\nmeaning we can reduce translation complexity and circumvent various limitations.\nThat being said,\npartially imitating the C memory model in Prolog is still a non-trivial task.\n\n\\subsubsection{Supporting C Memory-Access Operators}\nThe first step to simulating the C memory model is to support pointer operations.\nWe introduce the following new clauses into our target Prolog language:\n\\begin{lstlisting}[language=Prolog]\nrdPtrInt(+Ptr, +Size, -Content)\nwrPtrInt(+Ptr, +Size, +Content)\nrdPtrFloat(+Ptr, +Size, -Content)\nwrPtrFloat(+Ptr, +Size, +Content)\n\\end{lstlisting}\nThese clauses are implemented in C. \\texttt{rdPtrInt/3} and \\texttt{rdPtrFloat/3} allow us to load \nthe content of a memory cell (address and size indicated by \\texttt{Ptr} and \\texttt{Size}, respectively) into a Prolog variable \\texttt{Content}.\nSimilarly, \\texttt{wrPtrInt/3} and \\texttt{wrPtrFloat/3} can write the content of a Prolog variable \ninto a memory cell.\nThese four clauses simulate the behaviors of the ``pointer dereference'' operator (\\texttt{*}) in C.\n\nIn addition to read-from-pointer and write-to-pointer operations, C also\nhas the ``address-of'' operator which takes an lvalue, i.e., an expression that is allocated a\nstorage location, as the operand and returns\nits associated storage location, namely address. There is no need to explicitly support this\noperator in Prolog because the address of any lvalue in C has a static representation\nwhich is known by the compiler.\\footnote{For example, a local variable is usually\nallocated on the stack and the compiler will have a static expression of its address.\nOn x86, the expression is likely to be \\texttt{\\$offset(\\%ebp)} or \\texttt{\\$offset(\\%esp)},\nwhere \\texttt{\\$offset} is a constant. Compilers can also decide how to statically represent\nthe addresses of global variables.}\nWe can obtain the results of ``address-of'' operations \nin the C environment and pass those values into the Prolog environment as arguments.\n\nWe also handle several C syntax sugers related to memory access:\n``subscript'' (\\texttt{[]}) and ``field-of'' (\\texttt{.} and \\texttt{->}).\nWe convert these operators into equivalent combinations of pointer arithmetic and dereference\nso that we do not need to coin their counterparts in Prolog. \nThis conversion requires assumptions on compiler implementation and target architecture to calculate type sizes and\nfield displacements. \n\n\\subsubsection{Maintaining Consistency}\nIt is a natural scheme that a C-to-Prolog translation maps every C \nvariable to a corresponding Prolog variable. \nProlog does not allow variable update,\nbut we can overcome this restriction by transforming C code into a form close to \nstatic single assignment (SSA), \nin which variables are only initialized at one program location and never updated.\nIn the strict SSA form, variables can only be statically initialized once \neven if the scopes are disjoint.\nProlog does not require this because the language checks re-unification at run time, \nmeaning variables can be updated in exclusively executed parts of the program,\ne.g., the ``then'' and ``else'' branches of the same if statement.\nTherefore, we do not need to implement the $\\phi$ function in our SSA transformation.\n\nThe SSA transformation can be implemented by renaming variables.\nThe challenging part is that simply renaming variables \nin the original C code could break program semantics because \nof side effects caused by memory operations, i.e., variable contents can \nbe accessed without referring to variable names.\nThis is the consistency problem we have discussed earlier.\n{Fig.}~\\ref{fig:side-effects} shows an instance of the problem.\n\n\\newsavebox{\\firstlisting}\n\\begin{lrbox}{\\firstlisting}\n\\begin{minipage}{0.47\\linewidth}\n\\begin{lstlisting}[basicstyle=\\ttfamily\\footnotesize]\na=0;\np=&a;// p points to a\na=1; // a gets 1\nb=*p;// b gets a(1)\n\nc=0;\np=&c;\nc=1; // c gets 1\n*p=3;// c gets 3\nd=c; // d gets c(3)\n\\end{lstlisting}\n\\end{minipage}\n\\end{lrbox}\n\\newsavebox{\\secondlisting}\n\\begin{lrbox}{\\secondlisting}\n\\begin{minipage}{0.51\\linewidth}\n\\begin{lstlisting}[frame=leftline,basicstyle=\\ttfamily\\footnotesize]\na1=0;\np1=&a1;// p1 points to a1\na2=1;  // a2 gets 1\nb1=*p1;// b1 gets a1(0)\n\nc1=0;\np2=&c1;// p2 points to c1\nc2=1;  // c2 gets 1\n*p2=3; // c1 gets 3\nd1=c2; // d1 gets c2(1)\n\\end{lstlisting}\n\\end{minipage}\n\\end{lrbox}\n\\newsavebox{\\thirdlisting}\n\\begin{lrbox}{\\thirdlisting}\n\\begin{minipage}{0.13\\linewidth}\n\\begin{lstlisting}[basicstyle=\\ttfamily\\footnotesize]\n\n\n\na=0;     \np=&a;\na=1;\n\nb=*p;\n\nc=0;\np=&c;\nc=1;\n*p=3;\n\nd=c;\n\n\\end{lstlisting}\n\\end{minipage}\n\\end{lrbox}\n\\newsavebox{\\forthlisting}\n\\begin{lrbox}{\\forthlisting}\n\\begin{minipage}{0.32\\linewidth}\n\\begin{lstlisting}[frame=leftline,basicstyle=\\ttfamily\\footnotesize]\npa=&a;\npc=&c;\n\na=0;\np=&a;\na=1;\n*pa=a;// Flush\nb=*p;\n\nc=0;\np=&c;\nc=1;\n*p=3;\nc=*pc;// Reload\nd=c;\n\\end{lstlisting}\n\\end{minipage}\n\\end{lrbox}\n\\newsavebox{\\fifthlisting}\n\\begin{lrbox}{\\fifthlisting}\n\\begin{minipage}{0.50\\linewidth}\n\\begin{lstlisting}[frame=leftline,basicstyle=\\ttfamily\\footnotesize]\npa=&a1;// const pointer\npc=&c1;// const pointer\n\na1=0;\np1=&a1;\na2=1;  // a2 gets 1\n*pa=a2;// a1 gets a2(1)\nb1=*p1;// b1 gets a1(1)\n\nc1=0;\np2=&c1;\nc2=1;\n*p2=3; // c1 gets 3\nc3=*pc;// c3 gets c1(3)\nd1=c3; // d1 gets c3(3)\n\\end{lstlisting}\n\\end{minipage}\n\\end{lrbox}\n\n\\begin{figure}[!t]\n  \\vspace*{-12pt}\n  \\subfloat[\\scriptsize Original]{\\usebox{\\firstlisting}}\\label{fig:side-effects-orign}\\hfill\n  \\subfloat[\\scriptsize Renamed]{\\usebox{\\secondlisting}}\\label{fig:side-effects-after}\n  \\caption{Memory operations affecting the correctness of C source code SSA renaming.}\\label{fig:side-effects}\n\n\n\n  \\subfloat[\\scriptsize Orig.]{\\usebox{\\thirdlisting}}\\label{fig:flush-reload-origin}\\hfill\n  \\subfloat[\\scriptsize With flush and reload]{\\usebox{\\forthlisting}}\\label{fig:flush-reload-insert}\\hfill\n  \\subfloat[\\scriptsize Renamed with flush and reload]{\\usebox{\\fifthlisting}}\\label{fig:flush-reload-ssa}\n  \\caption{Semantic-preserving SSA renaming on C source code with the presence of pointer operations.}\n  \\label{fig:flush-reload}\n\\end{figure}\n\nTo address this issue,\nwe keep the addresses of local variables and parameters if they are possibly accessed via pointers.\nThen we flush variable contents back to the memory before a read-from-pointer operation and reload\nvariable contents from the memory after a write-to-pointer operation.\nInter-procedural pointer dereferences are also taken into account.\nWhen callee functions accept pointers as arguments,\nwe do variable flush before function calls and do variable reload after.\nThe flush makes sure that changes made by Prolog code are committed to the underlying C memory before they are read again.\nSimilarly, the reload assures that values unified with Prolog logical variables are always consistent with the content in C memory.\n\n\nWe perform a sound points-to analysis to compute the set of variables that need to be reloaded or flushed at each program point.\nAfter inserting the flush and reload operations, \nthe SSA variable renaming no longer breaks the original program semantics.\n\n\n{Fig.}~\\ref{fig:flush-reload} illustrates our solution based on the example in {Fig.}~\\ref{fig:side-effects}.\n\n\\subsection{Supporting Other C Features}\n\n\\subsubsection{Struct, Union, and Array} \nIn \\S\\ref{sec:cpob}, we showed that C data types \nlike struct and array can be manipulated via memory access.\nSince we have already built support for the C memory model in Prolog, \nthe original challenge now becomes a shortcut to supporting C struct, union, and array.\nWe simply transform the original C code and implement all \noperations on structs, unions, and arrays through pointers. \nAfter this transformation the primitive data types provided by Prolog are enough to represent any C data structure.\n\n\n\\subsubsection{Type Casting} \nWith our C memory simulation method, \nsupporting type castings performed via pointers does not require additional effort, \neven if they may violate the load-store consistency.\nAs for explicit castings, e.g., from integers to floating points, we utilize the\nbuilt-in Prolog type casting clauses like \\texttt{float/1}.\n\n\n\\subsubsection{External and Indirect Function Call}\nSince the source code of library functions is usually unavailable, \ntranslating them into Prolog is not an option. \nIn general, translations of {translingual obfuscation}{} can support external subroutine invocation with the help of foreign language interfaces.\nAs for C+Prolog obfuscation, most Prolog implementations provide the interface for calling C functions from a Prolog context.\nThe same interface can also be used to invoke functions via pointers.\n\n\\subsection{Obfuscating Translation}\n\\label{sec:oc-translate}\nOur translation scheme fully exploits the obfuscation-contributing features introduced \nin \\S\\ref{sec:oc-features}, generally because:\n\\begin{itemize}\n\\item The conversion from C data structures to Prolog data structures happens by default,\nand every C assignment is translated to Prolog unification.\n\\item Intra-procedural control-flow transfers originally coded in C are now implemented by Prolog's backtracking mechanism.\nThis significantly complicates the low-level logic of the resulting binaries.\n\\end{itemize}\n\nEspecially, we would like to highlight the method we use to support the C memory model in Prolog.\nAt the high level, the original C memory layout is kept after the translation. However,\nthe behavior of the C-part memory becomes much different from the original program.\nTo maintain the consistency between the C-side memory and Prolog-side memory, we introduce\nthe flush-reload method which disturbs the sequence of memory access.\nIn this way, the memory footprint of the obfuscated program is no longer what it was during\nprogram execution.\n\nWe believe our translation method is one of the factors that make {translingual obfuscation}\\ resilient to\nboth semantics-based and syntax-based binary diffing, as will be shown in \\S\\ref{sec:resilience}.\n\n\n\n\\section{Implementation of {\\textsc{Babel}}}\n\\label{sec:impl}\n\\ignore{In this section, we present the implementation of {\\textsc{Babel}}, a prototype of {translingual obfuscation}.}\n\n\n{\\textsc{Babel}}\\ is our {translingual obfuscation}\\ prototype.\nThe workflow of {\\textsc{Babel}}\\ has three steps: \nC code preprocessing, \nC-to-Prolog translation, and C+Prolog compilation.\nThe preprocessing step reforms the original C source code \nso that the processed program becomes suitable for line-by-line translation to Prolog. \nThe second step translates C functions to Prolog predicates.\nIn the last step, {\\textsc{Babel}}\\ combines C and Prolog code together with a carefully designed interface.\n\nWe choose GNU Prolog~\\cite{diaz2001} as the Prolog implementation to employ in {\\textsc{Babel}}.\nLike many other Prolog systems, GNU Prolog compiles Prolog source into the ``standard'' Warren Abstract Machine (WAM)~\\cite{warren1983} instructions.\nWhat is desirable to us is that GNU Prolog can further compile WAM code into native code. \nThis feature makes {\\textsc{Babel}}\\ more distinguishable from virtualization-based obfuscation tools\nwhich compile the original program to bytecode and execute it with a custom virtual machine.\n\n\n\\subsection{Preprocessing and Translating C to Prolog}\nBefore actually translating C to Prolog, we need to preprocess the C code first.\nThe preprocessing includes the following steps, which is done with the help of the CIL library~\\cite{CIL}.\n\\begin{enumerate}\n\\item Simplify C code into the three-address form without switch statements and ternary conditional expressions.\n\\item Convert loops to tail-recursive functions.\n\\item Eliminate control flow cuts. \n\\item Transform operations on global, struct, union, and array variables into pointer operations.\n\\item Perform variable flush and reload whenever necessary. \n\\item Eliminate all memory operators except pointer dereferences. \n\\item Rename variables so that the C code is in a form close to SSA.\n\\end{enumerate}\n\nAfter preprocessing, we can translate C to Prolog line by line. \nThe translation rules are listed in {Fig.}~\\ref{fig:trans-rules}. \nNote that by the time we start translating C to Prolog, \nthe preprocessed C code does not contain any switch and loop statements, \nbecause they are transformed into either nested if statements or recursive functions. \nAs discussed in \\S\\ref{sec:cfr}, we do not consider goto statements.\n\nWe take translating arithmetic and logical expressions as a trivial task, \nbut that leads to a limitation in our translation.\nDue to the fact that Prolog does not subdivide integer types,\ninteger arithmetics in Prolog are not equivalent to their C counterparts.\nFor example, given two C variables \\texttt{x} and \\texttt{y} of type \\texttt{int} (4 bytes long) and\ntheir addition \\texttt{x+y}, the equivalent expression in Prolog should be\n\\texttt{(X+Y){/\\symbol{92}}0xffffffff}, assuming that \\texttt{X} and \\texttt{Y} are the corresponding logical variables of \\texttt{x} and \\texttt{y}. \nTherefore, if a C program intentionally relies on integer overflows or underflows,\nthere is a chance that our translation will fail.\nHowever, fully emulating C semantics incurs significant performance penalty.\n\nPrevious work on translating C to other languages faces the same issue, \nand many of them chose to ignore it~\\cite{Buddrus:1998:CMC:330560.331015, martin_strategies_2001,trudel_c_2012}.\nThe C-to-JavaScript converter Emscripten provides the option to fully emulate the C semantics~\\cite{zakai_emscripten:_2011}.\nIt also has a set of optional heuristics to infer program points\nwhere full emulation is necessary, but that method is not guaranteed to work correctly.\nWe do not particularly take this issue into account when implementing {\\textsc{Babel}}. \nHowever, we expect {\\textsc{Babel}}'s translation to have a low failure chance thanks to the employment\nof write-to-pointer operations in Prolog and the variable flush-reload method. \nSince the write-to-pointer operation specifies data sizes, \nthe truncation automatically takes place whenever an integer variable is flushed and reloaded.\nIn GNU Prolog on 64-bit platforms,\nall integers are represented by 61-bit two's complement (3 bits are occupied by a WAM tag),\nwhich is large enough to hold most practical integer and\npointer\\footnote{Most 64-bit CPUs only implement a 48-bit virtual address space.} values.\n\n\n\n\\begin{figure*}[!ht]\n  \\centering\n\\resizebox{\\textwidth}{!}{\n\\tt\n  \\begin{tabular}{llll}\n    \\rm{Assignment} &  (foo = $e$;)$^\\mathcal{T}$ & $\\rightarrow$ & (Pfoo is $e^\\mathcal{T}$) \\\\\n    \\rm{Pointer arithmetic}  & (p2 = p1 + intVal;)$^\\mathcal{T}$ | $\\mathrm{TypeOf}$(p1) = $T$* & $\\rightarrow$ &  ($\\sigma(\\mbox{p2})$ is $\\sigma(\\mbox{p1})$ + $\\mathrm{SizeOf}$($T$) * $\\sigma(\\mbox{intVal})$)\\\\\n    \\rm{Pointer dereference} & (foo = *p;)$^\\mathcal{T}$ | $\\mathrm{TypeOf}$(p) = $T$* & $\\rightarrow$ & rdPtr($\\sigma(\\mbox{foo})$, $\\mathrm{\\mathrm{SizeOf}}$($T$), $\\sigma(\\mbox{p})$) \\\\\n    \\rm{Write by pointer} & (*p = foo;)$^\\mathcal{T}$ | $\\mathrm{TypeOf}$(p) = $T$* & $\\rightarrow$ & wrPtr($\\sigma(\\mbox{p})$, $\\mathrm{SizeOf}$($T$), $\\sigma(\\mbox{foo})$) \\\\\n    \\rm{Empty Block} & (\\{\\})$^\\mathcal{T}$ & $\\rightarrow$ & (true) \\\\\n    \\rm{Non-empty Block} & (\\{$s_1 \\cdots s_n$\\})$^\\mathcal{T}$ & $\\rightarrow$ & ($s_1^\\mathcal{T}$, $\\cdots$, $s_n^\\mathcal{T}$) \\\\\n    \\rm{Conditional} &  (if ($e$) \\{$b_{then}$\\} else \\{$b_{else}$\\})$^\\mathcal{T}$ & $\\rightarrow$ & ($e^\\mathcal{T}$, \\{$b_{then}$\\}$^\\mathcal{T}$; \\{$b_{else}$\\}$^\\mathcal{T}$) \\\\\n    \\rm{Function call} &  (ret = fun(a1, $\\cdots$, an);)$^\\mathcal{T}$ & $\\rightarrow$ & predFun($\\sigma(\\mbox{a1})$, $\\cdots$, $\\sigma(\\mbox{an})$, $\\sigma(\\mbox{ret})$)\\\\\n    \\rm{Indirect function call} &  (ret = funptr(a1, $\\cdots$, an);)$^\\mathcal{T}$ & $\\rightarrow$ & predIndFun($\\sigma(\\mbox{funptr})$, $\\sigma(\\mbox{a1})$, $\\cdots$, $\\sigma(\\mbox{an})$, $\\sigma(\\mbox{ret})$)\\\\\n    \\rm{Function return} &  (return $e$;)$^\\mathcal{T}$ & $\\rightarrow$ & ($\\mathcal{R}$ is $e^\\mathcal{T}$)\\\\\n    \\rm{Function definition} & (fun($T_1$ a1, $\\cdots$, $T_n$ an) \\{$b_{body}$\\})$^\\mathcal{T}$ & $\\rightarrow$ & predFun($\\sigma(\\mbox{a1})$, $\\cdots$, $\\sigma(\\mbox{an})$) :- $b_{body}^\\mathcal{T}$.\n  \\end{tabular}\n}\n  \\caption{Definition of $\\mathcal{T}$, {\\textsc{Babel}}'s C-to-Prolog translation. $e$, $s$, $b$, and $T$ denote C expressions, statements, blocks, and types, respectively. $\\sigma$ is the bijective mapping from C identifiers to corresponding Prolog identifiers. $\\mathcal{R}$ denotes the Prolog identifier used to hold the returned value in the translated predicate. \\texttt{predFun} can be either a real Prolog predicate or a wrapper of a foreign C function, depending on whether the target function is translated or not. \\texttt{predIndFun} is a wrapper for a special foreign C function which further calls into \\texttt{funptr} with given arguments.}\n  \\label{fig:trans-rules}\n\\end{figure*}\n\n\\subsection{Combining C and Prolog}\n\n\\shortlong\n{\\input{combining-short.tex}}\n{\\input{combining-long.tex}}\n\n{\\textsc{Babel}}\\ combines the C and Prolog runtime environments together, \nand the program starts from executing C code.\nWhen the execution encounters an obfuscated function\n(which is now a wrapper for initiating queries to the corresponding Prolog predicate),\nit setups a context prior to evaluating the Prolog predicate. \nIn the setup process the wrapper\nallocates local variables whose addresses are referred to in the preprocessed C function. \nThe wrapper then passes the addresses along with function arguments to the Prolog predicate \nthrough the C-to-Prolog interface provided by GNU Prolog.\n{Fig.}~\\ref{fig:context} illustrates how the two languages are combined.\n\n\n\\subsection{Customizing Prolog Engine}\nAlthough GNU Prolog has some nice features that make it a mostly adequate candidate for\nimplementing {\\textsc{Babel}},\nit still does not fully satisfy our requirements, thus requiring some customization. \n\nA notable issue about GNU Prolog is that its\ninterface for calling Prolog from C is not reentrant. \nThis is critical because by design, users of {\\textsc{Babel}}\\ can freely \nchoose the functions they want to obfuscate. \nTo support this,\nit is in general not possible to avoid stack traces that interleave C and Prolog\nsubroutines. We found that the non-reentrant issue results from the use of a global WAM\nstate across the whole GNU Prolog engine. We fixed it by maintaining \na stack to save the WAM state before a new C-to-Prolog interface invocation and\nrestore the state after the call is finished.\n\n\n\n\nAnother issue is that GNU Prolog does not implement garbage collection;\ntherefore memory consumption can easily explode.\nThis problem is not as severe as it looks because\nwe do not have to maintain a heap for Prolog runtime throughout the lifetime of the program.\nBecause we know that the life cycles of all Prolog variables are bounded by the scope of predicates, \nwe can safely empty the Prolog heap when there are no pending Prolog subroutines during the execution.\nSince GNU Prolog implements the heap as a large global\narray and indicates heap usage with a heap-top pointer, we can empty the heap by simply \nresetting the heap-top pointer to the starting point of the heap array, which is very efficient.\n\n\n\\section{Evaluation}\\label{sec:eval}\nCollberg et al.~\\cite{Collberg1998} proposed to evaluate an\nobfuscation technique with respect to four dimensions: \\emph{potency},\n\\emph{resilience}, \\emph{cost}, and \\emph{stealth}.\nPotency measures how obscure and complex the program has become after being obfuscated.\nResilience indicates how well programs obfuscated by {\\textsc{Babel}}\\ can withstand reverse engineering effort,\nespecially automated deobfuscation.\nCost measures the execution overhead imposed by obfuscation.\nStealth measures the difficulty in detecting the existence of obfuscation, given the obfuscated binaries.\nWe evaluate {\\textsc{Babel}}\\ and observe to what extent it meets these four criteria.\n\n\n\n\n\n\n\nTo show that our tool can effectively protect real-world software of different categories,\nwe apply {\\textsc{Babel}}\\ to six open source C programs that have been widely deployed for years or even decades.\nAmong the six programs, four are CPU-bound applications and the other two are IO-bound servers.\nThe CPU-bound applications include algebraic transformation (bzip2), integer computation (mcf), \nstate machine (regexp), and floating-point computation (svm\\_light).\nThe two IO-bound servers cover two of the most popular network protocols, i.e., FTP (oftpd) and HTTP (mongoose).\nWe believe that our selection is a representative evaluation set covering a wide\nrange of real-world software.\nTable~\\ref{tab:snd-eval-set} presents the details of these programs.\\footnote{\nWe notice that some previous work~\\cite{Chen:2009:CFO:1669112.1669162} on obfuscation employed the SPEC benchmarks or GNU Coreutils,\nwhich are also widely used in other research,\nfor evaluation. Unfortunately, these two software suites \nuse very complicated build infrastructures. Since {\\textsc{Babel}}\\ needs to compile C and Prolog together,\na specialized build procedure is required. Currently our prototypical implementation of {\\textsc{Babel}}\\ cannot\nautomatically hook an existing build system, so we are not able to include SPEC or GNU Coreutils into\nour evaluation.}\n\nWe define the term \\textit{obfuscation level} as the percentage of \nfunctions obfuscated in a C program.\nFor example, an obfuscated bzip2 instance at the 20\\% obfuscation level is a bzip2 \nbinary compiled from source code consisting of 80\\% of the original functions in C and \nProlog predicates translated from the other 20\\% C functions by {\\textsc{Babel}}.\n\\ignore{Formally, the number of obfuscated functions at obfuscation level $L$ is \n$\\ceil[\\big]{L \\cdot N}$ where $N$ is total number of functions in a program.}\nWe achieve all obfuscation levels by randomly selecting candidates from all functions\nthat can be obfuscated by {\\textsc{Babel}},\nbut note that this random selection scheme is just for avoiding subjective picking in our research. \nIn practice, {\\textsc{Babel}}\\ users should decide which functions\nare critical and in need of protection. \nThis is the same as popular commercial {virtualization-based obfuscation}\\ tools~\\cite{code-virtualizer,VMProtect}.\n\n\\begin{table}[t]\n  \\centering\n  \\caption{Programs used for {\\textsc{Babel}}\\ evaluation.}\\label{tab:snd-eval-set}\n  \\small\n\n  \\begin{tabular}{l|p{3.5cm}|c|c}\n    \\hline\n    Program & Description & LoC & \\# of Func. \\\\\n    \\hline\n    bzip2 & Data compressor & 8,117 & 108 \\\\\n    mcf   & Vehicle scheduler& 2,685 & 25 \\\\\n    regexp & Regular expression engine& 1,391 & 22 \\\\\n    svm\\_light & Support vector machine& 7,101 & 103 \\\\\n    \\hline\n    oftpd & Anonymous FTP server & 5,211 & 96 \\\\\n    mongoose & Light-weight HTTP server & 5,711 & 203 \\\\\n    \\hline\n  \\end{tabular}\n\n\\end{table}\n\nIn the evaluation, we compare {\\textsc{Babel}}{} with one of the most popular commercial obfuscators, Code Virtualizer (CV)~\\cite{code-virtualizer},\nwhich is virtualization based and has been on the market since 2006.\nThe comparison covers all the four dimensions of evaluation, but some of the evaluation\nmethodologies we designed for {\\textsc{Babel}}{} may not be suitable for evaluating Code\nVirtualizer. For those evaluations that we consider not suitable for CV, we will explain the reasons\nand readers should be cautious in interpreting the data.\n\n\\input{effectiveness}\n\\input{cost}\n\\input{stealth}\n\n\\section{Discussion}\\label{sec:discussion}\n\\subsection{Generalizing {Translingual Obfuscation}{}}\nAlthough it is usually quite challenging to translate programs in one language to another\nlanguage with very different syntax, semantics, and execution models,\nmany of the obstacles can be circumvented when the translation is for obfuscation\npurposes and not required to be complete. In our translation from C to Prolog,\nwe designate the task of supporting C memory model, which is one of the most challenging\nissues in translating C, partially to the C execution environment itself. This solution is\nnot feasible in general-purpose language translations. \nMeanwhile, some of our translation techniques are universally applicable to a class of\ntarget languages that share certain similarities. For example, the control flow regularization\nmethods we proposed can be adopted when translating C to many declarative programming languages. \nWe believe that {translingual obfuscation}\\ has the potential to be made a general framework that supports\nvarious source and target languages. \n\n\n\\subsection{Multithreading Support}\nOur current implementation of {\\textsc{Babel}}{} does not support C multithreading,\nand the main reason is that some components of GNU Prolog are not thread safe.\nSince GNU Prolog is a Prolog implementation for research and educational use,\nsome language features are not supported. However, many other Prolog\nimplementations that are more mature can indeed support multithreading well~\\cite{multithread}. \nBy investing enough engineering effort, we should be able to improve the implementation\nof GNU Prolog and ensure that it supports concurrent programming.\nTherefore, we do not view the current limitation as a fundamental one.\n\n\n\\subsection{Randomness}\nSome obfuscation techniques improve the security strength by introducing randomness.\nFor example, the virtualization-based obfuscators usually randomize the encoding of their\nvirtual instruction set~\\cite{eilam2011reversing} so that attackers cannot crack all randomized binaries by \nlearning the encoding of a single instance. Although this randomization is ineffective\nonce attackers learned how to systematically crack the virtual machine itself,\nthe idea of randomization does have some value.\n\nOur current design of {translingual obfuscation}{} does not explicitly feature any randomness. However,\nsince {translingual obfuscation}{} is orthogonal to existing obfuscation techniques, it can be stacked with those\ntechniques that do introduce randomness. {Translingual obfuscation}{} itself has the potential to feature\nrandomness as well. One promising direction could be making some of the foreign language\ncompilation strategies undeterministic. Previous\nresearch~\\cite{egele_blanket_2014} has shown that mutating compilation configurations can\neffectively disrupt some deobfuscation tools.\n\n\n\\subsection{Defeating {Translingual Obfuscation}}\n\n\n\n\nIn general, {translingual obfuscation}{} is open design and does not rely on any secrets,\nalthough it can be combined with other secret-based obfuscation methods. \nAll of our justification on the security strength of {translingual obfuscation}{} assumes\nthat attackers do possess the knowledge that we have translated C into Prolog.\nIndeed, with this knowledge attackers can choose to convert the binary to Prolog\nfirst rather than directly getting back to C. Either way,\nattackers will face severe challenges.\n\nWe would like to emphasize again\nthat we do not argue it is impossible to defeat {translingual obfuscation}{}.\nInstead, we argue that Prolog is more difficult to crack than C, in the {translingual obfuscation}\\ context.\nAs long as a \\mbox{{\\textsc{Babel}}}-translated Prolog predicate is compiled as native code,\nrecovering it to a high-level program representation faces all the difficulties encountered in C reverse\nengineering, including the hardness of disassembly and analysis~\\cite{uroboros}.\nIn \\S\\ref{sec:background} we revealed the \ndeep semantics gap between Prolog source code and its low-level implementation.\nThanks to this gap, we expect that recovering the computation logic of native code compiled\nfrom Prolog-translated C source code will consume a significant amount of reverse engineering\neffort.\n\nWhat makes defeating {translingual obfuscation}\\ even more challenging is that, the obfuscated code is not only a\nplain combination of normal Prolog plus normal C but a tangled mixture of both. The execution of\nobfuscated programs will switch back and forth between the two language environments and there\nwill be frequent interleaving of different memory models (see \\S\\ref{sec:design}).\nThis also imposes challenges to reverse engineering.\n\nThere is another point that grants {translingual obfuscation}\\ the potential to significantly delay reverse\nengineering attacks.\nAs stated in \\S\\ref{sec:benefits}, {translingual obfuscation}\\ is not limited to Prolog. There are \nmany other programming languages that we can misuse for protection. By mixing these languages\nin a single obfuscation procedure, the difficulty of reverse engineering will be further increased.\n\n\\section{Related Work}\\label{sec:related}\n\\subsection{Programming Language Translation}\nPeople seek to translate one programming language to another, especially from source to source, \nfor portability, re-engineering, and security purposes.\nThe source-to-source translation\nfrom C/C++ to Java is one of the most extensively explored topics in this field, \nleading to tools such as C2J~\\cite{laffra2001c2j}, C++2Java~\\cite{c++2java}, and Cappuccino~\\cite{Buddrus:1998:CMC:330560.331015}, etc.\nTrudel et al.~\\cite{trudel_c_2012} developed a converter that translates C to Eiffel, another object-oriented programming language.\nA tool called Emscripten can translate LLVM intermediate representation to JavaScript~\\cite{zakai_emscripten:_2011}.\nSince C/C++/Objective-C source code can be compiled into LLVM intermediate representation, \nEmscripten can also be used as a source-to-source translator without much additional effort.\nThe C-to-Prolog translation introduced in this paper is partial since we need to keep the\noriginal C execution environment; however, our translation is for software obfuscation and\nbeing partial is not a limitation. Instead, we show that for our purpose, \nmany technical issues commonly seen in programming language translation can be either\naddressed or circumvented.\n\n\\subsection{Obfuscation and Deobfuscation}\nSoftware obfuscation can be on either source level or binary level.\nFor source code obfuscation, \nSharif et al.~\\cite{Sharif2008}\nencrypted equality conditions that depend on input data with some\none-way hash functions. The evaluation shows that it is virtually\nimpossible to reason about the inputs that satisfy the equality\ncondition with symbolic execution. Moser et al.~\\cite{Moser2007}\ndemonstrate that opaque predicates can effectively hide control\ntransfer destination and data locations from advanced malware\ndetection techniques. \n\nObfuscation-oriented program transformations can also be performed at the binary level.\nPopov et al.~\\cite{Popov2007} obfuscate programs by replacing control\ntransfers with exceptions, implementing real control transfers in\nexception handling code, and inserting redundant junk transfers after the exceptions. \nMimimorphism~\\cite{Wu:2010:MNA:1866307.1866368} transforms a malicious binary\ninto a mimicry benign program, with statistical and semantic\ncharacteristics highly similar to the mimicry target. As a\nresult, obfuscated malware can successfully evade statistical anomaly\ndetection. Chen et al.~\\cite{Chen:2009:CFO:1669112.1669162} propose\na control-flow obfuscation method making use of Itanium processors' architectural support for\ninformation flow tracking. In detail, they utilize the deferred exception tokens in\nItanium processor registers to implement opaque predicates.\nDomas~\\cite{movfuscator} developed a compiler which generates a binary employing only the \\texttt{mov} family\ninstructions, based on the fact that x86 \\texttt{mov} is Turing complete.\nThere are other binary obfuscation methods which heavily relies on compression, encryption,\nand virtualization~\\cite{proceeding_Justin_RAID08,procecding_OmniUnpack_ACSAC07,procecding_PolyUnpack_ACSAC06}.\nAmong these obfuscation techniques, \nbinary packers using compression and encryption can be vulnerable to dynamic analysis because\nthe original code has to be restored at some point of program execution. \nAs for {virtualization-based obfuscation}, most current approaches are implemented in the decode-dispatch scheme~\\cite{smith05}. \nRecent effort~\\cite{Rolles:2009:UVO:1855876.1855877,Sharif2009} has identified the\ncharacteristics of the decode-dispatch pattern in the virtualization-obfuscated binaries so that\nthey can be effectively reverse engineered.\n\nAs for deobfuscation, most recent work focuses on attacking {virtualization-based obfuscation}.\nSharif et al.~\\cite{Sharif2009} has developed an outside-in approach which \nfirst reverse engineers the virtual machine and then decodes the bytecode to recover\nthe protected program.\n\n\nAnother deobfuscation method presented by Coogan et al.~\\cite{Coogan2011}\nchooses the inside-out method\nwhich utilizes equational reasoning to simplify the execution traces of protected programs. \nIn this way, the deobfuscator extracts instructions which are truly relevant to program logic.\nA very recent method proposed by Yadegari et al.~\\cite{yadegari2014generic} improved the\ninside-out approach with more generic control flow simplification \nalgorithms that can deobfuscate programs protected by nested virtualization.\nWithout access to these tools, we cannot directly test {\\textsc{Babel}}'s resilience to them.\nHowever, since {\\textsc{Babel}}\\ completely reforms C programs' data layout and reconstructs\nthe control flows with a much different programming paradigm,\nwe are very confident with {\\textsc{Babel}}'s security strength against these approaches.\n\nBinary diffing is another widely used reverse engineering technique that takes\nprogram obfuscation into account. Binary differs identify the syntactical or semantic\nsimilarity between two different binaries, and can be used to detect programming plagiarism\nand launch similarity-based attacks~\\cite{brumley08}.\nBinDiff~\\cite{bindiff} and CoP~\\cite{LUO}, the two differs we use for evaluating {\\textsc{Babel}}'s\nresilience, are currently the state of the art.\nOther examples of binary differs include DarunGrim2~\\cite{dg2}, Bdiff~\\cite{bdiff},\nBinHunt~\\cite{gao_binhunt:_2008}, and iBinHunt~\\cite{iBinhunt}.\nAlthough these tools can defeat certain types of program obfuscation,\nnone of them are designed to handle the complexity of {translingual obfuscation}.\n\n\\section{Conclusion}\\label{sec:conclusion}\nIn this paper, we present {translingual obfuscation}, a new software obfuscation scheme based on translations from one programming language to another. By utilizing certain design and implementation\nfeatures of the target language, we are able to protect the original program against reverse engineering.\nWe implement {\\textsc{Babel}}, a tool that translates part of a C program into Prolog \nand utilizes Prolog's unique language features to make the program obscure.\nWe evaluate {\\textsc{Babel}}\\ with respect to\npotency, resilience, cost, and stealth on real-world C programs of different categories.\nThe experimental results show that {translingual obfuscation}\\ is an adequate and practical software protection\ntechnique.\n\n\n\\section*{Acknowledgments}\nWe thank Herbert Bos and the anonymous reviewers\nfor their valuable feedback which has greatly helped us improve the paper.\nThis research was supported in part by the National Science Foundation (NSF)\ngrants CNS-1223710 and CCF-1320605, and the Office of\nNaval Research (ONR) grant N00014-13-1-0175.\n\n\\bibliographystyle{IEEEtranS}\n\\bibliography{main,smartphone,wu}\n\n\\begin{appendix}\n\\section{Additional Potency Evaluation Data}\n\\label{sec:extra}\nIn this appendix, we present the program complexity at obfuscation levels of 10\\%, 20\\%, 30\\%, 40\\%, and 50\\%, for both {\\textsc{Babel}}\\ (Table~\\ref{tab:babel-potency-all}) and Code Virtualizer (Table~\\ref{tab:cv-potency-all}). \nWe would like to remind readers that for the {\\textsc{Babel}}\\ potency data, all values are obtained by IDA Pro~\\cite{ida}.\nSince {\\textsc{Babel}}\\ generates many indirect control flow (see \\S~\\ref{sec:oc-features} and {Fig.}~\\ref{fig:example}),\nit is hard to evaluate how accurate IDA Pro is. Nevertheless, in our case\nthe reported values can be interpreted as lower bounds of the corresponding metrics.\n\\begin{table*}\n\\centering\n\\caption{Program Complexity of {\\textsc{Babel}}-Obfuscated Binaries at Different Obfuscation Levels}\n\\label{tab:babel-potency-all}\n\\begin{tabular}{l|c|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}}\n\\hline\n\\multirow{2}{*}{Program} & Obfuscation & \\multicolumn{2}{c|}{\\# of Call Graph Edges} & \\multicolumn{2}{c|}{\\# of CFG Edges} & \\multicolumn{2}{c|}{\\# of Basic Blocks} & \\multicolumn{2}{c|}{Cyclomatic Number} & \\multicolumn{2}{c}{Knot Count}\\\\\n\\cline{3-12}\n& Level& Value & Ratio & Value & Ratio & Value & Ratio & Value & Ratio & Value & Ratio \\\\\n\\hline\n\\multirow{6}{*}{bzip2} & 0\\%  & 353 & 1.0 & 5382 & 1.0 & 3528 & 1.0 & 1856 & 1.0 & 3120 & 1.0 \\\\\n                          & 10\\% & 5609 & 15.9 & 18539 & 3.4 & 15445 & 4.4 & 3096 & 1.7 & 12488 & 4.0 \\\\\n                          & 20\\% & 5719 & 16.2 & 18909 & 3.5 & 15788 & 4.5 & 3123 & 1.7 & 12166 & 3.9 \\\\\n                          & 30\\% & 5964 & 16.9 & 19771 & 3.7 & 17078 & 4.8 & 2695 & 1.5 & 12396 & 4.0 \\\\\n                          & 40\\% & 6386 & 18.1 & 19630 & 3.6 & 17907 & 5.1 & 1725 & 0.9 & 12027 & 3.9 \\\\\n                          & 50\\% & 6617 & 18.7 & 19829 & 3.7 & 18210 & 5.2 & 1621 & 0.9 & 12110 & 3.9 \\\\\n\\hline\n\\multirow{6}{*}{mcf} & No Obf.  & 78 & 1.0 & 854 & 1.0 & 583 & 1.0 & 273 & 1.0 & 153 & 1.0 \\\\\n                          & 10\\% & 5159 & 66.1 & 13352 & 15.6 & 11759 & 20.2 & 1595 & 5.8 & 8761 & 57.3 \\\\\n                          & 20\\% & 5302 & 68.0 & 13500 & 15.8 & 12079 & 20.7 & 1423 & 5.2 & 8761 & 57.3 \\\\\n                          & 30\\% & 5449 & 69.9 & 14233 & 16.7 & 13086 & 22.4 & 1149 & 4.2 & 8792 & 57.5 \\\\\n                          & 40\\% & 5519 & 70.8 & 13922 & 16.3 & 12926 & 22.2 & 998 & 3.7 & 8739 & 57.1 \\\\\n                          & 50\\% & 5697 & 73.0 & 14076 & 16.5 & 13464 & 23.1 & 614 & 2.2 & 8686 & 56.8 \\\\\n\\hline\n\\multirow{6}{*}{regexp} & No Obf.  & 72 & 1.0 & 855 & 1.0 & 591 & 1.0 & 266 & 1.0 & 1135 & 1.0 \\\\\n                          & 10\\% & 5053 & 70.2 & 13082 & 15.3 & 11447 & 19.4 & 1637 & 6.2 & 9675 & 8.5 \\\\\n                          & 20\\% & 5101 & 70.8 & 12964 & 15.2 & 11428 & 19.3 & 1538 & 5.8 & 9491 & 8.4 \\\\\n                          & 30\\% & 5276 & 73.3 & 13290 & 15.5 & 11802 & 20.0 & 1490 & 5.6 & 9530 & 8.4 \\\\\n                          & 40\\% & 5309 & 73.7 & 13064 & 15.3 & 11704 & 19.8 & 1362 & 5.1 & 9405 & 8.3 \\\\\n                          & 50\\% & 5375 & 74.7 & 13292 & 15.5 & 11940 & 20.2 & 1354 & 5.1 & 9393 & 8.3 \\\\\n\\hline\n\\multirow{6}{*}{svm} & No Obf.  & 511 & 1.0 & 5375 & 1.0 & 3545 & 1.0 & 1832 & 1.0 & 2972 & 1.0 \\\\\n                          & 10\\% & 5734 & 11.2 & 19156 & 3.6 & 15777 & 4.5 & 3381 & 1.8 & 11729 & 3.9 \\\\\n                          & 20\\% & 6343 & 12.4 & 19912 & 3.7 & 17368 & 4.9 & 2546 & 1.4 & 11658 & 3.9 \\\\\n                          & 30\\% & 6739 & 13.2 & 20752 & 3.9 & 18533 & 5.2 & 2221 & 1.2 & 11521 & 3.9 \\\\\n                          & 40\\% & 7052 & 13.8 & 20680 & 3.8 & 19049 & 5.4 & 1633 & 0.9 & 11547 & 3.9 \\\\\n                          & 50\\% & 7661 & 15.0 & 21119 & 3.9 & 20135 & 5.7 & 986 & 0.5 & 11552 & 3.9 \\\\\n\\hline\n\\multirow{6}{*}{oftpd} & No Obf.  & 455 & 1.0 & 2035 & 1.0 & 1667 & 1.0 & 370 & 1.0 & 1277 & 1.0 \\\\\n                          & 10\\% & 5541 & 12.2 & 14591 & 7.2 & 13011 & 7.8 & 1582 & 4.3 & 9856 & 7.7 \\\\\n                          & 20\\% & 5710 & 12.5 & 15110 & 7.4 & 13812 & 8.3 & 1300 & 3.5 & 9923 & 7.8 \\\\\n                          & 30\\% & 5810 & 12.8 & 15501 & 7.6 & 14422 & 8.7 & 1081 & 2.9 & 9911 & 7.8 \\\\\n                          & 40\\% & 5853 & 12.9 & 15875 & 7.8 & 15086 & 9.0 & 791 & 2.1 & 9858 & 7.7 \\\\\n                          & 50\\% & 6048 & 13.3 & 16493 & 8.1 & 16108 & 9.7 & 387 & 1.0 & 9954 & 7.8 \\\\\n\\hline\n\\multirow{6}{*}{mongoose} & No Obf.  & 1027 & 1.0 & 2788 & 1.0 & 2086 & 1.0 & 704 & 1.0 & 493 & 1.0 \\\\\n                          & 10\\% & 6288 & 6.1 & 15981 & 5.7 & 14262 & 6.8 & 1721 & 2.4 & 9495 & 19.3 \\\\\n                          & 20\\% & 6525 & 6.4 & 16464 & 5.9 & 15102 & 7.2 & 1364 & 1.9 & 9474 & 19.2 \\\\\n                          & 30\\% & 6762 & 6.6 & 17115 & 6.1 & 16079 & 7.7 & 1038 & 1.5 & 9491 & 19.3 \\\\\n                          & 40\\% & 6784 & 6.6 & 17597 & 6.3 & 16924 & 8.1 & 675 & 1.0 & 9447 & 19.2 \\\\\n                          & 50\\% & 7024 & 6.8 & 18470 & 6.6 & 18369 & 8.8 & 103 & 0.1 & 9450 & 19.2 \\\\\n\\hline\n\\end{tabular}\n\\end{table*}\n\n\\begin{table*}\n\\centering\n\\caption{Program Complexity of CV-Obfuscated Binaries at Different Obfuscation Levels}\n\\label{tab:cv-potency-all}\n\\begin{tabular}{l|c|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}|P{4em}P{2.2em}}\n\\hline\n\\multirow{2}{*}{Program} & Obfuscation & \\multicolumn{2}{c|}{\\# of Call Graph Edges} & \\multicolumn{2}{c|}{\\# of CFG Edges} & \\multicolumn{2}{c|}{\\# of Basic Blocks} & \\multicolumn{2}{c|}{Cyclomatic Number} & \\multicolumn{2}{c}{Knot Count}\\\\\n\\cline{3-12}\n& Level& Value & Ratio & Value & Ratio & Value & Ratio & Value & Ratio & Value & Ratio \\\\\n\\hline\n\\multirow{6}{*}{bzip2} & 0\\%  & 353 & 1.0 & 5382 & 1.0 & 3528 & 1.0 & 1856 & 1.0 & 3120 & 1.0 \\\\\n                          & 10\\% & 424 & 1.2 & 4079 & 0.8 & 2962 & 0.8 & 1119 & 0.6 & 645 & 0.2 \\\\\n                          & 20\\% & 385 & 1.1 & 3988 & 0.7 & 2906 & 0.8 & 1084 & 0.6 & 630 & 0.2 \\\\\n                          & 30\\% & 261 & 0.7 & 3868 & 0.7 & 2826 & 0.8 & 1044 & 0.6 & 713 & 0.2 \\\\\n                          & 40\\% & 248 & 0.7 & 3675 & 0.7 & 2684 & 0.8 & 993 & 0.5 & 699 & 0.2 \\\\\n                          & 50\\% & 242 & 0.7 & 3652 & 0.7 & 2684 & 0.8 & 970 & 0.5 & 696 & 0.2 \\\\\n\\hline\n\\multirow{6}{*}{mcf} & No Obf.  & 78 & 1.0 & 854 & 1.0 & 583 & 1.0 & 273 & 1.0 & 153 & 1.0 \\\\\n                          & 10\\% & 36 & 0.5 & 531 & 0.6 & 377 & 0.6 & 156 & 0.6 & 71 & 0.5 \\\\\n                          & 20\\% & 36 & 0.5 & 520 & 0.6 & 370 & 0.6 & 152 & 0.6 & 71 & 0.5 \\\\\n                          & 30\\% & 34 & 0.4 & 461 & 0.5 & 329 & 0.6 & 134 & 0.5 & 68 & 0.4 \\\\\n                          & 40\\% & 24 & 0.3 & 372 & 0.4 & 270 & 0.5 & 104 & 0.4 & 54 & 0.4 \\\\\n                          & 50\\% & 33 & 0.4 & 308 & 0.4 & 223 & 0.4 & 87 & 0.3 & 46 & 0.3 \\\\\n\\hline\n\\multirow{6}{*}{regexp} & No Obf.  & 72 & 1.0 & 855 & 1.0 & 591 & 1.0 & 266 & 1.0 & 1135 & 1.0 \\\\\n                          & 10\\% & 69 & 1.0 & 589 & 0.7 & 410 & 0.7 & 181 & 0.7 & 619 & 0.5 \\\\\n                          & 20\\% & 67 & 0.9 & 578 & 0.7 & 411 & 0.7 & 169 & 0.6 & 618 & 0.5 \\\\\n                          & 30\\% & 66 & 0.9 & 525 & 0.6 & 377 & 0.6 & 150 & 0.6 & 603 & 0.5 \\\\\n                          & 40\\% & 58 & 0.8 & 330 & 0.4 & 243 & 0.4 & 89 & 0.3 & 117 & 0.1 \\\\\n                          & 50\\% & 57 & 0.8 & 326 & 0.4 & 253 & 0.4 & 75 & 0.3 & 117 & 0.1 \\\\\n\\hline\n\\multirow{6}{*}{svm} & No Obf.  & 511 & 1.0 & 5375 & 1.0 & 3545 & 1.0 & 1832 & 1.0 & 2972 & 1.0 \\\\\n                          & 10\\% & 403 & 0.8 & 3612 & 0.7 & 2576 & 0.7 & 1038 & 0.6 & 324 & 0.1 \\\\\n                          & 20\\% & 382 & 0.7 & 3431 & 0.6 & 2460 & 0.7 & 973 & 0.5 & 313 & 0.1 \\\\\n                          & 30\\% & 357 & 0.7 & 3267 & 0.6 & 2358 & 0.7 & 911 & 0.5 & 302 & 0.1 \\\\\n                          & 40\\% & 337 & 0.7 & 3129 & 0.6 & 2259 & 0.6 & 872 & 0.5 & 293 & 0.1 \\\\\n                          & 50\\% & 311 & 0.6 & 2971 & 0.6 & 2147 & 0.6 & 826 & 0.5 & 282 & 0.1 \\\\\n\\hline\n\\multirow{6}{*}{oftpd} & No Obf.  & 455 & 1.0 & 2035 & 1.0 & 1667 & 1.0 & 370 & 1.0 & 1277 & 1.0 \\\\\n                          & 10\\% & 444 & 1.0 & 1923 & 0.9 & 1582 & 0.9 & 343 & 0.9 & 1097 & 0.9 \\\\\n                          & 20\\% & 411 & 0.9 & 1786 & 0.9 & 1454 & 0.9 & 334 & 0.9 & 1065 & 0.8 \\\\\n                          & 30\\% & 390 & 0.9 & 1727 & 0.8 & 1435 & 0.9 & 294 & 0.8 & 542 & 0.4 \\\\\n                          & 40\\% & 333 & 0.7 & 1500 & 0.7 & 1237 & 0.7 & 265 & 0.7 & 972 & 0.8 \\\\\n                          & 50\\% & 307 & 0.7 & 1384 & 0.7 & 1158 & 0.7 & 228 & 0.6 & 944 & 0.7 \\\\\n\\hline\n\\multirow{6}{*}{mongoose} & No Obf.  & 1027 & 1.0 & 2788 & 1.0 & 2086 & 1.0 & 704 & 1.0 & 493 & 1.0 \\\\\n                          & 10\\% & 717 & 0.7 & 2489 & 0.9 & 1934 & 0.9 & 557 & 0.8 & 526 & 1.1 \\\\\n                          & 20\\% & 644 & 0.6 & 2239 & 0.8 & 1786 & 0.9 & 455 & 0.6 & 462 & 0.9 \\\\\n                          & 30\\% & 585 & 0.6 & 2063 & 0.7 & 1638 & 0.8 & 427 & 0.6 & 442 & 0.9 \\\\\n                          & 40\\% & 532 & 0.5 & 1954 & 0.7 & 1555 & 0.7 & 401 & 0.6 & 430 & 0.9 \\\\\n                          & 50\\% & 467 & 0.5 & 1787 & 0.6 & 1424 & 0.7 & 365 & 0.5 & 400 & 0.8 \\\\\n\\hline\n\\end{tabular}\n\\end{table*}\n\n\\end{appendix}\n\n", "itemtype": "equation", "pos": 24242, "prevtext": "\n\n\\title{{Translingual Obfuscation}{\\shortlong{}{{\\thanks{This is an extended version of a paper to appear in  \\textit{Proceedings of the 1st IEEE European Symposium on Security and Privacy (Euro S\\&P 2016)} \\cite{mo}.}}}}}\n\n\\author{\n\\IEEEauthorblockN{Pei Wang, Shuai Wang, Jiang Ming, Yufei Jiang, and Dinghao Wu}\n\\IEEEauthorblockA{College of Information Sciences and Technology\\\\\nThe Pennsylvania State University\\\\\n\\{pxw172, szw175, jum310, yzj107, dwu\\}@ist.psu.edu}\n}\n\\maketitle\n\n\\begin{abstract}\n  Program obfuscation is an important software protection technique\n  that prevents attackers from revealing the programming logic and design of the software.\n  We introduce \\emph{{translingual obfuscation}}, a new software obfuscation scheme which\n  makes programs obscure by ``misusing'' the unique features of certain programming languages. \n  {Translingual obfuscation}\\ translates part of a program from its original language\n  to another language which has a different programming paradigm and execution model,\n  thus increasing program complexity and impeding reverse engineering.\n  In this paper, we investigate the feasibility and effectiveness of {translingual obfuscation}\\ with Prolog,\n  a logic programming language.\n  We implement {translingual obfuscation}\\ in a tool called {\\textsc{Babel}}, which can selectively translate C functions into\n  Prolog predicates.\n  By leveraging two important features of the Prolog language,\n  i.e., unification and backtracking, {\\textsc{Babel}}\\ obfuscates both the data layout and control flow of \n  C programs, making them much more difficult to reverse engineer.\n  Our experiments show that {\\textsc{Babel}}\\ provides effective\n  and stealthy software obfuscation, while the cost is only modest compared to one of\n  the most popular commercial obfuscators on the market.\n  With {\\textsc{Babel}}, we verified the feasibility of {translingual obfuscation}, which we consider to be\n  a promising new direction for software obfuscation. \n\\end{abstract}\n\n\\section{Introduction}\\label{sec:intro}\nObfuscation is an important technique for software protection,\nespecially for preventing reverse engineering from infringing software intellectual property. \nGenerally speaking, obfuscation is a semantics-preserving\nprogram transformation that aims to make a program\nmore difficult to understand and reverse engineer.\nThe idea of using obfuscating transformations to prevent\nreverse engineering can be traced back to \n Collberg et al.~\\cite{Collberg1997,Collberg1998, nagra2009surreptitious}. Since then many obfuscation\nmethods have been\nproposed~\\cite{Linn2003,Moser2007,Popov2007,Sharif2008,Chen:2009:CFO:1669112.1669162,Wu:2010:MNA:1866307.1866368}.\n{\\shortlong{}{{ Malware authors also heavily rely on obfuscation to compress or encrypt executable binaries so that their products can avoid malicious content detection~\\cite{Szor2005,Sikorski2012}. }}}\n\nCurrently the state-of-the-art obfuscation technique is to incorporate with\n\\textit{process-level virtualization}.\nFor example, obfuscators such as VMProtect~\\cite{VMProtect} and Code\nVirtualizer~\\cite{code-virtualizer} replace the original binary code\nwith new bytecode, and a custom interpreter is attached to\ninterpret and execute the bytecode. The result is that the original\nbinary code does not exist anymore, leaving only the bytecode and\ninterpreter, making it difficult to directly reverse engineer~\\cite{proceeding_Justin_RAID08}.\nHowever, recent work has shown that the decode-and-dispatch execution pattern \nof {virtualization-based obfuscation}\\ can be a severe vulnerability leading to effective deobfuscation~\\cite{Coogan2011,Sharif2009},\nimplying that we are in need of obfuscation techniques based on new schemes.\n\nWe propose a novel and practical obfuscation method called \\textit{{translingual obfuscation}}, \nwhich possesses strong security strength and good stealth, with only modest cost.\nThe key idea is that instead of inventing brand new obfuscation techniques,\nwe can exploit some existing programming languages for their unique design and \nimplementation features to achieve obfuscation effects.\nIn general, programming language features are rarely proposed or developed for obfuscation purposes;\nhowever, some of them indeed make reverse engineering much more challenging at the binary level and\nthus can be ``misused'' for software protection.\nIn particular, some programming languages are designed with unique paradigms and have very complicated execution models.\nTo make use of these language features, we can translate a program\nwritten in a certain language to another language which is more ``confusing'',\nin the sense that it consists of features leading to obfuscation effects.\n\nIn this paper, we obfuscate C programs by translating them into Prolog,\npresenting a feasible example of the {translingual obfuscation}{} scheme.\nC is a traditional imperative programming language while Prolog is\na typical logic programming language.\nThe Prolog language has some prominent features that provide strong obfuscation effects.\nPrograms written in Prolog are executed in a \\textit{search-and-backtrack} computation model\nwhich is dramatically different from the execution model of C and much more complicated.\nTherefore, translating C code to Prolog leads to obfuscated data layouts and control flows.\nEspecially, \\emph{the complexity of Prolog's execution model manifests mostly in the binary\nform of the programs,} making Prolog very suitable for software protection.\n\n\nTranslating one language to another is usually very difficult,\nespecially when the target and source languages have different programming paradigms.\nHowever, we made an important observation that for obfuscation purposes, \nlanguage translation could be conducted in a special manner.\nInstead of developing a ``clean'' translation from C to Prolog,\nwe propose an ``obfuscating'' translation scheme which retains part of the C memory model,\nin some sense making two execution models mixed together.\nWe believe this improves the obfuscating effect in a way that no obfuscation methods \nhave achieved before, to the best of our knowledge.\nConsequently in {translingual obfuscation}, the obfuscation does not only come from the obfuscating features of \nthe target language, but also from the translation itself.\nWith this new translation scheme we manage to kill two birds with one stone, i.e.,\nsolving the technical problems in implementing {translingual obfuscation}\\ and strengthening the obfuscation\nsimultaneously. \n\nThere may be of a concern that obfuscation techniques without solid theoretical \nfoundations will not withstand reverse engineering attacks in the long run. However,\nresearch on fundamental obfuscation theories, despite promising process made\nrecently~\\cite{\\shortlong{lopez-alt_--fly_2012,garg_candidate_2013,\nsahai_how_2014}{lopez-alt_--fly_2012,garg_candidate_2013,\nsahai_how_2014,boyle_extractability_2014,barak_protecting_2014}},\nis still not mature enough to spawn practical protection techniques.\nThere is a widely accepted consensus that no software protection scheme is resilient to\nskilled attackers if they inspect the software with intensive effort~\\cite{collberg_watermarking_2002}.\nA recently proved theorem~\\cite{barak_impossibility_2012} partially supporting this claim states that, a ``universally effective'' obfuscator\ndoes not exist, i.e., for any obfuscation algorithm, there always exists an program that it cannot\neffectively obfuscate.\nGiven the situation, it seems that developing an obfuscation scheme resilient to all\nreverse engineering threats (known or unknown) is too ambitious at this point. Hence, \nmaking reverse engineering more difficult (but not impossible) could be a more realistic \ngoal to pursue.\n\nWe have implemented {translingual obfuscation}\\ in a tool called {\\textsc{Babel}}. {\\textsc{Babel}}\\ can\nselectively transform a C function into semantically equivalent Prolog code and\ncompile code of both languages together into the executable form.\nOur experiment results show that {translingual obfuscation}\\ is obscure and\nstealthy. \nThe execution overhead of {\\textsc{Babel}}\\ is modest compared to a commercial obfuscator.\nWe also show that\n{translingual obfuscation}\\ is resilient to one of the most popular reverse engineering techniques.\n\nIn summary, we make the following contributions in this research:\n\\begin{itemize}\n\\item We propose a new obfuscation method, namely {translingual obfuscation}.\n  {Translingual obfuscation}\\ is novel because it exploits exotic language features instead of ad-hoc \n  program transformations to \n  protect programs against reverse engineering.\n  Our new method has a number of advantages over existing obfuscation techniques,\n  which will be discussed in depth later.\n\\item We implement {translingual obfuscation}\\ in a tool called {\\textsc{Babel}}\\\n  which translates C to Prolog at the scale of subroutines, i.e., from C functions\n  to Prolog predicates, to obfuscate the original programs.\n  Language translation is always a challenging problem, especially when the target language has\n  a heterogeneous execution model.\n\\item We evaluate {\\textsc{Babel}}\\ with respect to all four evaluation criteria proposed by Collberg \n  et al.~\\cite{Collberg1998}: potency, resilience, cost, and stealth, on a set of\n  real-world C programs with quite a bit of complexity and diversity.\n  Our experiments demonstrate that {\\textsc{Babel}}\\ provides strong protection against reverse engineering\n  with only modest cost. \n\\end{itemize}\n\nThe remainder of this paper is organized as follows. \n{\\shortlong{}{{ \\S\\ref{sec:tm} defines our threat model. }}}\n\\S\\ref{sec:mo} provides a high-level view on the insights and features of our {translingual obfuscation}\\ technique.\n\\S\\ref{sec:background} explains in detail why the Prolog programming language \ncan be misused for obfuscation.\nWe summarize the technical challenges in implementing {translingual obfuscation}\\ in \\S\\ref{sec:cpob}.\n\\S\\ref{sec:design} and \\S\\ref{sec:impl}\npresent our C-to-Prolog translation method and \nthe implementation details of {\\textsc{Babel}}, respectively.\nWe evaluate {\\textsc{Babel}}'s performance in \\S\\ref{sec:eval}.\n\\S\\ref{sec:discussion} has a discussion on some important topics about {translingual obfuscation},\nfollowed by the summary of related work in \\S\\ref{sec:related}.\n\\S\\ref{sec:conclusion} concludes the paper.\n\n{\\shortlong{}{{  \\section{Threat Model}\\label{sec:tm} For attackers who try to reverse engineer a program protected by obfuscation, we assume that they have full access to the binary form of the program. They can examine the static form of the binaries with whatever method available to them. They can also execute the victim binaries in a monitored environment with arbitrary input, thus can read any data that has lived in the memory.   Do note that although we assume attackers have unlimited access to program binaries, they should not posses any knowledge about the source code in our threat model. Assuming attackers can only examine the obfuscated program at the binary level is important, because that would mean any implementation detail of the language used in {translingual obfuscation}\\ contributes to the effectiveness of obfuscation. As for the particular case of employing Prolog in {translingual obfuscation},  since Prolog is a declarative programming language, there is a much deeper semantic gap between its source code and binaries, which is highlighted as one of the major sources of {translingual obfuscation}'s protection effects.   Finally, we explicitly clarify that in this work, attackers are assumed to try to reveal the logical structure of the binaries so that they can reproduce the algorithms by themselves.  In practice there are different levels of reverse engineering objectives. Sometimes understanding what a program achieves is sufficient for attackers to fulfill their goals, but in our case attackers need a more thorough understanding on the semantics of the victim binaries.  Our threat model may seem too coarsely defined. However, we believe it is quite realistic, since reverse engineering could be a very ad-hoc process in practice. Actually, lack of specifications makes it difficult for us to  design and evaluate a new obfuscation technique in a fully comprehensive manner, because we cannot make further assumptions on the methods or tools that attackers may make use of. Therefore, we hope that readers of this paper could pay more attention to the general idea and picture we want to present.   }}}\n\\section{{Translingual Obfuscation}}\\label{sec:mo}\n\\subsection{Overview}\n\nThe basic idea of {translingual obfuscation}\\ is that some programming languages are more\ndifficult to reverse engineer than others. Intuitively, C is relatively\neasy to reverse engineer because binary code compiled from C programs\nshares the same imperative execution model with the source code.\nFor some programming languages like Prolog, however, there is a much deeper\ngap between the source code and the\nresulting binaries, since these languages have fundamentally different\nabstractions from the imperative execution model of the underlying hardware.\nStarting from this insight, we analyze and evaluate the\nfeatures of a foreign programming language from the perspective of software protection.\nWe also develop the translation technique that transforms the original language\nto the obfuscating language. Only with these efforts devoted, {translingual obfuscation}\\ can be\na practical software protection scheme. \n\n\\begin{figure}[t]\n  \\centering\n  \\begin{tikzpicture}[scale=0.95,every node/.style={transform shape}]\n    \\scriptsize\n    \\node[rectangle, fill=green!30, minimum width=2.5cm,minimum height=1.7cm] (sourceAO1) {};\n    \\coordinate[above=.25cm of sourceAO1.north east] (sAOa1);\n    \\coordinate[below=.25cm of sourceAO1.south east] (sAOb1);\n    \\draw[dashed] (sAOa1) -- (sAOb1);\n    \\node[rectangle, fill=green!30, minimum width=1.95cm, minimum height=1.7cm, right=0 of sourceAO1] (bin-ob1) {};\n    \\node[rectangle, fill=red!30, minimum width=4.45cm, minimum height=1.7cm, right=0 of bin-ob1] (bin-de1) {};\n\n    \\coordinate[above=.5cm of bin-ob1.north east] (ba1);\n    \\coordinate[below=.5cm of bin-ob1.south east] (bb1);\n    \\draw (ba1) -- (bb1);\n\n    \\node[tape, draw=black, fill=white,text width=2cm, text centered, inner sep = .2ex, below=-.1cm of sourceAO1.center] (sourceA1) {Source code\\\\in language $\\mathcal{A}$};\n    \\node[above=2ex of sourceAO1.center, text width=2cm, text centered,text=black!100] {\\sf Source-Code\\\\Obfuscation};\n\n    \\node[tape, draw = black, fill = white, text width = 2cm, text centered, inner sep = .2ex, minimum height=.8cm, below=-.1cm of bin-ob1.east,] (bin1) {Binary};\n\n    \\draw[->] (sourceA1) -- (bin1);\n\n    \\node[above=2ex of bin-ob1.center, text width=2cm, text centered,text=black!100] {\\sf Binary\\\\Obfuscation};\n    \\node[above=3ex of bin-de1.center, text width=2cm, text centered,text=black!100] {\\sf Deobfuscation};    \n\n    \\node[above = .1cm of sAOa1, xshift=-.5cm] (label1) {\\textsf{\\textbf{Developer Side}}};\n    \\node[right = 3cm of label1] {\\textsf{\\textbf{Attacker Side}}};\n\n    \\node[rectangle, fill=green!30, minimum width=2.5cm,minimum height=1.7cm, below=1cm of sourceAO1] (sourceAO) {};\n    \\coordinate[above=.25cm of sourceAO.north east] (sAOa);\n    \\coordinate[below=.25cm of sourceAO.south east] (sAOb);\n    \\draw[dashed] (sAOa) -- (sAOb);\n\n    \\node[rectangle, fill=green!90, right=0 of sourceAO, minimum width=3cm,minimum height=1.7cm] (sourceBO) {};\n\n    \\node[rectangle, fill=green!30, minimum width=1.7cm, minimum height=1.7cm, right=0 of sourceBO] (bin-ob) {};\n    \\node[rectangle, fill=red!30, minimum width=1.7cm, minimum height=1.7cm, right=0 of bin-ob] (bin-de) {};\n\n    \\coordinate[above=.5cm of bin-ob.north east] (ba);\n    \\coordinate[below=.5cm of bin-ob.south east] (bb);\n    \\draw (ba) -- (bb);\n\n    \\node[tape, draw=black, fill=white,text width=2cm, text centered, inner sep = .2ex, below=-.1cm of sourceAO.center] (sourceA) {Source code\\\\in language $\\mathcal{A}$};\n\n    \\node[tape, draw=black, fill=white,text width=2.5cm, text centered, inner sep = .2ex, below=-.1cm of sourceBO.center] (sourceB) {Source code\\\\in language $\\mathcal{B}$ (and $\\mathcal{A}$)};\n\n    \\node[above=2ex of sourceAO.center, text width=2cm, text centered,text=black!100] {\\sf Source-Code\\\\Obfuscation};\n\n    \\node[above=2ex of sourceBO.center, text width=2cm, text centered] {\\textsf{\\textbf{{Translingual\\\\Obfuscation}}}};\n\n    \\node[tape, draw=black, fill=white, text width=2cm, minimum height=.8cm,text centered, inner sep=.2ex, below=-.1cm of bin-ob.east] (bin) {Binary};\n\n    \\draw[->] (sourceA) -- (sourceB);\n    \\draw[->] (sourceB) -- (bin);\n\n    \\node[above=2ex of bin-ob.center, text width=2cm, text centered,text=black!100] {\\sf Binary\\\\Obfuscation};\n    \\node[above=3ex of bin-de.center, text width=2cm, text centered,text=black!100] {\\sf Deobfuscation};    \n\n\n\n\n    \\draw[->,line width=1pt] (bb1) -- (ba);\n\n    \\coordinate[above=.25cm of sourceBO.north east] (sAOa);\n    \\coordinate[below=.25cm of sourceBO.south east] (sAOb);\n    \\draw[dashed] (sAOa) -- (sAOb);\n  \\end{tikzpicture}\n  \\caption{{Translingual obfuscation}\\ is a new protection layer complementary to existing obfuscation methods, pushing the frontier forward in the battle with reverse engineering.}\n  \\label{fig:race}\n\\end{figure}\n\nWe view {translingual obfuscation}\\ as a new layer of software protection in the obfuscation-deobfuscation arms race,\nas shown in {Fig.}~\\ref{fig:race}.\n\n\nDifferent from previous obfuscation methods which either work at the \nbinary level or perform same-language source-to-source transformations, \n{translingual obfuscation}\\ translates one language to another.\nTherefore, {translingual obfuscation}\\ can be applied after source-code obfuscation and before \nbinary obfuscation without affecting the applicability of existing\nobfuscation methods.\n\n\\subsection{Comparing with Virtualization-Based Obfuscation}\n\\label{sec:discussion:vo}\n\\begin{figure}[t]\n  \\centering\n  \\begin{tikzpicture}[trim right = 0cm, trim left=0cm]\n    \\node[circle,draw,minimum width=14em] (a) at (-1.4,0) {};\n    \\node[circle,draw,minimum width=14em] (b) at (1.4,0) {};\n    \\node[text width=10em,text centered] at (-1.4,3) {\\footnotesize \\textsf{\\textbf{{Translingual\\\\Obfuscation}\\\\}}};\n    \\node[text width=20em,text centered] at (1.4,3) {\\footnotesize \\textsf{\\textbf{Virtualization-Based\\\\Obfuscation\\\\}}};\n    \\node[text width=9em, text centered] at (0,0) {\\scriptsize \\textsf{{Exotic Language\\\\Features\\\\+\\\\Virtualization\\\\}}};\n    \\node[circle,draw,minimum width=6.5em] (c) at (-2.15,-1) {};\n    \\node[circle,draw,minimum width=6.5em] (d) at (2.15,-1) {};\n    \\node[text width=6em, text centered] (e) at (-2.15,-1) {\\scriptsize\\textsf{{\\textsc{Babel}}}\\\\\\textsf{{(GNU Prolog,\\\\native code and \\\\no interpreter)\\\\}}};\n    \\node[text width=6em, text centered] (f) at (2.15,-1) {\\scriptsize \\textsf{{VMProtect, Code Virtualizer,\\\\etc.\\\\}}};\n    \\node[text width=6em, text centered] (g) at (-2.1,1) {\\scriptsize\\textsf{Exotic Language Features\\\\(heterogeneous\\\\programming paradigms)\\\\}};\n    \\node[text width=6em, text centered] (g) at (2.1,1) {\\scriptsize\\textsf{Virtualization\\\\(byte code interpretation)\\\\}};\n  \\end{tikzpicture}\n  \\caption{Comparing {translingual obfuscation}\\ and {virtualization-based obfuscation}.}\n  \\label{fig:relationship}\n\\end{figure}\n\nThe {{virtualization-based obfuscation}} is currently the state of the art in binary obfuscation.\nSome features of {{translingual obfuscation}} resemble the idea of {{virtualization-based obfuscation}}, but we want to emphasize a significant difference here.\n\n\nCurrently, most implementations of {{virtualization-based obfuscation}}\ntend to encode original native machine code with a RISC-like virtual instruction set and interpret \nthe encoded binary in a decode-dispatch pattern~\\cite{smith05, Rolles:2009:UVO:1855876.1855877, Ghosh:2012:RAA:2151024.2151051},\nwhich has been identified as a notable weakness of security and can be exploited\nby various attacks~\\cite{Sharif2009,Coogan2011,yadegari2014generic}.\n\n\n\n\n\n\n{Translingual obfuscation}, however, gets most of its security strength by\n\\textit{intentionally} relying on obfuscation-contributing language \nfeatures that comes from a heterogeneous programming model.\nEssentially, {translingual obfuscation}\\ does not have to re-encode the original binary as long\nas the foreign language employed supports compilation into native code.\n{Fig.}~\\ref{fig:relationship} shows the relationship and key differences between the two methods.\nOur {translingual obfuscation}\\ implementation {\\textsc{Babel}}\\ and {{virtualization-based obfuscation}} do not overlap.\n\n\n\n\\subsection{Benefits}\n\\label{sec:benefits}\n{Translingual obfuscation}\\ can provide benefits\nthat cannot be delivered by any single obfuscation method developed before,\nto the best of our knowledge:\n\\begin{itemize}\n\n\n\n\n\\item\n{Translingual obfuscation}{} provides strong obfuscation strength and more obfuscation variety by introducing a different programming paradigm.\nIf there exists \\textit{a universally effective and automated method}\n\n\n\nto nullify the obfuscation effects, namely the additional\nprogram complexity, introduced by a programming language's execution model,\nthat would mean it is possible to significantly simplify the design and\nimplementation of that language,\nwhich is very unlikely for mature languages.\n\n\\item {Translingual obfuscation}\\ can be very stealthy, because programming with multiple languages\nis a completely legit practice.\nCompared with {virtualization-based obfuscation}\\ which\nencodes native code into bytecode that has an exotic encoding format, {translingual obfuscation}\\\nintroduces neither abnormal byte entropy nor deviant instruction distributions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\item {Translingual obfuscation}\\ is not just a single obfuscation algorithm but a general framework. Although we\nparticularly utilizes Prolog in this paper, there are other languages that can be misused for {translingual obfuscation}. For example, \nthe New Jersey implementation of ML (SML/NJ)~\\cite{sml-nj} does\nnot even include a runtime stack. Instead, it allocates all frames and closures\non a garbage-collected heap, potentially making \nprogram analysis much more difficult.\nAnother example is Haskell, a pure functional language featuring lazy \nevaluation~\\cite{Launchbury:1993:NSL:158511.158618}\nwhich can be implemented\nwith a unique execution model that greatly differs from the traditional\nimperative computation~\\cite{marlow_2007}.\n\n\n\n\n\n\n\n\n\\end{itemize}\nAll these benefits make us believe that {translingual obfuscation}\\ could be a new direction in software protection.\n\n\n\\section{Misusing Prolog for Obfuscation}\\label{sec:background}\nIn this section we briefly introduce the Prolog programming language\nand explain why we can misuse its language features for obfuscation.\n\\subsection{Prolog Basics}\nThe basic building blocks of Prolog are \\emph{terms}. Both a\nProlog program itself and the data it manipulates are built from\nterms. There are three kinds of terms: constants, variables, and\nstructures. A constant is either a number (integer or real) or\nan atom. \nAn atom is a general-purpose name, which is similar to a constant string entity in other languages. \nA structure term is of the form $f(t_1, \\cdots, t_n)$, where $f$ is a symbol called a \\emph{functor} and\n$t_1, \\cdots, t_n$ are subterms. The number of subterms a functor takes is called its \\emph{arity}.\nIt is allowed to use a symbol with different arities, so the notation `\\texttt{f/n}' is used when \nreferring to a structure term $f$ with $n$ subterms.\n\nStructure terms become \\emph{clauses} when assigned semantics.\nA clause can be a fact, a rule, or a query.\nA predefined clause is a fact if it has an empty body, \notherwise it is a rule. For example,\n``\\texttt{parent(jack,bill).}'' is a fact, which could mean that\n``jack is a parent of bill.'' One the other hand, a rule can be like the following line of code:\n\\begin{lstlisting}[language=Prolog]\ngrandparent(G,C):-parent(G,P),parent(P,C).\n\\end{lstlisting}\nThis rule can be written as the following formula in the first-order logic:\n{\\small\n", "index": 1, "text": "\n\\[\n\\begin{array}{r@{~~}l}\n  \\forall G, C, P. \\mathrm{grandparent}(G,C)\\leftarrow\\mathrm{parent}(G,P) \\land \\mathrm{parent}(P,C)\n\\end{array}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{r@{~~}l}\\forall G,C,P.\\mathrm{grandparent}(G,C)\\leftarrow%&#10;\\mathrm{parent}(G,P)\\land\\mathrm{parent}(P,C)~{}~{}\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mo>\u2200</mo><mi>G</mi></mrow><mo>,</mo><mi>C</mi><mo>,</mo><mi>P</mi></mrow><mo>.</mo><mrow><mrow><mi>grandparent</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2190</mo><mrow><mrow><mi>parent</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo>,</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>parent</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo>,</mo><mi>C</mi><mo rspace=\"9.1pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></mtd><mtd/></mtr></mtable></math>", "type": "latex"}]