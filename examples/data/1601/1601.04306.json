[{"file": "1601.04306.tex", "nexttext": "\nNote that the function $xe^{-x}$ is bounded on $[0,\\infty)$, and has maximum $1/e$ (at $x=1$).  \nSo for $d>2$,\n\n", "itemtype": "equation", "pos": 45514, "prevtext": "\n\n\\maketitle\n\n\\begin{abstract}\nWe propose distributed algorithms for two well-established problems that\noperate efficiently under extremely harsh conditions. \nOur algorithms achieve state-of-the-art performance in a simple and novel way.\n\nOur algorithm for maximal independent set selection operates on a network of identical anonymous \nprocessors. The processor at each node has no prior information about the network. \nAt each time step, each node can only broadcast a single bit to all its neighbours, \nor remain silent. \nEach node can detect whether one or more neighbours have broadcast, but cannot\ntell how many of its neighbours have broadcast, or which ones.\n\nWe build on recent work of Afek et al. which was \ninspired by studying the development of a network of cells in the fruit fly~\\cite{Afek2011a}.\nHowever we incorporate for the first time another important feature of the biological system: \nvarying the probability value used at each node based on local feedback from neighbouring nodes. \nGiven any $n$-node network, \nour algorithm achieves the optimal expected time complexity of $O(\\log n)$ rounds \nand the optimal expected message complexity of $O(1)$ single-bit messages broadcast by each node.\nWe also show that the previous approach, without feedback, \ncannot achieve better than $\\Omega(\\log^2 n)$ expected time complexity, \nwhatever global scheme is used to choose the probabilities. \n\nOur  algorithm for distributed greedy colouring \nworks under similar harsh conditions: each identical node has no prior information about the network,\ncan only broadcast a single message to all neighbours \nat each time step representing a desired colour, and can only\ndetect whether at least one neighbour has broadcast each colour value.\nWe show that our algorithm has an expected time complexity of $O(\\Delta+\\log n)$, \nwhere $\\Delta$ is the maximum degree of the network, \nand expected message complexity of $O(1)$ messages broadcast by each node.\n\n\n\\end{abstract}\n\n\n\n\\section{Introduction}\n\\label{secIntro}\nOne of the most fundamental problems in distributed computing is to distributively choose a set of local\nleaders in a network of connected processors so that every processor is either a leader or connected to a\nleader, and no two leaders are connected to each other. This problem is known as the distributed \n{\\em maximal independent set} (MIS) selection problem \nand has been considered as a challenging problem for \nthree decades~\\cite{Afek2011a}. \nIt has many applications, especially in wireless networks~\\cite{Kroeker2011b,Peleg2000d} \nand has been extensively\nstudied~\\cite{Luby1986a,Linial1992l,Alon1986a,Kuhn2005f,Kuhn2006t,Moscibroda2005m,Metivier2011a}. \n\nAnother fundamental problem in distributed computing that is closely related to the distributed MIS \nselection problem is the \\emph{$(\\Delta+1)$-colouring} problem. \nIn this problem the aim is to colour the vertices of a graph which has maximum degree $\\Delta$ \nusing no more than $\\Delta+1$ colours so that adjacent vertices are assigned different colours. \nLike the distributed MIS selection problem, the distributed $(\\Delta+1)$-colouring problem \nalso serves as a basic building block in many other distributed\nalgorithms, and has many applications for resource assignment, \nin particular for frequency assignment in radio-communication\nnetworks~\\cite{Maan2012a,Waters2005g,Ni2011c,Park1996a}. \nBecause of this, it has also been extensively\nstudied~\\cite{Barenboim2009d,Barenboim2011d,Kuhn2009w,Panconesi1996o,Schneider2010a,Johansson1999s,Panconesi2001s,Hedetniemi2003l,Hansen2004d}.\n\nA more restricted variant of the colouring problem is called \n\\emph{greedy colouring}~\\cite{Grundy1939m,Gavoille2009o}, where the aim is to obtain \na colouring with the property that no individual vertex can be recoloured with a smaller colour \n(in some fixed ordering of the colours). Computing a greedy colouring distributively is\nbelieved to be more difficult than computing an arbitrary $(\\Delta+1)$-colouring \ndistributively~\\cite{Gavoille2009o}, but such colourings often use a much smaller number of colours.\n\n\\subsection{Our Results}\n\nIn this paper, we first propose a randomised distributed MIS selection algorithm \nthat is able to operate under very harsh conditions. Our model of distributed computing\nassumes an identical anonymous processor at each node that has {\\em no information about the network}.\nAt each time step, each node can only {\\em broadcast a single bit} to all its neighbours, \nor remain silent. \nEach node can detect whether one or more neighbours have broadcast, but cannot\ntell how many neighbours have broadcast, {\\em or which ones}.\n\nWe prove that our algorithm is optimal in both time and bit complexity for such a model, \nby showing that it runs in expected $O(\\log n)$ time, where $n$ is the number of nodes,\nand the expected number of messages sent by \neach node is bounded by a constant, regardless of the network.\n\nWe then extend the approach to obtain an algorithm for the distributed greedy colouring problem. \nThis algorithm also runs under very harsh conditions where the processors are anonymous and\nhave no information about the network. For this problem we allow each node to broadcast\nonly a single message to all neighbours at each time step representing a single desired colour value.\nOnce again nodes can only detect whether at least one neighbour has broadcast \na colour, and cannot tell how many neighbours have broadcast, or which ones.\n\nThe algorithm we obtain is remarkably simple and computes a greedy colouring in expected $O(\\Delta+\\log n)$ time,\nwhere $n$ is the number of nodes and $\\Delta$ is the maximum degree of the network.\nOnce again the expected total number of messages sent by each processor is bounded by a constant.\nAs well as matching the best known time complexity for obtaining a greedy colouring, \nour algorithm is the first proposed algorithm for this problem \nwhere the nodes require no prior knowledge of the network\nand cannot distinguish between their neighbours.\n\nTo obtain our results we introduce a new form of analysis to determine the time complexity.\nNearly all previous analytical techniques in this area have relied on a general technique, \noriginally devised by Luby~\\cite{Luby1986a}, which divides the computation into successive phases \nand shows that some fixed fraction of the network is expected to be eliminated in each phase, \nso that there are at most logarithmically many phases. Our algorithms do not have this property, and\nhence require a more flexible form of analysis, which we describe in detail below.\n\n\n\n\n\n\n\\section{Preliminaries}\n\\label{secPre}\n\nGiven an undirected graph $G=(V, E)$, the \\emph{neighbourhood} of each vertex $v \\in V$ is defined to be\nthe set $\\Gamma(v)=\\{u:\\{u,v\\}\\in E\\}$ and the \\emph{degree} of each vertex $v$ is defined \nto be the number $\\deg_G(v)=|\\Gamma(v)|$. We define the maximum degree of the graph $G$ to be the maximum\nvalue of the degree over all vertices of $G$, which is denoted by $\\Delta=\\max_{v\\in V}\\{\\deg_G(v)\\}$. \nThe number of vertices of $G$ is $|V|$ and will usually be denoted by $n$. \nWe will say that an event on $G$ occurs \\emph{with high probability} if\n\nthe probability of the event tends to 1 as $n$ tends to infinity.\n\n\nWe will write $\\log a$ for the natural logarithm of $a$, \nand $\\log_b a$ for the logarithm of $a$ to the base $b$.\n\n\\subsection{Maximal Independent Set Selection}\n\\begin{definition}[Maximal Independent Set]\nGiven an undirected graph $G = (V,E)$, an {\\em independent set} in $G$ is a subset of vertices \n$U\\subseteq V$, such that no two vertices in $U$ are adjacent. \nAn independent set $U$ is called a {\\em maximal independent set} (MIS) if no further vertex \ncan be added to $U$ without violating independence.\n\\end{definition}\n\n\nDifferent maximal independent sets for the same network can vary greatly in size. In contrast to the MIS selection problem, the related problem of finding a {\\em maximum size} independent set (MaxIS) is notoriously hard. It is equivalent to finding a maximum clique in the complementary graph, and is therefore \\textbf{NP}-hard~\\cite{Karp1972r}. However, computing an arbitrary MIS (which is not necessarily of the maximum possible size) in linear time using a centralised sequential algorithm is trivial: simply scan the nodes in arbitrary order. If a node $u$ does not violate independence, add $u$ to the MIS. If $u$ violates independence, discard it. Hence the challenge is to compute such an MIS more efficiently in a distributed way with no centralised control.\n\n\n\\subsection{Greedy Colouring}\n\nA proper colouring of a graph assigns a colour to each vertex such that no two adjacent vertices are assigned the same colour. The colouring is called a $k$-colouring if at most $k$ different colours are used.\n\n\\begin{definition}[Graph Colouring]\nFor any undirected graph $G = (V,E)$,  a {\\em $k$-colouring} of $G$ is a function \n$f$ from the vertices $V$ to a set of colours $\\{c_1,c_2, \\ldots,c_k\\}$\nsuch that $f(u)\\neq f(v)$ for every edge $\\{u,v\\}\\in E$. \n\n$G$ is called {\\em $k$-colourable} if and only if there exists a $k$-colouring of $G$.\n\\end{definition}\n\nFor many practical applications it is desirable to minimize the number of colours used.  \nThe smallest possible positive integer $k$ for which there exists a $k$-colouring of $G$ \nis defined to be the \\emph{chromatic number} $\\chi$ of $G$. \nIt is known to be \\textbf{NP}-hard to approximate the chromatic number $\\chi$ within \na factor of $|V|^{1-\\varepsilon}$, for any $\\varepsilon>0$,\neven using a centralised algorithm with complete knowledge of the graph~\\cite{Zuckerman2006l}.\n\nHowever, a number of heuristic approaches can be used to rapidly obtain colourings\nwith a reasonably low number of colours on many graphs.\nFor example, the following greedy approach produces a colouring in linear time\nusing a centralised control.\n\n\\begin{definition}[Greedy Colouring]\nGiven an arbitrary ordering, $(v_1,v_2,\\ldots,v_n)$, of the vertices of $G$,\nand an arbitrary ordering on the colour values, \na \\emph{greedy colouring} algorithm considers \neach vertex from $v_1$ to $v_n$ in turn, assigning each vertex  \nthe smallest possible colour value that is not already assigned to any of its neighbours.\n\\end{definition}\n\n\\noindent\nNote that a colouring obtained in this way has the property that no individual vertex can be recoloured \nusing a smaller colour. A colouring with this property \nis sometimes called a \\emph{Grundy colouring}~\\cite{Gavoille2009o,Grundy1939m}.\nSince every greedy colouring algorithm produces a Grundy colouring,\nand every Grundy colouring can be obtained\nusing a greedy colouring algorithm (by choosing a suitable\nordering on the vertices)~\\cite{Gavoille2009o},\nwe will refer to any Grundy colouring as a greedy colouring,\neven if it is computed in some other way. \n\nIt is easy to see that a greedy colouring uses no more than $\\Delta+1$ colours,\nso we have that $\\chi\\leq\\Delta+1$ for any graph $G$. \nBrooks Theorem strengthens this observation by stating that \n$\\Delta$ colours suffice for all\ngraphs except odd cycles and complete graphs, which require $\\Delta+1$ colours.\n\n\\subsection{Distributed Computation Model}\n\nIn the widely-used Linial model~\\cite{Chaudhuri1987a,Linial1986l,Linial1992l,Gavoille2009o},\na distributed network is composed of a set $V$ of processors and a set $E$ of bidirectional \ncommunication links (channels) between pairs of processors. \nIf there is a link (channel) between two processors, these two processors are said to be {\\em neighbours}. \nA distributed network with $n$ processors where each processor has no more than $\\Delta$ neighbours\ncorresponds to an undirected graph $G=(V, E)$ with $n$ vertices and maximum degree $\\Delta$. \nA network is called \\emph{anonymous} if the processors cannot distinguish each other \nby unique identifiers.\nLinial's distributed computation model is a synchronous system and all processors operate in a \nlockstep fashion.\nWe will assume that all processors wake up and start their computation at the same time step.\nDuring each time step, all processors act in parallel and carry out the following operations\nsequentially~\\cite{Lynch1996d}:\n\n\\begin{enumerate}\n\\item Optionally send a message to each neighbouring node;\n\n\\item Receive any messages sent by neighbours;\n\n\\item Perform arbitrary local computation.\n\n\\end{enumerate}\nThe computation is said to be complete only when the local computations at every vertex have terminated.\n\nThe distributed computation model we use is based on this model, but \nwe impose the following severe additional conditions:\n\\begin{enumerate}\n\\item Each processor is anonymous and has no local or global information about the network;\n\\item At each time step, each processor either keeps silent or broadcasts \none message to all its neighbours;\n\\item Each processor can tell whether at least one neighbour has broadcast a message, \nbut cannot tell how many of them have done so, or which ones.\n\\end{enumerate}\n\n\\noindent\nIn our MIS algorithm we restrict the communication even further, so that each message contains\nonly a single bit. \nIn our greedy colouring algorithm we allow longer messages representing different colours.\n\nInformation about a network may be difficult to obtain, or subject to \nuncertainty and change,\nso it is desirable for some applications to find algorithms that can complete their task without \nusing such information~\\cite{Halpern1990k,Prakash1997a}.\nMoreover, using a small number of messages, each containing a single bit (or a small number of bits),\nallows an implementation to use less communication resources and less energy, \nand this may be crucial in some applications~\\cite{Lenzen2012d}.\nBecause of the restrictions we impose, \nour algorithms can be implemented using very simple communication\nmechanisms such as radio waves, optical signals, or even chemical signals, as in biological\nintercellular signalling~\\cite{Bray2006n,Collier1996p}.\n\n\\section{Related Results}\n\n\\subsection{Distributed MIS selection}\n\nThe study of distributed MIS selection can be traced back to the 1980s. \nIt was shown early on that the MIS selection problem is in the complexity class \\textbf{NC}~\\cite{Karp1985a}, and hence likely to be a good candidate for a parallel\nor distributed approach. \n\nWe review the current state-of-the-art here, focusing on the size of the messages (in bits)\nand the information about the network that is used at each node (see Table~\\ref{TalgorithmsMIS}). \nIn many cases it is possible to use estimates for the required graph parameters, and to \niteratively refine these, at the cost of a more sophisticated algorithm and additional \ncommunication rounds, but we describe only the simplest versions of the algorithms,\nas originally presented.\n\n\n\\begin{table*}[th]\n\n\\caption{Distributed MIS selection algorithms on graphs with $n$ nodes and maximal degree $\\Delta$\\label{TalgorithmsMIS}}\n\\vspace{2mm}\n\n\\scalebox{0.9}{\n\n\\begin{tabular}{|l|l|l|l|l|}\n      \\hline\n\n         Type                         &                    Time Steps                                   &             Message size (bits)                      &                       \\parbox{6cm}{Information about the graph and neighbourhood used at each node}                                     &   Reference \\\\\\hline\\hline\n\\multirow{3}{*}{Det.}     & \\multirow{2}{*}{$O(\\Delta+\\log^* n)$}           & \\multirow{3}{*}{$\\Omega(\\log n)$}       &\\multirow{3}{*}{\\parbox{55mm}{Unique IDs, size and maximum degree of the graph, and distinguishable channels}}  & \\cite{Barenboim2009d}\\\\\\cline{5-5}           \n                                         &                                                                           &                                                                  &                                                                                                                    &\\cite{Kuhn2009w}\\\\\\cline{2-2}\\cline{5-5}\n                                         & \\multirow{1}{*}{$O(2^{O(\\sqrt{\\log n})})$}    &                                                                &                                                                                                                     & \\cite{Panconesi1996o}\\\\ \\cline{1-5}\n\\multirow{9}{*}{Rand.} & \\multirow{4}{*}{$O(\\log^2 n)$}                      &\\multirow{1}{*}{$\\Omega(\\log \\Delta)$} &  Maximum degree in 2-neighbourhood                                                       &\\cite{Peleg2000d}\\\\ \\cline{3-5}                                                                   \n                                         &                                                                            &  \\multirow{1}{*}{3}                                 & \\multirow{1}{*}{None}                                                                             &\\cite{Emek2013s}\\\\ \\cline{3-5}\n                                         &                                                                            & 1                                                               & Size of the graph                                                                                      &\\cite{Afek2011a}\\\\ \\cline{3-5}\n                                         &                                                                            &  1                                                               &  None                                                                                                       & \\cite{Afek2011b}\\\\ \\cline{2-5}\n                                         & \\multirow{1}{*}{$O(\\log \\Delta\\sqrt{\\log n})$} & \\multirow{1}{*}{$\\Omega(\\log n)$}        &  \\parbox{6cm}{Size, maximum degree of the graph, and distinguishable channels}                       &\\cite{Barenboim2012t}\\\\ \\cline{2-5}\n                                         & \\multirow{4}{*}{$O(\\log n)$}                            &  {$\\Omega(\\log n)$}                                &  Size of the graph                                                                                        &\\cite{Lynch1996d}\\\\ \\cline{3-5}\n                                         &                                                                            &   $\\Omega(\\log \\Delta)$                          & Degrees of neighbours                                                                                &\\cite{Wattenhofer2007l}\\\\ \\cline{3-5}\n                                         &                                                                           &  1                                                              & Distinguishable channels                                                                                           &\\cite{Metivier2011a}\\\\ \\cline{3-5}\n                                         &                                                                          & 1                                                                & \\textbf{None}                                                                                              &\\textbf{This paper}\\\\ \\cline{1-5}\n\\end{tabular}}\n\\end{table*}\n\nA lower bound of $\\Omega(\\log^* n)$ time for distributed MIS selection on graphs with \n$\\Delta \\ge 2$ is given in~\\cite{Linial1987d}. \nThe most well-known lower bound for distributed MIS selection on general graphs, \n$\\Omega(\\sqrt{\\log n/(\\log\\log n)})$, is given in~\\cite{Kuhn2004w}. \n\n\n\n\n\nThis was improved to $\\Omega{(\\min\\{\\log \\Delta,\\sqrt{\\log n}\\})}$\nin~\\cite{Kuhn2010} (see also~\\cite{Barenboim2012t}).\nAll of these lower bounds have been shown to apply to both deterministic and randomised algorithms.\nIt was observed in~\\cite{Metivier2011a} that if only one-bit messages are allowed \nto be sent along each edge in any time step, then every distributed algorithm \nto select an MIS in a ring of size $n$ requires at least $\\Omega(\\log n)$ time steps \nwith high probability.\n\n\n\nFor deterministic distributed MIS selection on general graphs, the fastest known algorithms run in\n$O(\\Delta+\\log^* n)$ time~\\cite{Kuhn2009w,Barenboim2009d} \nor $O(2^{O(\\sqrt{\\log n})})$ time~\\cite{Panconesi1996o}. \nThese deterministic MIS algorithms rely on very sophisticated multi-phase techniques, \nuse a considerable amount of global information about the graph at each node, \nincluding unique node IDs,\nand allow complex messages to be sent on specific channels between nodes.\nNote that any deterministic algorithm requires some information at each node \n(such as a unique node ID) in order to break the symmetry~\\cite{Itai1990s,Peleg2000d}. \n\nUsing randomisation to break symmetry between nodes allows for simpler\nalgorithms, often requiring a smaller number of time steps.\nA simple parallel randomised algorithm for distributed MIS selection in the PRAM model of computation\nwas presented in 1986 by Luby~\\cite{Luby1986a} and independently by Alon et al.~\\cite{Alon1986a}.\n\nThis algorithm has been adapted to the message-passing model of distributed computation in several\nslightly different ways. In the version presented by Lynch~\\cite{Lynch1996d} each processor\nis assumed to know the total size, $n$, of the graph, and chooses a random integer in the range \n1 to $n^4$ at each time step. These integers are then broadcast as messages to all neighbouring nodes,\nso the messages sent between processors contain $\\Omega(\\log n)$ bits.\nUsing these messages the nodes are able to compute an MIS by selecting the nodes that \nchoose the largest random values in their neighbourhood, removing those nodes and their neighbours, \nand iterating this process. Using the analysis from~\\cite{Luby1986a}, this process \nis shown to terminate in $O(\\log n)$ time on average and with high\nprobability.\n\nIn the version presented by Wattenhofer~\\cite{Wattenhofer2007l} the nodes choose a probability value based on their\ndegree in the graph, and use this value, together with the degree values of their neighbours to \ndecide whether to join the MIS at each time step. In this variant the nodes\nexchange messages to\ndetermine the current degrees of their neighbours at each time step, and hence the \nmessages sent between processors contain $\\Omega(\\log \\Delta)$ bits.\nOnce again, using the analysis from~\\cite{Luby1986a}, this process \nis shown to terminate in $O(\\log n)$ time on average and with high probability.\n\nIn the version presented by Peleg~\\cite{Peleg2000d} the probability value\nat each node is chosen based on the maximum degree of the nodes \nat distance 1 or 2 away from it in the graph,\nand this value is then used to decide whether to join the MIS at each time step. \nPeleg shows with a simpler analysis that this algorithm halts in $O(\\log^2 n)$ time\non average and with high probability.\nOnce again the nodes\n\nexchange messages to determine the current degrees of their neighbours \nat each time step, and hence the \nmessages sent between processors contain $\\Omega(\\log \\Delta)$ bits.\n\nThese distributed randomised algorithms, \nall based on a similar approach and generally known as Luby's algorithm, \nremained the state-of-the-art for many years, but there have recently been some new developments.\n \nA new randomised MIS algorithm with time complexity $O(\\log \\Delta\\sqrt{\\log n})$\nwas proposed in~\\cite{Barenboim2012t}. \nThis algorithm improves on the $O(\\log n)$ algorithms when $\\log \\Delta < \\sqrt{\\log n}$. \nOn the other hand, this algorithm assumes that each processor knows \nthe size and maximal degree of the graph and can distinguish \nbetween channels so that it can send different messages along different edges.\nSince it relies on exchanging information about specific nodes,\nusing node identities, the messages exchanged in this algorithm contain $\\Omega(\\log n)$ bits.\n\nAlgorithms for MIS selection on special graphs such as sparse graphs and growth-bounded graphs \nhave also been studied~\\cite{Goldberg1988p,Barenboim2010s,Schneider2008a}. \n\n\\subsection{MIS Selection with Limited Communication}\n\nThere has recently been considerable interest in finding \nefficient distributed MIS selection \nalgorithms that can work in more restricted computational models, \nsuch as wireless network models~\\cite{Moscibroda2005m,Emek2013s,Cornejo2010d,Afek2011a,Afek2011b,Metivier2011a,Xu2013s}. \n\nFor example, the approach proposed in~\\cite{Metivier2011a}\nsplits the randomly generated values at each node into single bits, and \ncommunicates them one by one. When these bits are broadcast to all neighbours, \nthis approach achieves a time complexity of $O(\\log^2 n)$. By distinguishing\nbetween different neighbours, and having separate, overlapping, exchanges of messages with \neach neighbour, the overall time complexity is brought down to $O(\\log n)$ time \non average and with high probability. \nThis is shown to be the optimal time complexity that can be achieved with one-bit messages~\\cite{Metivier2011a}.\nHowever, to achieve this optimal performance requires that each vertex can \ndistinguish between its neighbours by locally known channel names, \nso that different messages can be sent along different edges at the same time step.\n\nA more radical approach is the novel distributed MIS selection algorithm inspired by the neurological development of the fruit fly which is given in~\\cite{Afek2011a,Afek2011b}.\n\nDuring development, certain cells in the pre-neural clusters of the fruit fly specialise to become \nsensory organ precursor (SOP) cells, which later develop into cells attached to \nsmall bristles (microchaetes) on the fly that are used to sense the environment. \nDuring the first stage of this developmental process each cell either becomes an SOP or a neighbour \nof an SOP, and no two SOPs are neighbours. These observed conditions are identical to the formal\nrequirements in the maximal independent set selection problem.\n\nHowever, Afek \\textit{et al.} pointed out that the method used by the fly to select the SOPs \nappears to be rather different from the standard algorithms for choosing an MIS described above.\nThe cells of the fly appear to solve the problem using only simple local interactions between certain\nmembrane-bound proteins, notably the proteins Notch and Delta~\\cite{Bray2006n,Collier1996p}. \nMoreover, they require very little knowledge about connectivity.\nBased on their study of this developmental process, Afek \\textit{et al.} proposed an\nalgorithm that works in a \ndistributed model where each node can only broadcast to all its neighbours or remain silent.\nMoreover, each node can only detect whether at least one neighbour has broadcast a signal.\nThis model of communication is sometimes referred to as a ``beeping'' model \nwith collision detection~\\cite{Afek2011b}.\n\nIn their proposed algorithm, each node broadcasts at each time step with a certain probability,\nwhich changes over time, and then checks whether any of its neighbours has broadcast at the same time. \nAs originally presented \\cite{Afek2011a}, the algorithm\nuses a sequence of gradually increasing global probability values\ncalculated from the total number of nodes of the graph $n$ and its maximum degree $\\Delta$.\nThe algorithm was further refined by Afek \\textit{et al.} in a later paper \\cite{Afek2011b}.\nIn the later version the probability values are chosen according to a fixed pattern, so that the individual nodes require no information at all about the graph.\nHowever, in both versions the expected number of time steps required \nwas shown to be $O(\\log^2 n)$ (see Table~\\ref{TalgorithmsMIS}). \n\nAnother approach to distributed computing  \nwith very restricted communication and processing capabilities is\nthe networked finite state machine model introduced in~\\cite{Emek2013s}.\nThis only allows a fixed finite number of distinct messages, and very limited computation \nat each node, based on the notion of a randomised finite state machine, with no information \nabout the network. \nIt is shown in~\\cite{Emek2013s} that a MIS can be computed in this very restricted model \nin $O(\\log^2 n)$ time, using only 7 states and 7 corresponding messages.\n\n\n\n\\subsection{Distributed Colouring}\n\nThe problem of $(\\Delta + 1)$-colouring is closely related to MIS selection\n\n\\cite{Kuhn2006o}. \nHence it can be shown that \nthe lower bounds for distributed MIS selection mentioned above also apply for distributed \n$(\\Delta+1)$-colouring. \nSimilarly, some state-of-the-art distributed $(\\Delta+1)$-colouring algorithms \nare closely related to the algorithms for distributed MIS selection described \nearlier (see Table~\\ref{TalgorithmsGC}).\n\n\\begin{table*}[t]\n\\caption{Distributed $(\\Delta+1)$-colouring algorithms on general graphs with $n$ nodes and maximal degree $\\Delta$ \\label{TalgorithmsGC}}\n\\vspace{2mm}\n\n\\small\n\\scalebox{0.85}{\n   \\begin{tabular}{|l|l|l|l|l|l|}\n     \n\n \\hline\n      Greediness & Type & Time Steps  & \\parbox{12mm}{Message size (bits)} & Information used at each node& Reference \\\\\\hline\\hline\n \\multirow{8}{*}{Non-greedy} &\\multirow{3}{*}{Det.} & \\multirow{2}*{$O(\\Delta+\\log^*n)$}               &{\\multirow{3}{*}{$\\Omega(\\log n)$}}& \\multirow{3}{*}{\\parbox{60mm}{Unique IDs, size and maximum degree of the graph, and distinguishable channels}} & \\cite{Barenboim2009d} \\\\ \\cline{6-6}\n                                                    &                                     &                                                                           &                                                             &                                                                                                                  & \\cite{Kuhn2009w}\\\\ \\cline{3-3}\\cline{6-6}\n                                                    &                                     & \\multirow{1}{*}{$O(2^{O(\\sqrt{\\log n})})$}   &                                              &                                                                                                                    & \\cite{Panconesi1996o}\\\\ \\cline{2-6}\n\n            & \\multirow{5}{*}{Rand.}  & \\multirow{1}{*}{$O(\\log \\Delta+\\sqrt{\\log n})$}                    & \\multirow{1}{*}{$\\Omega(\\log \\Delta)$} & \\parbox{60mm}{Upper bound on the size of the graph and distinguishable channels} & \\cite{Schneider2010a}\\\\ \\cline{3-6}\n            &                                        & \\multirow{1}{*}{$O(\\log \\Delta+2^{O(\\sqrt{\\log \\log n})})$} & \\multirow{1}{*}{$\\Omega(\\log n)$} & {\\parbox{60mm}{Unique IDs, size and maximum degree of the graph, and distinguishable channels}} & \\cite{Barenboim2012t}\\\\ \\cline{3-6}\n            &                                        &  \\multirow{3}{*}{$O(\\log n)$}                                                  &  $\\Omega(\\log n)$                             & Size of the graph                                                                                       &\\cite{Lynch1996d}\\\\\\cline{4-6}\n             &                                       &                                                                                                  & \\multirow{2}{*}{$\\Omega(\\log \\Delta)$} & \\multirow{1}{*}{Degrees of neighbours}                                            & \\cite{Wattenhofer2007l}\\\\\\cline{5-6}\n            &                                        &                                                    &                                                                                                                 &  Maximum degree of the graph                                                           & \\cite{Johansson1999s}\\\\ \\hline \\hline\n\n \\multirow{5}{*}{Greedy}        & \\multirow{1}{*}{Det.} & \\multirow{1}{*}{$O(\\Delta^2+\\log^*n)$}  &  \\multirow{1}{*}{$\\Omega(\\log n)$} &  {\\parbox{60mm}{Unique IDs, maximum degree of the graph, own degree and distinguishable channels}} & \\cite{Panconesi2001s}\\\\ \\cline{2-6}\n                                                 &\\multirow{4}{*}{Rand.}& \\multirow{1}{*}{$O(\\Delta^2\\log n)$}       & \\multirow{1}{*}{$\\Omega(\\log \\Delta)$} &  Own degree and degrees of neighbours                                            & \\cite{Hansen2004d} \\\\ \\cline{3-6}                                                        \n                                                 &                                      & \\multirow{3}{*}{$O(\\Delta+\\log n)$}           & \\multirow{1}{*}{$\\Omega(\\log \\Delta)$} & Maximum degree of the graph                                                            & \\cite{Gavoille2009o} \\\\  \\cline{4-6}\n                                                 \n\n            &  &   &      \\multirow{2}{*}{\\parbox{20mm}{$O(\\log \\mu)$\\\\ (where $\\mu =$ max colour used)}}            &  \\multirow{1}{*}{Distinguishable channels}                                                     & \\cite{Metivier2010a}\\\\ \\cline{5-6}\n                                                &                                         &                                                                      &                                                                & \\textbf{None}                                                                                    &\\textbf{This paper}\\\\ \\hline   \n    \\end{tabular}}\n\\end{table*}\n\n\n\nA randomised distributed $(\\Delta+1)$-colouring algorithm requiring $O(\\log \\Delta+\\sqrt{\\log n})$ time\nis proposed in~\\cite{Schneider2010a}. In this algorithm \nthe messages represent randomised preference levels for each of the possible colours. \nThis algorithm needs to know an upper bound of the size of the graph\nand requires each processor to be able to send different messages along different channels. \nSince the messages exchanged represent colours, the message size is at least $\\Omega(\\log \\Delta)$.\n\nA randomised algorithm with expected time complexity of \n$O(\\log \\Delta+2^{O(\\sqrt{\\log \\log n})})$ \nis given in~\\cite{Barenboim2012t}. However, this algorithm relies on a deterministic algorithm to \ncomplete a partial colouring, and hence requires unique node IDs, and messages with $\\Omega(\\log n)$ bits.\n\nJohansson proposed and analysed a simple randomised distributed \n$(\\Delta + 1)$-colouring algorithm requiring $O(\\log n)$ time~\\cite{Johansson1999s}. \nThe algorithm of Johansson requires that each vertex knows the maximum degree of the graph.\nEach message corresponds to a potential colour choice, so the messages in this algorithm \ncontain $\\Omega(\\log \\Delta)$ bits. \n\nThese algorithms do not attempt to obtain {\\em greedy} colourings, and hence tend to use the \nmaximum number, $\\Delta+1$, of colours.\nFor many classes of graphs, a greedy colouring will often use considerably fewer colours,\nbut computing a greedy colouring with a distributed algorithm is a more challenging problem.\nIn fact, the problem of computing a \ngreedy colouring for a given ordering of the vertices is known to be \n\\textbf{P}-complete~\\cite{Greenlaw1995l,Gebremedhin2003g}. \n\nPanconesi and Rizzi proposed a deterministic algorithm for graph colouring \nthat attempts to use a small number of colours~\\cite{Panconesi2001s}. \nThis algorithm was not originally designed to construct a greedy colouring. However, \nit can be easily modified to become a distributed greedy colouring algorithm \nby always choosing the first available colour when assigning a colour. \nIn view of this it is described in~\\cite{Gavoille2009o} as the first distributed approach to greedy colouring. The number of time steps taken by this algorithm is $O(\\Delta^2+\\log^*n)$~\\cite{Panconesi2001s}.\nIt is quite a sophisticated algorithm which relies on a preprocessing phase to produce a forest\ndecomposition of the graph. It assumes that each vertex has a unique identifier, \nand it also requires that each vertex knows its own degree and the maximum degree of the whole graph. \nThis algorithm also requires the ability to send different messages to different neighbours simultaneously.\nBecause identifiers are exchanged the message size of the algorithm is $\\Omega(\\log n)$.\n\n\n\n\nHansen et al. proposed a randomised distributed algorithm for graph colouring in~\\cite{Hansen2004d}. \nEven though the algorithm is not explicitly described in the original paper as a greedy colouring\nalgorithm, it is pointed out in~\\cite{Gavoille2009o} that the colourings it produces\nare actually greedy colourings. The expected number of time steps taken by this algorithm to produce a\ncolouring is $O(\\Delta^2\\log n)$~\\cite{Hansen2004d}.\nHowever, this algorithm assumes that each vertex knows its degree in the graph, \nand the messages exchanged include these numerical degree values as well as the colour values. \nHence the size of each message sent is at least $\\Omega(\\log \\Delta)$ bits. \n\nGavoille et al. give a detailed theoretical study of distributed greedy colouring~\\cite{Gavoille2009o}.\nThey establish a lower bound for this problem of $\\Omega(\\log n/\\log\\log n)$ time steps.\nMoreover, they note that an arbitrary $k$-colouring can be converted to a greedy colouring by a \nsimple distributed algorithm in $O(k)$ time steps. However, the conversion algorithm \nin~\\cite{Gavoille2009o} requires \neach node to know the value of $k$. Combining this approach with the most efficient\n$(\\Delta + 1)$-colouring algorithms described earlier gives a two-stage algorithm with\nan overall expected time complexity of $O(\\Delta + \\log n)$.\n\nM{\\'e}tivier et al. proposed a simple randomised distributed $(\\Delta + 1)$-colouring algorithm requiring $O(\\Delta+\\log n)$ time~\\cite{Metivier2010a}. The algorithm proposed by M{\\'e}tivier et al., does not assume any global knowledge of the network, but requires each processor to know from which channel it receives each message. \nThe algorithm consists of two stages: it first uses randomisation to break the symmetry and\nobtains a colouring in $O(\\log n)$ time with an unbounded number of colours; \nit then reduces the number of colours used to at most $\\Delta+1$ in $O(\\Delta+\\log n)$ time.\nThe colours in this second stage are chosen to be the smallest available, so the resulting colouring \nis a greedy colouring (although this is not made explicit).\nEach message exchanged in the first stage contains only one bit, \nbut each message in the second stage represents a final colour choice.\nSince the total number of colours used may be much lower than $\\Delta$ in some classes of graphs,\nwe give an upper bound on the message size of $(\\log \\mu)$ bits for this algorithm,\nwhere $\\mu$ is the maximum colour number used.\n\n\n\n\n\n\n\\section{Algorithm for MIS Selection}\n\\label{secMIS}\n\n\\begin{table*}[th]\n\\caption{The algorithm for distributed MIS selection at each node\n\\label{alg:MISlocal}}{\n\\centering\n\\framebox{\n\\begin{minipage}[c]{0.85\\linewidth}\n\\begin{tabbing}\n{\\bf Global constants:} \\= $p_0$ : lower bound on initial probability value; \\\\\n         \\> $f_1,f_2$ : lower and upper bounds on change factor for probability value.\\[0.1cm]\n{\\bf Local variables:} \\> $p$ : local probability value, initialised to some value in $[p_0,1]$;\\\\\n         \\> $f$ : change factor for probability value, chosen arbitrarily in $[f_1,f_2]$;\\\\\n         \\> {\\sc Trying} : Boolean flag, initialised to {\\sc False}.\n\\end{tabbing}\n\\algsetup{\nlinenosize=\\tiny,\nlinenodelimiter=.,\nindent = 3em\n}\n\\begin{algorithmic}[1]\n\n\\WHILE{active, in each round}\n\\vspace*{0.2cm}\n\\STATE *FIRST EXCHANGE*\n\n\\STATE With probability $p$, \nset {\\sc Trying} $\\leftarrow$ {\\sc True} and {\\bf send} signal to all neighbours;\n\\STATE {\\bf Receive} any signals sent by neighbours;\n\\STATE Set $f$ to some value in the interval $[f_1,f_2]$;\n\\IF{any signal was received}\n   \\STATE {\\sc Trying} $\\leftarrow$ {\\sc False} and $p\\leftarrow p/f$ (decrease $p$)  \n\\ELSE\n   \\STATE $p\\leftarrow \\min\\{fp,1\\}$ (increase $p$)\n\\ENDIF\n\n\\vspace*{0.2cm}\n\\STATE *SECOND EXCHANGE*\n\\IF{{\\sc Trying}}\n    \\STATE {\\bf Send} signal to all neighbours;\n    \\STATE Join the MIS and terminate (become inactive).\n\\ENDIF\n\\STATE {\\bf Receive} any signals sent by neighbours;\n\\IF{any signal was received}\n  \\STATE Terminate (become inactive)\n\\ENDIF\n\\ENDWHILE\n\\vspace*{0.2cm}\n\\end{algorithmic}\n\\end{minipage}\n}\n}\n\\end{table*}\n\nThe distributed algorithm for MIS selection proposed by Afek \\textit{et al.} \nis remarkably simple~\\cite{Afek2011a}.\nAt each step, each node may choose, with a certain probability $p$ (that varies over time),\nto signal to all its neighbours that it wishes to join the independent set.\nIf a node chooses to issue this signal, and none of its neighbours choose to do so in the same time step,\nthen it successfully joins the independent set, and becomes inactive, \nalong with all its immediate neighbours.\nHowever if any of these neighbouring nodes issue the same signal at the same time step, \nthen the node does not succeed in joining the independent set\nat that step. This process is repeated until all nodes become inactive.\n\n\nOur new algorithm uses a similar basic scheme, but with a different approach to\nthe way that the probability value $p$\nvaries over time (see Table~\\ref{alg:MISlocal}).\nInspired by the positive feedback mechanisms that control cellular processes~\\cite{Bray2006n,Collier1996p},\nwe give each node an independently updated probability value. \nThese probabilities are initialised to arbitrary values \n(above some fixed threshold value, $p_0 > 0$).\nThey are decreased whenever one or more neighbouring nodes signal that they \nwish to join the independent set, and are increased \nwhenever no neighbouring node issues such a signal.\nWe allow each increase or decrease to be by some arbitrary factor $f$, which may vary at each step,\nbut is bounded by the global parameters $f_1$ and $f_2$ (with $1 < f_1 \\leq f_2$).\n\n\nOur main result below shows that varying the probabilities in this way, \nusing a simple local feedback mechanism,\ngives an algorithm whose expected time to compute a maximal independent set is $O(\\log n)$ (see Corollary~\\ref{logexpected}, below).\nWe also show that the expected number of signals sent by each node is \nbounded by a constant (see Theorem~\\ref{thm:expectedbeeps}, below).\n\nNote that the algorithm in Table~\\ref{alg:MISlocal} consists of two successive message exchanges.\nWe shall refer to each such pair of message exchanges as a {\\em round} of the algorithm.\nHence each round occupies two consecutive time steps.\n\nTo investigate the performance of our new algorithm in practice we \nconstructed an implementation with the probability $p$\nat each node varying as follows: $p$ is initially set to ${1}/{2}$. \nIn any round where a signal is received from at least one neighbouring cell the value of $p$ is halved. \nIn all other rounds it is doubled (up to a maximum of $1$).\nWe then compared this algorithm with the algorithm in~\\cite{Afek2011b} by running both of them on random networks with different numbers of nodes, \nwhere each edge is present with probability ${1}/{2}$~\\cite{Scott2013f}.\n\nWe found that the mean number of rounds required in our experiments to complete our algorithm \nand choose a maximal independent set in these networks was approximately $2.5 \\log_2 n$,\nfor all values of $n$ between 20 and 200. However, the mean number of rounds required by the algorithm in~\\cite{Afek2011b} to select a maximal independent set was close to the exact value of $\\log_2^2 n$.\nAfek et al. do not discuss the expected number of signals broadcast at each node in their algorithm. \nWe found that the mean number of signals sent by each node in our algorithm was less than 2, \nregardless of the size of the network. However, our experiments indicated that the mean number \nof signals sent by each node when running the algorithm described in~\\cite{Afek2011b} \nincreased with the size of the network.\n\nBefore we analyse the performance of this algorithm \nwe first demonstrate in Section~\\ref{sec:MISgloballower}\nthat the use of a feedback mechanism to adjust the probability values,\nas described in lines 5-9 of Table~\\ref{alg:MISlocal}, is crucial\nto achieving the efficiency.\n\n\n\n\\subsection{Lower Bound for Globally Chosen Probability Values}\n\\label{sec:MISgloballower}\n\nIn this section we consider a class of algorithms similar to the one described in~\\cite{Afek2011a}\nwhere each node runs through the same fixed preset sequence of probability values,\nand does not adjust these to take into account the behaviour of other nodes.\nIn other words, we consider a simplified version of the algorithm described in \nTable~\\ref{alg:MISlocal}, where the probability values at all nodes are initialised to \nthe same value $p_0$,\nand the probability updates described in lines 5-9 are replaced\nby a simple update rule that changes $p$ to the next value in some fixed sequence $p_1,p_2,\\dots$.\nWe refer to this modified algorithm as \n\\emph{MIS selection with global probability values}.\n\nOur first result constructs an explicit family of graphs with $O(n)$ vertices, for which\n{\\em any} such algorithm takes at least $\\Omega(\\log^2 n)$ rounds,\nno matter what sequence of probability values is used.\n(Note that we generally omit floors and ceilings for clarity, and the graphs we construct\nin this result have $O(n)$ vertices rather than exactly $n$ vertices, to simplify their\ndescription.)\n\n\\begin{theorem}\nThere is a constant $\\kappa>0$ such that the following holds.\nLet $G$ be the graph consisting of $n^{1/3}$ disjoint copies of the complete graph $K_d$, \nfor each $d=1,\\dots,n^{1/3}$.\nThen with high probability,\nany MIS selection algorithm with global probability values \nrunning on $G$ does not terminate within $\\kappa \\log^2 n$ rounds.\n\\end{theorem}\n\n\\begin{proof}\nLet $p_0,p_1,p_2,\\ldots,$ be the sequence of probability values used by the algorithm.  \nFix $d$, and consider a copy $K$ of $K_d$.  The probability that some vertex of $K$ is added to the\nindependent set at the $i$th round is the probability that exactly one vertex of $K$ beeps, \nand so equals\n\n", "index": 1, "text": "\\begin{equation}\n\\label{eq:problimit}\ndp_i(1-p_i)^{d-1} \\le dp_i\\exp(-(d-1)p_i).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"dp_{i}(1-p_{i})^{d-1}\\leq dp_{i}\\exp(-(d-1)p_{i}).\" display=\"block\"><mrow><mrow><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow><mo>\u2264</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nAlso, for $x\\in[0,3/2e]$, we have $1-x\\ge\\exp(-2x)$.\nSo, by inequality~\\eqref{eq:problimit}, the probability that all the vertices of $K$ are still active\nafter $T$ rounds is at least\n\n", "itemtype": "equation", "pos": 45721, "prevtext": "\nNote that the function $xe^{-x}$ is bounded on $[0,\\infty)$, and has maximum $1/e$ (at $x=1$).  \nSo for $d>2$,\n\n", "index": 3, "text": "$$\ndp_i\\exp(-(d-1)p_i) = \\frac{d}{d-1} \\cdot  (d-1)p_i\\exp(-(d-1)p_i)\\le\\frac{3}{2e}.\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"dp_{i}\\exp(-(d-1)p_{i})=\\frac{d}{d-1}\\cdot(d-1)p_{i}\\exp(-(d-1)p_{i})\\leq\\frac%&#10;{3}{2e}.\" display=\"block\"><mrow><mrow><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow></mfrac><mo>\u22c5</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2264</mo><mfrac><mn>3</mn><mrow><mn>2</mn><mo>\u2062</mo><mi>e</mi></mrow></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nThe last inequality follows from the fact that $e^{p_i} \\leq e \\leq 3$.\n\nHence if $\\sum_{i=1}^T 6dp_i e^{-dp_i}<\\frac 14\\log n$ then the nodes of $K$ remain active \nwith probability at least $n^{-1/4}$.\nIn that case the probability that the nodes in all the copies of $K_d$ become inactive \nin $T$ rounds is at most\n\n", "itemtype": "equation", "pos": 45994, "prevtext": "\nAlso, for $x\\in[0,3/2e]$, we have $1-x\\ge\\exp(-2x)$.\nSo, by inequality~\\eqref{eq:problimit}, the probability that all the vertices of $K$ are still active\nafter $T$ rounds is at least\n\n", "index": 5, "text": "\\begin{align*}\n\\prod_{i=1}^T \\big(1-dp_i e^{-(d-1)p_i}\\big)\n&\\ge \\prod_{i=1}^T \\exp(-2dp_i e^{-(d-1)p_i}) \\\\\n&= \\exp(-\\sum_{i=1}^T 2dp_i e^{-(d-1)p_i}) \\\\\n&\\ge \\exp(-\\sum_{i=1}^T 6dp_i e^{-dp_i}).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\prod_{i=1}^{T}\\big{(}1-dp_{i}e^{-(d-1)p_{i}}\\big{)}\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover></mstyle><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\prod_{i=1}^{T}\\exp(-2dp_{i}e^{-(d-1)p_{i}})\" display=\"inline\"><mrow><mi/><mo>\u2265</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover></mstyle><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\exp(-\\sum_{i=1}^{T}2dp_{i}e^{-(d-1)p_{i}})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover></mstyle><mrow><mn>2</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>d</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\exp(-\\sum_{i=1}^{T}6dp_{i}e^{-dp_{i}}).\" display=\"inline\"><mrow><mrow><mi/><mo>\u2265</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover></mstyle><mrow><mn>6</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nand so with high probability the algorithm fails to terminate in $T$ rounds.\n\nIt follows that we need only consider the case when\n\n", "itemtype": "equation", "pos": 46520, "prevtext": "\nThe last inequality follows from the fact that $e^{p_i} \\leq e \\leq 3$.\n\nHence if $\\sum_{i=1}^T 6dp_i e^{-dp_i}<\\frac 14\\log n$ then the nodes of $K$ remain active \nwith probability at least $n^{-1/4}$.\nIn that case the probability that the nodes in all the copies of $K_d$ become inactive \nin $T$ rounds is at most\n\n", "index": 7, "text": "$$(1-n^{-1/4})^{n^{1/3}} \\le \\exp (-n^{1/12}),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"(1-n^{-1/4})^{n^{1/3}}\\leq\\exp(-n^{1/12}),\" display=\"block\"><mrow><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>n</mi><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mn>4</mn></mrow></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow><msup><mi>n</mi><mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></msup><mo>\u2264</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><msup><mi>n</mi><mrow><mn>1</mn><mo>/</mo><mn>12</mn></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": " \nfor every choice of $d\\ge3$.  We will show that this implies $T=\\Omega(\\log^2 n)$.\n\nLet us choose $d$ at random.  We define a probability distribution for $d$ by\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nand so with high probability the algorithm fails to terminate in $T$ rounds.\n\nIt follows that we need only consider the case when\n\n", "index": 9, "text": "$$\\sum_{i=1}^T 6dp_i e^{-dp_i} > \\frac 14\\log n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{T}6dp_{i}e^{-dp_{i}}&gt;\\frac{1}{4}\\log n\" display=\"block\"><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><mn>6</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo>&gt;</mo><mrow><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nfor $j=3,\\ldots,n^{1/3}$ (where $c$ is a normalizing constant: note that\n$c=\\Theta(1)$, as $\\sum_{i=1}^{n^{1/3}}1/j=\\Theta(\\log n)$).\nThen, for any $p\\in[0,1]$,\n\n", "itemtype": "equation", "pos": 46912, "prevtext": " \nfor every choice of $d\\ge3$.  We will show that this implies $T=\\Omega(\\log^2 n)$.\n\nLet us choose $d$ at random.  We define a probability distribution for $d$ by\n\n", "index": 11, "text": "$${\\mathbb P}[d=j]= \\frac{c}{j\\log n},$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[d=j]=\\frac{c}{j\\log n},\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><mi>d</mi><mo>=</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><mfrac><mi>c</mi><mrow><mi>j</mi><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mfrac><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBut $\\sum_{j=0}^\\infty pe^{-jp} = p/(1-e^{-p})<2$, as $p\\in[0,1]$; \nso we have ${\\mathbb E}[dpe^{-dp}]< 2c/\\log n$.  \nBy linearity of expectation,\nchoosing a random $d$, we have \n\n", "itemtype": "equation", "pos": 47114, "prevtext": "\nfor $j=3,\\ldots,n^{1/3}$ (where $c$ is a normalizing constant: note that\n$c=\\Theta(1)$, as $\\sum_{i=1}^{n^{1/3}}1/j=\\Theta(\\log n)$).\nThen, for any $p\\in[0,1]$,\n\n", "index": 13, "text": "$$\n{\\mathbb E}[dpe^{-dp}]\n= \\sum_{j=3}^{n^{1/3}} \\frac{c}{j\\log n} jpe^{-jp}\n\\le \\frac{c}{\\log n} \\sum_{j=0}^\\infty pe^{-jp}.\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{E}}[dpe^{-dp}]=\\sum_{j=3}^{n^{1/3}}\\frac{c}{j\\log n}jpe^{-jp}\\leq%&#10;\\frac{c}{\\log n}\\sum_{j=0}^{\\infty}pe^{-jp}.\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>d</mi><mo>\u2062</mo><mi>p</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow></msup></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>3</mn></mrow><msup><mi>n</mi><mrow><mn>1</mn><mo>/</mo><mn>3</mn></mrow></msup></munderover><mrow><mfrac><mi>c</mi><mrow><mi>j</mi><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mfrac><mo>\u2062</mo><mi>j</mi><mo>\u2062</mo><mi>p</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>j</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow></msup></mrow></mrow><mo>\u2264</mo><mrow><mfrac><mi>c</mi><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mfrac><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant=\"normal\">\u221e</mi></munderover><mrow><mi>p</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>j</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow></msup></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "  \nHence there is some value of $d$ for which\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nBut $\\sum_{j=0}^\\infty pe^{-jp} = p/(1-e^{-p})<2$, as $p\\in[0,1]$; \nso we have ${\\mathbb E}[dpe^{-dp}]< 2c/\\log n$.  \nBy linearity of expectation,\nchoosing a random $d$, we have \n\n", "index": 15, "text": "$${\\mathbb E}\\left[\\sum_{i=1}^T 6dp_i e^{-dp_i}\\right] < 12cT/\\log n.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{E}}\\left[\\sum_{i=1}^{T}6dp_{i}e^{-dp_{i}}\\right]&lt;12cT/\\log n.\" display=\"block\"><mrow><mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>[</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><mn>6</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo>]</mo></mrow></mrow><mo>&lt;</mo><mrow><mrow><mn>12</mn><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>T</mi></mrow><mo>/</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": " \nBy the argument above, this quantity must be at least\n$\\frac 14\\log n$, and so we must have $T=\\Omega(\\log^2 n)$.\n\\hfill~\n{}\n\\end{proof}\n\n\n\\subsection{Time Complexity with Locally Chosen Probability Values and Feedback}\n\\label{sec:localtime}\n\nIn this section we analyse the running time of our new algorithm for distributed MIS selection\ndescribed in Table~\\ref{alg:MISlocal}, where the probability values at each node \nare locally varied in each round based on feedback from neighbouring nodes.\n\nIt follows from the analysis of~\\cite{Afek2011a} that if this algorithm terminates \n(i.e., all nodes become inactive) then it correctly identifies an MIS.\nThe only question is the number of rounds required.\n\nNote that, unlike Luby's algorithm \\cite{Alon1986a,Luby1986a}, it is not true that in \nevery round we can expect at least some constant fraction of the edges to be incident \nto nodes that become inactive in that round. \nFor example, in a complete graph nodes will only become inactive when exactly one node signals. \nIf all nodes are initialised with the same probability value and with the same (fixed) \nincrease and decrease factor $f$, then all nodes will always possess the same probability value $p_t$.\nWhenever more than one node signals, all nodes will decrease their probabilities by $f$; \nif no node signals, all nodes will increase their probabilities by $f$. \nThe probability of exactly one node signalling is thus $np_t(1-p_t)^{n-1}$ at each round $t$.\nHence, for complete graphs, \nwith high probability all nodes will remain active for any fixed constant number of rounds.\nIt follows that we must carry out a more detailed analysis over a sequence of rounds\nwhose length increases with $n$.\n\n\\begin{theorem}\\label{logrounds}\nFor any fixed values of $p_0 > 0$, and $1 < f_1 \\leq f_2$, \nthere is a constant $K_0$ such that the following holds:\nFor any graph $G$ with $n$ vertices, and any $k\\ge1$,\nthe algorithm defined in Table~\\ref{alg:MISlocal} terminates in at most $K_0 (k+1) \\log n$  rounds,\nwith probability at least $1-O(1/n^k)$.\n\\end{theorem}\n\nBefore beginning the proof of Theorem \\ref{logrounds}, it will be useful to \ndefine some notation and record a few simple facts.\n\nWe will frequently use the well-known inequality\n\n\n", "itemtype": "equation", "pos": -1, "prevtext": "  \nHence there is some value of $d$ for which\n\n", "index": 17, "text": "$$\\sum_{i=1}^T 6dp_i e^{-dp_i}< 12cT/\\log n.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{T}6dp_{i}e^{-dp_{i}}&lt;12cT/\\log n.\" display=\"block\"><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><mrow><mn>6</mn><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>d</mi><mo>\u2062</mo><msub><mi>p</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo>&lt;</mo><mrow><mrow><mn>12</mn><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>T</mi></mrow><mo>/</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\nWe will also use the following inequality, which holds for any $\\lambda > 0$ \nand any $\\delta \\in [0,1-e^{-\\lambda}]$ (it holds with equality at the ends of this interval, and \nso holds at all points in between, by convexity).\n\n", "itemtype": "equation", "pos": 49836, "prevtext": " \nBy the argument above, this quantity must be at least\n$\\frac 14\\log n$, and so we must have $T=\\Omega(\\log^2 n)$.\n\\hfill~\n{}\n\\end{proof}\n\n\n\\subsection{Time Complexity with Locally Chosen Probability Values and Feedback}\n\\label{sec:localtime}\n\nIn this section we analyse the running time of our new algorithm for distributed MIS selection\ndescribed in Table~\\ref{alg:MISlocal}, where the probability values at each node \nare locally varied in each round based on feedback from neighbouring nodes.\n\nIt follows from the analysis of~\\cite{Afek2011a} that if this algorithm terminates \n(i.e., all nodes become inactive) then it correctly identifies an MIS.\nThe only question is the number of rounds required.\n\nNote that, unlike Luby's algorithm \\cite{Alon1986a,Luby1986a}, it is not true that in \nevery round we can expect at least some constant fraction of the edges to be incident \nto nodes that become inactive in that round. \nFor example, in a complete graph nodes will only become inactive when exactly one node signals. \nIf all nodes are initialised with the same probability value and with the same (fixed) \nincrease and decrease factor $f$, then all nodes will always possess the same probability value $p_t$.\nWhenever more than one node signals, all nodes will decrease their probabilities by $f$; \nif no node signals, all nodes will increase their probabilities by $f$. \nThe probability of exactly one node signalling is thus $np_t(1-p_t)^{n-1}$ at each round $t$.\nHence, for complete graphs, \nwith high probability all nodes will remain active for any fixed constant number of rounds.\nIt follows that we must carry out a more detailed analysis over a sequence of rounds\nwhose length increases with $n$.\n\n\\begin{theorem}\\label{logrounds}\nFor any fixed values of $p_0 > 0$, and $1 < f_1 \\leq f_2$, \nthere is a constant $K_0$ such that the following holds:\nFor any graph $G$ with $n$ vertices, and any $k\\ge1$,\nthe algorithm defined in Table~\\ref{alg:MISlocal} terminates in at most $K_0 (k+1) \\log n$  rounds,\nwith probability at least $1-O(1/n^k)$.\n\\end{theorem}\n\nBefore beginning the proof of Theorem \\ref{logrounds}, it will be useful to \ndefine some notation and record a few simple facts.\n\nWe will frequently use the well-known inequality\n\n\n", "index": 19, "text": "\\begin{equation}\\label{exp}\n(1-\\delta) \\le \\exp(-\\delta).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"(1-\\delta)\\leq\\exp(-\\delta).\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\n\n\n\nFinally, we will also need the following Chernoff-type inequality: \nif $X$ is a sum of Bernoulli random variables,\nwith expected value ${\\mathbb E} X=m$, then for every $\\delta>0$,\n\n", "itemtype": "equation", "pos": 50137, "prevtext": "\n\nWe will also use the following inequality, which holds for any $\\lambda > 0$ \nand any $\\delta \\in [0,1-e^{-\\lambda}]$ (it holds with equality at the ends of this interval, and \nso holds at all points in between, by convexity).\n\n", "index": 21, "text": "\\begin{equation}\\label{exp2}\n(1-\\delta) \\ge \\exp(-\\delta \\lambda/(1-e^{-\\lambda})).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"(1-\\delta)\\geq\\exp(-\\delta\\lambda/(1-e^{-\\lambda})).\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2265</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><mi>\u03b4</mi><mo>\u2062</mo><mi>\u03bb</mi></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>\u03bb</mi></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nIn particular,\n\n", "itemtype": "equation", "pos": 50421, "prevtext": "\n\n\n\n\nFinally, we will also need the following Chernoff-type inequality: \nif $X$ is a sum of Bernoulli random variables,\nwith expected value ${\\mathbb E} X=m$, then for every $\\delta>0$,\n\n", "index": 23, "text": "$${\\mathbb P}[X>m+\\delta]\\le\\exp(-\\delta^2/(2m+2\\delta/3)).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[X&gt;m+\\delta]\\leq\\exp(-\\delta^{2}/(2m+2\\delta/3)).\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><mi>X</mi><mo>&gt;</mo><mi>m</mi><mo>+</mo><mi>\u03b4</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><msup><mi>\u03b4</mi><mn>2</mn></msup><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>m</mi><mo>+</mo><mn>2</mn><mi>\u03b4</mi><mo>/</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\nWe refer to sending a signal in the first exchange of the algorithm in Table~\\ref{alg:MISlocal}\nas ``beeping\", and receiving such a signal from a neighbour as ``hearing a beep\". \n\nFor any vertex $v$, we define $\\mu_t(v)$, which we call the ``weight'' of $v$, \nto be the probability that $v$ beeps in round $t$. \n(By convention, we set $\\mu_t(v)=0$ if $v$ is inactive at time $t$; this\nsimplifies notation, while allowing us to ignore the contribution of inactive vertices.)\nFor any $W \\subseteq V$ we write $\\mu_t(W)$ for $\\sum_{v \\in W} \\mu_t(v)$.\nNote that $\\mu_t$ is a random measure on $V$, \nas it depends on the beeps of other vertices during the first $t-1$ rounds.\n\nRecall that the set of vertices adjacent to a given vertex $v$ is called the set of\n{\\em neighbours} of $v$, and denoted by $\\Gamma(v)$. \n\n\\begin{definition}\\label{def:lambdalightMIS}\nFor any $\\lambda > 0$, a vertex $v$ will be called {\\em $\\lambda$-light} in round $t$ if\n$\\mu_t(\\Gamma(v))\\le\\lambda$ and every neighbour of $v$ has weight at most $1-\\exp(-\\lambda)$;\notherwise, vertex $v$ is called {\\em $\\lambda$-heavy}.\n\\end{definition}\n\nFor any vertex that is {\\em $\\lambda$-light}, \nthe weight of each of its neighbours individually is bounded by $1-\\exp(-\\lambda)$ \nand the sum of all its neighbours' weights is not too large \n(and so the vertex is not too likely to hear a beep at time $t$). \nNote that a fixed vertex may move back and forth between being $\\lambda$-heavy and \n$\\lambda$-light over time.\n\nOur first result establishes a lower bound on the probability that at least one vertex in a set\nof $\\lambda$-light vertices will be added to the independent set in the current round.\n\n\\begin{lemma}\\label{light}\nLet $W$ be a set of vertices that are $\\lambda$-light at round $t$. \nThe probability that at least one vertex in $W$ is added to the independent set in round $t$ \nis at least $e^{-\\phi\\lambda}(1-e^{-\\mu_t(W)})$ where $\\phi = \\lambda/(1-\\exp(-\\lambda))$.\n\\end{lemma}\n\n\\begin{proof}\nLet us order the vertices of $W$ as $w_1,\\ldots,w_m$, where $m = |W|$.  \nThe probability that some vertex of $W$ is added to the independent set in round $t$ \nis at least the probability that the smallest vertex of $W$ that beeps in round $t$ \nis added to the independent set.\nFor $i=1,\\dots,m$, define events $E_i$ and $F_i$ by\n", "itemtype": "equation", "pos": 50498, "prevtext": "\nIn particular,\n\n", "index": 25, "text": "\\begin{equation}\\label{bigup}\n{\\mathbb P}[X>2m]\\le\\exp(-m/3).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[X&gt;2m]\\leq\\exp(-m/3).\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><mi>X</mi><mo>&gt;</mo><mn>2</mn><mi>m</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><mi>m</mi><mo>/</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n", "itemtype": "equation", "pos": 52881, "prevtext": "\n\nWe refer to sending a signal in the first exchange of the algorithm in Table~\\ref{alg:MISlocal}\nas ``beeping\", and receiving such a signal from a neighbour as ``hearing a beep\". \n\nFor any vertex $v$, we define $\\mu_t(v)$, which we call the ``weight'' of $v$, \nto be the probability that $v$ beeps in round $t$. \n(By convention, we set $\\mu_t(v)=0$ if $v$ is inactive at time $t$; this\nsimplifies notation, while allowing us to ignore the contribution of inactive vertices.)\nFor any $W \\subseteq V$ we write $\\mu_t(W)$ for $\\sum_{v \\in W} \\mu_t(v)$.\nNote that $\\mu_t$ is a random measure on $V$, \nas it depends on the beeps of other vertices during the first $t-1$ rounds.\n\nRecall that the set of vertices adjacent to a given vertex $v$ is called the set of\n{\\em neighbours} of $v$, and denoted by $\\Gamma(v)$. \n\n\\begin{definition}\\label{def:lambdalightMIS}\nFor any $\\lambda > 0$, a vertex $v$ will be called {\\em $\\lambda$-light} in round $t$ if\n$\\mu_t(\\Gamma(v))\\le\\lambda$ and every neighbour of $v$ has weight at most $1-\\exp(-\\lambda)$;\notherwise, vertex $v$ is called {\\em $\\lambda$-heavy}.\n\\end{definition}\n\nFor any vertex that is {\\em $\\lambda$-light}, \nthe weight of each of its neighbours individually is bounded by $1-\\exp(-\\lambda)$ \nand the sum of all its neighbours' weights is not too large \n(and so the vertex is not too likely to hear a beep at time $t$). \nNote that a fixed vertex may move back and forth between being $\\lambda$-heavy and \n$\\lambda$-light over time.\n\nOur first result establishes a lower bound on the probability that at least one vertex in a set\nof $\\lambda$-light vertices will be added to the independent set in the current round.\n\n\\begin{lemma}\\label{light}\nLet $W$ be a set of vertices that are $\\lambda$-light at round $t$. \nThe probability that at least one vertex in $W$ is added to the independent set in round $t$ \nis at least $e^{-\\phi\\lambda}(1-e^{-\\mu_t(W)})$ where $\\phi = \\lambda/(1-\\exp(-\\lambda))$.\n\\end{lemma}\n\n\\begin{proof}\nLet us order the vertices of $W$ as $w_1,\\ldots,w_m$, where $m = |W|$.  \nThe probability that some vertex of $W$ is added to the independent set in round $t$ \nis at least the probability that the smallest vertex of $W$ that beeps in round $t$ \nis added to the independent set.\nFor $i=1,\\dots,m$, define events $E_i$ and $F_i$ by\n", "index": 27, "text": "\n\\[\nE_i=(\\mbox{$w_i$ beeps; $w_1,\\dots,w_{i-1}$ do not beep})\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"E_{i}=(\\mbox{$w_{i}$ beeps; $w_{1},\\dots,w_{i-1}$ do not beep})\" display=\"block\"><mrow><msub><mi>E</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>w</mi><mi>i</mi></msub><mtext>\u00a0beeps;\u00a0</mtext><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>w</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow><mtext>\u00a0do not beep</mtext></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nThe events $E_i\\cap F_i$ are pairwise disjoint, so using the definition of conditional probability,\nwe have that the probability that the smallest of $W$ that beeps \nis added to the independent set is\n\n", "itemtype": "equation", "pos": 52945, "prevtext": "\n", "index": 29, "text": "\n\\[\nF_i=(\\mbox{no neighbour of $w_i$ beeps}).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"F_{i}=(\\mbox{no neighbour of $w_{i}$ beeps}).\" display=\"block\"><mrow><mrow><msub><mi>F</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>no neighbour of\u00a0</mtext><msub><mi>w</mi><mi>i</mi></msub><mtext>\u00a0beeps</mtext></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nIt is easily seen that ${\\mathbb P}[F_i|E_i]\\ge {\\mathbb P}[F_i]$ since ${\\mathbb P}[F_i|E_i]$ is conditioned on the\nevent that $w_i$ beeps and $w_1,\\dots,w_{i-1}$ do not. \nHence we have \n\n", "itemtype": "equation", "pos": 53195, "prevtext": "\nThe events $E_i\\cap F_i$ are pairwise disjoint, so using the definition of conditional probability,\nwe have that the probability that the smallest of $W$ that beeps \nis added to the independent set is\n\n", "index": 31, "text": "$$\n{\\mathbb P}\\left[\\bigcup_{i=1}^m(E_i\\cap F_i)\\right]\n=\\sum_{i=1}^m {\\mathbb P}[E_i\\cap F_i]\n=\\sum_{i=1}^m  {\\mathbb P}[E_i]{\\mathbb P}[F_i |E_i].\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}\\left[\\bigcup_{i=1}^{m}(E_{i}\\cap F_{i})\\right]=\\sum_{i=1}^{m}{%&#10;\\mathbb{P}}[E_{i}\\cap F_{i}]=\\sum_{i=1}^{m}{\\mathbb{P}}[E_{i}]{\\mathbb{P}}[F_{%&#10;i}|E_{i}].\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo>[</mo><munderover><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mo stretchy=\"false\">(</mo><msub><mi>E</mi><mi>i</mi></msub><mo>\u2229</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>]</mo></mrow><mo>=</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>E</mi><mi>i</mi></msub><mo>\u2229</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nSince $w_i$ is $\\lambda$-light, we may apply Inequality~\\eqref{exp2}, to conclude that \n\n", "itemtype": "equation", "pos": 53535, "prevtext": "\nIt is easily seen that ${\\mathbb P}[F_i|E_i]\\ge {\\mathbb P}[F_i]$ since ${\\mathbb P}[F_i|E_i]$ is conditioned on the\nevent that $w_i$ beeps and $w_1,\\dots,w_{i-1}$ do not. \nHence we have \n\n", "index": 33, "text": "$${\\mathbb P}[F_i |E_i] \\ge {\\mathbb P}[F_i] = \\prod_{v\\in \\Gamma(w_i)}(1-\\mu_t(v))$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[F_{i}|E_{i}]\\geq{\\mathbb{P}}[F_{i}]=\\prod_{v\\in\\Gamma(w_{i})}(1-%&#10;\\mu_{t}(v))\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>\u2265</mo><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>=</mo><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>v</mi><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>-</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nwhere $\\phi = \\lambda/(1-\\exp(-\\lambda))$.\n\nHence we have\n\n", "itemtype": "equation", "pos": 53709, "prevtext": "\nSince $w_i$ is $\\lambda$-light, we may apply Inequality~\\eqref{exp2}, to conclude that \n\n", "index": 35, "text": "\\begin{align*}\n\\prod_{v\\in \\Gamma(w_i)}(1-\\mu_t(v)) \n& \\ge \\prod_{v\\in \\Gamma(w_i)}\\exp(-\\phi\\mu_t(v))\\\\ \n& = \\exp(-\\phi \\mu_t(\\Gamma(w_i)))\\\\\n& \\ge \\exp(-\\phi\\lambda)\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\prod_{v\\in\\Gamma(w_{i})}(1-\\mu_{t}(v))\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>v</mi><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder></mstyle><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\prod_{v\\in\\Gamma(w_{i})}\\exp(-\\phi\\mu_{t}(v))\" display=\"inline\"><mrow><mi/><mo>\u2265</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>v</mi><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder></mstyle><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\exp(-\\phi\\mu_{t}(\\Gamma(w_{i})))\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\exp(-\\phi\\lambda)\" display=\"inline\"><mrow><mi/><mo>\u2265</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mi>\u03bb</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBut $\\sum_{i=1}^m {\\mathbb P}[E_i]$ is simply the probability that some vertex in $W$ beeps,\nwhich is given by $1-\\prod_{v \\in W}(1-\\mu_t(v))$.\nUsing Inequality~\\eqref{exp} this value is at least $1-\\exp(-\\mu_t(W))$.  \n\nThus the probability that some vertex of $W$ is added to the independent set in round $t$ \nis at least\n\n", "itemtype": "equation", "pos": 53948, "prevtext": "\nwhere $\\phi = \\lambda/(1-\\exp(-\\lambda))$.\n\nHence we have\n\n", "index": 37, "text": "$$\n\\sum_{i=1}^m  {\\mathbb P}[E_i]{\\mathbb P}[F_i |E_i]\\ge \\exp(-\\phi\\lambda)\\sum_{i=1}^m {\\mathbb P}[E_i].\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{m}{\\mathbb{P}}[E_{i}]{\\mathbb{P}}[F_{i}|E_{i}]\\geq\\exp(-\\phi%&#10;\\lambda)\\sum_{i=1}^{m}{\\mathbb{P}}[E_{i}].\" display=\"block\"><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy=\"false\">|</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>\u2265</mo><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><mi>\u03d5</mi><mi>\u03bb</mi><mo stretchy=\"false\">)</mo></mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\n\\hfill~\n{}\n\\end{proof}\n\n\n\\begin{proof}[of Theorem \\ref{logrounds}]\nFix an arbitrary vertex $v$.\nWe shall show that, with failure probability $O(1/n^{k+1})$,\n$v$ becomes inactive within $K_0 (k+1)\\log n$ rounds, for a suitable choice of constant $K_0$.\nTaking a union bound over all $n$ choices of $v$, it follows that with failure probability $O(1/n^k)$\nevery vertex becomes inactive and the algorithm terminates\nwithin $K_0 (k+1)\\log n$ rounds, which proves the theorem.\n\nAt each time step $t\\ge1$, we partition the neighbourhood of $v$ into $\\lambda$-light \nand $\\lambda$-heavy vertices, for a suitable fixed choice of $\\lambda$\n\n", "itemtype": "equation", "pos": 54381, "prevtext": "\nBut $\\sum_{i=1}^m {\\mathbb P}[E_i]$ is simply the probability that some vertex in $W$ beeps,\nwhich is given by $1-\\prod_{v \\in W}(1-\\mu_t(v))$.\nUsing Inequality~\\eqref{exp} this value is at least $1-\\exp(-\\mu_t(W))$.  \n\nThus the probability that some vertex of $W$ is added to the independent set in round $t$ \nis at least\n\n", "index": 39, "text": "$$\\exp(-\\phi\\lambda)\\sum_{i=1}^m {\\mathbb P}[E_i]\\ge e^{-\\phi\\lambda}(1-e^{-\\mu_t(W)}).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"\\exp(-\\phi\\lambda)\\sum_{i=1}^{m}{\\mathbb{P}}[E_{i}]\\geq e^{-\\phi\\lambda}(1-e^{%&#10;-\\mu_{t}(W)}).\" display=\"block\"><mrow><mrow><mrow><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mi>\u03bb</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mi>\u2119</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>\u2265</mo><mrow><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mi>\u03bb</mi></mrow></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\nWe will follow the behaviour of $\\mu_t(L_t)$ and $\\mu_t(H_t)$ over time.\n\nThe idea of the argument is roughly as follows:  if $\\mu_t(L_t)$\nis large at many rounds, then by Lemma~\\ref{light} it is very likely that some neighbour of $v$ will\nbe added to the independent set on one of these occasions, leading to $v$ becoming inactive.\nIf this does not happen, then  $\\mu_t(L_t)$ must be small most of the time.\nNow consider $H_t$.  Vertices that are $\\lambda$-heavy at time $t$ are likely to hear beeps\nand so drop in weight (as their signalling probability is reduced);\nit will follow that with high probability $\\mu_{t+1}(H_{t})$ is a constant factor smaller \nthan $\\mu_t(H_t)$ most of the time.\nNow we look at the evolution of $\\mu_t(\\Gamma(v))$, the weight of the whole neighbourhood of $v$.\nIt may be large and increasing for some small fraction of the time,\nbut mostly it is either shrinking or else it is already small.  \nIt will follow that, for at least some fixed fraction of the time, $\\mu_t(\\Gamma(v))$ is small.\nBut this implies that, for at least some fixed fraction of the time, $v$ will not hear any beeps,\nand hence $\\mu_t(v)$ will be large for some fixed fraction of the time.\nThis implies that it is very likely that at some point in the sequence of rounds we are considering \n$v$ will beep and not hear any beeps, and so get added to the independent set.\n\nTo make this argument precise, we now define the following constants:\n\n", "itemtype": "equation", "pos": 55103, "prevtext": "\n\n\\hfill~\n{}\n\\end{proof}\n\n\n\\begin{proof}[of Theorem \\ref{logrounds}]\nFix an arbitrary vertex $v$.\nWe shall show that, with failure probability $O(1/n^{k+1})$,\n$v$ becomes inactive within $K_0 (k+1)\\log n$ rounds, for a suitable choice of constant $K_0$.\nTaking a union bound over all $n$ choices of $v$, it follows that with failure probability $O(1/n^k)$\nevery vertex becomes inactive and the algorithm terminates\nwithin $K_0 (k+1)\\log n$ rounds, which proves the theorem.\n\nAt each time step $t\\ge1$, we partition the neighbourhood of $v$ into $\\lambda$-light \nand $\\lambda$-heavy vertices, for a suitable fixed choice of $\\lambda$\n\n", "index": 41, "text": "\\begin{align*}\nL_t=L_t(v)=&\\{x\\in\\Gamma(v) \\mid x\\ \\text{is $\\lambda$-light at step $t$}\\} \\\\\nH_t=H_t(v)=&\\{x\\in\\Gamma(v) \\mid x\\ \\text{is $\\lambda$-heavy at step $t$}\\}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle L_{t}=L_{t}(v)=\" display=\"inline\"><mrow><msub><mi>L</mi><mi>t</mi></msub><mo>=</mo><mrow><msub><mi>L</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{x\\in\\Gamma(v)\\mid x\\ \\text{is $\\lambda$-light at step $t$}\\}\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mi>x</mi><mo>\u2208</mo><mi mathvariant=\"normal\">\u0393</mi><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2223</mo><mpadded width=\"+5pt\"><mi>x</mi></mpadded><mrow><mtext>is\u00a0</mtext><mi>\u03bb</mi><mtext>-light at step\u00a0</mtext><mi>t</mi></mrow><mo stretchy=\"false\">}</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle H_{t}=H_{t}(v)=\" display=\"inline\"><mrow><msub><mi>H</mi><mi>t</mi></msub><mo>=</mo><mrow><msub><mi>H</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{x\\in\\Gamma(v)\\mid x\\ \\text{is $\\lambda$-heavy at step $t$}\\}.\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mi>x</mi><mo>\u2208</mo><mi mathvariant=\"normal\">\u0393</mi><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2223</mo><mpadded width=\"+5pt\"><mi>x</mi></mpadded><mrow><mtext>is\u00a0</mtext><mi>\u03bb</mi><mtext>-heavy at step\u00a0</mtext><mi>t</mi></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nThe values of these constants depend only on the fixed parameters $f_1$ and $f_2$ which bound the probability update factor $f$ used in the algorithm,\nand on the initial minimum probability threshold $p_0$ (see Table~\\ref{alg:MISlocal}). \nNote that $1 < f_1 \\leq f_2$, so $r \\geq 2$ and $\\lambda > \\log 256 > 5$.\n\nTo simplify the presentation, we also define\n\n", "itemtype": "equation", "pos": 56732, "prevtext": "\n\nWe will follow the behaviour of $\\mu_t(L_t)$ and $\\mu_t(H_t)$ over time.\n\nThe idea of the argument is roughly as follows:  if $\\mu_t(L_t)$\nis large at many rounds, then by Lemma~\\ref{light} it is very likely that some neighbour of $v$ will\nbe added to the independent set on one of these occasions, leading to $v$ becoming inactive.\nIf this does not happen, then  $\\mu_t(L_t)$ must be small most of the time.\nNow consider $H_t$.  Vertices that are $\\lambda$-heavy at time $t$ are likely to hear beeps\nand so drop in weight (as their signalling probability is reduced);\nit will follow that with high probability $\\mu_{t+1}(H_{t})$ is a constant factor smaller \nthan $\\mu_t(H_t)$ most of the time.\nNow we look at the evolution of $\\mu_t(\\Gamma(v))$, the weight of the whole neighbourhood of $v$.\nIt may be large and increasing for some small fraction of the time,\nbut mostly it is either shrinking or else it is already small.  \nIt will follow that, for at least some fixed fraction of the time, $\\mu_t(\\Gamma(v))$ is small.\nBut this implies that, for at least some fixed fraction of the time, $v$ will not hear any beeps,\nand hence $\\mu_t(v)$ will be large for some fixed fraction of the time.\nThis implies that it is very likely that at some point in the sequence of rounds we are considering \n$v$ will beep and not hear any beeps, and so get added to the independent set.\n\nTo make this argument precise, we now define the following constants:\n\n", "index": 43, "text": "\\begin{align*}\n\\label{constants}\nr      & = 1 + (\\log{f_2}/\\log{f_1});\\\\\n\\lambda& = \\log(32r(r+2)(f_2-f_1^{-1})/(f_2^{-1/r}-f_1^{-1}));\\\\\n\\phi   & = \\lambda/(1-\\exp(-\\lambda));\\\\\n\\beta  & = 1/(4(r+2)\\phi f_2);\\\\\n\\alpha & =(\\beta/2)(f_2^{-1/r}-f_1^{-1})/(f_2-f_1^{-1});\\\\\nK_0    & = (8r(r+2)) \\max\\{6,1/p_0,1/\\log f_2,1/(e^{-\\phi\\lambda}(1-e^{-\\alpha}))\\};\n\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r\" display=\"inline\"><mi>r</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=1+(\\log{f_{2}}/\\log{f_{1}});\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mn>1</mn><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>/</mo><mrow><mi>log</mi><mo>\u2061</mo><msub><mi>f</mi><mn>1</mn></msub></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>;</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\lambda\" display=\"inline\"><mi>\u03bb</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\log(32r(r+2)(f_{2}-f_{1}^{-1})/(f_{2}^{-1/r}-f_{1}^{-1}));\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>32</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>;</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\phi\" display=\"inline\"><mi>\u03d5</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\lambda/(1-\\exp(-\\lambda));\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mi>\u03bb</mi><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mi>\u03bb</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>;</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\beta\" display=\"inline\"><mi>\u03b2</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=1/(4(r+2)\\phi f_{2});\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mn>1</mn><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>4</mn><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>;</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\alpha\" display=\"inline\"><mi>\u03b1</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(\\beta/2)(f_{2}^{-1/r}-f_{1}^{-1})/(f_{2}-f_{1}^{-1});\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b2</mi><mo>/</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>;</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle K_{0}\" display=\"inline\"><msub><mi>K</mi><mn>0</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(8r(r+2))\\max\\{6,1/p_{0},1/\\log f_{2},1/(e^{-\\phi\\lambda}(1-e^{-%&#10;\\alpha}))\\};\\par&#10;\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>8</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">{</mo><mn>6</mn><mo>,</mo><mrow><mn>1</mn><mo>/</mo><msub><mi>p</mi><mn>0</mn></msub></mrow><mo>,</mo><mrow><mn>1</mn><mo>/</mo><mrow><mi>log</mi><mo>\u2061</mo><msub><mi>f</mi><mn>2</mn></msub></mrow></mrow><mo>,</mo><mrow><mn>1</mn><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>e</mi><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mi>\u03bb</mi></mrow></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>\u03b1</mi></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></mrow><mo>;</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\n\nAt each round $t$, we consider the following four possible events:\n\\begin{enumerate}\n\\item[(E1)]  $\\mu_t(L_t)\\ge \\alpha$\n\n[`$\\Gamma(v)$ has a significant weight of light neighbours']\n\\item[(E2)]  $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))\\le \\beta$\n\n[`$v$ is very light']\n\\item[(E3)]  $\\mu_t(L_t)< \\alpha$, $\\mu_t(\\Gamma(v))> \\beta$\nand $\\mu_{t+1}(\\Gamma(v))\\le f_2^{-1/r}\\mu_t(\\Gamma(v))$\n\n[`the neighbourhood of $v$ shrinks significantly in weight during round $t$']\n\\item[(E4)]  $\\mu_t(L_t)< \\alpha$, $\\mu_t(\\Gamma(v))> \\beta$\nand $\\mu_{t+1}(\\Gamma(v))>f_2^{-1/r}\\mu_t(\\Gamma(v))$\n\n[`the neighbourhood of $v$ does not shrink significantly in weight during round $t$ (and may grow)']\n\\end{enumerate}\nExactly one of these events must occur in each round.  \n\n\n\n\n\nWe organize the rest of the proof as a series of claims.\n\n\\begin{subclaim}\\label{claimE1limit}\nWith failure probability $O(1/n^{k+1})$, \n(E1) occurs at most $(K\\log n)/(8r(r+2))$ times in the first $K\\log n$ rounds.\n\\end{subclaim}\n\nEach time that (E1) occurs, it follows from Lemma \\ref{light} that \nwith probability at least $ e^{-\\phi\\lambda}(1-e^{-\\mu_t(L_t)}) \\ge e^{-\\phi\\lambda}(1-e^{-\\alpha})$\nsome vertex of $L_t$ is added to the independent set \n(and so $v$ becomes inactive and the process at $v$ terminates).\nLet $\\phi_1= e^{-\\phi\\lambda}(1-e^{-\\alpha})$:\nthe probability that (E1) occurs\nat least\n$(K\\log n)/(8r(r+2))$ times without $v$ becoming inactive is at most\n$(1-\\phi_1)^{(K\\log n)/(8r(r+2))}$ which is\nat most \n", "itemtype": "equation", "pos": 57461, "prevtext": "\nThe values of these constants depend only on the fixed parameters $f_1$ and $f_2$ which bound the probability update factor $f$ used in the algorithm,\nand on the initial minimum probability threshold $p_0$ (see Table~\\ref{alg:MISlocal}). \nNote that $1 < f_1 \\leq f_2$, so $r \\geq 2$ and $\\lambda > \\log 256 > 5$.\n\nTo simplify the presentation, we also define\n\n", "index": 45, "text": "\\begin{align*}\nK      & = K_0 (k+1).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle K\" display=\"inline\"><mi>K</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=K_{0}(k+1).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><msub><mi>K</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBy our choice of $K_0$, we have $K_0 \\geq (8r(r+2))/\\phi_1$,\nso this probability is at most $\\exp(-(k+1)\\log n)=n^{-(k+1)}$.  \nThis proves Claim~\\ref{claimE1limit}.\n\nThe bad event for us will be (E4), so let us bound the probability that (E4) occurs.\n\n\\begin{subclaim}\\label{claimE4prob}\nAt each round $t$, the probability that (E4) occurs is at most $1/(16r(r+2))$.\n\\end{subclaim}\n\nIf (E4) can occur, then we must have that $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))> \\beta$. \nFor any $x\\in H_t$, there are two cases to consider - the first is that the total weight of all its\nneighbouring vertices is greater than $\\lambda$; the second is that at least one of its neighbouring\nvertices individually has weight more than $1-\\exp(-\\lambda)$.\n\nIn the first case, using Inequality~\\eqref{exp}, the probability that no neighbour of $x$ beeps \nin round $t$ is at most $\\exp(-\\mu_t(\\Gamma(x)))$ which is bounded by $\\exp(-\\lambda)$. \nIn the second case, the probability that no neighbour of $x$ beeps in round $t$ \nis still at most $\\exp(-\\lambda)$. \nThus, for any $x \\in H_t$ we have shown that the probability that no neighbour of $x$ beeps \nin round $t$ is at most $\\exp(-\\lambda)$. \n\nLet $H_t^0$ be the set of vertices in $H_t$ that do not hear a beep in round $t$,\nand let $H_t^1=H_t\\setminus H_t^0$ be the remaining vertices in $H_t$ that do hear a beep. Then\n$\n{\\mathbb E}[\\mu_t(H_t^0)]\\le \\exp(-\\lambda)\\mu_t(H_t),\n$\nand so by Markov's inequality\n\n", "itemtype": "equation", "pos": 59005, "prevtext": "\n\nAt each round $t$, we consider the following four possible events:\n\\begin{enumerate}\n\\item[(E1)]  $\\mu_t(L_t)\\ge \\alpha$\n\n[`$\\Gamma(v)$ has a significant weight of light neighbours']\n\\item[(E2)]  $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))\\le \\beta$\n\n[`$v$ is very light']\n\\item[(E3)]  $\\mu_t(L_t)< \\alpha$, $\\mu_t(\\Gamma(v))> \\beta$\nand $\\mu_{t+1}(\\Gamma(v))\\le f_2^{-1/r}\\mu_t(\\Gamma(v))$\n\n[`the neighbourhood of $v$ shrinks significantly in weight during round $t$']\n\\item[(E4)]  $\\mu_t(L_t)< \\alpha$, $\\mu_t(\\Gamma(v))> \\beta$\nand $\\mu_{t+1}(\\Gamma(v))>f_2^{-1/r}\\mu_t(\\Gamma(v))$\n\n[`the neighbourhood of $v$ does not shrink significantly in weight during round $t$ (and may grow)']\n\\end{enumerate}\nExactly one of these events must occur in each round.  \n\n\n\n\n\nWe organize the rest of the proof as a series of claims.\n\n\\begin{subclaim}\\label{claimE1limit}\nWith failure probability $O(1/n^{k+1})$, \n(E1) occurs at most $(K\\log n)/(8r(r+2))$ times in the first $K\\log n$ rounds.\n\\end{subclaim}\n\nEach time that (E1) occurs, it follows from Lemma \\ref{light} that \nwith probability at least $ e^{-\\phi\\lambda}(1-e^{-\\mu_t(L_t)}) \\ge e^{-\\phi\\lambda}(1-e^{-\\alpha})$\nsome vertex of $L_t$ is added to the independent set \n(and so $v$ becomes inactive and the process at $v$ terminates).\nLet $\\phi_1= e^{-\\phi\\lambda}(1-e^{-\\alpha})$:\nthe probability that (E1) occurs\nat least\n$(K\\log n)/(8r(r+2))$ times without $v$ becoming inactive is at most\n$(1-\\phi_1)^{(K\\log n)/(8r(r+2))}$ which is\nat most \n", "index": 47, "text": "$$\\exp(-(\\phi_1K_0/(8r(r+2)))(k+1)\\log n).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"\\exp(-(\\phi_{1}K_{0}/(8r(r+2)))(k+1)\\log n).\" display=\"block\"><mrow><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>K</mi><mn>0</mn></msub></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>8</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nNow all vertices in $H_t^1$ decrease their weight by a factor of at least $f_1$, \nwhile vertices in $L_t$ and $H_t^0$ may either decrease or increase their weight \n(additionally, some weights may get set to 0 if vertices become inactive).  So\n\n", "itemtype": "equation", "pos": 60500, "prevtext": "\nBy our choice of $K_0$, we have $K_0 \\geq (8r(r+2))/\\phi_1$,\nso this probability is at most $\\exp(-(k+1)\\log n)=n^{-(k+1)}$.  \nThis proves Claim~\\ref{claimE1limit}.\n\nThe bad event for us will be (E4), so let us bound the probability that (E4) occurs.\n\n\\begin{subclaim}\\label{claimE4prob}\nAt each round $t$, the probability that (E4) occurs is at most $1/(16r(r+2))$.\n\\end{subclaim}\n\nIf (E4) can occur, then we must have that $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))> \\beta$. \nFor any $x\\in H_t$, there are two cases to consider - the first is that the total weight of all its\nneighbouring vertices is greater than $\\lambda$; the second is that at least one of its neighbouring\nvertices individually has weight more than $1-\\exp(-\\lambda)$.\n\nIn the first case, using Inequality~\\eqref{exp}, the probability that no neighbour of $x$ beeps \nin round $t$ is at most $\\exp(-\\mu_t(\\Gamma(x)))$ which is bounded by $\\exp(-\\lambda)$. \nIn the second case, the probability that no neighbour of $x$ beeps in round $t$ \nis still at most $\\exp(-\\lambda)$. \nThus, for any $x \\in H_t$ we have shown that the probability that no neighbour of $x$ beeps \nin round $t$ is at most $\\exp(-\\lambda)$. \n\nLet $H_t^0$ be the set of vertices in $H_t$ that do not hear a beep in round $t$,\nand let $H_t^1=H_t\\setminus H_t^0$ be the remaining vertices in $H_t$ that do hear a beep. Then\n$\n{\\mathbb E}[\\mu_t(H_t^0)]\\le \\exp(-\\lambda)\\mu_t(H_t),\n$\nand so by Markov's inequality\n\n", "index": 49, "text": "\\begin{equation}\\label{mi}\n{\\mathbb P}\\left[\\mu_t(H_t^0) \\ge 16r(r+2)\\exp(-\\lambda)\\mu_t(H_t)\\right]\\le 1/(16r(r+2)).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}\\left[\\mu_{t}(H_{t}^{0})\\geq 16r(r+2)\\exp(-\\lambda)\\mu_{t}(H_{t})%&#10;\\right]\\leq 1/(16r(r+2)).\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo>[</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>H</mi><mi>t</mi><mn>0</mn></msubsup><mo stretchy=\"false\">)</mo></mrow><mo>\u2265</mo><mn>16</mn><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><mi>\u03bb</mi><mo stretchy=\"false\">)</mo></mrow><msub><mi>\u03bc</mi><mi>t</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>H</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>]</mo></mrow><mo>\u2264</mo><mn>1</mn><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mn>16</mn><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nIt follows from Inequality~\\eqref{mi} that, with probability at least $1-1/(16r(r+2))$,\n\n", "itemtype": "equation", "pos": 60876, "prevtext": "\nNow all vertices in $H_t^1$ decrease their weight by a factor of at least $f_1$, \nwhile vertices in $L_t$ and $H_t^0$ may either decrease or increase their weight \n(additionally, some weights may get set to 0 if vertices become inactive).  So\n\n", "index": 51, "text": "\\begin{align*}\n\\mu_{t+1}(\\Gamma(v))\n& \\le \\frac{1}{f_1}\\mu_t(H_t^1) + f_2\\mu_t(H_t^0) +f_2\\mu_t(L_t)\\\\\n& =\\frac1{f_1}\\mu_t(\\Gamma(v))\\\\\n& ~~~~+ (f_2-\\frac1{f_1})\\mu_t(H_t^0) +(f_2-\\frac1{f_1})\\mu_t(L_t)\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\mu_{t+1}(\\Gamma(v))\" display=\"inline\"><mrow><msub><mi>\u03bc</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{1}{f_{1}}\\mu_{t}(H_{t}^{1})+f_{2}\\mu_{t}(H_{t}^{0})+f_{%&#10;2}\\mu_{t}(L_{t})\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>H</mi><mi>t</mi><mn>1</mn></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>H</mi><mi>t</mi><mn>0</mn></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>L</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\frac{1}{f_{1}}\\mu_{t}(\\Gamma(v))\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle~{}~{}~{}~{}+(f_{2}-\\frac{1}{f_{1}})\\mu_{t}(H_{t}^{0})+(f_{2}-%&#10;\\frac{1}{f_{1}})\\mu_{t}(L_{t})\" display=\"inline\"><mrow><mpadded width=\"+9.9pt\"><mi mathvariant=\"normal\">\u00a0</mi></mpadded><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msubsup><mi>H</mi><mi>t</mi><mn>0</mn></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>L</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nwhere the final inequality follows from our\nchoice of $\\lambda$, which gives\n\n", "itemtype": "equation", "pos": 61180, "prevtext": "\nIt follows from Inequality~\\eqref{mi} that, with probability at least $1-1/(16r(r+2))$,\n\n", "index": 53, "text": "\\begin{align*}\n\\mu_{t+1}(\\Gamma(v))\n& \\le \\frac1{f_1}\\mu_t(\\Gamma(v)) + (f_2-\\frac1{f_1}) 16r(r+2)e^{-\\lambda}\\mu_t(H_t)\\\\\n& \\hspace{1cm} +(f_2-\\frac1{f_1})\\mu_t(L_t)\\\\\n& \\le f_2^{-1/r}\\mu_t(\\Gamma(v)),\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\mu_{t+1}(\\Gamma(v))\" display=\"inline\"><mrow><msub><mi>\u03bc</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{1}{f_{1}}\\mu_{t}(\\Gamma(v))+(f_{2}-\\frac{1}{f_{1}})16r(%&#10;r+2)e^{-\\lambda}\\mu_{t}(H_{t})\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mn>16</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>\u03bb</mi></mrow></msup><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>H</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+(f_{2}-\\frac{1}{f_{1}})\\mu_{t}(L_{t})\" display=\"inline\"><mrow><mi>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</mi><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>f</mi><mn>1</mn></msub></mfrac></mstyle></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>L</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq f_{2}^{-1/r}\\mu_{t}(\\Gamma(v)),\" display=\"inline\"><mrow><mrow><mi/><mo>\u2264</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nand our choice of $\\alpha$ and $\\beta$, \nbecause we are assuming that $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))> \\beta$, so we have \n\n", "itemtype": "equation", "pos": 61473, "prevtext": "\nwhere the final inequality follows from our\nchoice of $\\lambda$, which gives\n\n", "index": 55, "text": "\\begin{align*}\n(f_2-f_1^{-1}) & 16r(r+2)e^{-\\lambda}\\mu_t(H_t)\\\\\n               & \\leq (f_2-f_1^{-1}) 16r(r+2)e^{-\\lambda}\\mu_t(\\Gamma(v))\\\\\n               & \\leq 1/2(f_2^{-1/r}-f_1^{-1})\\mu_t(\\Gamma(v)),\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(f_{2}-f_{1}^{-1})\" display=\"inline\"><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 16r(r+2)e^{-\\lambda}\\mu_{t}(H_{t})\" display=\"inline\"><mrow><mn>16</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>\u03bb</mi></mrow></msup><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>H</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex38.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq(f_{2}-f_{1}^{-1})16r(r+2)e^{-\\lambda}\\mu_{t}(\\Gamma(v))\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mn>16</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mi>\u03bb</mi></mrow></msup><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex39.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq 1/2(f_{2}^{-1/r}-f_{1}^{-1})\\mu_{t}(\\Gamma(v)),\" display=\"inline\"><mrow><mrow><mi/><mo>\u2264</mo><mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nThus the probability that (E4) does occur is bounded above by $1/(16r(r+2))$.  \nThis proves Claim~\\ref{claimE4prob}.\n\n\n\n\\begin{subclaim}\\label{claimE4limit}\nWith failure probability $O(1/n^{k+1})$, (E4) occurs at most $(K\\log n)/(8r(r+2))$ times\nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nAt each round, the probability of (E4) depends on the past history of the process.\nHowever, by Claim~\\ref{claimE4prob}, it is always at most $1/(16r(r+2))$, and so\nwe can couple occurrences of (E4) with a sequence of independent events each occurring with probability\n$1/(16r(r+2))$.  It follows that the number of occurrences of (E4)\nin the first $K\\log n$ rounds is\nstochastically dominated by a binomial random variable $X$ with parameters $K\\log n$ and $1/(16r(r+2))$.\nThe probability that (E4) occurs more than $(K\\log n)/(8r(r+2))$ times is therefore, \nby \\eqref{bigup}, at most \n", "itemtype": "equation", "pos": 61825, "prevtext": "\nand our choice of $\\alpha$ and $\\beta$, \nbecause we are assuming that $\\mu_t(L_t)< \\alpha$ and $\\mu_t(\\Gamma(v))> \\beta$, so we have \n\n", "index": 57, "text": "\\begin{align*}\n(f_2-f_1^{-1})\\mu_t(L_t)  \n& < (f_2-f_1^{-1})\\alpha \\\\\n& = 1/2(f_2^{-1/r}-f_1^{-1})\\beta\\\\ \n& < 1/2(f_2^{-1/r}-f_1^{-1})\\mu_t(\\Gamma(v)).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(f_{2}-f_{1}^{-1})\\mu_{t}(L_{t})\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>L</mi><mi>t</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;(f_{2}-f_{1}^{-1})\\alpha\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\u03b1</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex41.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=1/2(f_{2}^{-1/r}-f_{1}^{-1})\\beta\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\u03b2</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex42.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;1/2(f_{2}^{-1/r}-f_{1}^{-1})\\mu_{t}(\\Gamma(v)).\" display=\"inline\"><mrow><mrow><mi/><mo>&lt;</mo><mrow><mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>f</mi><mn>2</mn><mrow><mo>-</mo><mrow><mn>1</mn><mo>/</mo><mi>r</mi></mrow></mrow></msubsup><mo>-</mo><msubsup><mi>f</mi><mn>1</mn><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBy our choice of $K_0$, we have $K_0 \\ge 48r(r+2)$, so this probability is $O(n^{-(k+1)})$, \nwhich proves Claim~\\ref{claimE4limit}.\n\n\nFrom Claim~\\ref{claimE1limit} and Claim~\\ref{claimE4limit},\nwe conclude that with failure probability $O(n^{-(k+1)})$, (E1) and (E4) altogether occur at most\n$K(\\log n)/(4r(r+2))$ times in the first $K\\log n$ rounds. \nWe next show that, with small failure probability, $\\mu_t(\\Gamma(v))$ is small most of the time.\n\n\n\\begin{subclaim}\\label{runclaim}\nWith failure probability $O(1/n^{k+1})$,\n$\\mu_t(\\Gamma(v))>f_2\\beta$ at most $(K\\log n)/(2(r+2))$ times \nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nLet $T$ be the set of rounds $t \\geq 1$ at which $\\mu_t(\\Gamma(v)) > f_2\\beta$.\nWe decompose $T$ into (maximal) intervals of integers, say as $T_1\\cup \\dots \\cup T_m$.\nLet $T_i=[s_i,t_i]$ be one of these intervals.\nWe colour each integer $t\\in T_i$ {\\em red} if (E1) or (E4) occurred at the previous round, \nand {\\em blue} if (E3) occurred \n(note that  (E2) cannot occur, as $\\mu_{t-1}(\\Gamma(v))\\ge\\mu_t(\\Gamma(v))/f_2>\\beta$).\nBy the definition of (E3), we have $\\mu_t(\\Gamma(v))\\le f_2^{-1/r}\\mu_{t-1}(\\Gamma(v))$ at blue rounds, \nand we have $\\mu_t(\\Gamma(v))\\le f_2\\mu_{t-1}(\\Gamma(v))$ otherwise.\nLet $r_i$ be the number of red elements in $T_i$ and $b_i$ the number of blue elements.\nIt follows that \n\n", "itemtype": "equation", "pos": 62869, "prevtext": "\nThus the probability that (E4) does occur is bounded above by $1/(16r(r+2))$.  \nThis proves Claim~\\ref{claimE4prob}.\n\n\n\n\\begin{subclaim}\\label{claimE4limit}\nWith failure probability $O(1/n^{k+1})$, (E4) occurs at most $(K\\log n)/(8r(r+2))$ times\nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nAt each round, the probability of (E4) depends on the past history of the process.\nHowever, by Claim~\\ref{claimE4prob}, it is always at most $1/(16r(r+2))$, and so\nwe can couple occurrences of (E4) with a sequence of independent events each occurring with probability\n$1/(16r(r+2))$.  It follows that the number of occurrences of (E4)\nin the first $K\\log n$ rounds is\nstochastically dominated by a binomial random variable $X$ with parameters $K\\log n$ and $1/(16r(r+2))$.\nThe probability that (E4) occurs more than $(K\\log n)/(8r(r+2))$ times is therefore, \nby \\eqref{bigup}, at most \n", "index": 59, "text": "$${\\mathbb P}[X>2{\\mathbb E} X] \\le \\exp(-{\\mathbb E} X/3) \\le \\exp(-(K\\log n)/(48r(r+2))).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[X&gt;2{\\mathbb{E}}X]\\leq\\exp(-{\\mathbb{E}}X/3)\\leq\\exp(-(K\\log n)/(4%&#10;8r(r+2))).\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><mi>X</mi><mo>&gt;</mo><mn>2</mn><mi>\ud835\udd3c</mi><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><mi>\ud835\udd3c</mi><mi>X</mi><mo>/</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2264</mo><mi>exp</mi><mrow><mo stretchy=\"false\">(</mo><mo>-</mo><mrow><mo stretchy=\"false\">(</mo><mi>K</mi><mi>log</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mn>48</mn><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nSince $\\mu_{t_i}(\\Gamma(v))>f_2\\beta$ it follows that\n\n", "itemtype": "equation", "pos": 64307, "prevtext": "\nBy our choice of $K_0$, we have $K_0 \\ge 48r(r+2)$, so this probability is $O(n^{-(k+1)})$, \nwhich proves Claim~\\ref{claimE4limit}.\n\n\nFrom Claim~\\ref{claimE1limit} and Claim~\\ref{claimE4limit},\nwe conclude that with failure probability $O(n^{-(k+1)})$, (E1) and (E4) altogether occur at most\n$K(\\log n)/(4r(r+2))$ times in the first $K\\log n$ rounds. \nWe next show that, with small failure probability, $\\mu_t(\\Gamma(v))$ is small most of the time.\n\n\n\\begin{subclaim}\\label{runclaim}\nWith failure probability $O(1/n^{k+1})$,\n$\\mu_t(\\Gamma(v))>f_2\\beta$ at most $(K\\log n)/(2(r+2))$ times \nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nLet $T$ be the set of rounds $t \\geq 1$ at which $\\mu_t(\\Gamma(v)) > f_2\\beta$.\nWe decompose $T$ into (maximal) intervals of integers, say as $T_1\\cup \\dots \\cup T_m$.\nLet $T_i=[s_i,t_i]$ be one of these intervals.\nWe colour each integer $t\\in T_i$ {\\em red} if (E1) or (E4) occurred at the previous round, \nand {\\em blue} if (E3) occurred \n(note that  (E2) cannot occur, as $\\mu_{t-1}(\\Gamma(v))\\ge\\mu_t(\\Gamma(v))/f_2>\\beta$).\nBy the definition of (E3), we have $\\mu_t(\\Gamma(v))\\le f_2^{-1/r}\\mu_{t-1}(\\Gamma(v))$ at blue rounds, \nand we have $\\mu_t(\\Gamma(v))\\le f_2\\mu_{t-1}(\\Gamma(v))$ otherwise.\nLet $r_i$ be the number of red elements in $T_i$ and $b_i$ the number of blue elements.\nIt follows that \n\n", "index": 61, "text": "$$\\mu_{t_i}(\\Gamma(v))\\le \\mu_{s_i-1}(\\Gamma(v)) \\cdot {f_2}^{r_i-b_i/r}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex44.m1\" class=\"ltx_Math\" alttext=\"\\mu_{t_{i}}(\\Gamma(v))\\leq\\mu_{s_{i}-1}(\\Gamma(v))\\cdot{f_{2}}^{r_{i}-b_{i}/r}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\u03bc</mi><msub><mi>t</mi><mi>i</mi></msub></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mrow><msub><mi>\u03bc</mi><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mmultiscripts><mi>f</mi><mn>2</mn><none/><none/><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>-</mo><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>/</mo><mi>r</mi></mrow></mrow></mmultiscripts></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nHowever, $\\mu_{s_i-1}(\\Gamma(v)) \\leq f_2 \\beta$ in all cases where $s_i > 1$,\nand $\\mu_0(\\Gamma(v)) < n$. \nSumming over $i$, we see that \n\n\n\n\n", "itemtype": "equation", "pos": 64437, "prevtext": "\nSince $\\mu_{t_i}(\\Gamma(v))>f_2\\beta$ it follows that\n\n", "index": 63, "text": "\\begin{equation*}\nr_i>\\frac{1}{r}b_i + \\log_{f_2} f_2\\beta - \\log_{f_2} (\\mu_{s_i-1}(\\Gamma(v))).\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex45.m1\" class=\"ltx_Math\" alttext=\"r_{i}&gt;\\frac{1}{r}b_{i}+\\log_{f_{2}}f_{2}\\beta-\\log_{f_{2}}(\\mu_{s_{i}-1}(%&#10;\\Gamma(v))).\" display=\"block\"><mrow><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>&gt;</mo><mrow><mrow><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>\u2062</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><mo>+</mo><mrow><msub><mi>log</mi><msub><mi>f</mi><mn>2</mn></msub></msub><mo>\u2061</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><mi>\u03b2</mi></mrow></mrow></mrow><mo>-</mo><mrow><msub><mi>log</mi><msub><mi>f</mi><mn>2</mn></msub></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03bc</mi><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBut red rounds correspond to events (E1) and (E4), and we have already shown\nin Claims~\\ref{claimE1limit} and~\\ref{claimE4limit}\n that these occur at most $(K\\log n)/(4r(r+2))$ times altogether in the first $K\\log n$ rounds. \nHence the total number of rounds in $T$, both red and blue, is less than  \n$(K\\log n)/(4r(r+2)) + (K\\log n)/(4(r+2)) + r \\log n/\\log f_2$.\nBy our choice of $K_0$, this is less than $(K\\log n)/(2(r+2))$.\nThis proves Claim~\\ref{runclaim}.\n\n\n\n\\begin{subclaim}\\label{nohearclaim}\nWith failure probability $O(1/n^{k+1})$, $v$ hears a beep at most $(K\\log n)/(r+2)$ times \nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nBy our choice of $\\beta$, we have that \n$f_2\\beta = (1 - e^{-\\lambda})/(4 (r+2) \\lambda) < (1 - e^{-\\lambda})$.\nHence we may apply Inequality~\\eqref{exp2}, to show that when $\\mu_t(\\Gamma(v)) \\le f_2\\beta$ \nthe probability that $v$ hears no beep is \n\n", "itemtype": "equation", "pos": 64693, "prevtext": "\nHowever, $\\mu_{s_i-1}(\\Gamma(v)) \\leq f_2 \\beta$ in all cases where $s_i > 1$,\nand $\\mu_0(\\Gamma(v)) < n$. \nSumming over $i$, we see that \n\n\n\n\n", "index": 65, "text": "$$\n\\sum_{i=1}^{m} r_i > \\frac{1}{r}\\sum_{i=1}^{m} b_i + \\log_{f_2} f_2\\beta - \\log_{f_2} n\n$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex46.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{m}r_{i}&gt;\\frac{1}{r}\\sum_{i=1}^{m}b_{i}+\\log_{f_{2}}f_{2}\\beta-\\log%&#10;_{f_{2}}n\" display=\"block\"><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>r</mi><mi>i</mi></msub></mrow><mo>&gt;</mo><mrow><mrow><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>b</mi><mi>i</mi></msub></mrow></mrow><mo>+</mo><mrow><msub><mi>log</mi><msub><mi>f</mi><mn>2</mn></msub></msub><mo>\u2061</mo><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><mi>\u03b2</mi></mrow></mrow></mrow><mo>-</mo><mrow><msub><mi>log</mi><msub><mi>f</mi><mn>2</mn></msub></msub><mo>\u2061</mo><mi>n</mi></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nand so $v$ hears a beep with probability at most $\\phi f_2\\beta$ which equals $1/(4(r+2))$.\nUsing \n\n\\eqref{bigup}, this implies that with failure probability $O(n^{-(k+1)})$\nthere are at most $(K\\log n)/(2(r+2))$ rounds among the first $K\\log n$ \nat which $\\mu_t(\\Gamma(v)) \\le f_2\\beta$ and $v$ hears a beep. \nBy Claim~\\ref{runclaim}, with the same failure probability,\nthere are also at most $(K\\log n)/(2(r+2))$ rounds at which $\\mu_t(\\Gamma(v)) > f_2\\beta$\n(and $v$ might hear a beep at any of these steps).\nIt follows that, with failure probability $O(n^{-(k+1)})$,\n$v$ hears a beep at most $(K\\log n)/(r+2)$ times\nin the first $K\\log n$ rounds.\nThis proves Claim~\\ref{nohearclaim}.\n\n\n\n\\begin{subclaim}\\label{claimterminate}\nWith failure probability $O(1/n^{k+1})$,\n$v$ becomes inactive during the first $K\\log n$ rounds.\n\\end{subclaim}\n\nFrom the previous claim, we may assume that $v$ hears a beep on at most $K\\log n/(r+2)$\noccasions during the first $K\\log n$ rounds.\nOn these occasions it decreases its local probability value $p$ by a factor of at most $f_2$.\nWe shall refer to these as red steps.\n\nHence there are at least $\\frac{(r+1)}{(r+2)} K \\log n$ rounds during the first $K\\log n$ \nrounds where $v$ does not hear a beep, so it either terminates, \nor increases its local probability value $p$ by a factor of at least $f_1$, \nor else increases $p$ to 1.\nWe shall refer to these as blue rounds.\nNote that if $v$ beeps in a blue round then it will terminate in that round. \nHence a blue round where the value of $p$ increases to 1 must be immediately followed by a red \nround, or a blue round where $v$ terminates.\n\nNow, by our choice of $r$, $f_1^r > f_2$. \nThis means that there must be \nat least $\\frac{1}{(r+2)} K \\log n$ blue rounds during the first $K\\log n$ rounds\nwhere either $v$ has terminated, or else the local probability value $p$ at $v$ is at least \nas high as the initial value, $p_0$.\n\nThe probability that $v$ will terminate at each of these blue rounds is at least $p_0$,\nso the probability that $v$ remains active throughout all these blue rounds is at most\n$(1-p_0)^{K \\log n/(r+2)}$. \nUsing Inequality~\\eqref{exp}, this means that the probability that $v$ remains active throughout these\nrounds is at most \n\n", "itemtype": "equation", "pos": 65677, "prevtext": "\nBut red rounds correspond to events (E1) and (E4), and we have already shown\nin Claims~\\ref{claimE1limit} and~\\ref{claimE4limit}\n that these occur at most $(K\\log n)/(4r(r+2))$ times altogether in the first $K\\log n$ rounds. \nHence the total number of rounds in $T$, both red and blue, is less than  \n$(K\\log n)/(4r(r+2)) + (K\\log n)/(4(r+2)) + r \\log n/\\log f_2$.\nBy our choice of $K_0$, this is less than $(K\\log n)/(2(r+2))$.\nThis proves Claim~\\ref{runclaim}.\n\n\n\n\\begin{subclaim}\\label{nohearclaim}\nWith failure probability $O(1/n^{k+1})$, $v$ hears a beep at most $(K\\log n)/(r+2)$ times \nin the first $K\\log n$ rounds.\n\\end{subclaim}\n\nBy our choice of $\\beta$, we have that \n$f_2\\beta = (1 - e^{-\\lambda})/(4 (r+2) \\lambda) < (1 - e^{-\\lambda})$.\nHence we may apply Inequality~\\eqref{exp2}, to show that when $\\mu_t(\\Gamma(v)) \\le f_2\\beta$ \nthe probability that $v$ hears no beep is \n\n", "index": 67, "text": "\\begin{align*}\n\\prod_{x \\in \\Gamma(v)}(1-\\mu_t(x)) \n& \\ge \\prod_{x \\in \\Gamma(v)}\\exp(-\\phi\\mu_t(x))\\\\\n& \\ge \\exp(-\\phi\\mu_t(\\Gamma(v)))\\\\\n& \\ge \\exp(-\\phi f_2\\beta) \\ge 1-\\phi f_2\\beta,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex47.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\prod_{x\\in\\Gamma(v)}(1-\\mu_{t}(x))\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder></mstyle><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex47.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\prod_{x\\in\\Gamma(v)}\\exp(-\\phi\\mu_{t}(x))\" display=\"inline\"><mrow><mi/><mo>\u2265</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>x</mi><mo>\u2208</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></munder></mstyle><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex48.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\exp(-\\phi\\mu_{t}(\\Gamma(v)))\" display=\"inline\"><mrow><mi/><mo>\u2265</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>\u03bc</mi><mi>t</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex49.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq\\exp(-\\phi f_{2}\\beta)\\geq 1-\\phi f_{2}\\beta,\" display=\"inline\"><mrow><mrow><mi/><mo>\u2265</mo><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><mi>\u03b2</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2265</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><msub><mi>f</mi><mn>2</mn></msub><mo>\u2062</mo><mi>\u03b2</mi></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nBy our choice of $K_0$, we have $K_0 > (r+2)/p_0$, so this is $O(n^{-(k+1)})$.\nHence $v$ terminates with a failure probability that is $O(n^{-(k+1)})$.\n\nThis proves Claim~\\ref{claimterminate}, and completes the proof of Theorem~\\ref{logrounds}.\n\\hfill~\n{}\n\\end{proof}\n\n\\begin{corollary}\\label{logexpected}\nThe expected number of rounds taken by the algorithm in Table~\\ref{alg:MISlocal} \non any graph with $n$ nodes is $O(\\log n)$.\n\\end{corollary}\n\n\\begin{proof}\nLet $T$ be the total number of rounds taken by the algorithm and let\n$T' = \\lceil T/(K_0 \\log n) \\rceil$, where $K_0$ is the constant identified\nin Theorem~\\ref{logrounds}.\n\nBy Theorem~\\ref{logrounds}, we have that, for any $k \\geq 1$,\n\n", "itemtype": "equation", "pos": 68120, "prevtext": "\nand so $v$ hears a beep with probability at most $\\phi f_2\\beta$ which equals $1/(4(r+2))$.\nUsing \n\n\\eqref{bigup}, this implies that with failure probability $O(n^{-(k+1)})$\nthere are at most $(K\\log n)/(2(r+2))$ rounds among the first $K\\log n$ \nat which $\\mu_t(\\Gamma(v)) \\le f_2\\beta$ and $v$ hears a beep. \nBy Claim~\\ref{runclaim}, with the same failure probability,\nthere are also at most $(K\\log n)/(2(r+2))$ rounds at which $\\mu_t(\\Gamma(v)) > f_2\\beta$\n(and $v$ might hear a beep at any of these steps).\nIt follows that, with failure probability $O(n^{-(k+1)})$,\n$v$ hears a beep at most $(K\\log n)/(r+2)$ times\nin the first $K\\log n$ rounds.\nThis proves Claim~\\ref{nohearclaim}.\n\n\n\n\\begin{subclaim}\\label{claimterminate}\nWith failure probability $O(1/n^{k+1})$,\n$v$ becomes inactive during the first $K\\log n$ rounds.\n\\end{subclaim}\n\nFrom the previous claim, we may assume that $v$ hears a beep on at most $K\\log n/(r+2)$\noccasions during the first $K\\log n$ rounds.\nOn these occasions it decreases its local probability value $p$ by a factor of at most $f_2$.\nWe shall refer to these as red steps.\n\nHence there are at least $\\frac{(r+1)}{(r+2)} K \\log n$ rounds during the first $K\\log n$ \nrounds where $v$ does not hear a beep, so it either terminates, \nor increases its local probability value $p$ by a factor of at least $f_1$, \nor else increases $p$ to 1.\nWe shall refer to these as blue rounds.\nNote that if $v$ beeps in a blue round then it will terminate in that round. \nHence a blue round where the value of $p$ increases to 1 must be immediately followed by a red \nround, or a blue round where $v$ terminates.\n\nNow, by our choice of $r$, $f_1^r > f_2$. \nThis means that there must be \nat least $\\frac{1}{(r+2)} K \\log n$ blue rounds during the first $K\\log n$ rounds\nwhere either $v$ has terminated, or else the local probability value $p$ at $v$ is at least \nas high as the initial value, $p_0$.\n\nThe probability that $v$ will terminate at each of these blue rounds is at least $p_0$,\nso the probability that $v$ remains active throughout all these blue rounds is at most\n$(1-p_0)^{K \\log n/(r+2)}$. \nUsing Inequality~\\eqref{exp}, this means that the probability that $v$ remains active throughout these\nrounds is at most \n\n", "index": 69, "text": "$$\\exp(-p_0 K \\log n/(r+2)).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex50.m1\" class=\"ltx_Math\" alttext=\"\\exp(-p_{0}K\\log n/(r+2)).\" display=\"block\"><mrow><mrow><mi>exp</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mrow><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>\u2062</mo><mi>K</mi><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>n</mi></mrow></mrow><mo>/</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.04306.tex", "nexttext": "\nfor some constant $c'$.\n\n\n\nHence ${\\mathbb E}[T'] = \\sum_{k\\ge 1}{\\mathbb P}[T' \\ge k] = O(1)$.\n\\hfill~\n{}\n\\end{proof}\n\n\n\n\n\n\n\n\\subsection{Expected Number of Signals}\n\nIn this section we will show that the expected number of\ntimes that each node signals is bounded by a constant. \nHence the expected bit complexity per node for this algorithm\n{\\em does not increase at all} with the number of nodes.\n\n\n\\begin{theorem}\n\\label{thm:expectedbeeps}\nThe expected total number of signals broadcast by any node executing the algorithm in Table~\\ref{alg:MISlocal} is $O(1)$.\n\\end{theorem}\n\n\\begin{proof}\nLet $v$ be a node executing the algorithm in Table~\\ref{alg:MISlocal},\nand consider the whole sequence of rounds until $v$ becomes inactive.\n\nOnce again we will refer to sending a signal in the first exchange of the algorithm in Table~\\ref{alg:MISlocal}\nas ``beeping\", and receiving such a signal from a neighbour as ``hearing a beep\". \n\nDuring each round, one of the following 3 things happens in the first exchange:\n\\begin{description}\n\\item[Case 1] $v$ hears a beep from its neighbours,\nand so decreases its probability of beeping by a factor of $f$ (from $p_t$ to $\\frac{1}{f}p_t$).\nWe will call these {\\em red} rounds.\n\\item[Case 2] $v$ hears no beep from its neighbours,\nand so increases its probability of beeping by a factor of $f$ (from $p_t$ to $fp_t$).\nWe will call these {\\em blue} rounds.\n\\item[Case 3] $v$ hears no beep from its neighbours,\nand so increases its probability of beeping to $1$.\nWe will call these {\\em dark blue} rounds.\n\\end{description}\n\nIf $v$ beeps in any blue or dark blue round then it joins the MIS and becomes inactive, \nso the total number of beeps at such rounds is at most one, at the final round in the sequence.\nHence we only need to consider the expected number of beeps at red rounds.\n\nConsider first those red rounds (if any) where the value of $p_t$ is \nat its lowest point in the sequence so far.\nThe expected number of times that $v$ beeps during this subsequence of rounds \nis bounded by  \n$p_1+\\frac{p_1}{f_1}+\\frac{p_1}{f_1^2}+\\frac{p_1}{f_1^3}\\cdots \n\n\n\\leq \n\n\\frac{f_1}{f_1-1}p_1\n\\leq \\frac{f_1}{f_1-1}$.\n\nAt all of the remaining red rounds the value of $p_t$ is not at its lowest point so far,\nso it was lower at some previous blue round. \nHence each of these red rounds can be associated with a corresponding earlier blue round: \nthe most recent blue round where the value of $p_t$ was lower.\nWe now define the constant $r = \\lceil \\log f_2/\\log f_1 \\rceil$,\nwhere $f_1$ and $f_2$ denote respectively the lower bound and upper bound of $f$ as given in Table~\\ref{alg:MISlocal}. \nNote that $f_1^r \\geq f_2$. \nSince blue rounds increase the value of $p_t$ by at most a factor of $f_2$,\nand red rounds decrease the value of $p_t$ by at least a factor of $f_1$,\nit follows that each blue round will be associated with at most $r$ red rounds.\n\nHence we have partitioned the remaining red rounds into groups of at most $r$ red rounds, \neach associated with a single (earlier) blue round.\nWe now consider these groups of at most $r+1$ rounds, ordered by the position of the initial blue round.\nFor any such group, if the probability of beeping at the blue round is $p$, \nthen the probability of beeping at any of the associated red rounds is at most $f_2 p$.\nHence the conditional probability of beeping at the initial blue round, given that a beep occurs\nsomewhere in this group of rounds, is at least $1/(1+rf_2)$.\nHence if we consider the subsequence of groups where at least one beep occurs,\nthe expected number of such groups before a beep occurs at a blue round is at most $rf_2$\n(expected number of failures before the first success in a geometric distribution).\nSince each group can contribute at most $r$ beeps,\nthe expected number of beeps added in these groups\nbefore terminating is at most $r (rf_2)$.\n\nWe have shown that the expected number of times that $v$ beeps is at most\n$1 + \\frac{f_1}{f_1-1} +(\\lceil \\log {f_2}/\\log f_1 \\rceil)^2 f_2$, which proves the result.\n{}\n\\end{proof}\n\n\n\\section{Algorithm for Distributed Greedy Colouring}\n\\label{secGC}\n\n\nOur new algorithm for distributed greedy colouring (see Table~\\ref{alg:GClocal}) \nis similar to our new distributed MIS selection algorithm. \nAt each round, each node may choose, with a certain probability $p$, \nto broadcast its first available colour to all its neighbours, \nindicating that it wishes to use that colour. \nIf two neighbouring nodes broadcast the same colour in the same round, \nthen they will both abandon choosing that colour in that round. \nOn the other hand, if a node broadcasts a colour and none of its neighbouring nodes \nbroadcast the same colour in that round, then it is successfully coloured, \nand will notify all its neighbouring nodes that they are forbidden to use that colour. \n\nAs in our MIS selection algorithm, the way that the probability values $p$\nare chosen is inspired by the positive feedback mechanisms that control cellular\nprocesses.\nThe value of $p$ is initialised to some arbitrary value at each node\n(above some strictly positive fixed threshold value, $p_0$). \nThese values are then independently updated at each node in each round \nusing feedback from neighbouring nodes. \nThe value of $p$ is decreased at a node \nwhenever one or more neighbouring nodes broadcast the same colour, \nand is increased whenever no neighbouring node broadcasts the same colour. \nAs in our MIS selection algorithm, we allow each increase or decrease to be by some arbitrary factor $f$,\nwhich may vary at each round, but is always bounded by the global parameters $f_1$ and $f_2$ \n(with $1<f_1\\le f_2$).\n\n\\begin{table*}[t]\n\\caption{The algorithm for distributed greedy colouring at each node\n\\label{alg:GClocal}}{\n\\centering\n\\framebox{\n\\begin{minipage}[c]{0.85\\linewidth}\n\\begin{tabbing}\n{\\bf Global constants:} \\= $p_0$ : lower bound on initial probability value; \\\\\n         \\> $f_1,f_2$ : lower and upper bounds on change factor for probability value.\\[0.1cm]\n{\\bf Local variables:} \\> $p$ : local probability value, initialised to some value in $[p_0,1]$;\\\\\n         \\> $f$ : change factor for probability value, chosen arbitrarily in $[f_1,f_2]$;\\\\\n         \\> {\\sc Trying} : Boolean flag, initialised to {\\sc False};\\\\\n         \\> $S$ : Set of forbidden colours, i.e., those taken by neighbours, initialised to $\\emptyset$.\n\\end{tabbing}\n\\algsetup{\nlinenosize=\\tiny,\nlinenodelimiter=.,\nindent = 3em\n}\n\\begin{algorithmic}[1]\n\\WHILE{active, at each time step}\n\\vspace*{0.2cm}\n\\STATE *FIRST EXCHANGE*\n\n\\STATE Choose the smallest available colour $c$ that is not in $S$;\n\\STATE With probability $p$, \nset {\\sc Trying} $\\leftarrow$ {\\sc True} and {\\bf send} $c$ to all neighbours;\n\\STATE {\\bf Receive} any colour signals sent by neighbours;\n\\STATE Set $f$ to some value in the interval $[f_1,f_2]$;\n\\IF{any neighbour sent colour $c$}\n   \\STATE {\\sc Trying} $\\leftarrow$ {\\sc False} and $p\\leftarrow p/f$ (decrease $p$)  \n\\ELSE\n   \\STATE $p\\leftarrow \\min\\{fp,1\\}$ (increase $p$)\n\\ENDIF\n\n\\vspace*{0.2cm}\n\\STATE *SECOND EXCHANGE*\n\\IF{{\\sc Trying}}\n    \\STATE {\\bf Send} $c$ to all neighbours;\n    \\STATE Assign colour $c$ to this node and terminate (become inactive).\n\\ENDIF\n\\STATE {\\bf Receive} any colour signals sent by neighbours and add all distinct colours received to $S$.\n\\ENDWHILE\n\\vspace*{0.2cm}\n\\end{algorithmic}\n\\end{minipage}\n}\n}\n\\end{table*}\n\nThe correctness of the algorithm in Table~\\ref{alg:GClocal} follows easily from the two facts below:\n\\begin{description}\n\\item[Fact 1] No two nodes that are assigned the same colour in the same round are adjacent. \n\\item[Fact 2] The colour assigned to any node is the smallest colour that is different from \nall colours previously assigned to neighbouring nodes. \n\\end{description}\nThus, if the algorithm in Table~\\ref{alg:GClocal} is run on the nodes of any graph $G$, and all nodes\nbecome inactive, then the colour assigned to each of the nodes defines a greedy colouring of $G$. \n\nOur analysis of the distributed greedy colouring algorithm shown in Table~\\ref{alg:GClocal} \nis very similar to the analysis for the MIS selection algorithm given in Section~\\ref{sec:localtime}.\n\n\\begin{theorem}\\label{GCrounds}\nFor any fixed values of $p_0 > 0$, and $1 < f_1 \\leq f_2$, \nthere is a constant $K_0$ and a constant $r$ such that the following holds:\nFor any graph $G$ with $n$ vertices and maximum degree $\\Delta$, and any $k\\ge1$,\nthe algorithm defined in Table~\\ref{alg:GClocal} terminates in \nat most $8r(r+2)\\Delta + K_0(k+1)\\log n$ rounds,\nwith probability at least $1-O(1/n^k)$.\n\\end{theorem}\n\nAs in Section~\\ref{sec:localtime}, we refer to broadcasting any colour $c$ in the first exchange as\n``beeping\", and receiving {\\em the same} colour $c$ from a neighbour in that exchange as\n``hearing a beep\". \nAs before, for any vertex $v$, at any time step $t$, we define the measure $\\mu_t(v)$, \ncalled the ``weight'' of $v$, to be the probability that $v$ beeps in round $t$. \n\nThe set of neighbours of a vertex $v$ which are competing for the same colour as $v$\nin any round will be called the {\\em homogeneous} neighbours of $v$, \nand will be denoted by $\\Gamma^{(h)}(v)$.\nWe adapt Definition~\\ref{def:lambdalightMIS} to refer to homogeneous neighbours only, as follows.\n\n\\begin{definition}\\label{def:lighth}\nFor any $\\lambda > 0$, \na vertex $v$ will be called {\\em $\\lambda$-light$^{(h)}$} at round $t$  \nif $\\mu_t(\\Gamma^{(h)}(v))\\le\\lambda$ \nand every homogeneous neighbour of $v$ has weight at most $1-\\exp(-\\lambda)$;\notherwise, vertex $v$ is called {\\em $\\lambda$-heavy$^{(h)}$}.\n\\end{definition}\n\nAs in Section~\\ref{sec:localtime}, we first establish a lower bound on the probability \nthat at least one vertex in a set of $\\lambda$-light$^{(h)}$ vertices will be coloured at each round.\n\n\\begin{lemma}\\label{GClight}\nLet $W$ be a set of vertices that are $\\lambda$-light$^{(h)}$ at round $t$. \nThe probability that at least one vertex in $W$ gets coloured in round $t$ is at least\n$e^{-\\phi\\lambda}(1-e^{-\\mu_t(W)})$ where $\\phi = \\lambda/(1-\\exp(-\\lambda))$.\n\\end{lemma}\n\n\\begin{proof}\nIdentical to the proof of Lemma~\\ref{light}.\n\\hfill~\n{}\n\\end{proof}\n\n\\begin{proof}[of Theorem \\ref{GCrounds}]\nFix an arbitrary vertex $v$.\nWe use essentially the same argument as in the proof of Theorem~\\ref{logrounds},\npartitioning the neighbourhood of $v$ into $\\lambda$-light$^{(h)}$ and $\\lambda$-heavy$^{(h)}$\nvertices, and following the progress of these sets over time.\nNote that we consider the entire neighbourhood of $v$, not just the homogeneous neighbours.\nWe show that the weight of this entire neighbourhood is small for at least a fixed fraction of the \ntime, and hence $v$ fails to receive any colour signals for at least a fixed fraction of the time.\n\nWe define the same constants, and the same events $(E1)$ to $(E4)$ \n(see page 14). \nHowever, in this proof we will need to allow for the possibility that one or more neighbours\nof $v$ are successfully coloured at any time step, which can happen up to $\\Delta$ times,\nand does not immediately force $v$ to become inactive.\n\n\n\nEach time that (E1) occurs, it follows from Lemma \\ref{GClight} that \nwith probability at least $e^{-\\phi\\lambda}(1-e^{-\\alpha})$\nsome $\\lambda$-light$^{(h)}$ neighbour of $v$ will be coloured.\nLet $\\phi_1= e^{-\\phi\\lambda}(1-e^{-\\alpha})$.\nAs in the proof of Claim~\\ref{claimE1limit},\nthe probability that there are $(K\\log n)/(8r(r+2))$ occurrences of $(E1)$\nwhere no neighbour of $v$ is coloured is at most\n$(1-\\phi_1)^{(K\\log n)/(8r(r+2))}\\le \\exp(-(\\phi_1K_0/(8r(r+2)))(k+1)\\log n)$.\nBy our choice of $K_0$, we have $K_0 \\geq (8r(r+2))/\\phi_1$,\nso this probability is at most $\\exp(-(k+1)\\log n)=n^{-(k+1)}$.  \n\nHence with failure probability $O(1/n^{k+1})$, the {\\em total} number of \noccurrences of $(E1)$ \nis at most $\\Delta + (K\\log n)/(8r(r+2))$.\n\nSince we have a weaker upper bound on the number of occurrences of $(E1)$,\nwe will need to consider a longer sequence of rounds overall.\nIn fact, we will consider the first $8r(r+2)\\Delta + K\\log n$ rounds.\n\nFollowing exactly the same arguments as in the proof of \nClaims~\\ref{claimE4prob} and \\ref{claimE4limit},\nwe obtain that with failure probability $O(1/n^{k+1})$, \n(E4) occurs at most $\\Delta + (K\\log n)/(8r(r+2))$ times \nin the first $8r(r+2)\\Delta + K\\log n$ rounds.\n\nNext, following the argument used to prove Claim~\\ref{runclaim},\nbut using the weaker bound of $2\\Delta + (K\\log n)/(4r(r+2))$ for the total number of red rounds,\nwe obtain that with failure probability $O(1/n^{k+1})$,\n$\\mu_t(\\Gamma(v))>f_2\\beta$ at most $4r\\Delta + (K\\log n)/(2(r+2))$ times \nin the first $8r(r+2)\\Delta + K\\log n$ rounds.\n\nNow, using the same argument as in Claim~\\ref{nohearclaim} we can show that\nwith failure probability $O(1/n^{k+1})$, the fraction of rounds where \n$v$ hears a beep (or in fact receives any colour signal in the first exchange) \nduring the first $8r(r+2)\\Delta + K\\log n$ rounds is at most $1/(r+2)$.\n\nFinally, using the same argument as in Claim~\\ref{claimterminate}, this implies that\nwith failure probability $O(1/n^{k+1})$,\n$v$ becomes inactive during the first $8r(r+2)\\Delta + K\\log n$ rounds.\n\nTaking a union bound over all possible choices of $v$, as before, gives the result.\n\\hfill~\n{}\n\\end{proof}\n\n\\begin{corollary}\\label{GClogexpected}\nThe expected number of rounds taken by the algorithm in Table~\\ref{alg:GClocal} \non any graph with $n$ nodes is $O(\\Delta+\\log n)$.\n\\end{corollary}\n\nFinally, the proof of Theorem~\\ref{thm:expectedbeeps} considers only an individual node\nand does not take into account whether \nthe neighbours of a node become inactive or not, so this proof \napplies equally well to our distributed colouring algorithm, giving the following result.\n\n\\begin{theorem}\n\\label{thm:GCexpectedbeeps}\nThe expected total number of beeps broadcast by any node executing the algorithm in Table~\\ref{alg:GClocal} is $O(1)$.\n\\end{theorem}\n\n\n\\begin{thebibliography}{10}\n\\providecommand{\\url}[1]{{#1}}\n\\providecommand{\\urlprefix}{URL }\n\\expandafter\\ifx\\csname urlstyle\\endcsname\\relax\n  \\providecommand{\\doi}[1]{DOI~\\discretionary{}{}{}#1}\\else\n  \\providecommand{\\doi}{DOI~\\discretionary{}{}{}\\begingroup\n  \\urlstyle{rm}\\Url}\\fi\n\n\\bibitem{Afek2011b}\nAfek, Y., Alon, N., Bar-Joseph, Z., Cornejo, A., Haeupler, B., Kuhn, F.:\n  Beeping a maximal independent set.\n\\newblock In: Proceedings of the 25th International Conference on Distributed\n  Computing, DISC'11, pp. 32--50. Springer-Verlag (2011)\n\n\\bibitem{Afek2011a}\nAfek, Y., Alon, N., Barad, O., Hornstein, E., Barkai, N., Bar-Joseph, Z.: A\n  biological solution to a fundamental distributed computing problem.\n\\newblock Science \\textbf{331}(6014), 183--185 (2011)\n\n\\bibitem{Alon1986a}\nAlon, N., Babai, L., Itai, A.: A fast and simple randomized parallel algorithm\n  for the maximal independent set problem.\n\\newblock Journal of Algorithms \\textbf{7}, 567--583 (1986)\n\n\\bibitem{Barenboim2009d}\nBarenboim, L., Elkin, M.: Distributed ($\\delta+1$)-coloring in linear (in\n  $\\delta$) time.\n\\newblock In: Proceedings of the 41st Annual ACM Symposium on Theory of\n  Computing, STOC '09, pp. 111--120. ACM, New York, NY, USA (2009)\n\n\\bibitem{Barenboim2010s}\nBarenboim, L., Elkin, M.: {Sublogarithmic distributed MIS algorithm for sparse\n  graphs using Nash-Williams decomposition}.\n\\newblock Distributed Computing \\textbf{22}(5-6), 363--379 (2010)\n\n\\bibitem{Barenboim2011d}\nBarenboim, L., Elkin, M.: Deterministic distributed vertex coloring in\n  polylogarithmic time.\n\\newblock Journal of the ACM \\textbf{58}(5), 23:1--23:25 (2011)\n\n\\bibitem{Barenboim2012t}\nBarenboim, L., Elkin, M., Pettie, S., Schneider, J.: The locality of\n  distributed symmetry breaking.\n\\newblock In: Proceedings of the 2012 IEEE 53rd Annual Symposium on Foundations\n  of Computer Science, FOCS '12, pp. 321--330. IEEE Computer Society,\n  Washington, DC, USA (2012)\n\n\\bibitem{Bray2006n}\nBray, S.J.: Notch signalling: a simple pathway becomes complex.\n\\newblock Nature reviews Molecular cell biology \\textbf{7}(9), 678--689 (2006)\n\n\\bibitem{Chaudhuri1987a}\nChaudhuri, P.: Algorithms for some graph problems on a distributed\n  computational model.\n\\newblock Information Sciences \\textbf{43}(3), 205--228 (1987)\n\n\\bibitem{Collier1996p}\nCollier, J.R., Monk, N.A., Maini, P.K., Lewis, J.H.: Pattern formation by\n  lateral inhibition with feedback: a mathematical model of delta-notch\n  intercellular signalling.\n\\newblock Journal of Theoretical Biology \\textbf{183}(4), 429--446 (1996)\n\n\\bibitem{Cornejo2010d}\nCornejo, A., Kuhn, F.: Deploying wireless networks with beeps.\n\\newblock In: Proceedings of the 24th International Conference on Distributed\n  Computing, DISC'10, pp. 148--162. Springer-Verlag, Berlin, Heidelberg (2010)\n\n\\bibitem{Emek2013s}\nEmek, Y., Wattenhofer, R.: Stone age distributed computing.\n\\newblock In: Proceedings of the 2013 ACM Symposium on Principles of\n  Distributed Computing, PODC '13, pp. 137--146. ACM, New York, NY, USA (2013)\n\n\\bibitem{Gavoille2009o}\nGavoille, C., Klasing, R., Kosowski, A., Kuszner, {\\L}., Navarra, A.: On the\n  complexity of distributed graph coloring with local minimality constraints.\n\\newblock Networks \\textbf{54}(1), 12--19 (2009)\n\n\\bibitem{Gebremedhin2003g}\nGebremedhin, A.H., Lassous, I.G., Gustedt, J., Telle, J.A.: Graph coloring on\n  coarse grained multicomputers.\n\\newblock Discrete Applied Mathematics \\textbf{131}(1), 179--198 (2003)\n\n\\bibitem{Goldberg1988p}\nGoldberg, A.V., Plotkin, S.A., Shannon, G.E.: Parallel symmetry-breaking in\n  sparse graphs.\n\\newblock SIAM Journal on Discrete Mathematics \\textbf{1}(4), 434--446 (1988)\n\n\\bibitem{Greenlaw1995l}\nGreenlaw, R., Hoover, H.J., Ruzzo, W.L. (eds.): Limits to Parallel Computation:\n  {P}-completeness Theory.\n\\newblock Oxford University Press, Inc., New York, NY, USA (1995)\n\n\\bibitem{Grundy1939m}\nGrundy, P.: Mathematics and games.\n\\newblock Eureka \\textbf{2}, 6--8 (1939)\n\n\\bibitem{Halpern1990k}\nHalpern, J.Y., Moses, Y.: Knowledge and common knowledge in a distributed\n  environment.\n\\newblock Journal of the ACM \\textbf{37}(3), 549--587 (1990)\n\n\\bibitem{Hansen2004d}\nHansen, J., Kubale, M., Kuszner, {\\L}., Nadolski, A.: Distributed largest-first\n  algorithm for graph coloring.\n\\newblock In: M.~Danelutto, M.~Vanneschi, D.~Laforenza (eds.) Euro-Par 2004\n  Parallel Processing, \\emph{Lecture Notes in Computer Science}, vol. 3149, pp.\n  804--811. Springer Berlin Heidelberg (2004)\n\n\\bibitem{Hedetniemi2003l}\nHedetniemi, S.T., Jacobs, D.P., Srimani, P.K.: Linear time self-stabilizing\n  colorings.\n\\newblock Information Processing Letters \\textbf{87}(5), 251--255 (2003)\n\n\\bibitem{Itai1990s}\nItai, A., Rodeh, M.: Symmetry breaking in distributed networks.\n\\newblock Information and Computation \\textbf{88}(1), 60--87 (1990)\n\n\\bibitem{Johansson1999s}\nJohansson, O.: Simple distributed {$\\Delta+1$}-coloring of graphs.\n\\newblock Information Processing Letters \\textbf{70}(5), 229 -- 232 (1999)\n\n\\bibitem{Karp1972r}\nKarp, R.M.: Reducibility among combinatorial problems.\n\\newblock In: R.E. Miller, J.W. Thatcher (eds.) Complexity of Computer\n  Computations, The IBM Research Symposia Series, pp. 85--103. Plenum Press,\n  New York (1972)\n\n\\bibitem{Karp1985a}\nKarp, R.M., Wigderson, A.: A fast parallel algorithm for the maximal\n  independent set problem.\n\\newblock Journal of the ACM \\textbf{32}(4), 762--773 (1985)\n\n\\bibitem{Kroeker2011b}\nKroeker, K.L.: Biology-inspired networking.\n\\newblock Communications of the ACM \\textbf{54}, 11--13 (2011)\n\n\\bibitem{Kuhn2009w}\nKuhn, F.: Weak graph colorings: distributed algorithms and applications.\n\\newblock In: Proceedings of the 21st Annual Symposium on Parallelism in\n  Algorithms and Architectures, SPAA '09, pp. 138--144. ACM, New York, NY, USA\n  (2009)\n\n\\bibitem{Kuhn2005f}\n{Kuhn}, F., {Moscibroda}, T., {Nieberg}, T., {Wattenhofer}, R.: Fast\n  deterministic distributed maximal independent set computation on\n  growth-bounded graphs.\n\\newblock In: P.~{Fraigniaud} (ed.) Distributed Computing: 19th International\n  Conference, DISC 2005, \\emph{Lecture Notes in Computer Science}, vol. 3724,\n  pp. 273--283. Springer (2005)\n\n\\bibitem{Kuhn2004w}\nKuhn, F., Moscibroda, T., Wattenhofer, R.: What cannot be computed locally!\n\\newblock In: Proceedings of the 23rd Annual ACM Symposium on Principles of\n  Distributed Computing, PODC '04, pp. 300--309. ACM, New York, NY, USA (2004)\n\n\\bibitem{Kuhn2006t}\nKuhn, F., Moscibroda, T., Wattenhofer, R.: The price of being near-sighted.\n\\newblock In: Proceedings of the Seventeenth Annual ACM-SIAM Symposium on\n  Discrete Algorithm, SODA '06, pp. 980--989. New York, NY, USA (2006)\n\n\\bibitem{Kuhn2010}\nKuhn, F., Moscibroda, T., Wattenhofer, R.: Local computation: Lower and upper\n  bounds.\n\\newblock CoRR \\textbf{abs/1011.5470} (2010).\n\\newblock \\urlprefix\\url{http://arxiv.org/abs/1011.5470}\n\n\\bibitem{Kuhn2006o}\nKuhn, F., Wattenhofer, R.: On the complexity of distributed graph coloring.\n\\newblock In: Proceedings of the 25th Annual {ACM} Symposium on Principles of\n  Distributed Computing, PODC '06, pp. 7--15. New York, NY, USA (2006)\n\n\\bibitem{Lenzen2012d}\nLenzen, C., Wattenhofer, R.: Distributed algorithms for sensor networks.\n\\newblock Philosophical Transactions of the Royal Society A: Mathematical,\n  Physical and Engineering Sciences \\textbf{370}(1958), 11--26 (2012)\n\n\\bibitem{Linial1986l}\nLinial, N.: Legal coloring of graphs.\n\\newblock Combinatorica \\textbf{6}(1), 49--54 (1986)\n\n\\bibitem{Linial1987d}\nLinial, N.: Distributive graph algorithms -- global solutions from local data.\n\\newblock In: Proceedings of the 28th Annual Symposium on Foundations of\n  Computer Science, SFCS '87, pp. 331--335. IEEE Computer Society, Washington,\n  DC, USA (1987)\n\n\\bibitem{Linial1992l}\nLinial, N.: Locality in distributed graph algorithms.\n\\newblock SIAM Journal on Computing \\textbf{21}(1), 193--201 (1992)\n\n\\bibitem{Luby1986a}\nLuby, M.: A simple parallel algorithm for the maximal independent set problem.\n\\newblock SIAM Journal on Computing \\textbf{15}(4), 1036--1053 (1986)\n\n\\bibitem{Lynch1996d}\nLynch, N.A.: Distributed Algorithms.\n\\newblock Morgan Kaufmann Publishers Inc., San Francisco, CA, USA (1996)\n\n\\bibitem{Maan2012a}\nMaan, V., Purohit, G.N.: A distributed approach for frequency allocation using\n  graph coloring in mobile networks.\n\\newblock International Journal of Computer Applications \\textbf{58}(6), 9--13\n  (2012).\n\\newblock Published by Foundation of Computer Science, New York, USA\n\n\\bibitem{Metivier2010a}\nM{\\'e}tivier, Y., Robson, J.M., Saheb-Djahromi, N., Zemmari, A.: About\n  randomised distributed graph colouring and graph partition algorithms.\n\\newblock Information and Computation \\textbf{208}(11), 1296--1304 (2010)\n\n\\bibitem{Metivier2011a}\nM{\\'e}tivier, Y., Robson, J.M., Saheb-Djahromi, N., Zemmari, A.: An optimal bit\n  complexity randomized distributed {MIS} algorithm.\n\\newblock Distributed Computing \\textbf{23}(5-6), 331--340 (2011)\n\n\\bibitem{Moscibroda2005m}\nMoscibroda, T., Wattenhofer, R.: Maximal independent sets in radio networks.\n\\newblock In: Proceedings of the 24th Annual ACM Symposium on Principles of\n  Distributed Computing, PODC '05, pp. 148--157. ACM, New York, NY, USA (2005)\n\n\\bibitem{Ni2011c}\nNi, J., Srikant, R., Wu, X.: Coloring spatial point processes with applications\n  to peer discovery in large wireless networks.\n\\newblock IEEE/ACM Transactions on Networking \\textbf{19}(2), 575 --588 (2011)\n\n\\bibitem{Panconesi2001s}\nPanconesi, A., Rizzi, R.: Some simple distributed algorithms for sparse\n  networks.\n\\newblock Distributed Computing \\textbf{14}(2), 97--100 (2001)\n\n\\bibitem{Panconesi1996o}\nPanconesi, A., Srinivasan, A.: On the complexity of distributed network\n  decomposition.\n\\newblock Journal of Algorithms \\textbf{20}(2), 356--374 (1996)\n\n\\bibitem{Park1996a}\nPark, T., Lee, C.Y.: Application of the graph coloring algorithm to the\n  frequency assignment problem.\n\\newblock Journal of the Operations Research Society of Japan-Keiei Kagaku\n  \\textbf{39}(2), 258--265 (1996)\n\n\\bibitem{Peleg2000d}\nPeleg, D.: Distributed computing: a locality-sensitive approach.\n\\newblock Society for Industrial and Applied Mathematics, Philadelphia, PA, USA\n  (2000)\n\n\\bibitem{Prakash1997a}\nPrakash, R., Raynal, M., Singhal, M.: An adaptive causal ordering algorithm\n  suited to mobile computing environments.\n\\newblock Journal of Parallel and Distributed Computing \\textbf{41}(2),\n  190--204 (1997)\n\n\\bibitem{Schneider2008a}\nSchneider, J., Wattenhofer, R.: A log-star distributed maximal independent set\n  algorithm for growth-bounded graphs.\n\\newblock In: Proceedings of the 27th ACM Symposium on Principles of\n  Distributed Computing, PODC '08, pp. 35--44. ACM, New York, NY, USA (2008)\n\n\\bibitem{Schneider2010a}\nSchneider, J., Wattenhofer, R.: A new technique for distributed symmetry\n  breaking.\n\\newblock In: Proceedings of the 29th ACM SIGACT-SIGOPS Symposium on Principles\n  of Distributed Computing, PODC '10, pp. 257--266. ACM, New York, NY, USA\n  (2010)\n\n\\bibitem{Scott2013f}\nScott, A., Jeavons, P., Xu, L.: Feedback from nature: an optimal distributed\n  algorithm for maximal independent set selection.\n\\newblock In: Proceedings of the 2013 ACM Symposium on Principles of\n  Distributed Computing, PODC '13, pp. 147--156. ACM, New York, NY, USA (2013)\n\n\\bibitem{Waters2005g}\nWaters, R.J.: Graph colouring and frequency assignment.\n\\newblock Ph.D. thesis (2005)\n\n\\bibitem{Wattenhofer2007l}\nWattenhofer, R.: \\url{http://dcg.ethz.ch/lectures/fs08/distcomp/lecture/\n  chapter4.pdf} (2007)\n\n\\bibitem{Xu2013s}\nXu, L., Jeavons, P.: Simple neural-like {P} systems for maximal independent set\n  selection.\n\\newblock Neural Computation \\textbf{25}(6), 1642--1659 (2013)\n\n\\bibitem{Zuckerman2006l}\nZuckerman, D.: Linear degree extractors and the inapproximability of max clique\n  and chromatic number.\n\\newblock In: Proceedings of the 38th Annual ACM Symposium on Theory of\n  Computing, STOC '06, pp. 681--690. ACM, New York, NY, USA (2006)\n\n\\end{thebibliography}\n\n\n", "itemtype": "equation", "pos": 68850, "prevtext": "\nBy our choice of $K_0$, we have $K_0 > (r+2)/p_0$, so this is $O(n^{-(k+1)})$.\nHence $v$ terminates with a failure probability that is $O(n^{-(k+1)})$.\n\nThis proves Claim~\\ref{claimterminate}, and completes the proof of Theorem~\\ref{logrounds}.\n\\hfill~\n{}\n\\end{proof}\n\n\\begin{corollary}\\label{logexpected}\nThe expected number of rounds taken by the algorithm in Table~\\ref{alg:MISlocal} \non any graph with $n$ nodes is $O(\\log n)$.\n\\end{corollary}\n\n\\begin{proof}\nLet $T$ be the total number of rounds taken by the algorithm and let\n$T' = \\lceil T/(K_0 \\log n) \\rceil$, where $K_0$ is the constant identified\nin Theorem~\\ref{logrounds}.\n\nBy Theorem~\\ref{logrounds}, we have that, for any $k \\geq 1$,\n\n", "index": 71, "text": "$${\\mathbb P}[T' > k+1] \\leq c'/n^{k}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex51.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}[T^{\\prime}&gt;k+1]\\leq c^{\\prime}/n^{k}\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo stretchy=\"false\">[</mo><msup><mi>T</mi><mo>\u2032</mo></msup><mo>&gt;</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><msup><mi>c</mi><mo>\u2032</mo></msup><mo>/</mo><msup><mi>n</mi><mi>k</mi></msup></mrow></math>", "type": "latex"}]