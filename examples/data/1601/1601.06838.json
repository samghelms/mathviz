[{"file": "1601.06838.tex", "nexttext": "\nand\n\n", "itemtype": "equation", "pos": 10723, "prevtext": "\n\n\\maketitle\n\n\\thispagestyle{plain}\n\\pagestyle{plain}\n\n\\begin{abstract}\nIn any caching system, the admission and eviction policies determine which contents are added and removed from a cache when a miss occurs. Usually, these policies are devised so as to mitigate staleness and increase the hit probability. Nonetheless, the utility of having a high hit probability can vary across contents. This occurs, for instance, when service level agreements must be met, or if certain contents are more difficult to obtain than others.\nIn this paper, we propose utility-driven caching, where we associate with each content a utility, which is a function of the corresponding content hit probability.\nWe formulate optimization problems where the objectives are to maximize the sum of utilities over all contents. These problems differ according to the stringency of the cache capacity constraint.\nOur framework enables us to reverse engineer classical replacement policies such as LRU and FIFO, by computing the utility functions that they maximize.\nWe also develop online algorithms that can be used by service providers to implement various caching policies based on arbitrary utility functions.\n\n\n\\end{abstract}\n\\section{Introduction}\nThe increase in data traffic over past years is predicted to continue more aggressively, with global Internet traffic in 2019 estimated to reach 64 times of its volume in 2005~\\cite{cisco14}.\nThe growth in data traffic is recognized to be due primarily to streaming of video on-demand content over cellular networks.\nHowever, traditional methods such as increasing the amount of spectrum or deploying more base stations are not sufficient to cope with this predicted traffic increase~\\cite{Andrews12, Golrezaei12}. Caching is recognized, in current and future Internet architecture proposals, as one of the most effective means to improve the performance of web applications.\nBy bringing the content closer to users, caches greatly reduce network bandwidth usage, server load, and perceived service delays~\\cite{borst10}.\n\n\n\n\nBecause of the trend for ubiquitous computing, creation of new content publishers and consumers, the Internet is becoming an increasingly heterogeneous environment where different content types have different quality of service requirements, depending on the content publisher/consumer.\nSuch an increasing diversity in service expectations advocates the need for content delivery infrastructures with service differentiation among different applications and content classes.\nService differentiation not only induces important technical gains, but also provides significant economic benefits~\\cite{feldman02}.\nDespite a plethora of research on the design and implementation of \\emph{fair} and \\emph{efficient} algorithms for differentiated bandwidth sharing in communication networks, little work has focused on the provision of multiple levels of service in network and web caches.\nThe little available research has focused on designing controllers for partitioning cache space~\\cite{ko03, lu04}, biased replacement policies towards particular content classes~\\cite{kelly99}, or using multiple levels of caches~\\cite{feldman02}. These techniques either require additional controllers for fairness, or inefficiently use the cache storage.\n\nMoreover, traditional cache management policies such as LRU treat different contents in a strongly coupled manner that makes it difficult for (cache) service providers to implement differentiated services, and for content publishers to account for the valuation of their content delivered through content distribution networks.\nIn this paper, we propose a utility-driven caching framework, where each content has an associated utility and content is stored and managed in a cache so as to maximize the aggregate utility for all content. Utilities can be chosen to trade off user satisfaction and cost of storing the content in the cache.\nWe draw on analytical results for time-to-live (TTL) caches~\\cite{Nicaise14b}, to design caches with ties to utilities for individual (or classes of) contents.\nUtility functions also have implicit notions of fairness that dictate the time each content stays in cache.\n\nOur framework allows us to develop \\emph{online} algorithms for cache management, for which we prove achieve optimal performance. Our framework has implications for distributed pricing and control mechanisms and hence is well-suited for designing cache market economic models.\n\nOur main contributions in this paper can be summarized as follows:\n\\begin{itemize}\n\\item We formulate a utility-based optimization framework for maximizing aggregate content publisher utility subject to buffer capacity constraints at the service provider.\nWe show that existing caching policies, {\\emph{e.g.}}\\ LRU, LFU and FIFO, can be modeled as utility-driven caches within this framework.\n\\item By reverse engineering the LRU and FIFO caching policies as utility maximization problems, we show how the \\emph{characteristic time}~\\cite{Che01} defined for these caches relates to the Lagrange multiplier corresponding to the cache capacity constraint.\n\\item We develop online algorithms for managing cache content, and prove the convergence of these algorithms to the optimal solution using Lyapunov functions.\n\\item We show that our framework can be used in revenue based models where content publishers react to prices set by (cache) service providers without revealing their utility functions.\n\\item We perform simulations to show the efficiency of our online algorithms using different utility functions with different notions of fairness.\n\\end{itemize}\n\nThe remainder of the paper is organized as follows. We review related work in the next section. Section~\\ref{sec:model} explains the network model considered in this paper, and\nSection~\\ref{sec:opt} describes our approach in designing utility maximizing caches. In Section~\\ref{sec:fairness} we elaborate on fairness implications of utility functions, and in Section~\\ref{sec:reverse}, we derive the utility functions maximized by LRU and FIFO caches. In Section~\\ref{sec:online}, we develop online algorithms for implementing utility maximizing caches. We present simulation results in Section~\\ref{sec:simulation}, and discuss prospects and implications of the cache utility maximization framework in Section~\\ref{sec:discussion}. Finally, we conclude the paper in Section~\\ref{sec:conclusion}.\n\n\\section{Related Work}\n\\subsection{Network Utility Maximization}\n\n\nUtility functions have been widely used in the modeling and control of computer networks, from stability analysis of queues to the study of fairness in network resource allocation; see~\\cite{srikant13, neely10} and references therein. Kelly~\\cite{kelly97} was the first to formulate the problem of rate allocation as one of achieving maximum\naggregate utility for users, and describe how network-wide optimal rate allocation can be achieved by having individual users control their transmission rates.\nThe work of Kelly~{\\emph{et al.}}~\\cite{kelly98} presents the first mathematical model and analysis of the behavior of congestion control algorithms for general topology networks.\nSince then, there has been extensive research in generalizing and applying Kelly's \\emph{Network Utility Maximization} framework to model and analyze various network protocols and architectures. This framework has been used to study problems such as network routing~\\cite{tassiulas92}, throughput maximization~\\cite{eryilmaz07}, dynamic power allocation~\\cite{neely03} and scheduling in energy harvesting networks~\\cite{huang13}, among many others. Ma and Towsley~\\cite{Ma15} have recently proposed using utility functions for the purpose of designing contracts that allow service providers to monetize caching.\n\n\n\n\\subsection{Time-To-Live Caches}\nTTL caches, in which content eviction occurs upon the expiration of a timer, have been employed\nsince the early days of the Internet with the Domain Name System (DNS) being an important application~\\cite{Jung03}. More recently, TTL caches have regained popularity, mostly due to admitting a general approach in the analysis of caches that can also be used to model replacement-based caching policies such as LRU. The connection between\nTTL caches and replacement-based (capacity-driven) policies was first established for the LRU policy by Che~{\\emph{et al.}}~\\cite{Che01} through the notion of cache \\emph{characteristic time}. The characteristic time was theoretically justified and extended to other caching policies such as FIFO and RANDOM~\\cite{Fricker12}. \nThis connection was further confirmed to hold for more general arrival models than Poisson processes~\\cite{Bianchi13}. Over the past few years, several exact and approximate analyses have been proposed for modeling single caches in isolation as well as cache networks using the TTL framework~\\mbox{\\cite{Nicaise14, Berger14}}.\n\nIn this paper, we use TTL timers as \\emph{tuning knobs} for individual (or classes of) files to control the utilities observed by the corresponding contents,\nand to implement \\emph{fair} usage of cache space among different (classes of) contents.\nWe develop our framework based on two types of TTL caches described in the next section.\n\n\n\n\n\n\n\n\\section{Model}\n\\label{sec:model}\nConsider a set of $N$ files, and a cache of size $B$. We use the terms file and content interchangeably in this paper.\nLet $h_i$ denote the hit probability for content $i$.\nAssociated with each content, $i=1,\\ldots, N$, is a utility function $U_i:[0,1] \\rightarrow {\\mathbb{R}}$ that represents the ``satisfaction'' perceived by observing hit probability $h_i$.\n$U_i(\\cdot)$ is assumed to be increasing, continuously differentiable, and strictly concave.\nNote that a function with these properties is invertible. We will treat utility functions that do not satisfy these constraints as special cases.\n\n\\subsection{TTL Caches}\nIn a TTL cache, each content is associated with a timer~$t_i$.  Whenever a cache miss to content $i$ occurs, content $i$ is stored in the cache and its timer is set to $t_i$.\nTimers decrease at constant rate, and a content is evicted from cache when its timer reaches zero.\nWe can adjust the hit probability of a file by controlling the time a file is kept in cache.\n\nThere are two TTL cache designs:\n\\begin{itemize}\n\\item Non-reset TTL Cache: TTL is only set at cache misses, {\\emph{i.e.}}~TTL is not reset upon cache hits.\n\\item Reset TTL Cache: TTL is set each time the content is requested.\n\\end{itemize}\nPrevious work on the analysis of TTL caches~\\cite{Nicaise14} has shown that the hit probability of file $i$ for these two classes of non-reset and reset TTL caches can be expressed as \n\n", "index": 1, "text": "\\begin{equation}\n\\label{eq:hit_non_reset}\nh_i = 1 - \\frac{1}{1 + \\lambda_i t_i},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"h_{i}=1-\\frac{1}{1+\\lambda_{i}t_{i}},\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mrow></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nrespectively, where requests for file $i$ arrive at the cache according to a Poisson process with rate $\\lambda_i$.\nNote that depending on the utility functions, different (classes of) files might have different or equal TTL values.\n\n\n\\section{Cache Utility Maximization}\n\\label{sec:opt}\nIn this section, we formulate cache management as a utility maximization problem.  We introduce two formulations, one where the buffer size introduces a hard constraint and a second where it introduces a soft constraint.\n\n\\subsection{Hard Constraint Formulation}\nWe are interested in designing a cache management policy that optimizes the sum of utilities over all files, more precisely,\n\n", "itemtype": "equation", "pos": 10823, "prevtext": "\nand\n\n", "index": 3, "text": "\\begin{equation}\n\\label{eq:hit_reset}\nh_i = 1 - e^{-\\lambda_i t_i},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"h_{i}=1-e^{-\\lambda_{i}t_{i}},\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nNote that the feasible solution set is convex and since the objective function is strictly concave and continuous, a unique maximizer, called the optimal solution, exists.  Also note that the buffer constraint is based on the {\\em expected} number of files not exceeding the buffer size and not the total number of files.\nTowards the end of this section, we show that the buffer space can be managed in a way such that the probability of \\emph{violating} the buffer size constraint vanishes as the number of files and cache size grow large.\n\nThis formulation does not enforce any special technique for managing the cache content, and any strategy that can easily adjust the hit probabilities can be employed. We use the TTL cache as our building block because it provides the means through setting timers to control the hit probabilities of different files in order to maximize the sum of utilities.\n\nUsing timer based caching techniques for controlling the hit probabilities with $0 < t_i < \\infty$ ensures that $0 < h_i < 1$, and hence, disregarding the possibility of $h_i = 0$ or $h_i = 1$, we can write the Lagrangian function as\n\n", "itemtype": "equation", "pos": 11582, "prevtext": "\nrespectively, where requests for file $i$ arrive at the cache according to a Poisson process with rate $\\lambda_i$.\nNote that depending on the utility functions, different (classes of) files might have different or equal TTL values.\n\n\n\\section{Cache Utility Maximization}\n\\label{sec:opt}\nIn this section, we formulate cache management as a utility maximization problem.  We introduce two formulations, one where the buffer size introduces a hard constraint and a second where it introduces a soft constraint.\n\n\\subsection{Hard Constraint Formulation}\nWe are interested in designing a cache management policy that optimizes the sum of utilities over all files, more precisely,\n\n", "index": 5, "text": "\\begin{align}\n\\label{eq:opt}\n\\text{maximize} \\quad &\\sum_{i=1}^{N}{U_i(h_i)} \\notag\\\\\n\\text{such that} \\quad &\\sum_{i=1}^{N}{h_i} = B \\\\\n& 0 \\le h_i \\le 1, \\quad i=1, 2, \\ldots, N. \\notag\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{N}{U_{i}(h_{i})}\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{N}{h_{i}}=B\" display=\"inline\"><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>=</mo><mi>B</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 0\\leq h_{i}\\leq 1,\\quad i=1,2,\\ldots,N.\" display=\"inline\"><mrow><mrow><mrow><mn>0</mn><mo>\u2264</mo><msub><mi>h</mi><mi>i</mi></msub><mo>\u2264</mo><mn>1</mn></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>N</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $\\alpha$ is the Lagrange multiplier. \n\nIn order to achieve the maximum in ${\\mathcal{L}}(\\mathbf{h}, \\alpha)$, the hit probabilities should satisfy\n\n", "itemtype": "equation", "pos": 12917, "prevtext": "\nNote that the feasible solution set is convex and since the objective function is strictly concave and continuous, a unique maximizer, called the optimal solution, exists.  Also note that the buffer constraint is based on the {\\em expected} number of files not exceeding the buffer size and not the total number of files.\nTowards the end of this section, we show that the buffer space can be managed in a way such that the probability of \\emph{violating} the buffer size constraint vanishes as the number of files and cache size grow large.\n\nThis formulation does not enforce any special technique for managing the cache content, and any strategy that can easily adjust the hit probabilities can be employed. We use the TTL cache as our building block because it provides the means through setting timers to control the hit probabilities of different files in order to maximize the sum of utilities.\n\nUsing timer based caching techniques for controlling the hit probabilities with $0 < t_i < \\infty$ ensures that $0 < h_i < 1$, and hence, disregarding the possibility of $h_i = 0$ or $h_i = 1$, we can write the Lagrangian function as\n\n", "index": 7, "text": "\\begin{align*}\n{\\mathcal{L}}(\\mathbf{h}, \\alpha) &= \\sum_{i=1}^{N}{U_i(h_i)}-\\alpha\\left[ \\sum_{i=1}^{N}{h_i} - B\\right] \\\\\n&= \\sum_{i=1}^{N}{\\Big[ U_i(h_i)-\\alpha h_i \\Big]} + \\alpha B,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathcal{L}}(\\mathbf{h},\\alpha)\" display=\"inline\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{i=1}^{N}{U_{i}(h_{i})}-\\alpha\\left[\\sum_{i=1}^{N}{h_{i}}-B\\right]\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo>[</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo>]</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{i=1}^{N}{\\Big{[}U_{i}(h_{i})-\\alpha h_{i}\\Big{]}}+\\alpha B,\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><mo maxsize=\"160%\" minsize=\"160%\">[</mo><mrow><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">]</mo></mrow></mrow><mo>+</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mi>B</mi></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nLet $U'_i(\\cdot)$ denote the derivative of the the utility function $U_i(\\cdot)$, and define ${U'_i}^{-1}(\\cdot)$ as its inverse function.\nFrom~\\eqref{eq:drv} we get\n", "itemtype": "equation", "pos": 13271, "prevtext": "\nwhere $\\alpha$ is the Lagrange multiplier. \n\nIn order to achieve the maximum in ${\\mathcal{L}}(\\mathbf{h}, \\alpha)$, the hit probabilities should satisfy\n\n", "index": 9, "text": "\\begin{equation}\n\\label{eq:drv}\n\\frac{\\partial{\\mathcal{L}}}{\\partial h_i} = \\frac{{\\mathrm{d}} U_i}{{\\mathrm{d}} h_i} - \\alpha = 0.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\frac{\\partial{\\mathcal{L}}}{\\partial h_{i}}=\\frac{{\\mathrm{d}}U_{i}}{{\\mathrm%&#10;{d}}h_{i}}-\\alpha=0.\" display=\"block\"><mrow><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><mfrac><mrow><mi mathvariant=\"normal\">d</mi><mo>\u2062</mo><msub><mi>U</mi><mi>i</mi></msub></mrow><mrow><mi mathvariant=\"normal\">d</mi><mo>\u2062</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac><mo>-</mo><mi>\u03b1</mi></mrow><mo>=</mo><mn>0</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nor equivalently\n\n", "itemtype": "equation", "pos": 13585, "prevtext": "\n\nLet $U'_i(\\cdot)$ denote the derivative of the the utility function $U_i(\\cdot)$, and define ${U'_i}^{-1}(\\cdot)$ as its inverse function.\nFrom~\\eqref{eq:drv} we get\n", "index": 11, "text": "\n\\[U'_i(h_i) = \\alpha,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"U^{\\prime}_{i}(h_{i})=\\alpha,\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\u03b1</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nApplying the cache storage constraint we obtain\n\n", "itemtype": "equation", "pos": 13626, "prevtext": "\nor equivalently\n\n", "index": 13, "text": "\\begin{equation}\n\\label{eq:hu}\nh_i = {U'_i}^{-1}(\\alpha).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{i}}^{-1}(\\alpha).\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand $\\alpha$ can be computed by solving the fixed-point equation given above.\n\nAs mentioned before, we can implement utility maximizing caches using TTL based policies.\nUsing the expression for the hit probabilities of non-reset and reset TTL caches given in~\\eqref{eq:hit_non_reset} and~\\eqref{eq:hit_reset},\nwe can compute the timer parameters $t_i$, once $\\alpha$ is determined from~\\eqref{eq:c}.\nFor non-reset TTL caches we obtain\n\n", "itemtype": "equation", "pos": 13747, "prevtext": "\nApplying the cache storage constraint we obtain\n\n", "index": 15, "text": "\\begin{equation}\n\\label{eq:c}\n\\sum_{i}{h_i} = \\sum_{i}{{U'_i}^{-1}(\\alpha)} = B,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i}{h_{i}}=\\sum_{i}{{U^{\\prime}_{i}}^{-1}(\\alpha)}=B,\" display=\"block\"><mrow><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>B</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand for reset TTL caches we get\n\n", "itemtype": "equation", "pos": 14278, "prevtext": "\nand $\\alpha$ can be computed by solving the fixed-point equation given above.\n\nAs mentioned before, we can implement utility maximizing caches using TTL based policies.\nUsing the expression for the hit probabilities of non-reset and reset TTL caches given in~\\eqref{eq:hit_non_reset} and~\\eqref{eq:hit_reset},\nwe can compute the timer parameters $t_i$, once $\\alpha$ is determined from~\\eqref{eq:c}.\nFor non-reset TTL caches we obtain\n\n", "index": 17, "text": "\\begin{equation}\n\\label{eq:non_reset_t}\nt_i = -\\frac{1}{\\lambda_i}\\Big(1 - \\frac{1}{1 - {U'_i}^{-1}(\\alpha)}\\Big),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"t_{i}=-\\frac{1}{\\lambda_{i}}\\Big{(}1-\\frac{1}{1-{U^{\\prime}_{i}}^{-1}(\\alpha)}%&#10;\\Big{)},\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>-</mo><mrow><mfrac><mn>1</mn><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>-</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mfrac></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\\subsection{Soft Constraint Formulation}\n\\label{sec:soft}\nThe formulation in~\\eqref{eq:opt} assumes a hard constraint on cache capacity.\nIn some circumstances it may be appropriate for the (cache) service provider to increase the available cache storage at some cost to the file provider\nfor the additional resources\\footnote{One straightforward way of thinking this is to turn the cache memory disks on and off based on the demand.}.\nIn this case the cache capacity constraint can be replaced with a penalty function $C(\\cdot)$ denoting the cost for the extra cache storage.\nHere, $C(\\cdot)$ is assumed to be a convex and increasing function.\nWe can now write the utility and cost driven caching formulation as\n\n", "itemtype": "equation", "pos": 14440, "prevtext": "\nand for reset TTL caches we get\n\n", "index": 19, "text": "\\begin{equation}\n\\label{eq:reset_t}\nt_i = -\\frac{1}{\\lambda_i}\\log{\\Big(1 - {U'_i}^{-1}(\\alpha)\\Big)}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"t_{i}=-\\frac{1}{\\lambda_{i}}\\log{\\Big{(}1-{U^{\\prime}_{i}}^{-1}(\\alpha)\\Big{)}}.\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>-</mo><mrow><mfrac><mn>1</mn><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\nNote the optimality condition for the above optimization problem states that\n", "itemtype": "equation", "pos": 15271, "prevtext": "\n\n\\subsection{Soft Constraint Formulation}\n\\label{sec:soft}\nThe formulation in~\\eqref{eq:opt} assumes a hard constraint on cache capacity.\nIn some circumstances it may be appropriate for the (cache) service provider to increase the available cache storage at some cost to the file provider\nfor the additional resources\\footnote{One straightforward way of thinking this is to turn the cache memory disks on and off based on the demand.}.\nIn this case the cache capacity constraint can be replaced with a penalty function $C(\\cdot)$ denoting the cost for the extra cache storage.\nHere, $C(\\cdot)$ is assumed to be a convex and increasing function.\nWe can now write the utility and cost driven caching formulation as\n\n", "index": 21, "text": "\\begin{align}\n\\label{eq:opt_soft}\n\\text{maximize} \\quad &\\sum_{i=1}^{N}{U_i(h_i)} - C(\\sum_{i=1}^{N}{h_i} - B) \\\\\n\\text{such that} \\quad &0 \\le h_i \\le 1, \\quad i=1,2,\\ldots, N. \\notag\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{N}{U_{i}(h_{i})}-C(\\sum_{i=1}^{N}{h_{i}}-B)\" display=\"inline\"><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 0\\leq h_{i}\\leq 1,\\quad i=1,2,\\ldots,N.\" display=\"inline\"><mrow><mrow><mrow><mn>0</mn><mo>\u2264</mo><msub><mi>h</mi><mi>i</mi></msub><mo>\u2264</mo><mn>1</mn></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>N</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nTherefore, for the hit probabilities we obtain\n", "itemtype": "equation", "pos": 15546, "prevtext": "\n\n\nNote the optimality condition for the above optimization problem states that\n", "index": 23, "text": "\n\\[U'_i(h_i) = C'(\\sum_{i=1}^{N}{h_i} - B).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"U^{\\prime}_{i}(h_{i})=C^{\\prime}(\\sum_{i=1}^{N}{h_{i}}-B).\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand the optimal value for the cache storage can be computed using the fixed-point equation\n\n", "itemtype": "equation", "pos": 15639, "prevtext": "\n\nTherefore, for the hit probabilities we obtain\n", "index": 25, "text": "\n\\[h_i = {U'_i}^{-1}\\Big(C'(\\sum_{i=1}^{N}{h_i} - B)\\Big),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{i}}^{-1}\\Big{(}C^{\\prime}(\\sum_{i=1}^{N}{h_{i}}-B)\\Big{)},\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\\subsection{Buffer Constraint Violations}\n\\label{sec:violation}\nBefore we leave this section, we address an issue that arises in both formulations, namely how to deal with the fact that there may be more contents with unexpired timers than can be stored in the buffer.  This occurs in the formulation of (\\ref{eq:opt}) because the constraint is on the {\\em average} buffer occupancy and in (\\ref{eq:opt_soft}) because there is no constraint. Let us focus on the formulation in (\\ref{eq:opt}) first.  Our approach is to provide a buffer of size $B(1+\\epsilon )$ with $\\epsilon > 0$, where a portion $B$ is used to solve the optimization problem and the additional portion $\\epsilon B$ to handle buffer violations.  We will see that as the number of contents, $N$,  increases, we can get by growing $B$ in a sublinear manner, and allow $\\epsilon$ to shrink to zero, while ensuring that content will not be evicted from the cache before their timers expire with high probability.  Let  $X_i$ denote whether content $i$ is in the cache or not; $P(X_i =1) = h_i $.  Now Let ${\\mathbb{E}}\\bigl[\\sum_{i=1}^N X_i\\bigr] = \\sum_{i=1}^N h_i = B$. We write $B(N)$ as a function of $N$, and assume that $B(N) = \\omega (1)$. \n\\begin{theorem}\n\\label{thrm:violation}\nFor any $\\epsilon > 0$\n", "itemtype": "equation", "pos": 15791, "prevtext": "\nand the optimal value for the cache storage can be computed using the fixed-point equation\n\n", "index": 27, "text": "\\begin{equation}\n\\label{eq:elastic_B}\nB^* = \\sum_{i=1}^{N}{{U'_i}^{-1}\\Big(C'(B^* - B)\\Big)}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"B^{*}=\\sum_{i=1}^{N}{{U^{\\prime}_{i}}^{-1}\\Big{(}C^{\\prime}(B^{*}-B)\\Big{)}}.\" display=\"block\"><mrow><mrow><msup><mi>B</mi><mo>*</mo></msup><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>B</mi><mo>*</mo></msup><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\\end{theorem}\nThe proof follows from the application of a Chernoff bound.\n\nTheorem~\\ref{thrm:violation} states that we can size the buffer as $B(1+\\epsilon)$ while using a portion $B$ as the constraint in the optimization.  The remaining portion, $\\epsilon B$, is used to protect against buffer constraint violations. \nIt suffices for our purpose that ${\\epsilon^2 B(N) = \\omega (1)}$.  This allows us to select $B(N) = o(N)$ while at the same time selecting $\\epsilon = o(1)$. As an example, consider Zipf's law with $\\lambda_i = \\lambda/i^s$, $\\lambda > 0$, $0 < s <1$,  $i=1,\\ldots, N$ under the assumption that $\\max{\\{t_i\\}} = t$ for some $t <\\infty$.  In this case, we can grow the buffer as $B(N) = O(N^{1-s})$ while \n$\\epsilon$  can shrink as $\\epsilon = 1/N^{(1-s)/3}$.  Analogous expressions can be derived for $s \\ge 1$.\n\nSimilar choices can be made for the soft constraint formulation.\n\n\n\n\n\n\n\n\\section{Utility Functions and Fairness}\n\\label{sec:fairness}\nUsing different utility functions in the optimization formulation~\\eqref{eq:opt} yields different timer values for the files.\nIn this sense, each utility function defines a notion of fairness in allocating storage resources to different files.\nIn this section, we study a number of utility functions that have important fairness properties associated with them.\n\\subsection{Identical Utilities}\n\\label{sec:opt_identical}\nAssume that all files have the same utility function, {\\emph{i.e.}}\\ $U_i(h_i) = U(h_i)$ for all $i$. Then, from~\\eqref{eq:c} we obtain\n", "itemtype": "equation", "pos": 17174, "prevtext": "\n\n\\subsection{Buffer Constraint Violations}\n\\label{sec:violation}\nBefore we leave this section, we address an issue that arises in both formulations, namely how to deal with the fact that there may be more contents with unexpired timers than can be stored in the buffer.  This occurs in the formulation of (\\ref{eq:opt}) because the constraint is on the {\\em average} buffer occupancy and in (\\ref{eq:opt_soft}) because there is no constraint. Let us focus on the formulation in (\\ref{eq:opt}) first.  Our approach is to provide a buffer of size $B(1+\\epsilon )$ with $\\epsilon > 0$, where a portion $B$ is used to solve the optimization problem and the additional portion $\\epsilon B$ to handle buffer violations.  We will see that as the number of contents, $N$,  increases, we can get by growing $B$ in a sublinear manner, and allow $\\epsilon$ to shrink to zero, while ensuring that content will not be evicted from the cache before their timers expire with high probability.  Let  $X_i$ denote whether content $i$ is in the cache or not; $P(X_i =1) = h_i $.  Now Let ${\\mathbb{E}}\\bigl[\\sum_{i=1}^N X_i\\bigr] = \\sum_{i=1}^N h_i = B$. We write $B(N)$ as a function of $N$, and assume that $B(N) = \\omega (1)$. \n\\begin{theorem}\n\\label{thrm:violation}\nFor any $\\epsilon > 0$\n", "index": 29, "text": "\n\\[\n {\\mathbb{P}}\\bigl(\\sum_{i=1}^N X_i \\ge B(N)(1+\\epsilon)\\bigr) \\le e^{-\\epsilon^2 B(N)/3} .\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"{\\mathbb{P}}\\bigl{(}\\sum_{i=1}^{N}X_{i}\\geq B(N)(1+\\epsilon)\\bigr{)}\\leq e^{-%&#10;\\epsilon^{2}B(N)/3}.\" display=\"block\"><mrow><mi>\u2119</mi><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>X</mi><mi>i</mi></msub><mo>\u2265</mo><mi>B</mi><mrow><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>\u03f5</mi><mo stretchy=\"false\">)</mo></mrow><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow><mo>\u2264</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><mrow><msup><mi>\u03f5</mi><mn>2</mn></msup><mo>\u2062</mo><mi>B</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>/</mo><mn>3</mn></mrow></mrow></msup><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand hence\n", "itemtype": "equation", "pos": 18796, "prevtext": "\n\\end{theorem}\nThe proof follows from the application of a Chernoff bound.\n\nTheorem~\\ref{thrm:violation} states that we can size the buffer as $B(1+\\epsilon)$ while using a portion $B$ as the constraint in the optimization.  The remaining portion, $\\epsilon B$, is used to protect against buffer constraint violations. \nIt suffices for our purpose that ${\\epsilon^2 B(N) = \\omega (1)}$.  This allows us to select $B(N) = o(N)$ while at the same time selecting $\\epsilon = o(1)$. As an example, consider Zipf's law with $\\lambda_i = \\lambda/i^s$, $\\lambda > 0$, $0 < s <1$,  $i=1,\\ldots, N$ under the assumption that $\\max{\\{t_i\\}} = t$ for some $t <\\infty$.  In this case, we can grow the buffer as $B(N) = O(N^{1-s})$ while \n$\\epsilon$  can shrink as $\\epsilon = 1/N^{(1-s)/3}$.  Analogous expressions can be derived for $s \\ge 1$.\n\nSimilar choices can be made for the soft constraint formulation.\n\n\n\n\n\n\n\n\\section{Utility Functions and Fairness}\n\\label{sec:fairness}\nUsing different utility functions in the optimization formulation~\\eqref{eq:opt} yields different timer values for the files.\nIn this sense, each utility function defines a notion of fairness in allocating storage resources to different files.\nIn this section, we study a number of utility functions that have important fairness properties associated with them.\n\\subsection{Identical Utilities}\n\\label{sec:opt_identical}\nAssume that all files have the same utility function, {\\emph{i.e.}}\\ $U_i(h_i) = U(h_i)$ for all $i$. Then, from~\\eqref{eq:c} we obtain\n", "index": 31, "text": "\n\\[\\sum_{i=1}^{N}{{U'}^{-1}(\\alpha)} = N {U'}^{-1}(\\alpha) = B,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{N}{{U^{\\prime}}^{-1}(\\alpha)}=N{U^{\\prime}}^{-1}(\\alpha)=B,\" display=\"block\"><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mmultiscripts><mi>U</mi><none/><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>N</mi><mo>\u2062</mo><mmultiscripts><mi>U</mi><none/><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>B</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nUsing~\\eqref{eq:hu} for the hit probabilities we get\n", "itemtype": "equation", "pos": 18871, "prevtext": "\nand hence\n", "index": 33, "text": "\n\\[{U'}^{-1}(\\alpha) = B/N.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"{U^{\\prime}}^{-1}(\\alpha)=B/N.\" display=\"block\"><mrow><mrow><mrow><mmultiscripts><mi>U</mi><none/><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>B</mi><mo>/</mo><mi>N</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nUsing a non-reset TTL policy, the timers should be set according to\n", "itemtype": "equation", "pos": 18953, "prevtext": "\nUsing~\\eqref{eq:hu} for the hit probabilities we get\n", "index": 35, "text": "\n\\[h_i = B/N, \\quad \\forall{i}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"h_{i}=B/N,\\quad\\forall{i}.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mrow><mi>B</mi><mo>/</mo><mi>N</mi></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mo>\u2200</mo><mi>i</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhile with a reset TTL policy, they must equal\n", "itemtype": "equation", "pos": 19055, "prevtext": "\n\nUsing a non-reset TTL policy, the timers should be set according to\n", "index": 37, "text": "\n\\[t_i = \\frac{B}{\\lambda_i (N - B)},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"t_{i}=\\frac{B}{\\lambda_{i}(N-B)},\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mfrac><mi>B</mi><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nThe above calculations show that identical utility functions yield identical hit probabilities for all files. Note that the hit probabilities computed above do not depend on the utility function.\n\n\n\\subsection{$\\boldsymbol{\\beta}$-Fair Utility Functions}\nHere, we consider the family of $\\beta$-fair (also known as \\emph{isoelastic}) utility functions given by\n", "itemtype": "equation", "pos": 19141, "prevtext": "\nwhile with a reset TTL policy, they must equal\n", "index": 39, "text": "\n\\[t_i = -\\frac{1}{\\lambda_i}\\log{\\left(1-\\frac{B}{N}\\right)}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"t_{i}=-\\frac{1}{\\lambda_{i}}\\log{\\left(1-\\frac{B}{N}\\right)}.\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>-</mo><mrow><mfrac><mn>1</mn><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo>(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mi>B</mi><mi>N</mi></mfrac></mrow><mo>)</mo></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere the coefficient $w_i \\ge 0$ denotes the weight for file $i$.\nThis family of utility functions unifies different notions of fairness in resource allocation~\\cite{srikant13}.\nIn the remainder of this section, we investigate some of the choices for $\\beta$ that lead to interesting special cases.\n\n\\subsubsection{$\\boldsymbol{\\beta = 0}$}\\hspace*{\\fill} \\\\\nWith $\\beta = 0$, we get $U_i(h_i) = w_i h_i$, and maximizing the sum of the utilities\ncorresponds to\n", "itemtype": "equation", "pos": 19567, "prevtext": "\n\nThe above calculations show that identical utility functions yield identical hit probabilities for all files. Note that the hit probabilities computed above do not depend on the utility function.\n\n\n\\subsection{$\\boldsymbol{\\beta}$-Fair Utility Functions}\nHere, we consider the family of $\\beta$-fair (also known as \\emph{isoelastic}) utility functions given by\n", "index": 41, "text": "\n\\[U_i(h_i) = \\left\\{ \\begin{array}{ll}\n w_i\\frac{h_i^{1-\\beta}}{1-\\beta} & \\beta \\ge 0, \\beta \\neq 1; \\\\\n & \\\\\n w_i \\log{h_i} & \\beta = 1,\n \\end{array} \\right. \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"U_{i}(h_{i})=\\left\\{\\begin{array}[]{ll}w_{i}\\frac{h_{i}^{1-\\beta}}{1-\\beta}&amp;%&#10;\\beta\\geq 0,\\beta\\neq 1;\\\\&#10;&amp;\\\\&#10;w_{i}\\log{h_{i}}&amp;\\beta=1,\\end{array}\\right.\" display=\"block\"><mrow><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><mfrac><msubsup><mi>h</mi><mi>i</mi><mrow><mn>1</mn><mo>-</mo><mi>\u03b2</mi></mrow></msubsup><mrow><mn>1</mn><mo>-</mo><mi>\u03b2</mi></mrow></mfrac></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mi>\u03b2</mi><mo>\u2265</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>\u03b2</mi><mo>\u2260</mo><mn>1</mn></mrow></mrow><mo>;</mo></mrow></mtd></mtr><mtr><mtd/><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mi>\u03b2</mi><mo>=</mo><mn>1</mn></mrow><mo>,</mo></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nThe above utility function defined does not satisfy the requirements for a utility function mentioned in Section~\\ref{sec:model}, as it is not strictly concave.\nHowever, it is easy to see that the sum of the utilities is maximized when\n", "itemtype": "equation", "pos": 20192, "prevtext": "\nwhere the coefficient $w_i \\ge 0$ denotes the weight for file $i$.\nThis family of utility functions unifies different notions of fairness in resource allocation~\\cite{srikant13}.\nIn the remainder of this section, we investigate some of the choices for $\\beta$ that lead to interesting special cases.\n\n\\subsubsection{$\\boldsymbol{\\beta = 0}$}\\hspace*{\\fill} \\\\\nWith $\\beta = 0$, we get $U_i(h_i) = w_i h_i$, and maximizing the sum of the utilities\ncorresponds to\n", "index": 43, "text": "\n\\[\\max_{h_i}{\\sum_{i}{w_i h_i}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\max_{h_{i}}{\\sum_{i}{w_{i}h_{i}}}.\" display=\"block\"><mrow><mrow><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere we assume that weights are sorted as ${w_1 \\ge \\ldots \\ge w_N}$.\nThese hit probabilities indicate that the optimal timer parameters are\n", "itemtype": "equation", "pos": 20464, "prevtext": "\n\nThe above utility function defined does not satisfy the requirements for a utility function mentioned in Section~\\ref{sec:model}, as it is not strictly concave.\nHowever, it is easy to see that the sum of the utilities is maximized when\n", "index": 45, "text": "\n\\[h_i = 1, i=1,\\ldots, B  \\quad \\text{ and } \\quad h_i = 0, i=B+1,\\ldots, N,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"h_{i}=1,i=1,\\ldots,B\\quad\\text{ and }\\quad h_{i}=0,i=B+1,\\ldots,N,\" display=\"block\"><mrow><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>B</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>\u00a0and\u00a0</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mrow><mi>B</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>N</mi></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nNote that the policy obtained by implementing this utility function with $w_i = \\lambda_i$ corresponds to the Least-Frequently Used (LFU) caching policy,\nand maximizes the overall throughput.\n\n\\subsubsection{$\\boldsymbol{\\beta = 1}$}\\hspace*{\\fill} \\\\\nLetting $\\beta = 1$, we get $U_i(h_i) = w_i \\log{h_i}$,\nand hence maximizing the sum of the utilities corresponds to\n", "itemtype": "equation", "pos": 20685, "prevtext": "\nwhere we assume that weights are sorted as ${w_1 \\ge \\ldots \\ge w_N}$.\nThese hit probabilities indicate that the optimal timer parameters are\n", "index": 47, "text": "\n\\[t_i = \\infty, i=1,\\ldots, B  \\quad \\text{ and } \\quad t_i = 0, i=B+1,\\ldots, N.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"t_{i}=\\infty,i=1,\\ldots,B\\quad\\text{ and }\\quad t_{i}=0,i=B+1,\\ldots,N.\" display=\"block\"><mrow><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mi mathvariant=\"normal\">\u221e</mi></mrow><mo>,</mo><mrow><mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>B</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>\u00a0and\u00a0</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><mo>,</mo><mrow><mi>i</mi><mo>=</mo><mrow><mrow><mi>B</mi><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>N</mi></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nIt is easy to see that ${U'_i}^{-1}(\\alpha) = w_i / \\alpha$, and hence using~\\eqref{eq:c} we obtain\n", "itemtype": "equation", "pos": 21139, "prevtext": "\n\nNote that the policy obtained by implementing this utility function with $w_i = \\lambda_i$ corresponds to the Least-Frequently Used (LFU) caching policy,\nand maximizes the overall throughput.\n\n\\subsubsection{$\\boldsymbol{\\beta = 1}$}\\hspace*{\\fill} \\\\\nLetting $\\beta = 1$, we get $U_i(h_i) = w_i \\log{h_i}$,\nand hence maximizing the sum of the utilities corresponds to\n", "index": 49, "text": "\n\\[\\max_{h_i}{\\sum_{i}{w_i \\log{h_i}}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\max_{h_{i}}{\\sum_{i}{w_{i}\\log{h_{i}}}}.\" display=\"block\"><mrow><mrow><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhich yields\n", "itemtype": "equation", "pos": 21281, "prevtext": "\n\nIt is easy to see that ${U'_i}^{-1}(\\alpha) = w_i / \\alpha$, and hence using~\\eqref{eq:c} we obtain\n", "index": 51, "text": "\n\\[\\sum_{i}{{U'_i}^{-1}(\\alpha)} = \\sum_{i}{w_i} / \\alpha = B,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i}{{U^{\\prime}_{i}}^{-1}(\\alpha)}=\\sum_{i}{w_{i}}/\\alpha=B,\" display=\"block\"><mrow><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>/</mo><mi>\u03b1</mi></mrow></mrow><mo>=</mo><mi>B</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nThe hit probability of file $i$ then equals\n", "itemtype": "equation", "pos": 21358, "prevtext": "\nwhich yields\n", "index": 53, "text": "\n\\[\\alpha = \\sum_{i}{w_i} / B.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"\\alpha=\\sum_{i}{w_{i}}/B.\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>/</mo><mi>B</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\n\nThis utility function implements a \\emph{proportionally fair} policy~\\cite{kelly98}.\nWith $w_i = \\lambda_i$, the hit probability of file $i$ is proportional to the request arrival rate $\\lambda_i$.\n\n\\subsubsection{$\\boldsymbol{\\beta = 2}$}\\hspace*{\\fill} \\\\\nWith $\\beta = 2$, we get $U_i(h_i) = -w_i/h_i$, and maximizing the total utility corresponds to\n", "itemtype": "equation", "pos": 21434, "prevtext": "\nThe hit probability of file $i$ then equals\n", "index": 55, "text": "\n\\[h_i = {U'_i}^{-1}(\\alpha) = \\frac{w_i}{\\sum_{j}{w_j}}B.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{i}}^{-1}(\\alpha)=\\frac{w_{i}}{\\sum_{j}{w_{j}}}B.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><msub><mi>w</mi><mi>i</mi></msub><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>j</mi></msub><msub><mi>w</mi><mi>j</mi></msub></mrow></mfrac><mo>\u2062</mo><mi>B</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nIn this case, we get ${U'_i}^{-1}(\\alpha) = \\sqrt{w_i} / \\sqrt{\\alpha}$, therefore\n", "itemtype": "equation", "pos": 21851, "prevtext": "\n\n\n\nThis utility function implements a \\emph{proportionally fair} policy~\\cite{kelly98}.\nWith $w_i = \\lambda_i$, the hit probability of file $i$ is proportional to the request arrival rate $\\lambda_i$.\n\n\\subsubsection{$\\boldsymbol{\\beta = 2}$}\\hspace*{\\fill} \\\\\nWith $\\beta = 2$, we get $U_i(h_i) = -w_i/h_i$, and maximizing the total utility corresponds to\n", "index": 57, "text": "\n\\[\\max_{h_i}{\\sum_{i}{\\frac{-w_i}{h_i}}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"\\max_{h_{i}}{\\sum_{i}{\\frac{-w_{i}}{h_{i}}}}.\" display=\"block\"><mrow><mrow><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mfrac><mrow><mo>-</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><msub><mi>h</mi><mi>i</mi></msub></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand hence\n", "itemtype": "equation", "pos": 21979, "prevtext": "\n\nIn this case, we get ${U'_i}^{-1}(\\alpha) = \\sqrt{w_i} / \\sqrt{\\alpha}$, therefore\n", "index": 59, "text": "\n\\[\\sum_{i}{{U'_i}^{-1}(\\alpha)} = \\sum_{i}{\\sqrt{w_i}} / \\sqrt{\\alpha} = B,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i}{{U^{\\prime}_{i}}^{-1}(\\alpha)}=\\sum_{i}{\\sqrt{w_{i}}}/\\sqrt{\\alpha}=B,\" display=\"block\"><mrow><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msqrt><msub><mi>w</mi><mi>i</mi></msub></msqrt><mo>/</mo><msqrt><mi>\u03b1</mi></msqrt></mrow></mrow><mo>=</mo><mi>B</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nThe hit probability of file $i$ then equals\n", "itemtype": "equation", "pos": 22067, "prevtext": "\nand hence\n", "index": 61, "text": "\n\\[\\alpha = \\Big(\\sum_{i}{\\sqrt{w_i}}\\Big)^2 / B^2.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"\\alpha=\\Big{(}\\sum_{i}{\\sqrt{w_{i}}}\\Big{)}^{2}/B^{2}.\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>=</mo><mrow><msup><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msqrt><msub><mi>w</mi><mi>i</mi></msub></msqrt></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mn>2</mn></msup><mo>/</mo><msup><mi>B</mi><mn>2</mn></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nThe utility function defined above is known to yield minimum potential delay fairness. It was shown in~\\cite{kelly98} that the TCP congestion control protocol\nimplements such a utility function.\n\n\\subsubsection{$\\boldsymbol{\\beta \\rightarrow\\infty}$}\\hspace*{\\fill} \\\\\nWith $\\beta \\rightarrow\\infty$, maximizing the sum of the utilities corresponds to (see~\\cite{mo00} for proof)\n", "itemtype": "equation", "pos": 22165, "prevtext": "\n\nThe hit probability of file $i$ then equals\n", "index": 63, "text": "\n\\[h_i = {U'_i}^{-1}(\\alpha) = \\frac{\\sqrt{w_i}}{\\sqrt{\\alpha}} = \\frac{\\sqrt{w_i}}{\\sum_{j}{\\sqrt{w_j}}}B.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{i}}^{-1}(\\alpha)=\\frac{\\sqrt{w_{i}}}{\\sqrt{\\alpha}}=\\frac{%&#10;\\sqrt{w_{i}}}{\\sum_{j}{\\sqrt{w_{j}}}}B.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><msqrt><msub><mi>w</mi><mi>i</mi></msub></msqrt><msqrt><mi>\u03b1</mi></msqrt></mfrac><mo>=</mo><mrow><mfrac><msqrt><msub><mi>w</mi><mi>i</mi></msub></msqrt><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mi>j</mi></msub><msqrt><msub><mi>w</mi><mi>j</mi></msub></msqrt></mrow></mfrac><mo>\u2062</mo><mi>B</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nThis utility function does not comply with the rules mentioned in Section~\\ref{sec:model} for utility functions, as it is not strictly concave.\nHowever, it is easy to see that the above utility function yields\n", "itemtype": "equation", "pos": 22655, "prevtext": "\n\nThe utility function defined above is known to yield minimum potential delay fairness. It was shown in~\\cite{kelly98} that the TCP congestion control protocol\nimplements such a utility function.\n\n\\subsubsection{$\\boldsymbol{\\beta \\rightarrow\\infty}$}\\hspace*{\\fill} \\\\\nWith $\\beta \\rightarrow\\infty$, maximizing the sum of the utilities corresponds to (see~\\cite{mo00} for proof)\n", "index": 65, "text": "\n\\[\\max_{h_i}{\\min_{i}{h_i}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"\\max_{h_{i}}{\\min_{i}{h_{i}}}.\" display=\"block\"><mrow><mrow><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mo>\u2061</mo><mrow><munder><mi>min</mi><mi>i</mi></munder><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nUsing a non-reset TTL policy, the timers should be set according to\n", "itemtype": "equation", "pos": 18953, "prevtext": "\nUsing~\\eqref{eq:hu} for the hit probabilities we get\n", "index": 35, "text": "\n\\[h_i = B/N, \\quad \\forall{i}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"h_{i}=B/N,\\quad\\forall{i}.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mrow><mi>B</mi><mo>/</mo><mi>N</mi></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mo>\u2200</mo><mi>i</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\n\nIn our framework, we see from~\\eqref{eq:hu} that the file hit probabilities depend on the Lagrange multiplier $\\alpha$ corresponding to the cache size constraint in~\\eqref{eq:opt}.\nThis suggests a connection between $T$ and $\\alpha$. Further note that the hit probabilities are increasing functions of $T$. On the other hand, since utility functions are concave and increasing, $h_i = {U'_i}^{-1}(\\alpha)$ is a decreasing\nfunction of $\\alpha$. Hence, we can denote $T$ as a decreasing function of $\\alpha$, {\\emph{i.e.}}~$T = f(\\alpha)$. \n\nDifferent choices of function $f(\\cdot)$ would result in different utility functions for FIFO and LRU policies. \nHowever, if we impose the functional dependence $U_i(h_i) = \\lambda_i U_0(h_i)$, then the equation $h_i = {U'_i}^{-1}(\\alpha)$ yields\n", "itemtype": "equation", "pos": 24838, "prevtext": "\n\nThe utility function defined here maximizes the minimum hit probability, and corresponds to the \\emph{max-min fairness}. Note that using identical utility functions for all files resulted in similar hit probabilities as this case. A brief summary of the utility functions discussed here is given in Table~\\ref{tbl:u}. \n\\begin{table*}[]\n\\centering\n\\caption{$\\beta$-fair utility functions family}\n\\begin{tabular}{ | c | c | c | c |}\n\\hline\n$\\beta$ & $\\max{\\sum_{i}{U_i(h_i)}}$ & $h_i$ & implication \\\\\n\\hline\n  0 & $\\max{\\sum{w_i h_i}}$ & $h_i = 1, i\\le B, h_i = 0, i \\ge B+1$ & maximizing overall throughput \\\\\n  1 & $\\max{\\sum{w_i \\log{h_i}}}$ & $h_i = w_i B / \\sum_{j}{w_j}$ & proportional fairness \\\\\n  2 & $\\max{-\\sum{w_i / h_i}}$ & $h_i = \\sqrt{w_i} B / \\sum_{j}{\\sqrt{w_j}}$ & minimize potential delay \\\\\n  $\\infty$ & $\\max{\\min{h_i}}$ & $h_i = B/N$ & max-min fairness \\\\\n\\hline\n\\end{tabular}\n\\label{tbl:u}\n\\end{table*}\n\n\n\n\\section{Reverse Engineering}\n\\label{sec:reverse}\nIn this section, we study the widely used replacement-based caching policies, FIFO and LRU, and show that their hit/miss behaviors can be duplicated in our framework through an appropriate choice of utility functions.\n \nIt was shown in~\\cite{Nicaise14} that, with a proper choice of timer values, a TTL cache can generate the same statistical properties, {\\emph{i.e.}}~same hit/miss probabilities, as FIFO and LRU caching policies. \nIn implementing these caches, non-reset and reset TTL caches are used for FIFO and LRU, respectively, with $t_i=T, i=1,\\ldots,N$ where $T$ denotes the \\emph{characteristic time}~\\cite{Che01} of these caches. For FIFO and LRU caches with Poisson arrivals the hit probabilities can be expressed as\n$h_i = 1 - 1/(1+\\lambda_iT)$ and $h_i = 1 - e^{-\\lambda_i T}$, and $T$ is computed such that $\\sum_{i}{h_i} = B$.\nFor example for the LRU policy $T$ is the unique solution to the fixed-point equation\n", "index": 69, "text": "\n\\[\\sum_{i=1}^{N}{\\left(1 - e^{-\\lambda_i T}\\right)} = B.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{N}{\\left(1-e^{-\\lambda_{i}T}\\right)}=B.\" display=\"block\"><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><mo>(</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mi>T</mi></mrow></mrow></msup></mrow><mo>)</mo></mrow></mrow><mo>=</mo><mi>B</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nFrom the expressions for the hit probabilities of the FIFO and LRU policies, we obtain $T = 1/\\alpha$. In the remainder of the section, we use this to derive utility functions for the FIFO and LRU policies.\n\n\\subsection{FIFO}\nThe hit probability of file $i$ with request rate $\\lambda_i$ in a FIFO cache with characteristic time $T$ is\n", "itemtype": "equation", "pos": 25687, "prevtext": "\n\n\n\nIn our framework, we see from~\\eqref{eq:hu} that the file hit probabilities depend on the Lagrange multiplier $\\alpha$ corresponding to the cache size constraint in~\\eqref{eq:opt}.\nThis suggests a connection between $T$ and $\\alpha$. Further note that the hit probabilities are increasing functions of $T$. On the other hand, since utility functions are concave and increasing, $h_i = {U'_i}^{-1}(\\alpha)$ is a decreasing\nfunction of $\\alpha$. Hence, we can denote $T$ as a decreasing function of $\\alpha$, {\\emph{i.e.}}~$T = f(\\alpha)$. \n\nDifferent choices of function $f(\\cdot)$ would result in different utility functions for FIFO and LRU policies. \nHowever, if we impose the functional dependence $U_i(h_i) = \\lambda_i U_0(h_i)$, then the equation $h_i = {U'_i}^{-1}(\\alpha)$ yields\n", "index": 71, "text": "\n\\[h_i = {U'_0}^{-1}(\\alpha/\\lambda_i).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{0}}^{-1}(\\alpha/\\lambda_{i}).\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mn>0</mn><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>/</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nSubstituting this into~\\eqref{eq:hu} and letting $T = 1/\\alpha$ yields\n", "itemtype": "equation", "pos": 26064, "prevtext": "\nFrom the expressions for the hit probabilities of the FIFO and LRU policies, we obtain $T = 1/\\alpha$. In the remainder of the section, we use this to derive utility functions for the FIFO and LRU policies.\n\n\\subsection{FIFO}\nThe hit probability of file $i$ with request rate $\\lambda_i$ in a FIFO cache with characteristic time $T$ is\n", "index": 73, "text": "\n\\[h_i = 1 - \\frac{1}{1 + \\lambda_i T}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m1\" class=\"ltx_Math\" alttext=\"h_{i}=1-\\frac{1}{1+\\lambda_{i}T}.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mi>T</mi></mrow></mrow></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nComputing the inverse of ${U'_i}^{-1}(\\cdot)$ yields\n", "itemtype": "equation", "pos": 26176, "prevtext": "\nSubstituting this into~\\eqref{eq:hu} and letting $T = 1/\\alpha$ yields\n", "index": 75, "text": "\n\\[{U'_i}^{-1}(\\alpha) = 1 - \\frac{1}{1 + \\lambda_i / \\alpha}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m1\" class=\"ltx_Math\" alttext=\"{U^{\\prime}_{i}}^{-1}(\\alpha)=1-\\frac{1}{1+\\lambda_{i}/\\alpha}.\" display=\"block\"><mrow><mrow><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>/</mo><mi>\u03b1</mi></mrow></mrow></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand integration of the two sides of the above equation yields the utility function for the FIFO cache \n", "itemtype": "equation", "pos": 26293, "prevtext": "\nComputing the inverse of ${U'_i}^{-1}(\\cdot)$ yields\n", "index": 77, "text": "\n\\[U'_i(h_i) = \\frac{\\lambda_i}{h_i} - \\lambda_i,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m1\" class=\"ltx_Math\" alttext=\"U^{\\prime}_{i}(h_{i})=\\frac{\\lambda_{i}}{h_{i}}-\\lambda_{i},\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><msub><mi>\u03bb</mi><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub></mfrac><mo>-</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\\subsection{LRU}\n\n\n\n\n\nTaking $h_i = 1 - e^{-\\lambda_i T}$ for the LRU policy and letting ${T = 1/\\alpha}$ yields\n", "itemtype": "equation", "pos": 26447, "prevtext": "\nand integration of the two sides of the above equation yields the utility function for the FIFO cache \n", "index": 79, "text": "\n\\[U_i(h_i) = \\lambda_i (\\log{h_i} - h_i).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m1\" class=\"ltx_Math\" alttext=\"U_{i}(h_{i})=\\lambda_{i}(\\log{h_{i}}-h_{i}).\" display=\"block\"><mrow><mrow><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>log</mi><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhich yields\n", "itemtype": "equation", "pos": 26605, "prevtext": "\n\n\\subsection{LRU}\n\n\n\n\n\nTaking $h_i = 1 - e^{-\\lambda_i T}$ for the LRU policy and letting ${T = 1/\\alpha}$ yields\n", "index": 81, "text": "\n\\[{U'_i}^{-1}(\\alpha) = 1 - e^{-\\lambda_i/\\alpha},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m1\" class=\"ltx_Math\" alttext=\"{U^{\\prime}_{i}}^{-1}(\\alpha)=1-e^{-\\lambda_{i}/\\alpha},\" display=\"block\"><mrow><mrow><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mn>1</mn><mo>-</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>/</mo><mi>\u03b1</mi></mrow></mrow></msup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nIntegration of the two sides of the above equation yields the utility function for the LRU caching policy\n", "itemtype": "equation", "pos": 26671, "prevtext": "\nwhich yields\n", "index": 83, "text": "\n\\[U'_i(h_i) = \\frac{-\\lambda_i}{\\log{(1-h_i)}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m1\" class=\"ltx_Math\" alttext=\"U^{\\prime}_{i}(h_{i})=\\frac{-\\lambda_{i}}{\\log{(1-h_{i})}}.\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mo>-</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $\\text{li}(\\cdot)$ is the logarithmic integral function\n", "itemtype": "equation", "pos": 26827, "prevtext": "\nIntegration of the two sides of the above equation yields the utility function for the LRU caching policy\n", "index": 85, "text": "\n\\[U_i(h_i) = \\lambda_i \\text{li}(1-h_i),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m1\" class=\"ltx_Math\" alttext=\"U_{i}(h_{i})=\\lambda_{i}\\text{li}(1-h_{i}),\" display=\"block\"><mrow><mrow><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mtext>li</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nIt is easy to verify, using the approach explained in Section~\\ref{sec:opt}, that the utility functions computed\nabove indeed yield the correct expressions for the hit probabilities of the FIFO and LRU caches.\nWe believe these utility functions are unique if restricted to be multiplicative in\\footnote{We note that utility functions, defined in this context, are subject to affine transformations, {\\emph{i.e.}}~$aU+b$ yields the same hit probabilities as $U$ for any constant $a>0$ and $b$.} $\\lambda_i$.\n\n\n\n\n\n\n\n\n\n\n\\section{Online Algorithms}\n\\label{sec:online}\nIn Section~\\ref{sec:opt}, we formulated utility-driven caching as a convex optimization problem either with a fixed or an elastic cache size. However, it is not feasible to solve the optimization problem offline and then\nimplement the optimal strategy. Moreover, the system parameters can change over time. Therefore, we need algorithms\nthat can be used to implement the optimal strategy and adapt to changes in the system by collecting limited information.\nIn this section, we develop such algorithms.\n\n\\subsection{Dual Solution}\n\\label{sec:dual}\nThe utility-driven caching formulated in~\\eqref{eq:opt} is a convex optimization problem, and hence the optimal solution corresponds to solving the dual problem.\nThe Lagrange dual of the above problem is obtained by incorporating the constraints into the maximization by means of Lagrange multipliers\n\n", "itemtype": "equation", "pos": 26932, "prevtext": "\nwhere $\\text{li}(\\cdot)$ is the logarithmic integral function\n", "index": 87, "text": "\n\\[\\text{li}(x) = \\int_0^x{\\frac{{\\mathrm{d}} t}{\\ln{t}}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex38.m1\" class=\"ltx_Math\" alttext=\"\\text{li}(x)=\\int_{0}^{x}{\\frac{{\\mathrm{d}}t}{\\ln{t}}}.\" display=\"block\"><mrow><mrow><mrow><mtext>li</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mn>0</mn><mi>x</mi></msubsup><mfrac><mrow><mi mathvariant=\"normal\">d</mi><mo>\u2062</mo><mi>t</mi></mrow><mrow><mi>ln</mi><mo>\u2061</mo><mi>t</mi></mrow></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nUsing timer based caching techniques for controlling the hit probabilities with $0 < t_i < \\infty$ ensures that $0 < h_i < 1$, and hence we have $\\nu_i = 0$ and $\\eta_i = 0$. \n\nHere, we consider an algorithm based on the dual solution to the utility maximization problem~\\eqref{eq:opt}. Recall that we can write the Lagrange dual of the utility maximization problem as\n", "itemtype": "equation", "pos": 28407, "prevtext": "\n\nIt is easy to verify, using the approach explained in Section~\\ref{sec:opt}, that the utility functions computed\nabove indeed yield the correct expressions for the hit probabilities of the FIFO and LRU caches.\nWe believe these utility functions are unique if restricted to be multiplicative in\\footnote{We note that utility functions, defined in this context, are subject to affine transformations, {\\emph{i.e.}}~$aU+b$ yields the same hit probabilities as $U$ for any constant $a>0$ and $b$.} $\\lambda_i$.\n\n\n\n\n\n\n\n\n\n\n\\section{Online Algorithms}\n\\label{sec:online}\nIn Section~\\ref{sec:opt}, we formulated utility-driven caching as a convex optimization problem either with a fixed or an elastic cache size. However, it is not feasible to solve the optimization problem offline and then\nimplement the optimal strategy. Moreover, the system parameters can change over time. Therefore, we need algorithms\nthat can be used to implement the optimal strategy and adapt to changes in the system by collecting limited information.\nIn this section, we develop such algorithms.\n\n\\subsection{Dual Solution}\n\\label{sec:dual}\nThe utility-driven caching formulated in~\\eqref{eq:opt} is a convex optimization problem, and hence the optimal solution corresponds to solving the dual problem.\nThe Lagrange dual of the above problem is obtained by incorporating the constraints into the maximization by means of Lagrange multipliers\n\n", "index": 89, "text": "\\begin{align*}\n\\text{minimize} \\quad &D(\\alpha, \\boldsymbol{\\nu}, \\boldsymbol{\\eta}) = \\max_{h_i}\\Bigg\\{ \\sum_{i=1}^{N}{U_i(h_i)} \\\\\n&\\qquad\\qquad\\qquad -\\alpha\\left[ \\sum_{i=1}^{N}{h_i} - B\\right] \\\\\n&\\qquad\\qquad\\qquad -\\sum_{i=1}^{N}{\\nu_i (h_i - 1)} + \\sum_{i=1}^{N}{\\eta_i h_i} \\Bigg\\}\\\\\n\\text{such that} \\quad &\\alpha \\ge 0, \\quad \\boldsymbol{\\nu}, \\boldsymbol{\\eta} \\ge \\mathbf{0}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex39.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle D(\\alpha,\\boldsymbol{\\nu},\\boldsymbol{\\eta})=\\max_{h_{i}}\\Bigg{%&#10;\\{}\\sum_{i=1}^{N}{U_{i}(h_{i})}\" display=\"inline\"><mrow><mi>D</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo>,</mo><mi>\ud835\udf42</mi><mo>,</mo><mi>\ud835\udf3c</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mrow><mo maxsize=\"260%\" minsize=\"260%\">{</mo><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>U</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\qquad\\qquad\\qquad-\\alpha\\left[\\sum_{i=1}^{N}{h_{i}}-B\\right]\" display=\"inline\"><mrow><mi>\u2003\u2003</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2003\u2003</mo><mrow><mo>-</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo>[</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo>]</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex41.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\qquad\\qquad\\qquad-\\sum_{i=1}^{N}{\\nu_{i}(h_{i}-1)}+\\sum_{i=1}^{N%&#10;}{\\eta_{i}h_{i}}\\Bigg{\\}}\" display=\"inline\"><mrow><mi>\u2003\u2003</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2003\u2003</mo><mo>-</mo><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>\u03bd</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo>-</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>\u03b7</mi><mi>i</mi></msub><msub><mi>h</mi><mi>i</mi></msub><mo maxsize=\"260%\" minsize=\"260%\">}</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex42.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\alpha\\geq 0,\\quad\\boldsymbol{\\nu},\\boldsymbol{\\eta}\\geq\\mathbf{0}.\" display=\"inline\"><mrow><mrow><mrow><mi>\u03b1</mi><mo>\u2265</mo><mrow><mn>0</mn><mo rspace=\"12.5pt\">,</mo><mi>\ud835\udf42</mi></mrow></mrow><mo>,</mo><mrow><mi>\ud835\udf3c</mi><mo>\u2265</mo><mn/></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand the dual problem can be written as\n", "itemtype": "equation", "pos": 29177, "prevtext": "\nUsing timer based caching techniques for controlling the hit probabilities with $0 < t_i < \\infty$ ensures that $0 < h_i < 1$, and hence we have $\\nu_i = 0$ and $\\eta_i = 0$. \n\nHere, we consider an algorithm based on the dual solution to the utility maximization problem~\\eqref{eq:opt}. Recall that we can write the Lagrange dual of the utility maximization problem as\n", "index": 91, "text": "\n\\[D(\\alpha) = \\max_{h_i}{\\left\\{ \\sum_{i=1}^{N}{U_i(h_i)}-\\alpha\\left[ \\sum_{i=1}^{N}{h_i} - B\\right] \\right\\}},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m1\" class=\"ltx_Math\" alttext=\"D(\\alpha)=\\max_{h_{i}}{\\left\\{\\sum_{i=1}^{N}{U_{i}(h_{i})}-\\alpha\\left[\\sum_{i%&#10;=1}^{N}{h_{i}}-B\\right]\\right\\}},\" display=\"block\"><mrow><mrow><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mi>max</mi><msub><mi>h</mi><mi>i</mi></msub></munder><mo>\u2061</mo><mrow><mo>{</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo>[</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo>]</mo></mrow></mrow></mrow><mo>}</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nA natural decentralized approach to consider for minimizing $D(\\alpha)$ is to gradually move the decision variables towards the optimal point using the gradient descent algorithm.\nThe gradient can be easily computed as\n", "itemtype": "equation", "pos": 29331, "prevtext": "\nand the dual problem can be written as\n", "index": 93, "text": "\n\\[\\min_{\\alpha \\ge 0}{D(\\alpha)}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex44.m1\" class=\"ltx_Math\" alttext=\"\\min_{\\alpha\\geq 0}{D(\\alpha)}.\" display=\"block\"><mrow><mrow><mrow><munder><mi>min</mi><mrow><mi>\u03b1</mi><mo>\u2265</mo><mn>0</mn></mrow></munder><mo>\u2061</mo><mi>D</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand since we are doing a gradient \\emph{descent}, $\\alpha$ should be updated according to the \\emph{negative} of the gradient as\n", "itemtype": "equation", "pos": 29587, "prevtext": "\n\nA natural decentralized approach to consider for minimizing $D(\\alpha)$ is to gradually move the decision variables towards the optimal point using the gradient descent algorithm.\nThe gradient can be easily computed as\n", "index": 95, "text": "\n\\[\\frac{\\partial D(\\alpha)}{\\partial\\alpha} = -\\Big(\\sum_{i}{h_i} - B \\Big),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex45.m1\" class=\"ltx_Math\" alttext=\"\\frac{\\partial D(\\alpha)}{\\partial\\alpha}=-\\Big{(}\\sum_{i}{h_{i}}-B\\Big{)},\" display=\"block\"><mrow><mrow><mfrac><mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>D</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03b1</mi></mrow></mfrac><mo>=</mo><mrow><mo>-</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $\\gamma > 0$ controls the step size at each iteration. Note that the KTT conditions require that $\\alpha \\ge 0$.\n\nBased on the discussion in Section~\\ref{sec:opt}, to satisfy the optimality condition we must have\n", "itemtype": "equation", "pos": 29795, "prevtext": "\nand since we are doing a gradient \\emph{descent}, $\\alpha$ should be updated according to the \\emph{negative} of the gradient as\n", "index": 97, "text": "\n\\[\\alpha \\gets \\max{\\Big\\{0, \\alpha + \\gamma \\Big( \\sum_{i}{h_i} - B \\Big)\\Big\\}},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex46.m1\" class=\"ltx_Math\" alttext=\"\\alpha\\leftarrow\\max{\\Big{\\{}0,\\alpha+\\gamma\\Big{(}\\sum_{i}{h_{i}}-B\\Big{)}%&#10;\\Big{\\}}},\" display=\"block\"><mrow><mrow><mi>\u03b1</mi><mo>\u2190</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">{</mo><mn>0</mn><mo>,</mo><mrow><mi>\u03b1</mi><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">}</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nor equivalently\n\n", "itemtype": "equation", "pos": 13585, "prevtext": "\n\nLet $U'_i(\\cdot)$ denote the derivative of the the utility function $U_i(\\cdot)$, and define ${U'_i}^{-1}(\\cdot)$ as its inverse function.\nFrom~\\eqref{eq:drv} we get\n", "index": 11, "text": "\n\\[U'_i(h_i) = \\alpha,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex47.m1\" class=\"ltx_Math\" alttext=\"U^{\\prime}_{i}(h_{i})=\\alpha,\" display=\"block\"><mrow><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\u03b1</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nThe hit probabilities are then controlled based on the timer parameters $t_i$ which can be set according to~\\eqref{eq:non_reset_t} and~\\eqref{eq:reset_t} for non-reset and reset TTL caches.\n\nConsidering the hit probabilities as indicators of files residing in the cache, the expression $\\sum_{i}{h_i}$ can be interpreted as the number of items currently in the cache, denoted here as $B_{curr}$. We can thus summarize the control algorithm for a reset TTL algorithm as\n\n", "itemtype": "equation", "pos": 30139, "prevtext": "\nor equivalently\n", "index": 101, "text": "\n\\[h_i = {U'_i}^{-1}(\\alpha).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex48.m1\" class=\"ltx_Math\" alttext=\"h_{i}={U^{\\prime}_{i}}^{-1}(\\alpha).\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nWe obtain an algorithm for a non-reset TTL cache by using the correct expression for $t_i$ in~\\eqref{eq:non_reset_t}.\n\nLet $\\alpha^*$ denote the optimal value for $\\alpha$. We show in Appendix~\\ref{appn:dual} that $D(\\alpha) - D(\\alpha^*)$ is a Lyapunov function and the above algorithm converges to the optimal solution.\n\n\\subsection{Primal Solution}\nWe now consider an algorithm based on the optimization problem in~\\eqref{eq:opt_soft} known as the \\emph{primal} formulation.\n\nLet $W(\\mathbf{h})$ denote the objective function in~\\eqref{eq:opt_soft} defined as\n", "itemtype": "equation", "pos": 30640, "prevtext": "\nThe hit probabilities are then controlled based on the timer parameters $t_i$ which can be set according to~\\eqref{eq:non_reset_t} and~\\eqref{eq:reset_t} for non-reset and reset TTL caches.\n\nConsidering the hit probabilities as indicators of files residing in the cache, the expression $\\sum_{i}{h_i}$ can be interpreted as the number of items currently in the cache, denoted here as $B_{curr}$. We can thus summarize the control algorithm for a reset TTL algorithm as\n\n", "index": 103, "text": "\\begin{align}\n\\label{eq:dual_sol}\nt_i &= -\\frac{1}{\\lambda_i} \\log{\\Big(1 - {U'_i}^{-1}(\\alpha) \\Big)}, \\notag\\\\\n\\alpha &\\gets \\max{\\{0, \\alpha + \\gamma ( B_{curr} - B )\\}}.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex49.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle t_{i}\" display=\"inline\"><msub><mi>t</mi><mi>i</mi></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex49.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-\\frac{1}{\\lambda_{i}}\\log{\\Big{(}1-{U^{\\prime}_{i}}^{-1}(\\alpha%&#10;)\\Big{)}},\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac></mstyle><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mmultiscripts><mi>U</mi><mi>i</mi><mo>\u2032</mo><none/><mrow><mo>-</mo><mn>1</mn></mrow></mmultiscripts><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\alpha\" display=\"inline\"><mi>\u03b1</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leftarrow\\max{\\{0,\\alpha+\\gamma(B_{curr}-B)\\}}.\" display=\"inline\"><mrow><mrow><mi/><mo>\u2190</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mrow><mi>\u03b1</mi><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mrow><mi>c</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>r</mi></mrow></msub><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\n\n\nA natural approach to obtain the maximum value for $W(\\mathbf{h})$ is to use the gradient ascent algorithm.\nThe basic idea behind the gradient ascent algorithm is to move the variables $h_i$ in the direction of the gradient\n", "itemtype": "equation", "pos": 31388, "prevtext": "\nWe obtain an algorithm for a non-reset TTL cache by using the correct expression for $t_i$ in~\\eqref{eq:non_reset_t}.\n\nLet $\\alpha^*$ denote the optimal value for $\\alpha$. We show in Appendix~\\ref{appn:dual} that $D(\\alpha) - D(\\alpha^*)$ is a Lyapunov function and the above algorithm converges to the optimal solution.\n\n\\subsection{Primal Solution}\nWe now consider an algorithm based on the optimization problem in~\\eqref{eq:opt_soft} known as the \\emph{primal} formulation.\n\nLet $W(\\mathbf{h})$ denote the objective function in~\\eqref{eq:opt_soft} defined as\n", "index": 105, "text": "\n\\[W(\\mathbf{h}) = \\sum_{i=1}^{N}{U_i(h_i)} - C(\\sum_{i=1}^{N}{h_i} - B).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex50.m1\" class=\"ltx_Math\" alttext=\"W(\\mathbf{h})=\\sum_{i=1}^{N}{U_{i}(h_{i})}-C(\\sum_{i=1}^{N}{h_{i}}-B).\" display=\"block\"><mrow><mrow><mrow><mi>W</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>C</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nSince the hit probabilities are controlled by the TTL timers, we move $h_i$ towards the optimal point by updating timers $t_i$.\nLet $\\dot{h_i}$ denote the derivative of the hit probability $h_i$ with respect to time. Similarly, define $\\dot{t_i}$ as the derivative of the timer parameter $t_i$\nwith respect to time. We have\n", "itemtype": "equation", "pos": 31690, "prevtext": "\n\n\n\nA natural approach to obtain the maximum value for $W(\\mathbf{h})$ is to use the gradient ascent algorithm.\nThe basic idea behind the gradient ascent algorithm is to move the variables $h_i$ in the direction of the gradient\n", "index": 107, "text": "\n\\[\\frac{\\partial W(\\mathbf{h})}{\\partial h_i} = U'_i(h_i) - C'(\\sum_{i=1}^{N}{h_i} - B).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex51.m1\" class=\"ltx_Math\" alttext=\"\\frac{\\partial W(\\mathbf{h})}{\\partial h_{i}}=U^{\\prime}_{i}(h_{i})-C^{\\prime}%&#10;(\\sum_{i=1}^{N}{h_{i}}-B).\" display=\"block\"><mrow><mrow><mfrac><mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>W</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nFrom~\\eqref{eq:hit_non_reset} and~\\eqref{eq:hit_reset}, it is easy to confirm that $\\partial h_i/\\partial t_i > 0$ for non-reset and reset TTL caches.\nTherefore, moving $t_i$ in the direction of the gradient, also moves $h_i$s in that direction.\n\nBy gradient ascent, the timer parameters should be updated according to\n", "itemtype": "equation", "pos": 32105, "prevtext": "\nSince the hit probabilities are controlled by the TTL timers, we move $h_i$ towards the optimal point by updating timers $t_i$.\nLet $\\dot{h_i}$ denote the derivative of the hit probability $h_i$ with respect to time. Similarly, define $\\dot{t_i}$ as the derivative of the timer parameter $t_i$\nwith respect to time. We have\n", "index": 109, "text": "\n\\[\\dot{h_i} = \\frac{\\partial h_i}{\\partial t_i}\\dot{t_i}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex52.m1\" class=\"ltx_Math\" alttext=\"\\dot{h_{i}}=\\frac{\\partial h_{i}}{\\partial t_{i}}\\dot{t_{i}}.\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo>\u2062</mo><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $k_i > 0$ is the step-size parameter, and $\\sum_{i=1}^{N}{h_i}$ has been replaced with $B_{curr}$ based on the same argument as in the dual solution.\n\nLet $\\mathbf{h}^*$ denote the optimal solution to~\\eqref{eq:opt_soft}. We show in Appendix~\\ref{appn:primal} that $W(\\mathbf{h}^*) - W(\\mathbf{h})$ is a Lyapunov function, and the above algorithm converges to the optimal solution.\n\n\\subsection{Primal-Dual Solution}\nHere, we consider a third algorithm that combines elements of the previous two algorithms.\nConsider the control algorithm\n\n", "itemtype": "equation", "pos": 32484, "prevtext": "\nFrom~\\eqref{eq:hit_non_reset} and~\\eqref{eq:hit_reset}, it is easy to confirm that $\\partial h_i/\\partial t_i > 0$ for non-reset and reset TTL caches.\nTherefore, moving $t_i$ in the direction of the gradient, also moves $h_i$s in that direction.\n\nBy gradient ascent, the timer parameters should be updated according to\n", "index": 111, "text": "\n\\[t_i \\gets \\max{\\left\\{0, t_i + k_i\\Big[ U'_i(h_i) - C'(B_{curr} - B)  \\Big]\\right\\}},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex53.m1\" class=\"ltx_Math\" alttext=\"t_{i}\\leftarrow\\max{\\left\\{0,t_{i}+k_{i}\\Big{[}U^{\\prime}_{i}(h_{i})-C^{\\prime%&#10;}(B_{curr}-B)\\Big{]}\\right\\}},\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>\u2190</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo>{</mo><mn>0</mn><mo>,</mo><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">[</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mrow><mi>c</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>r</mi></mrow></msub><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">]</mo></mrow></mrow></mrow><mo>}</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nUsing Lyapunov techniques we show in Appendix~\\ref{appn:primal_dual} that the above algorithm converges to the optimal solution.\n\nNow, rather than updating the timer parameters according to the above rule explicitly based on the utility function, we can have update rules based on a cache hit or miss.\nConsider the following differential equation\n\n", "itemtype": "equation", "pos": 33120, "prevtext": "\nwhere $k_i > 0$ is the step-size parameter, and $\\sum_{i=1}^{N}{h_i}$ has been replaced with $B_{curr}$ based on the same argument as in the dual solution.\n\nLet $\\mathbf{h}^*$ denote the optimal solution to~\\eqref{eq:opt_soft}. We show in Appendix~\\ref{appn:primal} that $W(\\mathbf{h}^*) - W(\\mathbf{h})$ is a Lyapunov function, and the above algorithm converges to the optimal solution.\n\n\\subsection{Primal-Dual Solution}\nHere, we consider a third algorithm that combines elements of the previous two algorithms.\nConsider the control algorithm\n\n", "index": 113, "text": "\\begin{align*}\nt_i &\\gets \\max{\\{0,  t_i + k_i [ U'_i(h_i) - \\alpha]\\}}, \\\\\n\\alpha &\\gets \\max{\\{0, \\alpha + \\gamma (B_{current} - B)\\}}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex54.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle t_{i}\" display=\"inline\"><msub><mi>t</mi><mi>i</mi></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex54.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leftarrow\\max{\\{0,t_{i}+k_{i}[U^{\\prime}_{i}(h_{i})-\\alpha]\\}},\" display=\"inline\"><mrow><mrow><mi/><mo>\u2190</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\u03b1</mi></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex55.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\alpha\" display=\"inline\"><mi>\u03b1</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex55.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leftarrow\\max{\\{0,\\alpha+\\gamma(B_{current}-B)\\}}.\" display=\"inline\"><mrow><mrow><mi/><mo>\u2190</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mrow><mi>\u03b1</mi><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>B</mi><mrow><mi>c</mi><mo>\u2062</mo><mi>u</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>t</mi></mrow></msub><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $\\delta_m(t_i, \\alpha)$ and $-\\delta_h(t_i, \\alpha)$ denote the change in $t_i$ upon a cache miss or hit for file $i$, respectively.\nMore specifically, the timer for file $i$ is increased by $\\delta_m(t_i, \\alpha)$ upon a cache miss, and decreased by $\\delta_h(t_i, \\alpha)$ on a cache hit.\n\nThe equilibrium for~\\eqref{eq:t} happens when $\\dot{t_i} = 0$, which solving for $h_i$ yields\n", "itemtype": "equation", "pos": 33619, "prevtext": "\n\nUsing Lyapunov techniques we show in Appendix~\\ref{appn:primal_dual} that the above algorithm converges to the optimal solution.\n\nNow, rather than updating the timer parameters according to the above rule explicitly based on the utility function, we can have update rules based on a cache hit or miss.\nConsider the following differential equation\n\n", "index": 115, "text": "\\begin{equation}\n\\label{eq:t}\n\\dot{t_i} = \\delta_m(t_i, \\alpha)(1 - h_i)\\lambda_i - \\delta_h(t_i, \\alpha)h_i\\lambda_i,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\dot{t_{i}}=\\delta_{m}(t_{i},\\alpha)(1-h_{i})\\lambda_{i}-\\delta_{h}(t_{i},%&#10;\\alpha)h_{i}\\lambda_{i},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow><mo>-</mo><mrow><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>h</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nComparing the above expression with $h_i = {U'_i}^{-1}(\\alpha)$ suggests that\n$\\delta_m(t_i, \\alpha)$ and $\\delta_h(t_i, \\alpha)$ can be set to achieve desired hit probabilities and caching policies.\n\nMoreover, the differential equation~\\eqref{eq:t} can be reorganized as\n", "itemtype": "equation", "pos": 34144, "prevtext": "\nwhere $\\delta_m(t_i, \\alpha)$ and $-\\delta_h(t_i, \\alpha)$ denote the change in $t_i$ upon a cache miss or hit for file $i$, respectively.\nMore specifically, the timer for file $i$ is increased by $\\delta_m(t_i, \\alpha)$ upon a cache miss, and decreased by $\\delta_h(t_i, \\alpha)$ on a cache hit.\n\nThe equilibrium for~\\eqref{eq:t} happens when $\\dot{t_i} = 0$, which solving for $h_i$ yields\n", "index": 117, "text": "\n\\[h_i = \\frac{\\delta_m(t_i, \\alpha)}{\\delta_m(t_i, \\alpha) + \\delta_h(t_i, \\alpha)}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex56.m1\" class=\"ltx_Math\" alttext=\"h_{i}=\\frac{\\delta_{m}(t_{i},\\alpha)}{\\delta_{m}(t_{i},\\alpha)+\\delta_{h}(t_{i%&#10;},\\alpha)}.\" display=\"block\"><mrow><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand to move $t_i$ in the direction of the gradient $U'_i(h_i) - \\alpha$ a natural choice for the update functions can be\n", "itemtype": "equation", "pos": 34503, "prevtext": "\nComparing the above expression with $h_i = {U'_i}^{-1}(\\alpha)$ suggests that\n$\\delta_m(t_i, \\alpha)$ and $\\delta_h(t_i, \\alpha)$ can be set to achieve desired hit probabilities and caching policies.\n\nMoreover, the differential equation~\\eqref{eq:t} can be reorganized as\n", "index": 119, "text": "\n\\[\\dot{t_i} = h_i \\lambda_i \\Big(\\delta_m(t_i, \\alpha)/h_i - [\\delta_m(t_i, \\alpha) + \\delta_h(t_i, \\alpha)]\\Big),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex57.m1\" class=\"ltx_Math\" alttext=\"\\dot{t_{i}}=h_{i}\\lambda_{i}\\Big{(}\\delta_{m}(t_{i},\\alpha)/h_{i}-[\\delta_{m}(%&#10;t_{i},\\alpha)+\\delta_{h}(t_{i},\\alpha)]\\Big{)},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>/</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nTo implement proportional fairness for example, these functions can be set as\n\n", "itemtype": "equation", "pos": 34741, "prevtext": "\nand to move $t_i$ in the direction of the gradient $U'_i(h_i) - \\alpha$ a natural choice for the update functions can be\n", "index": 121, "text": "\n\\[\\delta_m(t_i, \\alpha) = h_i U'_i(h_i), \\text{ and } \\delta_m(t_i, \\alpha) + \\delta_h(t_i, \\alpha) = \\alpha.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex58.m1\" class=\"ltx_Math\" alttext=\"\\delta_{m}(t_{i},\\alpha)=h_{i}U^{\\prime}_{i}(h_{i}),\\text{ and }\\delta_{m}(t_{%&#10;i},\\alpha)+\\delta_{h}(t_{i},\\alpha)=\\alpha.\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>\u2062</mo><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mrow><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>\u03b1</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nFor the case of max-min fairness, recall from the discussion in Section~\\ref{sec:opt_identical} that a utility function that is content agnostic, {\\emph{i.e.}}\\ $U_i(h) = U(h)$, results in a max-min fair resource allocation. Without loss of generality we can have $U_i(h_i) = \\log{h_i}$. Thus, max-min fairness can be implemented by having\n", "itemtype": "equation", "pos": 34933, "prevtext": "\n\nTo implement proportional fairness for example, these functions can be set as\n\n", "index": 123, "text": "\\begin{equation}\n\\label{eq:prop_pd}\n\\delta_m(t_i, \\alpha) = \\lambda_i, \\text{ and } \\delta_h(t_i, \\alpha) = \\alpha - \\lambda_i.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\delta_{m}(t_{i},\\alpha)=\\lambda_{i},\\text{ and }\\delta_{h}(t_{i},\\alpha)=%&#10;\\alpha-\\lambda_{i}.\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow><mo>,</mo><mrow><mrow><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\u03b1</mi><mo>-</mo><msub><mi>\u03bb</mi><mi>i</mi></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nNote that with these functions, max-min fairness can be implemented without requiring knowledge about request arrival rates~$\\lambda_i$, while the previous approaches require such knowledge.\n\n\n\n\n\\subsection{Estimation of $\\lambda_i$}\n\\label{sec:estimate}\nComputing the timer parameter $t_i$ in the algorithms discussed in this section requires knowing the request arrival rates for most of the policies.\nEstimation techniques can be used to approximate the request rates in case such knowledge is not available at the (cache) service provider.\n\nLet $r_i$ denote the remaining TTL time for file $i$. Note that $r_i$ can be computed based on $t_i$ and a time-stamp for the last time file~$i$ was requested.\nLet $X_i$ denote the random variable corresponding to the inter-arrival times for the requests for file~$i$, and $\\bar{X_i}$ be its mean.\nWe can approximate the mean inter-arrival time as $\\hat{\\bar{X_i}} = t_i - r_i$. Note that $\\hat{\\bar{X_i}}$ defined in this way is a one-sample\nunbiased estimator of $\\bar{X_i}$. Therefore, $\\hat{\\bar{X_i}}$ is an unbiased estimator of $1/\\lambda_i$. In the simulation section, we will use this estimator in computing the timer parameters for evaluating our algorithms.\n\n\n\n\\begin{figure*}[t]\n\\centering\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{lru_dual_hit.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{fifo_dual_hit.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{prop_dual_hit_est.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{max_min_dual_hit_est.eps}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Hit probabilities from implementing the online dual algorithm using utility functions for LRU, FIFO, proportionally fair and max-min fair policies.}\n    \\centering\\label{fig:dual}\n\\end{figure*}\n\n\\section{Simulations}\n\\label{sec:simulation}\nIn this section, we evaluate the efficiency of the online algorithms developed in this paper.\nDue to space restrictions, we limit our study to four caching policies: FIFO, LRU, proportionally fair, and max-min fair.\n\nPer our discussion in Section~\\ref{sec:reverse}, non-reset and reset TTL caches can be used with $t_i = T, i=1,\\ldots,N$ to implement caches with the same statistical properties as FIFO and LRU caches.\nHowever, previous approaches require precomputing the cache characteristic time $T$.\nBy using the online dual algorithm developed in Section~\\ref{sec:dual} we are able to implement these policies with no a priori information of $T$.\nWe do so by implementing non-reset and reset TTL caches, with the timer parameters for all files\nset as $t_i = 1/\\alpha$, where $\\alpha$ denotes the dual variable and is updated according to~\\eqref{eq:dual_sol}.\n\nFor the proportionally fair policy, timer parameters are set to\n", "itemtype": "equation", "pos": 35416, "prevtext": "\n\nFor the case of max-min fairness, recall from the discussion in Section~\\ref{sec:opt_identical} that a utility function that is content agnostic, {\\emph{i.e.}}\\ $U_i(h) = U(h)$, results in a max-min fair resource allocation. Without loss of generality we can have $U_i(h_i) = \\log{h_i}$. Thus, max-min fairness can be implemented by having\n", "index": 125, "text": "\n\\[\\delta_m(t_i, \\alpha) = 1, \\text{ and } \\delta_h(t_i, \\alpha) = \\alpha - 1.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex59.m1\" class=\"ltx_Math\" alttext=\"\\delta_{m}(t_{i},\\alpha)=1,\\text{ and }\\delta_{h}(t_{i},\\alpha)=\\alpha-1.\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>\u03b4</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mo>,</mo><mrow><mrow><mtext>\u00a0and\u00a0</mtext><mo>\u2062</mo><msub><mi>\u03b4</mi><mi>h</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\u03b1</mi><mo>-</mo><mn>1</mn></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand for the max-min fair policy we set the timers as\n", "itemtype": "equation", "pos": 38413, "prevtext": "\nNote that with these functions, max-min fairness can be implemented without requiring knowledge about request arrival rates~$\\lambda_i$, while the previous approaches require such knowledge.\n\n\n\n\n\\subsection{Estimation of $\\lambda_i$}\n\\label{sec:estimate}\nComputing the timer parameter $t_i$ in the algorithms discussed in this section requires knowing the request arrival rates for most of the policies.\nEstimation techniques can be used to approximate the request rates in case such knowledge is not available at the (cache) service provider.\n\nLet $r_i$ denote the remaining TTL time for file $i$. Note that $r_i$ can be computed based on $t_i$ and a time-stamp for the last time file~$i$ was requested.\nLet $X_i$ denote the random variable corresponding to the inter-arrival times for the requests for file~$i$, and $\\bar{X_i}$ be its mean.\nWe can approximate the mean inter-arrival time as $\\hat{\\bar{X_i}} = t_i - r_i$. Note that $\\hat{\\bar{X_i}}$ defined in this way is a one-sample\nunbiased estimator of $\\bar{X_i}$. Therefore, $\\hat{\\bar{X_i}}$ is an unbiased estimator of $1/\\lambda_i$. In the simulation section, we will use this estimator in computing the timer parameters for evaluating our algorithms.\n\n\n\n\\begin{figure*}[t]\n\\centering\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{lru_dual_hit.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{fifo_dual_hit.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{prop_dual_hit_est.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.25\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{max_min_dual_hit_est.eps}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Hit probabilities from implementing the online dual algorithm using utility functions for LRU, FIFO, proportionally fair and max-min fair policies.}\n    \\centering\\label{fig:dual}\n\\end{figure*}\n\n\\section{Simulations}\n\\label{sec:simulation}\nIn this section, we evaluate the efficiency of the online algorithms developed in this paper.\nDue to space restrictions, we limit our study to four caching policies: FIFO, LRU, proportionally fair, and max-min fair.\n\nPer our discussion in Section~\\ref{sec:reverse}, non-reset and reset TTL caches can be used with $t_i = T, i=1,\\ldots,N$ to implement caches with the same statistical properties as FIFO and LRU caches.\nHowever, previous approaches require precomputing the cache characteristic time $T$.\nBy using the online dual algorithm developed in Section~\\ref{sec:dual} we are able to implement these policies with no a priori information of $T$.\nWe do so by implementing non-reset and reset TTL caches, with the timer parameters for all files\nset as $t_i = 1/\\alpha$, where $\\alpha$ denotes the dual variable and is updated according to~\\eqref{eq:dual_sol}.\n\nFor the proportionally fair policy, timer parameters are set to\n", "index": 127, "text": "\n\\[t_i = \\frac{-1}{\\lambda_i}\\log{(1 - \\frac{\\lambda_i}{\\alpha})},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex60.m1\" class=\"ltx_Math\" alttext=\"t_{i}=\\frac{-1}{\\lambda_{i}}\\log{(1-\\frac{\\lambda_{i}}{\\alpha})},\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mfrac><mrow><mo>-</mo><mn>1</mn></mrow><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><msub><mi>\u03bb</mi><mi>i</mi></msub><mi>\u03b1</mi></mfrac></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nWe implement the proportionally fair and max-min fair policies as reset TTL caches.\n\n\n\nIn the experiments to follow, we consider a cache with the expected number of files in the cache set to $B=1000$. Requests arrive for ${N = 10^4}$ files according to a Poisson process with aggregate rate one. File popularities follow a Zipf distribution with parameter ${s=0.8}$,~{\\emph{i.e.}}~${\\lambda_i = 1/i^s}$. In computing the timer parameters we use estimated values for the file request rates as explained in Section~\\ref{sec:estimate}.\n\nFigure~\\ref{fig:dual} compares the hit probabilities achieved by our online dual algorithm with those computed numerically for the four policies explained above.\nIt is clear that the online algorithms yield the exact hit probabilities for the FIFO, LRU and max-min fair policies. For the proportionally fair policy however, the\nsimulated hit probabilities do not exactly match numerically computed values. This is due to an error in estimating $\\lambda_i, i=1,\\ldots, N$. Note that we use a simple estimator\nhere that is unbiased for $1/\\lambda_i$ but biased for $\\lambda_i$. It is clear from the above equations that computing timer parameters for the max-min fair policy\nonly require estimates of $1/\\lambda_i$ and hence the results are good. Proportionally fair policy on the other hand requires estimating $\\lambda_i$ as well,\nhence using a biased estimate of $\\lambda_i$ introduces some error.\n\nTo confirm the above reasoning, we also simulate the proportionally fair policy assuming perfect knowledge of the request rates.\nFigure~\\ref{fig:prop_exact} shows that in this case simulation results exactly match the numerical values.\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.50\\linewidth}\n  \t\\centering\\includegraphics[scale=0.20]{prop_dual_hit.eps}\n  \t\\caption{\\label{fig:prop_exact}}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.50\\linewidth}\n  \t\\centering\\includegraphics[scale=0.20]{prop_pd_hit_est.eps}\n  \t\\caption{\\label{fig:prop_pd}}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Proportionally fair policy implemented using the (a) dual algorithm with exact knowledge of $\\lambda_i$s, and (b) primal-dual algorithm with ${\\delta_m(t_i, \\alpha) = \\lambda_i}$ and ${\\delta_h(t_i, \\alpha) = \\alpha - \\lambda_i}$, with approximate $\\lambda_i$ values.}\n  \\label{fig:prop_fair}\n\\end{figure}\n\nWe can also use the primal-dual algorithm to implement the proportionally fair policy.\nHere, we implement this policy using the update rules in~\\eqref{eq:prop_pd}, and estimated values for the request rates.\nFigure~\\ref{fig:prop_pd} shows that, unlike the dual approach, the simulation results match the numerical values.\nThis example demonstrates how one algorithm may be more desirable than others in implementing a specific policy.\n\nThe algorithms explained in Section~\\ref{sec:online} are proven to be globally and asymptotically stable, and converge to the optimal solution.\nFigure~\\ref{fig:lru_dual_var} shows the convergence of the dual variable for the LRU policy.\nThe red line in this figure shows $1/T=6.8\\times 10^{-4}$ where $T$ is the characteristic time of the LRU cache computed according to the discussion in Section~\\ref{sec:reverse}.\nAlso, Figure~\\ref{fig:lru_cache_size} shows how the number of contents in the cache is centered around the capacity $B$.\nThe probability density and complementary cumulative distribution function (CCDF) for the number of files in cache are shown in Figure~\\ref{fig:cs}.\nThe probability of violating the capacity $B$ by more than $10\\%$ is less than $2.5\\times 10^{-4}$. For larger systems, {\\emph{i.e.}}\\ for large $B$ and $N$, the probability of violating the \ntarget cache capacity becomes infinitesimally small; see the discussion in Section~\\ref{sec:violation}. This is what we also observe in our simulations.\nSimilar behavior in the convergence of the dual variable and cache size is observed in implementing the other policies as well.\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{lru_dual_var.eps}\n  \t\\caption{\\label{fig:lru_dual_var}}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{cs_conv.eps}\n  \t\\caption{\\label{fig:lru_cache_size}}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Convergence and stability of dual algorithm for the utility function representing LRU policy.}\n    \\label{fig:lru_dual}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\includegraphics[scale=0.21]{cs_distr.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\includegraphics[scale=0.21]{cs_ccdf.eps}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Cache size distribution and CCDF from dual algorithm with the utility function representing LRU policy.}\n    \\label{fig:cs}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Discussion}\n\\label{sec:discussion}\nIn this section, we explore the implications of utility-driven caching on monetizing the caching service and discuss some future research directions.\n\n\\subsection{Decomposition}\nThe formulation of the problem in Section~\\ref{sec:opt} assumes that the utility functions $U_i(\\cdot)$ are known to the system. In reality content providers might decide not to share their utility functions with the service provider. To handle this case, we decompose the optimization problem~\\eqref{eq:opt} into two simpler problems.\n\nSuppose that the cache storage is offered as a service and the service provider charges content providers at a constant rate $r$ for storage space. Hence, a content provider needs to pay an amount of $w_i = rh_i$ to receive hit probability $h_i$ for file $i$. The utility maximization problem for the content provider of file $i$ can then be written as\n\n", "itemtype": "equation", "pos": 38534, "prevtext": "\nand for the max-min fair policy we set the timers as\n", "index": 129, "text": "\n\\[t_i = \\frac{-1}{\\lambda_i}\\log{(1 - \\frac{1}{\\alpha})}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex61.m1\" class=\"ltx_Math\" alttext=\"t_{i}=\\frac{-1}{\\lambda_{i}}\\log{(1-\\frac{1}{\\alpha})}.\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><mfrac><mrow><mo>-</mo><mn>1</mn></mrow><msub><mi>\u03bb</mi><mi>i</mi></msub></mfrac><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><mn>1</mn><mi>\u03b1</mi></mfrac></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nNow, assuming that the service provider knows the vector $\\mathbf{w}$, for a proportionally fair resource allocation, the hit probabilities should be\nset according to\n\n", "itemtype": "equation", "pos": 44339, "prevtext": "\nWe implement the proportionally fair and max-min fair policies as reset TTL caches.\n\n\n\nIn the experiments to follow, we consider a cache with the expected number of files in the cache set to $B=1000$. Requests arrive for ${N = 10^4}$ files according to a Poisson process with aggregate rate one. File popularities follow a Zipf distribution with parameter ${s=0.8}$,~{\\emph{i.e.}}~${\\lambda_i = 1/i^s}$. In computing the timer parameters we use estimated values for the file request rates as explained in Section~\\ref{sec:estimate}.\n\nFigure~\\ref{fig:dual} compares the hit probabilities achieved by our online dual algorithm with those computed numerically for the four policies explained above.\nIt is clear that the online algorithms yield the exact hit probabilities for the FIFO, LRU and max-min fair policies. For the proportionally fair policy however, the\nsimulated hit probabilities do not exactly match numerically computed values. This is due to an error in estimating $\\lambda_i, i=1,\\ldots, N$. Note that we use a simple estimator\nhere that is unbiased for $1/\\lambda_i$ but biased for $\\lambda_i$. It is clear from the above equations that computing timer parameters for the max-min fair policy\nonly require estimates of $1/\\lambda_i$ and hence the results are good. Proportionally fair policy on the other hand requires estimating $\\lambda_i$ as well,\nhence using a biased estimate of $\\lambda_i$ introduces some error.\n\nTo confirm the above reasoning, we also simulate the proportionally fair policy assuming perfect knowledge of the request rates.\nFigure~\\ref{fig:prop_exact} shows that in this case simulation results exactly match the numerical values.\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.50\\linewidth}\n  \t\\centering\\includegraphics[scale=0.20]{prop_dual_hit.eps}\n  \t\\caption{\\label{fig:prop_exact}}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.50\\linewidth}\n  \t\\centering\\includegraphics[scale=0.20]{prop_pd_hit_est.eps}\n  \t\\caption{\\label{fig:prop_pd}}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Proportionally fair policy implemented using the (a) dual algorithm with exact knowledge of $\\lambda_i$s, and (b) primal-dual algorithm with ${\\delta_m(t_i, \\alpha) = \\lambda_i}$ and ${\\delta_h(t_i, \\alpha) = \\alpha - \\lambda_i}$, with approximate $\\lambda_i$ values.}\n  \\label{fig:prop_fair}\n\\end{figure}\n\nWe can also use the primal-dual algorithm to implement the proportionally fair policy.\nHere, we implement this policy using the update rules in~\\eqref{eq:prop_pd}, and estimated values for the request rates.\nFigure~\\ref{fig:prop_pd} shows that, unlike the dual approach, the simulation results match the numerical values.\nThis example demonstrates how one algorithm may be more desirable than others in implementing a specific policy.\n\nThe algorithms explained in Section~\\ref{sec:online} are proven to be globally and asymptotically stable, and converge to the optimal solution.\nFigure~\\ref{fig:lru_dual_var} shows the convergence of the dual variable for the LRU policy.\nThe red line in this figure shows $1/T=6.8\\times 10^{-4}$ where $T$ is the characteristic time of the LRU cache computed according to the discussion in Section~\\ref{sec:reverse}.\nAlso, Figure~\\ref{fig:lru_cache_size} shows how the number of contents in the cache is centered around the capacity $B$.\nThe probability density and complementary cumulative distribution function (CCDF) for the number of files in cache are shown in Figure~\\ref{fig:cs}.\nThe probability of violating the capacity $B$ by more than $10\\%$ is less than $2.5\\times 10^{-4}$. For larger systems, {\\emph{i.e.}}\\ for large $B$ and $N$, the probability of violating the \ntarget cache capacity becomes infinitesimally small; see the discussion in Section~\\ref{sec:violation}. This is what we also observe in our simulations.\nSimilar behavior in the convergence of the dual variable and cache size is observed in implementing the other policies as well.\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{lru_dual_var.eps}\n  \t\\caption{\\label{fig:lru_dual_var}}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\centering\\includegraphics[scale=0.21]{cs_conv.eps}\n  \t\\caption{\\label{fig:lru_cache_size}}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Convergence and stability of dual algorithm for the utility function representing LRU policy.}\n    \\label{fig:lru_dual}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\includegraphics[scale=0.21]{cs_distr.eps}\n \\end{subfigure}\n \\begin{subfigure}[b]{0.5\\linewidth}\n  \t\\includegraphics[scale=0.21]{cs_ccdf.eps}\n \\end{subfigure}\n\\vspace{-0.25cm}\n \\caption{Cache size distribution and CCDF from dual algorithm with the utility function representing LRU policy.}\n    \\label{fig:cs}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Discussion}\n\\label{sec:discussion}\nIn this section, we explore the implications of utility-driven caching on monetizing the caching service and discuss some future research directions.\n\n\\subsection{Decomposition}\nThe formulation of the problem in Section~\\ref{sec:opt} assumes that the utility functions $U_i(\\cdot)$ are known to the system. In reality content providers might decide not to share their utility functions with the service provider. To handle this case, we decompose the optimization problem~\\eqref{eq:opt} into two simpler problems.\n\nSuppose that the cache storage is offered as a service and the service provider charges content providers at a constant rate $r$ for storage space. Hence, a content provider needs to pay an amount of $w_i = rh_i$ to receive hit probability $h_i$ for file $i$. The utility maximization problem for the content provider of file $i$ can then be written as\n\n", "index": 131, "text": "\\begin{align}\n\\label{eq:opt_user}\n\\text{maximize} \\quad &U_i(w_i/r) - w_i \\\\\n\\text{such that} \\quad &w_i \\ge 0 \\notag\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle U_{i}(w_{i}/r)-w_{i}\" display=\"inline\"><mrow><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>/</mo><mi>r</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msub><mi>w</mi><mi>i</mi></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex62.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle w_{i}\\geq 0\" display=\"inline\"><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2265</mo><mn>0</mn></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nIt was shown in~\\cite{kelly97} that there always exist vectors $\\mathbf{w}$ and $\\mathbf{h}$, such that $\\mathbf{w}$ solves~\\eqref{eq:opt_user} and $\\mathbf{h}$ solves~\\eqref{eq:opt_network}; further, the vector $\\mathbf{h}$ is the unique solution to~\\eqref{eq:opt}.\n\n\\subsection{Cost and Utility Functions}\nIn Section~\\ref{sec:soft}, we defined a penalty function denoting the cost of using additional storage space. One might also define cost functions based on the consumed network bandwidth. This is especially interesting in modeling in-network caches with network links that are likely to be congested.\n\nOptimization problem~\\eqref{eq:opt} uses utility functions defined as functions of the hit probabilities. It is reasonable to define utility as a function of the hit \\emph{rate}. Whether this makes any changes to the problem, {\\emph{e.g.}}\\ in the notion of fairness, is a question that requires further investigation. One argument in support of utilities as functions of hit rates is that a service provider might prefer pricing based on request rate rather than cache occupancy. Moreover, in designing hierarchical caches a service provider's objective could be to minimize the internal bandwidth cost. This can be achieved by defining the utility functions as $U_i = -C_i(m_i)$ where $C_i(m_i)$ denotes the cost associated with miss rate $m_i$ for file $i$.\n\n\\subsection{Online Algorithms}\nIn Section~\\ref{sec:online}, we developed three online algorithms that can be used to implement utility-driven caching. Although these algorithms are proven to be stable and converge to the optimal solution, they have distinct features that can make one algorithm more effective in implementing a policy. For example, implementing the max-min fair policy based on the dual solution requires knowing/estimating the file request rates, while it can be implemented using the modified primal-dual solution without such knowledge. Moreover, the convergence rate of these algorithms may differ for different policies. The choice of non-reset or reset TTL caches also has implications on the design and performance of these algorithms.\nThese are subjects that require further study.\n\n\\section{Conclusion}\n\\label{sec:conclusion}\nIn this paper, we proposed the concept of utility-driven caching, and formulated it as an optimization problem with rigid and elastic cache storage size constraints. Utility-driven caching provides a general framework for defining caching policies with considerations of fairness among various groups of files, and implications on market economy for (cache) service providers and content publishers. This framework has the capability to model existing caching policies such as FIFO and LRU, as utility-driven caching policies.\n\nWe developed three decentralized algorithms that implement utility-driven caching policies in an online fashion and that can adapt to changes in file request rates over time. We prove that these algorithms are globally stable and converge to the optimal solution. Through simulations we illustrated the efficiency of these algorithms and the flexibility of our approach.\n\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{references}\n\n\\begin{appendices}\n\n\\section{Stability of Dual Solution}\n\\label{appn:dual}\nWe first note that $D(\\alpha)$ is the dual of a convex function and has a unique minimizer $\\alpha^*$.\nThe function ${V(\\alpha) = D(\\alpha) - D(\\alpha^*)}$, hence, is a non-negative function and equals zero only at $\\alpha = \\alpha^*$.\nDifferentiating $V(\\alpha)$ with respect to time we get\n", "itemtype": "equation", "pos": 44637, "prevtext": "\n\nNow, assuming that the service provider knows the vector $\\mathbf{w}$, for a proportionally fair resource allocation, the hit probabilities should be\nset according to\n\n", "index": 133, "text": "\\begin{align}\n\\label{eq:opt_network}\n\\text{maximize} \\quad &\\sum_{i=1}^{N}{w_i\\log{(h_i)}} \\\\\n\\text{such that} \\quad &\\sum_{i=1}^{N}{h_i} = B \\notag\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{N}{w_{i}\\log{(h_{i})}}\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex63.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{N}{h_{i}}=B\" display=\"inline\"><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>=</mo><mi>B</mi></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nTherefore, $V(\\cdot)$ is a Lyapunov function, and the system state will converge to optimum starting from any initial condition.\n\n\\section{Stability of Primal Solution}\n\\label{appn:primal}\nWe first note that since $W({\\mathbf{h}})$ is a strictly concave function, it has a unique maximizer ${\\mathbf{h}}^*$.\nMoreover ${V({\\mathbf{h}}) = W({\\mathbf{h}}^*) - W({\\mathbf{h}})}$ is a non-negative function and equals zero only at ${\\mathbf{h}} = {\\mathbf{h}}^*$.\nDifferentiating $V(\\cdot)$ with respect to time we obtain\n\n", "itemtype": "equation", "pos": 48346, "prevtext": "\n\nIt was shown in~\\cite{kelly97} that there always exist vectors $\\mathbf{w}$ and $\\mathbf{h}$, such that $\\mathbf{w}$ solves~\\eqref{eq:opt_user} and $\\mathbf{h}$ solves~\\eqref{eq:opt_network}; further, the vector $\\mathbf{h}$ is the unique solution to~\\eqref{eq:opt}.\n\n\\subsection{Cost and Utility Functions}\nIn Section~\\ref{sec:soft}, we defined a penalty function denoting the cost of using additional storage space. One might also define cost functions based on the consumed network bandwidth. This is especially interesting in modeling in-network caches with network links that are likely to be congested.\n\nOptimization problem~\\eqref{eq:opt} uses utility functions defined as functions of the hit probabilities. It is reasonable to define utility as a function of the hit \\emph{rate}. Whether this makes any changes to the problem, {\\emph{e.g.}}\\ in the notion of fairness, is a question that requires further investigation. One argument in support of utilities as functions of hit rates is that a service provider might prefer pricing based on request rate rather than cache occupancy. Moreover, in designing hierarchical caches a service provider's objective could be to minimize the internal bandwidth cost. This can be achieved by defining the utility functions as $U_i = -C_i(m_i)$ where $C_i(m_i)$ denotes the cost associated with miss rate $m_i$ for file $i$.\n\n\\subsection{Online Algorithms}\nIn Section~\\ref{sec:online}, we developed three online algorithms that can be used to implement utility-driven caching. Although these algorithms are proven to be stable and converge to the optimal solution, they have distinct features that can make one algorithm more effective in implementing a policy. For example, implementing the max-min fair policy based on the dual solution requires knowing/estimating the file request rates, while it can be implemented using the modified primal-dual solution without such knowledge. Moreover, the convergence rate of these algorithms may differ for different policies. The choice of non-reset or reset TTL caches also has implications on the design and performance of these algorithms.\nThese are subjects that require further study.\n\n\\section{Conclusion}\n\\label{sec:conclusion}\nIn this paper, we proposed the concept of utility-driven caching, and formulated it as an optimization problem with rigid and elastic cache storage size constraints. Utility-driven caching provides a general framework for defining caching policies with considerations of fairness among various groups of files, and implications on market economy for (cache) service providers and content publishers. This framework has the capability to model existing caching policies such as FIFO and LRU, as utility-driven caching policies.\n\nWe developed three decentralized algorithms that implement utility-driven caching policies in an online fashion and that can adapt to changes in file request rates over time. We prove that these algorithms are globally stable and converge to the optimal solution. Through simulations we illustrated the efficiency of these algorithms and the flexibility of our approach.\n\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{references}\n\n\\begin{appendices}\n\n\\section{Stability of Dual Solution}\n\\label{appn:dual}\nWe first note that $D(\\alpha)$ is the dual of a convex function and has a unique minimizer $\\alpha^*$.\nThe function ${V(\\alpha) = D(\\alpha) - D(\\alpha^*)}$, hence, is a non-negative function and equals zero only at $\\alpha = \\alpha^*$.\nDifferentiating $V(\\alpha)$ with respect to time we get\n", "index": 135, "text": "\n\\[\\dot{V}(\\alpha) = \\frac{\\partial V}{\\partial \\alpha}\\dot{\\alpha} = -\\gamma \\Big(\\sum_{i}{h_i} - B \\Big)^2 < 0.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex64.m1\" class=\"ltx_Math\" alttext=\"\\dot{V}(\\alpha)=\\frac{\\partial V}{\\partial\\alpha}\\dot{\\alpha}=-\\gamma\\Big{(}%&#10;\\sum_{i}{h_{i}}-B\\Big{)}^{2}&lt;0.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>V</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>V</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03b1</mi></mrow></mfrac><mo>\u2062</mo><mover accent=\"true\"><mi>\u03b1</mi><mo>\u02d9</mo></mover></mrow><mo>=</mo><mrow><mo>-</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mn>2</mn></msup></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nFor $\\dot{h_i}$ we have\n", "itemtype": "equation", "pos": 48980, "prevtext": "\n\nTherefore, $V(\\cdot)$ is a Lyapunov function, and the system state will converge to optimum starting from any initial condition.\n\n\\section{Stability of Primal Solution}\n\\label{appn:primal}\nWe first note that since $W({\\mathbf{h}})$ is a strictly concave function, it has a unique maximizer ${\\mathbf{h}}^*$.\nMoreover ${V({\\mathbf{h}}) = W({\\mathbf{h}}^*) - W({\\mathbf{h}})}$ is a non-negative function and equals zero only at ${\\mathbf{h}} = {\\mathbf{h}}^*$.\nDifferentiating $V(\\cdot)$ with respect to time we obtain\n\n", "index": 137, "text": "\\begin{align*}\n\\dot{V}({\\mathbf{h}}) &= \\sum_{i}{\\frac{\\partial V}{\\partial h_i}\\dot{h_i}} \\\\\n&= -\\sum_{i}{\\left( U'_i(h_i) - C'(\\sum_{i}{h_i} - B) \\right) \\dot{h_i}}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex65.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{V}({\\mathbf{h}})\" display=\"inline\"><mrow><mover accent=\"true\"><mi>V</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex65.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{i}{\\frac{\\partial V}{\\partial h_{i}}\\dot{h_{i}}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>V</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac></mstyle><mo>\u2062</mo><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex66.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-\\sum_{i}{\\left(U^{\\prime}_{i}(h_{i})-C^{\\prime}(\\sum_{i}{h_{i}}%&#10;-B)\\right)\\dot{h_{i}}}.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mrow><mo>(</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>)</mo></mrow><mo>\u2062</mo><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nFrom~\\eqref{eq:hit_non_reset} and~\\eqref{eq:hit_reset}, it is easy to confirm that $\\partial h_i/\\partial t_i > 0$ for non-reset and reset TTL caches.\nTherefore, moving $t_i$ in the direction of the gradient, also moves $h_i$s in that direction.\n\nBy gradient ascent, the timer parameters should be updated according to\n", "itemtype": "equation", "pos": 32105, "prevtext": "\nSince the hit probabilities are controlled by the TTL timers, we move $h_i$ towards the optimal point by updating timers $t_i$.\nLet $\\dot{h_i}$ denote the derivative of the hit probability $h_i$ with respect to time. Similarly, define $\\dot{t_i}$ as the derivative of the timer parameter $t_i$\nwith respect to time. We have\n", "index": 109, "text": "\n\\[\\dot{h_i} = \\frac{\\partial h_i}{\\partial t_i}\\dot{t_i}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex67.m1\" class=\"ltx_Math\" alttext=\"\\dot{h_{i}}=\\frac{\\partial h_{i}}{\\partial t_{i}}\\dot{t_{i}}.\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo>\u2062</mo><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nrespectively, and hence $\\partial h_i / \\partial t_i > 0$.\n\nFrom the controller for $t_i$ we have\n", "itemtype": "equation", "pos": 49288, "prevtext": "\nFor non-reset and reset TTL caches we have\n", "index": 141, "text": "\n\\[\\frac{\\partial h_i}{\\partial t_i} = \\frac{\\lambda_i}{(1+\\lambda_i t_i)^2} \\qquad\\text{ and }\\qquad \\frac{\\partial h_i}{\\partial t_i} = \\lambda_i e^{-\\lambda_i t_i},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex68.m1\" class=\"ltx_Math\" alttext=\"\\frac{\\partial h_{i}}{\\partial t_{i}}=\\frac{\\lambda_{i}}{(1+\\lambda_{i}t_{i})^%&#10;{2}}\\qquad\\text{ and }\\qquad\\frac{\\partial h_{i}}{\\partial t_{i}}=\\lambda_{i}e%&#10;^{-\\lambda_{i}t_{i}},\" display=\"block\"><mrow><mrow><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><mfrac><msub><mi>\u03bb</mi><mi>i</mi></msub><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>+</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mfrac><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003</mo><mtext>\u00a0and\u00a0</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003</mo><mrow><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo>=</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>-</mo><mrow><msub><mi>\u03bb</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mrow></msup></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nHence, we get\n", "itemtype": "equation", "pos": 49555, "prevtext": "\nrespectively, and hence $\\partial h_i / \\partial t_i > 0$.\n\nFrom the controller for $t_i$ we have\n", "index": 143, "text": "\n\\[t_i = k_i \\left( U'_i(h_i) - C'(\\sum_{i}{h_i} - B) \\right).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex69.m1\" class=\"ltx_Math\" alttext=\"t_{i}=k_{i}\\left(U^{\\prime}_{i}(h_{i})-C^{\\prime}(\\sum_{i}{h_{i}}-B)\\right).\" display=\"block\"><mrow><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo>(</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nTherefore, $V(\\cdot)$ is a Lyapunov function\\footnote{A description of Lyapunov functions and their applications can be found in~\\cite{srikant13}.}, and the system state will converge to ${\\mathbf{h}}^*$ starting from any initial condition.\n\n\\section{Stability of Primal-Dual Solution}\n\\label{appn:primal_dual}\nAs discussed in Section~\\ref{sec:opt}, the Lagrangian function for the optimization problem~\\eqref{eq:opt} is expressed as\n", "itemtype": "equation", "pos": 49634, "prevtext": "\n\nHence, we get\n", "index": 145, "text": "\n\\[\\dot{V}({\\mathbf{h}}) = -\\sum_{i}{k_i \\frac{\\partial h_i}{\\partial t_i} \\left( U'_i(h_i) - C'(\\sum_{i}{h_i} - B) \\right)^2} < 0.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex70.m1\" class=\"ltx_Math\" alttext=\"\\dot{V}({\\mathbf{h}})=-\\sum_{i}{k_{i}\\frac{\\partial h_{i}}{\\partial t_{i}}%&#10;\\left(U^{\\prime}_{i}(h_{i})-C^{\\prime}(\\sum_{i}{h_{i}}-B)\\right)^{2}}&lt;0.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>V</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>-</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mo>\u2062</mo><msup><mrow><mo>(</mo><mrow><mrow><msubsup><mi>U</mi><mi>i</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><msup><mi>C</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>)</mo></mrow><mn>2</mn></msup></mrow></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nNote that ${\\mathcal{L}}({\\mathbf{h}}, \\alpha)$ is concave in ${\\mathbf{h}}$ and convex in $\\alpha$, and hence first order condition for optimality of ${\\mathbf{h}}^*$ and $\\alpha^*$ implies\n\n", "itemtype": "equation", "pos": 50202, "prevtext": "\n\nTherefore, $V(\\cdot)$ is a Lyapunov function\\footnote{A description of Lyapunov functions and their applications can be found in~\\cite{srikant13}.}, and the system state will converge to ${\\mathbf{h}}^*$ starting from any initial condition.\n\n\\section{Stability of Primal-Dual Solution}\n\\label{appn:primal_dual}\nAs discussed in Section~\\ref{sec:opt}, the Lagrangian function for the optimization problem~\\eqref{eq:opt} is expressed as\n", "index": 147, "text": "\n\\[{\\mathcal{L}}({\\mathbf{h}}, \\alpha) = \\sum_{i}{U_i(h_i)} - \\alpha(\\sum_{i}{h_i} - B).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex71.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{L}}({\\mathbf{h}},\\alpha)=\\sum_{i}{U_{i}(h_{i})}-\\alpha(\\sum_{i}{h_{i%&#10;}}-B).\" display=\"block\"><mrow><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>\u03b1</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><msub><mi>h</mi><mi>i</mi></msub></mrow><mo>-</mo><mi>B</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\n\nAssume that the hit probability of a file can be expressed by $f(\\cdot)$ as a function of the corresponding timer value $t_i$, {\\emph{i.e.}}\\ ${h_i = f(t_i)}$. The temporal derivative of the hit probability can therefore be expressed as\n", "itemtype": "equation", "pos": 50484, "prevtext": "\nNote that ${\\mathcal{L}}({\\mathbf{h}}, \\alpha)$ is concave in ${\\mathbf{h}}$ and convex in $\\alpha$, and hence first order condition for optimality of ${\\mathbf{h}}^*$ and $\\alpha^*$ implies\n\n", "index": 149, "text": "\\begin{align*}\n{\\mathcal{L}}({\\mathbf{h}}^*, \\alpha) &\\le {\\mathcal{L}}({\\mathbf{h}}, \\alpha) + \\sum_{i}{\\frac{\\partial {\\mathcal{L}}}{\\partial h_i}(h_i^* - h_i)}, \\\\\n{\\mathcal{L}}({\\mathbf{h}}, \\alpha^*) &\\ge {\\mathcal{L}}({\\mathbf{h}}, \\alpha) + \\frac{\\partial {\\mathcal{L}}}{\\partial \\alpha}(\\alpha^* - \\alpha) .\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex72.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathcal{L}}({\\mathbf{h}}^{*},\\alpha)\" display=\"inline\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex72.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq{\\mathcal{L}}({\\mathbf{h}},\\alpha)+\\sum_{i}{\\frac{\\partial{%&#10;\\mathcal{L}}}{\\partial h_{i}}(h_{i}^{*}-h_{i})},\" display=\"inline\"><mrow><mrow><mi/><mo>\u2264</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac></mstyle><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>h</mi><mi>i</mi><mo>*</mo></msubsup><mo>-</mo><msub><mi>h</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex73.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathcal{L}}({\\mathbf{h}},\\alpha^{*})\" display=\"inline\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex73.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\geq{\\mathcal{L}}({\\mathbf{h}},\\alpha)+\\frac{\\partial{\\mathcal{L}%&#10;}}{\\partial\\alpha}(\\alpha^{*}-\\alpha).\" display=\"inline\"><mrow><mrow><mi/><mo>\u2265</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03b1</mi></mrow></mfrac></mstyle><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\u03b1</mi><mo>*</mo></msup><mo>-</mo><mi>\u03b1</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nor equivalently\n", "itemtype": "equation", "pos": 51050, "prevtext": "\n\nAssume that the hit probability of a file can be expressed by $f(\\cdot)$ as a function of the corresponding timer value $t_i$, {\\emph{i.e.}}\\ ${h_i = f(t_i)}$. The temporal derivative of the hit probability can therefore be expressed as\n", "index": 151, "text": "\n\\[\\dot{h_i} = f'(t_i) \\dot{t_i},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex74.m1\" class=\"ltx_Math\" alttext=\"\\dot{h_{i}}=f^{\\prime}(t_{i})\\dot{t_{i}},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><msup><mi>f</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere $f^{-1}(\\cdot)$ denotes the inverse of function $f(\\cdot)$. For notation brevity we define ${g(h_i) = f'(f^{-1}(h_i))}$. Note that as discussed in Appendix~\\ref{appn:primal}, $f(\\cdot)$ is an increasing function, and hence ${g(h_i)\\ge 0}$.\n\nIn the remaining, we show that $V({\\mathbf{h}}, \\alpha)$ defined below is a Lyapunov function for the primal-dual algorithm:\n", "itemtype": "equation", "pos": 51101, "prevtext": "\nor equivalently\n", "index": 153, "text": "\n\\[\\dot{h_i} = f'(f^{-1}(h_i)) \\dot{t_i},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex75.m1\" class=\"ltx_Math\" alttext=\"\\dot{h_{i}}=f^{\\prime}(f^{-1}(h_{i}))\\dot{t_{i}},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><msup><mi>f</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>f</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nDifferentiating the above function with respect to time we obtain\n", "itemtype": "equation", "pos": 51516, "prevtext": "\nwhere $f^{-1}(\\cdot)$ denotes the inverse of function $f(\\cdot)$. For notation brevity we define ${g(h_i) = f'(f^{-1}(h_i))}$. Note that as discussed in Appendix~\\ref{appn:primal}, $f(\\cdot)$ is an increasing function, and hence ${g(h_i)\\ge 0}$.\n\nIn the remaining, we show that $V({\\mathbf{h}}, \\alpha)$ defined below is a Lyapunov function for the primal-dual algorithm:\n", "index": 155, "text": "\n\\[V({\\mathbf{h}}, \\alpha) = \\sum_{i}{\\int_{h_i^*}^{h_i}{\\frac{x - h_i^*}{k_i g(x)}{\\mathrm{d}} x}} + \\frac{1}{2\\gamma}(\\alpha - \\alpha^*)^2.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex76.m1\" class=\"ltx_Math\" alttext=\"V({\\mathbf{h}},\\alpha)=\\sum_{i}{\\int_{h_{i}^{*}}^{h_{i}}{\\frac{x-h_{i}^{*}}{k_%&#10;{i}g(x)}{\\mathrm{d}}x}}+\\frac{1}{2\\gamma}(\\alpha-\\alpha^{*})^{2}.\" display=\"block\"><mrow><mrow><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><msubsup><mi>h</mi><mi>i</mi><mo>*</mo></msubsup><msub><mi>h</mi><mi>i</mi></msub></msubsup><mrow><mfrac><mrow><mi>x</mi><mo>-</mo><msubsup><mi>h</mi><mi>i</mi><mo>*</mo></msubsup></mrow><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac><mo>\u2062</mo><mrow><mo>d</mo><mi>x</mi></mrow></mrow></mrow></mrow><mo>+</mo><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mo>\u2062</mo><mi>\u03b3</mi></mrow></mfrac><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>-</mo><msup><mi>\u03b1</mi><mo>*</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nBased on the controllers defined for $t_i$ and $\\alpha$ we have\n", "itemtype": "equation", "pos": 51725, "prevtext": "\nDifferentiating the above function with respect to time we obtain\n", "index": 157, "text": "\n\\[\\dot{V}({\\mathbf{h}}, \\alpha) = \\sum_{i}{\\frac{h_i - h_i^*}{k_i g(h_i)}\\dot{h_i}} + \\frac{\\alpha - \\alpha^*}{\\gamma}\\dot{\\alpha}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex77.m1\" class=\"ltx_Math\" alttext=\"\\dot{V}({\\mathbf{h}},\\alpha)=\\sum_{i}{\\frac{h_{i}-h_{i}^{*}}{k_{i}g(h_{i})}%&#10;\\dot{h_{i}}}+\\frac{\\alpha-\\alpha^{*}}{\\gamma}\\dot{\\alpha}.\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>V</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mrow><mfrac><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>-</mo><msubsup><mi>h</mi><mi>i</mi><mo>*</mo></msubsup></mrow><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac><mo>\u2062</mo><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow></mrow><mo>+</mo><mrow><mfrac><mrow><mi>\u03b1</mi><mo>-</mo><msup><mi>\u03b1</mi><mo>*</mo></msup></mrow><mi>\u03b3</mi></mfrac><mo>\u2062</mo><mover accent=\"true\"><mi>\u03b1</mi><mo>\u02d9</mo></mover></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nand\n", "itemtype": "equation", "pos": 51923, "prevtext": "\nBased on the controllers defined for $t_i$ and $\\alpha$ we have\n", "index": 159, "text": "\n\\[\\dot{h_i} = g(h_i) \\dot{t_i} = k_i g(h_i) \\frac{\\partial {\\mathcal{L}}}{\\partial h_i},\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex78.m1\" class=\"ltx_Math\" alttext=\"\\dot{h_{i}}=g(h_{i})\\dot{t_{i}}=k_{i}g(h_{i})\\frac{\\partial{\\mathcal{L}}}{%&#10;\\partial h_{i}},\" display=\"block\"><mrow><mrow><mover accent=\"true\"><msub><mi>h</mi><mi>i</mi></msub><mo>\u02d9</mo></mover><mo>=</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mover accent=\"true\"><msub><mi>t</mi><mi>i</mi></msub><mo>\u02d9</mo></mover></mrow><mo>=</mo><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>\u2062</mo><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nReplacing for $\\dot{h_i}$ and $\\dot{\\alpha}$ in $\\dot{V}({\\mathbf{h}}, \\alpha)$, we obtain\n\n", "itemtype": "equation", "pos": 52018, "prevtext": "\nand\n", "index": 161, "text": "\n\\[\\dot{\\alpha} = -\\gamma\\frac{\\partial {\\mathcal{L}}}{\\partial \\alpha}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex79.m1\" class=\"ltx_Math\" alttext=\"\\dot{\\alpha}=-\\gamma\\frac{\\partial{\\mathcal{L}}}{\\partial\\alpha}.\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>\u03b1</mi><mo>\u02d9</mo></mover><mo>=</mo><mrow><mo>-</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03b1</mi></mrow></mfrac></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nwhere the last inequality follows from \n", "itemtype": "equation", "pos": 52184, "prevtext": "\nReplacing for $\\dot{h_i}$ and $\\dot{\\alpha}$ in $\\dot{V}({\\mathbf{h}}, \\alpha)$, we obtain\n\n", "index": 163, "text": "\\begin{align*}\n\\dot{V}({\\mathbf{h}}, \\alpha) &= \\sum_{i}{(h_i - h_i^*)\\frac{\\partial {\\mathcal{L}}}{\\partial h_i}} - (\\alpha - \\alpha^*)\\frac{\\partial {\\mathcal{L}}}{\\partial \\alpha} \\\\\n&\\le {\\mathcal{L}}({\\mathbf{h}}, \\alpha) - {\\mathcal{L}}({\\mathbf{h}}^*, \\alpha) + {\\mathcal{L}}({\\mathbf{h}}, \\alpha^*) - {\\mathcal{L}}({\\mathbf{h}}, \\alpha) \\\\\n&= \\Big({\\mathcal{L}}({\\mathbf{h}}^*, \\alpha^*) - {\\mathcal{L}}({\\mathbf{h}}^*, \\alpha)\\Big) + \\Big({\\mathcal{L}}({\\mathbf{h}}, \\alpha^*) - {\\mathcal{L}}({\\mathbf{h}}^*, \\alpha^*)\\Big) \\\\\n&\\le 0,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex80.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\dot{V}({\\mathbf{h}},\\alpha)\" display=\"inline\"><mrow><mover accent=\"true\"><mi>V</mi><mo>\u02d9</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex80.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{i}{(h_{i}-h_{i}^{*})\\frac{\\partial{\\mathcal{L}}}{\\partial h%&#10;_{i}}}-(\\alpha-\\alpha^{*})\\frac{\\partial{\\mathcal{L}}}{\\partial\\alpha}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>-</mo><msubsup><mi>h</mi><mi>i</mi><mo>*</mo></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><msub><mi>h</mi><mi>i</mi></msub></mrow></mfrac></mstyle></mrow></mrow><mo>-</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\u03b1</mi><mo>-</mo><msup><mi>\u03b1</mi><mo>*</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mo>\u2202</mo><mo>\u2061</mo><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi></mrow><mrow><mo>\u2202</mo><mo>\u2061</mo><mi>\u03b1</mi></mrow></mfrac></mstyle></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex81.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq{\\mathcal{L}}({\\mathbf{h}},\\alpha)-{\\mathcal{L}}({\\mathbf{h}}%&#10;^{*},\\alpha)+{\\mathcal{L}}({\\mathbf{h}},\\alpha^{*})-{\\mathcal{L}}({\\mathbf{h}}%&#10;,\\alpha)\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex82.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\Big{(}{\\mathcal{L}}({\\mathbf{h}}^{*},\\alpha^{*})-{\\mathcal{L}}(%&#10;{\\mathbf{h}}^{*},\\alpha)\\Big{)}+\\Big{(}{\\mathcal{L}}({\\mathbf{h}},\\alpha^{*})-%&#10;{\\mathcal{L}}({\\mathbf{h}}^{*},\\alpha^{*})\\Big{)}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mo>+</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex83.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq 0,\" display=\"inline\"><mrow><mrow><mi/><mo>\u2264</mo><mn>0</mn></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06838.tex", "nexttext": "\nfor any ${\\mathbf{h}}$ and $\\alpha$.\n\nMoreover, $V({\\mathbf{h}}, \\alpha)$ is non-negative and equals zero only at $({\\mathbf{h}}^*, \\alpha^*)$.\nTherefore, $V({\\mathbf{h}}, \\alpha)$ is a Lyapunov function, and the system state will converge to optimum starting from any initial condition.\n\n\\end{appendices}\n\n\n\n", "itemtype": "equation", "pos": 52780, "prevtext": "\nwhere the last inequality follows from \n", "index": 165, "text": "\n\\[{\\mathcal{L}}({\\mathbf{h}}, \\alpha^*)  \\le {\\mathcal{L}}({\\mathbf{h}}^*, \\alpha^*)  \\le {\\mathcal{L}}({\\mathbf{h}}^*, \\alpha),\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex84.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{L}}({\\mathbf{h}},\\alpha^{*})\\leq{\\mathcal{L}}({\\mathbf{h}}^{*},%&#10;\\alpha^{*})\\leq{\\mathcal{L}}({\\mathbf{h}}^{*},\\alpha),\" display=\"block\"><mrow><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc21</mi><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><msup><mi>\u03b1</mi><mo>*</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\u2112</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc21</mi><mo>*</mo></msup><mo>,</mo><mi>\u03b1</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]