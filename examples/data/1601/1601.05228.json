[{"file": "1601.05228.tex", "nexttext": "\n\n\\subsection{The INFO Section}\n\\label{sec:basicinfo}\n\nThe INFO section contains the meta data of the specification, like a\ntitle and some description\\footnote{We use colored verbatim font to\n  identify the syntactic elements of the specification.}. Furthermore,\nit defines the underlying semantics of the specification (Mealy or\nMoore / standard or strict implication) and the target model of the\nsynthesized implementation. Detailed information about supported\nsemantics and targets can be found in {Sect.~\\ref{{sec:semantics}}}.\n\nFinally, a comma separated list of tags can be specified to identify\nfeatures of the specification, e.g., the restriction to a specific\nfragment of LTL. A {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} can be any string literal and is not\nrestricted to any predefined keywords.\n\n\\goodbreak\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  INFO {!\\\\%\n\\lstinline!    TITLE:       \"!$ {\\ensuremath{\\langle \\text{\\textit{{some title}}} \\rangle}} $\\lstinline!\"!\\\\%\n\\lstinline!    DESCRIPTION: \"!$ {\\ensuremath{\\langle \\text{\\textit{{some description}}} \\rangle}} $\\lstinline!\"!\\\\%\n\\lstinline!    SEMANTICS:   !$ {\\ensuremath{\\langle \\text{\\textit{{semantics}}} \\rangle}} $\\\\%\n\\lstinline!    TARGET:      !$ {\\ensuremath{\\langle \\text{\\textit{{target}}} \\rangle}} $\\\\%\n\\lstinline!    TAGS:        !$ {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} $\n\\lstinline!,! $ {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} $\\lstinline!,!$ \\ \\ldots $\\\\%\n\\lstinline!  }!\n\n\\subsection{The MAIN Section}\n\nThe specification is completed by the MAIN section, which contains the\npartitioning of input and output signals, as well as the main\nspecification, separated into environment assumptions, system invariants\nand system guarantees. Multiple declarations and expressions need\nto be separated by a '\\lstinline!;!'.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  MAIN {!\\\\%\n\\lstinline!    INPUTS      { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{boolean signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    OUTPUTS     { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{boolean signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    ASSUMPTIONS { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    INVARIANTS  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    GUARANTEES  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!  }!\n\n\\vspace{1em}\n\n\\noindent\nThe ASSUMPTIONS, INVARIANTS and GUARANTEES subsections are optional.\n\n\\subsection{Basic Expressions}\n\nA basic expression~$ e $ is either a boolean signal or a basic LTL\nexpression. Each basic expression has a corresponding type that is\n$ {\\ensuremath{\\mathbb{S}}} $ for boolean signals and $ {\\ensuremath{\\mathbb{T}}} $ for LTL\nexpressions.  Basic expressions can be composed to larger expressions\nusing operators.  An overview over the different types of expressions\nand operators is given below.\n\n{\\medskip \\noindent {\\bf {Boolean Signal Declarations}.}}\n\nA signal identifier is represented by a string consisting of lowercase\nand uppercase letters~\\mbox{('\\lstinline!a!'-'\\lstinline!z!'},\n\\mbox{'\\lstinline!A!'-'\\lstinline!Z!')},\nnumbers~\\mbox{('\\lstinline!0!'-'\\lstinline!9!')},\nunderscores~\\mbox{('\\lstinline!_!')}, primes~\\mbox{('\\lstinline!'!')},\n\nand at-signs~\\mbox{('\\lstinline!@!')} and does not start with a number\nor a prime. Additionally, keywords like \\lstinline!X!, \\lstinline!G!\nor \\lstinline!U!, as defined in the rest of this document, are\nforbidden.\n\nAn identifier is declared as either an input or an output signal. We\ndenote the set of declared input signals as $ {\\ensuremath{\\mathcal{I}}} $ and the set of\ndeclared output signals as $ {\\ensuremath{\\mathcal{O}}} $, where\n$ {\\ensuremath{\\mathcal{I}}} \\cap {\\ensuremath{\\mathcal{O}}} = \\emptyset $.  Then, a boolean signal\ndeclaration simply consists of a signal identifier {\\ensuremath{\\langle \\text{\\textit{{name}}} \\rangle}} from\n$ {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} $.\n\n{\\medskip \\noindent {\\bf {Basic LTL Expressions}.}}\n\nA basic LTL expression conforms to the following grammar, including\ntruth values, signals, boolean operators and temporal operators. For\neasy parsing of the basic format, we require fully parenthesized\nexpressions, as expressed by the first of the following lines:\n\n\\begin{eqnarray*}\n  \\varphi & \\equiv & \n  \\text{\\lstinline|(|} \\varphi' \\text{\\lstinline|)|} \\\\\n  \\varphi' & \\equiv & \n  \\text{\\lstinline|true|} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!false!} {\\ensuremath{\\ \\ | \\ \\ }}\n  s \\text{\\ \\ \\ for } s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} {\\ensuremath{\\ \\ | \\ \\ }} \n  \\\\ & &\n  \\text{\\lstinline|!|} \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!&&!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!||!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!->!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!<->!} \\ \\varphi \n  \\\\ & & \n  \\text{\\lstinline!X!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!G!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!F!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!U!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!R!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!W!} \\ \\varphi\n\\end{eqnarray*}\n\nThus, a basic LTL expression is based on the expressions \n\n\ntrue, false, and signals, composed with boolean operators (negation,\nconjunction, disjunction, implication, equivalence) and temporal\noperators (next, globally, eventually, until, release, weak until).\n\n\n\n\nThe semantics are defined in the usual way.  A formal definition of\nthe semantics of the temporal operators can be found in\nAppendix~\\ref{apx_ltl}.\n\n\\newpage\n\n\\include{semantics}\n\n\\section{The Full Format}\n\\label{sec:format}\n\nIn the full format, a specification consists of three sections: the\nINFO section, the GLOBAL section and the MAIN section. The GLOBAL\nsection is optional.\n\n\n", "itemtype": "equation", "pos": 2210, "prevtext": "\n\n\\begin{center}\n  \\begin{huge}\n    A High-Level LTL Synthesis Format: \\[0.5em]\n    TLSF v1.0\n  \\end{huge}\n\n  \\vspace{2em}\n\n  \\begin{large}\n    Swen Jacobs, Felix Klein\n  \\end{large}\n\n  \\vspace{0.9em}\n  \n  \\verb!{jacobs,klein}@react.uni-saarland.de!\n\n  \n\n  \n    \n  \n\\end{center}\n\n\\vspace{0.2em}\n\n\\begin{abstract}\n  We present the Temporal Logic Synthesis Format (TLSF), \n\ta high-level format to describe synthesis problems via\n  Linear Temporal Logic (LTL). The format builds upon standard LTL,\n  but additionally allows to use high level constructs, such as sets\n  and functions, to provide a compact and human readable\n  representation. Furthermore, the format allows to identify\n  parameters of a specification such that a single description can be\n  used to define a family of problems. We also present a tool to\n  automatically translate the format into plain LTL, which then can be\n  used for synthesis by a solver. The tool also allows to adjust\n  parameters of the specification and to apply standard\n  transformations on the resulting formula.\n\\end{abstract}\n\n\\section{Overview}\nWe present the basic version of the Temporal Logic Synthesis Format (TLSF)\nin {Sect.~\\ref{{sec:basicformat}}}. In\n{Sect.~\\ref{{sec:semantics}}} we discuss the intended semantics of a\nspecification, defined in terms of different implementation models.\nThe full format is introduced in\n{Sect.~\\ref{{sec:format}}}. The full format can be compiled automatically to\nthe basic format. Thus, while it is more convenient to write\nspecifications in the full format, for a synthesis tool it is\nsufficient to support the basic format. We illustrate the main\nfeatures of the format in an example in {Sect.~\\ref{{sec:example}}}.  In\n{Sect.~\\ref{{sec:tool}}}, we give an overview of the SyFCo Tool, which can\ninterpret the specification, possibly with respect to given parameter\nvalues, and transform it to the basic format, as well as a number of\nexisting specification formats for backwards compatibility. Finally,\nwe discuss possible extensions of the format in\n{Sect.~\\ref{{sec:extensions}}}.\n\n\\section{The Basic Format}\n\\label{sec:basicformat}\n\nA specification in the basic format consists of an INFO section and a\nMAIN section:\n\n\n", "index": 1, "text": "\\begin{equation*}\n  {\\ensuremath{\\langle \\text{\\textit{{info}}} \\rangle}} {\\ensuremath{\\langle \\text{\\textit{{main}}} \\rangle}} \n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"{\\langle\\text{\\textit{{info}}}\\rangle}{\\langle\\text{\\textit{{main}}}\\rangle}\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc56\ud835\udc5b\ud835\udc53\ud835\udc5c</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc5a\ud835\udc4e\ud835\udc56\ud835\udc5b</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nThe INFO section is the same as in the basic format, defined in\n{Sect.~\\ref{{sec:basicinfo}}}. The GLOBAL section can be used to define\nparameters, and to bind identifiers to expressions that can be used\nlater in the specification. The MAIN section is used as before, but\ncan use extended sets of declarations and expressions.\n\nWe define the GLOBAL section in {Sect.~\\ref{{sec:global}}}, and the changes\nto the MAIN section compared to the basic format in\n{Sect.~\\ref{{sec:main-full}}}. The extended set of expressions that can be\nused in the full format is introduced in {Sect.~\\ref{{sec:expressions}}},\nextended signal and function declarations in\nSections~\\ref{sec:signals} and \\ref{sec:functions}, and additional\nnotation in Sections~\\ref{sec:bigoperator}--\\ref{sec:comments}.\n\n\\subsection{The GLOBAL Section}\n\\label{sec:global}\n\nThe GLOBAL section consists of the PARAMETERS subsection, defining the\nidentifiers that parameterize the specification, and the DEFINITIONS\nsubsection, that allows to define functions and bind identifiers to\ncomplex expressions. Multiple declarations need to be separated by a\n'\\lstinline!;!'. The section and its subsections are optional.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  GLOBAL {!\\\\%\n\\lstinline!    PARAMETERS { !\\\\%\n\\lstinline!      !$ ( {\\ensuremath{\\langle \\text{\\textit{{identifier}}} \\rangle}} $\\lstinline! = !\n$ {\\ensuremath{\\langle \\text{\\textit{{numerical expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\\\%\n\\lstinline!    }!\\\\%\n\\lstinline!    DEFINITIONS  { !\\\\%\n\\lstinline!      !\n$ (({\\ensuremath{\\langle \\text{\\textit{{function declaration}}} \\rangle}} {\\ensuremath{\\ \\ | \\ \\ }} {\\ensuremath{\\langle \\text{\\textit{{identifier}}} \\rangle}} $\n\\lstinline! = !$ {\\ensuremath{\\langle \\text{\\textit{{expression}}} \\rangle}}) $\\lstinline!;!$ )^{*} $\\\\%\n\\lstinline!    }!\\\\%\n\\lstinline!  }!\n\n\\subsection{The MAIN Section}\n\\label{sec:main-full}\n\nLike in the basic format, the MAIN section contains the partitioning\nof input and output signals, as well as the main\nspecification. However, signal declarations can now contain signal\nbuses, and LTL expressions can use parameters, functions, and\nidentifiers defined in the GLOBAL section.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  MAIN {!\\\\%\n\\lstinline!    INPUTS      { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    OUTPUTS     { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    ASSUMPTIONS { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    INVARIANTS  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    GUARANTEES  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!  }!\n\n\\vspace{1em}\n\n\\noindent\nAs before, the ASSUMPTIONS, INVARIANTS and GUARANTEES subsections are\noptional.\n\n\\subsection{Expressions}\n\\label{sec:expressions}\n\nAn expression~$ e $ is either a boolean signal, an $ n $-ary signal\n(called bus), a numerical expression, a boolean expression, an LTL\nexpression, or a set expression. Each expression has a corresponding\ntype that is either one of the basic types:\n$ {\\ensuremath{\\mathbb{S}}}, {\\ensuremath{\\mathbb{U}}}, {\\ensuremath{\\mathbb{N}}}, {\\ensuremath{\\mathbb{B}}}, {\\ensuremath{\\mathbb{T}}} $, or a recursively\ndefined set type $ \\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}} $ for some type\n$ {\\ensuremath{\\mathbb{X}}} $.\n\nAs before, an identifier is represented by a string consisting of\nlowercase and uppercase\nletters~(\\mbox{'\\lstinline!a!'-'\\lstinline!z!'},\n\\mbox{'\\lstinline!A!'-'\\lstinline!Z!'}),\nnumbers~('\\lstinline!0!'-'\\lstinline!9!'),\nunderscores~('\\lstinline!_!'), primes~('\\lstinline!'!'), and\nat-signs~('\\lstinline!@!') and does not start with a number or a\nprime.  In the full format, identifiers are bound to expressions of\ndifferent type. We denote the respective sets of identifiers by\n$ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{S}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{N}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{B}}}}}} $,\n$ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{T}}}}}} $, and $ {\\ensuremath{\\Gamma_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}}} $.  Finally, basic expressions can\nbe composed to larger expressions using operators. In the full format,\nwe do not require fully parenthesized expressions. If an expression is\nnot fully parenthesized, we use the precedence order given in\nAppendix~\\ref{apx_precedence}. An overview over the all types of\nexpressions and operators is given below.\n\n{\\medskip \\noindent {\\bf {Numerical Expressions}.}}\n\nA numerical expression~$ e_{{\\ensuremath{\\mathbb{N}}}} $ conforms to the following\ngrammar:\n\n\\begin{eqnarray*}\n  e_{{\\ensuremath{\\mathbb{N}}}} & \\equiv &\n  i \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{N}}}}}} {\\ensuremath{\\ \\ | \\ \\ }} \n  n  \\text{\\ \\ \\ for } n \\in {\\ensuremath{\\mathbb{N}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!+!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!-!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!*!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!/!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\, \\text{\\lstinline!\\%!} \\ \\, e_{{\\ensuremath{\\mathbb{N}}}} \\\\ \n  & &\n  \\text{\\lstinline!|!} e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\text{\\lstinline!|!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!MIN!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{N}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!MAX!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{N}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!SIZEOF!} \\ s \\ \\ \\text{ for } s \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}}\n\\end{eqnarray*}\n\nThus, a numerical expression either represents an identifier (bound to\na numerical value), a numerical constant, an addition, a subtraction, a\nmultiplication, an integer division, a modulo operation, the size of a\nset, the minimal/maximal value of a set of naturals, or the size (i.e., width) of a\nbus, respectively. The semantics are defined in the usual way.\n\n{\\medskip \\noindent {\\bf {Set Expressions}.}}\n\nA set expression~$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} $, containing elements\nof type $ \\mathbb{X} $, conforms to the following grammar:\n\n\\begin{eqnarray*}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} & \\equiv &\n  i  \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!\\{!} \\, e_{{\\ensuremath{\\mathbb{X}}}} \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{X}}}}\n  \\text{\\lstinline!,!} \\ldots \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{X}}}} \\,\n  \\text{\\lstinline!\\}!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!\\{!} \\, e_{{\\ensuremath{\\mathbb{N}}}} \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{N}}}} \\, \n  \\text{\\lstinline!..!}\\,  e_{{\\ensuremath{\\mathbb{N}}}} \\, \\text{\\lstinline!\\}!} {\\ensuremath{\\ \\ | \\ \\ }} \n  \\\\ &&\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(+)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(*)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(\\\\)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}\n\\end{eqnarray*}\n\nThus, the expression~$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} $ either\nrepresents an identifier (bound to a set of values of type\n$ {\\ensuremath{\\mathbb{X}}} $), an explicit list of elements of type $ {\\ensuremath{\\mathbb{X}}} $,\na list of elements specified by a range (for $ {\\ensuremath{\\mathbb{X}}} = {\\ensuremath{\\mathbb{N}}} $),\na union of two sets, an intersection or a difference,\nrespectively. The semantics of a range expression\n\\lstinline!{!$ x $\\lstinline!,!$ y $\\lstinline!..!$ z $\\lstinline!}!\nare defined for $ x < y $ via:\n\n\n", "itemtype": "equation", "pos": 8601, "prevtext": "\n\n\\subsection{The INFO Section}\n\\label{sec:basicinfo}\n\nThe INFO section contains the meta data of the specification, like a\ntitle and some description\\footnote{We use colored verbatim font to\n  identify the syntactic elements of the specification.}. Furthermore,\nit defines the underlying semantics of the specification (Mealy or\nMoore / standard or strict implication) and the target model of the\nsynthesized implementation. Detailed information about supported\nsemantics and targets can be found in {Sect.~\\ref{{sec:semantics}}}.\n\nFinally, a comma separated list of tags can be specified to identify\nfeatures of the specification, e.g., the restriction to a specific\nfragment of LTL. A {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} can be any string literal and is not\nrestricted to any predefined keywords.\n\n\\goodbreak\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  INFO {!\\\\%\n\\lstinline!    TITLE:       \"!$ {\\ensuremath{\\langle \\text{\\textit{{some title}}} \\rangle}} $\\lstinline!\"!\\\\%\n\\lstinline!    DESCRIPTION: \"!$ {\\ensuremath{\\langle \\text{\\textit{{some description}}} \\rangle}} $\\lstinline!\"!\\\\%\n\\lstinline!    SEMANTICS:   !$ {\\ensuremath{\\langle \\text{\\textit{{semantics}}} \\rangle}} $\\\\%\n\\lstinline!    TARGET:      !$ {\\ensuremath{\\langle \\text{\\textit{{target}}} \\rangle}} $\\\\%\n\\lstinline!    TAGS:        !$ {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} $\n\\lstinline!,! $ {\\ensuremath{\\langle \\text{\\textit{{tag}}} \\rangle}} $\\lstinline!,!$ \\ \\ldots $\\\\%\n\\lstinline!  }!\n\n\\subsection{The MAIN Section}\n\nThe specification is completed by the MAIN section, which contains the\npartitioning of input and output signals, as well as the main\nspecification, separated into environment assumptions, system invariants\nand system guarantees. Multiple declarations and expressions need\nto be separated by a '\\lstinline!;!'.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  MAIN {!\\\\%\n\\lstinline!    INPUTS      { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{boolean signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    OUTPUTS     { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{boolean signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    ASSUMPTIONS { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    INVARIANTS  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    GUARANTEES  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{basic LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!  }!\n\n\\vspace{1em}\n\n\\noindent\nThe ASSUMPTIONS, INVARIANTS and GUARANTEES subsections are optional.\n\n\\subsection{Basic Expressions}\n\nA basic expression~$ e $ is either a boolean signal or a basic LTL\nexpression. Each basic expression has a corresponding type that is\n$ {\\ensuremath{\\mathbb{S}}} $ for boolean signals and $ {\\ensuremath{\\mathbb{T}}} $ for LTL\nexpressions.  Basic expressions can be composed to larger expressions\nusing operators.  An overview over the different types of expressions\nand operators is given below.\n\n{\\medskip \\noindent {\\bf {Boolean Signal Declarations}.}}\n\nA signal identifier is represented by a string consisting of lowercase\nand uppercase letters~\\mbox{('\\lstinline!a!'-'\\lstinline!z!'},\n\\mbox{'\\lstinline!A!'-'\\lstinline!Z!')},\nnumbers~\\mbox{('\\lstinline!0!'-'\\lstinline!9!')},\nunderscores~\\mbox{('\\lstinline!_!')}, primes~\\mbox{('\\lstinline!'!')},\n\nand at-signs~\\mbox{('\\lstinline!@!')} and does not start with a number\nor a prime. Additionally, keywords like \\lstinline!X!, \\lstinline!G!\nor \\lstinline!U!, as defined in the rest of this document, are\nforbidden.\n\nAn identifier is declared as either an input or an output signal. We\ndenote the set of declared input signals as $ {\\ensuremath{\\mathcal{I}}} $ and the set of\ndeclared output signals as $ {\\ensuremath{\\mathcal{O}}} $, where\n$ {\\ensuremath{\\mathcal{I}}} \\cap {\\ensuremath{\\mathcal{O}}} = \\emptyset $.  Then, a boolean signal\ndeclaration simply consists of a signal identifier {\\ensuremath{\\langle \\text{\\textit{{name}}} \\rangle}} from\n$ {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} $.\n\n{\\medskip \\noindent {\\bf {Basic LTL Expressions}.}}\n\nA basic LTL expression conforms to the following grammar, including\ntruth values, signals, boolean operators and temporal operators. For\neasy parsing of the basic format, we require fully parenthesized\nexpressions, as expressed by the first of the following lines:\n\n\\begin{eqnarray*}\n  \\varphi & \\equiv & \n  \\text{\\lstinline|(|} \\varphi' \\text{\\lstinline|)|} \\\\\n  \\varphi' & \\equiv & \n  \\text{\\lstinline|true|} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!false!} {\\ensuremath{\\ \\ | \\ \\ }}\n  s \\text{\\ \\ \\ for } s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} {\\ensuremath{\\ \\ | \\ \\ }} \n  \\\\ & &\n  \\text{\\lstinline|!|} \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!&&!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!||!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!->!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!<->!} \\ \\varphi \n  \\\\ & & \n  \\text{\\lstinline!X!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!G!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!F!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!U!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!R!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!W!} \\ \\varphi\n\\end{eqnarray*}\n\nThus, a basic LTL expression is based on the expressions \n\n\ntrue, false, and signals, composed with boolean operators (negation,\nconjunction, disjunction, implication, equivalence) and temporal\noperators (next, globally, eventually, until, release, weak until).\n\n\n\n\nThe semantics are defined in the usual way.  A formal definition of\nthe semantics of the temporal operators can be found in\nAppendix~\\ref{apx_ltl}.\n\n\\newpage\n\n\\include{semantics}\n\n\\section{The Full Format}\n\\label{sec:format}\n\nIn the full format, a specification consists of three sections: the\nINFO section, the GLOBAL section and the MAIN section. The GLOBAL\nsection is optional.\n\n\n", "index": 3, "text": "\\begin{equation*}\n  {\\ensuremath{\\langle \\text{\\textit{{info}}} \\rangle}} [{\\ensuremath{\\langle \\text{\\textit{{global}}} \\rangle}}] {\\ensuremath{\\langle \\text{\\textit{{main}}} \\rangle}}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"{\\langle\\text{\\textit{{info}}}\\rangle}[{\\langle\\text{\\textit{{global}}}\\rangle%&#10;}]{\\langle\\text{\\textit{{main}}}\\rangle}\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc56\ud835\udc5b\ud835\udc53\ud835\udc5c</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc54\ud835\udc59\ud835\udc5c\ud835\udc4f\ud835\udc4e\ud835\udc59</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc5a\ud835\udc4e\ud835\udc56\ud835\udc5b</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nThe semantics of all other expressions is defined as usual. Sets\ncontain either positive integers, boolean expressions, LTL\nexpressions, buses, signals, or other sets of a specific type.\n\n{\\medskip \\noindent {\\bf {Boolean Expressions}.}}\n\nA boolean expression~$ e_{{\\ensuremath{\\mathbb{B}}}} $ conforms to the following\ngrammar:\n\n\\begin{eqnarray*}\n  e_{{\\ensuremath{\\mathbb{B}}}} & \\equiv & \n  i  \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{B}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{X}}}} \\ \\text{\\lstinline!IN!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline|true|} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!false!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline|!|}\\,e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n\n\n  \\\\ & & \n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!&&!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!||!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!->!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!<->!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\\\ & & \n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!==!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline~!=~} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!<!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!<=!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!>!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!>=!} \\ e_{{\\ensuremath{\\mathbb{N}}}}\n\\end{eqnarray*}\n\nThus, a boolean expression either represents an identifier (bound to a\nboolean value), a membership test, true, false, a negation, a\nconjunction, a disjunction, an implication, an equivalence, or an\nequation between two positive integers (equality, inequality, less\nthan, less or equal than, greater than, greater or equal than),\nrespectively. The semantics are defined in the usual way. Note that\nsignals are not allowed in a boolean expression, but only in an LTL\nexpression.\n\n{\\medskip \\noindent {\\bf {LTL Expressions}.}}\n\nAn LTL expression~$ \\varphi $ conforms to the same grammar as a\nboolean expression, except that it additionally includes signals and\ntemporal operators.\n\n\n\n\n", "itemtype": "equation", "pos": 17173, "prevtext": "\n\nThe INFO section is the same as in the basic format, defined in\n{Sect.~\\ref{{sec:basicinfo}}}. The GLOBAL section can be used to define\nparameters, and to bind identifiers to expressions that can be used\nlater in the specification. The MAIN section is used as before, but\ncan use extended sets of declarations and expressions.\n\nWe define the GLOBAL section in {Sect.~\\ref{{sec:global}}}, and the changes\nto the MAIN section compared to the basic format in\n{Sect.~\\ref{{sec:main-full}}}. The extended set of expressions that can be\nused in the full format is introduced in {Sect.~\\ref{{sec:expressions}}},\nextended signal and function declarations in\nSections~\\ref{sec:signals} and \\ref{sec:functions}, and additional\nnotation in Sections~\\ref{sec:bigoperator}--\\ref{sec:comments}.\n\n\\subsection{The GLOBAL Section}\n\\label{sec:global}\n\nThe GLOBAL section consists of the PARAMETERS subsection, defining the\nidentifiers that parameterize the specification, and the DEFINITIONS\nsubsection, that allows to define functions and bind identifiers to\ncomplex expressions. Multiple declarations need to be separated by a\n'\\lstinline!;!'. The section and its subsections are optional.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  GLOBAL {!\\\\%\n\\lstinline!    PARAMETERS { !\\\\%\n\\lstinline!      !$ ( {\\ensuremath{\\langle \\text{\\textit{{identifier}}} \\rangle}} $\\lstinline! = !\n$ {\\ensuremath{\\langle \\text{\\textit{{numerical expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\\\%\n\\lstinline!    }!\\\\%\n\\lstinline!    DEFINITIONS  { !\\\\%\n\\lstinline!      !\n$ (({\\ensuremath{\\langle \\text{\\textit{{function declaration}}} \\rangle}} {\\ensuremath{\\ \\ | \\ \\ }} {\\ensuremath{\\langle \\text{\\textit{{identifier}}} \\rangle}} $\n\\lstinline! = !$ {\\ensuremath{\\langle \\text{\\textit{{expression}}} \\rangle}}) $\\lstinline!;!$ )^{*} $\\\\%\n\\lstinline!    }!\\\\%\n\\lstinline!  }!\n\n\\subsection{The MAIN Section}\n\\label{sec:main-full}\n\nLike in the basic format, the MAIN section contains the partitioning\nof input and output signals, as well as the main\nspecification. However, signal declarations can now contain signal\nbuses, and LTL expressions can use parameters, functions, and\nidentifiers defined in the GLOBAL section.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  MAIN {!\\\\%\n\\lstinline!    INPUTS      { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    OUTPUTS     { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{signal declaration}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    ASSUMPTIONS { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    INVARIANTS  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!    GUARANTEES  { !\n$ ( {\\ensuremath{\\langle \\text{\\textit{{LTL expression}}} \\rangle}} $\\lstinline!;!$ )^{*} $\\lstinline! }!\\\\%\n\\lstinline!  }!\n\n\\vspace{1em}\n\n\\noindent\nAs before, the ASSUMPTIONS, INVARIANTS and GUARANTEES subsections are\noptional.\n\n\\subsection{Expressions}\n\\label{sec:expressions}\n\nAn expression~$ e $ is either a boolean signal, an $ n $-ary signal\n(called bus), a numerical expression, a boolean expression, an LTL\nexpression, or a set expression. Each expression has a corresponding\ntype that is either one of the basic types:\n$ {\\ensuremath{\\mathbb{S}}}, {\\ensuremath{\\mathbb{U}}}, {\\ensuremath{\\mathbb{N}}}, {\\ensuremath{\\mathbb{B}}}, {\\ensuremath{\\mathbb{T}}} $, or a recursively\ndefined set type $ \\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}} $ for some type\n$ {\\ensuremath{\\mathbb{X}}} $.\n\nAs before, an identifier is represented by a string consisting of\nlowercase and uppercase\nletters~(\\mbox{'\\lstinline!a!'-'\\lstinline!z!'},\n\\mbox{'\\lstinline!A!'-'\\lstinline!Z!'}),\nnumbers~('\\lstinline!0!'-'\\lstinline!9!'),\nunderscores~('\\lstinline!_!'), primes~('\\lstinline!'!'), and\nat-signs~('\\lstinline!@!') and does not start with a number or a\nprime.  In the full format, identifiers are bound to expressions of\ndifferent type. We denote the respective sets of identifiers by\n$ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{S}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{N}}}}}} $, $ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{B}}}}}} $,\n$ {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{T}}}}}} $, and $ {\\ensuremath{\\Gamma_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}}} $.  Finally, basic expressions can\nbe composed to larger expressions using operators. In the full format,\nwe do not require fully parenthesized expressions. If an expression is\nnot fully parenthesized, we use the precedence order given in\nAppendix~\\ref{apx_precedence}. An overview over the all types of\nexpressions and operators is given below.\n\n{\\medskip \\noindent {\\bf {Numerical Expressions}.}}\n\nA numerical expression~$ e_{{\\ensuremath{\\mathbb{N}}}} $ conforms to the following\ngrammar:\n\n\\begin{eqnarray*}\n  e_{{\\ensuremath{\\mathbb{N}}}} & \\equiv &\n  i \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{N}}}}}} {\\ensuremath{\\ \\ | \\ \\ }} \n  n  \\text{\\ \\ \\ for } n \\in {\\ensuremath{\\mathbb{N}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!+!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!-!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!*!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!/!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\, \\text{\\lstinline!\\%!} \\ \\, e_{{\\ensuremath{\\mathbb{N}}}} \\\\ \n  & &\n  \\text{\\lstinline!|!} e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\text{\\lstinline!|!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!MIN!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{N}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!MAX!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{N}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!SIZEOF!} \\ s \\ \\ \\text{ for } s \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}}\n\\end{eqnarray*}\n\nThus, a numerical expression either represents an identifier (bound to\na numerical value), a numerical constant, an addition, a subtraction, a\nmultiplication, an integer division, a modulo operation, the size of a\nset, the minimal/maximal value of a set of naturals, or the size (i.e., width) of a\nbus, respectively. The semantics are defined in the usual way.\n\n{\\medskip \\noindent {\\bf {Set Expressions}.}}\n\nA set expression~$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} $, containing elements\nof type $ \\mathbb{X} $, conforms to the following grammar:\n\n\\begin{eqnarray*}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} & \\equiv &\n  i  \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!\\{!} \\, e_{{\\ensuremath{\\mathbb{X}}}} \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{X}}}}\n  \\text{\\lstinline!,!} \\ldots \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{X}}}} \\,\n  \\text{\\lstinline!\\}!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!\\{!} \\, e_{{\\ensuremath{\\mathbb{N}}}} \\text{\\lstinline!,!} \\, e_{{\\ensuremath{\\mathbb{N}}}} \\, \n  \\text{\\lstinline!..!}\\,  e_{{\\ensuremath{\\mathbb{N}}}} \\, \\text{\\lstinline!\\}!} {\\ensuremath{\\ \\ | \\ \\ }} \n  \\\\ &&\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(+)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(*)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} \\, \\text{\\lstinline!(\\\\)!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}}\n\\end{eqnarray*}\n\nThus, the expression~$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} $ either\nrepresents an identifier (bound to a set of values of type\n$ {\\ensuremath{\\mathbb{X}}} $), an explicit list of elements of type $ {\\ensuremath{\\mathbb{X}}} $,\na list of elements specified by a range (for $ {\\ensuremath{\\mathbb{X}}} = {\\ensuremath{\\mathbb{N}}} $),\na union of two sets, an intersection or a difference,\nrespectively. The semantics of a range expression\n\\lstinline!{!$ x $\\lstinline!,!$ y $\\lstinline!..!$ z $\\lstinline!}!\nare defined for $ x < y $ via:\n\n\n", "index": 5, "text": "\\begin{equation*}\n  \\{ n \\in {\\ensuremath{\\mathbb{N}}} \\mid x \\leq n \\leq z \\wedge \\exists j.\\ n = x +\n  j \\cdot (y-x) \\}.\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\{n\\in{\\mathbb{N}}\\mid x\\leq n\\leq z\\wedge\\exists j.\\ n=x+j\\cdot(y-x)\\}.\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">{</mo><mrow><mi>n</mi><mo>\u2208</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>N</mi></mrow></mrow><mo>\u2223</mo><mrow><mrow><mi>x</mi><mo>\u2264</mo><mi>n</mi><mo>\u2264</mo><mrow><mi>z</mi><mo>\u2227</mo><mrow><mo>\u2203</mo><mi>j</mi></mrow></mrow></mrow><mo rspace=\"7.5pt\">.</mo><mrow><mi>n</mi><mo>=</mo><mrow><mi>x</mi><mo>+</mo><mrow><mi>j</mi><mo>\u22c5</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>y</mi><mo>-</mo><mi>x</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\n\\goodbreak\n\n\\noindent\nThus, an LTL expression additionally can represent an identifier bound\nto an LTL formula, a signal, an $e_{{\\ensuremath{\\mathbb{N}}}} $-th signal of a bus, a\nnext operation, a globally operation, an eventually operation, an\nuntil operation, a release operation, or a weak until operation,\nrespectively. Note that every boolean expression is also an LTL\nexpression, thus we allow the use of identifiers that are bound to\nboolean expressions as well. A formal definition of the semantics of\nthe temporal operators can be found in Appendix~\\ref{apx_ltl}.\n\n\\subsection{Signals and Buses}\n\\label{sec:signals}\n\nA signal declaration consists of the name of the signal.  As for the\nbasic format, signals are declared as either input or output signals,\ndenoted by $ {\\ensuremath{\\mathcal{I}}} $ and $ {\\ensuremath{\\mathcal{O}}} $, respectively. A bus\ndeclaration additionally specifies a signal width, i.e., a bus\nrepresents a finite set of signals.\n\n\n", "itemtype": "equation", "pos": 19957, "prevtext": "\n\nThe semantics of all other expressions is defined as usual. Sets\ncontain either positive integers, boolean expressions, LTL\nexpressions, buses, signals, or other sets of a specific type.\n\n{\\medskip \\noindent {\\bf {Boolean Expressions}.}}\n\nA boolean expression~$ e_{{\\ensuremath{\\mathbb{B}}}} $ conforms to the following\ngrammar:\n\n\\begin{eqnarray*}\n  e_{{\\ensuremath{\\mathbb{B}}}} & \\equiv & \n  i  \\text{\\ \\ \\ for } i \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{B}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{X}}}} \\ \\text{\\lstinline!IN!} \\ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline|true|} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!false!} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline|!|}\\,e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n\n\n  \\\\ & & \n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!&&!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!||!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!->!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!<->!} \\ e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\\\ & & \n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!==!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline~!=~} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!<!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!<=!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!>!} \\ e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{N}}}} \\ \\text{\\lstinline!>=!} \\ e_{{\\ensuremath{\\mathbb{N}}}}\n\\end{eqnarray*}\n\nThus, a boolean expression either represents an identifier (bound to a\nboolean value), a membership test, true, false, a negation, a\nconjunction, a disjunction, an implication, an equivalence, or an\nequation between two positive integers (equality, inequality, less\nthan, less or equal than, greater than, greater or equal than),\nrespectively. The semantics are defined in the usual way. Note that\nsignals are not allowed in a boolean expression, but only in an LTL\nexpression.\n\n{\\medskip \\noindent {\\bf {LTL Expressions}.}}\n\nAn LTL expression~$ \\varphi $ conforms to the same grammar as a\nboolean expression, except that it additionally includes signals and\ntemporal operators.\n\n\n\n\n", "index": 7, "text": "\\begin{equation*}\n  \\varphi \\ \\, \\equiv \\ \\, \\ldots {\\ensuremath{\\ \\ | \\ \\ }}\n  i \\text{\\ \\ for } i \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{T}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  s \\text{\\ \\ for } s \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{S}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  b \\text{\\lstinline![!} e_{{\\ensuremath{\\mathbb{N}}}} \n  \\text{\\lstinline!]!} \\text{ for } b \n  \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!X!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!G!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\text{\\lstinline!F!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!U!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!R!} \\ \\varphi {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi \\ \\text{\\lstinline!W!} \\ \\varphi\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"{{{{{{{{{{{{{{{{\\varphi\\ \\,\\equiv\\ \\,\\ldots{\\ \\ |\\ \\ }i\\text{\\ \\ for}i\\in{\\Gamma_{{\\mathbb{T}}%&#10;}}{\\ \\ |\\ \\ }s\\text{\\ \\ for}s\\in{\\Gamma_{{\\mathbb{S}}}}{\\ \\ |\\ \\ }b\\text{%&#10;\\lstinline 1}}}e_{{\\mathbb{N}}}\\text{\\lstinline 1}}}\\text{for}b\\in{\\Gamma_{{%&#10;\\mathbb{U}}}}{\\ \\ |\\ \\ }\\text{\\lstinline 1}}}\\ \\varphi{\\ \\ |\\ \\ }\\text{%&#10;\\lstinline 1}}}\\ \\varphi{\\ \\ |\\ \\ }\\text{\\lstinline 1}}}\\ \\varphi{\\ \\ |\\ \\ }%&#10;\\varphi\\ \\text{\\lstinline 1}}}\\ \\varphi{\\ \\ |\\ \\ }\\varphi\\ \\text{\\lstinline 1}%&#10;}}\\ \\varphi{\\ \\ |\\ \\ }\\varphi\\ \\text{\\lstinline 1}}}\\ \\varphi\" display=\"block\"><mrow><mpadded width=\"+6.7pt\"><mi>\u03c6</mi></mpadded><mo rspace=\"9.2pt\">\u2261</mo><mi mathvariant=\"normal\">\u2026</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>i</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>i</mi><mo>\u2208</mo><msub><mi mathvariant=\"normal\">\u0393</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>T</mi></mrow></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>s</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo>\u2208</mo><msub><mi mathvariant=\"normal\">\u0393</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>S</mi></mrow></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>b</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext class=\"ltx_lstlisting\">[</mtext><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>N</mi></mrow></msub><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mrow><mtext mathvariant=\"normal\">]</mtext><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\text</span></mtext></mrow><mi>f</mi><mi>o</mi><mi>r</mi><mi>b</mi><mo>\u2208</mo><msub><mi mathvariant=\"normal\">\u0393</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>U</mi></mrow></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>X</mtext></mpadded><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>G</mtext></mpadded><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>F</mtext></mpadded><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+5pt\"><mi>\u03c6</mi></mpadded><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>U</mtext></mpadded><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+5pt\"><mi>\u03c6</mi></mpadded><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>R</mtext></mpadded><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+5pt\"><mi>\u03c6</mi></mpadded><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+5pt\"><mtext>W</mtext></mpadded><mi>\u03c6</mi></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nIn other words, a signal declaration \\lstinline!s! specifies a signal\n$ s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} $, where a bus declaration\n\\lstinline!b[n]! specifies $ n $ signals~\\lstinline!b[0]!,\n\\lstinline!b[1]!, $ \\ldots $, \\lstinline!b[n-1]!, with either\n\\lstinline!b[i]!$ \\in {\\ensuremath{\\mathcal{I}}} $ for all $ i $, or\n\\lstinline!b[i]!$ \\in {\\ensuremath{\\mathcal{O}}} $ for all $ i $.\n\nConsider that we use \\lstinline!b[i]! to access the $ i $-th value of\n$ b $, i.e., we use the same syntax as for the declaration\nitself\\footnote{C-Array Syntax Style}. Also note that for the declared\nsignals~$ s $, we have\n$ s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} \\subseteq {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{S}}}}}} $, and for the\ndeclared buses $ b $, we have $ b \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}} $.\n\n\\subsection{Function Declarations}\n\\label{sec:functions}\n\nAs another feature, one can declare (recursive) functions of arbitrary\narity inside the DEFINITIONS section. Functions can be used to define\nsimple macros, but also to generate complex formulas from a given set\nof parameters. A declaration of a function of arity~$ n $ has the form\n\n\n\n\n", "itemtype": "equation", "pos": 21755, "prevtext": "\n\n\\goodbreak\n\n\\noindent\nThus, an LTL expression additionally can represent an identifier bound\nto an LTL formula, a signal, an $e_{{\\ensuremath{\\mathbb{N}}}} $-th signal of a bus, a\nnext operation, a globally operation, an eventually operation, an\nuntil operation, a release operation, or a weak until operation,\nrespectively. Note that every boolean expression is also an LTL\nexpression, thus we allow the use of identifiers that are bound to\nboolean expressions as well. A formal definition of the semantics of\nthe temporal operators can be found in Appendix~\\ref{apx_ltl}.\n\n\\subsection{Signals and Buses}\n\\label{sec:signals}\n\nA signal declaration consists of the name of the signal.  As for the\nbasic format, signals are declared as either input or output signals,\ndenoted by $ {\\ensuremath{\\mathcal{I}}} $ and $ {\\ensuremath{\\mathcal{O}}} $, respectively. A bus\ndeclaration additionally specifies a signal width, i.e., a bus\nrepresents a finite set of signals.\n\n\n", "index": 9, "text": "\\begin{equation*}\n  \\langle \\text{\\textit{name}} \\rangle {\\ensuremath{\\ \\ | \\ \\ }}\n  \\langle \\text{\\textit{name}} \\rangle \\text{\\lstinline![!} \n  e_{{\\ensuremath{\\mathbb{N}}}} \\text{\\lstinline!]!}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"{{{{\\langle\\text{\\textit{name}}\\rangle{\\ \\ |\\ \\ }\\langle\\text{\\textit{name}}%&#10;\\rangle\\text{\\lstinline 1}}}e_{{\\mathbb{N}}}\\text{\\lstinline 1}}}\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext>\ud835\udc5b\ud835\udc4e\ud835\udc5a\ud835\udc52</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mo stretchy=\"false\">\u27e8</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext>\ud835\udc5b\ud835\udc4e\ud835\udc5a\ud835\udc52</mtext><mo stretchy=\"false\">\u27e9</mo></mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext class=\"ltx_lstlisting\">[</mtext><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>N</mi></mrow></msub><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext class=\"ltx_lstlisting\">]</mtext></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nwhere\n$ {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{1}}}}} \\rangle}}, {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{2}}}}} \\rangle}},\n\\ldots, {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{n}}}}} \\rangle}} $\nare fresh identifiers that can only be used inside the\nsub-expressions~$ e_{c} $. An expression~$ e_{c} $ conforms to the\nfollowing grammar:\n\n\n", "itemtype": "equation", "pos": 23190, "prevtext": "\n\nIn other words, a signal declaration \\lstinline!s! specifies a signal\n$ s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} $, where a bus declaration\n\\lstinline!b[n]! specifies $ n $ signals~\\lstinline!b[0]!,\n\\lstinline!b[1]!, $ \\ldots $, \\lstinline!b[n-1]!, with either\n\\lstinline!b[i]!$ \\in {\\ensuremath{\\mathcal{I}}} $ for all $ i $, or\n\\lstinline!b[i]!$ \\in {\\ensuremath{\\mathcal{O}}} $ for all $ i $.\n\nConsider that we use \\lstinline!b[i]! to access the $ i $-th value of\n$ b $, i.e., we use the same syntax as for the declaration\nitself\\footnote{C-Array Syntax Style}. Also note that for the declared\nsignals~$ s $, we have\n$ s \\in {\\ensuremath{\\mathcal{I}}} \\cup {\\ensuremath{\\mathcal{O}}} \\subseteq {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{S}}}}}} $, and for the\ndeclared buses $ b $, we have $ b \\in {\\ensuremath{\\Gamma_{{\\ensuremath{\\mathbb{U}}}}}} $.\n\n\\subsection{Function Declarations}\n\\label{sec:functions}\n\nAs another feature, one can declare (recursive) functions of arbitrary\narity inside the DEFINITIONS section. Functions can be used to define\nsimple macros, but also to generate complex formulas from a given set\nof parameters. A declaration of a function of arity~$ n $ has the form\n\n\n\n\n", "index": 11, "text": "\\begin{equation*}\n  {\\ensuremath{\\langle \\text{\\textit{{function name}}} \\rangle}} \\text{\\lstinline!(!}\n  {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{1}}}}} \\rangle}} \\text{\\lstinline!,!} \n  {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{2}}}}} \\rangle}} \\text{\\lstinline!,!}  \n  \\ldots \\text{\\lstinline!,!}\n  {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{n}}}}} \\rangle}} \\text{\\lstinline!) =\\ !}\n  (e_{c})^{+},\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"{{{{{{{{{{{\\langle\\text{\\textit{{function name}}}\\rangle}\\text{\\lstinline 1}}}{\\langle%&#10;\\text{\\textit{{arg${}_{1}$}}}\\rangle}\\text{\\lstinline 1}}}{\\langle\\text{%&#10;\\textit{{arg${}_{2}$}}}\\rangle}\\text{\\lstinline 1}}}\\ldots\\text{\\lstinline 1}}%&#10;}{\\langle\\text{\\textit{{arg${}_{n}$}}}\\rangle}\\text{\\lstinline 1}}}(e_{c})^{+},\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext mathvariant=\"italic\">function name</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext class=\"ltx_lstlisting\">(</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc4e\ud835\udc5f\ud835\udc54</mtext><msub><mi/><mn>1</mn></msub></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext class=\"ltx_lstlisting\">,</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc4e\ud835\udc5f\ud835\udc54</mtext><msub><mi/><mn>2</mn></msub></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext mathvariant=\"normal\">,</mtext><mo>\u2062</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext class=\"ltx_lstlisting\">,</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc4e\ud835\udc5f\ud835\udc54</mtext><msub><mi/><mi>n</mi></msub></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow class=\"ltx_lstlisting\"><mtext>)</mtext><mtext mathcolor=\"red\"/><mtext>=</mtext><mtext>\\</mtext></mrow><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mi>c</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>+</mo></msup></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nThus, a function can be bound to any expression~$ e $, parameterized\nin its arguments, which additionally may be guarded by some boolean\nexpression~$ e_{{\\ensuremath{\\mathbb{B}}}} $, or a pattern match~$ e_{{\\ensuremath{\\mathbb{P}}}} $. If the\nregular expression~$ (e_{c})^{+} $ consists of more than one\nexpression~$ e_{c} $, then the function binds to the first expression\nwhose guard evaluates to \\lstinline!true! (in the order of their\ndeclaration). Furthermore, the special guard \\lstinline!otherwise! can\nbe used, which evaluates to true if and only if all other guards\nevaluate to \\lstinline!false!. Expressions without a guard are\nimplicitly guarded by \\lstinline!true!. All sub-expressions~$ e_{c} $\nneed to have the same type $ {\\ensuremath{\\mathbb{X}}} $. For every instantiation of\na function by given parameters, we view the resulting expression\n$ e_{{\\ensuremath{\\mathbb{X}}}} $ as an identifier in~$ \\Gamma_{{\\ensuremath{\\mathbb{X}}}} $, bound\nto the result of the function application.\n\n\n\n\n \n{\\medskip \\noindent {\\bf {Pattern Matching}.}}\n\\label{sec_patterns}\n\nPattern matches are special guards of the form\n\n\n", "itemtype": "equation", "pos": 24014, "prevtext": "\n\nwhere\n$ {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{1}}}}} \\rangle}}, {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{2}}}}} \\rangle}},\n\\ldots, {\\ensuremath{\\langle \\text{\\textit{{arg\\ensuremath{_{n}}}}} \\rangle}} $\nare fresh identifiers that can only be used inside the\nsub-expressions~$ e_{c} $. An expression~$ e_{c} $ conforms to the\nfollowing grammar:\n\n\n", "index": 13, "text": "\\begin{equation*}\n  e_{c} \\ \\, \\equiv \\ \\, e {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} \\ \\text{\\lstinline!:!} \\ e {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathbb{P}} \\ \\text{\\lstinline!:!} \\ e \n  \\qquad \\qquad \\text{where } \n  \\ \\ e \\ \\, \\equiv  \\ \\,\n  e_{{\\ensuremath{\\mathbb{N}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{{\\ensuremath{\\mathbb{B}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}}} {\\ensuremath{\\ \\ | \\ \\ }}\n  \\varphi\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"{{{{e_{c}\\ \\,\\equiv\\ \\,e{\\ \\ |\\ \\ }e_{{\\mathbb{B}}}\\ \\text{\\lstinline 1}}}\\ e{\\ \\ %&#10;|\\ \\ }e_{\\mathbb{P}}\\ \\text{\\lstinline 1}}}\\ e\\qquad\\qquad\\text{where}\\ \\ e\\ %&#10;\\,\\equiv\\ \\,e_{{\\mathbb{N}}}{\\ \\ |\\ \\ }e_{{\\mathbb{B}}}{\\ \\ |\\ \\ }e_{\\mathcal{%&#10;S}_{{\\mathbb{X}}}}{\\ \\ |\\ \\ }\\varphi\" display=\"block\"><mrow><mpadded width=\"+6.7pt\"><msub><mi>e</mi><mi>c</mi></msub></mpadded><mo rspace=\"9.2pt\">\u2261</mo><mi>e</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+5pt\"><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>B</mi></mrow></msub></mpadded><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting\" width=\"+5pt\"><mtext>:</mtext></mpadded><mi>e</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+5pt\"><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>P</mi></mrow></msub></mpadded><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mpadded class=\"ltx_lstlisting\" width=\"+5pt\"><mtext>:</mtext></mpadded><mi>e</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2003\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mpadded width=\"+6.7pt\"><mi>e</mi></mpadded><mo rspace=\"9.2pt\">\u2261</mo><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>N</mi></mrow></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>B</mi></mrow></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><msub><mi>e</mi><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>X</mi></mrow></msub></msub><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>\u03c6</mi></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nwhich can be used to describe different behavior depending on the\nstructure of an LTL expression. Hence, a guard~$ e_{{\\ensuremath{\\mathbb{P}}}} $ evaluates\nto \\lstinline!true! if and only if $ \\varphi $ and $ \\varphi' $ are\nstructurally equivalent, with respect to their boolean and temporal\nconnectives. Furthermore, identifier names that are used in\n$ \\varphi' $ need to be fresh, since every identifier expression that\nappears in $ \\varphi' $ is bound to the equivalent sub-expression in\n$ \\varphi $, which is only visible inside the right-hand-side of the\nguard. Furthermore, to improve readability, the special\nidentifier~\\lstinline!_! (wildcard) can be used,\nwhich always remains unbound. To clarify this feature, consider the\nfollowing function declaration:\n\n\\vspace{0.6em}\n\n\\noindent\n\\lstinline!  fun(f) =!\\\\%\n\\vspace{-0.4em}\n\\lstinline!    f !$ \\hspace{-1.5pt} {\\ensuremath{\\color{codecolor} \\raisebox{-9pt}{\\scalebox{1.7}{\\textasciitilde}}}} \\hspace{-1.5pt} $\n\\lstinline! a U _: a!\\\\%\n\\lstinline!    otherwise: X f!\n   \n\\vspace{0.6em}\n\n\\noindent The function $ \\textit{fun} $ gets an LTL formula $ f $ as a\nparameter. If $ f $ is an until formula of the form\n$ \\varphi_{1} \\LTLuntil \\varphi_{2} $, then $ \\textit{fun}(f) $ binds\nto $ \\varphi_{1} $, otherwise $ \\textit{fun}(f) $ binds to\n$ \\LTLnext f $.\n\n\n\n\\subsection{Big Operator Notation}\n\\label{sec:bigoperator}\n\n\nIt is often useful to express parameterized expressions using ``big''\noperators, e.g., we use $ \\Sigma $ to denote a sum over multiple\nsub-expressions, $ \\Pi $ to denote a product, or $ \\bigcup $ to denote\na union. It is also possible to use this kind of notion in this\nspecification format. The corresponding syntax looks as follows:\n\n\n", "itemtype": "equation", "pos": 25612, "prevtext": "\n\nThus, a function can be bound to any expression~$ e $, parameterized\nin its arguments, which additionally may be guarded by some boolean\nexpression~$ e_{{\\ensuremath{\\mathbb{B}}}} $, or a pattern match~$ e_{{\\ensuremath{\\mathbb{P}}}} $. If the\nregular expression~$ (e_{c})^{+} $ consists of more than one\nexpression~$ e_{c} $, then the function binds to the first expression\nwhose guard evaluates to \\lstinline!true! (in the order of their\ndeclaration). Furthermore, the special guard \\lstinline!otherwise! can\nbe used, which evaluates to true if and only if all other guards\nevaluate to \\lstinline!false!. Expressions without a guard are\nimplicitly guarded by \\lstinline!true!. All sub-expressions~$ e_{c} $\nneed to have the same type $ {\\ensuremath{\\mathbb{X}}} $. For every instantiation of\na function by given parameters, we view the resulting expression\n$ e_{{\\ensuremath{\\mathbb{X}}}} $ as an identifier in~$ \\Gamma_{{\\ensuremath{\\mathbb{X}}}} $, bound\nto the result of the function application.\n\n\n\n\n \n{\\medskip \\noindent {\\bf {Pattern Matching}.}}\n\\label{sec_patterns}\n\nPattern matches are special guards of the form\n\n\n", "index": 15, "text": "\\begin{equation*}\n  e_{{\\ensuremath{\\mathbb{P}}}} \\equiv \\ \\, \\varphi \\ {\\ensuremath{\\color{codecolor} \\raisebox{-9pt}{\\scalebox{1.7}{\\textasciitilde}}}} \\ \\varphi' ,\n  \\vspace{-0.5em}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"e_{{\\mathbb{P}}}\\equiv\\ \\,\\varphi\\ {\\color{codecolor}\\raisebox{-9.0pt}{%&#10;\\scalebox{1.7}{\\textasciitilde}}}\\ \\varphi^{\\prime},\\vspace{-0.5em}\" display=\"block\"><mrow><mrow><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>P</mi></mrow></msub><mo rspace=\"9.2pt\">\u2261</mo><mrow><mpadded width=\"+5pt\"><mi>\u03c6</mi></mpadded><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\color</mtext></merror><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mpadded width=\"+5pt\"><mpadded depth=\"+9.0pt\" height=\"-9.0pt\" voffset=\"-9.0pt\"><mtext class=\"undefined\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ERROR undefined\">\\scalebox</span></mtext><mtext>1.7~</mtext></mpadded></mpadded><mo>\u2062</mo><msup><mi>\u03c6</mi><mo>\u2032</mo></msup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nLet $ x_{j} $ and $ S_{j} $ be the identifier represented by\n$ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{j}}}}} \\rangle}} $ and the set represented by\n$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{j}}}\\! $, respectively. Further, let\n$ \\bigoplus $ be the mathematical operator corresponding to\n$ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} $. Then, the above expression corresponds to the\nmathematical expression:\n\n\n", "itemtype": "equation", "pos": 27529, "prevtext": "\n\nwhich can be used to describe different behavior depending on the\nstructure of an LTL expression. Hence, a guard~$ e_{{\\ensuremath{\\mathbb{P}}}} $ evaluates\nto \\lstinline!true! if and only if $ \\varphi $ and $ \\varphi' $ are\nstructurally equivalent, with respect to their boolean and temporal\nconnectives. Furthermore, identifier names that are used in\n$ \\varphi' $ need to be fresh, since every identifier expression that\nappears in $ \\varphi' $ is bound to the equivalent sub-expression in\n$ \\varphi $, which is only visible inside the right-hand-side of the\nguard. Furthermore, to improve readability, the special\nidentifier~\\lstinline!_! (wildcard) can be used,\nwhich always remains unbound. To clarify this feature, consider the\nfollowing function declaration:\n\n\\vspace{0.6em}\n\n\\noindent\n\\lstinline!  fun(f) =!\\\\%\n\\vspace{-0.4em}\n\\lstinline!    f !$ \\hspace{-1.5pt} {\\ensuremath{\\color{codecolor} \\raisebox{-9pt}{\\scalebox{1.7}{\\textasciitilde}}}} \\hspace{-1.5pt} $\n\\lstinline! a U _: a!\\\\%\n\\lstinline!    otherwise: X f!\n   \n\\vspace{0.6em}\n\n\\noindent The function $ \\textit{fun} $ gets an LTL formula $ f $ as a\nparameter. If $ f $ is an until formula of the form\n$ \\varphi_{1} \\LTLuntil \\varphi_{2} $, then $ \\textit{fun}(f) $ binds\nto $ \\varphi_{1} $, otherwise $ \\textit{fun}(f) $ binds to\n$ \\LTLnext f $.\n\n\n\n\\subsection{Big Operator Notation}\n\\label{sec:bigoperator}\n\n\nIt is often useful to express parameterized expressions using ``big''\noperators, e.g., we use $ \\Sigma $ to denote a sum over multiple\nsub-expressions, $ \\Pi $ to denote a product, or $ \\bigcup $ to denote\na union. It is also possible to use this kind of notion in this\nspecification format. The corresponding syntax looks as follows:\n\n\n", "index": 17, "text": "\\begin{equation*}\n  {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} \\text{\\lstinline![!} \\, \n  {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{0}}}}} \\rangle}} \\, \n  \\text{\\lstinline!IN!} \\; e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{0}}} \\! \n  \\text{\\lstinline!,!}\\, {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{1}}}}} \\rangle}} \\, \n  \\text{\\lstinline!IN!} \\; e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{1}}} \\! \n  \\text{\\lstinline!,!}\\, \\ldots \\, \n  \\text{\\lstinline!,!} \\,{\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{n}}}}} \\rangle}} \\, \n  \\text{\\lstinline!IN!} \\; e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{n}}} \n  \\text{\\lstinline!]!} \\, e_{{\\ensuremath{\\mathbb{X}}}} \n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"{{{{{{{{{{{{{{{{{\\langle\\text{\\textit{{op}}}\\rangle}\\text{\\lstinline 1}}}\\,{\\langle\\text{%&#10;\\textit{{id${}_{0}$}}}\\rangle}\\,\\text{\\lstinline 1}}}\\;e_{\\mathcal{S}_{{%&#10;\\mathbb{X}}_{0}}}\\!\\text{\\lstinline 1}}}\\,{\\langle\\text{\\textit{{id${}_{1}$}}}%&#10;\\rangle}\\,\\text{\\lstinline 1}}}\\;e_{\\mathcal{S}_{{\\mathbb{X}}_{1}}}\\!\\text{%&#10;\\lstinline 1}}}\\,\\ldots\\,\\text{\\lstinline 1}}}\\,{\\langle\\text{\\textit{{id${}_{%&#10;n}$}}}\\rangle}\\,\\text{\\lstinline 1}}}\\;e_{\\mathcal{S}_{{\\mathbb{X}}_{n}}}\\text%&#10;{\\lstinline 1}}}\\,e_{{\\mathbb{X}}}\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mtext>\ud835\udc5c\ud835\udc5d</mtext></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting\" width=\"+1.7pt\"><mtext>[</mtext></mpadded><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc56\ud835\udc51</mtext><msub><mi/><mn>0</mn></msub></mrow></mrow><mo rspace=\"4.2pt\" stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+2.8pt\"><mrow><mtext>I</mtext><mtext>N</mtext></mrow></mpadded><mo>\u2062</mo><mpadded width=\"-1.7pt\"><msub><mi>e</mi><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><msub><mi>X</mi><mn>0</mn></msub></mrow></msub></msub></mpadded><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting\" width=\"+1.7pt\"><mtext>,</mtext></mpadded><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc56\ud835\udc51</mtext><msub><mi/><mn>1</mn></msub></mrow></mrow><mo rspace=\"4.2pt\" stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+2.8pt\"><mrow><mtext>I</mtext><mtext>N</mtext></mrow></mpadded><mo>\u2062</mo><mpadded width=\"-1.7pt\"><msub><mi>e</mi><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><msub><mi>X</mi><mn>1</mn></msub></mrow></msub></msub></mpadded><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting\" width=\"+1.7pt\"><mtext>,</mtext></mpadded><mo>\u2062</mo><mpadded width=\"+1.7pt\"><mi mathvariant=\"normal\">\u2026</mi></mpadded><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting\" width=\"+1.7pt\"><mtext>,</mtext></mpadded><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mrow><mtext>\ud835\udc56\ud835\udc51</mtext><msub><mi/><mi>n</mi></msub></mrow></mrow><mo rspace=\"4.2pt\" stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting ltx_lst_identifier\" width=\"+2.8pt\"><mrow><mtext>I</mtext><mtext>N</mtext></mrow></mpadded><mo>\u2062</mo><msub><mi>e</mi><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><msub><mi>X</mi><mi>n</mi></msub></mrow></msub></msub><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mo>\u2062</mo><mpadded class=\"ltx_lstlisting\" width=\"+1.7pt\"><mtext>]</mtext></mpadded><mo>\u2062</mo><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>X</mi></mrow></msub></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nNote that $ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{0}}}}} \\rangle}} $ is already bound in\nexpression $ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{1}}} \\!$,\n$ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{1}}}}} \\rangle}} $ is bound in\n$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{2}}} \\!$, and so forth. The syntax is\nsupported by every operator\n$ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} \\in \\{ \\text{\\lstinline!+!},\n\\text{\\lstinline!*!}, \\text{\\lstinline!(+)!},\n\\text{\\lstinline!(*)!}, \\text{\\lstinline!&&!},\n\\text{\\lstinline!||!} \\} $.\n\n\\subsection{Syntactic Sugar}\n\\label{sec:syntacticsugar}\n\nTo improve readability, there is additional syntactic sugar, which can\nbe used beside the standard syntax. Let $ n $ and $ m $ be numerical\nexpressions, then\n\n\\begin{itemize}\n\n\\item \\lstinline!X[!$ n $\\lstinline!]!$ \\; \\varphi $ denotes a stack\n  of $ n $ next operations, e.g.: \\[0.5em]\n  \\lstinline!  X[3] a!$ \\ \\, \\equiv \\ \\, $ \\lstinline!X X X a!\n\n\\item \\lstinline!F[!$ n $\\lstinline!:!$ m $\\lstinline!]!$ \\; \\varphi $\n  denotes that $ \\varphi $ holds somewhere between the next $ n $ and\n  $ m $ steps, e.g.: \\[0.5em]\n  \\lstinline!  F[2:3] a!$ \\ \\, \\equiv \\ \\, $\\lstinline!X X(a || X a)!\n\n\\item \\lstinline!G[!$ n $\\lstinline!:!$ m $\\lstinline!]!$ \\; \\varphi $\n  denotes that $ \\varphi $ holds everywhere between the next $ n $ and\n  $ m $ steps, e.g.: \\[0.5em]\n  \\lstinline!  G[1:3] a!$ \\ \\, \\equiv \\ \\, $\\lstinline!X(a && X(a && X a))!\n\n\\item $ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} $\\lstinline![!$ \\, \\ldots $\\lstinline!,!$ \\, n \\, \\circ_{1} \n  {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} \\circ_{2} \\, m \\, $\\lstinline!,!$ \\ldots $\\lstinline!]!$ \\, e_{X} $\n  denotes a big operator application, where  $ n \\, \\circ_{1} {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} \n  \\circ_{2} \\, m $ with $ \\circ_{1}, \\circ_{2} \\in \\{ \\text{\\lstinline!<!},\n  \\text{\\lstinline!<=!} \\} $ denotes that {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} ranges from $ n $ to\n  $ m $. Thereby, the inclusion of $ n $ and $ m $ depends on the\n  choice of $ \\circ_{1} $ and $ \\circ_{2} $, respectively. Thus, the\n  notation provides an alternative to membership in combination with\n  set ranges, e.g.: \\[0.5em]\n  \\lstinline!  &&[0 <= i < n] b[i]!$ \\ \\, \\equiv \\ \\, \n  $\\lstinline!&&[i IN {0,1..n-1}] b[i]!\n  \n  \n  \n  \n  \n\n\\end{itemize}\n\n\\subsection{Comments}\n\\label{sec:comments}\n\nIt is possible to use C style comments anywhere in the specification,\ni.e., there are single line comments initialized by \\lstinline!//! and\nmulti line comments between \\lstinline!/*! and\n\\lstinline!*/!.  Multi line comments can be nested.\n\n\\newpage\n\n\\section{Example: A Parameterized Arbiter}\n\\label{sec:example}\n\nTo get some feeling for the interplay of the aforementioned features,\nconsider the following example specification of a parameterized\narbiter.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  INFO!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline!    TITLE!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:       !\n\\lstinline[stringstyle=\\ttfamily\\color{red!30!orange!80!black}]!\"A Parameterized Arbiter\"!\\\\%\n\\lstinline!    DESCRIPTION!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!: !\n\\lstinline[stringstyle=\\ttfamily\\color{red!30!orange!80!black}]!\"An arbiter, parameterized in the number of clients\"!\\\\%\n\\lstinline!    SEMANTICS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:   !\n\\lstinline[identifierstyle=\\ttfamily\\color{gray!70!black}]!Mealy!\\\\%\n\\lstinline!    TARGET!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:      !\n\\lstinline[identifierstyle=\\ttfamily\\color{gray!70!black}]!Mealy!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\\\\%\n\\lstinline!  !\\\\%\n\\lstinline!  GLOBAL !\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!{!\\\\%\n\\lstinline!    PARAMETERS !\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!{!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // two clients!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      n!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! = 2;!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    DEFINITIONS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // mutual exclusion!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      mutual!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]!(b) =!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!        ||!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]![i !\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!IN!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {0,1..n-1}]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!          &&!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]![j !\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!IN!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {0,1..n-1} !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!(\\)!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {i}]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]~            !~\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!(b[i] !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!&&!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! b[j]);!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // the Request-Response condition!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      reqres!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!(req,res) =!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!        G!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! (req !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black},identifierstyle=\\ttfamily\\color{cyan!50!black}]!-> F!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! res);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\\\\%\n\\lstinline!  !\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!  /* Ensure mutual exclusion on the output bus and guarantee!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{orange!60!black},identifierstyle=\\ttfamily\\color{orange!60!black}]!     that each request on the input bus is eventually granted */!\\\\%\n\\lstinline!  MAIN!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline!    INPUTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      r!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![n];!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    OUTPUTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      g!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![n];!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    INVARIANTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!      mutual(g);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    GUARANTEES!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!      &&!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![0 <= i < n]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!        reqres(r[i],g[i]);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\n\n\\vspace{1em}\n\n\\noindent The example is parameterized in the number of clients~$ n $\n(here: $ n = 2 $). Furthermore, it uses two functions:\n$ \\textit{mutual}(b) $, which ensures mutual exclusions on the signals\nof a bus~$ b $ of width~$ n $, and\n$ \\textit{reqres}(\\textit{req}, \\textit{res}) $, which ensures that\nevery request~$ \\textit{req} $ is eventually followed by some\nresponse~$ \\textit{res} $. In the final specification, both conditions\nare then combined over the inputs $ r_{i} $ and outputs $ g_{i} $.\n\n\\section{The SyFCo Tool}\n\\label{sec:tool}\n\nWe created a Synthesis Format Conversion Tool (SyFCo)~\\cite{SyFCo}\nthat can interpret the high level constructs of the format and\nsupports transformation of the specification back to plain LTL. The\ntool has been designed to be modular with respect to the supported\noutput formats and semantics. Furthermore, the tool can identify and\nmanipulate parameters, targets and semantics of a specification on the\nfly, and thus allows comparative studies, as it is for example needed\nin the Synthesis Competition.\n\n\\vspace{1em}\n\n\\noindent The main features of the tool can be summarized as follows:\n\n\\begin{itemize}\n\n\\item Evaluation of high level constructs in the full format to reduce\n  full TLSF to basic TLSF.\n\n\\item Transformation to other existing specification formats, like\n  Promela LTL~\\cite{PromelaLTL}, PSL~\\cite{EF2006},\n  Unbeast~\\cite{E2010}, or Wring~\\cite{SomenziB00}.\n\n\\item On the fly adjustment of parameters, semantics or targets.\n\n\\item Preprocessing of the resulting LTL formula\n\n\\begin{itemize}\n\n\\item[$ \\circ $] conversion to negation normal form\n\n\\item[$ \\circ $] replacement of derived operators\n\n\\item[$ \\circ $] pushing/pulling next, eventually, or globally operators inwards/outwards\n\n\\item[$ \\circ $] $ \\ldots $ \\raisebox{-8pt}{\\ }\n\n\\end{itemize}\n\n\\end{itemize}\n\n\\section{Extensions}\n\\label{sec:extensions}\n\nThe format remains open for further extensions, which allow more fine\ngrained control over the specification with respect to a particular\nsynthesis problem. At the current time of writing, the following\nextensions were under consideration:\n\n\\begin{itemize}\n\n\\item Compositionality: The possibility to separate specifications\n  into multiple components, which then can be used as building blocks\n  to specify larger components.\n\t\n\\item Partial Implementations: a specification that is separated into\n  multiple components might also contain components that are already\n  implemented. Implemented components could be given in the AIGER\n  format that is already used in SYNTCOMP~\\cite{SYNTCOMP-format}.\n\n\\item Additional syntactic sugar, like enumerations or arithmetic on\n  busses.\n\n\\end{itemize}\n\n\\section*{Acknowledgments}\n\nWe thank Sebastian Schirmer, who supported us with the results of his\nBachelor Thesis~\\cite{THSEBSCH}, to resolve many design decisions\nthat came up during the development of this format. We thank Roderick Bloem, \nR\\\"udiger Ehlers, Bernd Finkbeiner, Ayrat Khalimov, Robert K\\\"onighofer, Nir \nPiterman, and Leander Tentrup for comments on the TSLF and drafts of this \ndocument.\n\n\\bibliographystyle{plain}\n\\bibliography{biblio}\n\n\\newpage\n\\appendix\n\n\\section{Appendix}\n\n\\subsection{Linear Temporal Logic}\n\\label{apx_ltl}\n\nLinear Temporal Logic (LTL) is a temporal logic, defined over a finite\nset of atomic propositions~$ \\text{AP} $. The syntax of LTL conforms to the\nfollowing grammar:\n\n\n", "itemtype": "equation", "pos": 28673, "prevtext": "\n\nLet $ x_{j} $ and $ S_{j} $ be the identifier represented by\n$ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{j}}}}} \\rangle}} $ and the set represented by\n$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{j}}}\\! $, respectively. Further, let\n$ \\bigoplus $ be the mathematical operator corresponding to\n$ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} $. Then, the above expression corresponds to the\nmathematical expression:\n\n\n", "index": 19, "text": "\\begin{equation*}\n  \\bigoplus\\limits_{x_{0} \\in S_{0}} \\ \n  \\bigoplus\\limits_{x_{1} \\in S_{1}} \\ \\cdots \\ \n  \\bigoplus\\limits_{x_{n} \\in S_{n}}\n  \\big( e_{{\\ensuremath{\\mathbb{X}}}} )\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\bigoplus\\limits_{x_{0}\\in S_{0}}\\ \\bigoplus\\limits_{x_{1}\\in S_{1}}\\ \\cdots\\ %&#10;\\bigoplus\\limits_{x_{n}\\in S_{n}}\\big{(}e_{{\\mathbb{X}}})\" display=\"block\"><mrow><mpadded width=\"+5pt\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>\u2208</mo><msub><mi>S</mi><mn>0</mn></msub></mrow></munder></mpadded><mrow><mpadded width=\"+5pt\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>\u2208</mo><msub><mi>S</mi><mn>1</mn></msub></mrow></munder></mpadded><mrow><mpadded width=\"+5pt\"><mi mathvariant=\"normal\">\u22ef</mi></mpadded><mo>\u2062</mo><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u2295</mo><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>\u2208</mo><msub><mi>S</mi><mi>n</mi></msub></mrow></munder><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><msub><mi>e</mi><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\mathbb</mtext></merror><mo>\u2062</mo><mi>X</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.05228.tex", "nexttext": "\n\nThe semantics of LTL are defined over infinite\nwords~$ \\alpha = \\alpha_{0}\\alpha_{1}\\alpha_{2}\\dots \\in\n(2^{\\text{AP}})^{\\omega} $.\nA word~$ \\alpha $ satisfies a formula~$ \\varphi $ at position\n$ i \\in {\\ensuremath{\\mathbb{N}}} $:\n\n\\begin{itemize}\n\n\\item $ \\alpha, i \\vDash \\textit{true} $ \n\n\\item $ \\alpha, i \\vDash p $ \\ iff \\ $ p \\in \\alpha_{i} $\n\n\\item $ \\alpha, i \\vDash \\neg \\varphi $ \\ iff \\\n  $ \\alpha, i \\not\\vDash \\varphi $\n\n\\item $ \\alpha, i \\vDash \\varphi_{1} \\vee \\varphi_{2} $ \\ iff \\\n  $ \\alpha, i \\vDash \\varphi_{1} $ or $ \\alpha, i \\vDash \\varphi_{2} $\n\n\\item $ \\alpha, i \\vDash \\LTLnext \\varphi $ \\ iff \\\n  $ \\alpha, i + 1 \\vDash \\varphi $\n\n\\item $ \\alpha, i \\vDash \\varphi_{1} \\LTLuntil \\varphi_{2} $ \\ iff \\\n  $ \\exists n \\geq i.\\ \\alpha, n \\vDash \\varphi_{2} $ and\n  $ \\forall i \\leq j < n.\\ \\alpha, j \\vDash \\varphi_{1} $\n\n\\end{itemize}\n\n\\noindent A word~$ \\alpha \\in 2^{\\text{AP}} $\nsatisfies a formula~$ \\varphi $ iff $ \\alpha, 0 \\vDash \\varphi $.\nBeside the standard operators, we have the following derived operators:\n\n\\begin{itemize}\n\n\\item\n  $ \\varphi_{1} \\wedge \\varphi_{2} \\equiv \\neg(\\neg \\varphi_{1} \\vee\n  \\neg \\varphi_{2}) $\n\n\\item\n  $ \\varphi_{1} \\rightarrow \\varphi_{2} \\equiv \\neg \\varphi_{1} \\vee\n  \\varphi_{2} $\n\n\\item\n  $ \\varphi_{1} \\leftrightarrow \\varphi_{2} \\equiv (\\varphi_{1}\n  \\rightarrow \\varphi_{2}) \\wedge (\\varphi_{2} \\rightarrow\n  \\varphi_{1}) $\n\n\\item\n  $ \\LTLeventually \\varphi \\equiv \\text{\\textit{true}} \\LTLuntil\n  \\varphi $\n\n\\item $ \\LTLglobally \\varphi \\equiv \\neg \\LTLeventually \\neg \\varphi $\n\n\\item\n  $ \\varphi_{1} \\LTLrelease \\varphi_{2} \\equiv \\neg(\\neg \\varphi_{1}\n  \\LTLuntil \\neg \\varphi_{2}) $\n\n\\item\n  $ \\varphi_{1} \\LTLweakuntil \\varphi_{2} \\equiv (\\varphi_{1}\n  \\LTLuntil \\varphi_{2}) \\vee \\LTLglobally \\varphi_{1} $\n\n\\end{itemize}\n\n\\subsection{Mealy and Moore Automata}\n\\label{apx_memo}\n\nA Mealy automaton is a tuple\n$ \\mathcal{M}_{e} = ({\\ensuremath{\\mathcal{I}}}, {\\ensuremath{\\mathcal{O}}}, Q, q_{0}, \\delta, \\lambda_{e})\n$, where\n\n\\begin{itemize}\n\n\\item $ {\\ensuremath{\\mathcal{I}}} $ is a finite set of input letters,\n\n\\item $ {\\ensuremath{\\mathcal{O}}} $ is a finite set of output letters,\n\n\\item $ Q $ is finite set of states,\n\n\\item $ q_{0} \\in Q $ is the initial state,\n\n\\item $ \\delta \\colon Q \\times {\\ensuremath{\\mathcal{I}}} \\rightarrow Q $ is the\n  transition function, and\n\n\\item\n  $ \\lambda_{e} \\colon Q \\times {\\ensuremath{\\mathcal{I}}} \\rightarrow {\\ensuremath{\\mathcal{O}}} $\n  is the output function.\n\n\\end{itemize}\n\n\\noindent Hence, the output depends on the current state of the\nautomaton and the last input letter.\n\n\\bigskip\n\n\\noindent A Moore automaton is a tuple\n$ \\mathcal{M}_{o} = ({\\ensuremath{\\mathcal{I}}}, {\\ensuremath{\\mathcal{O}}}, Q, q_{0}, \\delta, \\lambda_{o})\n$,\nwhere $ {\\ensuremath{\\mathcal{I}}}, {\\ensuremath{\\mathcal{O}}}, Q, q_{0} $ and $ \\delta $ are defined as\nfor Mealy automata. However, the output function\n$ \\lambda_{o} \\colon Q \\rightarrow {\\ensuremath{\\mathcal{O}}} $ determines the current\noutput only on the current state of the automaton, but not the last\ninput.\n\n\\subsection{Operator Precedence, Alternative Operators}\n\\label{apx_precedence}\n\nThe following table lists the precedence, arity and associativity of\nall expression operators. Also consider the alternative names in\nbrackets which can be used instead of the symbolic representations.\n\n\n\\begin{center}\n  \\centering\n\n  \\begin{tabular}{|c|l|l|c|c|}\n    \\hline \n    \\textbf{Precedence} & \\textbf{Operator} & \\textbf{Description} & \\textbf{Arity} &  \\textbf{Associativity} \\\\\n    \\hline\n    \\hline\n    \\multirow{6}{*}{1} & \\lstinline!+[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!SUM[!$ \\cdot $\\lstinline!]!) & sum & \\multirow{6}{*}{unary} & \\\\\n      & \\lstinline!*[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!PROD[!$ \\cdot $\\lstinline!]!) & product & & \\\\\n      & \\lstinline!|!$ \\cdots $\\lstinline!|!\\ (\\lstinline!SIZE!) & size & & \\\\\n      & \\lstinline!MIN! & minimum & & \\\\\n      & \\lstinline!MAX! & maximum & & \\\\\n      & \\lstinline!SIZEOF! & size of a bus & & \\\\\n    \\hline\n    2 & \\lstinline!*!\\ (\\lstinline!MUL!) & multiplication & binary & left-to-right \\\\\n    \\hline\n    \\multirow{2}{*}{3} & \\lstinline!/!\\ (\\lstinline!DIV!) & integer division & \\multirow{2}{*}{binary} & \\multirow{2}{*}{right-to-left} \\\\\n      & \\lstinline!\n    \\hline\n    \\multirow{2}{*}{4} & \\lstinline!+!\\ (\\lstinline!PLUS!) & addition & \\multirow{2}{*}{binary} & \\multirow{2}{*}{left-to-right} \\\\\n      & \\lstinline!-!\\ (\\lstinline!MINUS!) & difference & & \\\\\n    \\hline \n    \\multirow{2}{*}{5} & \\lstinline!(*)[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!CAP[!$ \\cdot $\\lstinline!]!) & intersection & \\multirow{2}{*}{unary} & \\\\\n      & \\lstinline!(+)[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!CUP[!$ \\cdot $\\lstinline!]!) & union &  & \\\\\n    \\hline\n    6 & \\lstinline!(\\)!\\ (\\lstinline!(-)!,\\lstinline!SETMINUS!) & set difference & binary & right-to-left \\\\\n    \\hline\n    7 & \\lstinline!(*)!\\ (\\lstinline!CAP!) & intersection & binary & left-to-right \\\\\n    \\hline\n    8 & \\lstinline!(+)! (\\lstinline!CUP!) & union & binary & left-to-right \\\\\n    \\hline\n    \\multirow{6}{*}{9} & \\lstinline!==!\\ (\\lstinline!EQ!) & equality & \\multirow{6}{*}{binary} & \\multirow{6}{*}{left-to-right} \\\\\n      & \\lstinline~!=~\\ (\\lstinline!/=!, \\lstinline!NEQ!) & inequality & & \\\\\n      & \\lstinline!<!\\ (\\lstinline!LE!) & smaller than & & \\\\\n      & \\lstinline!<=!\\ (\\lstinline!LEQ!) & smaller or equal than & & \\\\\n      & \\lstinline!>!\\ (\\lstinline!GE!) & greater then & & \\\\\n      & \\lstinline!>=!\\ (\\lstinline!GEG!) & greater or equal than & & \\\\\n    \\hline\n    10 & \\lstinline!IN!\\ (\\lstinline!ELEM!, \\lstinline!<-!) & membership & binary & left-to-right \\\\\n    \\hline\n    \\multirow{6}{*}{11} & \\lstinline~!~\\ (\\lstinline!NOT!) & negation & \\multirow{6}{*}{unary} & \\\\\n       & \\lstinline!X! & next & & \\\\\n       & \\lstinline!F! & finally & & \\\\\n       & \\lstinline!G! & globally & & \\\\\n       & \\lstinline!&&[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!AND[!$ \\cdot $\\lstinline!]!, \\lstinline!FORALL[!$ \\cdot $\\verb!]!) & conjunction & & \\\\\n       & \\lstinline!||[!$ \\cdot $\\lstinline!]!\\ (\\lstinline!OR[!$ \\cdot $\\lstinline!]!, \\lstinline!EXISTS[!$ \\cdot $\\verb!]!) & disjunction & & \\\\\n    \\hline\n    12 & \\lstinline!&&!\\ (\\lstinline!AND!) & conjunction & binary & left-to-right \\\\\n    \\hline\n    13 & \\lstinline!||!\\ (\\lstinline!OR!) & disjunction & binary & left-to-right \\\\     \n    \\hline\n    \\multirow{2}{*}{14} & \\lstinline!->!\\ (\\lstinline!IMPLIES!) & implication & \\multirow{2}{*}{binary} & \\multirow{2}{*}{right-to-left} \\\\   \n       & \\lstinline!<->!\\ (\\lstinline!EQUIV!) & equivalence &  & \\\\     \n    \\hline\n    15 & \\lstinline!W! & weak until & binary & right-to-left \\\\\n    \\hline\n    16 & \\lstinline!U! & until & binary & right-to-left \\\\\n    \\hline\n    17 & \\lstinline!R! & release & binary & left-to-right \\\\\n    \\hline\n    18 & \\!{\\color{blue!70!black}\\raisebox{-9pt}{\\scalebox{1.7}{\\textasciitilde}}} \\vspace{-5pt} & pattern match & binary & left-to-right \\\\\n    \\hline\n    19 & \\lstinline!:! & guard & binary & left-to-right \\\\    \n    \\hline\n  \\end{tabular}\n\\end{center}\n\n\n", "itemtype": "equation", "pos": 40300, "prevtext": "\n\nNote that $ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{0}}}}} \\rangle}} $ is already bound in\nexpression $ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{1}}} \\!$,\n$ {\\ensuremath{\\langle \\text{\\textit{{id\\ensuremath{_{1}}}}} \\rangle}} $ is bound in\n$ e_{\\mathcal{S}_{{\\ensuremath{\\mathbb{X}}}_{2}}} \\!$, and so forth. The syntax is\nsupported by every operator\n$ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} \\in \\{ \\text{\\lstinline!+!},\n\\text{\\lstinline!*!}, \\text{\\lstinline!(+)!},\n\\text{\\lstinline!(*)!}, \\text{\\lstinline!&&!},\n\\text{\\lstinline!||!} \\} $.\n\n\\subsection{Syntactic Sugar}\n\\label{sec:syntacticsugar}\n\nTo improve readability, there is additional syntactic sugar, which can\nbe used beside the standard syntax. Let $ n $ and $ m $ be numerical\nexpressions, then\n\n\\begin{itemize}\n\n\\item \\lstinline!X[!$ n $\\lstinline!]!$ \\; \\varphi $ denotes a stack\n  of $ n $ next operations, e.g.: \\[0.5em]\n  \\lstinline!  X[3] a!$ \\ \\, \\equiv \\ \\, $ \\lstinline!X X X a!\n\n\\item \\lstinline!F[!$ n $\\lstinline!:!$ m $\\lstinline!]!$ \\; \\varphi $\n  denotes that $ \\varphi $ holds somewhere between the next $ n $ and\n  $ m $ steps, e.g.: \\[0.5em]\n  \\lstinline!  F[2:3] a!$ \\ \\, \\equiv \\ \\, $\\lstinline!X X(a || X a)!\n\n\\item \\lstinline!G[!$ n $\\lstinline!:!$ m $\\lstinline!]!$ \\; \\varphi $\n  denotes that $ \\varphi $ holds everywhere between the next $ n $ and\n  $ m $ steps, e.g.: \\[0.5em]\n  \\lstinline!  G[1:3] a!$ \\ \\, \\equiv \\ \\, $\\lstinline!X(a && X(a && X a))!\n\n\\item $ {\\ensuremath{\\langle \\text{\\textit{{op}}} \\rangle}} $\\lstinline![!$ \\, \\ldots $\\lstinline!,!$ \\, n \\, \\circ_{1} \n  {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} \\circ_{2} \\, m \\, $\\lstinline!,!$ \\ldots $\\lstinline!]!$ \\, e_{X} $\n  denotes a big operator application, where  $ n \\, \\circ_{1} {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} \n  \\circ_{2} \\, m $ with $ \\circ_{1}, \\circ_{2} \\in \\{ \\text{\\lstinline!<!},\n  \\text{\\lstinline!<=!} \\} $ denotes that {\\ensuremath{\\langle \\text{\\textit{{id}}} \\rangle}} ranges from $ n $ to\n  $ m $. Thereby, the inclusion of $ n $ and $ m $ depends on the\n  choice of $ \\circ_{1} $ and $ \\circ_{2} $, respectively. Thus, the\n  notation provides an alternative to membership in combination with\n  set ranges, e.g.: \\[0.5em]\n  \\lstinline!  &&[0 <= i < n] b[i]!$ \\ \\, \\equiv \\ \\, \n  $\\lstinline!&&[i IN {0,1..n-1}] b[i]!\n  \n  \n  \n  \n  \n\n\\end{itemize}\n\n\\subsection{Comments}\n\\label{sec:comments}\n\nIt is possible to use C style comments anywhere in the specification,\ni.e., there are single line comments initialized by \\lstinline!//! and\nmulti line comments between \\lstinline!/*! and\n\\lstinline!*/!.  Multi line comments can be nested.\n\n\\newpage\n\n\\section{Example: A Parameterized Arbiter}\n\\label{sec:example}\n\nTo get some feeling for the interplay of the aforementioned features,\nconsider the following example specification of a parameterized\narbiter.\n\n\\vspace{1em}\n\n\\noindent\n\\lstinline!  INFO!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline!    TITLE!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:       !\n\\lstinline[stringstyle=\\ttfamily\\color{red!30!orange!80!black}]!\"A Parameterized Arbiter\"!\\\\%\n\\lstinline!    DESCRIPTION!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!: !\n\\lstinline[stringstyle=\\ttfamily\\color{red!30!orange!80!black}]!\"An arbiter, parameterized in the number of clients\"!\\\\%\n\\lstinline!    SEMANTICS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:   !\n\\lstinline[identifierstyle=\\ttfamily\\color{gray!70!black}]!Mealy!\\\\%\n\\lstinline!    TARGET!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!:      !\n\\lstinline[identifierstyle=\\ttfamily\\color{gray!70!black}]!Mealy!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\\\\%\n\\lstinline!  !\\\\%\n\\lstinline!  GLOBAL !\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!{!\\\\%\n\\lstinline!    PARAMETERS !\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!{!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // two clients!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      n!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! = 2;!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    DEFINITIONS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // mutual exclusion!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      mutual!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]!(b) =!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!        ||!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]![i !\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!IN!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {0,1..n-1}]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!          &&!\n\\lstinline[identifierstyle=\\ttfamily\\color{black},basicstyle=\\ttfamily\\color{black}]![j !\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!IN!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {0,1..n-1} !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!(\\)!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! {i}]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]~            !~\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!(b[i] !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!&&!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! b[j]);!\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!      // the Request-Response condition!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      reqres!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!(req,res) =!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{cyan!50!black}]!        G!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! (req !\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black},identifierstyle=\\ttfamily\\color{cyan!50!black}]!-> F!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]! res);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\\\\%\n\\lstinline!  !\\\\%\n\\lstinline[commentstyle=\\ttfamily\\color{orange!60!black}]!  /* Ensure mutual exclusion on the output bus and guarantee!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{orange!60!black},identifierstyle=\\ttfamily\\color{orange!60!black}]!     that each request on the input bus is eventually granted */!\\\\%\n\\lstinline!  MAIN!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline!    INPUTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      r!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![n];!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    OUTPUTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[identifierstyle=\\ttfamily\\color{green!50!black}]!      g!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![n];!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    INVARIANTS!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!      mutual(g);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\%\n\\lstinline!    GUARANTEES!\n\\lstinline[basicstyle=\\ttfamily\\color{black}]! {!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{cyan!50!black}]!      &&!\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]![0 <= i < n]!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black},identifierstyle=\\ttfamily\\color{black}]!        reqres(r[i],g[i]);!\\\\%\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!    }!\\\\\n\\lstinline[basicstyle=\\ttfamily\\color{black}]!  }!\n\n\\vspace{1em}\n\n\\noindent The example is parameterized in the number of clients~$ n $\n(here: $ n = 2 $). Furthermore, it uses two functions:\n$ \\textit{mutual}(b) $, which ensures mutual exclusions on the signals\nof a bus~$ b $ of width~$ n $, and\n$ \\textit{reqres}(\\textit{req}, \\textit{res}) $, which ensures that\nevery request~$ \\textit{req} $ is eventually followed by some\nresponse~$ \\textit{res} $. In the final specification, both conditions\nare then combined over the inputs $ r_{i} $ and outputs $ g_{i} $.\n\n\\section{The SyFCo Tool}\n\\label{sec:tool}\n\nWe created a Synthesis Format Conversion Tool (SyFCo)~\\cite{SyFCo}\nthat can interpret the high level constructs of the format and\nsupports transformation of the specification back to plain LTL. The\ntool has been designed to be modular with respect to the supported\noutput formats and semantics. Furthermore, the tool can identify and\nmanipulate parameters, targets and semantics of a specification on the\nfly, and thus allows comparative studies, as it is for example needed\nin the Synthesis Competition.\n\n\\vspace{1em}\n\n\\noindent The main features of the tool can be summarized as follows:\n\n\\begin{itemize}\n\n\\item Evaluation of high level constructs in the full format to reduce\n  full TLSF to basic TLSF.\n\n\\item Transformation to other existing specification formats, like\n  Promela LTL~\\cite{PromelaLTL}, PSL~\\cite{EF2006},\n  Unbeast~\\cite{E2010}, or Wring~\\cite{SomenziB00}.\n\n\\item On the fly adjustment of parameters, semantics or targets.\n\n\\item Preprocessing of the resulting LTL formula\n\n\\begin{itemize}\n\n\\item[$ \\circ $] conversion to negation normal form\n\n\\item[$ \\circ $] replacement of derived operators\n\n\\item[$ \\circ $] pushing/pulling next, eventually, or globally operators inwards/outwards\n\n\\item[$ \\circ $] $ \\ldots $ \\raisebox{-8pt}{\\ }\n\n\\end{itemize}\n\n\\end{itemize}\n\n\\section{Extensions}\n\\label{sec:extensions}\n\nThe format remains open for further extensions, which allow more fine\ngrained control over the specification with respect to a particular\nsynthesis problem. At the current time of writing, the following\nextensions were under consideration:\n\n\\begin{itemize}\n\n\\item Compositionality: The possibility to separate specifications\n  into multiple components, which then can be used as building blocks\n  to specify larger components.\n\t\n\\item Partial Implementations: a specification that is separated into\n  multiple components might also contain components that are already\n  implemented. Implemented components could be given in the AIGER\n  format that is already used in SYNTCOMP~\\cite{SYNTCOMP-format}.\n\n\\item Additional syntactic sugar, like enumerations or arithmetic on\n  busses.\n\n\\end{itemize}\n\n\\section*{Acknowledgments}\n\nWe thank Sebastian Schirmer, who supported us with the results of his\nBachelor Thesis~\\cite{THSEBSCH}, to resolve many design decisions\nthat came up during the development of this format. We thank Roderick Bloem, \nR\\\"udiger Ehlers, Bernd Finkbeiner, Ayrat Khalimov, Robert K\\\"onighofer, Nir \nPiterman, and Leander Tentrup for comments on the TSLF and drafts of this \ndocument.\n\n\\bibliographystyle{plain}\n\\bibliography{biblio}\n\n\\newpage\n\\appendix\n\n\\section{Appendix}\n\n\\subsection{Linear Temporal Logic}\n\\label{apx_ltl}\n\nLinear Temporal Logic (LTL) is a temporal logic, defined over a finite\nset of atomic propositions~$ \\text{AP} $. The syntax of LTL conforms to the\nfollowing grammar:\n\n\n", "index": 21, "text": "\\begin{equation*}\n  \\varphi \\ \\ := \\ \\ \\text{\\textit{true}} {\\ensuremath{\\ \\ | \\ \\ }}  p \\in \\text{AP}\n  {\\ensuremath{\\ \\ | \\ \\ }} \\neg \\varphi {\\ensuremath{\\ \\ | \\ \\ }} \\varphi \\vee \\varphi\n  {\\ensuremath{\\ \\ | \\ \\ }} \\LTLnext \\varphi {\\ensuremath{\\ \\ | \\ \\ }} \\varphi \\LTLuntil \\varphi\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\varphi\\ \\ :=\\ \\ \\text{\\textit{true}}{\\ \\ |\\ \\ }p\\in\\text{AP}{\\ \\ |\\ \\ }\\neg%&#10;\\varphi{\\ \\ |\\ \\ }\\varphi\\vee\\varphi{\\ \\ |\\ \\ }\\LTLnext\\varphi{\\ \\ |\\ \\ }%&#10;\\varphi\\LTLuntil\\varphi\" display=\"block\"><mrow><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo>:=</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mtext>\ud835\udc61\ud835\udc5f\ud835\udc62\ud835\udc52</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>p</mi><mo>\u2208</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\text</mtext></merror><mi>A</mi><mi>P</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi mathvariant=\"normal\">\u00ac</mi><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>\u03c6</mi><mo>\u2228</mo><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\LTLnext</mtext></merror><mi>\u03c6</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mo stretchy=\"false\">|</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>\u03c6</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\LTLuntil</mtext></merror><mi>\u03c6</mi></mrow></math>", "type": "latex"}]