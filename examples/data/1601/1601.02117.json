[{"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 11600, "prevtext": "\n\\begin{titlepage}\n\n  \\begin{center}\n    \\includegraphics[width=0.2\\textwidth]{./lapps_logo.pdf}\\[1cm]\n\n    {\\rule{\\linewidth}{0.5mm}} \\[0.4cm]\n    {\\huge \\bfseries Location Aware Password\\[0.2cm] Protection System}\\[0.4cm]\n    {\\rule{\\linewidth}{0.5mm}} \\[1.5cm]\n\n\n    \\textsc{\\LARGE University Of Essex}\\[0.5cm]\n    \\textsc{\\LARGE The Department of Computer\\[0.2cm] Science and Electronic Engineering}\\[1.5cm]\n\n    \\begin{minipage}{0.4\\textwidth}\n      \\begin{flushleft} \\large\n        \\emph{Author:}\\\\\n        Chathura M. \\textsc{Sarathchandra Magurawalage}\n      \\end{flushleft}\n    \\end{minipage}\n    \\begin{minipage}{0.4\\textwidth}\n      \\begin{flushright} \\large\n        \\emph{Supervisor:}\\\\\n        Prof.~Kun \\textsc{Yang}\n      \\end{flushright}\n    \\end{minipage}\n\n    \\vfill\n\n  \\end{center}\n\\end{titlepage}\n\n\\begin{abstract}\n  \\begin{itshape}\n    This report describes the design and the implementation of a password\n    protection system that has been proposed as an idea then developed\n    by the author for his undergraduate final year project, at the University of Essex. \n\n    When designing the system the author has concentrated on adding\n    extra layers of security to the traditional security systems\n    without having to completely replace the existing security systems.\n\n    \\gls{lapps} is designed to strengthen the security of traditional password\n    protection systems. This is achieved by adding several layers of\n    protection to the passwords that most traditional password protection\n    systems generate. The current implementation looks at the \n    Password/Pin numbers of Credit/Debit cards that are used on\n    \\gls{atm},though the underlying design of\n    the system can be used in many  other scenarios. A password that\n    is generated will be allocated to a particular user and to the \\gls{atm}\n    that is nearest to the user. \\gls{lapps} ensures the following qualities\n    of the passwords that it generates.\n\n    \\begin{itemize}\n    \\item Location Awareness\n\n      The passwords are generated according to the user's geographical area,\n      that they request their passwords from. So a password will only be\n      active in just one location.\n\n    \\item Time Awareness:\n\n      A password will only be valid for five minutes. The unused passwords\n      will be discarded.\n\n    \\item  Dynamic\n\n      The user has to have a new password each time he/she logs in. A\n      password is generated to be used only once. \n\n    \\item  User Oriented/Specific\n\n      The received password can only be used by the requester, and can only\n      be used on its allocated \\gls{atm}.\n\n    \\item Two Factor Authenticity\n\n      The confidential information will be secured using two-factor\n      authentication.\n    \\end{itemize}\n    For extra security, a Pin generating device has been introduced. This will\n    produce an eight digit number that the user has to supply to the\n    mobile application, before requesting for a password. The user\n    can obtain a pin number by inserting his/her Debit/Credit card and the\n    fixed password that has been allocated when the user registers\n    with the system.\n  \\end{itshape}\n\\end{abstract}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\tableofcontents\n\n\\printglossaries\n\n\\section{Introduction}\n\nWith the increasing security issues in the modern password protection systems,\nthe security experts are concerned about their passwords more than\nthey did few years back. With the increasing possible computing power,\nattackers are able to carry out multitudinous attacks on the passwords in a\nsmall amount of time.(E.g. brute force attack).\n\nWith the advancements of the malicious attacks, it is almost hard to\ntrust the security of your confidential information that has been\nsecured only using long term fixed passwords. As a solution\n\\gls{lapps} adds varied layers of security to the existing password protection\nsystems. In section \\ref{sec:traditional_vuls} the variations between the\nlayers and how they work will be explained.\n\n\\subsection{Background}\nMobile applications are rapidly growing with the escalating usage of\nmobile devices such as hand held computers (Mobile Phones, Mobile\nPads). In the academia research on mobile software and hardware\ntechnologies in the last decade have been increased. A core\nfundamental element of \"Pervasive computing\" is to hide the underlying\nmechanisms of systems to the user and perform actions with its\ncontext-awareness. The idea is to sense and react to dynamic\nenvironments and activities. Furthermore Location Information is a\ncompelling integral of context. So the Location aware computing is a\nwidely heard topic in this area. The authors of the article\n\\cite{hazas_scott_krumm_laccoa} write about the appliance of the\nlocation awareness in \"Invisible Computing\". The papers\n\\cite{Marmasse00location-awareinformation} and \\cite{1192785}\nelaborates on \"Location Awareness\" for real world\napplications. Moreover the latter suggests a \"Pervasive Computing\"\narchitecture that has been used on an implementation of a smart\nenvironment that assists elderly persons to live longer. \n\nLocation Awareness in most cases achieved by location\nsensing. \\gls{gps} has been widely used today for sensing geographical\nlocations using satellite signals. Despite the popularity of it, the\ndisadvantages and flows of \\gls{gps} can not be neglected when\nconsidering designing a \"Location Aware\" architecture. In the article\n\\cite{1203757} the authors analyse the reason why \\gls{gps} is not the\noptimal universal location sensing mechanism. The main reason\nappeared to be that \\gls{gps} does not work indoors, in particular in\nsteel-framed buildings. The resolution of it is a few meters and it may not\nbe adequate for some applications. Additionally the added weight, cost\nand energy consumption might not be competent for some applications. Consequently academics in the \"Lule \u00cc\u008a University of Technology\n\" has designed an architecture \\cite{Nord:2002:ALA:820747.821324} that\nuses more than one sensing mechanisms to retrieve Location\nInformation, such as GPS, Bluetooth, WaveLAN, IR, HiperLAN and etc. Hence\nthat the availability, precision and accuracy of Location Information is\nimproved. Additionally they propose a Generic Positioning protocol (GPP)\nfor positioning information that exchange between devices and other\nnetworked services.\n\nUsers may be apprehesive about the security when sharing their\nlocation with a third party. The author sees this being a future problem while\ncarrying out further development of this project. One solution is to\ncontrol access to the information by letting user manage the delivery\nand the accuracy of the location information using rule-based\npolicies. The paper \\cite{1276918} introduces the \"mix zone\" model which\n\"anonymize\" user's identity by restricting the position where users can\nbe located. Additionally the authors of the paper \\cite{4343900} talk\nabout the privacy in Location aware computing.\n\n\\subsection{Related Work}\nConsidering the related work, the idea of a Location Aware Password\nProtection system seem to be original. Albeit some work has been done\nin the area of \"Location aware access control\" \\cite{Cruz_alocation}\n\\cite{Michalakis03location-awareaccess} in combination of other contexts.  \n\n\\subsection{Vulnerabilities in conventional password protection\n  systems}\\label{sec:traditional_vuls}\n\nThe passwords that majority of password protection systems generate, are static\npasswords. Meaning that they are assigned to the users in a fixed\nmanner. Hence these passwords can be used more than one time. Thus if\nthe password gets in to the hands of the unwanted, they will be able to\nuse it without the owner knowing nothing about it, in most cases. Or a\nthird party can use the password until the password would be changed\nby the owner. But in most password protection systems if the password\nis in the hands of the unwanted then they have no restrictions to change the\npassword without having the owners permission.\n\nMalicious attackers are able to steal passwords from users by using advanced\ntechniques and equipments \\cite{klein_pass_security_survery} (E.g\nSkimming, password hacking). These stolen passwords can be reused to\nget access to the corresponding user accounts. If bank card details\nhave been stolen using skimming devices, the card details can be\nreprinted in to dummy \\gls{atm} cards, and then the recorded password\ncan be used with its corresponding \\gls{atm} card to steal money out of users accounts.\n\nAttackers may be able to crack passwords using advanced algorithms\nwith high computational power. (The use of 'birthday attack' to\ncrack password hashes) \\cite{klein_pass_security_survery}\n\nMost password protection systems use One-Factor authentication. Which is\n\"Something a user knows\" (E.g Systems that depend on security of just\none password). This is less secure. If the master password (one and\nonly security factor) is going to be compromised then the system will be open to any kind of malicious access.\n\n\\subsection{Objectives}\\label{sec:objectives}\n\n\\begin{itemize}\n\\item Make the passwords dynamic so that each time a user logs in to\n  the system he/she will use a new password.\n\\item Restrain the geographical locations that the passwords can be\n  used, so that passwords can only be used within the users locations.\n\\item Make the passwords not reusable. So that used passwords will be inoperative.\n\\item Restrict the password's active time. Subsequently a user will\n  have a short time frame to use the password. After the active time\n  is up, the password will be invalid. \n\\item Harden the security of systems by introducing a second authentication\n  factor.\n\\item Create a uniform architecture that will accommodate above\n  factors.\n\\item Implement the architecture as a solution to a real-world\n  problem.\n\\item Evaluate the success of the architecture.\n\\end{itemize}\n\n\\section{LAPPS Architecture}\\label{sec:lapps_arch}\nThe \\gls{lapps} architecture follows the idea of having layers of protection\nthat can be variable. Which means depending on the desired level of\nprotection, the layers can be added or removed without having to\nworry about the relationships between the layers, since the layers\ndoes not depend on each other.\n\n\\gls{lapps} layers can be added to the existing password protection systems,\nwithout having to entirely replace the old systems.\n\nAs shown in figure \\ref{fig:layers}, the layers of \\gls{lapps} wraps\naround the password (base).\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{LAPPS_Layers.pdf}\n  \\end{center}\n  \\caption{The layers of LAPPS Architecture\\label{fig:layers}}\n\\end{figure}\n\nThe following sections will elaborate on the core and the layers of the \\gls{lapps} architecture.\n\n\\subsection{Password}\nThe core of the \\gls{lapps} architecture is a standard password. A\ncharacter $p_i$ of a password $P$ can be $p_i \\in L$, $p_i \\in A$ or\n$p_i \\in S$ where $L$, $A$ and $S$ imply all possible letters,\nAlphanumerical values and Symbols respectively.\n\nThe other layers that are wrapped around this string, will strengthen the security of the password.\n\n\\subsection{User Specific/Oriented}\n\nThis layer of \\gls{lapps} operates on the database level of the system\ncalled \"lappStore\". To make the password user specific, a password\n$p_i$ is allocated to just one particular individual. A registered\nuser $U_i$ may be allocated to more than one password over time, but\nhe/she will only have one active password at a time. $HP$ denotes the\nallocated user-password pairs in the history and $AP$ implies the active user-password pairs at present.\\\\\n\nSuch that:\n", "index": 1, "text": "\n\\[\nHP = \\{U_1:p_1, U_1:p_2, U_1:p_3, U_2:p_5\\}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"HP=\\{U_{1}:p_{1},U_{1}:p_{2},U_{1}:p_{3},U_{2}:p_{5}\\}\" display=\"block\"><mrow><mrow><mi>H</mi><mo>\u2062</mo><mi>P</mi></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>U</mi><mn>1</mn></msub><mo>:</mo><mrow><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>,</mo><msub><mi>U</mi><mn>1</mn></msub></mrow><mo>:</mo><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>,</mo><msub><mi>U</mi><mn>1</mn></msub></mrow><mo>:</mo><mrow><msub><mi>p</mi><mn>3</mn></msub><mo>,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><mo>:</mo><msub><mi>p</mi><mn>5</mn></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nIf a user requests for a password one after another before the\nformer one expires, the former password will be deactivated and a new\npassword will be allocated. This avoids a user having more than one\npassword at a time. This ensures that there is only one active\npassword per user at a time, and only the owner can use it.\n\n\\subsection{Dynamic}\nWith \\gls{lapps} the user has to request for a password each time they log\nin. So that one password can only be used once. If a criminal gets\nhold of a password illegally, then there won't be any use of the\npassword, if the owner of the password has already used it, or he/she\nhas requested for a new one.\n\nIn the current \\gls{lapps} implementation a user is able to request\nfor a password using an Android mobile application called\n\"LAPPSMobile\". When the client requests for a password, the server\nwill reply back with a new password only if the user's given\ninformation is correct. The information included is the user's ID,\nthe registration number of the application, location information and\nthe eight digit number that has been generated by the Pin generating\ndevice. The connection between the sever and the client is encrypted.\n\nTo be able to gain a registration ID for the mobile application, the\nowner of the mobile phone and the particular instance of the\napplication has to be registered with the \"LAPPSserver\" (The server\nside application of the \\gls{lapps} architecture) along with the owner's user information.\n\nThe \\ref{sec:location_aware},\n\\ref{sec:time_aware},\\ref{sec:two_factor} sections will explain this extra information that has been sent to the server by the mobile application.\n\\subsection{Location Awareness}\\label{sec:location_aware}\n\nThe location awareness is the main layer of \\gls{lapps}. The reason being, this is the main factor that makes \\gls{lapps} special. This particular\nlayer has been influenced to name the \\gls{lapps} architecture. \n\nThis layer makes the passwords active only in a particular geographical\narea. When a user requests for a password, the user has to be\napproximately in a password \\emph{active zone}. If the user is not in a\npassword \\emph{active zone} then the \\gls{lapps} server may not\ngenerate a password for that particular individual. An error message would\nbe passed back instead. The area size of the \\emph{active zone} can easily\nbe variable according to specific requirements. If the user has\nsuccessfully received a password then to use the password he/she\nhas to be geographically present in the particular area that the received password is active. One password will be active only in one geographical area.\n\nBecause of this peculiar reason stolen unused passwords will be useless in\nother geographical areas other than the \\emph{active zone} of the particular\npassword. Although an attacker might be determined to use the password\nin the \\emph{active zone}, the other layers of \\gls{lapps} make it harder for it to work.\n\n\\subsection{Time Awareness}\\label{sec:time_aware}\n\nThe passwords that are generated by \\gls{lapps}, are only active within a\nlimited time window. If the password is not being used within this time\nframe, the password will be extinct. Depending on the requirements,\nthe time frame can be increased or decreased.\n\nThis leaves unused stolen passwords a limited amount of time to be\nactive. Hence the stolen unused passwords have to be used within a limited\namount of time and also within the exact corresponding password \\emph{active zone}.\nThis makes stolen passwords nonetheless useless.\n\n\\subsection{Two-factor authenticity}\\label{sec:two_factor}\n\\gls{lapps} uses two factor authentication to harden the existing layers of\nprotection. This layer can be removed easily if not desired.\n\nTwo-factor authentication uses two of the three well known authenticating\nfactors \\cite{allen_pickup_two-factor_2007}. These two factors are:\n\n\\begin{itemize}\n\\item Something that user knows. (E.g: \"A fixed password\")\n\\item Something that user has. (E.g: \"An \\gls{atm} card\")\n\\end{itemize}\n\nA fixed password will be allocated to every user who is registered\nwith \\gls{lapps}. This password can be used for this exact purpose\nonly. By using these two factors, the \\gls{lapps} authenticates the user,\neven before he/she gains a password. Only if the user is able\nto authenticate using these two factors, he/she will be able to\ngain a password. Any other way the server will bounce back with an\nerror message. Similar implementations have been introduced by other\norganisations such as PinSentry device of Barclays Bank PLC \\cite{AliJahaJaha2009rl}.\n\nThe most recent implementation of \\gls{lapps} uses a fixed password and \\gls{atm} card\ninformation to generate eight digit number that will only be valid for\na very short period of time. This is attained by using a hash function\nwith salts. Section \\ref{sec:lapps_atm_impl} explains how this is implemented.\n\n\\subsection{Evaluation on LAPPS Layers}\\label{lapps_eval}\n\nThere are five layers in the \\gls{lapps} architecture in total. The layers\ncan be removed or added to the stack of layers, depending on the\nlevel of security desired by the user. Though new layers can be\nadded on top of these five layers.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.19]{layer2.pdf}\n  \\end{center}\n  \\caption{Usability vs Security}\n  \\label{fig:layer2}\n\\end{figure}\n\nAlthough the idea of adding more security layers is quite promising from\nthe security point of view, the more you add layers in to the stack\nthe less user friendly the system would be (Figure\n\\ref{fig:layer2}). So the security administrators have to find the\nright security levels that would fit in to their needs. As an example\nlets look at a system with and without the final layer the \"Two-factor\nauthenticity\". When this layer is present, as the first step the user\nhas to use their fixed password number and \\gls{atm} card for example, to\nobtain a second eight digit pin number. This number is then used to get\nthe final pin number that can be used to access the protected\ninformation or service. This can be a tedious process granting that\nthe user is in a hurry or conceding that the user has not got the \\gls{atm}\ncard with them when they need to get access to the particular service or data. \n\nAn example for an extra layer of security would be to use the third\nauthentication factor, which is \"Something that user is\"\n(E.g. fingerprints), with the other two authentication factors that is mentioned in section \\ref{sec:two_factor}.\n\n\\subsection{LAPPS solution to the vulnerabilities in traditional\n  password protection systems}\n\nIn section \\ref{sec:traditional_vuls} the author has mentioned the\nvulnerabilities that is in traditional password protection\nsystems. The following pointers will summarise the factors about the\nsolution \\gls{lapps} architecture that has been explained in detail in section \\ref{sec:lapps_arch}.\n\n\\begin{itemize}\n\\item A password that is generated by the \\gls{lapps} is allocated to\n  just one individual. \n\\item There will only be one active password per user. So only the\n  owner owns an active password.\n\\item The passwords are generated in a dynamic fashion so that a user\n  may use a new password each time he/she access the secured\n  data/service.\n\\item One password can only be used once. So that the stolen used passwords\n  are dysfunctional.\n\\item The passwords will only be generated if the user can\n  successfully authenticate. If a criminal steals a password\n  requesting device (E.g. Smart Mobile phone with a registered\n  \"LAPPSMobile\" Application installed) he/she will not be able to gain a\n  password without supplying other information to the device.\n\\item The users have to be in a \"Password \\emph{Active zone}\" to be able to\n  request for passwords.\n\\item Every password is allocated to only one \"Password Active\n  Zone\". Stolen unused passwords can not be used in multiple locations.\n\\item A password can only be used within its allocated \"Password\n  \\emph{Active Zone}\". Stolen unused passwords can not be used outside the allocated\n  geographical area.\n\\item A password is only valid for a very limited amount of time. So\n  that the user will have to use the password within this time\n  frame. If the password is not being used within this time window,\n  the password will be extinct.\n\\item To be able to authenticate, the user has to acquire an eight digit pin\n  number using their fixed password and the corresponding smart card,\n  for an example. So that stolen password requesting devices will be\n  useless to a person who does not know the fixed password and does\n  not own a Pin generating device with the corresponding fixed password.\n\\end{itemize}\n\n\\section{LAPPS ATM Implementation}\\label{sec:lapps_atm_impl}\n\nThe current implementation of \\gls{lapps} architecture focuses on hardening\n\\gls{atm} password systems by utilising its layers to fit in to the\nconventional \\gls{atm} systems.\\\\\n\nFactors about traditional \\gls{atm} password protection systems.\n\\begin{itemize}\n\\item A user may be assigned to a fixed password with its dedicated\n  Credit/Debit card number.\n\\item The password can be used from anywhere in\n  the world, along with its Credit/Debit card. The geographical\n  location has no effect on the authenticity of the user.\n\\item The vulnerabilities mentioned in section\n  \\ref{sec:traditional_vuls} are valid in this case.\n\\end{itemize} \n\nThere have been reported many crimes that are related to the security\nof \\glspl{atm} and other password protection systems\n\\cite{klein_pass_security_survery}. Such as, robberies, stealing\nconfidential information using hidden cameras and card readers and\nhacking, with the advancements of technology.\n\n\\subsection{The Architecture of the LAPPS implementation for ATM\n  systems}\n\nFigure \\ref{fig:lapps-arch} shows, the components that are being\nused in the \\gls{lapps}. The server side application (LAPPSServer), client\napplication and Pin generating device are the components of this system. Section \\ref{sec:layer_mapping} elaborates in what respect \\gls{lapps}\nuses these components in its various layers of security.\n\nTo be able to use the system the user has to have a smart phone that\nruns Android platform.\n\nThe components of the system:\n\n\\begin{itemize}\n\\item \"lappStore\" is the main database of the \\gls{lapps} system. The allocated\n  passwords and user information are stored here. \n\\item LAPPSMobile is the client application that the user can request\n  passwords from. This application is developed on the Android\n  platform and has to have the GPS functionality.\n\\item The LAPPSServer application replies to the requests from LAPPSMobile\n  application, only if the authentication information is correct. \n\\end{itemize}\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{LAPPS_Architecture.pdf}\n  \\end{center}\n  \\caption{The Architecture of LAPPS for ATM systems}\n  \\label{fig:lapps-arch}\n\\end{figure}\n\n\\subsubsection{How a user would use \"LAPPS for ATMs\"?}\n\n\\begin{itemize}\n\\item User has to generate an 8 digit number from the Pin generating device\n  by using his/her fixed password and the Credit/Debit card.\n\\item Then by staying no more than 20 meters away from the desired \\gls{atm}\n  that user intends to use, he/she can request for a password from\n  the LAPPSMobile. And also may be asked to insert the 8 digit pin\n  before the application sends a request to the server.\n\\item If the authentication details are correct then the server may\n  reply with a password and the ID of the \\gls{atm} that the password is\n  allocated to. Else ways it will send back an error message.\n\\item Finally the user may log in to the \\gls{atm} that the password is\n  active on, using the password and his/hers \\gls{atm} card.\n\\end{itemize}\n\n\\subsection{LAPPS Layer mapping to the \"LAPPS for ATM\" implementation}\\label{sec:layer_mapping}\n\nThe following pointers will construe how the security layers of \\gls{lapps}\nhave been implemented in to \"\\gls{lapps} for \\gls{atm}\" implementation.\n\n\\subsubsection{User specific/Oriented}\nIn a table called \"allocation\" in the lappStore, the LAPPSServer\nstores the generated passwords with its allocated user and the \\gls{atm}\nmachine ID. So that the password will only be allocated to one\nuser.\n\n\\subsubsection{Dynamic}\nThe passwords are not predefined. It is generated on demand as clients\nrequest. If LAPPSServer has authenticated the user, then the password\nwill be generated.\n\n\\subsubsection{Location Awareness}\n\nTo be able to request for a password a user has to be less than 20\nmeters away from more than one \\gls{atm}. The password is allocated to the\nnearest \\gls{atm} to the user only if the user is no far than 20 meters away\nfrom it. And the password can only be used on the allocated \\gls{atm}. \n\n\\subsubsection{Time Awareness}\n\nA password is only available for just 5 minutes after it has been\ngenerated. If the user has not used the password on its allocated \\gls{atm},\nit will be expired.\n\n\\subsubsection{Two-Factor Authentication}\n\nBefore a user requests for a password, they will be asked to enter an 8\ndigit number. This has to be obtained from a Pin generating device by using\nthe user's \\gls{atm} card and their fixed password.\n\n\\subsection{The components of \"LAPPS for ATM\"}\\label{sec:components}\n\nThe configuration information of all of the following components have\nbeen stored in properties files, in \".txt\" format. On that account if the\ninformation changes in the future the user is able to reconfigure the\nsoftware without having to change the code.\\\\\n\nSuch files may contain.\n\\begin{enumerate}\n\\item The URL of the database.\n\\item The name of the database.\n\\item The URL of the server.\n\\item The PORT number of the database management system.\n\\item The PORT number that the server is passively waiting/listening\n  for connections from the clients.\n\\item The user names and the passwords for the database with different\n  access permissions. \n\\end{enumerate}\n\n\\subsubsection{The lappStore (Database)}\n\nThe database has been implemented on \"PostgreSQL\"\n\\cite{postgresql_documentation} database management\nsystem. The reason for using this particular piece of software is that\nit is open-source and the powerful PostGIS \\cite{postgis_manual}\nspatial database extension for PostgreSQL. This extension follows\nSimple Feature Access for, SQL specification from Open Geospatial Consortium (OGC).\\\\\nThe database contains four tables. They are:\n\n\\begin{itemize}\n\\item user:\\\\\n  This table stores the information about users in the system. A\n  row of this table contains the user ID, registration ID, name,\n  hashed fixed password. Passwords are hashed using SHA2-512 algorithm.\n\\item password:\\\\\n  The hashed passwords are stored in this table with their expiry time.\n  Passwords are hashed using SHA2-512 algorithm.\n\\item atm:\\\\\n  This table contains the IDs of \\glspl{atm} and their location\n  information. This table contains all of the \\glspl{atm} that the users can\n  get access to.\n\n\\item allocation:\\\\\n  An allocation contains a password, a user, an \\gls{atm} ID and a Boolean flag\n  that can toggle to be true if the password has been used, otherwise it\n  is false (default). Since a user is allowed to use a password once, if\n  this value is 'true' then the password is unusable. There will be one\n  row in this table for every allocation (For sometime).\n\\end{itemize}\n\nThis database has been designed so that a minimum amount of data will be\nstored, to keep the database less ponderous. To keep the database\nclean, there is are triggers devised into the database.\n\nThe triggers trigger every time a user inserts a record in to the\nallocation table. One trigger deletes the allocation rows that the\nexpiry time of the passwords have been exceeded and the other deletes\nthe rows that their password allocation has been already used. The\nexpired and used information in the 'allocation' table is useless\nbecause they will not be used by the LAPPSServer in anyway after they\nhad its use. Although the passwords still will be stored in the\n'password' table, because they are used by LAPPSServer to generate unique passwords.\n\nThe idea is that to keep this table clean as possible so that the\ntransactions can be performed somewhat faster.\n\n\\paragraph{Database design}\\label{sec:database_design}\n:\\\\\\\\\nFigure \\ref{fig:database_design} shows a diagram of the design of lappStore database.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.4]{Diagram1.pdf}\n  \\end{center}\n  \\caption{The database design \\label{fig:database_design}}\n\\end{figure}\n\nThe database contains four tables. Namely they are user, allocation,\npassword and atm. The relationships between them have been shown using\nthe black lines that connects the class boxes. The classes that have\nbeen connected by a line with an arrow at the end are the foreign keys\nthat refer to the corresponding columns at the other end of the\nrelationship/line. For example \"password\" column in the \"allocation\"\ntable is a foreign key of the \"password\" column in the \"password\"\ntable, and so on. Hence the type of the foreign key column and the\ncorresponding column are the same.\n\nThe multiplicity factors of the tables shows in figure\n\\ref{fig:database_design} that a user can only have one allocation at\na time (0..1) but an allocation will always have a user (1..1). A\npassword can only have one allocation (0..1) but an allocation will\nalways have a password (1..1). An allocation will always have an ATM\n(1..1) but an ATM may have zero or many allocations (0..*).\n\n\\subparagraph{user Table}\\label{sec:user_table}\n:\\\\\n\nAs the name suggests, the user table contains the information that is\nrelevant to the users of the LAPPS system. It is assumed that all of\nthese attributes of the users have been allocated and filled by the\nbank. \\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item regId   - The registered ID of the user's mobile application.\n\\item userId  - The ID of the user (Primary Key).\n\\item fixpass - The fixed password that has been allocated by the bank\n  to the user, when they sign up with the bank.\n\\item name - The name of the individual. \n\\end{itemize}\n\nThe current implementation allows users to have one application\nregistered per person. It is assumed that the users have already\nregistered their applications when they sign up with the bank. The\nregId is stored in the users LAPPSMobile application instances.\n\n\\subparagraph{atm Table}\n\nAll of the ATM machines that belong to the system has to be\nin this table. There should be one record per each ATM that\nis registered with the system. The LAPPSServer uses the information in\nthis table to calculate the distance between the users and the\n\\glspl{atm}.\n\nColumn description:\n\n\\begin{itemize}\n\\item atmId - The unique ID of the ATM (Primary Key)\n\\item lati - The latitude geographical information of the ATM.\n\\item longi - The longitude geographical information of the ATM.\n\\item geom - The geographical information of type \"\\gls{srid}\" 27700.\n\\end{itemize}\n\nTo create this special 'geom' column a special command had to be\nused from the PostGIS library \\cite{postgis_manual}. As parameters of\nthis function you can parse the \"schema name\", \"table name\",  \"column name\",\n\"SRID\", type, dimension etc.\\\\\n\nHow this geometry column was added to the 'atm' table as follows.\n\n\\begin{verbatim}\nSELECT AddGeometryColumn('public', 'atm', 'geom', 27700, 'POINT', 2);\n\\end{verbatim}\n\nTo calculate the column values of type \\gls{srid} 27700 the author has\nused the following command that iterates through all of the rows in\nthe 'atm' table and updates the 'geom' column.\n\n\\begin{verbatim}\nUPDATE atm SET geom=PointFromText('POINT('|| lati||' '|| longi || ')', 27700);\n\\end{verbatim}\n\nThe 'PointFromText' function converts the received SRID 4326 (lati,\nlongi) value to SRID 27700 type value and stores it in the 'geom' column.\n\nMore information on spatial distance calculation will be discussed in the section \\ref{sec:calc_atm_dist}.\n\nOther parts of this database are triggers that are in service to\nkeep the database less bulky. These triggers fire after every time a record has been added to the table.\\\\\n\nTrigger 1: Deletes the rows that are expired by time.\\\\\n\nThe pseudo code of the triggers:\n\\begin{verbatim}\nBEGIN\nDELETE FROM allocation as a USING password AS  pass WHERE\na.password=pass.password AND pass.expTime <= CURRENT_TIMESTAMP; \nRETURN NULL;\nEND\n\\end{verbatim}\n\nAssume that the $\\{a_i, \\dots, a_n\\}$ are $n$ allocations. Each\npassword $P_i$ has got its expiry time $ET_{P_i}$ associated with\nit. The trigger function iterates through all $n$ allocation records\n$A$ and deletes the records that are $ET_{P_i a_i} \\leq CT$ where $CT$\nis the current time. After the trigger has been fired we can say that,\n\n", "itemtype": "equation", "pos": 11650, "prevtext": "\n", "index": 3, "text": "\n\\[\nAP = \\{U_1:p_7, U_2:p_8, U_3:p_9\\}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"AP=\\{U_{1}:p_{7},U_{2}:p_{8},U_{3}:p_{9}\\}\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mi>P</mi></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>U</mi><mn>1</mn></msub><mo>:</mo><mrow><mrow><msub><mi>p</mi><mn>7</mn></msub><mo>,</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><mo>:</mo><mrow><msub><mi>p</mi><mn>8</mn></msub><mo>,</mo><msub><mi>U</mi><mn>3</mn></msub></mrow><mo>:</mo><msub><mi>p</mi><mn>9</mn></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nTrigger 2: Deletes the passwords that have been used.\\\\\n\nThe pseudo code of the triggers:\n\\begin{verbatim}\nBEGIN\nDELETE FROM allocation WHERE used=true;\nRETURN NULL;\nEND\n\\end{verbatim}\n\nIf that the $\\{a_i,\\dots, a_n\\}$ are $n$ allocations. The trigger iterates\nthrough all $n$ allocations $A$ and deletes the allocation records that\nthe 'used' column of it $PT_{a_i}$ has been assigned to the value\n\\emph{true}. Furthermore, after the trigger has been fired we can say that,\n\n", "itemtype": "equation", "pos": 32381, "prevtext": "\n\nIf a user requests for a password one after another before the\nformer one expires, the former password will be deactivated and a new\npassword will be allocated. This avoids a user having more than one\npassword at a time. This ensures that there is only one active\npassword per user at a time, and only the owner can use it.\n\n\\subsection{Dynamic}\nWith \\gls{lapps} the user has to request for a password each time they log\nin. So that one password can only be used once. If a criminal gets\nhold of a password illegally, then there won't be any use of the\npassword, if the owner of the password has already used it, or he/she\nhas requested for a new one.\n\nIn the current \\gls{lapps} implementation a user is able to request\nfor a password using an Android mobile application called\n\"LAPPSMobile\". When the client requests for a password, the server\nwill reply back with a new password only if the user's given\ninformation is correct. The information included is the user's ID,\nthe registration number of the application, location information and\nthe eight digit number that has been generated by the Pin generating\ndevice. The connection between the sever and the client is encrypted.\n\nTo be able to gain a registration ID for the mobile application, the\nowner of the mobile phone and the particular instance of the\napplication has to be registered with the \"LAPPSserver\" (The server\nside application of the \\gls{lapps} architecture) along with the owner's user information.\n\nThe \\ref{sec:location_aware},\n\\ref{sec:time_aware},\\ref{sec:two_factor} sections will explain this extra information that has been sent to the server by the mobile application.\n\\subsection{Location Awareness}\\label{sec:location_aware}\n\nThe location awareness is the main layer of \\gls{lapps}. The reason being, this is the main factor that makes \\gls{lapps} special. This particular\nlayer has been influenced to name the \\gls{lapps} architecture. \n\nThis layer makes the passwords active only in a particular geographical\narea. When a user requests for a password, the user has to be\napproximately in a password \\emph{active zone}. If the user is not in a\npassword \\emph{active zone} then the \\gls{lapps} server may not\ngenerate a password for that particular individual. An error message would\nbe passed back instead. The area size of the \\emph{active zone} can easily\nbe variable according to specific requirements. If the user has\nsuccessfully received a password then to use the password he/she\nhas to be geographically present in the particular area that the received password is active. One password will be active only in one geographical area.\n\nBecause of this peculiar reason stolen unused passwords will be useless in\nother geographical areas other than the \\emph{active zone} of the particular\npassword. Although an attacker might be determined to use the password\nin the \\emph{active zone}, the other layers of \\gls{lapps} make it harder for it to work.\n\n\\subsection{Time Awareness}\\label{sec:time_aware}\n\nThe passwords that are generated by \\gls{lapps}, are only active within a\nlimited time window. If the password is not being used within this time\nframe, the password will be extinct. Depending on the requirements,\nthe time frame can be increased or decreased.\n\nThis leaves unused stolen passwords a limited amount of time to be\nactive. Hence the stolen unused passwords have to be used within a limited\namount of time and also within the exact corresponding password \\emph{active zone}.\nThis makes stolen passwords nonetheless useless.\n\n\\subsection{Two-factor authenticity}\\label{sec:two_factor}\n\\gls{lapps} uses two factor authentication to harden the existing layers of\nprotection. This layer can be removed easily if not desired.\n\nTwo-factor authentication uses two of the three well known authenticating\nfactors \\cite{allen_pickup_two-factor_2007}. These two factors are:\n\n\\begin{itemize}\n\\item Something that user knows. (E.g: \"A fixed password\")\n\\item Something that user has. (E.g: \"An \\gls{atm} card\")\n\\end{itemize}\n\nA fixed password will be allocated to every user who is registered\nwith \\gls{lapps}. This password can be used for this exact purpose\nonly. By using these two factors, the \\gls{lapps} authenticates the user,\neven before he/she gains a password. Only if the user is able\nto authenticate using these two factors, he/she will be able to\ngain a password. Any other way the server will bounce back with an\nerror message. Similar implementations have been introduced by other\norganisations such as PinSentry device of Barclays Bank PLC \\cite{AliJahaJaha2009rl}.\n\nThe most recent implementation of \\gls{lapps} uses a fixed password and \\gls{atm} card\ninformation to generate eight digit number that will only be valid for\na very short period of time. This is attained by using a hash function\nwith salts. Section \\ref{sec:lapps_atm_impl} explains how this is implemented.\n\n\\subsection{Evaluation on LAPPS Layers}\\label{lapps_eval}\n\nThere are five layers in the \\gls{lapps} architecture in total. The layers\ncan be removed or added to the stack of layers, depending on the\nlevel of security desired by the user. Though new layers can be\nadded on top of these five layers.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.19]{layer2.pdf}\n  \\end{center}\n  \\caption{Usability vs Security}\n  \\label{fig:layer2}\n\\end{figure}\n\nAlthough the idea of adding more security layers is quite promising from\nthe security point of view, the more you add layers in to the stack\nthe less user friendly the system would be (Figure\n\\ref{fig:layer2}). So the security administrators have to find the\nright security levels that would fit in to their needs. As an example\nlets look at a system with and without the final layer the \"Two-factor\nauthenticity\". When this layer is present, as the first step the user\nhas to use their fixed password number and \\gls{atm} card for example, to\nobtain a second eight digit pin number. This number is then used to get\nthe final pin number that can be used to access the protected\ninformation or service. This can be a tedious process granting that\nthe user is in a hurry or conceding that the user has not got the \\gls{atm}\ncard with them when they need to get access to the particular service or data. \n\nAn example for an extra layer of security would be to use the third\nauthentication factor, which is \"Something that user is\"\n(E.g. fingerprints), with the other two authentication factors that is mentioned in section \\ref{sec:two_factor}.\n\n\\subsection{LAPPS solution to the vulnerabilities in traditional\n  password protection systems}\n\nIn section \\ref{sec:traditional_vuls} the author has mentioned the\nvulnerabilities that is in traditional password protection\nsystems. The following pointers will summarise the factors about the\nsolution \\gls{lapps} architecture that has been explained in detail in section \\ref{sec:lapps_arch}.\n\n\\begin{itemize}\n\\item A password that is generated by the \\gls{lapps} is allocated to\n  just one individual. \n\\item There will only be one active password per user. So only the\n  owner owns an active password.\n\\item The passwords are generated in a dynamic fashion so that a user\n  may use a new password each time he/she access the secured\n  data/service.\n\\item One password can only be used once. So that the stolen used passwords\n  are dysfunctional.\n\\item The passwords will only be generated if the user can\n  successfully authenticate. If a criminal steals a password\n  requesting device (E.g. Smart Mobile phone with a registered\n  \"LAPPSMobile\" Application installed) he/she will not be able to gain a\n  password without supplying other information to the device.\n\\item The users have to be in a \"Password \\emph{Active zone}\" to be able to\n  request for passwords.\n\\item Every password is allocated to only one \"Password Active\n  Zone\". Stolen unused passwords can not be used in multiple locations.\n\\item A password can only be used within its allocated \"Password\n  \\emph{Active Zone}\". Stolen unused passwords can not be used outside the allocated\n  geographical area.\n\\item A password is only valid for a very limited amount of time. So\n  that the user will have to use the password within this time\n  frame. If the password is not being used within this time window,\n  the password will be extinct.\n\\item To be able to authenticate, the user has to acquire an eight digit pin\n  number using their fixed password and the corresponding smart card,\n  for an example. So that stolen password requesting devices will be\n  useless to a person who does not know the fixed password and does\n  not own a Pin generating device with the corresponding fixed password.\n\\end{itemize}\n\n\\section{LAPPS ATM Implementation}\\label{sec:lapps_atm_impl}\n\nThe current implementation of \\gls{lapps} architecture focuses on hardening\n\\gls{atm} password systems by utilising its layers to fit in to the\nconventional \\gls{atm} systems.\\\\\n\nFactors about traditional \\gls{atm} password protection systems.\n\\begin{itemize}\n\\item A user may be assigned to a fixed password with its dedicated\n  Credit/Debit card number.\n\\item The password can be used from anywhere in\n  the world, along with its Credit/Debit card. The geographical\n  location has no effect on the authenticity of the user.\n\\item The vulnerabilities mentioned in section\n  \\ref{sec:traditional_vuls} are valid in this case.\n\\end{itemize} \n\nThere have been reported many crimes that are related to the security\nof \\glspl{atm} and other password protection systems\n\\cite{klein_pass_security_survery}. Such as, robberies, stealing\nconfidential information using hidden cameras and card readers and\nhacking, with the advancements of technology.\n\n\\subsection{The Architecture of the LAPPS implementation for ATM\n  systems}\n\nFigure \\ref{fig:lapps-arch} shows, the components that are being\nused in the \\gls{lapps}. The server side application (LAPPSServer), client\napplication and Pin generating device are the components of this system. Section \\ref{sec:layer_mapping} elaborates in what respect \\gls{lapps}\nuses these components in its various layers of security.\n\nTo be able to use the system the user has to have a smart phone that\nruns Android platform.\n\nThe components of the system:\n\n\\begin{itemize}\n\\item \"lappStore\" is the main database of the \\gls{lapps} system. The allocated\n  passwords and user information are stored here. \n\\item LAPPSMobile is the client application that the user can request\n  passwords from. This application is developed on the Android\n  platform and has to have the GPS functionality.\n\\item The LAPPSServer application replies to the requests from LAPPSMobile\n  application, only if the authentication information is correct. \n\\end{itemize}\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{LAPPS_Architecture.pdf}\n  \\end{center}\n  \\caption{The Architecture of LAPPS for ATM systems}\n  \\label{fig:lapps-arch}\n\\end{figure}\n\n\\subsubsection{How a user would use \"LAPPS for ATMs\"?}\n\n\\begin{itemize}\n\\item User has to generate an 8 digit number from the Pin generating device\n  by using his/her fixed password and the Credit/Debit card.\n\\item Then by staying no more than 20 meters away from the desired \\gls{atm}\n  that user intends to use, he/she can request for a password from\n  the LAPPSMobile. And also may be asked to insert the 8 digit pin\n  before the application sends a request to the server.\n\\item If the authentication details are correct then the server may\n  reply with a password and the ID of the \\gls{atm} that the password is\n  allocated to. Else ways it will send back an error message.\n\\item Finally the user may log in to the \\gls{atm} that the password is\n  active on, using the password and his/hers \\gls{atm} card.\n\\end{itemize}\n\n\\subsection{LAPPS Layer mapping to the \"LAPPS for ATM\" implementation}\\label{sec:layer_mapping}\n\nThe following pointers will construe how the security layers of \\gls{lapps}\nhave been implemented in to \"\\gls{lapps} for \\gls{atm}\" implementation.\n\n\\subsubsection{User specific/Oriented}\nIn a table called \"allocation\" in the lappStore, the LAPPSServer\nstores the generated passwords with its allocated user and the \\gls{atm}\nmachine ID. So that the password will only be allocated to one\nuser.\n\n\\subsubsection{Dynamic}\nThe passwords are not predefined. It is generated on demand as clients\nrequest. If LAPPSServer has authenticated the user, then the password\nwill be generated.\n\n\\subsubsection{Location Awareness}\n\nTo be able to request for a password a user has to be less than 20\nmeters away from more than one \\gls{atm}. The password is allocated to the\nnearest \\gls{atm} to the user only if the user is no far than 20 meters away\nfrom it. And the password can only be used on the allocated \\gls{atm}. \n\n\\subsubsection{Time Awareness}\n\nA password is only available for just 5 minutes after it has been\ngenerated. If the user has not used the password on its allocated \\gls{atm},\nit will be expired.\n\n\\subsubsection{Two-Factor Authentication}\n\nBefore a user requests for a password, they will be asked to enter an 8\ndigit number. This has to be obtained from a Pin generating device by using\nthe user's \\gls{atm} card and their fixed password.\n\n\\subsection{The components of \"LAPPS for ATM\"}\\label{sec:components}\n\nThe configuration information of all of the following components have\nbeen stored in properties files, in \".txt\" format. On that account if the\ninformation changes in the future the user is able to reconfigure the\nsoftware without having to change the code.\\\\\n\nSuch files may contain.\n\\begin{enumerate}\n\\item The URL of the database.\n\\item The name of the database.\n\\item The URL of the server.\n\\item The PORT number of the database management system.\n\\item The PORT number that the server is passively waiting/listening\n  for connections from the clients.\n\\item The user names and the passwords for the database with different\n  access permissions. \n\\end{enumerate}\n\n\\subsubsection{The lappStore (Database)}\n\nThe database has been implemented on \"PostgreSQL\"\n\\cite{postgresql_documentation} database management\nsystem. The reason for using this particular piece of software is that\nit is open-source and the powerful PostGIS \\cite{postgis_manual}\nspatial database extension for PostgreSQL. This extension follows\nSimple Feature Access for, SQL specification from Open Geospatial Consortium (OGC).\\\\\nThe database contains four tables. They are:\n\n\\begin{itemize}\n\\item user:\\\\\n  This table stores the information about users in the system. A\n  row of this table contains the user ID, registration ID, name,\n  hashed fixed password. Passwords are hashed using SHA2-512 algorithm.\n\\item password:\\\\\n  The hashed passwords are stored in this table with their expiry time.\n  Passwords are hashed using SHA2-512 algorithm.\n\\item atm:\\\\\n  This table contains the IDs of \\glspl{atm} and their location\n  information. This table contains all of the \\glspl{atm} that the users can\n  get access to.\n\n\\item allocation:\\\\\n  An allocation contains a password, a user, an \\gls{atm} ID and a Boolean flag\n  that can toggle to be true if the password has been used, otherwise it\n  is false (default). Since a user is allowed to use a password once, if\n  this value is 'true' then the password is unusable. There will be one\n  row in this table for every allocation (For sometime).\n\\end{itemize}\n\nThis database has been designed so that a minimum amount of data will be\nstored, to keep the database less ponderous. To keep the database\nclean, there is are triggers devised into the database.\n\nThe triggers trigger every time a user inserts a record in to the\nallocation table. One trigger deletes the allocation rows that the\nexpiry time of the passwords have been exceeded and the other deletes\nthe rows that their password allocation has been already used. The\nexpired and used information in the 'allocation' table is useless\nbecause they will not be used by the LAPPSServer in anyway after they\nhad its use. Although the passwords still will be stored in the\n'password' table, because they are used by LAPPSServer to generate unique passwords.\n\nThe idea is that to keep this table clean as possible so that the\ntransactions can be performed somewhat faster.\n\n\\paragraph{Database design}\\label{sec:database_design}\n:\\\\\\\\\nFigure \\ref{fig:database_design} shows a diagram of the design of lappStore database.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.4]{Diagram1.pdf}\n  \\end{center}\n  \\caption{The database design \\label{fig:database_design}}\n\\end{figure}\n\nThe database contains four tables. Namely they are user, allocation,\npassword and atm. The relationships between them have been shown using\nthe black lines that connects the class boxes. The classes that have\nbeen connected by a line with an arrow at the end are the foreign keys\nthat refer to the corresponding columns at the other end of the\nrelationship/line. For example \"password\" column in the \"allocation\"\ntable is a foreign key of the \"password\" column in the \"password\"\ntable, and so on. Hence the type of the foreign key column and the\ncorresponding column are the same.\n\nThe multiplicity factors of the tables shows in figure\n\\ref{fig:database_design} that a user can only have one allocation at\na time (0..1) but an allocation will always have a user (1..1). A\npassword can only have one allocation (0..1) but an allocation will\nalways have a password (1..1). An allocation will always have an ATM\n(1..1) but an ATM may have zero or many allocations (0..*).\n\n\\subparagraph{user Table}\\label{sec:user_table}\n:\\\\\n\nAs the name suggests, the user table contains the information that is\nrelevant to the users of the LAPPS system. It is assumed that all of\nthese attributes of the users have been allocated and filled by the\nbank. \\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item regId   - The registered ID of the user's mobile application.\n\\item userId  - The ID of the user (Primary Key).\n\\item fixpass - The fixed password that has been allocated by the bank\n  to the user, when they sign up with the bank.\n\\item name - The name of the individual. \n\\end{itemize}\n\nThe current implementation allows users to have one application\nregistered per person. It is assumed that the users have already\nregistered their applications when they sign up with the bank. The\nregId is stored in the users LAPPSMobile application instances.\n\n\\subparagraph{atm Table}\n\nAll of the ATM machines that belong to the system has to be\nin this table. There should be one record per each ATM that\nis registered with the system. The LAPPSServer uses the information in\nthis table to calculate the distance between the users and the\n\\glspl{atm}.\n\nColumn description:\n\n\\begin{itemize}\n\\item atmId - The unique ID of the ATM (Primary Key)\n\\item lati - The latitude geographical information of the ATM.\n\\item longi - The longitude geographical information of the ATM.\n\\item geom - The geographical information of type \"\\gls{srid}\" 27700.\n\\end{itemize}\n\nTo create this special 'geom' column a special command had to be\nused from the PostGIS library \\cite{postgis_manual}. As parameters of\nthis function you can parse the \"schema name\", \"table name\",  \"column name\",\n\"SRID\", type, dimension etc.\\\\\n\nHow this geometry column was added to the 'atm' table as follows.\n\n\\begin{verbatim}\nSELECT AddGeometryColumn('public', 'atm', 'geom', 27700, 'POINT', 2);\n\\end{verbatim}\n\nTo calculate the column values of type \\gls{srid} 27700 the author has\nused the following command that iterates through all of the rows in\nthe 'atm' table and updates the 'geom' column.\n\n\\begin{verbatim}\nUPDATE atm SET geom=PointFromText('POINT('|| lati||' '|| longi || ')', 27700);\n\\end{verbatim}\n\nThe 'PointFromText' function converts the received SRID 4326 (lati,\nlongi) value to SRID 27700 type value and stores it in the 'geom' column.\n\nMore information on spatial distance calculation will be discussed in the section \\ref{sec:calc_atm_dist}.\n\nOther parts of this database are triggers that are in service to\nkeep the database less bulky. These triggers fire after every time a record has been added to the table.\\\\\n\nTrigger 1: Deletes the rows that are expired by time.\\\\\n\nThe pseudo code of the triggers:\n\\begin{verbatim}\nBEGIN\nDELETE FROM allocation as a USING password AS  pass WHERE\na.password=pass.password AND pass.expTime <= CURRENT_TIMESTAMP; \nRETURN NULL;\nEND\n\\end{verbatim}\n\nAssume that the $\\{a_i, \\dots, a_n\\}$ are $n$ allocations. Each\npassword $P_i$ has got its expiry time $ET_{P_i}$ associated with\nit. The trigger function iterates through all $n$ allocation records\n$A$ and deletes the records that are $ET_{P_i a_i} \\leq CT$ where $CT$\nis the current time. After the trigger has been fired we can say that,\n\n", "index": 5, "text": "\n\\[\n\\forall a \\in A : ET_{P_i a} > CT\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\forall a\\in A:ET_{P_{i}a}&gt;CT\" display=\"block\"><mrow><mrow><mrow><mo>\u2200</mo><mi>a</mi></mrow><mo>\u2208</mo><mi>A</mi></mrow><mo>:</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><msub><mi>T</mi><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>\u2062</mo><mi>a</mi></mrow></msub></mrow><mo>&gt;</mo><mrow><mi>C</mi><mo>\u2062</mo><mi>T</mi></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n\\subparagraph{password Table}\\label{password_table}:\\\\\n\nAll the passwords that have been generated, are stored in this table\nwith its corresponding expiry date and time. \\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item password - The password (Primary Key).\n\\item expTime  - The expiry time of the password.\n\\end{itemize}\n\nThe expiry time of the passwords have been calculated by the server. The\nserver adds 5 minutes to the current time and then stores the value in\nthe expTime column along with each generated password.\n\n\\subparagraph{allocation Table}\\label{sec:allocation_table}:\\\\\n\nThis table contains all of the allocations that are alive on time. One\nallocation has got the lifetime of 5 minutes. A trigger will delete\nthe expired rows. Ideally all of the passwords that are in this table,\nare only unused allocations since the used allocations will be deleted\nby one of the triggers. Of course there is a time window before the\ntriggers have been fired, where the used or expired allocations still\nwill be in this table.\n\nInitially every time LAPPS has successfully generated a password, a\nrecord will be added to this table. A user will have just one record\nin this table at a time, since LAPPSServer makes sure that a user can have only one allocation/Password at a time.\\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item userId - The ID of the user that the password has been allocated\n  to(Foreign key).\n\\item password - The allocated password (Foreign key).\n\\item atmId - The ID of the ATM that the password has been\n  allocated to (Foreign key).\n\\item used - Boolean flag; true if the password has been used, false otherwise.\n\\end{itemize}\n\n\\subsubsection{Pin Generating Device}\n\nUsers have to use this device to generate an 8 digit pin number before\nthey request for a dynamic password. A user may insert their\nCredit/Debit card in to the Pin generating device and insert his/her\nfixed password. Using the card and password an 8 digit password may be\ngenerated. \n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.5]{pinsentry.pdf}\n  \\end{center}\n  \\caption{Pin Generating device software \\label{fig:pinsentry}}\n\\end{figure}\n\nHow a user would use the application?\\\\\n\n\\begin{enumerate}\n\\item Select the user's register ID from the drop down selection menu.\n\\item Enter the user's registration ID.\n\\item Enter the user's fixed password\n\\item Click the 'Generate' button.\n\\item Finally the generated password will be generated on the screen.\n\\end{enumerate}\n\nAlthough the users enter all of their authentication information in\nthis application, a real Pin generating device, does not prompt the\nuser to insert this information. Instead this information apart from\nthe user's fixed password, is obtained from the user's Credit/Debit\ncard when it is being inserted into the device. For that reason only\nfor the testing and debugging purposes the above design has been\nused. Besides the project's emphasis is on the algorithm that is being used to generate the pin numbers.\n\n\\paragraph{Algorithm}\\label{sec:algorithm}\n:\\\\\\\\\nFirstly the following algorithm generates a hexadecimal value\n$X$, assuming that the byte array that has been returned by $H$ the\nSHA2-512 hashing algorithm, has been converted to hexadecimal. If all\npossible time values are $TM$, given a time stamp of the current time\nrounded to the nearest minute is $TT$ we can say that $TT\\in\nTM$. The $TT$ is rounded to the nearest minute since it removes added\ncomplications to the algorithm by the \"Seconds\" fraction of the time\nstamp, when the server authenticates the pin number (More on pin number\nauthentication in section \\ref{sec:server_auth_alg}). We assume that $\\{U_i,\\dots,U_n\\} $ are $n$ parties who are registered with\nLAPPS. $ID_{U_i}$ denotes the $U_i$'s unique identity. $FP_{U_i}$ implies the fixed password of $U_i$.\n\n", "itemtype": "equation", "pos": 32898, "prevtext": "\n\nTrigger 2: Deletes the passwords that have been used.\\\\\n\nThe pseudo code of the triggers:\n\\begin{verbatim}\nBEGIN\nDELETE FROM allocation WHERE used=true;\nRETURN NULL;\nEND\n\\end{verbatim}\n\nIf that the $\\{a_i,\\dots, a_n\\}$ are $n$ allocations. The trigger iterates\nthrough all $n$ allocations $A$ and deletes the allocation records that\nthe 'used' column of it $PT_{a_i}$ has been assigned to the value\n\\emph{true}. Furthermore, after the trigger has been fired we can say that,\n\n", "index": 7, "text": "\n\\[\n\\forall a \\in A : PT_a = false\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\forall a\\in A:PT_{a}=false\" display=\"block\"><mrow><mrow><mrow><mo>\u2200</mo><mi>a</mi></mrow><mo>\u2208</mo><mi>A</mi></mrow><mo>:</mo><mrow><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>T</mi><mi>a</mi></msub></mrow><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>e</mi></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nSecondly loop through the characters $x_i$ of $X$ and retrieve the\nfirst four characters that are $x_i \\in D$ where $D$ denotes digits\nfrom 0 to 9. Reverse the hexadecimal string and then again carryout\nthe same procedure to find the final four digits of the eight digit number.\n\nEvery minute this pin number will change due to how hash functions\nwork with the salted time stamp. Which means that the pin numbers that\nare being generated by using this technique will only be valid for around a minute or two (Further discussion is in section \\ref{sec:server_auth_alg}).\n\nIt is highly unlikely that someone would be able to guess or crack\nthis password, using today's computational power within this limited\ntime frame. The added salts make it even harder.\n\n\\paragraph{Software Design}\\label{sec:pinsentry_design}:\\\\\n\nThe software consists of two classes Hasher and the PinSentry. Figure \\ref{fig:Diagram2_pinsentry} shows a class diagram of these two classes.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.43]{Diagram2_pinsentry.pdf}\n  \\end{center}\n  \\caption{The class diagram of the Pin Generating device software \\label{fig:Diagram2_pinsentry}}\n\\end{figure}\n\nThe PinSentry class creates all the Graphical User Interface for the\nusers to insert their authentication information and to display the\ngenerated pin numbers. The static methods in the Hasher class has been\nused by the PinSentry class to generate the hash values and to convert\nthem to Hexadecimal values.\n\nAs shown in figure \\ref{fig:Diagram2_pinsentry}, a Pinsentry has a Hasher (1..1).\n\nHasher uses Java's inbuilt libraries to hash the strings. In\nparticular the \"java.security.MessageDigest\" class. The PinSentry\nclass may only produce a pin number only if the given authentication\ninformation were correct. Although do not forget that even if the\nPinSentry device allowed the users to enter invalid fixed passwords, because\nthe inserted fixed password completely depends on the pin number\ngeneration, the server will deny the pin numbers that are generated with invalid pin numbers.\n\n\\subsubsection{LAPPS Server}\\label{sec:lapps_server}\nThe server application has been developed using the Java\ntechnology. This Java daemon listens on a port in the host\ncomputer until a client connects to it. The current implementation\nonly waits for \"GETPASS\" requests. Though more services can easily\nbe adapted to the server in future (More on section \\ref{sec:client_server_communication}). When the client sends a \"GETPASS\"\nrequest to the server with it's authentication information and\nlocation information, the server daemon will reply with a password\nonly if the authentication information is correct. \n\n\\paragraph{Software Design}\\label{sec:lappsServer_software_design}:\\\\\n\nFigure \\ref{fig:lappsServer_software_design} shows a diagram of\ndesign of the LAPPS Server.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.28]{Diagram3_lappsServer.pdf}\n  \\end{center}\n  \\caption{The class diagram of the LAPPS server}\n  \\label{fig:lappsServer_software_design}\n\\end{figure}\n\nLAPPS server is a daemon service that is preferably running on a\nserver machine. Which means that powerful hardware is needed to handle\nthe number of incoming requests from the clients. The current client\napplication is designed for the Android platform. The LAPPS server is\nable to handle \"GETPASS\" requests from the clients as described in the\nbeginning of the \\ref{sec:lapps_server} section. \n\nFigure \\ref{fig:lappsServer_software_design} illustrates the\nrelationships between the classes. LAPPSServer class has an instance of the Db class, a Hasher and a QRCodeGenerator (1..1).\n\nThe most befitting way to elucidate the relationships of the bare mechanisms\ninside the LAPPSServer is to analyse it's work flow. So the following\nsection \\ref{sec:server_workflow} unravels the inside code\nmechanisms of the LAPPSServer which responds to requests that it\nreceives (described in the protocol section \\ref{sec:lapps_protocol}) by the client applications.\n\n\\subparagraph{The server's work flow}\\label{sec:server_workflow}\n\n\\begin{enumerate}\n\\item The LAPPSServer waits passively for client requests.\n\\item The client connects to the server. Then the server will be\n  passively waiting for requests from the clients.\n\\item Client application sends a \"GETPASS\" request to the server with\n  other geographical and authentication information (More on password requests in section \\ref{sec:client_server_communication}).\n\\item LAPPSServer validates the 8 digit number (More on 8 digit pin number\n  generation in section \\ref{sec:algorithm} and validation in section \\ref{sec:server_auth_alg}).\n\\item If the 8 digit number does not match then an error message will\n  be sent back to the client encoded in to a QR Code(More on error\n  messages in section \\ref{code:fail:error}).\n\\item If the 8 digit number is correct then, LAPPSServer checks if\n  there are any Automated Teller Machines that is less than 20 metres\n  away from the user. (More on finding the nearest ATMs in section \\ref{sec:calc_atm_dist}\n\\item If there are no any \\glspl{atm} then an error message is sent\n  back to the client encoded in to a QR code (More on error messages in section\n  \\ref{code:fail:error}).\n\\item Then a random unique password is created that has not been\n  generated before (More on password generation in\n  section\\ref{sec:password_generation})\n\\item The generated password is hashed using SHA2-512 one way hash\n  function. The returned byte array from the function is then\n  converted to Hexadecimal. This is done so this value will be stored\n  in the database as a substitute to storing the password in plain\n  text. Accordingly the security of the passwords strengthened.\n\\item If there is an allocation record that belongs to the same user\n  already in the database, then the server deletes it before storing\n  the new allocation into the table, as one user is allowed to have\n  only one active allocation/password at a time (More on storing\n  allocations in section \\ref{sec:allocate_new_pass}).\n\\item The generated password and the closest \\gls{atm} are allocated to the user by  storing a record in the 'allocation' table with the generated password, the ID of the \\gls{atm}, the ID of the user, the registration ID of\n  the user's application and the expiry time of the allocation (More on storing\n  allocations in section \\ref{sec:allocate_new_pass}). \n\\item A response message is created with the ID of the allocated\n  \\gls{atm} and the password (More on successful messages in section \\ref{sec:client_server_communication}).\n\\item Then this respond message is encoded in to a QR code, which in\n  size vary according to the size of the message (More on QR code\n  generation in section \\ref{sec:qr_generation}).  \n\\item Finally the QR code with the generated password and the\n  ID of the allocated \\gls{atm} is sent back to the client.\n\\end{enumerate}\n\n\\paragraph{Allocating new passwords}\\label{sec:allocate_new_pass}:\\\\\n\nLet $\\{a_i,\\dots,a_n\\}$ be all $n$ active allocations $A$ that are\nin the database. $U_i$ is a user that owns an allocation. This user\nmay only have one and only allocation $a_{u_i}$ at a time in the\n'allocation table'. Such that:\n\n", "itemtype": "equation", "pos": 36755, "prevtext": "\n\n\\subparagraph{password Table}\\label{password_table}:\\\\\n\nAll the passwords that have been generated, are stored in this table\nwith its corresponding expiry date and time. \\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item password - The password (Primary Key).\n\\item expTime  - The expiry time of the password.\n\\end{itemize}\n\nThe expiry time of the passwords have been calculated by the server. The\nserver adds 5 minutes to the current time and then stores the value in\nthe expTime column along with each generated password.\n\n\\subparagraph{allocation Table}\\label{sec:allocation_table}:\\\\\n\nThis table contains all of the allocations that are alive on time. One\nallocation has got the lifetime of 5 minutes. A trigger will delete\nthe expired rows. Ideally all of the passwords that are in this table,\nare only unused allocations since the used allocations will be deleted\nby one of the triggers. Of course there is a time window before the\ntriggers have been fired, where the used or expired allocations still\nwill be in this table.\n\nInitially every time LAPPS has successfully generated a password, a\nrecord will be added to this table. A user will have just one record\nin this table at a time, since LAPPSServer makes sure that a user can have only one allocation/Password at a time.\\\\\n\nColumn description:\n\n\\begin{itemize}\n\\item userId - The ID of the user that the password has been allocated\n  to(Foreign key).\n\\item password - The allocated password (Foreign key).\n\\item atmId - The ID of the ATM that the password has been\n  allocated to (Foreign key).\n\\item used - Boolean flag; true if the password has been used, false otherwise.\n\\end{itemize}\n\n\\subsubsection{Pin Generating Device}\n\nUsers have to use this device to generate an 8 digit pin number before\nthey request for a dynamic password. A user may insert their\nCredit/Debit card in to the Pin generating device and insert his/her\nfixed password. Using the card and password an 8 digit password may be\ngenerated. \n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.5]{pinsentry.pdf}\n  \\end{center}\n  \\caption{Pin Generating device software \\label{fig:pinsentry}}\n\\end{figure}\n\nHow a user would use the application?\\\\\n\n\\begin{enumerate}\n\\item Select the user's register ID from the drop down selection menu.\n\\item Enter the user's registration ID.\n\\item Enter the user's fixed password\n\\item Click the 'Generate' button.\n\\item Finally the generated password will be generated on the screen.\n\\end{enumerate}\n\nAlthough the users enter all of their authentication information in\nthis application, a real Pin generating device, does not prompt the\nuser to insert this information. Instead this information apart from\nthe user's fixed password, is obtained from the user's Credit/Debit\ncard when it is being inserted into the device. For that reason only\nfor the testing and debugging purposes the above design has been\nused. Besides the project's emphasis is on the algorithm that is being used to generate the pin numbers.\n\n\\paragraph{Algorithm}\\label{sec:algorithm}\n:\\\\\\\\\nFirstly the following algorithm generates a hexadecimal value\n$X$, assuming that the byte array that has been returned by $H$ the\nSHA2-512 hashing algorithm, has been converted to hexadecimal. If all\npossible time values are $TM$, given a time stamp of the current time\nrounded to the nearest minute is $TT$ we can say that $TT\\in\nTM$. The $TT$ is rounded to the nearest minute since it removes added\ncomplications to the algorithm by the \"Seconds\" fraction of the time\nstamp, when the server authenticates the pin number (More on pin number\nauthentication in section \\ref{sec:server_auth_alg}). We assume that $\\{U_i,\\dots,U_n\\} $ are $n$ parties who are registered with\nLAPPS. $ID_{U_i}$ denotes the $U_i$'s unique identity. $FP_{U_i}$ implies the fixed password of $U_i$.\n\n", "index": 9, "text": "\n\\[\nX = H( H(FP_{U_i}) + t + ID_{U_i})\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"X=H(H(FP_{U_{i}})+t+ID_{U_{i}})\" display=\"block\"><mrow><mi>X</mi><mo>=</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>F</mi><mo>\u2062</mo><msub><mi>P</mi><msub><mi>U</mi><mi>i</mi></msub></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mi>t</mi><mo>+</mo><mrow><mi>I</mi><mo>\u2062</mo><msub><mi>D</mi><msub><mi>U</mi><mi>i</mi></msub></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nConsequently before allocating a new password the LAPPSServer queries\nthe database to ensure that there will not be another active allocation in the\ndatabase. If there is already a valid allocation, the sever deletes it\nbefore storing the new allocation/password in to the database. How\nthis can be achieved is presented in the following pseudo code of a SQL query.\n\n\\begin{verbatim}\nDELETE FROM allocation WHERE userId=<USER_ID>\n\\end{verbatim}\n\nThen to store the new allocation the server executes an SQL\ncommand. The following pseudo code shows how this is done.\n\n\\begin{verbatim}\nINSERT INTO allocation(userId, password, atmId, used)\nVALUES(<USER_ID>, <GENERATED_PASSWORD>, <ALLOCATED_ATM>, false)\n\\end{verbatim}\n\n\\paragraph{Communication between the server and client} \\label{sec:client_server_communication}:\\\\\n\nThe communication between the client and the server is carried out by\nusing TLS over TCP/IP sockets. The reason for using TCP/IP sockets is\nthe low overhead when transferring data over. The TLS layer will\nencrypt the data since the data being transferred are private and\nconfidential.\\\\\n\nJava JDK comes with a tool called \"keytool\" that can be used to\ngenerate key stores and to export them to certificates. In this\nproject the author has used the \"keytool\" to create the key\nstores. This tool can be used to generate key stores for debugging\npurposes. A commercial certificate that is signed by a certificate\nauthority (CA) can be created by buying certificates from a well known\ncertificate authority such as \"Verisign\" and importing/signing your certificates by the bought certificate.\n\nAfter a secured connection has been established the client and the server\nuses the following messaging techniques to communicate with each\nother.\n\nThe client application sends \"GETPASS\" requests to the server to\nrequest dynamic passwords to be able to use on \\glspl{atm}. \n\nAn example of a \"GETPASS\" request.\\\\\n\n\\emph{GETPASS $<$8 digit pin$>$ $<$userID$>$ $<$reg ID$>$\n  $<$latitude$>$ $<$longitude$>$}\\\\\n\nIf the request is valid the server generates a password and finds\nand designates this password to the nearest Automated Tailor Machine\nto the user. Finally it creates a response message by concatenating\nthis information. \\\\\n\nA response message of successful transaction looks like as follows.\\\\\n\n\\emph{ SUCCESS: $<$atm\\_id$>$ $<$password$>$} \\\\\n\n\nAnd a response/error message of unsuccessful transaction looks like as\nfollows.\\\\\n\n\\emph{ FAIL: $<$ The Error message $>$}\\\\ \\label{code:fail:error}\n\nThe LAPPSServer has been coded so that new mechanisms can be easily\nimplemented in the future. It has been achieved by modularising the code\nthat deals with divergent request messages. Alternately the\nencapsulated code makes the program code easy to read. \\\\\n\nThe following pseudo code shows how this is done in the LAPPSServer\nclass. To demonstrate how code that deals with new request codes can\nbe added, the following code contains a dummy block of code that deals\nwith \"HELP\" requests. \n\n\\begin{verbatim}\nwhile (true) {\n  if (connection.hasRequests()) {\n   \n/****Deals with GETPASS requests***/ \n   if (connection.next().equals(\"GETPASS\")) {\n      recieveInformation();\n      if (matchPasswords() && hasATMs()) {\n        sendPassword();\n      } else {\n        sendErrorMessage();\n      }\n   }\n/**********************************/ \n\n/****Deals with \"HELP\" requests***/ \n   if (connection.next().equals(\"HELP\")) {\n     //Add code to deal with \"HELP\" requests.\n   }\n/**********************************/ \n\n   // Code for handling other request codes can be added here\n}\n\\end{verbatim}\n\n\\paragraph{The LAPPS Protocol}\\label{sec:lapps_protocol}\n\n:\\\\\n\nA successful transaction will undertake following steps to\nsuccessfully retrieve a password from the LAPPS Server as shown in\n\"figure \\ref{fig:protocol}\".\n\n\\begin{enumerate}\n\\item Client establishes a TLS over TCP/IP Connection to the server.\n\\item Server responds with an Acknowledgement message to the client.\n\\item Client sends a \"GETPASS\" request to the server with the\n  additional information.\n\\item If the authentication information are correct then the server\n  responds with a password with the ID of its allocated \\gls{atm}.\n\\item Client closes the connection. \n\\end{enumerate}\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{lapps_protocol.pdf}\n  \\end{center}\n  \\caption{The Protocol of the LAPPS Architecture}\n  \\label{fig:protocol}\n\\end{figure}\n\nIf the server is unable to send the acknowledgement message, the\nclient would not carry out any other requests. Since this message\nensures the client that it is open for any requests from the client.\n\n\\paragraph{Password generation}\\label{sec:password_generation}\n:\\\\\nA character in a password is generated by;\n\n\\begin{enumerate}\n\\item Store the valid characters in an array. \n\\item Then by using a random number generator, generate a random\n  number that is no greater than the size of the array. \n\\item Finally get the character that the subscript value of it is equal\n  to the generated random number.\n\\item This procedure is carried out eight (The number of characters in\n  the password) times.\n\\item Finally To make the generated password unique, the server\n  queries the \"password\" column in the \"password\" table and look for\n  pre-generated passwords. If the password already exists, then\n  another password is generated and compared until it generates a\n  password that does not exist in the database. Although this adds a\n  high overhead on the password generation process as the database\n  grows.\n\\end{enumerate}\n\nThe length of the password can easily be variable as easily as changing\nan Integer variable in the LAPPSServer class.\n\nThe pseudo code of the SQL query that looks for existing matching\npasswords in the 'password' column.\n\n\\begin{verbatim}\nSELECT password FROM password WHERE password=<generated_password>\n\\end{verbatim}\n\nIf this query returns a Result Set then this password already exists in\nthe database.\\\\\n\nMore suggestions on password generation:\\\\\n\nTo make the sequence of characters even more random, the array can be shuffled\nformer to the selection. Although this will add an overhead when generating a password.\n\n\\paragraph{Finding the nearest Automated Tailor Machine}\\label{sec:calc_atm_dist}\n\n:\\\\\n\nThe author has used PostGIS extension to calculate the distances between two\npoints in spatial surfaces as it allows programmers to manipulate spatial objects in PostgreSQL databases. \n\nIn the table called \"atm\" contains the location information of all of\nthe \\glspl{atm} that belongs to the system. The location information are\nstored as 'Geometry' typed instances. \n\nThe geometrical information that is retrieved are likely to be in the\nformat of \\gls{wgs} 1984 system. The \\gls{srid} of this is '4326'. The\ngeometrical instances are stored in the type of \\gls{srid} 27700 since\nthe author lives in England, United Kingdom. Because depending on where the\nobjects are geographically located the \\gls{srid} changes.\n\nThe properties of the \\gls{srid} 2770 in the EPSG Geodetic Parameter\nRegistry \\cite{EPSG_web} is as below.\n\n\\begin{itemize}\n\\item Name            : OSGB 1936 / British National Grid \\\\\n\\item Code            : EPSG::27700 \\\\\n\\item Type            : ProjectedCRS \\\\\n\\item Area Description: United Kingdom (UK) - Great Britain - England and Wales onshore, Scotland onshore and Western Isles nearshore; Isle of Man onshore.\\\\\n\\end{itemize}\n\nHaving got these locations stored in the database, to find the nearest\n\\gls{atm} machine to the user the server follows the following\nprocedure. \n\n\\begin{enumerate}\n\\item Convert the user's geographical information in to the \\gls{srid}\n  27700 format.\n\\item Query the database, and calculate the distance between the\n  user's geographical spatial point and the \\glspl{atm} points.\n\\item Then retrieve the \\gls{atm} information of the \\glspl{atm} that\n  are in distance of less than 20 meters away from user. Therefore in the\n  retrieved result set $\\{r_i,\\dots, r_n\\}$ of all $n$ elements $R$\n  the calculated distance is stored in the virtual column\n  'distance'. Such that,\n \n", "itemtype": "equation", "pos": 44009, "prevtext": "\n\nSecondly loop through the characters $x_i$ of $X$ and retrieve the\nfirst four characters that are $x_i \\in D$ where $D$ denotes digits\nfrom 0 to 9. Reverse the hexadecimal string and then again carryout\nthe same procedure to find the final four digits of the eight digit number.\n\nEvery minute this pin number will change due to how hash functions\nwork with the salted time stamp. Which means that the pin numbers that\nare being generated by using this technique will only be valid for around a minute or two (Further discussion is in section \\ref{sec:server_auth_alg}).\n\nIt is highly unlikely that someone would be able to guess or crack\nthis password, using today's computational power within this limited\ntime frame. The added salts make it even harder.\n\n\\paragraph{Software Design}\\label{sec:pinsentry_design}:\\\\\n\nThe software consists of two classes Hasher and the PinSentry. Figure \\ref{fig:Diagram2_pinsentry} shows a class diagram of these two classes.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.43]{Diagram2_pinsentry.pdf}\n  \\end{center}\n  \\caption{The class diagram of the Pin Generating device software \\label{fig:Diagram2_pinsentry}}\n\\end{figure}\n\nThe PinSentry class creates all the Graphical User Interface for the\nusers to insert their authentication information and to display the\ngenerated pin numbers. The static methods in the Hasher class has been\nused by the PinSentry class to generate the hash values and to convert\nthem to Hexadecimal values.\n\nAs shown in figure \\ref{fig:Diagram2_pinsentry}, a Pinsentry has a Hasher (1..1).\n\nHasher uses Java's inbuilt libraries to hash the strings. In\nparticular the \"java.security.MessageDigest\" class. The PinSentry\nclass may only produce a pin number only if the given authentication\ninformation were correct. Although do not forget that even if the\nPinSentry device allowed the users to enter invalid fixed passwords, because\nthe inserted fixed password completely depends on the pin number\ngeneration, the server will deny the pin numbers that are generated with invalid pin numbers.\n\n\\subsubsection{LAPPS Server}\\label{sec:lapps_server}\nThe server application has been developed using the Java\ntechnology. This Java daemon listens on a port in the host\ncomputer until a client connects to it. The current implementation\nonly waits for \"GETPASS\" requests. Though more services can easily\nbe adapted to the server in future (More on section \\ref{sec:client_server_communication}). When the client sends a \"GETPASS\"\nrequest to the server with it's authentication information and\nlocation information, the server daemon will reply with a password\nonly if the authentication information is correct. \n\n\\paragraph{Software Design}\\label{sec:lappsServer_software_design}:\\\\\n\nFigure \\ref{fig:lappsServer_software_design} shows a diagram of\ndesign of the LAPPS Server.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.28]{Diagram3_lappsServer.pdf}\n  \\end{center}\n  \\caption{The class diagram of the LAPPS server}\n  \\label{fig:lappsServer_software_design}\n\\end{figure}\n\nLAPPS server is a daemon service that is preferably running on a\nserver machine. Which means that powerful hardware is needed to handle\nthe number of incoming requests from the clients. The current client\napplication is designed for the Android platform. The LAPPS server is\nable to handle \"GETPASS\" requests from the clients as described in the\nbeginning of the \\ref{sec:lapps_server} section. \n\nFigure \\ref{fig:lappsServer_software_design} illustrates the\nrelationships between the classes. LAPPSServer class has an instance of the Db class, a Hasher and a QRCodeGenerator (1..1).\n\nThe most befitting way to elucidate the relationships of the bare mechanisms\ninside the LAPPSServer is to analyse it's work flow. So the following\nsection \\ref{sec:server_workflow} unravels the inside code\nmechanisms of the LAPPSServer which responds to requests that it\nreceives (described in the protocol section \\ref{sec:lapps_protocol}) by the client applications.\n\n\\subparagraph{The server's work flow}\\label{sec:server_workflow}\n\n\\begin{enumerate}\n\\item The LAPPSServer waits passively for client requests.\n\\item The client connects to the server. Then the server will be\n  passively waiting for requests from the clients.\n\\item Client application sends a \"GETPASS\" request to the server with\n  other geographical and authentication information (More on password requests in section \\ref{sec:client_server_communication}).\n\\item LAPPSServer validates the 8 digit number (More on 8 digit pin number\n  generation in section \\ref{sec:algorithm} and validation in section \\ref{sec:server_auth_alg}).\n\\item If the 8 digit number does not match then an error message will\n  be sent back to the client encoded in to a QR Code(More on error\n  messages in section \\ref{code:fail:error}).\n\\item If the 8 digit number is correct then, LAPPSServer checks if\n  there are any Automated Teller Machines that is less than 20 metres\n  away from the user. (More on finding the nearest ATMs in section \\ref{sec:calc_atm_dist}\n\\item If there are no any \\glspl{atm} then an error message is sent\n  back to the client encoded in to a QR code (More on error messages in section\n  \\ref{code:fail:error}).\n\\item Then a random unique password is created that has not been\n  generated before (More on password generation in\n  section\\ref{sec:password_generation})\n\\item The generated password is hashed using SHA2-512 one way hash\n  function. The returned byte array from the function is then\n  converted to Hexadecimal. This is done so this value will be stored\n  in the database as a substitute to storing the password in plain\n  text. Accordingly the security of the passwords strengthened.\n\\item If there is an allocation record that belongs to the same user\n  already in the database, then the server deletes it before storing\n  the new allocation into the table, as one user is allowed to have\n  only one active allocation/password at a time (More on storing\n  allocations in section \\ref{sec:allocate_new_pass}).\n\\item The generated password and the closest \\gls{atm} are allocated to the user by  storing a record in the 'allocation' table with the generated password, the ID of the \\gls{atm}, the ID of the user, the registration ID of\n  the user's application and the expiry time of the allocation (More on storing\n  allocations in section \\ref{sec:allocate_new_pass}). \n\\item A response message is created with the ID of the allocated\n  \\gls{atm} and the password (More on successful messages in section \\ref{sec:client_server_communication}).\n\\item Then this respond message is encoded in to a QR code, which in\n  size vary according to the size of the message (More on QR code\n  generation in section \\ref{sec:qr_generation}).  \n\\item Finally the QR code with the generated password and the\n  ID of the allocated \\gls{atm} is sent back to the client.\n\\end{enumerate}\n\n\\paragraph{Allocating new passwords}\\label{sec:allocate_new_pass}:\\\\\n\nLet $\\{a_i,\\dots,a_n\\}$ be all $n$ active allocations $A$ that are\nin the database. $U_i$ is a user that owns an allocation. This user\nmay only have one and only allocation $a_{u_i}$ at a time in the\n'allocation table'. Such that:\n\n", "index": 11, "text": "\n\\[\n\\exists ! a \\in A: a \\mapsto U_i\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\exists!a\\in A:a\\mapsto U_{i}\" display=\"block\"><mrow><mrow><mrow><mrow><mo>\u2203</mo><mo lspace=\"0pt\" rspace=\"3.5pt\">!</mo></mrow><mo>\u2061</mo><mi>a</mi></mrow><mo>\u2208</mo><mi>A</mi></mrow><mo>:</mo><mrow><mi>a</mi><mo>\u21a6</mo><msub><mi>U</mi><mi>i</mi></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": " \n\\item Order the Result set by the distance.\n\\item Get the top/first element of the Result Set.\n\\end{enumerate}\n\nAll of above steps can be done by using one query.\n\nTo calculate the distance the author has used the st\\_distance\\_sphere()\nfunction of PostGIS \\cite{postgis_manual}. \n\nThe author used two variations of the query that had two widely\ndifferent performance levels.\n\nThe first query was a simple query that calculates the distance from\nthe given user's geographical location (latitude, longitude) and the\nall other \\glspl{atm} in the database. Then it orders the result by\nthe distance and finally retrieve the first row which is the closest\n\\gls{atm} to the user. The SQL query is as shown below.\n\n\\begin{verbatim}\nSELECT atmId, st_distance_sphere(PointFromText('POINT(latitude longitude)',\n27700), geom) AS Distance  \nFrom atm \norder by distance \nlimit 1;\n\\end{verbatim}\n\nThis is not the optimum solution. This query calculates the distance\nfor every \\gls{atm} in the database which can easily be millions in real\nlife. So due to this issue there will be an unacceptable overhead when\nexecuting this SQL query.\n\nThe SQL query that is currently implemented in LAPPSServer is the\nfollowing. \n\n\\begin{verbatim}\nSELECT atmId, st_distance_sphere(PointFromText('POINT(latitude \nlongitude)',27700), geom) AS distance\nFROM atm\nWHERE geom && expand(PointFromText('POINT(latitude longitude)',\n27700), 20) AND st_distance_sphere(PointFromText('POINT(latitude longitude)',\n27700), geom) < 20 \norder by distance\nlimit 1;\n\\end{verbatim}\n\nThis query creates a bounding box of 20 metres around the interest\npoint (User's location) and filters the rows that fits in this\nbox. Then it calculates the exact distances to the user location, orders the points by their distance to the user and finally\nselects the first row/point. \n\nThe author has found this query very efficient that it performs much\nfaster than the first query.\n\n\\paragraph{Authenticating users}\n:\\\\\nThe server authenticates the users by checking the validity of the 8\ndigit pin number, the ID of the user and the registration number.\n\nLet $ID^R_{U_i}$ be the received unique identification of the user $U_i$ and the\n$ID_{u_i}$ is the identification of $U_i$ in the database, $PN^R_{u_i}$ is the\nreceived 8 digit pin number that has been received by $U_i$ and\n$PN_{U_i}$ is the calculated 8 digit number by the LAPPSServer (More\non calculating the 8 digit number in section\n\\ref{sec:algorithm}) if $RN^R_{U_i}$ is the received\nregistration number of $U_i$ and $RN_{U_i}$ the stored registration\nnumber of $U_i$ in the database, we can say that only if $ID^R_{U_i} =\nID_{u_i}$ and $PN^R_{u_i} =  PN_{U_i}$ and $ RN^R_{U_i} =  RN_{U_i}$\nthat $U_i$ is authoritative.\n\nThe registration number is assigned to the particular instance of the\nLAPPSMobile android mobile application. When $U_i$ registers\nhis/her mobile device with the user account, this field will be\nallocated.\n\n\\subparagraph{Algorithm to authenticate 8 digit number}\\label{sec:server_auth_alg}\n:\\\\\nTo check if the 8 digit number is correct. The server uses the\nsame algorithm as the Pin generating device. The author has described how this\nis done in section \\ref{sec:algorithm}. Server is capable of\ncalculating the same algorithm independently since the user ID and the\ncorresponding fix password are stored in the lappStore database.\n\nThe server calculates the same algorithm $f$ using the current time stamp\nrounded to the nearest minute. But when the server does this, the\nrounded minute might be different to the one that the Pin generating\ndevice has been used. For an instance, if the user $U_i$ has generated\na pin number $PN^R_{U_i}$ at \"12.30:45\" then server calculates the pin\nnumber at \"12.31:15\", the rounded time stamp of the server will be\n12.31:00 where as the Pin generating device has used \"12.30:00\" when\ncalculating the password. For that reason, if the generated 8 digit\nnumber $PN_{u_i}$ of $U_i$ does not match it will generate another pin\nnumber using $f$ but rounding up the time stamp $TT_{ms}$ after removing a\nminute in milliseconds $ms$ from the time stamp. To make the following\nnotation simple and clear $GU$ denotes the authenticated users. Such that,\n\nThe first attempt to authenticate:\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nConsequently before allocating a new password the LAPPSServer queries\nthe database to ensure that there will not be another active allocation in the\ndatabase. If there is already a valid allocation, the sever deletes it\nbefore storing the new allocation/password in to the database. How\nthis can be achieved is presented in the following pseudo code of a SQL query.\n\n\\begin{verbatim}\nDELETE FROM allocation WHERE userId=<USER_ID>\n\\end{verbatim}\n\nThen to store the new allocation the server executes an SQL\ncommand. The following pseudo code shows how this is done.\n\n\\begin{verbatim}\nINSERT INTO allocation(userId, password, atmId, used)\nVALUES(<USER_ID>, <GENERATED_PASSWORD>, <ALLOCATED_ATM>, false)\n\\end{verbatim}\n\n\\paragraph{Communication between the server and client} \\label{sec:client_server_communication}:\\\\\n\nThe communication between the client and the server is carried out by\nusing TLS over TCP/IP sockets. The reason for using TCP/IP sockets is\nthe low overhead when transferring data over. The TLS layer will\nencrypt the data since the data being transferred are private and\nconfidential.\\\\\n\nJava JDK comes with a tool called \"keytool\" that can be used to\ngenerate key stores and to export them to certificates. In this\nproject the author has used the \"keytool\" to create the key\nstores. This tool can be used to generate key stores for debugging\npurposes. A commercial certificate that is signed by a certificate\nauthority (CA) can be created by buying certificates from a well known\ncertificate authority such as \"Verisign\" and importing/signing your certificates by the bought certificate.\n\nAfter a secured connection has been established the client and the server\nuses the following messaging techniques to communicate with each\nother.\n\nThe client application sends \"GETPASS\" requests to the server to\nrequest dynamic passwords to be able to use on \\glspl{atm}. \n\nAn example of a \"GETPASS\" request.\\\\\n\n\\emph{GETPASS $<$8 digit pin$>$ $<$userID$>$ $<$reg ID$>$\n  $<$latitude$>$ $<$longitude$>$}\\\\\n\nIf the request is valid the server generates a password and finds\nand designates this password to the nearest Automated Tailor Machine\nto the user. Finally it creates a response message by concatenating\nthis information. \\\\\n\nA response message of successful transaction looks like as follows.\\\\\n\n\\emph{ SUCCESS: $<$atm\\_id$>$ $<$password$>$} \\\\\n\n\nAnd a response/error message of unsuccessful transaction looks like as\nfollows.\\\\\n\n\\emph{ FAIL: $<$ The Error message $>$}\\\\ \\label{code:fail:error}\n\nThe LAPPSServer has been coded so that new mechanisms can be easily\nimplemented in the future. It has been achieved by modularising the code\nthat deals with divergent request messages. Alternately the\nencapsulated code makes the program code easy to read. \\\\\n\nThe following pseudo code shows how this is done in the LAPPSServer\nclass. To demonstrate how code that deals with new request codes can\nbe added, the following code contains a dummy block of code that deals\nwith \"HELP\" requests. \n\n\\begin{verbatim}\nwhile (true) {\n  if (connection.hasRequests()) {\n   \n/****Deals with GETPASS requests***/ \n   if (connection.next().equals(\"GETPASS\")) {\n      recieveInformation();\n      if (matchPasswords() && hasATMs()) {\n        sendPassword();\n      } else {\n        sendErrorMessage();\n      }\n   }\n/**********************************/ \n\n/****Deals with \"HELP\" requests***/ \n   if (connection.next().equals(\"HELP\")) {\n     //Add code to deal with \"HELP\" requests.\n   }\n/**********************************/ \n\n   // Code for handling other request codes can be added here\n}\n\\end{verbatim}\n\n\\paragraph{The LAPPS Protocol}\\label{sec:lapps_protocol}\n\n:\\\\\n\nA successful transaction will undertake following steps to\nsuccessfully retrieve a password from the LAPPS Server as shown in\n\"figure \\ref{fig:protocol}\".\n\n\\begin{enumerate}\n\\item Client establishes a TLS over TCP/IP Connection to the server.\n\\item Server responds with an Acknowledgement message to the client.\n\\item Client sends a \"GETPASS\" request to the server with the\n  additional information.\n\\item If the authentication information are correct then the server\n  responds with a password with the ID of its allocated \\gls{atm}.\n\\item Client closes the connection. \n\\end{enumerate}\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{lapps_protocol.pdf}\n  \\end{center}\n  \\caption{The Protocol of the LAPPS Architecture}\n  \\label{fig:protocol}\n\\end{figure}\n\nIf the server is unable to send the acknowledgement message, the\nclient would not carry out any other requests. Since this message\nensures the client that it is open for any requests from the client.\n\n\\paragraph{Password generation}\\label{sec:password_generation}\n:\\\\\nA character in a password is generated by;\n\n\\begin{enumerate}\n\\item Store the valid characters in an array. \n\\item Then by using a random number generator, generate a random\n  number that is no greater than the size of the array. \n\\item Finally get the character that the subscript value of it is equal\n  to the generated random number.\n\\item This procedure is carried out eight (The number of characters in\n  the password) times.\n\\item Finally To make the generated password unique, the server\n  queries the \"password\" column in the \"password\" table and look for\n  pre-generated passwords. If the password already exists, then\n  another password is generated and compared until it generates a\n  password that does not exist in the database. Although this adds a\n  high overhead on the password generation process as the database\n  grows.\n\\end{enumerate}\n\nThe length of the password can easily be variable as easily as changing\nan Integer variable in the LAPPSServer class.\n\nThe pseudo code of the SQL query that looks for existing matching\npasswords in the 'password' column.\n\n\\begin{verbatim}\nSELECT password FROM password WHERE password=<generated_password>\n\\end{verbatim}\n\nIf this query returns a Result Set then this password already exists in\nthe database.\\\\\n\nMore suggestions on password generation:\\\\\n\nTo make the sequence of characters even more random, the array can be shuffled\nformer to the selection. Although this will add an overhead when generating a password.\n\n\\paragraph{Finding the nearest Automated Tailor Machine}\\label{sec:calc_atm_dist}\n\n:\\\\\n\nThe author has used PostGIS extension to calculate the distances between two\npoints in spatial surfaces as it allows programmers to manipulate spatial objects in PostgreSQL databases. \n\nIn the table called \"atm\" contains the location information of all of\nthe \\glspl{atm} that belongs to the system. The location information are\nstored as 'Geometry' typed instances. \n\nThe geometrical information that is retrieved are likely to be in the\nformat of \\gls{wgs} 1984 system. The \\gls{srid} of this is '4326'. The\ngeometrical instances are stored in the type of \\gls{srid} 27700 since\nthe author lives in England, United Kingdom. Because depending on where the\nobjects are geographically located the \\gls{srid} changes.\n\nThe properties of the \\gls{srid} 2770 in the EPSG Geodetic Parameter\nRegistry \\cite{EPSG_web} is as below.\n\n\\begin{itemize}\n\\item Name            : OSGB 1936 / British National Grid \\\\\n\\item Code            : EPSG::27700 \\\\\n\\item Type            : ProjectedCRS \\\\\n\\item Area Description: United Kingdom (UK) - Great Britain - England and Wales onshore, Scotland onshore and Western Isles nearshore; Isle of Man onshore.\\\\\n\\end{itemize}\n\nHaving got these locations stored in the database, to find the nearest\n\\gls{atm} machine to the user the server follows the following\nprocedure. \n\n\\begin{enumerate}\n\\item Convert the user's geographical information in to the \\gls{srid}\n  27700 format.\n\\item Query the database, and calculate the distance between the\n  user's geographical spatial point and the \\glspl{atm} points.\n\\item Then retrieve the \\gls{atm} information of the \\glspl{atm} that\n  are in distance of less than 20 meters away from user. Therefore in the\n  retrieved result set $\\{r_i,\\dots, r_n\\}$ of all $n$ elements $R$\n  the calculated distance is stored in the virtual column\n  'distance'. Such that,\n \n", "index": 13, "text": "\\[\n  \\forall r \\in R: distance_r < 20\n  \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\forall r\\in R:distance_{r}&lt;20\" display=\"block\"><mrow><mrow><mrow><mo>\u2200</mo><mi>r</mi></mrow><mo>\u2208</mo><mi>R</mi></mrow><mo>:</mo><mrow><mrow><mi>d</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><msub><mi>e</mi><mi>r</mi></msub></mrow><mo>&lt;</mo><mn>20</mn></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56442, "prevtext": " \n\\item Order the Result set by the distance.\n\\item Get the top/first element of the Result Set.\n\\end{enumerate}\n\nAll of above steps can be done by using one query.\n\nTo calculate the distance the author has used the st\\_distance\\_sphere()\nfunction of PostGIS \\cite{postgis_manual}. \n\nThe author used two variations of the query that had two widely\ndifferent performance levels.\n\nThe first query was a simple query that calculates the distance from\nthe given user's geographical location (latitude, longitude) and the\nall other \\glspl{atm} in the database. Then it orders the result by\nthe distance and finally retrieve the first row which is the closest\n\\gls{atm} to the user. The SQL query is as shown below.\n\n\\begin{verbatim}\nSELECT atmId, st_distance_sphere(PointFromText('POINT(latitude longitude)',\n27700), geom) AS Distance  \nFrom atm \norder by distance \nlimit 1;\n\\end{verbatim}\n\nThis is not the optimum solution. This query calculates the distance\nfor every \\gls{atm} in the database which can easily be millions in real\nlife. So due to this issue there will be an unacceptable overhead when\nexecuting this SQL query.\n\nThe SQL query that is currently implemented in LAPPSServer is the\nfollowing. \n\n\\begin{verbatim}\nSELECT atmId, st_distance_sphere(PointFromText('POINT(latitude \nlongitude)',27700), geom) AS distance\nFROM atm\nWHERE geom && expand(PointFromText('POINT(latitude longitude)',\n27700), 20) AND st_distance_sphere(PointFromText('POINT(latitude longitude)',\n27700), geom) < 20 \norder by distance\nlimit 1;\n\\end{verbatim}\n\nThis query creates a bounding box of 20 metres around the interest\npoint (User's location) and filters the rows that fits in this\nbox. Then it calculates the exact distances to the user location, orders the points by their distance to the user and finally\nselects the first row/point. \n\nThe author has found this query very efficient that it performs much\nfaster than the first query.\n\n\\paragraph{Authenticating users}\n:\\\\\nThe server authenticates the users by checking the validity of the 8\ndigit pin number, the ID of the user and the registration number.\n\nLet $ID^R_{U_i}$ be the received unique identification of the user $U_i$ and the\n$ID_{u_i}$ is the identification of $U_i$ in the database, $PN^R_{u_i}$ is the\nreceived 8 digit pin number that has been received by $U_i$ and\n$PN_{U_i}$ is the calculated 8 digit number by the LAPPSServer (More\non calculating the 8 digit number in section\n\\ref{sec:algorithm}) if $RN^R_{U_i}$ is the received\nregistration number of $U_i$ and $RN_{U_i}$ the stored registration\nnumber of $U_i$ in the database, we can say that only if $ID^R_{U_i} =\nID_{u_i}$ and $PN^R_{u_i} =  PN_{U_i}$ and $ RN^R_{U_i} =  RN_{U_i}$\nthat $U_i$ is authoritative.\n\nThe registration number is assigned to the particular instance of the\nLAPPSMobile android mobile application. When $U_i$ registers\nhis/her mobile device with the user account, this field will be\nallocated.\n\n\\subparagraph{Algorithm to authenticate 8 digit number}\\label{sec:server_auth_alg}\n:\\\\\nTo check if the 8 digit number is correct. The server uses the\nsame algorithm as the Pin generating device. The author has described how this\nis done in section \\ref{sec:algorithm}. Server is capable of\ncalculating the same algorithm independently since the user ID and the\ncorresponding fix password are stored in the lappStore database.\n\nThe server calculates the same algorithm $f$ using the current time stamp\nrounded to the nearest minute. But when the server does this, the\nrounded minute might be different to the one that the Pin generating\ndevice has been used. For an instance, if the user $U_i$ has generated\na pin number $PN^R_{U_i}$ at \"12.30:45\" then server calculates the pin\nnumber at \"12.31:15\", the rounded time stamp of the server will be\n12.31:00 where as the Pin generating device has used \"12.30:00\" when\ncalculating the password. For that reason, if the generated 8 digit\nnumber $PN_{u_i}$ of $U_i$ does not match it will generate another pin\nnumber using $f$ but rounding up the time stamp $TT_{ms}$ after removing a\nminute in milliseconds $ms$ from the time stamp. To make the following\nnotation simple and clear $GU$ denotes the authenticated users. Such that,\n\nThe first attempt to authenticate:\n\n", "index": 15, "text": "$$PN_{u_i} = f(TT_{ms})$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"PN_{u_{i}}=f(TT_{ms})\" display=\"block\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>N</mi><msub><mi>u</mi><mi>i</mi></msub></msub></mrow><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>T</mi><mo>\u2062</mo><msub><mi>T</mi><mrow><mi>m</mi><mo>\u2062</mo><mi>s</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56468, "prevtext": "\n\n", "index": 17, "text": "$$If$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"If\" display=\"block\"><mrow><mi>I</mi><mo>\u2062</mo><mi>f</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56474, "prevtext": "\n", "index": 19, "text": "\n\\[\nPN^R_{U_i} = PN_{U_i}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"PN^{R}_{U_{i}}=PN_{U_{i}}\" display=\"block\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><msubsup><mi>N</mi><msub><mi>U</mi><mi>i</mi></msub><mi>R</mi></msubsup></mrow><mo>=</mo><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>N</mi><msub><mi>U</mi><mi>i</mi></msub></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56503, "prevtext": "\n\n", "index": 21, "text": "$$Then$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"Then\" display=\"block\"><mrow><mi>T</mi><mo>\u2062</mo><mi>h</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>n</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nThe second attempt to authenticate if the first attempt was unsuccessful:\n\n\n", "itemtype": "equation", "pos": 56511, "prevtext": "\n", "index": 23, "text": "\n\\[\nU_i \\in GU\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"U_{i}\\in GU\" display=\"block\"><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2208</mo><mrow><mi>G</mi><mo>\u2062</mo><mi>U</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56468, "prevtext": "\n\n", "index": 17, "text": "$$If$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"If\" display=\"block\"><mrow><mi>I</mi><mo>\u2062</mo><mi>f</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56611, "prevtext": "\n", "index": 27, "text": "\n\\[\nPN^R_{U_i} \\neq PN_{U_i}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"PN^{R}_{U_{i}}\\neq PN_{U_{i}}\" display=\"block\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><msubsup><mi>N</mi><msub><mi>U</mi><mi>i</mi></msub><mi>R</mi></msubsup></mrow><mo>\u2260</mo><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>N</mi><msub><mi>U</mi><mi>i</mi></msub></msub></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56503, "prevtext": "\n\n", "index": 21, "text": "$$Then$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"Then\" display=\"block\"><mrow><mi>T</mi><mo>\u2062</mo><mi>h</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>n</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56651, "prevtext": "\n", "index": 31, "text": "\n\\[\nPN_{u_i} = f(TT_{ms}-60000_{ms})\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"PN_{u_{i}}=f(TT_{ms}-60000_{ms})\" display=\"block\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>N</mi><msub><mi>u</mi><mi>i</mi></msub></msub></mrow><mo>=</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>T</mi><mo>\u2062</mo><msub><mi>T</mi><mrow><mi>m</mi><mo>\u2062</mo><mi>s</mi></mrow></msub></mrow><mo>-</mo><msub><mn>60000</mn><mrow><mi>m</mi><mo>\u2062</mo><mi>s</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56691, "prevtext": "\n\n", "index": 33, "text": "$$\\therefore$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\therefore\" display=\"block\"><mo>\u2234</mo></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56468, "prevtext": "\n\n", "index": 17, "text": "$$If$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"If\" display=\"block\"><mrow><mi>I</mi><mo>\u2062</mo><mi>f</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\n", "itemtype": "equation", "pos": 56712, "prevtext": "\n", "index": 37, "text": "\n\\[\nPN_{u_i} = PN^R_{U_i}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"PN_{u_{i}}=PN^{R}_{U_{i}}\" display=\"block\"><mrow><mrow><mi>P</mi><mo>\u2062</mo><msub><mi>N</mi><msub><mi>u</mi><mi>i</mi></msub></msub></mrow><mo>=</mo><mrow><mi>P</mi><mo>\u2062</mo><msubsup><mi>N</mi><msub><mi>U</mi><mi>i</mi></msub><mi>R</mi></msubsup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n", "itemtype": "equation", "pos": 56503, "prevtext": "\n\n", "index": 21, "text": "$$Then$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"Then\" display=\"block\"><mrow><mi>T</mi><mo>\u2062</mo><mi>h</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>n</mi></mrow></math>", "type": "latex"}, {"file": "1601.02117.tex", "nexttext": "\n\nFinally if $U_i$ is still $U_i \\notin GU$ then the received password request is\nnot approved.\\\\\n\nIn other words, if the received pin number is correct it will match with one of the two pin numbers that is generated by salting two different time stamps.\n\n\\paragraph{QR Code Generation}\\label{sec:qr_generation}:\\\\\n\nQRCodeGenerator class uses the \"com.google.zxing\" library to create QR\ncodes the a given string. In particular an instance of QRCodeWriter\nclass has been used to perform the encoding of the\nstrings. Alternately the encode() method returns a QR code of type\n'BufferedImage' with the given string encoded in it.\n\nConventionally there is a fixed size to the QR codes that applications\ngenerate, that specified by the developer. But the speciality of\nthis piece of code is that it generates the QR codes that only fits\nthe string that is supplied. So it will not produce large QR codes\nwhen only a fraction of it has been used. This is important because\nsmall QR codes are beneficial when transferring them over networks.\n\nA QR code with a \"SUCCESS\" message (section\n\\ref{sec:client_server_communication}) encoded inside is about the size\nof a '29 x 29' pixel image. An average size of a QR code with a \"FAIL\" message\n(section \\ref{sec:client_server_communication}) coded inside is about\nthe size of a '33 x 33' pixel image. These images are very small so\nthat they can be transferred over the networks efficiently. Although\nthe performance of the system can be dramatically improved if the\nmessages are passed as text, the added QR code functionality makes it more enjoyable.\n\n\\subsubsection{LAPPSMobile}\n\nThis mobile application is the only way of requesting passwords from\nthe LAPPS Server. This application is designed for the mobile phones\nthat run Android platform. The application requires access to the\nInternet and geographical location information. \n\nAs described in section \\ref{sec:lapps_protocol}, this application\nsends \"GETPASS\" requests to the server with other authentication and\nlocation information, to retrieve a password.\n\nAdditionally, this application is capable of understanding the message\ncodes that are sent by the server. Currently there are only two error\ncodes. they are \"SUCCESS\" and \"FAIL\". The author has elucidated these two\ncodes in section \\ref{sec:lapps_server}.\n\nIf the application receives a message with a \"SUCCESS\" code, it will\nprint out a message as shown in figure \\ref{fig:lapps_mobile_ss_c}.\n\nThe following figure \\ref{fig:lapps_mobile_ss} shows the screen shots\nof the completed LAPPSMobile Application.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\subfloat[The Pin request button]{    \\includegraphics[scale=0.228]{LAPPSMobile1.pdf}\\label{fig:lapps_mobile_ss_a}}\n    \\subfloat[Application requests for a 8 digit number]{     \\includegraphics[scale=0.228]{LAPPSMobile_8pin.pdf}\\label{fig:lapps_mobile_ss_b}}\n    \\subfloat[A Successfully received QR code]{    \\includegraphics[scale=0.228]{LAPPSMobile2.pdf}\\label{fig:lapps_mobile_ss_c}}\n    \\subfloat[After the QRCode has been decoded]{\n      \\includegraphics[scale=0.228]{LAPPSMobile3.pdf}\\label{fig:lapps_mobile_ss_d}}\n  \\end{center}\n  \\caption{The LAPPSMobile Application Screen-shots.}\\label{fig:lapps_mobile_ss}\n\\end{figure}\n\n\\paragraph{Software Design}\\label{sec:lappsmobile_software_design}:\\\\\n\nA class diagram of the software design of the LAPPSMobile application\nis shown below in figure \\ref{fig:lapps_mobile_design}\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.3]{Diagram4_lappsMobile.pdf}\n  \\end{center}\n  \\caption{The design of the LAPPSMobile Application}\n  \\label{fig:lapps_mobile_design}\n\\end{figure}\n\nThe application can be compiled and has been tested on android 2.2,\n2.3.3, 3.2 and 4.03 platforms. The application seem to function very\nwell in all of these platforms.\n\nThe application requires following permissions to be able to get\naccess to the resources to be able to function substantially. The\npermissions are programmed in XML language in the AndroidManifest.xml\nfile in the application.\n\n\\begin{verbatim}\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\\end{verbatim}\n\nThe first line permits the access to the location information using the\nGPS receiver of the mobile device. The Second line allows access to the\nlocation information using Wifi, Cell-ID etc., to the mobile\napplication. Final two lines grant the access to the Internet and the\nstate of the network respectively.\n\n\\subparagraph{The work flow of the LAPPSMobile\n  Application}\\label{sec:lappsmobile_workflow}:\\\\\n\n\\begin{enumerate}\n\\item When the application starts, the LAPPSMobile application\n  acquires a TLS over TCP/IP connection to the LAPPSServer. If the\n  attempt to connect to the server is not successful a message is being\n  displayed on the screen. When the user taps on the \"Get a Pin\n  Number\" button (Figure \\ref{fig:lapps_mobile_ss_a})  it will try to\n  reconnect to the LAPPSServer in  the occasions that it is not connected.\n\\item When the user taps on the \"Get A Pin Number\" button the\n  application prompts the user to enter an 8 digit number (Figure\n  \\ref{fig:lapps_mobile_ss_b}) only if the application can retrieve\n  location information. If the GPS information is unobtainable then a\n  message is being displayed on the screen (More on retrieving GPS\n  information in section \\ref{sec:gps_loaction_listener}).\n\\item After the user has tapped on the \"Ok\" button the location\n  information, ID of the user, registered ID of the application and\n  the inserted 8 digit number is sent to the server.\n\\item If the authentication is successful then the LAPPSServer sends a\n  QR code with the allocated password and the ID of the \\gls{atm}\n  encoded.\n\\item The received QR code is displayed on the screen with the ID of\n  the ATM machine that the user and the password have been allocated\n  to (Figure \\ref{fig:lapps_mobile_ss_c}). Ideally the user is able\n  to scan the QR code on the correct \\gls{atm} and log in to the\n  machine. The second option is to tap on the \"Decode QR code\" button so that\n  the QR code will be decoded (More on decoding QR code in section\n  \\ref{sec:qrcode_decode}) and the password and the ID of the\n  \\gls{atm} is presented in the next window (Figure\n  \\ref{fig:lapps_mobile_ss_d}).\n\\item Finally the connection closes when the user exits from the application.\n\\end{enumerate}\n\n\\subparagraph {How LAPPSMobile handle response messages}\\label{lappsmobile_response_messages}:\\\\\n\nThere are currently two types of respond messages. They are \"SUCCESS\"\nmessages which are successful responds and \"FAIL\" messages which are\nresponds that are sent back for unsuccessful requests. Comparatively\nto the way LAPPSServer has been coded to handle request messages (in\nsection \\ref{sec:client_server_communication}) the LAPPSMobile has\nbeen coded in consideration of that it is easily adaptable for future\nchanges as well as the clarity of the code itself. A pseudo code of\nthe code is shown below. To demonstrate how a newly introduced response\nmessage (NEW\\_RESPOND) can be handled a dummy code block has been added to the pseudo\ncode.\n\n\\begin{verbatim}\nwhile (true) {\n  if (connection.hasRespond()) {\n   \n/****Deals with \"SUCCESS\" requests***/ \n   if (connection.next().equals(\"SUCCESS:\")) {\n      displayQRCode();\n   }\n/**********************************/ \n\n/****Deals with \"FAIL\" response messages***/ \n   if (connection.next().equals(\"FAIL:\")) {\n      displayErrorMessage();\n   }\n/**********************************/ \n\n\n/****Deals with \"NEW_RESPOND\" response messages***/ \n   if (connection.next().equals(\"NEW_RESPOND:\")) {\n      handleResponse();\n   }\n/**********************************/ \n\n   // Code for handling new response codes can be added here\n}\n\\end{verbatim}\n\n\\subparagraph{Decoding the QR codes} \\label{sec:qrcode_decode}:\\\\\\\\\nAfter the application has been received the QR code, LAPPSMobile uses\nand instance of the \"com.google.zxing.qrcode.QRCodeReader\" class from\nthe \"Zxing\" library to decode the received QR code. The \"Zxing\" class\n\"RGBLuminanceSource\" has been added supplementary to the existing\n\"com.google.zxing.qrcode\" library. This file is licenced under the\nApache License, Version 2.0 \\cite{apache_license2}. The\n\"RGBLuminanceSource\" has been used as a \"LuminanceSource\" when converting the\n\"Bitmap\" typed QR code to type of \"BinaryBitmap\".\n\n\\subparagraph{GPSLocationListener class}\\label{sec:gps_loaction_listener}:\\\\\n\nThe LAPPSMobileActivity class contains an instance of the\nGPSLocationListener class. This class is a type of \"LocationListener\"\nwhich updates the user's location persistently and stores them in two\nlatitude and longitude variables in the \"LAPPSMobileActivity\"\nclass. Additionally it notifies the main application when the location\ninformation is obtainable and unobtainable.\n\n\\subsubsection{ATM emulator}\\label{sec:atm_emulator}\n\nThe LAPPSMobile is able to request for passwords and LAPPSServer is\ncapable of generating passwords. One of the important aspect of this\nproject is to authenticate and to prove that the generated passwords\nensures the security measures that LAPPS claims to comply.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.5]{atm_emu.pdf}\n  \\end{center}\n  \\caption{Screen-shot of the ATM Emulator \\label{fig:atm_emu_ss}}\n\\end{figure}\n\n\\paragraph{Software Design}\\label{sec:atm_emulator_design}:\\\\\n\nThe following class diagram shows the design of the software program.\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.4]{Diagram5_atm_emu.pdf}\n  \\end{center}\n  \\caption{The design of the ATM Emulator \\label{fig:atm_emu_design}}\n\\end{figure}\n\nThe diagram above shows the attributes and the functions in the\nclasses and it suggests the relationships between them. ATMEmu class\ncontains instances of Hasher and Db classes (1..1). \n\n\\subparagraph{How a user would use the ATM emulator}:\\\\\n\n\\begin{enumerate}\n\\item User selects the ATM machine that their password has been\n  allocated to. This resembles the user using the allocated ATM\n  machine to use the received password.\n\\item Then user enters their Identification number(ID). This resembles\n  the user inserting their Credit/Debit card to the allocated \\gls{atm}\n\\item Finally the user enters their fixed password and clicks on the\n  \"Log In\" button.\n\\item If all of the authentication information is correct then a\n  message is shown on the screen. Alternatively if the information is\n  not correct an error message is shown.\n\\end{enumerate}\n\n\\subparagraph{The work flow of the ATM\n  emulator}\\label{sec:atm_emu_workflow}:\n\n\\begin{enumerate}\n\\item ATMEmu creates the Graphical User Interface when it starts.\n\\item After a user has entered the authentication information, it\n  authenticates these information by querying the lappsStore\n  database (Pseudo code of the query in section\n  \\ref{sec:atm_pas_auth}). Because the password has been stored in the\n  database as hashed using SHA2-512, ATMEmu validates this password by\n  creating a hash value of the inserted password and comparing it with the value that is stored in the database. To accomplish this the \"hashPassword()\" method in the Hasher class has been used (More on password authentication in\n  section \\ref{sec:atm_pas_auth}).\n\\item If the password is not authoritative then an error message is\n  shown on the screen.\n\\item If the user has successfully logged in, ATMEmu stores the value\n  \"true\" in the \"used\" column in the corresponding row in the\n  \"allocation\" table. This indicates that the password has been used.\n\\end{enumerate}\n\n\\subparagraph{Authenticating Password}\\label{sec:atm_pas_auth}:\\\\\n\nTo authenticate the password that is being inserted in to the ATM\nEmulator, it queries the lappStore database to validate if there is a\npredefined allocation to the particular \\gls{atm} that belongs to the\nparticular user. Then the inserted password is matched against the\npassword that is stored in the database. Finally it checks if the password's\nexpiry time has been passed and it has not been used. If all of the above\nparameters are positively ticks then one record will be returned.\n\nThe following pseudo code of a SQL query shows how this is done.\n\n\\begin{verbatim}\nSELECT atmId \nFROM allocation AS a,password AS p \nWHERE a.atmId=<ATM_ID> AND a.userId=<USER's ID> AND\na.password=<Inserted_password AND a.password=p.password \nAND p.expTime > CURRENT_TIMESTAMP AND a.used=false;\n\\end{verbatim}\n\nIf the above SQL query returns a record then it is confirmed that the\ninserted password is authoritative.\n\nIf the password is correct then it means that the user will log in to\nthe \\gls{atm}. Hence it has to be noted immediately in to the\ndatabase. This is done by using a SQL query and it is demonstrated by the\nfollowing pseudo code.\n\n\\begin{verbatim}\nUPDATE allocation SET used=true WHERE atmId=<ATM_ID \nAND userId=<USER's ID> AND password=<PASSWORD>\n\\end{verbatim}\n\n\\section{Performance of LAPPS}\\label{sec:lapps_performance}\nIn this section the author looks at the performance of the LAPPS\nServer. To carry out the test runs he has used an Intel(R) Core(TM)2\nDuo CPU P8600 @2.40GHz CPU with L2 3072 KB of cache. The laptop has\ngot 4 GB of RAM and using Ubuntu Linux 11.10.\n\nTo send request to the server in this experiment he has used the\nAndroid emulator that comes with the Android SDK \\cite{android_sdk}, to run the\nLAPPSMobile application. The server, Pin generating device and\nthe client (Android emulator) were running on the same machine.\n\nTable \\ref{tab:performance} shows the performance measures of LAPPS in\ndifferent test cases, that the author has gathered after performing 80 runs per\neach test case. The median total response time of LAPPS is 56\nmilliseconds, despite the fact that all programs were running in the\nsame computer for testing so that the processing power has been distributed\nbetween all programs. Table \\ref{tab:performance} shows that the\nmedian time that has taken to authenticate an 8 digit pin number was\nabout 1 millisecond and it is 1\\% of its total response time. Similarly,\nto find the nearest ATM to the user and to generate a new unique\npassword, 1 millisecond has been taken in both cases and both measured\ntimes are 1\\% of their total response times. To generate a QR code for\na response message, the median time that LAPPS has taken was 3\nmilliseconds. This is 5\\% of its total response time. Finally time\nwise the most expensive action in the process of responding to user\nrequests was storing allocation records in to the database. In median\ntime, it has taken 39 milliseconds, that is 69\\% of its total response time. \n\nWe can conclude that the current LAPPS implementation is fairy quick\nalthough the performance evaluation could have carried out in a better\nenvironment for better results. This can be added as a further task on\nthis project.\n\n\\section{Evaluation}\\label{sec:evaluation}\n\nThe Location Aware Password Protection system is an architecture that\nadds five assorted layers around passwords that is generated by\ntraditional password protection systems. These layers have been\ndesigned to harden the traditional password protection systems. In\nsection \\ref{sec:lapps_arch} the author has expounded how these layers\nwork. The main advantage of these layers is that according to the\nuser's desire, the layers can be added or removed. The main speciality of the\nwhole \\gls{lapps} architecture is that the passwords can be allocated to\ngeographical locations, so that a password will only be valid in it's\nallocated geographical area. Also the password can only be allocated to\none geographical area, even though you can choose to customise the\n\"Location Awareness\" layer so that you can allocate the password in to\nvaried geographical areas. Though these layers harden the passwords\nthere still are drawbacks. These are discussed in section\n\\ref{lapps_eval}. LAPPS allows one password only to be used once, by\nstoring a Boolean value in the 'used' column in the 'allocation'\ntable, if one has been used. A password's active time has been\nrestricted by storing the expiry time in the database, so that\nonly if the current time is less than the expiry time, the password is\nusable. The Pin Sentry device introduces a second authentication\nfactor that hardens the security.\n\nThe current implementation of \\gls{lapps} has been implemented to harden the\npassword security systems in Automated Tailor machines. Though it has not\nbeen tested on a real \\gls{atm} network yet. Section\n\\ref{sec:layer_mapping} demonstrates how the \\gls{lapps} layers have \ndirectly been implemented into a real world software\napplication. Section \\ref{sec:components} goes through more technical details on how these components of \"\\gls{lapps} for \\glspl{atm}\" have been\nimplemented.\n\n\n\\section{Project Planning}\\label{sec:project_planning}\n\nI have started planning my project very early. As early as June 2011; just after I have finished the second year I have had a meeting with\nmy supervisor regarding my allocated project \"Live video stream over\ncloud\". After a couple of discussions I was given the opportunity to\ndeliver my own project proposal that is relative to my interest\nareas. Since \"Computer Security\" is one of my interest areas, I have\nproposed a project idea and we named it \"Location Aware Password\nProtection System\".\n\nThrough out the project planning, designing and the implementation\nprocesses I have regularly noted the changes, new findings,\nachievements and etc. in my logbook, and the finished milestones and task had been marked in the gantt chart. The log book has  been regularly marked by\nProf.~Kun after every meeting that we did once every two weeks.\n\nSince the day I came up with the \\gls{lapps} idea (07/09/2011), I have\nresearched about the theoretical values of the technologies that is\nrelevant to the subject area. This helped me to gain a better\nunderstanding of the topic. At first the project scenario was just based on\nthe security of \\glspl{atm}. After 19/09/2011 I have started looking in to\nmore technical details that could be imperative for the implementation\nof the project, as well as the more theoretical sides. The background\nresearch gained me more confidence about the plausibility of\nimplementation of the project that has to be done in a limited time\nperiod. At this stage I was quite confident about the project idea and\nthe implementation, and I had planned to finish off the project during the December holiday in 2011/2012. \n\nOn 27/11/2011 I started the design of the software with a draft\ndesign of the database. The initial idea of the project has been\nsubject to continuous minor changes over time. For instance, according\nto the newly evolved project idea, the password that will be generated\nby \\gls{lapps} had to have a time frame that it will be valid\nfor. Consequently the design of the database had to be changed. This\nwas done on 03/01/2012. There were three main components in the\nsoftware system and by this time I had already started the development\nof all of the components together. Since all of the components have to\nwork together, testing had been carried out along side with the\nsoftware development. I was quite happy that I stared the\nimplementation very early so I would be able to get on with other\nuniversity work with less pressure when the university starts. The\nchanges that my supervisor proposed and the ones that I have decided\nto change, I happily accepted and put in to the design because they\nonly made the project better and more interesting.\n\nTo keep the project on track and manage the code, I have used the\n\"git\" version control system. This has made my work easier to manage\nand to keep track of. Every time I have applied a significant change to\nthe code, I have committed the changes to the \"git\" local\nrepository. Additionally I submitted comments along with the commits\nso I have a description of what I have done corresponding to the\ncommits. The daily progress had been noted on the log book. The\nresearch I have been doing during the summer and the first semester helped\nto choose the technologies and tools to implement the software.\n\nDuring the implementation, there were easier problems than some of the\nothers and there were more difficult problems than many others. It is\nfair to say that this project is fairly a complicated one. One of the\nchallenges that I had to face during the development was that I had\nproblems with implementing TLS mechanism to the socket connections in\nthe Android application. I only had the problem when I compiled this\ncode for the Android 2.2 framework. As a solution I carried on my\ndevelopment under the Android 4.03 framework. Hence I was able to\ncarry out the development of the project until I had found an alternative\nto the bug I had under the Android 2.2 framework. I was able to\ncomplete the implementations of all of the components before the first\nmeeting with my supervisor on 26/01/2012. The effort payed off at the end because I had a good feed back about the finished project, from Prof.~Kun.\n\nHaving completed the proposed password protection system, after few\ndiscussions with my supervisor I decided to extend the project\nconsidering that I had plenty of time left. After the first extension\nthe passwords that are stored in the database are no longer stored as\nplain text, now database only holds the hashed values of the\npasswords, consequently I had to program ATM Simulator and the\nLAPPSServer to work with the hashes. Secondly I have introduced a Pin\ngenerating device software to the software system. So that all users\nare required to supply the 8 digit number that is generated by this\ndevice software when they request for a password. Consequently I have changed\nLAPPSMobile Android application, the database and the LAPPSServer\napplication to work with the 8 digit pin number and to authenticate these digits. All of the these had been completely implemented by\n22/02/2012. Figure \\ref{fig:gantt1} and \\ref{fig:gantt2} shows the\nproject task breakdown and gantt charts.\n\nLooking back at all of the phases in the project, I think I did well\nin terms of time management of the project. Hence I had extra time to\nextend, test and modify the software among many other assignments and\ncoursework at the University. There were many changes that I have\ncarried out during the implementation such as I have decided to change\nthe Database Management System (DBMS) to PostgreSQL so that I was able\nto use the PostGIS software program. So I had to adapt to its SQL\nsyntax for queries and triggers. The whole process of learning Android\ndevelopment feels like an adaptation from general Java programming to\nAndroid. Although I was enjoying every bit of it. In the project I\nhave learnt so many things such as Project Planing, about TLS/SSL\nkeys and certificate generation, Android application development,\nPostgreSQL DBMS and git version control system. I believe with the\nexperience I have gained during this project I will be able to do a\nbetter job next time I will be involved in a project.\n\n\\section{Summary}\n\nIn this thesis the author has introduced an architecture that is designed to\nconsolidate conventional password protection systems. \\gls{lapps}\narchitecture can be adopted to the traditional password protection\nsystems easily without having to comprehensively replace old\nsystems. These layers make the traditional passwords safe enough to\nprotect private and confidential information considering the threats\nthat have been reported for the last decade. Additionally these layers are\ncustomisable to the user's needs. The signature value of \\gls{lapps} is the\nlocation awareness.  \n\nThe \"\\gls{lapps} for \\glspl{atm}\" implementation is an example of how this\narchitecture can be endorsed into a software application. Section \\ref{sec:evaluation} shows how the objectives\n\\ref{sec:objectives} of the project have been achieved. We have seen\nthe performance of LAPPS in different test cases in section\n\\ref{sec:lapps_performance}. Finally section \\ref{sec:project_planning}\ndiscloses how the author has manged the time during the project.\n\n\\bibliographystyle{IEEEannot}\n\\bibliography{citations}\n\n\\appendix\n\\section{Appendix}\n\n\\begin{figure}[htp]\n  \\centering\n  \\begin{center}\n    \\includegraphics[scale=0.37]{ganttchart12.pdf}\n  \\end{center}\n  \\caption{Task breakdown and gantt Chart 1 \\label{fig:gantt1}}\n\\end{figure}\n\n\n\\begin{figure}[htp]\n  \\begin{center}\n    \\includegraphics[scale=0.37]{ganttchart22.pdf}\n  \\end{center}\n  \\caption{Task breakdown and gantt Chart 2 \\label{fig:gantt2}}\n\\end{figure}\n\n\n\\begin{table}\n  \\begin{tabular}{|l|c|r|}\n    \\hline\n\n    Test Case & Median Time (ms)& \\% from total response time\\\\\n    \\hline\n    Total response time & 56 & 100 \\\\\n    Pin number authentication & 1 & 1\\\\\n    Generate unique password & 1 & 1\\\\\n    Find closest ATM & 1 & 1 \\\\\n    QR code generation & 3 & 5\\\\\n    Store allocation & 39 & 69\\\\\n    \\hline\n  \\end{tabular}\n  \\caption{The performance measures of LAPPS}\n  \\label{tab:performance}\n\\end{table}\n\n", "itemtype": "equation", "pos": 56749, "prevtext": "\n", "index": 41, "text": "\n\\[U_i \\in GU\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"U_{i}\\in GU\" display=\"block\"><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>\u2208</mo><mrow><mi>G</mi><mo>\u2062</mo><mi>U</mi></mrow></mrow></math>", "type": "latex"}]