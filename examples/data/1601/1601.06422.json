[{"file": "1601.06422.tex", "nexttext": "\nfor some scalars $\\sigma_1, \\sigma_2, \\ldots, \\sigma_{R} \\ge 0$ and orthonormal vectors ${\\mathbf u}_1, {\\mathbf u}_2, \\ldots, {\\mathbf u}_{R} \\in {\\mathbb{R}}^{{M}}$ and ${\\mathbf v}_1, {\\mathbf v}_2, \\ldots, {\\mathbf v}_{R} \\in {\\mathbb{R}}^{{N}}$.  The $\\{\\sigma_k\\}$ can be interpreted as the $R$ largest singular values of ${{\\mathbf X}_0}$, and the $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ as the corresponding singular vectors.  The collection of all such matrices form a {\\em union of subspaces} in ${\\mathbb{R}}^{{M}\\times{N}}$; each set of vectors $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ define an ${R}$-dimensional subspace, and the $\\{\\sigma_k\\}$ correspond to an expansion in that subspace.  As the $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ can vary continuously, this union contains uncountably many such subspaces.\n\n\nHowever, by counting the degrees of freedom in the singular value decomposition, we see that the set of rank ${R}$ matrices can be parameterized by $O({R}({M}+{N}))$ numbers, which when ${R}$ is small is much less than the ${M} {N}$ required to specify a general matrix.  This suggests that it might be possible to accurately recover a low-rank matrix from relatively few measurements, and as is noted above, recent results have shown that this is indeed possible~\\cite{Gross_Recovering,CandeR_Exact,CandeT_Power,KeshaMO_Matrix,Recht_Simpler,RechtFP_Guaranteed}.\n\nWe will assume that rather than observing ${{\\mathbf X}_0}$ directly we instead observe ${\\mathbf y} = {\\mathcal A}({{\\mathbf X}_0}) + {\\mathbf z}$ where ${\\mathbf z}$ represents noise and ${\\mathcal A}: {\\mathbb{R}}^{{M} \\times {N}} \\rightarrow {\\mathbb{R}}^{L}$ is a linear {\\em measurement operator} that acts on a matrix ${{\\mathbf X}_0}$ by taking standard inner products against ${L}$ pre-defined ${M}\\times{N}$ matrices ${\\boldsymbol{{A}}}_1,\\ldots,{\\boldsymbol{{A}}}_{L}$:\n\n", "itemtype": "equation", "pos": 6858, "prevtext": "\n\n\\title{An overview of low-rank matrix recovery from incomplete observations}\n\n\\vspace{2mm}\n\\author{Mark A.\\ Davenport and Justin Romberg\\footnote{M.\\ D.\\ and J.\\ R.\\ are with the School of Electrical and Computer Engineering, Georgia Institute of Technology, Atlanta, GA 30332 USA (e-mail: \\{mdav,jrom\\}@gatech.edu).\n\nM.\\ D.\\ is supported by NRL grant N00173-14-2-C001, AFOSR grant FA9550-14-1-0342, and NSF grants CCF-1409406, CCF-1350616, and CMMI-1537261.  J.\\ R.\\ is supported by ONR grant N00014-11-1-0459, NSF grant CCF-1422540, and a grant from the Packard Foundation.}}\n\\date{January 24, 2016}\n\n\\maketitle\n\n\n\\begin{abstract}\nLow-rank matrices play a fundamental role in modeling and computational methods for signal processing and machine learning.  In many applications where low-rank matrices arise, these matrices cannot be fully sampled or directly observed, and one encounters the problem of recovering the matrix given only incomplete and indirect observations.  This paper provides an overview of modern techniques for exploiting low-rank structure to perform matrix recovery in these settings, providing a survey of recent advances in this rapidly-developing field.  Specific attention is paid to the algorithms most commonly used in practice, the existing theoretical guarantees for these algorithms, and representative practical applications of these techniques.\n\\end{abstract}\n\n\n\n\n\\section{Introduction}\n\nLow-rank matrices arise in an incredibly wide range of settings throughout science and applied mathematics.  To name just a few examples, we commonly encounter low-rank matrices in contexts as varied as:\n\\begin{itemize}\n\\item {\\bf ensembles of signals}: the output of a sensor array or network, a collection of video frames, or a sequence of segments of a longer signal can often be highly correlated and represented using a low-rank matrix~\\cite{DavieE_Rank,ahmed15co};\n\\item {\\bf system identification}: low-rank (Hankel) matrices correspond to low-order linear, time-invariant systems~\\cite{LiuV_Interior};\n\\item {\\bf adjacency matrices}: the connectivity structure of many graphs, such as those that arise in manifold learning and social networks, is often low rank~\\cite{LiniaLR_Geometry};\n\\item {\\bf distance matrices}: in many data embedding problems --- such as those that arise in the context of multidimensional scaling~\\cite{BorgG_Modern}, sensor localization~\\cite{SoY_Theory,BiswaLWY_Semidefinite}, nuclear magnetic resonance spectroscopy~\\cite{Singe_Remark,SingeC_Uniqueness}, and others --- the matrix of pairwise distances will typically have a rank dependent on the (low) dimension of the space in which the data lies;\n\\item {\\bf item response data}: low-rank models are frequently used in analyzing data sets containing the responses of various individuals to a range of items, such as survey data~\\cite{Linde_Handbook}, educational data~\\cite{LanWSB_Sparse}, the data generated by recommendation systems~\\cite{GoldbNOT_Using,Srebr_Learning,RenniS_Fast}, and others;\n\\item {\\bf machine learning}: low-rank models are ubiquitous in machine learning, laying the foundation for both classical techniques such as principal component analysis~\\cite{Pears_Lines,Hotel_Analysis} as well as modern approaches to multi-task learning~\\cite{ArgyrEP_Convex,OboziTJ_Joint} and natural language processing~\\cite{Dumai_Latent,Blei_Probabilistic};\n\\item {\\bf quantum state tomography}: a pure quantum state of $N$ ions can be described by a $2^N \\times 2^N$ matrix with rank one~\\cite{GrossLFBE_Quantum}.\n\\end{itemize}\n\nIn all of these settings, the matrices we are ultimately interested in can be extremely large.  Moreover, as data becomes increasingly cheap to acquire, the potential size will continue to grow.  This raises a number of challenges, but often a key obstacle is that fully observing the matrix of interest can prove to be an impossible task: it can be prohibitively expensive to fully sample the entire output of a sensor array; we might only be able to measure the strength of a few connections in a graph; and any particular user of a recommendation system will provide only a few ratings. In such settings we are left with a highly incomplete set of observations, and unfortunately, many of the most popular approaches to processing the data in the applications where low-rank matrices arise assume that we have a fully-sampled data set and are generally not robust to missing/incomplete data.  In these situations we are confronted with the inverse problem of recovering the full matrix from our incomplete observations.\n\nWhile such recovery is not always possible in general, when the matrix is low rank, it is possible to exploit this structure and to perform this kind of recovery in a surprisingly efficient manner.  In fact, in recent years there has been tremendous progress in our understanding of how to solve such problems.  While many of these applications have a relatively long history in which various existing approaches to dealing with incomplete observations have been independently developed, recent advances in the closely related field of compressive sensing~\\cite{Donoh_Compressed,Cande_Compressive,DavenDEK_Introduction} have enabled a burst of progress in the last few years.  We now have a unified framework which provides a strong base of theoretical results concerning when it is possible to recover a low-rank matrix from incomplete observations using efficient, practical algorithms~\\cite{Gross_Recovering,CandeR_Exact,CandeT_Power,KeshaMO_Matrix,Recht_Simpler,RechtFP_Guaranteed}.\n\nIn this paper we provide a survey of this developing field.  We begin with a more formal mathematical statement of the problem of low-rank matrix recovery in Section~\\ref{sec:mrprob}, followed in Section~\\ref{sec:mralgs} by an overview of some of the algorithms most commonly used in practice to solve these kinds of problems.  We provide a brief overview of the existing theoretical guarantees for these algorithms in Sections~\\ref{sec:gauss},~\\ref{sec:mc}, and~\\ref{sec:nonlinear} for several concrete observation models with an emphasis on how many observations are required to reliably recover a low-rank matrix and what additional assumptions are potentially required. Finally, in Section~\\ref{sec:lifting} we describe an important application of these techniques to an important class of problems where we can solve {\\em quadratic} and {\\em bilinear} systems of equations by re-casting them as a simple problem of low-rank matrix recovery.\n\n\n\n\\section{The Matrix Recovery Problem}\n\\label{sec:mrprob}\n\n\nWe begin by carefully stating what we mean by {\\em low-rank matrix recovery}.\n\nWe observe a matrix ${{\\mathbf X}_0}$, which we will assume to have size ${M} \\times {N}$ and which we can express either exactly or approximately as having rank ${R} \\ll {M}, {N}$.  This means that we can write\n", "index": 1, "text": "\n\\[\n\t{{\\mathbf X}_0} \\approx \\sum_{k=1}^{R} \\sigma_k {\\mathbf u}_k {\\mathbf v}_k^{\\mathrm{T}}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"{{\\mathbf{X}}_{0}}\\approx\\sum_{k=1}^{R}\\sigma_{k}{\\mathbf{u}}_{k}{\\mathbf{v}}_%&#10;{k}^{\\mathrm{T}}\" display=\"block\"><mrow><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>\u2248</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc2e</mi><mi>k</mi></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc2f</mi><mi>k</mi><mi mathvariant=\"normal\">T</mi></msubsup></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\nOur discussion below will at times involve the adjoint of this operator, which is defined as\n", "itemtype": "equation", "pos": 8865, "prevtext": "\nfor some scalars $\\sigma_1, \\sigma_2, \\ldots, \\sigma_{R} \\ge 0$ and orthonormal vectors ${\\mathbf u}_1, {\\mathbf u}_2, \\ldots, {\\mathbf u}_{R} \\in {\\mathbb{R}}^{{M}}$ and ${\\mathbf v}_1, {\\mathbf v}_2, \\ldots, {\\mathbf v}_{R} \\in {\\mathbb{R}}^{{N}}$.  The $\\{\\sigma_k\\}$ can be interpreted as the $R$ largest singular values of ${{\\mathbf X}_0}$, and the $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ as the corresponding singular vectors.  The collection of all such matrices form a {\\em union of subspaces} in ${\\mathbb{R}}^{{M}\\times{N}}$; each set of vectors $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ define an ${R}$-dimensional subspace, and the $\\{\\sigma_k\\}$ correspond to an expansion in that subspace.  As the $\\{{\\boldsymbol{{u}}}_k\\},\\{{\\boldsymbol{{v}}}_k\\}$ can vary continuously, this union contains uncountably many such subspaces.\n\n\nHowever, by counting the degrees of freedom in the singular value decomposition, we see that the set of rank ${R}$ matrices can be parameterized by $O({R}({M}+{N}))$ numbers, which when ${R}$ is small is much less than the ${M} {N}$ required to specify a general matrix.  This suggests that it might be possible to accurately recover a low-rank matrix from relatively few measurements, and as is noted above, recent results have shown that this is indeed possible~\\cite{Gross_Recovering,CandeR_Exact,CandeT_Power,KeshaMO_Matrix,Recht_Simpler,RechtFP_Guaranteed}.\n\nWe will assume that rather than observing ${{\\mathbf X}_0}$ directly we instead observe ${\\mathbf y} = {\\mathcal A}({{\\mathbf X}_0}) + {\\mathbf z}$ where ${\\mathbf z}$ represents noise and ${\\mathcal A}: {\\mathbb{R}}^{{M} \\times {N}} \\rightarrow {\\mathbb{R}}^{L}$ is a linear {\\em measurement operator} that acts on a matrix ${{\\mathbf X}_0}$ by taking standard inner products against ${L}$ pre-defined ${M}\\times{N}$ matrices ${\\boldsymbol{{A}}}_1,\\ldots,{\\boldsymbol{{A}}}_{L}$:\n\n", "index": 3, "text": "\\begin{equation} \\label{def:A}\n{\\ifthenelse{\\boolean{twoColVersion}} {{ \\begin{aligned} y_i  = \\langle {{\\mathbf X}_0}, {\\mathbf A}_i  \\rangle + z_i  & = {\\text{trace}}({\\mathbf A}_i^{\\mathrm{T}}{{\\mathbf X}_0}) + z_i \\\\ & = \\sum_{m=1}^{M}\\sum_{n=1}^{N} X_0[m,n]A_i[m,n] + z_i. \\end{aligned} }} {{\ty_i = \\langle {{\\mathbf X}_0}, {\\mathbf A}_i  \\rangle + z_i = {\\text{trace}}({\\mathbf A}_i^{\\mathrm{T}}{{\\mathbf X}_0}) + z_i = \\sum_{m=1}^{M}\\sum_{n=1}^{N} X_0[m,n]A_i[m,n] + z_i.}} }\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"{{y_{i}=\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}\\rangle+z_{i}={\\text{trace}}%&#10;({\\mathbf{A}}_{i}^{\\mathrm{T}}{{\\mathbf{X}}_{0}})+z_{i}=\\sum_{m=1}^{M}\\sum_{n=%&#10;1}^{N}X_{0}[m,n]A_{i}[m,n]+z_{i}.}}\" display=\"block\"><mrow><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><mrow><mtext>trace</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msubsup><mi>\ud835\udc00</mi><mi>i</mi><mi mathvariant=\"normal\">T</mi></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msub><mi>A</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\nOur survey focuses on three basic variations of this measurement model.  The first is taking ${\\mathcal A}$ to be a {\\em random projection}, where each of the ${\\boldsymbol{{A}}}_i$ consisting of independent and identically distributed random variables.  Although this model arises in only a limited number of practical situations, the theory is so streamlined that it can be understood almost from first principles (see Section~\\ref{sec:gauss}).  For our second model, ${\\mathcal A}$ returns a subset of the entries of the target.  Recovering from these samples is known as the {\\em matrix completion} problem.  In this case, each of the ${\\boldsymbol{{A}}}_i$ has exactly one non-zero entry.  The analysis for this problem, which we overview in Section~\\ref{sec:mc}, can also be extended to observing a subset of the expansion coefficients of ${{\\mathbf X}_0}$ in a fixed (and known) orthobasis.  The third model, which we will discuss in Section~\\ref{sec:lifting}, is that the ${\\boldsymbol{{A}}}_i$ are rank-1 matrices.  These are encountered when each observation can be written as a quadratic or bilinear form in ${{\\mathbf X}_0}$.\n\nWhile these are the measurement models that have received the most attention in the literature, they are by no means the only interesting models.  Other models inspired by applications in imaging and signal processing have also appeared recently in the literature (see for example \\cite{krahmer14st,ahmed15co,ahmed15co2,tang14co,bahmani15li}).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Algorithms for Matrix Recovery}\n\\label{sec:mralgs}\n\n\n\\subsection{Low-rank approximation}\n\nWe start by reviewing the classical problem of finding the best low-rank approximation to a given ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}_0$.  By ``best'', we mean closest in the sum-of-squares sense, and we formulate the problem as\n\n", "itemtype": "equation", "pos": 9456, "prevtext": "\n\nOur discussion below will at times involve the adjoint of this operator, which is defined as\n", "index": 5, "text": "\n\\[\n\t{\\mathcal A}^*({\\boldsymbol{{w}}}) = \\sum_{i=1}^{L} w_i{\\boldsymbol{{A}}}_i.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{A}}^{*}({\\boldsymbol{{w}}})=\\sum_{i=1}^{L}w_{i}{\\boldsymbol{{A}}}_{i}.\" display=\"block\"><mrow><mrow><mrow><msup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>*</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc98</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc68</mi><mi>i</mi></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $\\|{\\boldsymbol{{X}}}-{\\boldsymbol{{X}}}_0\\|_F^2 = \\sum_{m,n}(X[m,n]-X_0[m,n])^2$ is the square of the standard Frobenius norm, and ${R}$ is the desired rank of the approximation.  This problem is nonconvex, but is actually easy to solve explicitly using the {\\em singular value decomposition} (SVD).  In particular, if we decompose ${\\boldsymbol{{X}}}_0$ as\n", "itemtype": "equation", "pos": 11374, "prevtext": "\n\nOur survey focuses on three basic variations of this measurement model.  The first is taking ${\\mathcal A}$ to be a {\\em random projection}, where each of the ${\\boldsymbol{{A}}}_i$ consisting of independent and identically distributed random variables.  Although this model arises in only a limited number of practical situations, the theory is so streamlined that it can be understood almost from first principles (see Section~\\ref{sec:gauss}).  For our second model, ${\\mathcal A}$ returns a subset of the entries of the target.  Recovering from these samples is known as the {\\em matrix completion} problem.  In this case, each of the ${\\boldsymbol{{A}}}_i$ has exactly one non-zero entry.  The analysis for this problem, which we overview in Section~\\ref{sec:mc}, can also be extended to observing a subset of the expansion coefficients of ${{\\mathbf X}_0}$ in a fixed (and known) orthobasis.  The third model, which we will discuss in Section~\\ref{sec:lifting}, is that the ${\\boldsymbol{{A}}}_i$ are rank-1 matrices.  These are encountered when each observation can be written as a quadratic or bilinear form in ${{\\mathbf X}_0}$.\n\nWhile these are the measurement models that have received the most attention in the literature, they are by no means the only interesting models.  Other models inspired by applications in imaging and signal processing have also appeared recently in the literature (see for example \\cite{krahmer14st,ahmed15co,ahmed15co2,tang14co,bahmani15li}).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Algorithms for Matrix Recovery}\n\\label{sec:mralgs}\n\n\n\\subsection{Low-rank approximation}\n\nWe start by reviewing the classical problem of finding the best low-rank approximation to a given ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}_0$.  By ``best'', we mean closest in the sum-of-squares sense, and we formulate the problem as\n\n", "index": 7, "text": "\\begin{equation}\n\t\\label{eq:lrapprox}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{\\boldsymbol{{X}}}_0\\|_F^2\\quad\\text{subject to}\\quad {\\text{rank}}({\\boldsymbol{{X}}}) = {R},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{%&#10;\\boldsymbol{{X}}}_{0}\\|_{F}^{2}\\quad\\text{subject to}\\quad{\\text{rank}}({%&#10;\\boldsymbol{{X}}})={R},\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mi>\ud835\udc7f</mi><mo>-</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>subject to</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mtext>rank</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>R</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $K=\\min({M},{N})$, ${\\boldsymbol{{U}}},{\\boldsymbol{{V}}}$ are ${M}\\times K$ and ${N}\\times K$ matrices with orthonormal columns ${\\boldsymbol{{u}}}_1,\\ldots,{\\boldsymbol{{u}}}_K$ and ${\\boldsymbol{{v}}}_1,\\ldots,{\\boldsymbol{{v}}}_K$, and ${\\boldsymbol{{\\Sigma}}}$ is a diagonal $K\\times K$ matrix with sorted entries $\\sigma_1\\geq\\sigma_2\\geq\\cdots\\geq\\sigma_K\\geq 0$, then the solution to \\eqref{eq:lrapprox} is found simply by truncating this expansion:\n", "itemtype": "equation", "pos": 11961, "prevtext": "\nwhere $\\|{\\boldsymbol{{X}}}-{\\boldsymbol{{X}}}_0\\|_F^2 = \\sum_{m,n}(X[m,n]-X_0[m,n])^2$ is the square of the standard Frobenius norm, and ${R}$ is the desired rank of the approximation.  This problem is nonconvex, but is actually easy to solve explicitly using the {\\em singular value decomposition} (SVD).  In particular, if we decompose ${\\boldsymbol{{X}}}_0$ as\n", "index": 9, "text": "\n\\[\n\t{\\boldsymbol{{X}}}_0 = {\\boldsymbol{{U}}}{\\boldsymbol{{\\Sigma}}}{\\boldsymbol{{V}}}^{\\mathrm{T}} = \\sum_{k=1}^{K}\\sigma_k{\\boldsymbol{{u}}}_k{\\boldsymbol{{v}}}_k^{\\mathrm{T}},\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}_{0}={\\boldsymbol{{U}}}{\\boldsymbol{{\\Sigma}}}{\\boldsymbol{{%&#10;V}}}^{\\mathrm{T}}=\\sum_{k=1}^{K}\\sigma_{k}{\\boldsymbol{{u}}}_{k}{\\boldsymbol{{%&#10;v}}}_{k}^{\\mathrm{T}},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>=</mo><mrow><mi>\ud835\udc7c</mi><mo>\u2062</mo><mi>\ud835\udeba</mi><mo>\u2062</mo><msup><mi>\ud835\udc7d</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc96</mi><mi>k</mi></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>k</mi><mi mathvariant=\"normal\">T</mi></msubsup></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis is known as the Eckart-Young theorem; see \\cite[Chapter 7]{horn85ma} for a detailed proof and discussion.\nFor medium scale problems, computing the SVD to high precision is tractable, with computational complexity scaling as $O(K^2\\max({M},N))$.\n\nComputing the best low-rank approximation, then, is akin to {\\em thresholding} the singular values: we take the matrix, compute its SVD, keep the large singular values while killing off the small ones, and then reconstruct.  A variation of the program above makes this connection clearer.  The Lagrangian of \\eqref{eq:lrapprox} is\n\n", "itemtype": "equation", "pos": 12607, "prevtext": "\nwhere $K=\\min({M},{N})$, ${\\boldsymbol{{U}}},{\\boldsymbol{{V}}}$ are ${M}\\times K$ and ${N}\\times K$ matrices with orthonormal columns ${\\boldsymbol{{u}}}_1,\\ldots,{\\boldsymbol{{u}}}_K$ and ${\\boldsymbol{{v}}}_1,\\ldots,{\\boldsymbol{{v}}}_K$, and ${\\boldsymbol{{\\Sigma}}}$ is a diagonal $K\\times K$ matrix with sorted entries $\\sigma_1\\geq\\sigma_2\\geq\\cdots\\geq\\sigma_K\\geq 0$, then the solution to \\eqref{eq:lrapprox} is found simply by truncating this expansion:\n", "index": 11, "text": "\n\\[\n\t\\widehat{{\\boldsymbol{{X}}}} = \\sum_{k=1}^{R}\\sigma_k{\\boldsymbol{{u}}}_k{\\boldsymbol{{v}}}_k^{\\mathrm{T}}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\widehat{{\\boldsymbol{{X}}}}=\\sum_{k=1}^{R}\\sigma_{k}{\\boldsymbol{{u}}}_{k}{%&#10;\\boldsymbol{{v}}}_{k}^{\\mathrm{T}}.\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>\ud835\udc7f</mi><mo>^</mo></mover><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc96</mi><mi>k</mi></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mi>k</mi><mi mathvariant=\"normal\">T</mi></msubsup></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nAs we vary the parameter $\\lambda$ above, the solution to the program changes --- in fact, the set of solutions produced for different $0\\leq\\lambda<\\infty$ is exactly the same as the set of solutions for \\eqref{eq:lrapprox} produced for all $1\\leq{R}\\leq K$.  Given $\\lambda$, we solve \\eqref{eq:lrapproxlagrange} by computing the SVD, hard thresholding the singular values via\n\n", "itemtype": "equation", "pos": 13305, "prevtext": "\nThis is known as the Eckart-Young theorem; see \\cite[Chapter 7]{horn85ma} for a detailed proof and discussion.\nFor medium scale problems, computing the SVD to high precision is tractable, with computational complexity scaling as $O(K^2\\max({M},N))$.\n\nComputing the best low-rank approximation, then, is akin to {\\em thresholding} the singular values: we take the matrix, compute its SVD, keep the large singular values while killing off the small ones, and then reconstruct.  A variation of the program above makes this connection clearer.  The Lagrangian of \\eqref{eq:lrapprox} is\n\n", "index": 13, "text": "\\begin{equation}\n\t\\label{eq:lrapproxlagrange}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{\\boldsymbol{{X}}}_0\\|_F^2 + \\lambda\\cdot{\\text{rank}}({\\boldsymbol{{X}}}).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{%&#10;\\boldsymbol{{X}}}_{0}\\|_{F}^{2}+\\lambda\\cdot{\\text{rank}}({\\boldsymbol{{X}}}).\" display=\"block\"><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mi>\ud835\udc7f</mi><mo>-</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mrow><mi>\u03bb</mi><mo>\u22c5</mo><mtext>rank</mtext></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwith $\\gamma = \\sqrt{\\lambda}$, and then taking $\\widehat{{\\boldsymbol{{X}}}} = {\\boldsymbol{{U}}}{\\boldsymbol{{\\Sigma}}}'{\\boldsymbol{{V}}}^{\\mathrm{T}}$.\n\nA common variation of the algorithm above involves replacing the hard threshold in \\eqref{eq:hardthreshold} with a {\\em soft} threshold.  In this case we still set the singular values that are small to zero, but now the large values are shrunk:\n\n", "itemtype": "equation", "pos": 13896, "prevtext": "\nAs we vary the parameter $\\lambda$ above, the solution to the program changes --- in fact, the set of solutions produced for different $0\\leq\\lambda<\\infty$ is exactly the same as the set of solutions for \\eqref{eq:lrapprox} produced for all $1\\leq{R}\\leq K$.  Given $\\lambda$, we solve \\eqref{eq:lrapproxlagrange} by computing the SVD, hard thresholding the singular values via\n\n", "index": 15, "text": "\\begin{equation}\n\t\\label{eq:hardthreshold}\n\t\\sigma_k' = \\begin{cases} \\sigma_k, & \\sigma_k\\geq \\gamma, \\\\ 0, & \\sigma_k < \\gamma, \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\sigma_{k}^{\\prime}=\\begin{cases}\\sigma_{k},&amp;\\sigma_{k}\\geq\\gamma,\\\\&#10;0,&amp;\\sigma_{k}&lt;\\gamma,\\end{cases}\" display=\"block\"><mrow><msubsup><mi>\u03c3</mi><mi>k</mi><mo>\u2032</mo></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>\u2265</mo><mi>\u03b3</mi></mrow><mo>,</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mn>0</mn><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>&lt;</mo><mi>\u03b3</mi></mrow><mo>,</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis amounts to a more gradual phasing out of the terms that just cross the threshold.  It turns out that this soft thresholding process can also be put in variational form; when $\\gamma = \\lambda/2$ the result of the procedure above is the solution to\n\n", "itemtype": "equation", "pos": 14455, "prevtext": "\nwith $\\gamma = \\sqrt{\\lambda}$, and then taking $\\widehat{{\\boldsymbol{{X}}}} = {\\boldsymbol{{U}}}{\\boldsymbol{{\\Sigma}}}'{\\boldsymbol{{V}}}^{\\mathrm{T}}$.\n\nA common variation of the algorithm above involves replacing the hard threshold in \\eqref{eq:hardthreshold} with a {\\em soft} threshold.  In this case we still set the singular values that are small to zero, but now the large values are shrunk:\n\n", "index": 17, "text": "\\begin{equation}\n\t\\label{eq:softthreshold}\n\t\\sigma_k' = \\begin{cases} \\sigma_k-\\gamma, & \\sigma_k\\geq\\gamma, \\\\ 0, & \\sigma_k < \\gamma. \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\sigma_{k}^{\\prime}=\\begin{cases}\\sigma_{k}-\\gamma,&amp;\\sigma_{k}\\geq\\gamma,\\\\&#10;0,&amp;\\sigma_{k}&lt;\\gamma.\\end{cases}\" display=\"block\"><mrow><msubsup><mi>\u03c3</mi><mi>k</mi><mo>\u2032</mo></msubsup><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>-</mo><mi>\u03b3</mi></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>\u2265</mo><mi>\u03b3</mi></mrow><mo>,</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mn>0</mn><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><msub><mi>\u03c3</mi><mi>k</mi></msub><mo>&lt;</mo><mi>\u03b3</mi></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $\\|{\\boldsymbol{{X}}}\\|_*$ is the {\\em nuclear norm}, and is equal to the sum of the singular values of ${\\boldsymbol{{X}}}$.\n\n\n\n$\\|{\\boldsymbol{{X}}}\\|_*$ is also known as the {\\em trace norm}, as it is equal to the trace when ${\\boldsymbol{{X}}}$ is symmetric positive semidefinite.  Unlike the rank, $\\|{\\boldsymbol{{X}}}\\|_*$ is a convex function, and often appears as a convex proxy for rank in optimization problems \\cite{fazel02phd}.  While in the approximation problem we are considering here, the solutions to \\eqref{eq:lrapproxlagrange} and \\eqref{eq:nnlagrange} involve very similar computations, this will not be the case at all when we consider recovery from partial observations in the next section.\n\nIn the procedures above, the computational cost is dominated by computing the SVD.  For matrices with ${M},{N}$ on the order of $100$--$1000$, there are a number of exact methods with similar computational complexity --- see \\cite[Chap.\\ 45]{hogben13ha} for an overview.  When ${\\boldsymbol{{X}}}_0$ is large but is very well approximated by a matrix with modest rank, randomized algorithms can be used to compute an approximate SVD \\cite{talwalkar13la,halko11fi,mahoney11ra}.\n\n\n\\subsection{Low-rank recovery and nuclear norm minimization}\n\nThe low-rank {\\em approximation} problem described above readily admits a straightforward solution.  However, in this survey we are concerned instead with the low-rank {\\em recovery} problem where we are working from (possibly noisy) indirect observations, ${\\boldsymbol{{y}}}\\approx{\\mathcal A}({\\boldsymbol{{X}}}_0)$.  In this case we would ideally like to solve the analog of \\eqref{eq:lrapprox},\n\n", "itemtype": "equation", "pos": 14871, "prevtext": "\nThis amounts to a more gradual phasing out of the terms that just cross the threshold.  It turns out that this soft thresholding process can also be put in variational form; when $\\gamma = \\lambda/2$ the result of the procedure above is the solution to\n\n", "index": 19, "text": "\\begin{equation}\n\t\\label{eq:nnlagrange}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}} \\|{\\boldsymbol{{X}}}-{\\boldsymbol{{X}}}_0\\|_F^2 + \\lambda\\|{\\boldsymbol{{X}}}\\|_*,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{%&#10;\\boldsymbol{{X}}}_{0}\\|_{F}^{2}+\\lambda\\|{\\boldsymbol{{X}}}\\|_{*},\" display=\"block\"><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mi>\ud835\udc7f</mi><mo>-</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mi>\u03bb</mi><mo>\u2062</mo><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nUnfortunately, whereas~\\eqref{eq:lrapprox} could be solved via a simple SVD,~\\eqref{eq:lrrecovery} is in general NP-hard.\n\nIn contrast, the nuclear norm minimization program remains tractable. In particular, with indirect observations, we replace \\eqref{eq:nnlagrange} with\n\n", "itemtype": "equation", "pos": 16726, "prevtext": "\nwhere $\\|{\\boldsymbol{{X}}}\\|_*$ is the {\\em nuclear norm}, and is equal to the sum of the singular values of ${\\boldsymbol{{X}}}$.\n\n\n\n$\\|{\\boldsymbol{{X}}}\\|_*$ is also known as the {\\em trace norm}, as it is equal to the trace when ${\\boldsymbol{{X}}}$ is symmetric positive semidefinite.  Unlike the rank, $\\|{\\boldsymbol{{X}}}\\|_*$ is a convex function, and often appears as a convex proxy for rank in optimization problems \\cite{fazel02phd}.  While in the approximation problem we are considering here, the solutions to \\eqref{eq:lrapproxlagrange} and \\eqref{eq:nnlagrange} involve very similar computations, this will not be the case at all when we consider recovery from partial observations in the next section.\n\nIn the procedures above, the computational cost is dominated by computing the SVD.  For matrices with ${M},{N}$ on the order of $100$--$1000$, there are a number of exact methods with similar computational complexity --- see \\cite[Chap.\\ 45]{hogben13ha} for an overview.  When ${\\boldsymbol{{X}}}_0$ is large but is very well approximated by a matrix with modest rank, randomized algorithms can be used to compute an approximate SVD \\cite{talwalkar13la,halko11fi,mahoney11ra}.\n\n\n\\subsection{Low-rank recovery and nuclear norm minimization}\n\nThe low-rank {\\em approximation} problem described above readily admits a straightforward solution.  However, in this survey we are concerned instead with the low-rank {\\em recovery} problem where we are working from (possibly noisy) indirect observations, ${\\boldsymbol{{y}}}\\approx{\\mathcal A}({\\boldsymbol{{X}}}_0)$.  In this case we would ideally like to solve the analog of \\eqref{eq:lrapprox},\n\n", "index": 21, "text": "\\begin{equation*} \\label{eq:lrrecovery}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}} \\|{\\boldsymbol{{y}}}-{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 \\quad\\text{subject to}\\quad {\\text{rank}}({\\boldsymbol{{X}}})={R}.\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{y}}}-{%&#10;\\mathcal{A}}({\\boldsymbol{{X}}})\\|_{2}^{2}\\quad\\text{subject to}\\quad{\\text{%&#10;rank}}({\\boldsymbol{{X}}})={R}.\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mi>\ud835\udc9a</mi><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>subject to</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mtext>rank</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>R</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis is an unconstrained convex optimization program, and can be solved in a systematic way using a {\\em proximal algorithm} \\cite{parikh13pr,combettes11pr}.  The solution(s) to \\eqref{eq:matrixlasso} will obey, for any $\\gamma>0$, the fixed point condition \\cite{combettes11pr}\n", "itemtype": "equation", "pos": 17238, "prevtext": "\nUnfortunately, whereas~\\eqref{eq:lrapprox} could be solved via a simple SVD,~\\eqref{eq:lrrecovery} is in general NP-hard.\n\nIn contrast, the nuclear norm minimization program remains tractable. In particular, with indirect observations, we replace \\eqref{eq:nnlagrange} with\n\n", "index": 23, "text": "\\begin{equation}\n\t\\label{eq:matrixlasso}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}} \\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_2^2 + \\lambda\\|{\\boldsymbol{{X}}}\\|_*.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\mathcal{A}}({%&#10;\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_{2}^{2}+\\lambda\\|{\\boldsymbol{{X}}}\\|_%&#10;{*}.\" display=\"block\"><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mi>\u03bb</mi><mo>\u2062</mo><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\t\nwhere the proximal operator is\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nThis is an unconstrained convex optimization program, and can be solved in a systematic way using a {\\em proximal algorithm} \\cite{parikh13pr,combettes11pr}.  The solution(s) to \\eqref{eq:matrixlasso} will obey, for any $\\gamma>0$, the fixed point condition \\cite{combettes11pr}\n", "index": 25, "text": "\n\\[\n\t{\\boldsymbol{{X}}}_\\star = \\operatorname{prox}_{\\gamma}({\\boldsymbol{{X}}}_\\star - \\gamma{\\mathcal A}^*({\\mathcal A}({\\boldsymbol{{X}}}_\\star) - {\\boldsymbol{{y}}} )\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}_{\\star}=\\operatorname{prox}_{\\gamma}({\\boldsymbol{{X}}}_{%&#10;\\star}-\\gamma{\\mathcal{A}}^{*}({\\mathcal{A}}({\\boldsymbol{{X}}}_{\\star})-{%&#10;\\boldsymbol{{y}}})\" display=\"block\"><mrow><msub><mi>\ud835\udc7f</mi><mo>\u22c6</mo></msub><mo>=</mo><msub><mo>prox</mo><mi>\u03b3</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mo>\u22c6</mo></msub><mo>-</mo><mi>\u03b3</mi><msup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>*</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mo>\u22c6</mo></msub><mo stretchy=\"false\">)</mo></mrow><mo>-</mo><mi>\ud835\udc9a</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nOne class of methods for solving \\eqref{eq:matrixlasso} are based on the iteration\n\n", "itemtype": "equation", "pos": 17928, "prevtext": "\t\nwhere the proximal operator is\n\n", "index": 27, "text": "\\begin{equation}\n\t\\label{eq:nnprox}\n\t\\operatorname{prox}_{\\gamma}({\\boldsymbol{{Z}}}) = {\\operatorname{\\text{arg~min}}}_{{\\boldsymbol{{X}}}} \\|{\\boldsymbol{{X}}}-{\\boldsymbol{{Z}}}\\|_F^2 + \\gamma\\lambda\\|{\\boldsymbol{{X}}}\\|_*.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{prox}_{\\gamma}({\\boldsymbol{{Z}}})={\\operatorname{\\text{arg~{}%&#10;min}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}-{\\boldsymbol{{Z}}}\\|_{F}^{2}+%&#10;\\gamma\\lambda\\|{\\boldsymbol{{X}}}\\|_{*}.\" display=\"block\"><mrow><mrow><mrow><msub><mo>prox</mo><mi>\u03b3</mi></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc81</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mtext>arg\u00a0min</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mi>\ud835\udc7f</mi><mo>-</mo><mi>\ud835\udc81</mi></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>\u03bb</mi><mo>\u2062</mo><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nfor some appropriately chosen sequence $\\{\\gamma_k\\}$ \\cite{cai10si}.  As discussed in the previous section, the subproblem \\eqref{eq:nnprox} is solved by singular value soft-thresholding.  Computing the SVD of the ${\\boldsymbol{{X}}}_k - \\gamma_k{\\mathcal A}^*({\\mathcal A}({\\boldsymbol{{X}}}_k) - {\\boldsymbol{{y}}} )$ at each iteration is almost always the dominant cost, as it typically requires significantly more computation than applying ${\\mathcal A}$ and ${\\mathcal A}^*$.\n\nState-of-the-art methods for solving \\eqref{eq:matrixlasso} based on singular value thresholding are not too much more complicated.  For example, the FISTA algorithm \\cite{beck09fa} modifies the basic iteration in \\eqref{eq:proxiter} through intelligent choices of the scaling coefficient $\\gamma_k$ and by replacing ${\\boldsymbol{{X}}}_k$ with a carefully chosen combination of ${\\boldsymbol{{X}}}_k$ and ${\\boldsymbol{{X}}}_{k-1}$.  These small changes have almost no effect on the amount of computation done at each iteration, but they converge in significantly fewer iterations.\n\n\n\nThe simplicity of these proximal-type algorithms makes them very attractive for small to medium sized problems.  However, as the number of rows and columns in the matrix gets to be several thousand, direct computation of the SVD becomes problematic.  For specially structured ${\\mathcal A}$, including the important case where ${\\mathcal A}({\\boldsymbol{{X}}})$ returns a subset of the entries of ${\\boldsymbol{{X}}}$, fast algorithms that take advantage of this structure to compute the SVD have been developed to solve \\eqref{eq:matrixlasso} or closely related problems \\cite{mazumder10sp,cai10si}.  In more general settings, techniques from randomized linear algebra have been applied to compute approximate SVDs \\cite{zhou11go}.\n\nStorage is also an issue when the target matrix is large.  Since we expect the target matrix to have small rank, we would like to save on storage by restricting the iterates to also be low rank.  We can reformulate the program above with  ${\\boldsymbol{{X}}}\\approx {\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}}$, and optimize over the ${M}\\times{R}$ and ${N}\\times{R}$ matrices ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$ rather than the ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$.  This reformulation is driven by the fact that the nuclear norm is equal to the minimum Frobenius norm factorization \\cite{RechtFP_Guaranteed}:\n", "itemtype": "equation", "pos": 18254, "prevtext": "\nOne class of methods for solving \\eqref{eq:matrixlasso} are based on the iteration\n\n", "index": 29, "text": "\\begin{equation}\n\t\\label{eq:proxiter}\n\t{\\boldsymbol{{X}}}_{k+1} = \\operatorname{prox}_{\\gamma_k}({\\boldsymbol{{X}}}_k - \\gamma_k{\\mathcal A}^*({\\mathcal A}({\\boldsymbol{{X}}}_k) - {\\boldsymbol{{y}}} ),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}_{k+1}=\\operatorname{prox}_{\\gamma_{k}}({\\boldsymbol{{X}}}_{%&#10;k}-\\gamma_{k}{\\mathcal{A}}^{*}({\\mathcal{A}}({\\boldsymbol{{X}}}_{k})-{%&#10;\\boldsymbol{{y}}}),\" display=\"block\"><mrow><msub><mi>\ud835\udc7f</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mo>prox</mo><msub><mi>\u03b3</mi><mi>k</mi></msub></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mi>k</mi></msub><mo>-</mo><msub><mi>\u03b3</mi><mi>k</mi></msub><msup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>*</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>-</mo><mi>\ud835\udc9a</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nWe can then replace \\eqref{eq:matrixlasso} with\n\n", "itemtype": "equation", "pos": 20906, "prevtext": "\nfor some appropriately chosen sequence $\\{\\gamma_k\\}$ \\cite{cai10si}.  As discussed in the previous section, the subproblem \\eqref{eq:nnprox} is solved by singular value soft-thresholding.  Computing the SVD of the ${\\boldsymbol{{X}}}_k - \\gamma_k{\\mathcal A}^*({\\mathcal A}({\\boldsymbol{{X}}}_k) - {\\boldsymbol{{y}}} )$ at each iteration is almost always the dominant cost, as it typically requires significantly more computation than applying ${\\mathcal A}$ and ${\\mathcal A}^*$.\n\nState-of-the-art methods for solving \\eqref{eq:matrixlasso} based on singular value thresholding are not too much more complicated.  For example, the FISTA algorithm \\cite{beck09fa} modifies the basic iteration in \\eqref{eq:proxiter} through intelligent choices of the scaling coefficient $\\gamma_k$ and by replacing ${\\boldsymbol{{X}}}_k$ with a carefully chosen combination of ${\\boldsymbol{{X}}}_k$ and ${\\boldsymbol{{X}}}_{k-1}$.  These small changes have almost no effect on the amount of computation done at each iteration, but they converge in significantly fewer iterations.\n\n\n\nThe simplicity of these proximal-type algorithms makes them very attractive for small to medium sized problems.  However, as the number of rows and columns in the matrix gets to be several thousand, direct computation of the SVD becomes problematic.  For specially structured ${\\mathcal A}$, including the important case where ${\\mathcal A}({\\boldsymbol{{X}}})$ returns a subset of the entries of ${\\boldsymbol{{X}}}$, fast algorithms that take advantage of this structure to compute the SVD have been developed to solve \\eqref{eq:matrixlasso} or closely related problems \\cite{mazumder10sp,cai10si}.  In more general settings, techniques from randomized linear algebra have been applied to compute approximate SVDs \\cite{zhou11go}.\n\nStorage is also an issue when the target matrix is large.  Since we expect the target matrix to have small rank, we would like to save on storage by restricting the iterates to also be low rank.  We can reformulate the program above with  ${\\boldsymbol{{X}}}\\approx {\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}}$, and optimize over the ${M}\\times{R}$ and ${N}\\times{R}$ matrices ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$ rather than the ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$.  This reformulation is driven by the fact that the nuclear norm is equal to the minimum Frobenius norm factorization \\cite{RechtFP_Guaranteed}:\n", "index": 31, "text": "\n\\[\n\t\\|{\\boldsymbol{{X}}}\\|_* = \\min_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}} \\frac{1}{2}\\left(\\|{\\boldsymbol{{L}}}\\|_F^2 + \\|{\\boldsymbol{{R}}}\\|_F^2\\right)\n\t\\quad\\text{subject to}\\quad {\\boldsymbol{{X}}}={\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\|{\\boldsymbol{{X}}}\\|_{*}=\\min_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}}\\frac{1%&#10;}{2}\\left(\\|{\\boldsymbol{{L}}}\\|_{F}^{2}+\\|{\\boldsymbol{{R}}}\\|_{F}^{2}\\right)%&#10;\\quad\\text{subject to}\\quad{\\boldsymbol{{X}}}={\\boldsymbol{{L}}}{\\boldsymbol{{%&#10;R}}}^{\\mathrm{T}}.\" display=\"block\"><mrow><mrow><mrow><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub><mo>=</mo><mrow><mrow><mrow><munder><mi>min</mi><mrow><mi>\ud835\udc73</mi><mo>,</mo><mi>\ud835\udc79</mi></mrow></munder><mo>\u2061</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><mo>\u2062</mo><mrow><mo>(</mo><mrow><msubsup><mrow><mo>\u2225</mo><mi>\ud835\udc73</mi><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mrow><mo>\u2225</mo><mi>\ud835\udc79</mi><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo>)</mo></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>subject to</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mi>\ud835\udc7f</mi><mo>=</mo><mrow><mi>\ud835\udc73</mi><mo>\u2062</mo><msup><mi>\ud835\udc79</mi><mi mathvariant=\"normal\">T</mi></msup></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nand if the solution to \\eqref{eq:matrixlasso} does indeed have rank at most ${R}$, it will also be the solution to \\eqref{eq:bmnonconvex}.  While this new formulation is non-convex --- ${\\mathcal A}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})$ is a combination of products of unknowns --- there are assurances that the local minima in \\eqref{eq:bmnonconvex} are also global minima if the rank of the true solution is smaller than ${R}$ \\cite{burer05lo}.\n\n\nThis technique is sometimes referred to as the {\\em Burer-Monteiro heuristic}, after the authors of \\cite{burer03no,burer05lo} who proposed a version of the above for general semidefinite programming, and it is used in state-of-the-art large scale implementations of matrix recovery problems \\cite{recht13pa}.\n\nThe parameter $\\lambda$ in \\eqref{eq:matrixlasso} determines the trade-off between the fidelity of the solution to the measurements ${\\boldsymbol{{y}}}$ and its conformance to the low-rank model.  When we are very confident in the measurements, it might make sense to use them to define a set of linear equality constraints, solving\n\n", "itemtype": "equation", "pos": 21213, "prevtext": "\nWe can then replace \\eqref{eq:matrixlasso} with\n\n", "index": 33, "text": "\\begin{equation}\n\t\\label{eq:bmnonconvex}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}} \\|{\\mathcal A}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})-{\\boldsymbol{{y}}}\\|_2^2 + \\frac{\\lambda}{2}\\|{\\boldsymbol{{L}}}\\|_F^2 + \\frac{\\lambda}{2}\\|{\\boldsymbol{{R}}}\\|_F^2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}}\\|{%&#10;\\mathcal{A}}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})-{\\boldsymbol{{%&#10;y}}}\\|_{2}^{2}+\\frac{\\lambda}{2}\\|{\\boldsymbol{{L}}}\\|_{F}^{2}+\\frac{\\lambda}{%&#10;2}\\|{\\boldsymbol{{R}}}\\|_{F}^{2},\" display=\"block\"><mrow><mrow><mrow><msub><mtext>minimize</mtext><mrow><mi>\ud835\udc73</mi><mo>,</mo><mi>\ud835\udc79</mi></mrow></msub><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc73</mi><mo>\u2062</mo><msup><mi>\ud835\udc79</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mfrac><mi>\u03bb</mi><mn>2</mn></mfrac><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mi>\ud835\udc73</mi><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mfrac><mi>\u03bb</mi><mn>2</mn></mfrac><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mi>\ud835\udc79</mi><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\t\nThe output of this program will match \\eqref{eq:matrixlasso} as $\\lambda\\rightarrow 0$.  Some of the analytical results we review in Sections~\\ref{sec:gauss} and \\ref{sec:mc} reveal conditions under which \\eqref{eq:nneq} recovers a low-rank matrix ${{\\mathbf X}_0}$ exactly given measurements ${\\boldsymbol{{y}}}={\\mathcal A}({\\boldsymbol{{X}}}_0)$ as constraints.\n\n\n\\subsection{Iterative hard thresholding}\n\nFrom the algorithmic point of view, iterative hard thresholding (IHT) algorithms \\cite{jain10gu,tanner13no} are very similar to the proximal algorithms used to solve nuclear norm minimization in the previous section.  However, when the target is very low rank, they tend to converge extremely quickly.\n\nThe basic iteration is as follows.  From the current estimate ${\\boldsymbol{{X}}}_k$, we first take a step in the direction of the gradient of $\\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_2^2$, then project onto the set of rank ${R}$ matrices:\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nand if the solution to \\eqref{eq:matrixlasso} does indeed have rank at most ${R}$, it will also be the solution to \\eqref{eq:bmnonconvex}.  While this new formulation is non-convex --- ${\\mathcal A}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})$ is a combination of products of unknowns --- there are assurances that the local minima in \\eqref{eq:bmnonconvex} are also global minima if the rank of the true solution is smaller than ${R}$ \\cite{burer05lo}.\n\n\nThis technique is sometimes referred to as the {\\em Burer-Monteiro heuristic}, after the authors of \\cite{burer03no,burer05lo} who proposed a version of the above for general semidefinite programming, and it is used in state-of-the-art large scale implementations of matrix recovery problems \\cite{recht13pa}.\n\nThe parameter $\\lambda$ in \\eqref{eq:matrixlasso} determines the trade-off between the fidelity of the solution to the measurements ${\\boldsymbol{{y}}}$ and its conformance to the low-rank model.  When we are very confident in the measurements, it might make sense to use them to define a set of linear equality constraints, solving\n\n", "index": 35, "text": "\\begin{equation}\n\t\\label{eq:nneq}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~\\|{\\boldsymbol{{X}}}\\|_*\\quad\\text{subeject to}\\quad {\\mathcal A}({\\boldsymbol{{X}}})={\\boldsymbol{{y}}}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~{}\\|{\\boldsymbol{{X}}}\\|%&#10;_{*}\\quad\\text{subeject to}\\quad{\\mathcal{A}}({\\boldsymbol{{X}}})={\\boldsymbol%&#10;{{y}}}.\" display=\"block\"><mrow><mrow><mrow><mrow><mpadded width=\"+3.3pt\"><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub></mpadded><mo>\u2062</mo><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>subeject to</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>\ud835\udc9a</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThe $\\operatorname{ProjectRank}_{{R}}$ operator computes the top ${R}$ left and right singular vectors and singular values --- when ${R}$ is small compared to ${M}$ and ${N}$, this can be done in significantly less time than computing a full SVD \\cite{simon00lo}, especially if the operator ${\\mathcal A}$ and its adjoint ${\\mathcal A}^*$ are structured in a such a way that there is a fast method for applying the matrices ${\\boldsymbol{{Y}}}_{k+1}$ to a series of vectors.  In these cases, the intermediate matrix ${\\boldsymbol{{Y}}}_{k+1}$ is not computed explicitly, but each term in the first equation above can be handled efficiently in the SVD computation.  The implementations of IHT in \\cite{jain10gu,tanner13no} rely on existing software packages \\cite{propack} to do this.\n\nIn contrast to the nuclear norm minimization algorithm above, each of the iterates ${\\boldsymbol{{X}}}_k$ IHT produces has a prescribed rank.  The storage required for ${\\boldsymbol{{X}}}_k$ is roughly ${R}({M}+{N})$, as opposed to the ${M}{N}$ required for a general ${M}\\times{N}$ matrix.  This difference is critical for large-scale applications.\n\n\n\n\n\n\\subsection{Alternating projections}\n\\label{sec:alternatingprojections}\n\nThe alternating projections algorithm  is another space efficient technique which stores the iterates in factored form.  The algorithm is extraordinarily simple, and easy to interpret: looking for a ${M}\\times{N}$ rank ${R}$ matrix that is consistent with ${\\boldsymbol{{y}}}$:\n", "itemtype": "equation", "pos": 23813, "prevtext": "\t\nThe output of this program will match \\eqref{eq:matrixlasso} as $\\lambda\\rightarrow 0$.  Some of the analytical results we review in Sections~\\ref{sec:gauss} and \\ref{sec:mc} reveal conditions under which \\eqref{eq:nneq} recovers a low-rank matrix ${{\\mathbf X}_0}$ exactly given measurements ${\\boldsymbol{{y}}}={\\mathcal A}({\\boldsymbol{{X}}}_0)$ as constraints.\n\n\n\\subsection{Iterative hard thresholding}\n\nFrom the algorithmic point of view, iterative hard thresholding (IHT) algorithms \\cite{jain10gu,tanner13no} are very similar to the proximal algorithms used to solve nuclear norm minimization in the previous section.  However, when the target is very low rank, they tend to converge extremely quickly.\n\nThe basic iteration is as follows.  From the current estimate ${\\boldsymbol{{X}}}_k$, we first take a step in the direction of the gradient of $\\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_2^2$, then project onto the set of rank ${R}$ matrices:\n\n", "index": 37, "text": "\\begin{align*}\n\t{\\boldsymbol{{Y}}}_{k+1} &= {\\boldsymbol{{X}}}_k - \\gamma_k{\\mathcal A}^*({\\mathcal A}({\\boldsymbol{{X}}}_k) - {\\boldsymbol{{y}}})) \\\\\n\t{\\boldsymbol{{X}}}_{k+1} &= \\operatorname{ProjectRank}_{{R}}({\\boldsymbol{{Y}}}_{k+1}).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{Y}}}_{k+1}\" display=\"inline\"><msub><mi>\ud835\udc80</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle={\\boldsymbol{{X}}}_{k}-\\gamma_{k}{\\mathcal{A}}^{*}({\\mathcal{A}}%&#10;({\\boldsymbol{{X}}}_{k})-{\\boldsymbol{{y}}}))\" display=\"inline\"><mrow><mo>=</mo><msub><mi>\ud835\udc7f</mi><mi>k</mi></msub><mo>-</mo><msub><mi>\u03b3</mi><mi>k</mi></msub><msup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>*</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>-</mo><mi>\ud835\udc9a</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{X}}}_{k+1}\" display=\"inline\"><msub><mi>\ud835\udc7f</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\operatorname{ProjectRank}_{{R}}({\\boldsymbol{{Y}}}_{k+1}).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><msub><mo>ProjectRank</mo><mi>R</mi></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc80</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nis the same as looking for a ${M}\\times{R}$ matrix ${\\boldsymbol{{L}}}$ and a ${N}\\times{R}$ matrix ${\\boldsymbol{{R}}}$ whose product is consistent with ${\\boldsymbol{{y}}}$:\n\n", "itemtype": "equation", "pos": 25556, "prevtext": "\nThe $\\operatorname{ProjectRank}_{{R}}$ operator computes the top ${R}$ left and right singular vectors and singular values --- when ${R}$ is small compared to ${M}$ and ${N}$, this can be done in significantly less time than computing a full SVD \\cite{simon00lo}, especially if the operator ${\\mathcal A}$ and its adjoint ${\\mathcal A}^*$ are structured in a such a way that there is a fast method for applying the matrices ${\\boldsymbol{{Y}}}_{k+1}$ to a series of vectors.  In these cases, the intermediate matrix ${\\boldsymbol{{Y}}}_{k+1}$ is not computed explicitly, but each term in the first equation above can be handled efficiently in the SVD computation.  The implementations of IHT in \\cite{jain10gu,tanner13no} rely on existing software packages \\cite{propack} to do this.\n\nIn contrast to the nuclear norm minimization algorithm above, each of the iterates ${\\boldsymbol{{X}}}_k$ IHT produces has a prescribed rank.  The storage required for ${\\boldsymbol{{X}}}_k$ is roughly ${R}({M}+{N})$, as opposed to the ${M}{N}$ required for a general ${M}\\times{N}$ matrix.  This difference is critical for large-scale applications.\n\n\n\n\n\n\\subsection{Alternating projections}\n\\label{sec:alternatingprojections}\n\nThe alternating projections algorithm  is another space efficient technique which stores the iterates in factored form.  The algorithm is extraordinarily simple, and easy to interpret: looking for a ${M}\\times{N}$ rank ${R}$ matrix that is consistent with ${\\boldsymbol{{y}}}$:\n", "index": 39, "text": "\n\\[\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~\\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_2^2,\\quad\\text{subject to}\\quad{\\text{rank}}({\\boldsymbol{{X}}})={R},\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~{}\\|{\\mathcal{A}}({%&#10;\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_{2}^{2},\\quad\\text{subject to}\\quad{%&#10;\\text{rank}}({\\boldsymbol{{X}}})={R},\" display=\"block\"><mrow><mrow><mrow><mrow><mpadded width=\"+3.3pt\"><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub></mpadded><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><mo rspace=\"12.5pt\">,</mo><mtext>subject to</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mtext>rank</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mi>R</mi></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis optimization problem is still non-convex, but with one of ${\\boldsymbol{{L}}}$ or ${\\boldsymbol{{R}}}$ fixed, it is a simple least-squares problem.  This motivates the following iteration.  Given current estimates ${\\boldsymbol{{L}}}_k$,${\\boldsymbol{{R}}}_k$, we update using\n\n", "itemtype": "equation", "pos": 25920, "prevtext": "\nis the same as looking for a ${M}\\times{R}$ matrix ${\\boldsymbol{{L}}}$ and a ${N}\\times{R}$ matrix ${\\boldsymbol{{R}}}$ whose product is consistent with ${\\boldsymbol{{y}}}$:\n\n", "index": 41, "text": "\\begin{equation}\n\t\\label{eq:altminopt}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}}~\\|{\\mathcal A}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})-{\\boldsymbol{{y}}}\\|_2^2.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{L}}},{\\boldsymbol{{R}}}}~{}\\|{%&#10;\\mathcal{A}}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}^{\\mathrm{T}})-{\\boldsymbol{{%&#10;y}}}\\|_{2}^{2}.\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><msub><mtext>minimize</mtext><mrow><mi>\ud835\udc73</mi><mo>,</mo><mi>\ud835\udc79</mi></mrow></msub></mpadded><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc73</mi><mo>\u2062</mo><msup><mi>\ud835\udc79</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nEach step involves solving a linear system of equations with ${R}{M}$ or ${R}{N}$ variables for which we can draw on well-established algorithms in numerical linear algebra.  Its simplicity and efficiency make it one of the most popular methods for large-scale matrix factorization \\cite{koren09ma}, and it tends to outperform nuclear norm minimization \\cite{haldar09ra,jain13lo}, especially in cases where the rank ${R}$ is very small compared to ${N},{M}$.\n\nThere are few general convergence guarantees for alternating projections, and the final solution tends to depend heavily on the initialization of ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$.  However, guarantees for the rate of convergence can be found in \\cite{Kesha_Efficient} and recent work \\cite{jain13lo} has provided some first theoretical results for conditions under which the iterations above converge to the true low-rank matrix (and a method for supplying a reliable starting point).  These are discussed further in Sections~\\ref{sec:gauss} and \\ref{sec:mc} below.\n\nAnother advantage alternating projections is that the framework can be extended to handle structure on one or both of the factors ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$.  Typically, this means that the least-squares problems above are either regularized or constrained in a manner which encourages or enforces the desired structure.  Extensions of the iterations above have been used successfully for problems including non-negative matrix factorization \\cite{kim08no}, sparse PCA, where we restrict the number of nonzero terms in  ${\\boldsymbol{{L}}},{\\boldsymbol{{R}}}$ \\cite{zou06sp}, and dictionary learning \\cite{olshausen96na,lewicki99pr}, where ${\\boldsymbol{{L}}}$ is a well-conditioned matrix and ${\\boldsymbol{{R}}}$ is sparse.  Again, there are few strong theoretical guarantees for these algorithms, with notable exceptions in the recent works \\cite{lee13ne,agarwal14le}.\n\n\nThe optimization problems for alternating projections \\eqref{eq:altminopt} and the Burer-Monteiro heurtistic \\eqref{eq:bmnonconvex} are similar (nonlinear) least-squares problems on the matrix factors ${\\boldsymbol{{L}}},{\\boldsymbol{{R}}}$.  The algorithms used to solve them, though, have a distinct difference: instead of fixing for one factor and optimizing the other as in \\eqref{eq:altminiter} above, solvers for \\eqref{eq:bmnonconvex} (e.g.,~\\cite{recht13pa}) typically take descent steps on ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$ simultaneously.  Convergence analysis for closely related local descent methods can be found in the recent works \\cite{TuBSR_Lowrank,BhojKS_Dropping}.\n\n\n\n\n\n\n\n\\subsection{Other algorithms for matrix recovery}\n\nThe methods above are by no means the only algorithms which have been proposed for low-rank matrix recovery.  We close this section by briefly mentioning some other techniques.\n\nRecent years have seen a renewed interest in Frank-Wolfe-type algorithms for minimizing norms defined by the convex hull of a set of atoms~\\cite{clarkson10co,jaggi13re}.  These algorithms are of particular interest for minimizing the nuclear norm (where the atoms are rank-1 matrices), as they only require computing the leading singular vector at every iteration, rather than a full SVD~\\cite{jaggi10si}.\nThe nuclear norm problems in~\\eqref{eq:matrixlasso} and~\\eqref{eq:nneq} can also be minimized by solving a series of weighted least-squares problems, each of which can be solved using standard techniques for linear systems of equations~\\cite{fornasier11lo,MohanF_Iterative,FornaPRW_Conjugate}.\n\nBeyond the nuclear norm, other proxies for rank exist.  The max-norm~\\cite{srebro04ma,srebro05ra} is a convex function that results in a similar optimization program to~\\eqref{eq:matrixlasso}, and is subject to similar heuristics as~\\eqref{eq:bmnonconvex} for storage reduction~\\cite{recht13pa}.  Alternatively, the logarithm of the determinant is a nonconvex, but smooth, proxy for rank when ${\\boldsymbol{{X}}}$ is positive semidefinite (and can be applied to general matrices by embedding them in a PSD matrix).  In practice, locally minimizing this function subject to convex constraints tends to produce low-rank solutions~\\cite{FazelHB_Logdet}.\n\nA greedy algorithm for low-rank recovery was presented in~\\cite{lee10ad}.  This algorithm alternates between selecting an estimate for the ${R}$-dimensional subspace in which ${{\\mathbf X}_0}$ lives, and projecting onto these subspaces; it is equipped with strong theoretical guarantees.  Another class of algorithms evolves the left and right singular vectors along the Grassman manifold~\\cite{dai11su,KeshaMO_Matrix}.  These algorithms, which are specialized for the matrix completion problem, are computationally efficient, and have equally strong theoretical performance guarantees.\n\n\n\n\\section{Matrix Recovery from Gaussian Observations}\n\\label{sec:gauss}\n\n\n\nThe theory of low-rank recovery is clean and elegant when the measurement operator ${\\mathcal A}(\\cdot)$ is a random projection.  Applications where this is a good model for the observations are limited, but looking at it as an abstract problem gives us real mathematical insight about why low-rank recovery works.\n\nThe discussion in this section will center on ``Gaussian'' ${\\mathcal A}(\\cdot)$, where the entries of each of the ${\\boldsymbol{{A}}}_m$ are independent and identically distributed normal random variables with zero mean and variance $L^{-1}$ --- this variance is chosen so that ${\\operatorname{E}}[\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2] = \\|{\\boldsymbol{{X}}}\\|_F^2$ for any fixed ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$.\n\n\\subsection{The matrix restricted isometry property}\n\\label{ssec:MRIP}\n\nWe first examine the fundamental question of whether we can distinguish different rank-${R}$ matrices viewed through the lens of the operator ${\\mathcal A}$.  One way to formalize this is asking whether ${\\mathcal A}$ preserves the distances between all such matrices; this is certainly true if there exists a $0\\leq\\delta<1$ such that\n\n", "itemtype": "equation", "pos": 26422, "prevtext": "\nThis optimization problem is still non-convex, but with one of ${\\boldsymbol{{L}}}$ or ${\\boldsymbol{{R}}}$ fixed, it is a simple least-squares problem.  This motivates the following iteration.  Given current estimates ${\\boldsymbol{{L}}}_k$,${\\boldsymbol{{R}}}_k$, we update using\n\n", "index": 43, "text": "\\begin{equation}\n\t\\label{eq:altminiter}\n    \\begin{aligned}\n\t{\\boldsymbol{{R}}}_{k+1} &= \\arg\\min_{{\\boldsymbol{{R}}}}\\|{\\mathcal A}({\\boldsymbol{{L}}}_k{\\boldsymbol{{R}}}^{\\mathrm{T}}) - {\\boldsymbol{{y}}}\\|_2^2, \\\\\n\t{\\boldsymbol{{L}}}_{k+1} &= \\arg\\min_{{\\boldsymbol{{L}}}}\\|{\\mathcal A}({\\boldsymbol{{L}}}{\\boldsymbol{{R}}}_{k+1}^{\\mathrm{T}}) - {\\boldsymbol{{y}}}\\|_2^2.\n    \\end{aligned}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13X.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{R}}}_{k+1}\" display=\"inline\"><msub><mi>\ud835\udc79</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13X.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\arg\\min_{{\\boldsymbol{{R}}}}\\|{\\mathcal{A}}({\\boldsymbol{{L}}}_%&#10;{k}{\\boldsymbol{{R}}}^{\\mathrm{T}})-{\\boldsymbol{{y}}}\\|_{2}^{2},\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mi>arg</mi><mo>\u2061</mo><munder><mi>min</mi><mi>\ud835\udc79</mi></munder></mrow><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\ud835\udc73</mi><mi>k</mi></msub><mo>\u2062</mo><msup><mi>\ud835\udc79</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13Xa.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{L}}}_{k+1}\" display=\"inline\"><msub><mi>\ud835\udc73</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13Xa.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\arg\\min_{{\\boldsymbol{{L}}}}\\|{\\mathcal{A}}({\\boldsymbol{{L}}}{%&#10;\\boldsymbol{{R}}}_{k+1}^{\\mathrm{T}})-{\\boldsymbol{{y}}}\\|_{2}^{2}.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mi>arg</mi><mo>\u2061</mo><munder><mi>min</mi><mi>\ud835\udc73</mi></munder></mrow><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc73</mi><mo>\u2062</mo><msubsup><mi>\ud835\udc79</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mi mathvariant=\"normal\">T</mi></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nfor all ${\\boldsymbol{{X}}}_1,{\\boldsymbol{{X}}}_2$ of rank ${R}$ or smaller.  This condition is known as the {\\em matrix restricted isometry property} (matrix-RIP), and is the matrix analog to the restricted isometry property from compressive sensing~\\cite{DavenDEK_Introduction}. The first immediate consequence is that all matrices of rank ${R}$ or less have unique images, since if ${\\mathcal A}({\\boldsymbol{{X}}}_1)={\\mathcal A}({\\boldsymbol{{X}}}_2)$ for ${\\boldsymbol{{X}}}_1\\not={\\boldsymbol{{X}}}_2$, then the lower bound would be violated.  Qualitatively, the upper and lower bounds tell us that two rank ${R}$ matrices are as distinguishable from their measurements as they would be if they were observed directly.  With \\eqref{eq:matrix-rip} established, we can use any number of techniques to recover a low-rank matrix from measurements through ${\\mathcal A}$; we discuss some specific guarantees below.\n\nA Gaussian ${\\mathcal A}$ will almost certainly have the  matrix restricted isometry property when the number of observations are commensurate with the number of degrees of freedom for an ${M}\\times{N}$ matrix with rank ${R}$.  Specifically, \\eqref{eq:matrix-rip} holds with high probability when\\footnote{We use this compact notation to mean that there is a constant so that ${L}\\geq\\mathrm{Const}\\cdot{R}({M}+{N})$.}\n\n", "itemtype": "equation", "pos": 32866, "prevtext": "\nEach step involves solving a linear system of equations with ${R}{M}$ or ${R}{N}$ variables for which we can draw on well-established algorithms in numerical linear algebra.  Its simplicity and efficiency make it one of the most popular methods for large-scale matrix factorization \\cite{koren09ma}, and it tends to outperform nuclear norm minimization \\cite{haldar09ra,jain13lo}, especially in cases where the rank ${R}$ is very small compared to ${N},{M}$.\n\nThere are few general convergence guarantees for alternating projections, and the final solution tends to depend heavily on the initialization of ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$.  However, guarantees for the rate of convergence can be found in \\cite{Kesha_Efficient} and recent work \\cite{jain13lo} has provided some first theoretical results for conditions under which the iterations above converge to the true low-rank matrix (and a method for supplying a reliable starting point).  These are discussed further in Sections~\\ref{sec:gauss} and \\ref{sec:mc} below.\n\nAnother advantage alternating projections is that the framework can be extended to handle structure on one or both of the factors ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$.  Typically, this means that the least-squares problems above are either regularized or constrained in a manner which encourages or enforces the desired structure.  Extensions of the iterations above have been used successfully for problems including non-negative matrix factorization \\cite{kim08no}, sparse PCA, where we restrict the number of nonzero terms in  ${\\boldsymbol{{L}}},{\\boldsymbol{{R}}}$ \\cite{zou06sp}, and dictionary learning \\cite{olshausen96na,lewicki99pr}, where ${\\boldsymbol{{L}}}$ is a well-conditioned matrix and ${\\boldsymbol{{R}}}$ is sparse.  Again, there are few strong theoretical guarantees for these algorithms, with notable exceptions in the recent works \\cite{lee13ne,agarwal14le}.\n\n\nThe optimization problems for alternating projections \\eqref{eq:altminopt} and the Burer-Monteiro heurtistic \\eqref{eq:bmnonconvex} are similar (nonlinear) least-squares problems on the matrix factors ${\\boldsymbol{{L}}},{\\boldsymbol{{R}}}$.  The algorithms used to solve them, though, have a distinct difference: instead of fixing for one factor and optimizing the other as in \\eqref{eq:altminiter} above, solvers for \\eqref{eq:bmnonconvex} (e.g.,~\\cite{recht13pa}) typically take descent steps on ${\\boldsymbol{{L}}}$ and ${\\boldsymbol{{R}}}$ simultaneously.  Convergence analysis for closely related local descent methods can be found in the recent works \\cite{TuBSR_Lowrank,BhojKS_Dropping}.\n\n\n\n\n\n\n\n\\subsection{Other algorithms for matrix recovery}\n\nThe methods above are by no means the only algorithms which have been proposed for low-rank matrix recovery.  We close this section by briefly mentioning some other techniques.\n\nRecent years have seen a renewed interest in Frank-Wolfe-type algorithms for minimizing norms defined by the convex hull of a set of atoms~\\cite{clarkson10co,jaggi13re}.  These algorithms are of particular interest for minimizing the nuclear norm (where the atoms are rank-1 matrices), as they only require computing the leading singular vector at every iteration, rather than a full SVD~\\cite{jaggi10si}.\nThe nuclear norm problems in~\\eqref{eq:matrixlasso} and~\\eqref{eq:nneq} can also be minimized by solving a series of weighted least-squares problems, each of which can be solved using standard techniques for linear systems of equations~\\cite{fornasier11lo,MohanF_Iterative,FornaPRW_Conjugate}.\n\nBeyond the nuclear norm, other proxies for rank exist.  The max-norm~\\cite{srebro04ma,srebro05ra} is a convex function that results in a similar optimization program to~\\eqref{eq:matrixlasso}, and is subject to similar heuristics as~\\eqref{eq:bmnonconvex} for storage reduction~\\cite{recht13pa}.  Alternatively, the logarithm of the determinant is a nonconvex, but smooth, proxy for rank when ${\\boldsymbol{{X}}}$ is positive semidefinite (and can be applied to general matrices by embedding them in a PSD matrix).  In practice, locally minimizing this function subject to convex constraints tends to produce low-rank solutions~\\cite{FazelHB_Logdet}.\n\nA greedy algorithm for low-rank recovery was presented in~\\cite{lee10ad}.  This algorithm alternates between selecting an estimate for the ${R}$-dimensional subspace in which ${{\\mathbf X}_0}$ lives, and projecting onto these subspaces; it is equipped with strong theoretical guarantees.  Another class of algorithms evolves the left and right singular vectors along the Grassman manifold~\\cite{dai11su,KeshaMO_Matrix}.  These algorithms, which are specialized for the matrix completion problem, are computationally efficient, and have equally strong theoretical performance guarantees.\n\n\n\n\\section{Matrix Recovery from Gaussian Observations}\n\\label{sec:gauss}\n\n\n\nThe theory of low-rank recovery is clean and elegant when the measurement operator ${\\mathcal A}(\\cdot)$ is a random projection.  Applications where this is a good model for the observations are limited, but looking at it as an abstract problem gives us real mathematical insight about why low-rank recovery works.\n\nThe discussion in this section will center on ``Gaussian'' ${\\mathcal A}(\\cdot)$, where the entries of each of the ${\\boldsymbol{{A}}}_m$ are independent and identically distributed normal random variables with zero mean and variance $L^{-1}$ --- this variance is chosen so that ${\\operatorname{E}}[\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2] = \\|{\\boldsymbol{{X}}}\\|_F^2$ for any fixed ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$.\n\n\\subsection{The matrix restricted isometry property}\n\\label{ssec:MRIP}\n\nWe first examine the fundamental question of whether we can distinguish different rank-${R}$ matrices viewed through the lens of the operator ${\\mathcal A}$.  One way to formalize this is asking whether ${\\mathcal A}$ preserves the distances between all such matrices; this is certainly true if there exists a $0\\leq\\delta<1$ such that\n\n", "index": 45, "text": "\\begin{equation}\n\t\\label{eq:matrix-rip}\n{\\ifthenelse{\\boolean{twoColVersion}} {{1-\\delta \t~\\leq~ \t\\frac{\\|{\\mathcal A}({\\boldsymbol{{X}}}_1) - {\\mathcal A}({\\boldsymbol{{X}}}_2)\\|_2^2}{\\|{\\boldsymbol{{X}}}_1-{\\boldsymbol{{X}}}_2\\|_F^2} \t~\\leq~ \t1+\\delta}} {{\t(1-\\delta)\\|{\\boldsymbol{{X}}}_1-{\\boldsymbol{{X}}}_2\\|_F^2 \t~\\leq~ \t\\|{\\mathcal A}({\\boldsymbol{{X}}}_1) - {\\mathcal A}({\\boldsymbol{{X}}}_2)\\|_2^2 \t~\\leq~ \t(1+\\delta)\\|{\\boldsymbol{{X}}}_1-{\\boldsymbol{{X}}}_2\\|_F^2}} }\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"{{(1-\\delta)\\|{\\boldsymbol{{X}}}_{1}-{\\boldsymbol{{X}}}_{2}\\|_{F}^{2}~{}\\leq~{%&#10;}\\|{\\mathcal{A}}({\\boldsymbol{{X}}}_{1})-{\\mathcal{A}}({\\boldsymbol{{X}}}_{2})%&#10;\\|_{2}^{2}~{}\\leq~{}(1+\\delta)\\|{\\boldsymbol{{X}}}_{1}-{\\boldsymbol{{X}}}_{2}%&#10;\\|_{F}^{2}}}\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mpadded width=\"+3.3pt\"><msubsup><mrow><mo>\u2225</mo><mrow><msub><mi>\ud835\udc7f</mi><mn>1</mn></msub><mo>-</mo><msub><mi>\ud835\udc7f</mi><mn>2</mn></msub></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mpadded></mrow><mo rspace=\"5.8pt\">\u2264</mo><mpadded width=\"+3.3pt\"><msubsup><mrow><mo>\u2225</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mpadded><mo rspace=\"5.8pt\">\u2264</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>+</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><msub><mi>\ud835\udc7f</mi><mn>1</mn></msub><mo>-</mo><msub><mi>\ud835\udc7f</mi><mn>2</mn></msub></mrow><mo>\u2225</mo></mrow><mi>F</mi><mn>2</mn></msubsup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis can be established through relatively simple probabilistic methods.  We sketch the argument below; the detailed proof in~\\cite{CandeP_Tight} smartly combines ideas from~\\cite{RechtFP_Guaranteed} and~\\cite{Versh_Introduction}.\n\n To begin, notice that it is enough to show that $(1-\\delta)\\leq\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2\\leq(1+\\delta)$ for all ${\\boldsymbol{{X}}}$ of rank $2{R}$ and unit Frobenius norm.  Then there are three basic steps for establishing \\eqref{eq:gaussianmeas}.\n\\begin{enumerate}\n\n\t\\item For any arbitrary fixed ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$ with $\\|{\\boldsymbol{{X}}}\\|_F^2=1$,\n\t\n", "itemtype": "equation", "pos": 34700, "prevtext": "\nfor all ${\\boldsymbol{{X}}}_1,{\\boldsymbol{{X}}}_2$ of rank ${R}$ or smaller.  This condition is known as the {\\em matrix restricted isometry property} (matrix-RIP), and is the matrix analog to the restricted isometry property from compressive sensing~\\cite{DavenDEK_Introduction}. The first immediate consequence is that all matrices of rank ${R}$ or less have unique images, since if ${\\mathcal A}({\\boldsymbol{{X}}}_1)={\\mathcal A}({\\boldsymbol{{X}}}_2)$ for ${\\boldsymbol{{X}}}_1\\not={\\boldsymbol{{X}}}_2$, then the lower bound would be violated.  Qualitatively, the upper and lower bounds tell us that two rank ${R}$ matrices are as distinguishable from their measurements as they would be if they were observed directly.  With \\eqref{eq:matrix-rip} established, we can use any number of techniques to recover a low-rank matrix from measurements through ${\\mathcal A}$; we discuss some specific guarantees below.\n\nA Gaussian ${\\mathcal A}$ will almost certainly have the  matrix restricted isometry property when the number of observations are commensurate with the number of degrees of freedom for an ${M}\\times{N}$ matrix with rank ${R}$.  Specifically, \\eqref{eq:matrix-rip} holds with high probability when\\footnote{We use this compact notation to mean that there is a constant so that ${L}\\geq\\mathrm{Const}\\cdot{R}({M}+{N})$.}\n\n", "index": 47, "text": "\\begin{equation}\n\t\\label{eq:gaussianmeas}\n\t{L} ~\\gtrsim~ {R}({N}+{M}).\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"{L}~{}\\gtrsim~{}{R}({N}+{M}).\" display=\"block\"><mrow><mrow><mpadded width=\"+3.3pt\"><mi>L</mi></mpadded><mo rspace=\"5.8pt\">\u2273</mo><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>+</mo><mi>M</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\tfor $t \\le \\frac12$, where $C$ and $c$ are reasonable constants that can be calculated explicitly (standard calculations yield $C\\leq 2$ and $c\\geq 1/8$).  Since the entries of ${\\mathcal A}({\\boldsymbol{{X}}})$ are independent Gaussian random variables, $\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2$ is a chi-squared random variable with ${L}$ degrees of freedom, and the inequality above follows from standard tail bounds \\cite{laurent00ad}.\n\t\n\tWe want \\eqref{eq:tailbound} to hold not just for a single matrix, but uniformly over the set of all unit-norm rank $2{R}$ matrices.  It is straightforward to get a uniform result over any finite set ${\\mathcal{{Q}}}$ of such matrices by using a union bound:\n\n", "itemtype": "equation", "pos": 35414, "prevtext": "\nThis can be established through relatively simple probabilistic methods.  We sketch the argument below; the detailed proof in~\\cite{CandeP_Tight} smartly combines ideas from~\\cite{RechtFP_Guaranteed} and~\\cite{Versh_Introduction}.\n\n To begin, notice that it is enough to show that $(1-\\delta)\\leq\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2\\leq(1+\\delta)$ for all ${\\boldsymbol{{X}}}$ of rank $2{R}$ and unit Frobenius norm.  Then there are three basic steps for establishing \\eqref{eq:gaussianmeas}.\n\\begin{enumerate}\n\n\t\\item For any arbitrary fixed ${M}\\times{N}$ matrix ${\\boldsymbol{{X}}}$ with $\\|{\\boldsymbol{{X}}}\\|_F^2=1$,\n\t\n", "index": 49, "text": "\\begin{equation}\n\t\t\\label{eq:tailbound}\n\t\t\\operatorname{P}\\left({\\left|\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 - 1\\right| > t}\\right)\n\t\t~\\leq~\n\t\tC{\\mathrm{e}}^{-c{L} t^2}\n\t\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E16.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{P}\\left({\\left|\\|{\\mathcal{A}}({\\boldsymbol{{X}}})\\|_{2}^{2}-1%&#10;\\right|&gt;t}\\right)~{}\\leq~{}C{\\mathrm{e}}^{-c{L}t^{2}}\" display=\"block\"><mrow><mrow><mo>P</mo><mo>\u2061</mo><mrow><mo>(</mo><mrow><mrow><mo>|</mo><mrow><msubsup><mrow><mo>\u2225</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>-</mo><mn>1</mn></mrow><mo>|</mo></mrow><mo>&gt;</mo><mi>t</mi></mrow><mo rspace=\"5.8pt\">)</mo></mrow></mrow><mo rspace=\"5.8pt\">\u2264</mo><mrow><mi>C</mi><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mi>c</mi><mo>\u2062</mo><mi>L</mi><mo>\u2062</mo><msup><mi>t</mi><mn>2</mn></msup></mrow></mrow></msup></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\tEven though the set of all unit-norm rank $2{R}$ matrices is infinite, the next step shows us that it is enough to consider a finite subset.\n\t\n\t\\item Let ${\\mathcal{{R}}}$ denote the set of ${M}\\times{N}$ matrices ${\\boldsymbol{{X}}}$ with ${\\text{rank}}({\\boldsymbol{{X}}})\\leq{R}$ and $\\|{\\boldsymbol{{X}}}\\|_F=1$.  Now let ${\\mathcal{{R}}}_\\epsilon$ be any finite $\\epsilon$-approximation to ${\\mathcal{{R}}}$ --- this means that ${\\mathcal{{R}}}_\\epsilon\\subset{\\mathcal{{R}}}$ and for every ${\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}$ there is an $\\bar{{\\boldsymbol{{X}}}}$ in ${\\mathcal{{R}}}_\\epsilon$ that is within $\\epsilon$: $\\|{\\boldsymbol{{X}}}-\\bar{{\\boldsymbol{{X}}}}\\|_F\\leq\\epsilon$.  Then a short argument shows that for $\\epsilon = \\delta/(4\\sqrt{2})$,\n   \n", "itemtype": "equation", "pos": 36307, "prevtext": "\n\tfor $t \\le \\frac12$, where $C$ and $c$ are reasonable constants that can be calculated explicitly (standard calculations yield $C\\leq 2$ and $c\\geq 1/8$).  Since the entries of ${\\mathcal A}({\\boldsymbol{{X}}})$ are independent Gaussian random variables, $\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2$ is a chi-squared random variable with ${L}$ degrees of freedom, and the inequality above follows from standard tail bounds \\cite{laurent00ad}.\n\t\n\tWe want \\eqref{eq:tailbound} to hold not just for a single matrix, but uniformly over the set of all unit-norm rank $2{R}$ matrices.  It is straightforward to get a uniform result over any finite set ${\\mathcal{{Q}}}$ of such matrices by using a union bound:\n\n", "index": 51, "text": "\\[\n\t\t\\operatorname{P}\\left({\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{Q}}}}\\left|\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 - 1\\right| > t}\\right)\n\t\t~\\leq~\n\t\t|{\\mathcal{{Q}}}|\\cdot C\\,{\\mathrm{e}}^{-c{L} t^2}.\n\t\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{P}\\left({\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{Q}}}}\\left|\\|{%&#10;\\mathcal{A}}({\\boldsymbol{{X}}})\\|_{2}^{2}-1\\right|&gt;t}\\right)~{}\\leq~{}|{%&#10;\\mathcal{{Q}}}|\\cdot C\\,{\\mathrm{e}}^{-c{L}t^{2}}.\" display=\"block\"><mrow><mrow><mrow><mo>P</mo><mo>\u2061</mo><mrow><mo>(</mo><mrow><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mi>\ud835\udc7f</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcac</mi></mrow></munder><mo>\u2061</mo><mrow><mo>|</mo><mrow><msubsup><mrow><mo>\u2225</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>-</mo><mn>1</mn></mrow><mo>|</mo></mrow></mrow><mo>&gt;</mo><mi>t</mi></mrow><mo rspace=\"5.8pt\">)</mo></mrow></mrow><mo rspace=\"5.8pt\">\u2264</mo><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcac</mi><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mpadded width=\"+1.7pt\"><mi>C</mi></mpadded></mrow><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mi>c</mi><mo>\u2062</mo><mi>L</mi><mo>\u2062</mo><msup><mi>t</mi><mn>2</mn></msup></mrow></mrow></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n    implies that \n   \n", "itemtype": "equation", "pos": 37287, "prevtext": "\n\tEven though the set of all unit-norm rank $2{R}$ matrices is infinite, the next step shows us that it is enough to consider a finite subset.\n\t\n\t\\item Let ${\\mathcal{{R}}}$ denote the set of ${M}\\times{N}$ matrices ${\\boldsymbol{{X}}}$ with ${\\text{rank}}({\\boldsymbol{{X}}})\\leq{R}$ and $\\|{\\boldsymbol{{X}}}\\|_F=1$.  Now let ${\\mathcal{{R}}}_\\epsilon$ be any finite $\\epsilon$-approximation to ${\\mathcal{{R}}}$ --- this means that ${\\mathcal{{R}}}_\\epsilon\\subset{\\mathcal{{R}}}$ and for every ${\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}$ there is an $\\bar{{\\boldsymbol{{X}}}}$ in ${\\mathcal{{R}}}_\\epsilon$ that is within $\\epsilon$: $\\|{\\boldsymbol{{X}}}-\\bar{{\\boldsymbol{{X}}}}\\|_F\\leq\\epsilon$.  Then a short argument shows that for $\\epsilon = \\delta/(4\\sqrt{2})$,\n   \n", "index": 53, "text": "\\[\n\t\t\\max_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}_\\epsilon}\\left|\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 - 1\\right| \\leq \\delta/2\n\t\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\max_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}_{\\epsilon}}\\left|\\|{\\mathcal{A}}({%&#10;\\boldsymbol{{X}}})\\|_{2}^{2}-1\\right|\\leq\\delta/2\" display=\"block\"><mrow><mrow><munder><mi>max</mi><mrow><mi>\ud835\udc7f</mi><mo>\u2208</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mi>\u03f5</mi></msub></mrow></munder><mo>\u2061</mo><mrow><mo>|</mo><mrow><msubsup><mrow><mo>\u2225</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>-</mo><mn>1</mn></mrow><mo>|</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>\u03b4</mi><mo>/</mo><mn>2</mn></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\tThus the supremum over the infinite set on the right can be replaced with the maximum over the finite set on the left.  Using the result from step 1, we now have\n\n", "itemtype": "equation", "pos": 37442, "prevtext": "\n    implies that \n   \n", "index": 55, "text": "\\[\n        \\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}}\\left|\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 - 1\\right| \\leq \\delta.\n\t\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}}\\left|\\|{\\mathcal{A}}({\\boldsymbol{%&#10;{X}}})\\|_{2}^{2}-1\\right|\\leq\\delta.\" display=\"block\"><mrow><mrow><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mi>\ud835\udc7f</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi></mrow></munder><mo>\u2061</mo><mrow><mo>|</mo><mrow><msubsup><mrow><mo>\u2225</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>-</mo><mn>1</mn></mrow><mo>|</mo></mrow></mrow><mo>\u2264</mo><mi>\u03b4</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\t\n\t\\item The size of ${\\mathcal{{R}}}_\\epsilon$ can be estimated as a function of $\\epsilon$.  The bound in \\cite{CandeP_Tight} reads\n\n", "itemtype": "equation", "pos": 37735, "prevtext": "\n\tThus the supremum over the infinite set on the right can be replaced with the maximum over the finite set on the left.  Using the result from step 1, we now have\n\n", "index": 57, "text": "\\[\n\t\t\\operatorname{P}\\left({\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}}\\left|\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2 - 1\\right| > \\delta}\\right)\n\t\t~\\leq~|{\\mathcal{{R}}}_\\epsilon|\\cdot C\\,{\\mathrm{e}}^{-cL\\delta^2/4}.\n\t\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{P}\\left({\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{R}}}}\\left|\\|{%&#10;\\mathcal{A}}({\\boldsymbol{{X}}})\\|_{2}^{2}-1\\right|&gt;\\delta}\\right)~{}\\leq~{}|{%&#10;\\mathcal{{R}}}_{\\epsilon}|\\cdot C\\,{\\mathrm{e}}^{-cL\\delta^{2}/4}.\" display=\"block\"><mrow><mrow><mrow><mo>P</mo><mo>\u2061</mo><mrow><mo>(</mo><mrow><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mi>\ud835\udc7f</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi></mrow></munder><mo>\u2061</mo><mrow><mo>|</mo><mrow><msubsup><mrow><mo>\u2225</mo><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup><mo>-</mo><mn>1</mn></mrow><mo>|</mo></mrow></mrow><mo>&gt;</mo><mi>\u03b4</mi></mrow><mo rspace=\"5.8pt\">)</mo></mrow></mrow><mo rspace=\"5.8pt\">\u2264</mo><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mi>\u03f5</mi></msub><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mpadded width=\"+1.7pt\"><mi>C</mi></mpadded></mrow><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mrow><mi>c</mi><mo>\u2062</mo><mi>L</mi><mo>\u2062</mo><msup><mi>\u03b4</mi><mn>2</mn></msup></mrow><mo>/</mo><mn>4</mn></mrow></mrow></msup></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\tCombining this with the choice of $\\epsilon$ above and plugging it into the result of step 2, tells us that \\eqref{eq:matrix-rip} will hold with probability at least $1-C'{\\mathrm{e}}^{-c'{L}}$ when ${L}\\gtrsim \\delta^{-2}{R}({M}+{N})$.\n\\end{enumerate}\n\nBeyond basic identifiability, the matrix-RIP is also sufficient for concrete algorithms to produce accurate estimates of low-rank matrices.  For example, \\cite{oymak11si,cai13co} refine an argument in \\cite{RechtFP_Guaranteed} to show that nuclear norm minimization will recover rank ${R}$ ${\\boldsymbol{{X}}}_0$ when $\\delta\\leq 0.3$ in \\eqref{eq:matrix-rip}.  A similar result holds for iterative hard thresholding techniques \\cite{jain10gu} and their variants \\cite{tanner13no}: when $\\delta\\leq 1/3$, we are guaranteed to recover rank-${R}$ ${\\boldsymbol{{X}}}_0$ with linear convergence.  The best known guarantees for alternating minimization are weaker: \\cite{jain13lo} states that $\\delta\\leq \\mathrm{Const}/{R}$ is sufficient for linear convergence, which is achieved for Gaussian ${\\mathcal A}$ when ${L}\\gtrsim{R}^3({M}+{N})$.\n\nThe uniformity of the matrix-RIP, that it holds for all pairs of rank ${R}$ matrices simultaneously, results in stability guarantees for each of these algorithms when the measurements are made in the presence of noise, or the target matrix is only approximately low rank.\n\n\n\\subsection{Convex geometry and Gaussian widths}\n\nOne strength of the analysis described above (based on the matrix-RIP) is that it is quite general and can help in analyzing a variety of different algorithms.  However, the resulting bounds are often quite loose.  In the specific case of nuclear norm minimization, however, there are very precise conditions under which it will succeed (or fail) with high probability with a Gaussian measurement ensemble. These results are of a slightly different nature than those based on the matrix-RIP in the previous section.  They are weaker, in that they only speak to the recovery of a single matrix; the target ${\\boldsymbol{{X}}}_0$ is fixed, the ensemble $\\{{\\boldsymbol{{A}}}_\\ell~:~\\ell=1\\,\\ldots,{L}\\}$ is generated independently of ${\\boldsymbol{{X}}}_0$, and the probability with which ${\\boldsymbol{{X}}}_0$ is recovered is computed. But they are also stronger in the sense that they are much more precise in telling us when recovery will succeed or fail. In this section, we will focus on  results outlining the conditions for recovering ${\\boldsymbol{{X}}}_0$ perfectly in the absence of noise.  Given ${\\boldsymbol{{y}}}={\\mathcal A}({\\boldsymbol{{X}}}_0)$, we solve the equality constrained problem \\eqref{eq:nneq}.\n\n\n\n\n\nRecent works \\cite{chandrasekaran12co,oymak11ti,amelunxen14li} analyze the performance of this program using very intuitive geometrical principles.  The target matrix ${\\boldsymbol{{X}}}_0$ is a member of two different convex sets; it is in the nuclear norm ball of radius $\\|{\\boldsymbol{{X}}}_0\\|_*$,\n\n", "itemtype": "equation", "pos": 38093, "prevtext": "\n\t\n\t\\item The size of ${\\mathcal{{R}}}_\\epsilon$ can be estimated as a function of $\\epsilon$.  The bound in \\cite{CandeP_Tight} reads\n\n", "index": 59, "text": "\\[\n\t\t|{\\mathcal{{R}}}_\\epsilon| \\leq \\left(\\frac{9}{\\epsilon}\\right)^{{R}({M}+{N}+1)} = ~{\\mathrm{e}}^{{R}({M}+{N}+1)\\log(9/\\epsilon)}.\n\t\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"|{\\mathcal{{R}}}_{\\epsilon}|\\leq\\left(\\frac{9}{\\epsilon}\\right)^{{R}({M}+{N}+1%&#10;)}=~{}{\\mathrm{e}}^{{R}({M}+{N}+1)\\log(9/\\epsilon)}.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\u211b</mi><mi>\u03f5</mi></msub><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><msup><mrow><mo>(</mo><mfrac><mn>9</mn><mi>\u03f5</mi></mfrac><mo>)</mo></mrow><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>M</mi><mo>+</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></msup><mo rspace=\"5.8pt\">=</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>M</mi><mo>+</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>9</mn><mo>/</mo><mi>\u03f5</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nand it is in the affine space consisting of all ${M}\\times{N}$ matrices that have the same measurements,\n\n", "itemtype": "equation", "pos": 41181, "prevtext": "\n\tCombining this with the choice of $\\epsilon$ above and plugging it into the result of step 2, tells us that \\eqref{eq:matrix-rip} will hold with probability at least $1-C'{\\mathrm{e}}^{-c'{L}}$ when ${L}\\gtrsim \\delta^{-2}{R}({M}+{N})$.\n\\end{enumerate}\n\nBeyond basic identifiability, the matrix-RIP is also sufficient for concrete algorithms to produce accurate estimates of low-rank matrices.  For example, \\cite{oymak11si,cai13co} refine an argument in \\cite{RechtFP_Guaranteed} to show that nuclear norm minimization will recover rank ${R}$ ${\\boldsymbol{{X}}}_0$ when $\\delta\\leq 0.3$ in \\eqref{eq:matrix-rip}.  A similar result holds for iterative hard thresholding techniques \\cite{jain10gu} and their variants \\cite{tanner13no}: when $\\delta\\leq 1/3$, we are guaranteed to recover rank-${R}$ ${\\boldsymbol{{X}}}_0$ with linear convergence.  The best known guarantees for alternating minimization are weaker: \\cite{jain13lo} states that $\\delta\\leq \\mathrm{Const}/{R}$ is sufficient for linear convergence, which is achieved for Gaussian ${\\mathcal A}$ when ${L}\\gtrsim{R}^3({M}+{N})$.\n\nThe uniformity of the matrix-RIP, that it holds for all pairs of rank ${R}$ matrices simultaneously, results in stability guarantees for each of these algorithms when the measurements are made in the presence of noise, or the target matrix is only approximately low rank.\n\n\n\\subsection{Convex geometry and Gaussian widths}\n\nOne strength of the analysis described above (based on the matrix-RIP) is that it is quite general and can help in analyzing a variety of different algorithms.  However, the resulting bounds are often quite loose.  In the specific case of nuclear norm minimization, however, there are very precise conditions under which it will succeed (or fail) with high probability with a Gaussian measurement ensemble. These results are of a slightly different nature than those based on the matrix-RIP in the previous section.  They are weaker, in that they only speak to the recovery of a single matrix; the target ${\\boldsymbol{{X}}}_0$ is fixed, the ensemble $\\{{\\boldsymbol{{A}}}_\\ell~:~\\ell=1\\,\\ldots,{L}\\}$ is generated independently of ${\\boldsymbol{{X}}}_0$, and the probability with which ${\\boldsymbol{{X}}}_0$ is recovered is computed. But they are also stronger in the sense that they are much more precise in telling us when recovery will succeed or fail. In this section, we will focus on  results outlining the conditions for recovering ${\\boldsymbol{{X}}}_0$ perfectly in the absence of noise.  Given ${\\boldsymbol{{y}}}={\\mathcal A}({\\boldsymbol{{X}}}_0)$, we solve the equality constrained problem \\eqref{eq:nneq}.\n\n\n\n\n\nRecent works \\cite{chandrasekaran12co,oymak11ti,amelunxen14li} analyze the performance of this program using very intuitive geometrical principles.  The target matrix ${\\boldsymbol{{X}}}_0$ is a member of two different convex sets; it is in the nuclear norm ball of radius $\\|{\\boldsymbol{{X}}}_0\\|_*$,\n\n", "index": 61, "text": "\\begin{equation}\n\t\\label{eq:normball}\n\t{\\boldsymbol{{X}}}_0 \\in {\\mathcal{{B}}} := \\{{\\boldsymbol{{X}}}~:~\\|{\\boldsymbol{{X}}}\\|_*\\leq\\|{\\boldsymbol{{X}}}_0\\|_*\\},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E17.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}_{0}\\in{\\mathcal{{B}}}:=\\{{\\boldsymbol{{X}}}~{}:~{}\\|{%&#10;\\boldsymbol{{X}}}\\|_{*}\\leq\\|{\\boldsymbol{{X}}}_{0}\\|_{*}\\},\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mo>:=</mo><mrow><mo stretchy=\"false\">{</mo><mpadded width=\"+3.3pt\"><mi>\ud835\udc7f</mi></mpadded><mo rspace=\"5.8pt\">:</mo><mrow><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub><mo>\u2264</mo><msub><mrow><mo>\u2225</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nBy definition, ${\\boldsymbol{{X}}}_0$ is the unique solution to \\eqref{eq:nneq} if and only if it is the only matrix in the intersection of ${\\mathcal{{B}}}$ and ${\\mathcal{{S}}}$; this is illustrated in Figure~\\ref{fig:ballplane}(a).  Generating ${\\mathcal A}$ with a Gaussian distribution is the same as choosing the orientation of ${\\mathcal{{S}}}$ uniformly at random.  The local geometry of the tip of ${\\mathcal{{B}}}$ is determined by the rank of ${\\boldsymbol{{X}}}_0$, smaller ranks make this point more singular, and hence decrease the probability of an intersection.  The dimension of the set ${\\mathcal{{S}}}$ is ${M}{N}-{L}$, the same as the null space of ${\\mathcal A}$; as ${L}$ increases, ${\\mathcal{{S}}}$ gets smaller, and the probability of an intersection decreases.\n\nWe can make both of these statements precise.  The collection of directions that lead into the ball (i.e., decrease the nuclear norm) ${\\mathcal{{B}}}$ from the point ${\\boldsymbol{{X}}}_0$ is called the {\\em tangent cone} of ${\\mathcal{{B}}}$ at ${\\boldsymbol{{X}}}_0$:\n\n", "itemtype": "equation", "pos": 41465, "prevtext": "\nand it is in the affine space consisting of all ${M}\\times{N}$ matrices that have the same measurements,\n\n", "index": 63, "text": "\\begin{equation}\n\t\\label{eq:affinespace}\n\t{\\boldsymbol{{X}}}_0 \\in {\\mathcal{{S}}} := \\{{\\boldsymbol{{X}}}~:~{\\mathcal A}({\\boldsymbol{{X}}})={\\boldsymbol{{y}}}\\}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E18.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}_{0}\\in{\\mathcal{{S}}}:=\\{{\\boldsymbol{{X}}}~{}:~{}{\\mathcal%&#10;{A}}({\\boldsymbol{{X}}})={\\boldsymbol{{y}}}\\}.\" display=\"block\"><mrow><mrow><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcae</mi><mo>:=</mo><mrow><mo stretchy=\"false\">{</mo><mpadded width=\"+3.3pt\"><mi>\ud835\udc7f</mi></mpadded><mo rspace=\"5.8pt\">:</mo><mrow><mrow><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc7f</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi>\ud835\udc9a</mi></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nAsking if there is a better feasible point in \\eqref{eq:nneq} than ${\\boldsymbol{{X}}}_0$ is exactly the same as asking if the subspace ${\\mathcal{{S}}}-{\\boldsymbol{{X}}}_0 = {\\operatorname{Null}}({\\mathcal A})$ (the affine set ${\\mathcal{{S}}}$ shifted to the origin) intersects the cone ${\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0)$ at any place other than the origin.\n\n\n\n\\begin{figure}\n\t\\centering\n{\\ifthenelse{\\boolean{twoColVersion}} {{ \t\\begin{tabular}{cc} \t\t\\includegraphics[scale=0.3]{convgeom1} & \t\t\\includegraphics[trim=50 110 100 80,clip,scale=0.6]{convgeom2} \\\\ \t\t(a) & (b) \t\\end{tabular}}} {{\t\\begin{tabular}{ccc} \t\t\\includegraphics[scale=0.3]{convgeom1} & \\hspace{1in} & \t\t\\includegraphics[trim=50 110 100 80,clip,scale=.6]{convgeom2} \\\\ \t\t(a) & &  (b) \t\\end{tabular}}} }\n\t\\caption{\\small\\sl (a) The solution to the optimization program \\eqref{eq:nneq} is ${\\boldsymbol{{X}}}_0$ when the norm ball ${\\mathcal{{B}}}$ defined in \\eqref{eq:normball} and the affine space in \\eqref{eq:affinespace} intersect at only one point.  (b) The tangent cone ${\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0)$ from \\eqref{eq:tangentcone} along with a representative element ${\\boldsymbol{{H}}}\\in{\\mathcal{{T}}}_{\\mathcal{{B}}}({\\boldsymbol{{X}}}_0)$. }\n\t\\label{fig:ballplane}\n\\end{figure}\n\n\nWhen does a randomly chosen subspace intersect a cone only at the origin?  A clean answer is given in \\cite{chandrasekaran12co}, which builds on the classic work \\cite{gordon88mi}. This answer depends on the notion of the {\\em Gaussian width} of a set ${\\mathcal{{C}}}$, which is defined as\n", "itemtype": "equation", "pos": 42703, "prevtext": "\nBy definition, ${\\boldsymbol{{X}}}_0$ is the unique solution to \\eqref{eq:nneq} if and only if it is the only matrix in the intersection of ${\\mathcal{{B}}}$ and ${\\mathcal{{S}}}$; this is illustrated in Figure~\\ref{fig:ballplane}(a).  Generating ${\\mathcal A}$ with a Gaussian distribution is the same as choosing the orientation of ${\\mathcal{{S}}}$ uniformly at random.  The local geometry of the tip of ${\\mathcal{{B}}}$ is determined by the rank of ${\\boldsymbol{{X}}}_0$, smaller ranks make this point more singular, and hence decrease the probability of an intersection.  The dimension of the set ${\\mathcal{{S}}}$ is ${M}{N}-{L}$, the same as the null space of ${\\mathcal A}$; as ${L}$ increases, ${\\mathcal{{S}}}$ gets smaller, and the probability of an intersection decreases.\n\nWe can make both of these statements precise.  The collection of directions that lead into the ball (i.e., decrease the nuclear norm) ${\\mathcal{{B}}}$ from the point ${\\boldsymbol{{X}}}_0$ is called the {\\em tangent cone} of ${\\mathcal{{B}}}$ at ${\\boldsymbol{{X}}}_0$:\n\n", "index": 65, "text": "\\begin{equation}\n\t\\label{eq:tangentcone}\n\t{\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0) = \\{{\\boldsymbol{{H}}}~:~\\|{\\boldsymbol{{X}}}_0+\\epsilon{\\boldsymbol{{H}}}\\|_*\\leq\\|{\\boldsymbol{{X}}}_0\\|_*~~\\text{for some $\\epsilon>0$}\\}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E19.m1\" class=\"ltx_Math\" alttext=\"{\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_{0})=\\{{\\boldsymbol{{H}}}%&#10;~{}:~{}\\|{\\boldsymbol{{X}}}_{0}+\\epsilon{\\boldsymbol{{H}}}\\|_{*}\\leq\\|{%&#10;\\boldsymbol{{X}}}_{0}\\|_{*}~{}~{}\\text{for some $\\epsilon&gt;0$}\\}.\" display=\"block\"><mrow><mrow><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcaf</mi><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mpadded width=\"+3.3pt\"><mi>\ud835\udc6f</mi></mpadded><mo rspace=\"5.8pt\">:</mo><mrow><msub><mrow><mo>\u2225</mo><mrow><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>+</mo><mrow><mi>\u03f5</mi><mo>\u2062</mo><mi>\ud835\udc6f</mi></mrow></mrow><mo>\u2225</mo></mrow><mo>*</mo></msub><mo>\u2264</mo><mrow><mpadded width=\"+6.6pt\"><msub><mrow><mo>\u2225</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>\u2225</mo></mrow><mo>*</mo></msub></mpadded><mo>\u2062</mo><mrow><mtext>for some\u00a0</mtext><mrow><mi>\u03f5</mi><mo>&gt;</mo><mn>0</mn></mrow></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere ${\\boldsymbol{{G}}}$ is a matrix whose entries are independent zero-mean Gaussian random variables with unit variance, and the expectation is taken with respect to ${\\boldsymbol{{G}}}$. The quantity $w({\\mathcal{{C}}})$ can be interpreted as the amount we expect a set ${\\mathcal{{C}}}$ to align with a randomly drawn vector. It is shown in~\\cite{chandrasekaran12co} that a randomly chosen subspace will intersect a cone ${\\mathcal{{C}}}$ only at the origin with high probability if the codimension of the subspace is at least as large as the square of the Gaussian width:\n", "itemtype": "equation", "pos": 44560, "prevtext": "\nAsking if there is a better feasible point in \\eqref{eq:nneq} than ${\\boldsymbol{{X}}}_0$ is exactly the same as asking if the subspace ${\\mathcal{{S}}}-{\\boldsymbol{{X}}}_0 = {\\operatorname{Null}}({\\mathcal A})$ (the affine set ${\\mathcal{{S}}}$ shifted to the origin) intersects the cone ${\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0)$ at any place other than the origin.\n\n\n\n\\begin{figure}\n\t\\centering\n{\\ifthenelse{\\boolean{twoColVersion}} {{ \t\\begin{tabular}{cc} \t\t\\includegraphics[scale=0.3]{convgeom1} & \t\t\\includegraphics[trim=50 110 100 80,clip,scale=0.6]{convgeom2} \\\\ \t\t(a) & (b) \t\\end{tabular}}} {{\t\\begin{tabular}{ccc} \t\t\\includegraphics[scale=0.3]{convgeom1} & \\hspace{1in} & \t\t\\includegraphics[trim=50 110 100 80,clip,scale=.6]{convgeom2} \\\\ \t\t(a) & &  (b) \t\\end{tabular}}} }\n\t\\caption{\\small\\sl (a) The solution to the optimization program \\eqref{eq:nneq} is ${\\boldsymbol{{X}}}_0$ when the norm ball ${\\mathcal{{B}}}$ defined in \\eqref{eq:normball} and the affine space in \\eqref{eq:affinespace} intersect at only one point.  (b) The tangent cone ${\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0)$ from \\eqref{eq:tangentcone} along with a representative element ${\\boldsymbol{{H}}}\\in{\\mathcal{{T}}}_{\\mathcal{{B}}}({\\boldsymbol{{X}}}_0)$. }\n\t\\label{fig:ballplane}\n\\end{figure}\n\n\nWhen does a randomly chosen subspace intersect a cone only at the origin?  A clean answer is given in \\cite{chandrasekaran12co}, which builds on the classic work \\cite{gordon88mi}. This answer depends on the notion of the {\\em Gaussian width} of a set ${\\mathcal{{C}}}$, which is defined as\n", "index": 67, "text": "\n\\[\nw({\\mathcal{{C}}}) = {\\operatorname{E}}\\left[\\sup_{{\\boldsymbol{{X}}}\\in{\\mathcal{{C}}},\\|{\\boldsymbol{{X}}}\\|_F=1} \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{G}}}}\\right>\\right],\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"w({\\mathcal{{C}}})={\\operatorname{E}}\\left[\\sup_{{\\boldsymbol{{X}}}\\in{%&#10;\\mathcal{{C}}},\\|{\\boldsymbol{{X}}}\\|_{F}=1}\\left&lt;{{\\boldsymbol{{X}}},{%&#10;\\boldsymbol{{G}}}}\\right&gt;\\right],\" display=\"block\"><mrow><mrow><mrow><mi>w</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>E</mo><mo>\u2061</mo><mrow><mo>[</mo><mrow><munder><mo movablelimits=\"false\">sup</mo><mrow><mrow><mi>\ud835\udc7f</mi><mo>\u2208</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi></mrow><mo>,</mo><mrow><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mi>F</mi></msub><mo>=</mo><mn>1</mn></mrow></mrow></munder><mo>\u2061</mo><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><mi>\ud835\udc6e</mi><mo>\u27e9</mo></mrow></mrow><mo>]</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nIt is clear that for subsets of ${M}\\times{N}$ matrices,  $\\omega({\\mathcal{{C}}})\\leq\\sqrt{{M}{N}}$, and if ${\\mathcal{{C}}}$ is a $D$ dimensional subspace, a quick calculation shows that $w({\\mathcal{{C}}})=\\sqrt{D}$.  The codimension of ${\\operatorname{Null}}({\\mathcal A})$ is always ${L}$, so measuring the Gaussian width of the tangent cone gives an immediate sufficient condition on the number of measurements needed for accurate recovery.  The bound on the Gaussian width $w({\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0))^2 ~\\leq~ 3{R}({M}+{N}-{R})$ gives us the sharp sufficient condition of\n\n", "itemtype": "equation", "pos": 45322, "prevtext": "\nwhere ${\\boldsymbol{{G}}}$ is a matrix whose entries are independent zero-mean Gaussian random variables with unit variance, and the expectation is taken with respect to ${\\boldsymbol{{G}}}$. The quantity $w({\\mathcal{{C}}})$ can be interpreted as the amount we expect a set ${\\mathcal{{C}}}$ to align with a randomly drawn vector. It is shown in~\\cite{chandrasekaran12co} that a randomly chosen subspace will intersect a cone ${\\mathcal{{C}}}$ only at the origin with high probability if the codimension of the subspace is at least as large as the square of the Gaussian width:\n", "index": 69, "text": "\n\\[\n\t\\operatorname{codim}({\\operatorname{Null}}({\\mathcal A})) ~\\geq~ w({\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0))^2 + 1.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{codim}({\\operatorname{Null}}({\\mathcal{A}}))~{}\\geq~{}w({%&#10;\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_{0}))^{2}+1.\" display=\"block\"><mrow><mrow><mrow><mo>codim</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo>Null</mo><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"5.8pt\">\u2265</mo><mrow><mrow><mi>w</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcaf</mi><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mrow><mo>+</mo><mn>1</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\nThe relation in \\eqref{eq:cprw-tight} is very close to being necessary as well.  In \\cite{oymak11ti,amelunxen14li}, it is shown that if the number of observations is not too far below $w({\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0))^2$, then the probability that \\eqref{eq:nneq} fails to recover ${\\boldsymbol{{X}}}_0$ is very close to $1$.  These papers contain an impressive suite of numerical experiments showing that the success or failure of equality-constrained nuclear norm minimization \\eqref{eq:nneq} can be predicted accurately from the parameters ${M},{N},{R}$.\n\nIt should be mentioned that the analysis in \\cite{chandrasekaran12co} and \\cite{amelunxen14li} applies to many different types of structured recovery problems based on convex optimization; the low-rank recovery results discussed above are an important special case.\n\n\n\n\n\n\n\\section{Matrix Completion}\n\\label{sec:mc}\n\n\nAs we have just seen, the theory of low-rank matrix recovery is particularly elegant in the case where the measurement operator ${\\mathcal A}(\\cdot)$ is a (Gaussian) random projection operator.  While this provides some insight into the kind of behavior we can hope for in many applications, it is also far from representative of the type of observations we often encounter in practice.  In particular, in many settings of interest the ${\\boldsymbol{{A}}}_i$ are highly structured --- in the case of matrix {\\em completion}, the ${\\boldsymbol{{A}}}_i$ will have only a single nonzero value of 1 corresponding to the row and column of the observed element.  An equivalent way to think about this type of measurement is that we only observe the entries of ${\\boldsymbol{{X}}}_0$ on a subset $\\Omega$ of the complete set of entries.  This kind of measurement model arises in a variety of practical  settings.  For example, we might have a large number of questions we would like to potentially ask a number of users (as in a large-scale survey or recommendation system) but in practice we might only expect to receive responses to a few of these questions from any given user.  Similarly, in many large-scale graphs (such as graphs representing the strength of social connections or the distances between sensors or other items) we might only be able to measure/observe the strength of a few connections in a graph.\n\nEven if the elements of $\\Omega$ are chosen at random, this scenario has some significant differences from the case where the ${\\boldsymbol{{A}}}_i$ are Gaussian. It is clear that we cannot expect the theory developed using Gaussian widths to be of much use, since our observations are not Gaussian, but there is a more fundamental problem that arises in the case of matrix completion.\n\n\\subsection{Which matrices can be completed?}\nIn particular, the most immediate challenge we encounter when developing a theory of matrix completion is that it is no longer possible to obtain the kind of uniform guarantees that apply to {\\em all} low-rank matrices described in Section~\\ref{sec:gauss}.  To see why, consider a matrix with rank one, but where one (or both) singular vectors are {\\em sparse}, meaning that their energy is concentrated on just a few entries.  When this occurs, as illustrated in Figure~\\ref{fig:sparsesvs}, the resulting matrix will also have its energy mostly concentrated on just a few entries, in which case most entries give us very little information and the recovery problem is highly ill-posed unless nearly all the entries are observed.  (Another way to see this is to realize that if only a few entries of such a matrix are observed, the matrix is very likely to live in the nullspace of the measurement operator ${\\mathcal A}$.)   More generally, if any particular column (or row) is approximately orthogonal to the span of the remaining columns (or rows), then it will be impossible to estimate without essentially observing the entire column (or row).\n\n\\begin{figure}\n\\centering\n\\resizebox{3.5in}{!}{\\parbox{.5\\linewidth}{\n\n", "itemtype": "equation", "pos": 46072, "prevtext": "\nIt is clear that for subsets of ${M}\\times{N}$ matrices,  $\\omega({\\mathcal{{C}}})\\leq\\sqrt{{M}{N}}$, and if ${\\mathcal{{C}}}$ is a $D$ dimensional subspace, a quick calculation shows that $w({\\mathcal{{C}}})=\\sqrt{D}$.  The codimension of ${\\operatorname{Null}}({\\mathcal A})$ is always ${L}$, so measuring the Gaussian width of the tangent cone gives an immediate sufficient condition on the number of measurements needed for accurate recovery.  The bound on the Gaussian width $w({\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0))^2 ~\\leq~ 3{R}({M}+{N}-{R})$ gives us the sharp sufficient condition of\n\n", "index": 71, "text": "\\begin{equation}\n\t\\label{eq:cprw-tight}\n\t{L} \\geq 3R({M}+{N}-{R})+1.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E20.m1\" class=\"ltx_Math\" alttext=\"{L}\\geq 3R({M}+{N}-{R})+1.\" display=\"block\"><mrow><mrow><mi>L</mi><mo>\u2265</mo><mrow><mrow><mn>3</mn><mo>\u2062</mo><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>M</mi><mo>+</mo><mi>N</mi></mrow><mo>-</mo><mi>R</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mn>1</mn></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "}}\n    \\caption{\\small\\sl  A low-rank matrix with sparse singular vectors, resulting in a matrix which mostly consists of zeros.}\n\t\\label{fig:sparsesvs}\n\\end{figure}\n\nThus, there exist low-rank matrices which, in the absence of any prior information, would clearly be impossible to recover from the observation of only a few entries.  In order to avoid such cases, we need to ensure that each entry of the matrix tells us something about the other rows/columns.  Fortunately, this is very likely to be the case in most practical applications of interest.  For example, the entire premise of the collaborative filtering approach to recommendation systems is that knowing how a particular user feels about a particular item provides information about other users and items.  This notion can be mathematically quantified in various different ways, but the bulk of the literature on matrix completion builds on the notion of {\\em coherence} as introduced in~\\cite{CandeR_Exact}.  Given an $R$-dimensional subspace $U$ of ${ \\mathbb{R} }^N$, the coherence is defined as\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nThe relation in \\eqref{eq:cprw-tight} is very close to being necessary as well.  In \\cite{oymak11ti,amelunxen14li}, it is shown that if the number of observations is not too far below $w({\\mathcal{{T}}}_{{\\mathcal{{B}}}}({\\boldsymbol{{X}}}_0))^2$, then the probability that \\eqref{eq:nneq} fails to recover ${\\boldsymbol{{X}}}_0$ is very close to $1$.  These papers contain an impressive suite of numerical experiments showing that the success or failure of equality-constrained nuclear norm minimization \\eqref{eq:nneq} can be predicted accurately from the parameters ${M},{N},{R}$.\n\nIt should be mentioned that the analysis in \\cite{chandrasekaran12co} and \\cite{amelunxen14li} applies to many different types of structured recovery problems based on convex optimization; the low-rank recovery results discussed above are an important special case.\n\n\n\n\n\n\n\\section{Matrix Completion}\n\\label{sec:mc}\n\n\nAs we have just seen, the theory of low-rank matrix recovery is particularly elegant in the case where the measurement operator ${\\mathcal A}(\\cdot)$ is a (Gaussian) random projection operator.  While this provides some insight into the kind of behavior we can hope for in many applications, it is also far from representative of the type of observations we often encounter in practice.  In particular, in many settings of interest the ${\\boldsymbol{{A}}}_i$ are highly structured --- in the case of matrix {\\em completion}, the ${\\boldsymbol{{A}}}_i$ will have only a single nonzero value of 1 corresponding to the row and column of the observed element.  An equivalent way to think about this type of measurement is that we only observe the entries of ${\\boldsymbol{{X}}}_0$ on a subset $\\Omega$ of the complete set of entries.  This kind of measurement model arises in a variety of practical  settings.  For example, we might have a large number of questions we would like to potentially ask a number of users (as in a large-scale survey or recommendation system) but in practice we might only expect to receive responses to a few of these questions from any given user.  Similarly, in many large-scale graphs (such as graphs representing the strength of social connections or the distances between sensors or other items) we might only be able to measure/observe the strength of a few connections in a graph.\n\nEven if the elements of $\\Omega$ are chosen at random, this scenario has some significant differences from the case where the ${\\boldsymbol{{A}}}_i$ are Gaussian. It is clear that we cannot expect the theory developed using Gaussian widths to be of much use, since our observations are not Gaussian, but there is a more fundamental problem that arises in the case of matrix completion.\n\n\\subsection{Which matrices can be completed?}\nIn particular, the most immediate challenge we encounter when developing a theory of matrix completion is that it is no longer possible to obtain the kind of uniform guarantees that apply to {\\em all} low-rank matrices described in Section~\\ref{sec:gauss}.  To see why, consider a matrix with rank one, but where one (or both) singular vectors are {\\em sparse}, meaning that their energy is concentrated on just a few entries.  When this occurs, as illustrated in Figure~\\ref{fig:sparsesvs}, the resulting matrix will also have its energy mostly concentrated on just a few entries, in which case most entries give us very little information and the recovery problem is highly ill-posed unless nearly all the entries are observed.  (Another way to see this is to realize that if only a few entries of such a matrix are observed, the matrix is very likely to live in the nullspace of the measurement operator ${\\mathcal A}$.)   More generally, if any particular column (or row) is approximately orthogonal to the span of the remaining columns (or rows), then it will be impossible to estimate without essentially observing the entire column (or row).\n\n\\begin{figure}\n\\centering\n\\resizebox{3.5in}{!}{\\parbox{.5\\linewidth}{\n\n", "index": 73, "text": "\\begin{align*}\n{\\boldsymbol{{u}}} \\hspace{0.86in} {\\boldsymbol{{v}}}^*\\hspace{1.02in} &   \\hspace{0.8in} {\\boldsymbol{{X}}}_0 \\\\\n\\begin{bmatrix}  \\\\ {\\color{red} \\bullet} \\\\  \\\\ {\\color{red} \\bullet} \\\\  \\\\   \\\\  \\\\ \\\\  \\end{bmatrix}   \\begin{array}{c} \\begin{bmatrix}  {\\color{red} \\bullet}  &  \\hphantom{0} & \\hphantom{0}  & \\hphantom{0}    &  \\hphantom{0} & \\hphantom{0}   & {\\color{red} \\bullet}  &  \\hphantom{0}    \\end{bmatrix}  \\\\ \\\\ \\\\ \\\\ \\\\  \\\\  \\\\ \\\\ \\end{array}   = &\n \\begin{bmatrix}\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} \\\\\n{\\color{red} \\bullet}  &  \\hphantom{0} & \\hphantom{0}  & \\hphantom{0}    &  \\hphantom{0} & \\hphantom{0}   & {\\color{red} \\bullet}  &  \\hphantom{0} \\\\\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} \\\\\n{\\color{red} \\bullet}  &  \\hphantom{0} & \\hphantom{0}  & \\hphantom{0}    &  \\hphantom{0} & \\hphantom{0}   & {\\color{red} \\bullet}  &  \\hphantom{0} \\\\\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} \\\\\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} \\\\\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} \\\\\n\\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0} & \\hphantom{0}\n\\end{bmatrix}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{u}}}\\hskip 62.1522pt{\\boldsymbol{{v}}}^{*}\" display=\"inline\"><mrow><mi>\ud835\udc96</mi><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2003\u2003\u2003\u2003\u2006</mo><msup><mi>\ud835\udc97</mi><mo>*</mo></msup></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\\boldsymbol{{X}}}_{0}\" display=\"inline\"><mrow><mi>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</mi><mo>\u2062</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\begin{bmatrix}\\\\&#10;{\\color[rgb]{1,0,0}\\bullet}\\\\&#10;\\\\&#10;{\\color[rgb]{1,0,0}\\bullet}\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\end{bmatrix}\\begin{array}[]{c}\\begin{bmatrix}{\\color[rgb]{1,0,0}\\bullet}&amp;&amp;&amp;&amp;&amp;%&#10;&amp;{\\color[rgb]{1,0,0}\\bullet}&amp;\\end{bmatrix}\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\\\&#10;\\end{array}=\" display=\"inline\"><mrow><mrow><mrow><mo>[</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u2062</mo><mtable rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo>[</mo><mtable columnspacing=\"5pt\"><mtr><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr></mtable><mo>]</mo></mrow></mtd></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr><mtr><mtd/></mtr></mtable></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\begin{bmatrix}&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\&#10;{\\color[rgb]{1,0,0}\\bullet}&amp;&amp;&amp;&amp;&amp;&amp;{\\color[rgb]{1,0,0}\\bullet}&amp;\\\\&#10;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\&#10;{\\color[rgb]{1,0,0}\\bullet}&amp;&amp;&amp;&amp;&amp;&amp;{\\color[rgb]{1,0,0}\\bullet}&amp;\\\\&#10;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\&#10;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\&#10;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\\\&#10;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\end{bmatrix}\" display=\"inline\"><mrow><mo>[</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mo mathcolor=\"#FF0000\">\u2219</mo></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr><mtr><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd><mtd columnalign=\"center\"><mi/></mtd></mtr></mtable><mo>]</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $\\{{\\boldsymbol{{e}}}_i\\}$ denotes the canonical basis for ${ \\mathbb{R} }^N$ and ${\\mathcal P}_U$ denotes the orthogonal projection onto $U$. Clearly, the largest value that $\\mu(U)$ can take is $N/R$, which occurs when some ${\\boldsymbol{{e}}}_i$ lies in the span of $U$.  The smallest possible value for $\\mu(U)$ is 1, which occurs when $U$ is the span of vectors with constant magnitude $1/\\sqrt{N}$.   \nMatrices whose column and row spaces have a small coherence (close to 1) are called {\\em incoherent} and represent a class of matrices where each entry contains a comparable amount of information so that completion from a small number of observations is potentially feasible.\n\n\\subsection{Recovery guarantees}\nThere is now a rich literature providing a range of guarantees under which it is possible to recover a matrix ${\\boldsymbol{{X}}}_0$ from randomly chosen entries under the assumption that ${\\boldsymbol{{X}}}_0$ is incoherent and/or satisfies certain similar conditions. As a representative example, we will describe the guarantees that are possible when using nuclear norm minimization as a recovery technique, as first developed in~\\cite{CandeR_Exact} and further refined in~\\cite{Gross_Recovering,CandeT_Power,Recht_Simpler}.\n\nTo state the main conclusion of this literature, we will assume for the moment that ${\\boldsymbol{{X}}}_0$ is an $M \\times N$ matrix of rank $R$ with singular value decomposition ${\\boldsymbol{{U}}} {\\boldsymbol{{\\Sigma}}} {\\boldsymbol{{V}}}^*$. We will also assume that $\\mu({\\boldsymbol{{U}}}), \\mu({\\boldsymbol{{V}}}) \\le \\mu_0$ and further that the matrix ${\\boldsymbol{{E}}} = {\\boldsymbol{{U}}} {\\boldsymbol{{V}}}^*$ has a maximum entry bounded by $\\mu_1 \\sqrt{R/MN}$ .\\footnote{As argued in~\\cite{CandeR_Exact}, as a simple consequence of the Cauchy-Schwarz inequality, the assumption on ${\\boldsymbol{{E}}}$ will always hold with $\\mu_1 = \\mu_0 \\sqrt{R}.$ In addition, a more refined analysis using alternative concentration bounds can eliminate the need for any assumption on $\\mu_1$ (see, for example, \\cite{Chen_Incoherence}). Moreover, given a limited amount of {\\em a priori} information about the underlying matrix, it is also possible to obtain results that omit any dependence on the incoherence by sampling certain rows/columns more heavily~\\cite{ChenBSW_Completing}. } We will also assume, without loss of generality, that $M>N$.  Then if $L$ entries of ${\\boldsymbol{{X}}}_0$ are observed with locations sampled uniformly at random with\n\n", "itemtype": "equation", "pos": 52736, "prevtext": "}}\n    \\caption{\\small\\sl  A low-rank matrix with sparse singular vectors, resulting in a matrix which mostly consists of zeros.}\n\t\\label{fig:sparsesvs}\n\\end{figure}\n\nThus, there exist low-rank matrices which, in the absence of any prior information, would clearly be impossible to recover from the observation of only a few entries.  In order to avoid such cases, we need to ensure that each entry of the matrix tells us something about the other rows/columns.  Fortunately, this is very likely to be the case in most practical applications of interest.  For example, the entire premise of the collaborative filtering approach to recommendation systems is that knowing how a particular user feels about a particular item provides information about other users and items.  This notion can be mathematically quantified in various different ways, but the bulk of the literature on matrix completion builds on the notion of {\\em coherence} as introduced in~\\cite{CandeR_Exact}.  Given an $R$-dimensional subspace $U$ of ${ \\mathbb{R} }^N$, the coherence is defined as\n\n", "index": 75, "text": "\\begin{equation} \\label{eq:coherence}\n\\mu(U) := \\frac{N}{R} \\max_{1 \\le i \\le N} \\| {\\mathcal P}_U {\\boldsymbol{{e}}}_i \\|_2^2,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E21.m1\" class=\"ltx_Math\" alttext=\"\\mu(U):=\\frac{N}{R}\\max_{1\\leq i\\leq N}\\|{\\mathcal{P}}_{U}{\\boldsymbol{{e}}}_{%&#10;i}\\|_{2}^{2},\" display=\"block\"><mrow><mrow><mrow><mi>\u03bc</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mfrac><mi>N</mi><mi>R</mi></mfrac><mo>\u2062</mo><munder><mi>max</mi><mrow><mn>1</mn><mo>\u2264</mo><mi>i</mi><mo>\u2264</mo><mi>N</mi></mrow></munder><mo>\u2062</mo><msubsup><mrow><mo>\u2225</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udcab</mi><mi>U</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc86</mi><mi>i</mi></msub></mrow><mo>\u2225</mo></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n${\\boldsymbol{{X}}}_0$ will be the solution to~\\eqref{eq:nneq} with high probability.  We note that the required number of observations in the matrix completion setting exceeds that required in the Gaussian case (i.e., $O(R(M+N))$) in two natural ways.  First,  $L$ scales with the level of incoherence as quantified by $\\mu_0$ and $\\mu_1$.  For example, in the case where $\\mu({\\boldsymbol{{U}}})$ or $\\mu({\\boldsymbol{{V}}})$ approach their maximal value then the bound in~\\eqref{eq:MCmeasbound} reduces to the requirement that we observe nearly every entry.  The second difference is that we have an additional $\\log$ factor.  While the power of $2$ on the $\\log$ may not be strictly necessary, some logarithmic dependence on the dimension of the matrix is a necessary consequence of the random observation model.  In particular, as a consequence of the classic {\\em coupon collector} problem, we need at least $O(M \\log M)$ observations simply to ensure that we observe each row at least once.  (If $N>M$, the same argument applies with columns instead of rows.)\n\nFinally, we also note that the above result applies to the specific case of noise-free observations of a matrix with rank at most $R$.  Similar results can also be established that guarantee approximate recovery in the case of noisy observations and approximately low-rank matrices with the amount of recovery error being naturally determined by the amount of noise and degree of approximation error~\\cite{KeshaMO_MatrixNoise, NegahW_Restricted, KoltcLT_Nuclear, CandeP_Matrix, RohdeT_Estimation, Klopp_Rank, GaiffL_Sharp, Klopp_High, Koltc_Von}.\n\nThe full proof of the exact recovery result described above is somewhat involved, but has been significantly simplified in the work of~\\cite{Gross_Recovering} and subsequently in~\\cite{Recht_Simpler} to the point where the key ingredients are relatively straightforward.  In light of the discussion of Section~\\ref{ssec:MRIP} one might expect that a possible avenue of attack would be to show that by selecting elements of our matrix at random, we obtain a measurement operator ${\\mathcal A}$ that satisfies something like the matrix-RIP in~\\eqref{eq:matrix-rip} but which holds only for matrices satisfying our incoherence assumptions.  In fact, it is indeed possible to pursue this route (and the incoherence assumption is vital to ensure that ${\\operatorname{E}}[\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2] = \\|{\\boldsymbol{{X}}}\\|_F^2$ as is required at the outset in Section~\\ref{sec:gauss}).  This is essentially the approach taken in~\\cite{NegahW_Restricted}.  However, the difference between two incoherent matrices is not necessarily itself incoherent, which leads to some significant challenges in an RIP-based analysis.  Moreover, this approach fails to yield the kind of exact recovery guarantee described above in the exactly low rank case and is primarily of interest in the noisy setting.\n\nInstead of approaching the problem from the perspective of the matrix-RIP, the approach taken in~\\cite{Gross_Recovering,CandeR_Exact, CandeT_Power,Recht_Simpler} relies on an alternative approach based on duality theory.  At a high level, the argument consists primarily of two main steps.  In the first step, one shows that if a dual vector satisfying certain special properties\\footnote{Specifically, the required properties can be defined as follows. Given the matrix ${\\boldsymbol{{X}}}_0 = {\\boldsymbol{{U}}} {\\boldsymbol{{\\Sigma}}} {\\boldsymbol{{V}}}^*$, define $T$ to be the subspace of ${ \\mathbb{R} }^{M \\times N}$ spanned by elements of the form ${\\boldsymbol{{U}}} {\\boldsymbol{{Y}}}^*$ and ${\\boldsymbol{{X}}} {\\boldsymbol{{V}}}^*$, where ${\\boldsymbol{{X}}}$ and ${\\boldsymbol{{Y}}}$ are arbitrary, and let ${\\mathcal P}_T$ and ${\\mathcal P}_{T^\\perp}$ denote the projections onto $T$ and its orthogonal complement, respectively.  Then our goal is to show that there exists a ${\\boldsymbol{{\\lambda}}}$ in the range of ${\\mathcal A}$ satisfying ${\\mathcal P}_T({\\mathcal A}^*({\\boldsymbol{{\\lambda}}})) = {\\boldsymbol{{U}}} {\\boldsymbol{{V}}}^*$ and $\\| {\\mathcal P}_{T^\\perp}({\\mathcal A}^*({\\boldsymbol{{\\lambda}}})) \\| < 1$.} exists, then this is a sufficient condition to ensure exact recovery, i.e., that the minimizer of~\\eqref{eq:nneq} is given by ${\\boldsymbol{{X}}}_0$.  This vector is called a {\\em dual certificate} because it certifies that the (unique) optimal solution to~\\eqref{eq:nneq} is ${\\boldsymbol{{X}}}_0$. This step in the argument relies entirely on elementary inequalities and standard notions from duality theory.\n\nThe more challenging part of the argument is the second step, in which one must show that given random samples of a matrix ${\\boldsymbol{{X}}}_0$ satisfying the required coherence properties, such a dual certificate must exist (with high probability).  The original proof of this in~\\cite{CandeR_Exact} and the subsequent improvement in~\\cite{CandeT_Power} involved rather intricate analysis, made especially difficult by the fact that when we observe $L$ distinct entries of a matrix, our observations are not fully independent (since we cannot sample the same entry twice).  In~\\cite{Gross_Recovering} this analysis is dramatically simplified by two observations: {\\em (i)} it is actually sufficient to merely obtain an {\\em approximate} dual certificate, which can be easier to construct, and {\\em (ii)} one can alternatively consider an observation model of sampling {\\em with replacement}.  Under this model, one can analyze the adjoint operator ${\\mathcal A}^*(\\cdot)$ by treating its output as a sum of {\\em independent} random matrices, which enables the use of the powerful concentration inequalities recently developed in~\\cite{AhlswW_Strong} that bound the deviation of this sum from its expected value. This allows one to analyze the relatively simple ``golfing scheme'' of~\\cite{Gross_Recovering}, which consists of an iterative construction of an approximate dual certificate.  See~\\cite{Recht_Simpler} for a condensed description of this approach and~\\cite{Tropp_User} for an overview (and other applications) of the matrix concentration inequalities used in this analysis. It is also worth noting that this line of analysis also provides theory for alternative low-rank matrix recovery scenarios beyond simply the matrix completion case.  Indeed, the arguments in~\\cite{Gross_Recovering} were originally developed to address the problem of quantum state tomography, where the goal is to efficiently determine the quantum state of a system via a small number of observations~\\cite{GrossLFBE_Quantum}.  This problem can be posed as a matrix recovery problem, but where the ${\\boldsymbol{{A}}}_i$ are constructed from Pauli matrices.  Perhaps somewhat surprisingly, the theory described above can also be readily adapted to this scenario.\n\nFinally, we also note that similar guarantees hold for a range of alternative algorithmic approaches. For example, both the approaches based on alternating minimization~\\cite{jain13lo,Hardt_Understanding,HardtW_Fast} and spectral methods with iterations similar to the proximal method~\\cite{KeshaMO_Matrix} described in Section~\\ref{sec:mralgs} have been shown to provide exact reconstruction under similar coherence assumptions, but at the cost of a slight increase in the required number of observations.  In particular, the results of~\\cite{KeshaMO_Matrix,jain13lo,Hardt_Understanding} all involve a dependence on the condition number of ${{\\mathbf X}_0}$ in which the number of required observations grows when the $R^{\\text{th}}$ singular value gets too small.  By a clever iterative scheme,~\\cite{HardtW_Fast} shows that it is possible to eliminate this dependence in the context of alternating minimization.  However, just as in the Gaussian measurement case, the best-known guarantees for alternating minimization also involve a polynomial dependence on the rank $R$ as opposed to the linear dependence which can be obtained using other approaches.  Nevertheless, the substantial computational advantages of these approaches means that they provide an attractive alternative in practice.\n\n\n\n\n\n\n\n\\section{Nonlinear Observation Models}\n\\label{sec:nonlinear}\n\n\nAlthough the theoretical results described in Sections~\\ref{sec:gauss} and~\\ref{sec:mc} are quite impressive, there is an important gap between the observation model described by~\\eqref{def:A} and many common applications of low-rank matrix recovery.  As an example, consider the matrix completion problem in the context of a recommendation system where ${\\boldsymbol{{X}}}_0$ represents a matrix whose entries each represent a rating for a particular user on a particular item.  In most practical recommendation systems (or indeed, any system soliciting any kind of feedback from people), the observations are ``quantized'', for example, to the set of integers between 1 and 5.  If we believe that it is possible for a user's true rating to be, for example, 4.5, then we must account for the impact of this ``quantization noise'' on our recovery.  Of course, one could potentially treat quantization simply as a form of bounded noise and rely on the existing stability guarantees mentioned in Sections~\\ref{sec:gauss} and~\\ref{sec:mc}, but this is somewhat unsatisfying because the ratings are not simply quantized --- there are also hard limits placed on the minimum and maximum allowable ratings.  (Why should we suppose that an item given a rating of 5 could not have a true underlying rating of 6 or 7 or 10? And note that if this is indeed the case, then the ``quantization error'' can be potentially extremely large.)  In such a situation, it can be much more advantageous to directly consider a nonlinear observation model of the form\n\n", "itemtype": "equation", "pos": 55388, "prevtext": "\nwhere $\\{{\\boldsymbol{{e}}}_i\\}$ denotes the canonical basis for ${ \\mathbb{R} }^N$ and ${\\mathcal P}_U$ denotes the orthogonal projection onto $U$. Clearly, the largest value that $\\mu(U)$ can take is $N/R$, which occurs when some ${\\boldsymbol{{e}}}_i$ lies in the span of $U$.  The smallest possible value for $\\mu(U)$ is 1, which occurs when $U$ is the span of vectors with constant magnitude $1/\\sqrt{N}$.   \nMatrices whose column and row spaces have a small coherence (close to 1) are called {\\em incoherent} and represent a class of matrices where each entry contains a comparable amount of information so that completion from a small number of observations is potentially feasible.\n\n\\subsection{Recovery guarantees}\nThere is now a rich literature providing a range of guarantees under which it is possible to recover a matrix ${\\boldsymbol{{X}}}_0$ from randomly chosen entries under the assumption that ${\\boldsymbol{{X}}}_0$ is incoherent and/or satisfies certain similar conditions. As a representative example, we will describe the guarantees that are possible when using nuclear norm minimization as a recovery technique, as first developed in~\\cite{CandeR_Exact} and further refined in~\\cite{Gross_Recovering,CandeT_Power,Recht_Simpler}.\n\nTo state the main conclusion of this literature, we will assume for the moment that ${\\boldsymbol{{X}}}_0$ is an $M \\times N$ matrix of rank $R$ with singular value decomposition ${\\boldsymbol{{U}}} {\\boldsymbol{{\\Sigma}}} {\\boldsymbol{{V}}}^*$. We will also assume that $\\mu({\\boldsymbol{{U}}}), \\mu({\\boldsymbol{{V}}}) \\le \\mu_0$ and further that the matrix ${\\boldsymbol{{E}}} = {\\boldsymbol{{U}}} {\\boldsymbol{{V}}}^*$ has a maximum entry bounded by $\\mu_1 \\sqrt{R/MN}$ .\\footnote{As argued in~\\cite{CandeR_Exact}, as a simple consequence of the Cauchy-Schwarz inequality, the assumption on ${\\boldsymbol{{E}}}$ will always hold with $\\mu_1 = \\mu_0 \\sqrt{R}.$ In addition, a more refined analysis using alternative concentration bounds can eliminate the need for any assumption on $\\mu_1$ (see, for example, \\cite{Chen_Incoherence}). Moreover, given a limited amount of {\\em a priori} information about the underlying matrix, it is also possible to obtain results that omit any dependence on the incoherence by sampling certain rows/columns more heavily~\\cite{ChenBSW_Completing}. } We will also assume, without loss of generality, that $M>N$.  Then if $L$ entries of ${\\boldsymbol{{X}}}_0$ are observed with locations sampled uniformly at random with\n\n", "index": 77, "text": "\\begin{equation}\n\\label{eq:MCmeasbound}\nL \\gtrsim \\max( \\mu_0, \\mu_1^2) R(M+N) \\log^2( M ),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E22.m1\" class=\"ltx_Math\" alttext=\"L\\gtrsim\\max(\\mu_{0},\\mu_{1}^{2})R(M+N)\\log^{2}(M),\" display=\"block\"><mrow><mrow><mi>L</mi><mo>\u2273</mo><mrow><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03bc</mi><mn>0</mn></msub><mo>,</mo><msubsup><mi>\u03bc</mi><mn>1</mn><mn>2</mn></msubsup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2062</mo><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>M</mi><mo>+</mo><mi>N</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><msup><mi>log</mi><mn>2</mn></msup><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $Q(\\cdot)$ is a scalar function that captures the impact of quantization, or any other potential nonlinearity of interest.  We describe some concrete examples below.\n\n\\subsection{One-bit observations}\n\nThe inadequacy of standard low-rank matrix recovery techniques in dealing with this effect is particularly pronounced when we consider problems where each observation is quantized to a single-bit.  In particular, suppose that our observations are given by\n\n", "itemtype": "equation", "pos": 65230, "prevtext": "\n${\\boldsymbol{{X}}}_0$ will be the solution to~\\eqref{eq:nneq} with high probability.  We note that the required number of observations in the matrix completion setting exceeds that required in the Gaussian case (i.e., $O(R(M+N))$) in two natural ways.  First,  $L$ scales with the level of incoherence as quantified by $\\mu_0$ and $\\mu_1$.  For example, in the case where $\\mu({\\boldsymbol{{U}}})$ or $\\mu({\\boldsymbol{{V}}})$ approach their maximal value then the bound in~\\eqref{eq:MCmeasbound} reduces to the requirement that we observe nearly every entry.  The second difference is that we have an additional $\\log$ factor.  While the power of $2$ on the $\\log$ may not be strictly necessary, some logarithmic dependence on the dimension of the matrix is a necessary consequence of the random observation model.  In particular, as a consequence of the classic {\\em coupon collector} problem, we need at least $O(M \\log M)$ observations simply to ensure that we observe each row at least once.  (If $N>M$, the same argument applies with columns instead of rows.)\n\nFinally, we also note that the above result applies to the specific case of noise-free observations of a matrix with rank at most $R$.  Similar results can also be established that guarantee approximate recovery in the case of noisy observations and approximately low-rank matrices with the amount of recovery error being naturally determined by the amount of noise and degree of approximation error~\\cite{KeshaMO_MatrixNoise, NegahW_Restricted, KoltcLT_Nuclear, CandeP_Matrix, RohdeT_Estimation, Klopp_Rank, GaiffL_Sharp, Klopp_High, Koltc_Von}.\n\nThe full proof of the exact recovery result described above is somewhat involved, but has been significantly simplified in the work of~\\cite{Gross_Recovering} and subsequently in~\\cite{Recht_Simpler} to the point where the key ingredients are relatively straightforward.  In light of the discussion of Section~\\ref{ssec:MRIP} one might expect that a possible avenue of attack would be to show that by selecting elements of our matrix at random, we obtain a measurement operator ${\\mathcal A}$ that satisfies something like the matrix-RIP in~\\eqref{eq:matrix-rip} but which holds only for matrices satisfying our incoherence assumptions.  In fact, it is indeed possible to pursue this route (and the incoherence assumption is vital to ensure that ${\\operatorname{E}}[\\|{\\mathcal A}({\\boldsymbol{{X}}})\\|_2^2] = \\|{\\boldsymbol{{X}}}\\|_F^2$ as is required at the outset in Section~\\ref{sec:gauss}).  This is essentially the approach taken in~\\cite{NegahW_Restricted}.  However, the difference between two incoherent matrices is not necessarily itself incoherent, which leads to some significant challenges in an RIP-based analysis.  Moreover, this approach fails to yield the kind of exact recovery guarantee described above in the exactly low rank case and is primarily of interest in the noisy setting.\n\nInstead of approaching the problem from the perspective of the matrix-RIP, the approach taken in~\\cite{Gross_Recovering,CandeR_Exact, CandeT_Power,Recht_Simpler} relies on an alternative approach based on duality theory.  At a high level, the argument consists primarily of two main steps.  In the first step, one shows that if a dual vector satisfying certain special properties\\footnote{Specifically, the required properties can be defined as follows. Given the matrix ${\\boldsymbol{{X}}}_0 = {\\boldsymbol{{U}}} {\\boldsymbol{{\\Sigma}}} {\\boldsymbol{{V}}}^*$, define $T$ to be the subspace of ${ \\mathbb{R} }^{M \\times N}$ spanned by elements of the form ${\\boldsymbol{{U}}} {\\boldsymbol{{Y}}}^*$ and ${\\boldsymbol{{X}}} {\\boldsymbol{{V}}}^*$, where ${\\boldsymbol{{X}}}$ and ${\\boldsymbol{{Y}}}$ are arbitrary, and let ${\\mathcal P}_T$ and ${\\mathcal P}_{T^\\perp}$ denote the projections onto $T$ and its orthogonal complement, respectively.  Then our goal is to show that there exists a ${\\boldsymbol{{\\lambda}}}$ in the range of ${\\mathcal A}$ satisfying ${\\mathcal P}_T({\\mathcal A}^*({\\boldsymbol{{\\lambda}}})) = {\\boldsymbol{{U}}} {\\boldsymbol{{V}}}^*$ and $\\| {\\mathcal P}_{T^\\perp}({\\mathcal A}^*({\\boldsymbol{{\\lambda}}})) \\| < 1$.} exists, then this is a sufficient condition to ensure exact recovery, i.e., that the minimizer of~\\eqref{eq:nneq} is given by ${\\boldsymbol{{X}}}_0$.  This vector is called a {\\em dual certificate} because it certifies that the (unique) optimal solution to~\\eqref{eq:nneq} is ${\\boldsymbol{{X}}}_0$. This step in the argument relies entirely on elementary inequalities and standard notions from duality theory.\n\nThe more challenging part of the argument is the second step, in which one must show that given random samples of a matrix ${\\boldsymbol{{X}}}_0$ satisfying the required coherence properties, such a dual certificate must exist (with high probability).  The original proof of this in~\\cite{CandeR_Exact} and the subsequent improvement in~\\cite{CandeT_Power} involved rather intricate analysis, made especially difficult by the fact that when we observe $L$ distinct entries of a matrix, our observations are not fully independent (since we cannot sample the same entry twice).  In~\\cite{Gross_Recovering} this analysis is dramatically simplified by two observations: {\\em (i)} it is actually sufficient to merely obtain an {\\em approximate} dual certificate, which can be easier to construct, and {\\em (ii)} one can alternatively consider an observation model of sampling {\\em with replacement}.  Under this model, one can analyze the adjoint operator ${\\mathcal A}^*(\\cdot)$ by treating its output as a sum of {\\em independent} random matrices, which enables the use of the powerful concentration inequalities recently developed in~\\cite{AhlswW_Strong} that bound the deviation of this sum from its expected value. This allows one to analyze the relatively simple ``golfing scheme'' of~\\cite{Gross_Recovering}, which consists of an iterative construction of an approximate dual certificate.  See~\\cite{Recht_Simpler} for a condensed description of this approach and~\\cite{Tropp_User} for an overview (and other applications) of the matrix concentration inequalities used in this analysis. It is also worth noting that this line of analysis also provides theory for alternative low-rank matrix recovery scenarios beyond simply the matrix completion case.  Indeed, the arguments in~\\cite{Gross_Recovering} were originally developed to address the problem of quantum state tomography, where the goal is to efficiently determine the quantum state of a system via a small number of observations~\\cite{GrossLFBE_Quantum}.  This problem can be posed as a matrix recovery problem, but where the ${\\boldsymbol{{A}}}_i$ are constructed from Pauli matrices.  Perhaps somewhat surprisingly, the theory described above can also be readily adapted to this scenario.\n\nFinally, we also note that similar guarantees hold for a range of alternative algorithmic approaches. For example, both the approaches based on alternating minimization~\\cite{jain13lo,Hardt_Understanding,HardtW_Fast} and spectral methods with iterations similar to the proximal method~\\cite{KeshaMO_Matrix} described in Section~\\ref{sec:mralgs} have been shown to provide exact reconstruction under similar coherence assumptions, but at the cost of a slight increase in the required number of observations.  In particular, the results of~\\cite{KeshaMO_Matrix,jain13lo,Hardt_Understanding} all involve a dependence on the condition number of ${{\\mathbf X}_0}$ in which the number of required observations grows when the $R^{\\text{th}}$ singular value gets too small.  By a clever iterative scheme,~\\cite{HardtW_Fast} shows that it is possible to eliminate this dependence in the context of alternating minimization.  However, just as in the Gaussian measurement case, the best-known guarantees for alternating minimization also involve a polynomial dependence on the rank $R$ as opposed to the linear dependence which can be obtained using other approaches.  Nevertheless, the substantial computational advantages of these approaches means that they provide an attractive alternative in practice.\n\n\n\n\n\n\n\n\\section{Nonlinear Observation Models}\n\\label{sec:nonlinear}\n\n\nAlthough the theoretical results described in Sections~\\ref{sec:gauss} and~\\ref{sec:mc} are quite impressive, there is an important gap between the observation model described by~\\eqref{def:A} and many common applications of low-rank matrix recovery.  As an example, consider the matrix completion problem in the context of a recommendation system where ${\\boldsymbol{{X}}}_0$ represents a matrix whose entries each represent a rating for a particular user on a particular item.  In most practical recommendation systems (or indeed, any system soliciting any kind of feedback from people), the observations are ``quantized'', for example, to the set of integers between 1 and 5.  If we believe that it is possible for a user's true rating to be, for example, 4.5, then we must account for the impact of this ``quantization noise'' on our recovery.  Of course, one could potentially treat quantization simply as a form of bounded noise and rely on the existing stability guarantees mentioned in Sections~\\ref{sec:gauss} and~\\ref{sec:mc}, but this is somewhat unsatisfying because the ratings are not simply quantized --- there are also hard limits placed on the minimum and maximum allowable ratings.  (Why should we suppose that an item given a rating of 5 could not have a true underlying rating of 6 or 7 or 10? And note that if this is indeed the case, then the ``quantization error'' can be potentially extremely large.)  In such a situation, it can be much more advantageous to directly consider a nonlinear observation model of the form\n\n", "index": 79, "text": "\\begin{equation}\\label{def:Q}\ny_i = Q \\left( \\langle {{\\mathbf X}_0}, {\\mathbf A}_i \\rangle + z_i \\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E23.m1\" class=\"ltx_Math\" alttext=\"y_{i}=Q\\left(\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}\\rangle+z_{i}\\right),\" display=\"block\"><mrow><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nIn such a case, the assumptions made in the standard theory of matrix recovery do not apply, standard algorithms are ill-posed, and an alternative theory is required.  To see why, simply observe that in the noise-free setting (where $z_i = 0$), we could rescale ${{\\mathbf X}_0}$ arbitrarily without changing any observations.\\footnote{In fact, in the noise-free setting the situation is even worse than one might suspect. Even if the normalization is fixed/known a priori, the problem remains highly ill-posed.  See~\\cite{DavenPBW_One} for further discussion.}\n\nWhat is perhaps somewhat surprising is that when considering the noisy setting the situation completely changes --- the noise has a ``dithering'' effect and the problem becomes well-posed.  In fact, it is possible to show that one can sometimes recover ${{\\mathbf X}_0}$ to the same degree of accuracy that is possible when given access to completely unquantized measurements, and that given sufficiently many measurements it is possible to recover ${{\\mathbf X}_0}$ to an arbitrary level of precision. For the specific case of matrix completion, this observation model is analyzed in~\\cite{DavenPBW_One} with the main conclusion being that it is possible to recover any ${{\\mathbf X}_0}$ belonging to a certain class of approximately low-rank matrices up to an error proportional to $\\sqrt{R(M+N)/L}$, so that by taking $L = C R(M+N)$ one can drive the recovery error to be arbitrarily small. The recovery algorithm in~\\cite{DavenPBW_One} is a simple modification of~\\eqref{eq:matrixlasso}, but where the fidelity constraint $\\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_F^2$ is replaced by the negative log-likelihood of ${\\boldsymbol{{X}}}$ given observations from the model in~\\eqref{def:Q1bit}.  A limitation of this approach is that it requires knowledge of the distribution of the noise $z_i$, but note that for many common noise distributions this still results in a convex optimization problem which can be solved with variants of the same algorithms described in Section~\\ref{sec:mralgs}.  Similar results are described in~\\cite{CaiZ_Max}, which again uses a penalized maximum-likelihood estimator but with a different regularizer than the nuclear norm.  See also~\\cite{BhaskJ_1bit} and~\\cite{SoniJHG_Noisy} which suggest potential improvements for the case of exactly low-rank matrices.  Note that many of these results are of interest even in the case where every entry of the matrix is observed, as this provides a theoretically justified way to reveal the ``underlying'' low-rank matrix given only quantized data.\n\nWhile most of the existing research into the one-bit observation model has focused on the model in~\\eqref{def:Q1bit}, and specifically in the matrix completion setting, it is important to note that it would not be difficult to extend this literature to handle the Gaussian observation model described in Section~\\ref{sec:gauss} and/or related one-bit observation models.  As an example, an alternative model might involve a setting where we can only tell if the magnitude of our observations is ``small'' or ``large'', as captured by a model along the lines of\n\n", "itemtype": "equation", "pos": 65816, "prevtext": "\nwhere $Q(\\cdot)$ is a scalar function that captures the impact of quantization, or any other potential nonlinearity of interest.  We describe some concrete examples below.\n\n\\subsection{One-bit observations}\n\nThe inadequacy of standard low-rank matrix recovery techniques in dealing with this effect is particularly pronounced when we consider problems where each observation is quantized to a single-bit.  In particular, suppose that our observations are given by\n\n", "index": 81, "text": "\\begin{equation}\\label{def:Q1bit}\ny_i = \\begin{cases} +1 & \\text{if~} \\langle {{\\mathbf X}_0}, {\\mathbf A}_i \\rangle + z_i \\ge 0 \\\\\n-1 & \\text{if~} \\langle {{\\mathbf X}_0}, {\\mathbf A}_i \\rangle + z_i < 0. \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E24.m1\" class=\"ltx_Math\" alttext=\"y_{i}=\\begin{cases}+1&amp;\\text{if~{}}\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}%&#10;\\rangle+z_{i}\\geq 0\\\\&#10;-1&amp;\\text{if~{}}\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}\\rangle+z_{i}&lt;0.\\end{cases}\" display=\"block\"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>\u2265</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nA similar theory could be developed for this setting.  See~\\cite{KarbaO_Robust} for example applications and one possible approach.\n\n\n\\subsection{Comparisons}\n\nAnother application of the one-bit observation models in~\\eqref{def:Q1bit} or~\\eqref{def:Qnearfar} arises when one considers scenarios involving comparisons between different entries in the matrix ${{\\mathbf X}_0}$.   This might occur in the context of paired comparisons, where a person evaluates a pair of items and indicates whether they are similar or dissimilar, or whether one\nis preferred to the other. This type of data frequently arises when dealing with judgements made by human\nsubjects, since people are typically more accurate and find it easier to make such judgements than to assign\nnumerical scores~\\cite{David_Method}.  These settings can be readily accommodated by the models in~\\eqref{def:Q1bit} or~\\eqref{def:Qnearfar} by slightly modifying the ${\\boldsymbol{{A}}}_i$.  In particular, when comparing $X_0[m,n]$ to $X_0[m',n']$ one can set ${\\boldsymbol{{A}}}_i = {\\boldsymbol{{e}}}_m {\\boldsymbol{{e}}}_n^T - {\\boldsymbol{{e}}}_{m'} {\\boldsymbol{{e}}}_{n'}^T$ so that, for example,~\\eqref{def:Q1bit} becomes\n\n", "itemtype": "equation", "pos": 69213, "prevtext": "\nIn such a case, the assumptions made in the standard theory of matrix recovery do not apply, standard algorithms are ill-posed, and an alternative theory is required.  To see why, simply observe that in the noise-free setting (where $z_i = 0$), we could rescale ${{\\mathbf X}_0}$ arbitrarily without changing any observations.\\footnote{In fact, in the noise-free setting the situation is even worse than one might suspect. Even if the normalization is fixed/known a priori, the problem remains highly ill-posed.  See~\\cite{DavenPBW_One} for further discussion.}\n\nWhat is perhaps somewhat surprising is that when considering the noisy setting the situation completely changes --- the noise has a ``dithering'' effect and the problem becomes well-posed.  In fact, it is possible to show that one can sometimes recover ${{\\mathbf X}_0}$ to the same degree of accuracy that is possible when given access to completely unquantized measurements, and that given sufficiently many measurements it is possible to recover ${{\\mathbf X}_0}$ to an arbitrary level of precision. For the specific case of matrix completion, this observation model is analyzed in~\\cite{DavenPBW_One} with the main conclusion being that it is possible to recover any ${{\\mathbf X}_0}$ belonging to a certain class of approximately low-rank matrices up to an error proportional to $\\sqrt{R(M+N)/L}$, so that by taking $L = C R(M+N)$ one can drive the recovery error to be arbitrarily small. The recovery algorithm in~\\cite{DavenPBW_One} is a simple modification of~\\eqref{eq:matrixlasso}, but where the fidelity constraint $\\|{\\mathcal A}({\\boldsymbol{{X}}})-{\\boldsymbol{{y}}}\\|_F^2$ is replaced by the negative log-likelihood of ${\\boldsymbol{{X}}}$ given observations from the model in~\\eqref{def:Q1bit}.  A limitation of this approach is that it requires knowledge of the distribution of the noise $z_i$, but note that for many common noise distributions this still results in a convex optimization problem which can be solved with variants of the same algorithms described in Section~\\ref{sec:mralgs}.  Similar results are described in~\\cite{CaiZ_Max}, which again uses a penalized maximum-likelihood estimator but with a different regularizer than the nuclear norm.  See also~\\cite{BhaskJ_1bit} and~\\cite{SoniJHG_Noisy} which suggest potential improvements for the case of exactly low-rank matrices.  Note that many of these results are of interest even in the case where every entry of the matrix is observed, as this provides a theoretically justified way to reveal the ``underlying'' low-rank matrix given only quantized data.\n\nWhile most of the existing research into the one-bit observation model has focused on the model in~\\eqref{def:Q1bit}, and specifically in the matrix completion setting, it is important to note that it would not be difficult to extend this literature to handle the Gaussian observation model described in Section~\\ref{sec:gauss} and/or related one-bit observation models.  As an example, an alternative model might involve a setting where we can only tell if the magnitude of our observations is ``small'' or ``large'', as captured by a model along the lines of\n\n", "index": 83, "text": "\\begin{equation}\\label{def:Qnearfar}\ny_i = \\begin{cases} +1 & \\text{if~} |\\langle {{\\mathbf X}_0}, {\\mathbf A}_i \\rangle + z_i| \\ge T \\\\\n-1 & \\text{if~} |\\langle {{\\mathbf X}_0}, {\\mathbf A}_i \\rangle + z_i| < T. \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E25.m1\" class=\"ltx_Math\" alttext=\"y_{i}=\\begin{cases}+1&amp;\\text{if~{}}|\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}%&#10;\\rangle+z_{i}|\\geq T\\\\&#10;-1&amp;\\text{if~{}}|\\langle{{\\mathbf{X}}_{0}},{\\mathbf{A}}_{i}\\rangle+z_{i}|&lt;T.%&#10;\\end{cases}\" display=\"block\"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>\u2265</mo><mi>T</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><msub><mi>\ud835\udc17</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>&lt;</mo><mi>T</mi></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nA similar theory can be developed for low-rank recovery under this model.  For example, see~\\cite{LuN_Individualized,ParkNZSD_Preference} for discussion of paired comparisons and~\\cite{OhTX_Collaboratively} for a generalization to ordinal comparisons among groups of entries in ${{\\mathbf X}_0}$.\n\n\\subsection{Categorical observations and other noise models}\n\nWhile the discussion above has focused on the one-bit case where $Q(\\cdot) = \\text{sign}(\\cdot)$, the algorithms developed for this case can often be readily extended to handle more general nonlinearities.  For example, in the case of more general quantization schemes to arbitrary finite alphabets, one must simply be able to compute the log-likelihood function in order to be able to compute the regularized maximum-likelihood estimate as analyzed in~\\cite{DavenPBW_One}.  This has applications to multi-bit quantization schemes (e.g., ratings being quantized to the integers from 1 to 5) and also to handle general forms of categorical data (e.g., group membership, race/ethnicity, zip code, etc.).   Moreover, in many cases the analysis can also be extended to handle this kind of observation~\\cite{LafonKMS_Probabilistic,KloppLMS_Adaptive,CaoX_Categorical}.  Finally, it is also worth noting that this body of work has also established a variety of both algorithmic and analytical techniques for handling a variety of complex probabilistic observation models.  As a result, this has laid the foundation for a number of works which consider more general noise models beyond simple bounded perturbations or Gaussian measurement noise.  For example,~\\cite{CaoX_Poisson} explores the impact of the signal-dependent (Poisson) noise  that arises in dealing with applications involving count data.  These techniques are further generalized in~\\cite{GunasRG_Exponential,Lafon_Low} to general exponential noise families. See also~\\cite{KabasKMSZ_Phase} for a treatment of matrix factorization problems allowing for a quite general family of noise models. \n\n\n\\section{Lifting}\n\\label{sec:lifting}\n\n\n\nThe progress in recovering a low-rank matrix from an incomplete set of linear measurements described above has also affected the way we think about solving {\\em quadratic} and {\\em bilinear} systems of equations.  There is a simple, but perhaps until recently under-appreciated, way to re-cast a system of quadratic equations as a system of linear equations whose solution obeys a rank constraint.  This method, known as {\\em lifting}, is best illustrated with a small, concrete example.  Consider the following system of $6$ quadratic equations in three unknowns $v_1,v_2,v_3$:\n\n", "itemtype": "equation", "pos": 70641, "prevtext": "\nA similar theory could be developed for this setting.  See~\\cite{KarbaO_Robust} for example applications and one possible approach.\n\n\n\\subsection{Comparisons}\n\nAnother application of the one-bit observation models in~\\eqref{def:Q1bit} or~\\eqref{def:Qnearfar} arises when one considers scenarios involving comparisons between different entries in the matrix ${{\\mathbf X}_0}$.   This might occur in the context of paired comparisons, where a person evaluates a pair of items and indicates whether they are similar or dissimilar, or whether one\nis preferred to the other. This type of data frequently arises when dealing with judgements made by human\nsubjects, since people are typically more accurate and find it easier to make such judgements than to assign\nnumerical scores~\\cite{David_Method}.  These settings can be readily accommodated by the models in~\\eqref{def:Q1bit} or~\\eqref{def:Qnearfar} by slightly modifying the ${\\boldsymbol{{A}}}_i$.  In particular, when comparing $X_0[m,n]$ to $X_0[m',n']$ one can set ${\\boldsymbol{{A}}}_i = {\\boldsymbol{{e}}}_m {\\boldsymbol{{e}}}_n^T - {\\boldsymbol{{e}}}_{m'} {\\boldsymbol{{e}}}_{n'}^T$ so that, for example,~\\eqref{def:Q1bit} becomes\n\n", "index": 85, "text": "\\begin{equation}\\label{def:Qcompare}\ny_i = \\begin{cases} +1 & \\text{if~} X_0[m,n]  + z_i \\ge X_0[m',n'] \\\\\n-1 & \\text{if~} X_0[m,n]  + z_i < X_0[m',n']. \\end{cases}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E26.m1\" class=\"ltx_Math\" alttext=\"y_{i}=\\begin{cases}+1&amp;\\text{if~{}}X_{0}[m,n]+z_{i}\\geq X_{0}[m^{\\prime},n^{%&#10;\\prime}]\\\\&#10;-1&amp;\\text{if~{}}X_{0}[m,n]+z_{i}&lt;X_{0}[m^{\\prime},n^{\\prime}].\\end{cases}\" display=\"block\"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mo>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>X</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>\u2265</mo><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>m</mi><mo>\u2032</mo></msup><mo>,</mo><msup><mi>n</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>X</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>+</mo><msub><mi>z</mi><mi>i</mi></msub></mrow><mo>&lt;</mo><mrow><msub><mi>X</mi><mn>0</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><msup><mi>m</mi><mo>\u2032</mo></msup><mo>,</mo><msup><mi>n</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">]</mo></mrow></mrow></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThese equations are quadratic in the entries of the vector ${\\boldsymbol{{v}}}$, but they are linear in the entries of the matrix\n", "itemtype": "equation", "pos": 73455, "prevtext": "\nA similar theory can be developed for low-rank recovery under this model.  For example, see~\\cite{LuN_Individualized,ParkNZSD_Preference} for discussion of paired comparisons and~\\cite{OhTX_Collaboratively} for a generalization to ordinal comparisons among groups of entries in ${{\\mathbf X}_0}$.\n\n\\subsection{Categorical observations and other noise models}\n\nWhile the discussion above has focused on the one-bit case where $Q(\\cdot) = \\text{sign}(\\cdot)$, the algorithms developed for this case can often be readily extended to handle more general nonlinearities.  For example, in the case of more general quantization schemes to arbitrary finite alphabets, one must simply be able to compute the log-likelihood function in order to be able to compute the regularized maximum-likelihood estimate as analyzed in~\\cite{DavenPBW_One}.  This has applications to multi-bit quantization schemes (e.g., ratings being quantized to the integers from 1 to 5) and also to handle general forms of categorical data (e.g., group membership, race/ethnicity, zip code, etc.).   Moreover, in many cases the analysis can also be extended to handle this kind of observation~\\cite{LafonKMS_Probabilistic,KloppLMS_Adaptive,CaoX_Categorical}.  Finally, it is also worth noting that this body of work has also established a variety of both algorithmic and analytical techniques for handling a variety of complex probabilistic observation models.  As a result, this has laid the foundation for a number of works which consider more general noise models beyond simple bounded perturbations or Gaussian measurement noise.  For example,~\\cite{CaoX_Poisson} explores the impact of the signal-dependent (Poisson) noise  that arises in dealing with applications involving count data.  These techniques are further generalized in~\\cite{GunasRG_Exponential,Lafon_Low} to general exponential noise families. See also~\\cite{KabasKMSZ_Phase} for a treatment of matrix factorization problems allowing for a quite general family of noise models. \n\n\n\\section{Lifting}\n\\label{sec:lifting}\n\n\n\nThe progress in recovering a low-rank matrix from an incomplete set of linear measurements described above has also affected the way we think about solving {\\em quadratic} and {\\em bilinear} systems of equations.  There is a simple, but perhaps until recently under-appreciated, way to re-cast a system of quadratic equations as a system of linear equations whose solution obeys a rank constraint.  This method, known as {\\em lifting}, is best illustrated with a small, concrete example.  Consider the following system of $6$ quadratic equations in three unknowns $v_1,v_2,v_3$:\n\n", "index": 87, "text": "\\begin{equation*}\n    {\\ifthenelse{\\boolean{twoColVersion}} {{     \\begin{aligned} \t\t4v_1^2 + 12 v_2^2 + 7v_3^2 + 25v_1v_2 + 16v_1v_3  + 7 v_2v_3  &= 237 \\\\ \t\t13v_1^2 - 3v_2^2 + 2v_3^2 - 5v_1v_2 + 23v_1v_3 + 3v_2v_3 &= -4 \\\\ \t\t-3v_1^2 - 12v_2^2 + 2v_3^2 -37v_1v_2 + 12v_1v_3 -6v_2v_3 &= -100 \\\\ \t\t6v_1^2 + v_2^2 + 2 v_3^2 - 16 v_1v_2 + v_1v_3  + 3v_2v_3  &= 153 \\\\ \t\t5v_1^2 - 25v_2^2 - 7v_3^2 + 8v_1v_2 - 4v_1v_3 - 4 v_2v_3 &= -459 \\\\ \t\t-9v_1^2 -9v_2^2 + 4v_3^2 -20v_1v_2 -2v_1v_3 + 10v_2v_3 &= 230. \t\\end{aligned}}} {{\\begin{aligned} \t\t4v_1^2 + 12 v_2^2 + 7v_3^2 + 25v_1v_2 + 16v_1v_3  + 7 v_2v_3  &= 237 \\\\ \t\t13v_1^2 - 3v_2^2 + 2v_3^2 - 5v_1v_2 + 23v_1v_3 + 3v_2v_3 &= -4 \\\\ \t\t-3v_1^2 - 12v_2^2 + 2v_3^2 -37v_1v_2 + 12v_1v_3 -6v_2v_3 &= -100 \t\\end{aligned} \t\\quad \t\\begin{aligned} \t\t6v_1^2 + v_2^2 + 2 v_3^2 - 16 v_1v_2 + v_1v_3  + 3v_2v_3  &= 153 \\\\ \t\t5v_1^2 - 25v_2^2 - 7v_3^2 + 8v_1v_2 - 4v_1v_3 - 4 v_2v_3 &= -459 \\\\ \t\t-9v_1^2 -9v_2^2 + 4v_3^2 -20v_1v_2 -2v_1v_3 + 10v_2v_3 &= 230. \t\\end{aligned}}} }\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"{{\\begin{aligned} \\displaystyle 4v_{1}^{2}+12v_{2}^{2}+7v_{3}^{2}+25v_{1}v_{2}%&#10;+16v_{1}v_{3}+7v_{2}v_{3}&amp;\\displaystyle=237\\\\&#10;\\displaystyle 13v_{1}^{2}-3v_{2}^{2}+2v_{3}^{2}-5v_{1}v_{2}+23v_{1}v_{3}+3v_{2%&#10;}v_{3}&amp;\\displaystyle=-4\\\\&#10;\\displaystyle-3v_{1}^{2}-12v_{2}^{2}+2v_{3}^{2}-37v_{1}v_{2}+12v_{1}v_{3}-6v_{%&#10;2}v_{3}&amp;\\displaystyle=-100\\end{aligned}\\quad\\begin{aligned} \\displaystyle 6v_{%&#10;1}^{2}+v_{2}^{2}+2v_{3}^{2}-16v_{1}v_{2}+v_{1}v_{3}+3v_{2}v_{3}&amp;\\displaystyle=%&#10;153\\\\&#10;\\displaystyle 5v_{1}^{2}-25v_{2}^{2}-7v_{3}^{2}+8v_{1}v_{2}-4v_{1}v_{3}-4v_{2}%&#10;v_{3}&amp;\\displaystyle=-459\\\\&#10;\\displaystyle-9v_{1}^{2}-9v_{2}^{2}+4v_{3}^{2}-20v_{1}v_{2}-2v_{1}v_{3}+10v_{2%&#10;}v_{3}&amp;\\displaystyle=230.\\end{aligned}}}\" display=\"block\"><mrow><mtable columnspacing=\"0pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mrow><mn>4</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mn>12</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mn>25</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>+</mo><mrow><mn>16</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow><mo>+</mo><mrow><mn>7</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mn>237</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mrow><mrow><mn>13</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow><mo>-</mo><mrow><mn>3</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>5</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>23</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow><mo>+</mo><mrow><mn>3</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mn>4</mn></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mrow><mrow><mrow><mo>-</mo><mrow><mn>3</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>12</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>37</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>12</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow><mo>-</mo><mrow><mn>6</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mn>100</mn></mrow></mrow></mtd></mtr></mtable><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtable columnspacing=\"0pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mrow><mn>6</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow><mo>+</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>16</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mrow><mo>+</mo><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow><mo>+</mo><mrow><mn>3</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mn>153</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mrow><mn>5</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow><mo>-</mo><mrow><mn>25</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mrow><mo>-</mo><mrow><mn>7</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mrow><mo>+</mo><mrow><mn>8</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mrow><mo>-</mo><mrow><mn>4</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow><mo>-</mo><mrow><mn>4</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mn>459</mn></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mrow><mrow><mrow><mrow><mo>-</mo><mrow><mn>9</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>9</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mrow></mrow><mo>+</mo><mrow><mn>4</mn><mo>\u2062</mo><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mrow></mrow><mo>-</mo><mrow><mn>20</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow><mo>+</mo><mrow><mn>10</mn><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mi/><mo>=</mo><mn>230</mn></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nFor example, the first two equations above can be written as\n{\\ifthenelse{\\boolean{twoColVersion}} {{\n", "itemtype": "equation", "pos": 74607, "prevtext": "\nThese equations are quadratic in the entries of the vector ${\\boldsymbol{{v}}}$, but they are linear in the entries of the matrix\n", "index": 89, "text": "\n\\[\n\t{\\boldsymbol{{X}}} = {\\boldsymbol{{v}}}{\\boldsymbol{{v}}}^{\\mathrm{T}} =\n\t\\begin{bmatrix}\n\t\tv_1^2 & v_1v_2 & v_1v_3 \\\\\n\t\tv_2v_1 & v_2^2 & v_2v_3 \\\\\n\t\tv_3v_1 & v_3v_2 & v_3^2\n\t\\end{bmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}={\\boldsymbol{{v}}}{\\boldsymbol{{v}}}^{\\mathrm{T}}=\\begin{%&#10;bmatrix}v_{1}^{2}&amp;v_{1}v_{2}&amp;v_{1}v_{3}\\\\&#10;v_{2}v_{1}&amp;v_{2}^{2}&amp;v_{2}v_{3}\\\\&#10;v_{3}v_{1}&amp;v_{3}v_{2}&amp;v_{3}^{2}\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mi>\ud835\udc7f</mi><mo>=</mo><mrow><mi>\ud835\udc97</mi><mo>\u2062</mo><msup><mi>\ud835\udc97</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msubsup><mi>v</mi><mn>1</mn><mn>2</mn></msubsup></mtd><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mtd><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow></mtd><mtd columnalign=\"center\"><msubsup><mi>v</mi><mn>2</mn><mn>2</mn></msubsup></mtd><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>3</mn></msub></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>3</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>1</mn></msub></mrow></mtd><mtd columnalign=\"center\"><mrow><msub><mi>v</mi><mn>3</mn></msub><mo>\u2062</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mtd><mtd columnalign=\"center\"><msubsup><mi>v</mi><mn>3</mn><mn>2</mn></msubsup></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": " with\n", "itemtype": "equation", "pos": -1, "prevtext": "\nFor example, the first two equations above can be written as\n{\\ifthenelse{\\boolean{twoColVersion}} {{\n", "index": 91, "text": "\\[     \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_1}\\right>=237 \\quad\\text{and}\\quad \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_2}\\right>=-4, \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"\\left&lt;{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_{1}}\\right&gt;=237\\quad\\text{and}%&#10;\\quad\\left&lt;{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_{2}}\\right&gt;=-4,\" display=\"block\"><mrow><mrow><mrow><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mn>1</mn></msub><mo>\u27e9</mo></mrow><mo>=</mo><mrow><mn>237</mn><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>and</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mn>2</mn></msub><mo>\u27e9</mo></mrow><mo>=</mo><mrow><mo>-</mo><mn>4</mn></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": " }} {{\n", "itemtype": "equation", "pos": -1, "prevtext": " with\n", "index": 93, "text": "\\[ \t{\\boldsymbol{{A}}}_1 = \t\\begin{bmatrix} \t\t4 & 12.5 & 8 \\\\ 12.5 & 12 & 3.5 \\\\ 8 & 3.5 & 7 \t\\end{bmatrix}, ~~ \t{\\boldsymbol{{A}}}_2 = \t\\begin{bmatrix} \t\t13 & -2.5 & 11.5 \\\\ -2.5 & -3 & 1.5 \\\\ 11.5 & 1.5 & 2 \t\\end{bmatrix}. \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{A}}}_{1}=\\begin{bmatrix}4&amp;12.5&amp;8\\\\&#10;12.5&amp;12&amp;3.5\\\\&#10;8&amp;3.5&amp;7\\end{bmatrix},~{}~{}{\\boldsymbol{{A}}}_{2}=\\begin{bmatrix}13&amp;-2.5&amp;11.5%&#10;\\\\&#10;-2.5&amp;-3&amp;1.5\\\\&#10;11.5&amp;1.5&amp;2\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>\ud835\udc68</mi><mn>1</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>4</mn></mtd><mtd columnalign=\"center\"><mn>12.5</mn></mtd><mtd columnalign=\"center\"><mn>8</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>12.5</mn></mtd><mtd columnalign=\"center\"><mn>12</mn></mtd><mtd columnalign=\"center\"><mn>3.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>8</mn></mtd><mtd columnalign=\"center\"><mn>3.5</mn></mtd><mtd columnalign=\"center\"><mn>7</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo rspace=\"9.1pt\">,</mo><mrow><msub><mi>\ud835\udc68</mi><mn>2</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>13</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>2.5</mn></mrow></mtd><mtd columnalign=\"center\"><mn>11.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>2.5</mn></mrow></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>3</mn></mrow></mtd><mtd columnalign=\"center\"><mn>1.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>11.5</mn></mtd><mtd columnalign=\"center\"><mn>1.5</mn></mtd><mtd columnalign=\"center\"><mn>2</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "}} }\nThe other four measurement matrices ${\\boldsymbol{{A}}}_3,\\ldots,{\\boldsymbol{{A}}}_6$ are defined similarly.  Using these six matrices to define ${\\mathcal A}:{ \\mathbb{R} }^{3\\times 3}\\rightarrow{ \\mathbb{R} }^6$ along with $y_1=-237,\\ldots,y_6 = 230$, we compute\n", "itemtype": "equation", "pos": -1, "prevtext": " }} {{\n", "index": 95, "text": "\\[     \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_1}\\right>=237,\\quad\\text{with}\\quad \t{\\boldsymbol{{A}}}_1 = \t\\begin{bmatrix} \t\t4 & 12.5 & 8 \\\\ 12.5 & 12 & 3.5 \\\\ 8 & 3.5 & 7 \t\\end{bmatrix}, \t\\quad \t\\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_2}\\right>=-4,\\quad\\text{with}\\quad \t{\\boldsymbol{{A}}}_2 = \t\\begin{bmatrix} \t\t13 & -2.5 & 11.5 \\\\ -2.5 & -3 & 1.5 \\\\ 11.5 & 1.5 & 2 \t\\end{bmatrix}. \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\left&lt;{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_{1}}\\right&gt;=237,\\quad\\text{with}%&#10;\\quad{\\boldsymbol{{A}}}_{1}=\\begin{bmatrix}4&amp;12.5&amp;8\\\\&#10;12.5&amp;12&amp;3.5\\\\&#10;8&amp;3.5&amp;7\\end{bmatrix},\\quad\\left&lt;{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_{2}}%&#10;\\right&gt;=-4,\\quad\\text{with}\\quad{\\boldsymbol{{A}}}_{2}=\\begin{bmatrix}13&amp;-2.5&amp;%&#10;11.5\\\\&#10;-2.5&amp;-3&amp;1.5\\\\&#10;11.5&amp;1.5&amp;2\\end{bmatrix}.\" display=\"block\"><mrow><mrow><mrow><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mn>1</mn></msub><mo>\u27e9</mo></mrow><mo>=</mo><mrow><mn>237</mn><mo rspace=\"12.5pt\">,</mo><mtext>with</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mrow><msub><mi>\ud835\udc68</mi><mn>1</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>4</mn></mtd><mtd columnalign=\"center\"><mn>12.5</mn></mtd><mtd columnalign=\"center\"><mn>8</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>12.5</mn></mtd><mtd columnalign=\"center\"><mn>12</mn></mtd><mtd columnalign=\"center\"><mn>3.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>8</mn></mtd><mtd columnalign=\"center\"><mn>3.5</mn></mtd><mtd columnalign=\"center\"><mn>7</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mn>2</mn></msub><mo>\u27e9</mo></mrow><mo>=</mo><mrow><mrow><mo>-</mo><mn>4</mn></mrow><mo rspace=\"12.5pt\">,</mo><mtext>with</mtext></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><msub><mi>\ud835\udc68</mi><mn>2</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>13</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>2.5</mn></mrow></mtd><mtd columnalign=\"center\"><mn>11.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>2.5</mn></mrow></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>3</mn></mrow></mtd><mtd columnalign=\"center\"><mn>1.5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>11.5</mn></mtd><mtd columnalign=\"center\"><mn>1.5</mn></mtd><mtd columnalign=\"center\"><mn>2</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhich has solution\n", "itemtype": "equation", "pos": 75962, "prevtext": "}} }\nThe other four measurement matrices ${\\boldsymbol{{A}}}_3,\\ldots,{\\boldsymbol{{A}}}_6$ are defined similarly.  Using these six matrices to define ${\\mathcal A}:{ \\mathbb{R} }^{3\\times 3}\\rightarrow{ \\mathbb{R} }^6$ along with $y_1=-237,\\ldots,y_6 = 230$, we compute\n", "index": 97, "text": "\n\\[\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}} \\|{\\boldsymbol{{X}}}\\|_*\\quad\\text{subject to}\\quad \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_\\ell}\\right>=y_\\ell,~~\\ell=1,\\ldots,6,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}\\|{\\boldsymbol{{X}}}\\|_{*%&#10;}\\quad\\text{subject to}\\quad\\left&lt;{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_{\\ell%&#10;}}\\right&gt;=y_{\\ell},~{}~{}\\ell=1,\\ldots,6,\" display=\"block\"><mrow><mrow><mrow><mrow><mrow><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub><mo>\u2062</mo><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>subject to</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow></mrow><mo>=</mo><msub><mi>y</mi><mi mathvariant=\"normal\">\u2113</mi></msub></mrow><mo rspace=\"9.1pt\">,</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>6</mn></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThe reader can verify that $v_1=-1,v_2=3,v_3=5$ is indeed a solution to the equations above.  This solution is also unique up to a sign change.\n\n\n\nWe see now that solving any system of quadratic equations is equivalent to finding a rank-1 matrix that obeys a set of linear equality constraints.  The low-rank recovery results discussed above can now be applied directly to the problem of solving such equations.  For example, we have seen in Section~\\ref{sec:gauss} that a linear operator defined by ${N}\\times{N}$ matrices ${\\boldsymbol{{A}}}_1,\\ldots{\\boldsymbol{{A}}}_{{L}}$ whose entries are populated by independent random variables will stably embed the set of rank-1 matrices when ${L}\\geq\\mathrm{Const}\\cdot{N}$.  This means that if we have a slightly over-determined system of quadratic equations with random coefficients which does in fact have a solution, then we can find that solution by applying any one of a number of low-rank recovery algorithms.\n\n\n\n\\subsection{Phase retrieval}\n\nQuadratic and bilinear problems that arise in applications typically have special structure in the equation coefficients ${\\boldsymbol{{A}}}_m$.  One type of problem that has received considerable attention in the literature recently is recovering a vector ${\\boldsymbol{{v}}}_0\\in{R}^{{N}}$ from observations of the {\\em magnitude} of a series of linear measurements:\n\n", "itemtype": "equation", "pos": 76178, "prevtext": "\nwhich has solution\n", "index": 99, "text": "\n\\[\n\t{\\boldsymbol{{X}}}^\\star =\n\t\\begin{bmatrix}\n\t\t1 & -3 & 5 \\\\ -3 & 9 & 15 \\\\ -5 & 15 & 25\n\t\\end{bmatrix}\n\t=\n\t\\begin{bmatrix}\n\t\t-1 \\\\ 3 \\\\ 5\n\t\\end{bmatrix}\t\n\t\\begin{array}{@{}c@{}}{\n  \t\t\\begin{bmatrix}\n    \t\t\t-1 & 3 & 5\n  \t\t\\end{bmatrix}}\\\\\\\\\n\t\\end{array}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"{\\boldsymbol{{X}}}^{\\star}=\\begin{bmatrix}1&amp;-3&amp;5\\\\&#10;-3&amp;9&amp;15\\\\&#10;-5&amp;15&amp;25\\end{bmatrix}=\\begin{bmatrix}-1\\\\&#10;3\\\\&#10;5\\end{bmatrix}\\begin{array}[]{@{}c@{}}{\\begin{bmatrix}-1&amp;3&amp;5\\end{bmatrix}}\\\\&#10;\\\\&#10;\\end{array}.\" display=\"block\"><mrow><mrow><msup><mi>\ud835\udc7f</mi><mo>\u22c6</mo></msup><mo>=</mo><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>3</mn></mrow></mtd><mtd columnalign=\"center\"><mn>5</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>3</mn></mrow></mtd><mtd columnalign=\"center\"><mn>9</mn></mtd><mtd columnalign=\"center\"><mn>15</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>5</mn></mrow></mtd><mtd columnalign=\"center\"><mn>15</mn></mtd><mtd columnalign=\"center\"><mn>25</mn></mtd></mtr></mtable><mo>]</mo></mrow><mo>=</mo><mrow><mrow><mo>[</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>3</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>5</mn></mtd></mtr></mtable><mo>]</mo></mrow><mo>\u2062</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo>[</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"center\"><mn>3</mn></mtd><mtd columnalign=\"center\"><mn>5</mn></mtd></mtr></mtable><mo>]</mo></mrow></mtd></mtr><mtr><mtd/></mtr></mtable></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nIf the $\\{{\\boldsymbol{{a}}}_\\ell\\}$ span ${R}^{N}$ (which will happen for a generic set of measurement vector when ${L}\\geq{N}$), then knowing the signs (or phase, if the vectors are complex) of the\n$\\left<{{\\boldsymbol{{v}}}_0,{\\boldsymbol{{a}}}_\\ell}\\right>$ along with the $y_\\ell$ would be enough to recover ${\\boldsymbol{{v}}}_0$ --- for this reason, this problem is referred to as {\\em phase retrieval} in the literature.\n\nBy squaring the observations in \\eqref{eq:magmeas}, we see that\n\n", "itemtype": "equation", "pos": 77805, "prevtext": "\nThe reader can verify that $v_1=-1,v_2=3,v_3=5$ is indeed a solution to the equations above.  This solution is also unique up to a sign change.\n\n\n\nWe see now that solving any system of quadratic equations is equivalent to finding a rank-1 matrix that obeys a set of linear equality constraints.  The low-rank recovery results discussed above can now be applied directly to the problem of solving such equations.  For example, we have seen in Section~\\ref{sec:gauss} that a linear operator defined by ${N}\\times{N}$ matrices ${\\boldsymbol{{A}}}_1,\\ldots{\\boldsymbol{{A}}}_{{L}}$ whose entries are populated by independent random variables will stably embed the set of rank-1 matrices when ${L}\\geq\\mathrm{Const}\\cdot{N}$.  This means that if we have a slightly over-determined system of quadratic equations with random coefficients which does in fact have a solution, then we can find that solution by applying any one of a number of low-rank recovery algorithms.\n\n\n\n\\subsection{Phase retrieval}\n\nQuadratic and bilinear problems that arise in applications typically have special structure in the equation coefficients ${\\boldsymbol{{A}}}_m$.  One type of problem that has received considerable attention in the literature recently is recovering a vector ${\\boldsymbol{{v}}}_0\\in{R}^{{N}}$ from observations of the {\\em magnitude} of a series of linear measurements:\n\n", "index": 101, "text": "\\begin{equation}\n\t\\label{eq:magmeas}\n\ty_\\ell = |\\left<{{\\boldsymbol{{v}}}_0,{\\boldsymbol{{a}}}_\\ell}\\right>|,\\quad \\ell=1,\\ldots,{L}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E27.m1\" class=\"ltx_Math\" alttext=\"y_{\\ell}=|\\left&lt;{{\\boldsymbol{{v}}}_{0},{\\boldsymbol{{a}}}_{\\ell}}\\right&gt;|,%&#10;\\quad\\ell=1,\\ldots,{L}.\" display=\"block\"><mrow><mrow><mrow><msub><mi>y</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mo>\u27e8</mo><msub><mi>\ud835\udc97</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>L</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere both ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ and ${\\boldsymbol{{A}}}_\\ell ={\\boldsymbol{{a}}}_\\ell{\\boldsymbol{{a}}}_\\ell^{\\mathrm{T}}$ are rank 1 and symmetric.  This means that the equation coefficients in the quadratic phase retrieval problem are structured in that they can be arranged into rank 1 matrices.\n\nIn \\cite{balan06si}, it is shown that for generic ${\\boldsymbol{{a}}}_\\ell$, if ${L}\\geq 2N-1$, then ${\\boldsymbol{{v}}}_0$ is the only vector (up to a sign) that has the measurements \\eqref{eq:magmeas}.  This bound is tight, as for ${L} < 2N-1$ there is no set of ${\\boldsymbol{{a}}}_\\ell$ such that ${\\boldsymbol{{v}}}_0$ is uniquely specified.\\footnote{The threshold becomes ${L}\\lessgtr 4N-2$ when the vectors are complex.}\n\nThe connection between phase retrieval and low-rank recovery was popularized in~\\cite{candes13ph}, which gave the name {\\em PhaseLift} to the method of treating the nonlinear inverse problem \\eqref{eq:magmeas} as the rank-constrained linear inverse problem \\eqref{eq:lifting} and showed that\n\n", "itemtype": "equation", "pos": 78448, "prevtext": "\nIf the $\\{{\\boldsymbol{{a}}}_\\ell\\}$ span ${R}^{N}$ (which will happen for a generic set of measurement vector when ${L}\\geq{N}$), then knowing the signs (or phase, if the vectors are complex) of the\n$\\left<{{\\boldsymbol{{v}}}_0,{\\boldsymbol{{a}}}_\\ell}\\right>$ along with the $y_\\ell$ would be enough to recover ${\\boldsymbol{{v}}}_0$ --- for this reason, this problem is referred to as {\\em phase retrieval} in the literature.\n\nBy squaring the observations in \\eqref{eq:magmeas}, we see that\n\n", "index": 103, "text": "\\begin{equation}\n\t\\label{eq:lifting}\n    {\\ifthenelse{\\boolean{twoColVersion}} {{     |\\left<{{\\boldsymbol{{v}}}_0,{\\boldsymbol{{a}}}_\\ell}\\right>|^2 = {\\boldsymbol{{v}}}_0^{\\mathrm{T}}{\\boldsymbol{{a}}}_\\ell{\\boldsymbol{{a}}}_\\ell^{\\mathrm{T}}{\\boldsymbol{{v}}}_0 = \\left<{{\\boldsymbol{{X}}}_0,{\\boldsymbol{{A}}}_\\ell}\\right>,}} {{|\\left<{{\\boldsymbol{{v}}}_0,{\\boldsymbol{{a}}}_\\ell}\\right>|^2 = {\\boldsymbol{{v}}}_0^{\\mathrm{T}}{\\boldsymbol{{a}}}_\\ell{\\boldsymbol{{a}}}_\\ell^{\\mathrm{T}}{\\boldsymbol{{v}}}_0 = \\left<{{\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}},{\\boldsymbol{{a}}}_\\ell{\\boldsymbol{{a}}}_\\ell^{\\mathrm{T}}}\\right> = \\left<{{\\boldsymbol{{X}}}_0,{\\boldsymbol{{A}}}_\\ell}\\right>,}} }\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E28.m1\" class=\"ltx_Math\" alttext=\"{{|\\left&lt;{{\\boldsymbol{{v}}}_{0},{\\boldsymbol{{a}}}_{\\ell}}\\right&gt;|^{2}={%&#10;\\boldsymbol{{v}}}_{0}^{\\mathrm{T}}{\\boldsymbol{{a}}}_{\\ell}{\\boldsymbol{{a}}}_%&#10;{\\ell}^{\\mathrm{T}}{\\boldsymbol{{v}}}_{0}=\\left&lt;{{\\boldsymbol{{v}}}_{0}{%&#10;\\boldsymbol{{v}}}_{0}^{\\mathrm{T}},{\\boldsymbol{{a}}}_{\\ell}{\\boldsymbol{{a}}}%&#10;_{\\ell}^{\\mathrm{T}}}\\right&gt;=\\left&lt;{{\\boldsymbol{{X}}}_{0},{\\boldsymbol{{A}}}_%&#10;{\\ell}}\\right&gt;,}}\" display=\"block\"><mrow><mrow><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mo>\u27e8</mo><msub><mi>\ud835\udc97</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow><mo stretchy=\"false\">|</mo></mrow><mn>2</mn></msup><mo>=</mo><mrow><msubsup><mi>\ud835\udc97</mi><mn>0</mn><mi mathvariant=\"normal\">T</mi></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi><mi mathvariant=\"normal\">T</mi></msubsup><mo>\u2062</mo><msub><mi>\ud835\udc97</mi><mn>0</mn></msub></mrow><mo>=</mo><mrow><mo>\u27e8</mo><mrow><msub><mi>\ud835\udc97</mi><mn>0</mn></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc97</mi><mn>0</mn><mi mathvariant=\"normal\">T</mi></msubsup></mrow><mo>,</mo><mrow><msub><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><msubsup><mi>\ud835\udc82</mi><mi mathvariant=\"normal\">\u2113</mi><mi mathvariant=\"normal\">T</mi></msubsup></mrow><mo>\u27e9</mo></mrow><mo>=</mo><mrow><mo>\u27e8</mo><msub><mi>\ud835\udc7f</mi><mn>0</mn></msub><mo>,</mo><msub><mi>\ud835\udc68</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nsuccessfully recovers ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ when ${L}\\gtrsim{N}\\log{N}$.  In \\cite{demanet14st}, it was shown that the nuclear norm minimization above is actually unnecessary: the rank-1 ${\\boldsymbol{{X}}}_0$ is the only matrix that is both in the SDP cone (${\\boldsymbol{{X}}}_0\\succeq{\\bf 0}$) and obeys the linear constraints.  The recovery task, then, is just to find a matrix that obeys these sets of constraints --- \\cite{demanet14st} also shows that a straightforward projection onto convex sets (POCS) algorithm has linear convergence.  Recent work in \\cite{candes14so} has refined these results to show that ${L}\\gtrsim N$ observations are sufficient.\n\n\nOnce the ${\\boldsymbol{{a}}}_\\ell$ are chosen, they will work {\\em uniformly} well (with high probability) for all vectors ${\\boldsymbol{{v}}}_0$ \\cite{kueng14lo}.  That work also shows that the uniform recovery results extend to target matrices ${\\boldsymbol{{X}}}_0$ with general rank ${R}$.  A related result appears in \\cite{chen15ex}, which examines this problem in the context of estimating a (low-rank) covariance matrix from {\\em sketches} of the data vectors.\n\nAs with many of the analytical results we have discussed, the randomness of the $\\{{\\boldsymbol{{a}}}_\\ell\\}$ plays a large role in establishing the effectiveness of the recovery technique.  In practice, the types of measurements that can be made are determined by the physics of the measurement system, and taking the ${\\boldsymbol{{a}}}_\\ell$ to be isotropic random vectors is not a realistic model.  However, it is sometimes possible to alter the acquisition system slightly to inject enough diversity in the ${\\boldsymbol{{a}}}_\\ell$ to make the recovery effective.  This is analyzed in detail in \\cite{candes15ph}, where the acquisition process consists of first modulating a signal with a small number of pseudo-random patterns, then measuring the magnitudes of the Fourier transform of the result.  Another example can be found in \\cite{eldar15sp}, where magnitudes of the short-time Fourier transform are measured, a problem which arises in several different applications in signal processing and optics.\n\nThe lifting framework described above is not the only path to a convex relaxation.  The {\\em PhaseCut} method, proposed in \\cite{waldspurger15ph},  casts the recovery problem as an equality constrained quadratic program, and then uses a well-known  relaxation for this type of problem.  Interestingly, although the PhaseCut and PhaseLift relaxations are in general different, they recover the correct ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ under identical conditions. \n\nFinally, there are mathematical guarantees for other algorithms for solving the nonlinear inverse problem in \\eqref{eq:magmeas}.  Algorithms very similar to the alternating minimization algorithm from Section~\\ref{sec:alternatingprojections} have been used for phase retrieval since the 1970s \\cite{fienup82ph}.  In \\cite{netrapalli13ph}, a theoretical analysis of alternating projections for phase retrieval was given (along with an intelligent method for initializing the algorithm) that gives a guarantee of effectiveness when ${L}\\gtrsim {N}\\log^3{N}$.  Recent work in \\cite{candes14ph} shows that a local descent algorithm again coupled with a smart initialization is as effective for phase retrieval as the convex relaxations above while being far more computationally efficient.\nAlgorithms of this type also have performance guarantees for recovering rank-$R$ matrices from measurements of the form \\eqref{eq:lifting} \\cite{WhiteSW_Local}.\n\nAn extended survey of the recent work on this problem, including a more in depth discussion of most of the results above, can be found in \\cite{shechtman15ph}.\n\n\n\n\\subsection{Blind deconvolution}\n\nPerhaps an even more important and prevalent problem, especially in the signal processing and communications communities, is {\\em blind deconvolution}.  Here we observe the (discrete-time) convolution of two signals,\n\n", "itemtype": "equation", "pos": 80249, "prevtext": "\nwhere both ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ and ${\\boldsymbol{{A}}}_\\ell ={\\boldsymbol{{a}}}_\\ell{\\boldsymbol{{a}}}_\\ell^{\\mathrm{T}}$ are rank 1 and symmetric.  This means that the equation coefficients in the quadratic phase retrieval problem are structured in that they can be arranged into rank 1 matrices.\n\nIn \\cite{balan06si}, it is shown that for generic ${\\boldsymbol{{a}}}_\\ell$, if ${L}\\geq 2N-1$, then ${\\boldsymbol{{v}}}_0$ is the only vector (up to a sign) that has the measurements \\eqref{eq:magmeas}.  This bound is tight, as for ${L} < 2N-1$ there is no set of ${\\boldsymbol{{a}}}_\\ell$ such that ${\\boldsymbol{{v}}}_0$ is uniquely specified.\\footnote{The threshold becomes ${L}\\lessgtr 4N-2$ when the vectors are complex.}\n\nThe connection between phase retrieval and low-rank recovery was popularized in~\\cite{candes13ph}, which gave the name {\\em PhaseLift} to the method of treating the nonlinear inverse problem \\eqref{eq:magmeas} as the rank-constrained linear inverse problem \\eqref{eq:lifting} and showed that\n\n", "index": 105, "text": "\\begin{align*}\n\t{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~\\|{\\boldsymbol{{X}}}\\|_* ~~ \\text{subject to} ~~ \\left<{{\\boldsymbol{{X}}},{\\boldsymbol{{A}}}_\\ell}\\right>&=y_\\ell^2,~\\ell=1,\\ldots,{L}, \\\\\n\t{\\boldsymbol{{X}}}&\\succeq{\\bf 0},\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\operatorname{\\text{minimize}}}_{{\\boldsymbol{{X}}}}~{}\\|{%&#10;\\boldsymbol{{X}}}\\|_{*}~{}~{}\\text{subject to}~{}~{}\\left&lt;{{\\boldsymbol{{X}}},%&#10;{\\boldsymbol{{A}}}_{\\ell}}\\right&gt;\" display=\"inline\"><mrow><mpadded width=\"+3.3pt\"><msub><mtext>minimize</mtext><mi>\ud835\udc7f</mi></msub></mpadded><mo>\u2062</mo><mpadded width=\"+6.6pt\"><msub><mrow><mo>\u2225</mo><mi>\ud835\udc7f</mi><mo>\u2225</mo></mrow><mo>*</mo></msub></mpadded><mo>\u2062</mo><mpadded width=\"+6.6pt\"><mtext>subject to</mtext></mpadded><mo>\u2062</mo><mrow><mo>\u27e8</mo><mi>\ud835\udc7f</mi><mo>,</mo><msub><mi>\ud835\udc68</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=y_{\\ell}^{2},~{}\\ell=1,\\ldots,{L},\" display=\"inline\"><mrow><mrow><mrow><mi/><mo>=</mo><msubsup><mi>y</mi><mi mathvariant=\"normal\">\u2113</mi><mn>2</mn></msubsup></mrow><mo rspace=\"5.8pt\">,</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mi>L</mi></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{{X}}}\" display=\"inline\"><mi>\ud835\udc7f</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\succeq{\\bf 0},\" display=\"inline\"><mrow><mrow><mi/><mo>\u2ab0</mo><mn/></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nand want to recover ${\\boldsymbol{{h}}}$ and ${\\boldsymbol{{s}}}$.  Each sample of ${\\boldsymbol{{y}}}$ is a different linear combination of entries in ${\\boldsymbol{{s}}}$ multiplied by entries in ${\\boldsymbol{{h}}}$, and so this is a {\\em bilinear} inverse problem.  It can be recast (``lifted'') into a rank-constrained linear inverse problem in almost exactly the same way described above for quadratic problems.  The only difference is that we want to recover a non-symmetric rank-1 matrix.  For the convolution in \\eqref{eq:convolution}, each sample is the sum along a skew-diagonal of ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$; this is illustrated in Figure~\\ref{fig:matrixtomo1}.\n\n\n\\begin{figure}\n\t\\centering\n\t\\includegraphics[scale=0.25]{matrix-tomo1}\n\t\\caption{\\small\\sl Each sample of the convolution ${\\boldsymbol{{y}}}={\\boldsymbol{{s}}}\\star{\\boldsymbol{{h}}}$ in \\eqref{eq:convolution} is a sum along a skew-diagonal of the rank-1 matrix ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$.}\n\t\\label{fig:matrixtomo1}\n\\end{figure}\n\n\nThis is in general a intractable problem without at least partial information about ${\\boldsymbol{{h}}}$ and/or ${\\boldsymbol{{s}}}$.  We will start with only the simplest of assumptions --- that $h[k]$ takes non-zero values only on $k=0,\\ldots,K-1$ and that $s[n]$ takes non-zero values only on $n=0,\\ldots,{N}-1$.  The convolution, then, will be non-zero only on $\\ell = 0,\\ldots,{L}-1={N}+K-1$.  In this case, if we translate our observations into the Fourier domain, then we can naturally express them as inner products against known rank-1 matrices.  The discrete-time Fourier transform (DTFT) of signal $x[n]$ with arbitrary length is given by\n", "itemtype": "equation", "pos": 84581, "prevtext": "\nsuccessfully recovers ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ when ${L}\\gtrsim{N}\\log{N}$.  In \\cite{demanet14st}, it was shown that the nuclear norm minimization above is actually unnecessary: the rank-1 ${\\boldsymbol{{X}}}_0$ is the only matrix that is both in the SDP cone (${\\boldsymbol{{X}}}_0\\succeq{\\bf 0}$) and obeys the linear constraints.  The recovery task, then, is just to find a matrix that obeys these sets of constraints --- \\cite{demanet14st} also shows that a straightforward projection onto convex sets (POCS) algorithm has linear convergence.  Recent work in \\cite{candes14so} has refined these results to show that ${L}\\gtrsim N$ observations are sufficient.\n\n\nOnce the ${\\boldsymbol{{a}}}_\\ell$ are chosen, they will work {\\em uniformly} well (with high probability) for all vectors ${\\boldsymbol{{v}}}_0$ \\cite{kueng14lo}.  That work also shows that the uniform recovery results extend to target matrices ${\\boldsymbol{{X}}}_0$ with general rank ${R}$.  A related result appears in \\cite{chen15ex}, which examines this problem in the context of estimating a (low-rank) covariance matrix from {\\em sketches} of the data vectors.\n\nAs with many of the analytical results we have discussed, the randomness of the $\\{{\\boldsymbol{{a}}}_\\ell\\}$ plays a large role in establishing the effectiveness of the recovery technique.  In practice, the types of measurements that can be made are determined by the physics of the measurement system, and taking the ${\\boldsymbol{{a}}}_\\ell$ to be isotropic random vectors is not a realistic model.  However, it is sometimes possible to alter the acquisition system slightly to inject enough diversity in the ${\\boldsymbol{{a}}}_\\ell$ to make the recovery effective.  This is analyzed in detail in \\cite{candes15ph}, where the acquisition process consists of first modulating a signal with a small number of pseudo-random patterns, then measuring the magnitudes of the Fourier transform of the result.  Another example can be found in \\cite{eldar15sp}, where magnitudes of the short-time Fourier transform are measured, a problem which arises in several different applications in signal processing and optics.\n\nThe lifting framework described above is not the only path to a convex relaxation.  The {\\em PhaseCut} method, proposed in \\cite{waldspurger15ph},  casts the recovery problem as an equality constrained quadratic program, and then uses a well-known  relaxation for this type of problem.  Interestingly, although the PhaseCut and PhaseLift relaxations are in general different, they recover the correct ${\\boldsymbol{{X}}}_0={\\boldsymbol{{v}}}_0{\\boldsymbol{{v}}}_0^{\\mathrm{T}}$ under identical conditions. \n\nFinally, there are mathematical guarantees for other algorithms for solving the nonlinear inverse problem in \\eqref{eq:magmeas}.  Algorithms very similar to the alternating minimization algorithm from Section~\\ref{sec:alternatingprojections} have been used for phase retrieval since the 1970s \\cite{fienup82ph}.  In \\cite{netrapalli13ph}, a theoretical analysis of alternating projections for phase retrieval was given (along with an intelligent method for initializing the algorithm) that gives a guarantee of effectiveness when ${L}\\gtrsim {N}\\log^3{N}$.  Recent work in \\cite{candes14ph} shows that a local descent algorithm again coupled with a smart initialization is as effective for phase retrieval as the convex relaxations above while being far more computationally efficient.\nAlgorithms of this type also have performance guarantees for recovering rank-$R$ matrices from measurements of the form \\eqref{eq:lifting} \\cite{WhiteSW_Local}.\n\nAn extended survey of the recent work on this problem, including a more in depth discussion of most of the results above, can be found in \\cite{shechtman15ph}.\n\n\n\n\\subsection{Blind deconvolution}\n\nPerhaps an even more important and prevalent problem, especially in the signal processing and communications communities, is {\\em blind deconvolution}.  Here we observe the (discrete-time) convolution of two signals,\n\n", "index": 107, "text": "\\begin{equation}\n\t\\label{eq:convolution}\n\ty[\\ell] = \\sum_{n}h[n]s[\\ell-n],\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E29.m1\" class=\"ltx_Math\" alttext=\"y[\\ell]=\\sum_{n}h[n]s[\\ell-n],\" display=\"block\"><mrow><mrow><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>n</mi></munder><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>-</mo><mi>n</mi></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\t\nThe DTFT of the observations ${\\boldsymbol{{y}}}$, after we zero-pad it outside its support, is the point-by-point multiplication of the DTFTs of ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$ (also after zero-padding).  Since all three signals are zero outside of $\\{0,\\ldots,{L}-1\\}$, we can evaluate the DTFT of the observations at ${L}$ equally spaced frequencies between $-\\pi$ and $\\pi$ by computing the vector inner products\n", "itemtype": "equation", "pos": -1, "prevtext": "\nand want to recover ${\\boldsymbol{{h}}}$ and ${\\boldsymbol{{s}}}$.  Each sample of ${\\boldsymbol{{y}}}$ is a different linear combination of entries in ${\\boldsymbol{{s}}}$ multiplied by entries in ${\\boldsymbol{{h}}}$, and so this is a {\\em bilinear} inverse problem.  It can be recast (``lifted'') into a rank-constrained linear inverse problem in almost exactly the same way described above for quadratic problems.  The only difference is that we want to recover a non-symmetric rank-1 matrix.  For the convolution in \\eqref{eq:convolution}, each sample is the sum along a skew-diagonal of ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$; this is illustrated in Figure~\\ref{fig:matrixtomo1}.\n\n\n\\begin{figure}\n\t\\centering\n\t\\includegraphics[scale=0.25]{matrix-tomo1}\n\t\\caption{\\small\\sl Each sample of the convolution ${\\boldsymbol{{y}}}={\\boldsymbol{{s}}}\\star{\\boldsymbol{{h}}}$ in \\eqref{eq:convolution} is a sum along a skew-diagonal of the rank-1 matrix ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$.}\n\t\\label{fig:matrixtomo1}\n\\end{figure}\n\n\nThis is in general a intractable problem without at least partial information about ${\\boldsymbol{{h}}}$ and/or ${\\boldsymbol{{s}}}$.  We will start with only the simplest of assumptions --- that $h[k]$ takes non-zero values only on $k=0,\\ldots,K-1$ and that $s[n]$ takes non-zero values only on $n=0,\\ldots,{N}-1$.  The convolution, then, will be non-zero only on $\\ell = 0,\\ldots,{L}-1={N}+K-1$.  In this case, if we translate our observations into the Fourier domain, then we can naturally express them as inner products against known rank-1 matrices.  The discrete-time Fourier transform (DTFT) of signal $x[n]$ with arbitrary length is given by\n", "index": 109, "text": "\n\\[\n\t\\hat{x}(\\omega) = \\sum_{n=-\\infty}^\\infty x[n]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega n},\\quad -\\pi\\leq\\omega<\\pi.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\hat{x}(\\omega)=\\sum_{n=-\\infty}^{\\infty}x[n]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega&#10;n%&#10;},\\quad-\\pi\\leq\\omega&lt;\\pi.\" display=\"block\"><mrow><mrow><mrow><mrow><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c9</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>n</mi><mo>=</mo><mrow><mo>-</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></mrow><mi mathvariant=\"normal\">\u221e</mi></munderover><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mi mathvariant=\"normal\">j</mi><mo>\u2062</mo><mi>\u03c9</mi><mo>\u2062</mo><mi>n</mi></mrow></mrow></msup></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mo>-</mo><mi>\u03c0</mi></mrow><mo>\u2264</mo><mi>\u03c9</mi><mo>&lt;</mo><mi>\u03c0</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere $\\omega_\\ell = 2\\pi(\\ell-1)/{L}$ for $\\ell=0,\\ldots,{L}-1$ and ${\\boldsymbol{{f}}}_{\\ell,{L}}$ is the Fourier vector in ${\\mathbb{C}}^{L}$ that has entries $f_{\\ell,{L}}[n] = {\\mathrm{e}}^{{\\mathrm{j}}\\omega_\\ell n},~n=0,\\ldots,{L}-1$.  All ${L}$ of these inner products can be produced quickly by applying a fast Fourier transform (FFT) to the vector ${\\boldsymbol{{y}}}$.  Using ${\\boldsymbol{{f}}}_{\\ell,{N}}\\in{\\mathbb{C}}^{N}$ and ${\\boldsymbol{{f}}}_{\\ell,K}\\in{\\mathbb{C}}^K$ for length ${N}$ and $K$ Fourier vectors (still at frequencies $\\omega_\\ell$), we can write\n\n", "itemtype": "equation", "pos": 86926, "prevtext": "\t\nThe DTFT of the observations ${\\boldsymbol{{y}}}$, after we zero-pad it outside its support, is the point-by-point multiplication of the DTFTs of ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$ (also after zero-padding).  Since all three signals are zero outside of $\\{0,\\ldots,{L}-1\\}$, we can evaluate the DTFT of the observations at ${L}$ equally spaced frequencies between $-\\pi$ and $\\pi$ by computing the vector inner products\n", "index": 111, "text": "\n\\[\n\t\\hat{y}[\\ell] := \\hat{y}(\\omega_\\ell) = \\left<{{\\boldsymbol{{y}}}, {\\boldsymbol{{f}}}_{\\ell,{L}}}\\right>, \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"\\hat{y}[\\ell]:=\\hat{y}(\\omega_{\\ell})=\\left&lt;{{\\boldsymbol{{y}}},{\\boldsymbol{{%&#10;f}}}_{\\ell,{L}}}\\right&gt;,\" display=\"block\"><mrow><mrow><mrow><mover accent=\"true\"><mi>y</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>:=</mo><mrow><mover accent=\"true\"><mi>y</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>\u27e8</mo><mi>\ud835\udc9a</mi><mo>,</mo><msub><mi>\ud835\udc87</mi><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>L</mi></mrow></msub><mo>\u27e9</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nFor real-valued ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$, the real and imaginary parts of $\\hat{y}(\\omega_\\ell)$ yield inner products against two real-valued rank-1 matrices:\n", "itemtype": "equation", "pos": 87622, "prevtext": "\nwhere $\\omega_\\ell = 2\\pi(\\ell-1)/{L}$ for $\\ell=0,\\ldots,{L}-1$ and ${\\boldsymbol{{f}}}_{\\ell,{L}}$ is the Fourier vector in ${\\mathbb{C}}^{L}$ that has entries $f_{\\ell,{L}}[n] = {\\mathrm{e}}^{{\\mathrm{j}}\\omega_\\ell n},~n=0,\\ldots,{L}-1$.  All ${L}$ of these inner products can be produced quickly by applying a fast Fourier transform (FFT) to the vector ${\\boldsymbol{{y}}}$.  Using ${\\boldsymbol{{f}}}_{\\ell,{N}}\\in{\\mathbb{C}}^{N}$ and ${\\boldsymbol{{f}}}_{\\ell,K}\\in{\\mathbb{C}}^K$ for length ${N}$ and $K$ Fourier vectors (still at frequencies $\\omega_\\ell$), we can write\n\n", "index": 113, "text": "\\begin{align*}\n\t\\hat{y}[\\ell] &= \\hat{s}(\\omega_\\ell)\\cdot \\hat{h}(\\omega_\\ell) \\\\\n\t&= \\left(\\sum_{n=0}^{N-1}s[n]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega_\\ell n}\\right)\\left(\\sum_{k=0}^{K-1}h[k]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega_\\ell k}\\right) \\\\\n\t&= \\left<{{\\boldsymbol{{s}}},{\\boldsymbol{{f}}}_{\\ell,N}}\\right>\\left<{{\\boldsymbol{{h}}},{\\boldsymbol{{f}}}_{\\ell,K}}\\right> \\\\\n\t&= \\left<{{\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}},{\\boldsymbol{{f}}}_{\\ell,N}{\\mkern 1.5mu\\overline{\\mkern-1.5mu{{\\boldsymbol{{f}}}}\\mkern-1.5mu}\\mkern 1.5mu}_{\\ell,K}^{\\mathrm{H}}}\\right>.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\hat{y}[\\ell]\" display=\"inline\"><mrow><mover accent=\"true\"><mi>y</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\hat{s}(\\omega_{\\ell})\\cdot\\hat{h}(\\omega_{\\ell})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mover accent=\"true\"><mi>s</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u22c5</mo><mover accent=\"true\"><mi>h</mi><mo stretchy=\"false\">^</mo></mover></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\left(\\sum_{n=0}^{N-1}s[n]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega_{%&#10;\\ell}n}\\right)\\left(\\sum_{k=0}^{K-1}h[k]{\\mathrm{e}}^{-{\\mathrm{j}}\\omega_{%&#10;\\ell}k}\\right)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo>(</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><mi>s</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mi mathvariant=\"normal\">j</mi><mo>\u2062</mo><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mi>n</mi></mrow></mrow></msup></mrow></mrow><mo>)</mo></mrow><mo>\u2062</mo><mrow><mo>(</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>K</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><msup><mi mathvariant=\"normal\">e</mi><mrow><mo>-</mo><mrow><mi mathvariant=\"normal\">j</mi><mo>\u2062</mo><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mi>k</mi></mrow></mrow></msup></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\left&lt;{{\\boldsymbol{{s}}},{\\boldsymbol{{f}}}_{\\ell,N}}\\right&gt;%&#10;\\left&lt;{{\\boldsymbol{{h}}},{\\boldsymbol{{f}}}_{\\ell,K}}\\right&gt;\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo>\u27e8</mo><mi>\ud835\udc94</mi><mo>,</mo><msub><mi>\ud835\udc87</mi><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>N</mi></mrow></msub><mo>\u27e9</mo></mrow><mo>\u2062</mo><mrow><mo>\u27e8</mo><mi>\ud835\udc89</mi><mo>,</mo><msub><mi>\ud835\udc87</mi><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>K</mi></mrow></msub><mo>\u27e9</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\left&lt;{{\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}},{%&#10;\\boldsymbol{{f}}}_{\\ell,N}{\\mkern 1.5mu \\overline{\\mkern-1.5mu {{\\boldsymbol{{%&#10;f}}}}\\mkern-1.5mu }\\mkern 1.5mu }_{\\ell,K}^{\\mathrm{H}}}\\right&gt;.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo>\u27e8</mo><mrow><mi>\ud835\udc94</mi><mo>\u2062</mo><msup><mi>\ud835\udc89</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo>,</mo><mrow><msub><mi>\ud835\udc87</mi><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>N</mi></mrow></msub><mo>\u2062</mo><msubsup><mover accent=\"true\"><mi>\ud835\udc87</mi><mo>\u00af</mo></mover><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>,</mo><mi>K</mi></mrow><mi mathvariant=\"normal\">H</mi></msubsup></mrow><mo>\u27e9</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nwhere ${\\boldsymbol{{A}}}_\\ell,{\\boldsymbol{{B}}}_\\ell$ are ${N}\\times K$ matrices with entries\n", "itemtype": "equation", "pos": 88384, "prevtext": "\nFor real-valued ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$, the real and imaginary parts of $\\hat{y}(\\omega_\\ell)$ yield inner products against two real-valued rank-1 matrices:\n", "index": 115, "text": "\n\\[\n\t\\operatorname{Re}\\left\\{{\\hat{y}[\\ell]}\\right\\} = \\left<{{\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}},{\\boldsymbol{{A}}}_\\ell}\\right>,\\quad \\operatorname{Im}\\left\\{{\\hat{y}[\\ell]}\\right\\} = \\left<{{\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}},{\\boldsymbol{{B}}}_\\ell}\\right>,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m1\" class=\"ltx_Math\" alttext=\"\\operatorname{Re}\\left\\{{\\hat{y}[\\ell]}\\right\\}=\\left&lt;{{\\boldsymbol{{s}}}{%&#10;\\boldsymbol{{h}}}^{\\mathrm{T}},{\\boldsymbol{{A}}}_{\\ell}}\\right&gt;,\\quad%&#10;\\operatorname{Im}\\left\\{{\\hat{y}[\\ell]}\\right\\}=\\left&lt;{{\\boldsymbol{{s}}}{%&#10;\\boldsymbol{{h}}}^{\\mathrm{T}},{\\boldsymbol{{B}}}_{\\ell}}\\right&gt;,\" display=\"block\"><mrow><mrow><mrow><mrow><mo>Re</mo><mo>\u2061</mo><mrow><mo>{</mo><mrow><mover accent=\"true\"><mi>y</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>}</mo></mrow></mrow><mo>=</mo><mrow><mo>\u27e8</mo><mrow><mi>\ud835\udc94</mi><mo>\u2062</mo><msup><mi>\ud835\udc89</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo>,</mo><msub><mi>\ud835\udc68</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><mo>Im</mo><mo>\u2061</mo><mrow><mo>{</mo><mrow><mover accent=\"true\"><mi>y</mi><mo stretchy=\"false\">^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>}</mo></mrow></mrow><mo>=</mo><mrow><mo>\u27e8</mo><mrow><mi>\ud835\udc94</mi><mo>\u2062</mo><msup><mi>\ud835\udc89</mi><mi mathvariant=\"normal\">T</mi></msup></mrow><mo>,</mo><msub><mi>\ud835\udc69</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u27e9</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\n\nWith only the finite support assumption, the blind deconvolution problem is still fundamentally hard.  Past even the trivial ambiguity of replacing ${\\boldsymbol{{s}}},{\\boldsymbol{{h}}}$ with $\\alpha{\\boldsymbol{{s}}},\\alpha^{-1}{\\boldsymbol{{h}}}$ for some $\\alpha\\not=0$, there will typically be many pairs of vectors consistent with the measurements ${\\boldsymbol{{y}}}$ --- the argument for this is carefully laid out for linear convolution in the recent work \\cite{choudhary14fu}.  However, more generic constraints on ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$ can make the problem very well-posed, and allow it to be solved using convex relaxations.  In \\cite{ahmed14bl}, it is shown that if ${\\boldsymbol{{h}}}$ is restricted to have any known support of size $K$ on $\\{0,\\ldots,{L}\\}$, and ${\\boldsymbol{{s}}}$ comes from a known random subspace of dimension ${N}$, then nuclear norm minimization will recover ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$ with high probability when\n", "itemtype": "equation", "pos": 88772, "prevtext": "\nwhere ${\\boldsymbol{{A}}}_\\ell,{\\boldsymbol{{B}}}_\\ell$ are ${N}\\times K$ matrices with entries\n", "index": 117, "text": "\n\\[\n\tA_\\ell[n,k] = \\cos(\\omega_\\ell(n+k)),\n\t\\quad\n\tB_\\ell[n,k] = -\\sin(\\omega_\\ell(n+k)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m1\" class=\"ltx_Math\" alttext=\"A_{\\ell}[n,k]=\\cos(\\omega_{\\ell}(n+k)),\\quad B_{\\ell}[n,k]=-\\sin(\\omega_{\\ell}%&#10;(n+k)).\" display=\"block\"><mrow><mrow><mrow><mrow><msub><mi>A</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mi>cos</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><mrow><msub><mi>B</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo>,</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>=</mo><mrow><mo>-</mo><mrow><mi>sin</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c9</mi><mi mathvariant=\"normal\">\u2113</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06422.tex", "nexttext": "\nThis says that the dimension of our linear models (which determines their expressive power) can be within a logarithmic factor of the ambient dimension.  General identifiablility results for deterministic subspace models are discussed in \\cite{LiLB_IdentifiabilityA}.\n\n\n\nThe lifting technique described above for blind deconvolution is just one of many methods that have been proposed for this important problem (see the books \\cite{haykin94bl,campisi07bl} or the survey \\cite{tong98mu} for an overview of algorithms used in digital communications, imaging, and other areas).  The lifting technique, however, puts the problem into the realm of optimization.  This makes it very natural to add (convex) constraints for modeling prior knowledge about the signal, or integrate indirect or partial measurements.  In \\cite{tang14co,bahmani15li}, for example, it is shown that if the image is modulated before being blurred by an unknown kernel, the recovery problem is actually very well-posed.  Recovery in this scenario is possible without any prior knowledge of the image, and the restrictions on the blur kernel are very mild.  In \\cite{LingS_Selfcalibration}, the lifting framework is applied to the closely related problem of auto-calibrating sensor arrays.  Techniques for encouraging ${\\boldsymbol{{s}}}$ and/or ${\\boldsymbol{{h}}}$ to be sparse have recently been studied in \\cite{LeeLJB_Stability,Chi_Guaranteed,bahmani15ne}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\frenchspacing\n\n\\bibliographystyle{plain}\n\\bibliography{MDbib,lrr-refs}\n\n\n", "itemtype": "equation", "pos": 89867, "prevtext": "\n\nWith only the finite support assumption, the blind deconvolution problem is still fundamentally hard.  Past even the trivial ambiguity of replacing ${\\boldsymbol{{s}}},{\\boldsymbol{{h}}}$ with $\\alpha{\\boldsymbol{{s}}},\\alpha^{-1}{\\boldsymbol{{h}}}$ for some $\\alpha\\not=0$, there will typically be many pairs of vectors consistent with the measurements ${\\boldsymbol{{y}}}$ --- the argument for this is carefully laid out for linear convolution in the recent work \\cite{choudhary14fu}.  However, more generic constraints on ${\\boldsymbol{{s}}}$ and ${\\boldsymbol{{h}}}$ can make the problem very well-posed, and allow it to be solved using convex relaxations.  In \\cite{ahmed14bl}, it is shown that if ${\\boldsymbol{{h}}}$ is restricted to have any known support of size $K$ on $\\{0,\\ldots,{L}\\}$, and ${\\boldsymbol{{s}}}$ comes from a known random subspace of dimension ${N}$, then nuclear norm minimization will recover ${\\boldsymbol{{s}}}{\\boldsymbol{{h}}}^{\\mathrm{T}}$ with high probability when\n", "index": 119, "text": "\n\\[\n\t\\max(K,{N}) \\leq \\mathrm{Const}\\cdot \\frac{{L}}{\\log^3{L}}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m1\" class=\"ltx_Math\" alttext=\"\\max(K,{N})\\leq\\mathrm{Const}\\cdot\\frac{{L}}{\\log^{3}{L}}.\" display=\"block\"><mrow><mrow><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><mi>K</mi><mo>,</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>Const</mi><mo>\u22c5</mo><mfrac><mi>L</mi><mrow><msup><mi>log</mi><mn>3</mn></msup><mo>\u2061</mo><mi>L</mi></mrow></mfrac></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}]