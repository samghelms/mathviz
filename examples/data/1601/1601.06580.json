[{"file": "1601.06580.tex", "nexttext": "\nwhere $\\rho$ is evaporation rate, $t$ is the current iteration and $\\Gamma$ is th distance between the $\\mathbf{x_i}$ and all individuals $n$ in the population. The distance is calculated by\n\n", "itemtype": "equation", "pos": 9401, "prevtext": "\n\n\n \\begin{titlepage}\n \\begin{center}\n {\\Large \\sc PREPRINT VERSION\\\\}\n  \\vspace{5mm}\n{\\huge Is swarm intelligence able to create mazes?\\\\}\n \\vspace{10mm}\n {\\Large D. Po{\\l}ap, M. Wo\\'{z}niak C. Napoli, E. Tramontana}\\\\~\\\\\n {\\large Email: napoli@dmi.unict.it\\\\}~\\\\\n \\vspace{5mm}\n{\\Large \\sc FINAL VERSION PUBLISHED ON:\\\\~\\\\ \\bf International Journal of Electronics and Telecommunications,\\\\ Vol. 6, n. 4, pp. 305--310 (2015)}\n \\end{center}\n \\vspace{5mm}\n {\\Large \\sc BIBITEX: \\\\}\n \n@Article\\{polap2015swarm,\\\\\n  author =        \\{Polap, Dawid and Wozniak, Marcin and Napoli, Christian and Tramontana, Emiliano\\},\\\\\n  title =         \\{Is swarm intelligence able to create mazes?\\},\\\\\n  journal =       \\{International Journal of Electronics and Telecommunications\\},\\\\\n  year =          \\{2015\\},\\\\\n  volume =        \\{61\\},\\\\\n  number =        \\{4\\},\\\\\n  pages =         \\{305--310\\},\\\\\n  doi =           \\{10.1515/eletel-2015-0039\\},\\\\\n  url =           \\{http://ijet.ise.pw.edu.pl/index.php/ijet/article/view/10.1515-elete2015-0039\\}\\\\\n\\}\\\\\n\n\n \\vspace{5mm}\n \\begin{center}\nPublished version copyright \\copyright~2015 International Journal of Electronics and Telecommunications \\\\\n\\vspace{5mm}\nUPLOADED UNDER SELF-ARCHIVING POLICIES\\\\\nNO COPYRIGHT INFRINGEMENT INTENDED \\\\\n \\end{center}\n\\end{titlepage}\n\n\n\\title{Is swarm intelligence able to create mazes?}\n\n\\author{Dawid Po{\\l}ap, Marcin Wo{\\'z}niak, Christian Napoli and Emiliano Tramontana\n\n\\thanks{Dawid Po{\\l}ap and Marcin Wo{\\'z}niak are with Institute of Mathematics, Silesian University of Technology, Kaszubska 23, 44-100 Gliwice, Poland, (e-mail: Dawid.Polap@gmail.com, Marcin.Wozniak@polsl.pl)}\n\\thanks{C. Napoli and E. Tramontana are with Department of Mathematics and Informatics, University of Catania, Viale A. Doria 6, 95125 Catania, Italy, (e-mail: napoli@dmi.unict.it, tramontana@dmi.unict.it)}\n}\n\n\n\n\\maketitle\n\n\\markboth{D. Po{\\l}ap, M. Wo{\\'z}niak, C. Napoli, E. Tramontana}{Is swarm intelligence able to create mazes?}\n\n\n\\begin{abstract}\n\nIn this paper, the idea of applying Computational Intelligence in the process of creation board games, in particular mazes, is presented. For two different algorithms the proposed idea has been examined. The results of the experiments are shown and discussed to present advantages and disadvantages.\n\\end{abstract}\n\n\\begin{IEEEkeywords}\nComputational Intelligence, Heuristic Algorithm\n\\end{IEEEkeywords}\n\n\\maketitle\n\n\\section{Introduction}\\label{sec:intro}\n\\IEEEPARstart{T}{}he first evolutionary algorithms have been shown in the 70s \\cite{holland1973},\\cite{baldwin1986}. Where in \\cite{holland1973} J. Holland has shown that the nature is giving best optimization techniques, which are implementable in various optimization problems. Further with research on possible applications computer scientists have developed several techniques that map behavior of various animals into computer algorithms. In \\cite{Yang2009} cuckoos breeding habits were implemented to search for optimum solutions, \\cite{Slota2013j} and \\cite{Brociek2015} present nature based algorithms applied to solve metal solidification modeling, \\cite{Slota2014e} shows how to modify harmony search method to more efficiently optimize differential models of solidification models, \\cite{Wozniak2015_11}, \\cite{Wozniak2014_1}; \\cite{NapWoa,napoli2014} and \\cite{Wozniak2015_4} present evolutionary approach to model and optimize cloud based system for efficient user verification and network traffic positioning. In \\cite{bartczak2012} text data clustering was optimized by application of ant colony, in \\cite{bartczak2014} significant operating points were solved, while in \\cite{Mandziuk2014_3} presents dedicated particle swarm modeling for dynamic routing problems. Computational intelligence based on swarm algorithms is also efficient in various image processing problems, like key-point search \\cite{Wozniak2015_3}, \\cite{Wozniak2014_14}, \\cite{Wozniak2014_6}. Other important application of swarm intelligence leads to implementations with neural networks or other intelligent systems \\cite{Wozniak2015_5}, \\cite{Wozniak2015_9}, \\cite{Wozniak2015_8}, \\cite{MartisiusD12} and \\cite{napoli2015}. Until this day these algorithms found numerous applications as an alternative to existing solutions in almost every field of science. \n\nOne of them, where a swarm intelligence has been used, are various games. In \\cite{Mandziuk2014_2} evolutionary approach was implemented to automatically solve playing strategies, while in \\cite{Mandziuk2014_1} similar approach is presented to efficiently help in optimization of evaluation function for various games. Regardless of the type of game, the environment must be strongly varied in order to enhance playability. Second important feature is proper security that enables players to develop gaming playability \\cite{Mandziuk2015_1}. The greater playability, the quality of the game is bigger. \n\nIn this paper we would like present a novel approach to board games automatic development based on dedicated swarm intelligence implementation. In the case of 2D games, board is generated depending to the level of complexity. The higher the level, the board should be more difficult to pass. In most cases, each board for 2D game may be presented as a maze which is a system of many roads, where the majority does not lead anywhere. Mazes are designed in accordance with certain principles which are specified for each game separately. In general, a maze has one entrance and one exit and the player's task is to find the road leading through a maze without crossing the walls.  A similar case is for 3D games where the walls have been replaced by models of nature or some dedicated architecture models. The main problem of creating this type of board games that are focused on the playability is to reduce complexity to create an shape which may be an appropriate maze. Many maze generators are based on the graph theory which mainly uses tree search algorithms such as Prim's or Kruskal's algorithms, which are efficient for energy saving routing design \\cite{Hirao2012} and gaming systems \\cite{Najman2013}. In this paper, we would like to propose an alternative methods to create mazes. We base our approach on Swarm Intelligence (SI) with dedicated strategies for boards construction.  \n\\section{Swarm intelligence algorithms with developed procedures to compose mazes}\nSwarm Intelligence is an algorithmic description of the coordinated moves that all swarm particles do together. This movement is based on communication between them, when information about surrounding conditions is passed to optimize strategy of movement. Mathematical model of this type of optimization is developed on observation of animals. Various species perform several optimization strategies to breed, feed, spread and escape. In this paper we want to concentrate on two algorithms simulating colony of ants and bees. \n\nIn nature ants search for sources of food. Information about their locations is left for other ants in special traces of pheromones. Model of this behavior is very efficient in many optimization problems, like heat transfer modeling \\cite{Slota2012u}. Similarly, it is possible to model a colony of bees. Among bees information is passed in a kind of dance that bees performs in the hive if a source of nectar was found. This algorithm can be applied i.e. for key point search in 2D pictures \\cite{Wozniak2015_3}. These two algorithms can be implemented to create mazes. In the following sections we present dedicated versions developed for the purpose of maze construction.\n\\subsection{Artificial Ant Colony Algorithm}\\label{AACAsec}\nArtificial Ant Colony Algorithm (AACA) was inspired by the life of ants and more specifically the search for food. Ants are able to find a way back to the nest, mark it for other ants and also carry several times more weight of food than theirs to home. This particular modeling of nature inspired optimization AACA has been applied in various tasks, like solidification modeling \\cite{Brociek2015}, image processing \\cite{Wozniak2015_18} and data clustering \\cite{bartczak2012}. In AACA, the movement of ants is done in random directions leaving behind a trail of pheromone which allows them to return to the nest or reconstruct a path to the food. In each case going in search of food and after finding a source of food at the way to home ant is able to move both directions because of the left pheromone track. This pheromone marking process is performed by all ants in the home. Every ant that leaves the home can follow tracks of the others. In the situation, when the number of paths is more than one, ants will choose the road in which trail pheromones is the strongest after a temporary evaporation. This guarantees that before many other ants were traveling this path, so at the and of it a large source of food can be found. Model of this marking is performed in the following iterations in the algorithm. Each iteration means that all the ants left home in the search of food and moved over the space leaving pheromone trials. In the next iteration these trials are evaluated by others and if leading to better source of food improved with new portion of pheromones or if leading to weak source abandoned. \n\nDuring the first iteration, the pheromone value is everywhere the same. In subsequent iterations, the value is updated by\n\n", "index": 1, "text": "\\begin{equation}\\label{eq:pheromone}\nf^{t+1}(\\mathbf{x_i},\\mathbf{x_j})=(1-\\rho)f^{t}(\\mathbf{x_i},\\mathbf{x_j})+\\Gamma_i^{t},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"f^{t+1}(\\mathbf{x_{i}},\\mathbf{x_{j}})=(1-\\rho)f^{t}(\\mathbf{x_{i}},\\mathbf{x_%&#10;{j}})+\\Gamma_{i}^{t},\" display=\"block\"><mrow><mrow><mrow><msup><mi>f</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc23</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mi>\u03c1</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msup><mi>f</mi><mi>t</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc23</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msubsup><mi mathvariant=\"normal\">\u0393</mi><mi>i</mi><mi>t</mi></msubsup></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $L^t_{ij}$ is the length of the path between ants $i$ and $j$, which is defined as Cartesian metric \n\n", "itemtype": "equation", "pos": 9734, "prevtext": "\nwhere $\\rho$ is evaporation rate, $t$ is the current iteration and $\\Gamma$ is th distance between the $\\mathbf{x_i}$ and all individuals $n$ in the population. The distance is calculated by\n\n", "index": 3, "text": "\\begin{equation}\\label{eq:distance}\n\\Gamma_i^{t}=\\sum_{i=1}^n\\frac{1}{L_{ij}^{t}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\Gamma_{i}^{t}=\\sum_{i=1}^{n}\\frac{1}{L_{ij}^{t}},\" display=\"block\"><mrow><mrow><msubsup><mi mathvariant=\"normal\">\u0393</mi><mi>i</mi><mi>t</mi></msubsup><mo>=</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><msubsup><mi>L</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow><mi>t</mi></msubsup></mfrac></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $\\mathbf{x_i}$ and $\\mathbf{x_j}$ are points in $R\\times R$ space, $x_{i,k}, x_{k,j}$-k-th components of the spatial coordinates $\\mathbf{x_i}$ and $ \\mathbf{x_j}$ representing insect.\n\nThe probability of choosing the road to the ant $\\mathbf{x_j}$ by $\\mathbf{x_i}$ is calculated by\n\n", "itemtype": "equation", "pos": 9939, "prevtext": "\nwhere $L^t_{ij}$ is the length of the path between ants $i$ and $j$, which is defined as Cartesian metric \n\n", "index": 5, "text": "\\begin{equation}\\label{eq:lengtgh}\nL_{ij}=\\lVert \\mathbf{x_i} - \\mathbf{x_j} \\rVert = \\sqrt{\\sum^{2}_{k=1}(x_{i,k}-x_{j,k})^2},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"L_{ij}=\\lVert\\mathbf{x_{i}}-\\mathbf{x_{j}}\\rVert=\\sqrt{\\sum^{2}_{k=1}(x_{i,k}-%&#10;x_{j,k})^{2}},\" display=\"block\"><mrow><mrow><msub><mi>L</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo fence=\"true\" stretchy=\"false\">\u2225</mo><mrow><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>-</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc23</mi></msub></mrow><mo fence=\"true\" stretchy=\"false\">\u2225</mo></mrow><mo>=</mo><msqrt><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mn>2</mn></munderover><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $N^k_i$ is a set of unknown roads for $k$ ant which lead to the $i$, $\\alpha$ means the impact of left pheromones.\n\nThe movement of ants is based on the highest probability $p^t$ and it is defined as\n\n", "itemtype": "equation", "pos": 10372, "prevtext": "\nwhere $\\mathbf{x_i}$ and $\\mathbf{x_j}$ are points in $R\\times R$ space, $x_{i,k}, x_{k,j}$-k-th components of the spatial coordinates $\\mathbf{x_i}$ and $ \\mathbf{x_j}$ representing insect.\n\nThe probability of choosing the road to the ant $\\mathbf{x_j}$ by $\\mathbf{x_i}$ is calculated by\n\n", "index": 7, "text": "\\begin{equation}\\label{eq:choosepath}\np^{t}(\\mathbf{x_i},\\mathbf{x_j})=\\frac{[f^{t}(\\mathbf{x_i},\\mathbf{x_j})]^\\alpha\\left[\\frac{1}{L_{ij}^{t}}\\right]^\\beta}{\\sum_{\\alpha\\in N^k_i}\\left([f^{t}(\\mathbf{x_i},\\mathbf{x_\\alpha})]^\\alpha\\left[\\frac{1}{L_{i\\alpha}^{t}}\\right]\\right)},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"p^{t}(\\mathbf{x_{i}},\\mathbf{x_{j}})=\\frac{[f^{t}(\\mathbf{x_{i}},\\mathbf{x_{j}%&#10;})]^{\\alpha}\\left[\\frac{1}{L_{ij}^{t}}\\right]^{\\beta}}{\\sum_{\\alpha\\in N^{k}_{%&#10;i}}\\left([f^{t}(\\mathbf{x_{i}},\\mathbf{x_{\\alpha}})]^{\\alpha}\\left[\\frac{1}{L_%&#10;{i\\alpha}^{t}}\\right]\\right)},\" display=\"block\"><mrow><mrow><mrow><msup><mi>p</mi><mi>t</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc23</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><msup><mrow><mo stretchy=\"false\">[</mo><mrow><msup><mi>f</mi><mi>t</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc23</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mi>\u03b1</mi></msup><mo>\u2062</mo><msup><mrow><mo>[</mo><mfrac><mn>1</mn><msubsup><mi>L</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow><mi>t</mi></msubsup></mfrac><mo>]</mo></mrow><mi>\u03b2</mi></msup></mrow><mrow><msub><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>\u03b1</mi><mo>\u2208</mo><msubsup><mi>N</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msub><mrow><mo>(</mo><mrow><msup><mrow><mo stretchy=\"false\">[</mo><mrow><msup><mi>f</mi><mi>t</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><msub><mi>\ud835\udc31</mi><mi>\u03b1</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">]</mo></mrow><mi>\u03b1</mi></msup><mo>\u2062</mo><mrow><mo>[</mo><mfrac><mn>1</mn><msubsup><mi>L</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>\u03b1</mi></mrow><mi>t</mi></msubsup></mfrac><mo>]</mo></mrow></mrow><mo>)</mo></mrow></mrow></mfrac></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $\\text{ind(t)}$ means a set of neighbor indicts after sort. Implementation of the algorithm is shown in Algorithm \\ref{AACAAlgorithm}.\n\\begin{algorithm}[!ht]\n\\caption{AACA to create mazes}\n\\label{AACAAlgorithm}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Define all coefficients: $n$ size of workers population, $\\alpha$ impact of left pheromones, $\\rho$ evaporation rate, $\\zeta$ the minimum value of the pheromone,$r$ number of random alleys, \n\\STATE Create array with $\\alpha$ values and two different exits,\n\\WHILE{the queen does not pass the entire maze}\n\t\\STATE{Update pheromone values using \\eqref{eq:pheromone},}\n\t\\STATE{Calculate distances between worker ants \\eqref{eq:lengtgh},}\n\t\\STATE{Calculate possible path to follow by worker $i$ to location $j$ $p^{t}(\\mathbf{x_i},\\mathbf{x_j})$ using \\eqref{eq:choosepath},}\n\t\\STATE{Determine the best position to follow,}\n\t\\STATE{Move population of workers using \\eqref{eq:move},}\n\\ENDWHILE\n\\STATE Recalculate the value of pheromone according to \\eqref{eq:map},\n\\STATE Return array of recalculated values of pheromone.\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\n\n\\subsection{Artificial Bee Colony Algorithm}\\label{ABCAsec}\nArtificial Bee Colony Algorithm (ABCA) reflects the behavior of honey bees during the search for food. When bees are looking for nectar sources, they can communicate with each other. One of the most common communication techniques is the waggle dance, during which bees inform each other about the quality of the found source, distance from the hive and direction. Waggle dance allows to find the location where the best nectar is to be found. In the algorithm, there are different types of bees because of their role in the hive. The first group are scouts who look for food at random way and communicate with others by waggle dance in the hive. The second group are an onlookers who choose the best areas for exploration after the watch of the dance. The last are employed bees who are looking for the best quality nectar in the designated areas. All of them communicate to pass the information. Model of this process is performed in the following iterations in the algorithm. Each iteration means that all the bees left home in the search of food and came back pass the information to the others. In the next iteration other bees fly to these locations to search for food. If a better source of food is found this is information is passed at the end of iteration.\n\nIn the first stage of the algorithm, we create an array that reflects the map of meadow where bees are moving in search of the best flowers. At the beginning, all fields (except entrance and exit) has the same value of $\\zeta$. The exits are marked threefold value of $\\zeta$. Depending on the quality of the place, each bee may modify this value by the following equation\n\n", "itemtype": "equation", "pos": 10874, "prevtext": "\nwhere $N^k_i$ is a set of unknown roads for $k$ ant which lead to the $i$, $\\alpha$ means the impact of left pheromones.\n\nThe movement of ants is based on the highest probability $p^t$ and it is defined as\n\n", "index": 9, "text": "\\begin{equation}\\label{eq:move}\n\\mathbf{x_i^{t+1}}=\\mathbf{x_i^{t}}+\\text{sign}(\\mathbf{x_i^{t}}(\\text{ind}(t))-\\mathbf{x_i^{t}}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{x_{i}^{t+1}}=\\mathbf{x_{i}^{t}}+\\text{sign}(\\mathbf{x_{i}^{t}}(\\text{%&#10;ind}(t))-\\mathbf{x_{i}^{t}}),\" display=\"block\"><mrow><mrow><msubsup><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><mrow><mi>\ud835\udc2d</mi><mo>+</mo><mn>\ud835\udfcf</mn></mrow></msubsup><mo>=</mo><mrow><msubsup><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><mi>\ud835\udc2d</mi></msubsup><mo>+</mo><mrow><mtext>sign</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msubsup><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><mi>\ud835\udc2d</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mtext>ind</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><msubsup><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><mi>\ud835\udc2d</mi></msubsup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $f(\\mathbf{x_i},\\zeta)$ is called fitness function and it is calculated by\n\n", "itemtype": "equation", "pos": 13847, "prevtext": "\nwhere $\\text{ind(t)}$ means a set of neighbor indicts after sort. Implementation of the algorithm is shown in Algorithm \\ref{AACAAlgorithm}.\n\\begin{algorithm}[!ht]\n\\caption{AACA to create mazes}\n\\label{AACAAlgorithm}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Define all coefficients: $n$ size of workers population, $\\alpha$ impact of left pheromones, $\\rho$ evaporation rate, $\\zeta$ the minimum value of the pheromone,$r$ number of random alleys, \n\\STATE Create array with $\\alpha$ values and two different exits,\n\\WHILE{the queen does not pass the entire maze}\n\t\\STATE{Update pheromone values using \\eqref{eq:pheromone},}\n\t\\STATE{Calculate distances between worker ants \\eqref{eq:lengtgh},}\n\t\\STATE{Calculate possible path to follow by worker $i$ to location $j$ $p^{t}(\\mathbf{x_i},\\mathbf{x_j})$ using \\eqref{eq:choosepath},}\n\t\\STATE{Determine the best position to follow,}\n\t\\STATE{Move population of workers using \\eqref{eq:move},}\n\\ENDWHILE\n\\STATE Recalculate the value of pheromone according to \\eqref{eq:map},\n\\STATE Return array of recalculated values of pheromone.\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\n\n\\subsection{Artificial Bee Colony Algorithm}\\label{ABCAsec}\nArtificial Bee Colony Algorithm (ABCA) reflects the behavior of honey bees during the search for food. When bees are looking for nectar sources, they can communicate with each other. One of the most common communication techniques is the waggle dance, during which bees inform each other about the quality of the found source, distance from the hive and direction. Waggle dance allows to find the location where the best nectar is to be found. In the algorithm, there are different types of bees because of their role in the hive. The first group are scouts who look for food at random way and communicate with others by waggle dance in the hive. The second group are an onlookers who choose the best areas for exploration after the watch of the dance. The last are employed bees who are looking for the best quality nectar in the designated areas. All of them communicate to pass the information. Model of this process is performed in the following iterations in the algorithm. Each iteration means that all the bees left home in the search of food and came back pass the information to the others. In the next iteration other bees fly to these locations to search for food. If a better source of food is found this is information is passed at the end of iteration.\n\nIn the first stage of the algorithm, we create an array that reflects the map of meadow where bees are moving in search of the best flowers. At the beginning, all fields (except entrance and exit) has the same value of $\\zeta$. The exits are marked threefold value of $\\zeta$. Depending on the quality of the place, each bee may modify this value by the following equation\n\n", "index": 11, "text": "\\begin{equation}\\label{mapModification}\n\\Theta(\\zeta)=\n\\begin{cases}\n\\zeta+0,1 \\quad\\quad\\quad\\text{if}\\quad\\quad \\Gamma(\\mathbf{x_i}, \\zeta)<0,5\\\\ \n\\zeta-0,05 \\quad\\quad\\quad\\text{if}\\quad\\quad \\Gamma(\\mathbf{x_i}, \\zeta)>0,5\n\\end{cases}\n,\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\Theta(\\zeta)=\\begin{cases}\\zeta+0,1\\quad\\quad\\quad\\text{if}\\quad\\quad\\Gamma(%&#10;\\mathbf{x_{i}},\\zeta)&lt;0,5\\\\&#10;\\zeta-0,05\\quad\\quad\\quad\\text{if}\\quad\\quad\\Gamma(\\mathbf{x_{i}},\\zeta)&gt;0,5%&#10;\\end{cases},\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0398</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03b6</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><mrow><mi>\u03b6</mi><mo>+</mo><mn>0</mn></mrow><mo>,</mo><mn>1</mn><mo separator=\"true\">\u2003\u2003\u2003</mo><mtext>if</mtext><mo separator=\"true\">\u2003\u2003</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><mi>\u03b6</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow><mo>,</mo><mn>5</mn></mrow></mtd><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mrow><mrow><mi>\u03b6</mi><mo>-</mo><mn>0</mn></mrow><mo>,</mo><mn>05</mn><mo separator=\"true\">\u2003\u2003\u2003</mo><mtext>if</mtext><mo separator=\"true\">\u2003\u2003</mo><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><mi>\u03b6</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>&gt;</mo><mn>0</mn></mrow><mo>,</mo><mn>5</mn></mrow></mtd><mtd/></mtr></mtable></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $r$ is a index of exit to which the distance is the smallest from current position. \n\nIn the implementation of the algorithm, we assume that each bee is a point in space. When the new sources are found, the bees can leave the current position towards better. Bees are looking for a new source when they receive information from the hive after watching the waggle dance. At the end of each iteration, all the bees are compared in order to obtain information about the location of the best source. It is interpreted as the waggle dance. An onlooker bee choose the best area through by\n\n", "itemtype": "equation", "pos": 14184, "prevtext": "\nwhere $f(\\mathbf{x_i},\\zeta)$ is called fitness function and it is calculated by\n\n", "index": 13, "text": "\\begin{equation}\\label{fitness}\n\\Gamma(\\mathbf{x_i},\\zeta)=\\zeta\\sqrt{(x_{r,0}-x_{i,0})^2+(x_{r,1}-x_{i,1})^2},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\Gamma(\\mathbf{x_{i}},\\zeta)=\\zeta\\sqrt{(x_{r,0}-x_{i,0})^{2}+(x_{r,1}-x_{i,1}%&#10;)^{2}},\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><mi>\u03b6</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\u03b6</mi><mo>\u2062</mo><msqrt><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mrow><mi>r</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mrow><mi>r</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nAfter gaining information about the fitness of bees, they are sorted to find the best positions. After that, onlookers can move in this direction. The movement of bees is made by \n\n", "itemtype": "equation", "pos": 14900, "prevtext": "\nwhere $r$ is a index of exit to which the distance is the smallest from current position. \n\nIn the implementation of the algorithm, we assume that each bee is a point in space. When the new sources are found, the bees can leave the current position towards better. Bees are looking for a new source when they receive information from the hive after watching the waggle dance. At the end of each iteration, all the bees are compared in order to obtain information about the location of the best source. It is interpreted as the waggle dance. An onlooker bee choose the best area through by\n\n", "index": 15, "text": "\\begin{equation}\\label{ABCAwaggle}\np(\\mathbf{x_i})=\\frac{\\Gamma(\\mathbf{x_i},1)}{\\sum_{i=1}^{i=n} \\Gamma(\\mathbf{x_i},1)}.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"p(\\mathbf{x_{i}})=\\frac{\\Gamma(\\mathbf{x_{i}},1)}{\\sum_{i=1}^{i=n}\\Gamma(%&#10;\\mathbf{x_{i}},1)}.\" display=\"block\"><mrow><mrow><mrow><mi>p</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow></msubsup><mrow><mi mathvariant=\"normal\">\u0393</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi></msub><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $k$ is a random index from the set of the best sources, $\\alpha_k$ is a random number from $\\langle -1,1\\rangle$ and $\\varDelta\\mathbf{x_{ik}}$ is obtained by\n\n", "itemtype": "equation", "pos": 15218, "prevtext": "\nAfter gaining information about the fitness of bees, they are sorted to find the best positions. After that, onlookers can move in this direction. The movement of bees is made by \n\n", "index": 17, "text": "\\begin{equation}\\label{ABCAmotion}\n\\mathbf{x_i}^{t+1}=\\mathbf{x_i}^t+\\alpha_{k}\\cdot \\varDelta\\mathbf{x_{ik}},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\mathbf{x_{i}}^{t+1}=\\mathbf{x_{i}}^{t}+\\alpha_{k}\\cdot\\varDelta\\mathbf{x_{ik}},\" display=\"block\"><mrow><mrow><mmultiscripts><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><none/><none/><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></mmultiscripts><mo>=</mo><mrow><mmultiscripts><mi>\ud835\udc31</mi><mi>\ud835\udc22</mi><none/><none/><mi>t</mi></mmultiscripts><mo>+</mo><mrow><mrow><msub><mi>\u03b1</mi><mi>k</mi></msub><mo>\u22c5</mo><mi mathvariant=\"normal\">\u0394</mi></mrow><mo>\u2062</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22\ud835\udc24</mi></msub></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $j$ is randomly chosen spatial coordinate of the chosen bee. The implemented algorithm is illustrated in Algorithm \\ref{ABCAAlgorithm}. The algorithm returns an array that is a map on which the bees moved.\n\\begin{algorithm}[!ht]\n\\caption{ABCA to create mazes}\n\\label{ABCAAlgorithm}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Define all coefficients: $n$ size of population, $m$ - number of chosen best bees, $\\zeta$ the minimum value to create a wall, $r$ number of random alleys, \n\\STATE Create position array with value $\\zeta$ and two different exits,\n\\STATE Create population,\n\\WHILE{the queen does not pass the entire maze}\n\t\\STATE{Evaluate the values in array according to \\eqref{mapModification}}\n\t\\STATE{Evaluate population using \\eqref{ABCAwaggle}}\n\t\\STATE{Sort $bees$ according to the value of location,}\n\t\\STATE{Select $m$ best locations among all $bees$,}\n\t\\STATE{Other $bees$ replace with randomly selected bees}\n\t\\STATE{using \\eqref{ABCAmotion} move the $bees$ toward nectar source (exits) defined in \\eqref{ABCAcontact}},\n\\ENDWHILE\n\\STATE Recalculate the value from position array according to \\eqref{eq:map},\n\\STATE Return array,\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\n\n\\subsection{An Adaptation of AACA and ABCA to Create Mazes}\nAn adaptation of presented Swarm Intelligence algorithms to create mazes requires additional operations to obtain picture of the maze. Each of the presented algorithms returns an array of values (ants \u00e2\u0080\u0093 an array of pheromones, bees \u00e2\u0080\u0093 the map of meadow) which represent the maze. Each of these values is calculated by the following function\n\n", "itemtype": "equation", "pos": 15509, "prevtext": "\nwhere $k$ is a random index from the set of the best sources, $\\alpha_k$ is a random number from $\\langle -1,1\\rangle$ and $\\varDelta\\mathbf{x_{ik}}$ is obtained by\n\n", "index": 19, "text": "\\begin{equation}\\label{ABCAcontact}\n\\varDelta\\mathbf{x_{ik}}=(x_{ij}-x_{kj}),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\varDelta\\mathbf{x_{ik}}=(x_{ij}-x_{kj}),\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>\ud835\udc31</mi><mi>\ud835\udc22\ud835\udc24</mi></msub></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>\u2062</mo><mi>j</mi></mrow></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nwhere $\\kappa$ is the limit value for which it will create a wall of the maze.\n\\begin{algorithm}[!ht]\n\\caption{The algorithm for maze design using Swarm Intelligence}\n\\label{ALLIN}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Use Algorithm \\ref{AACAAlgorithm} or Algorithm \\ref{ABCAAlgorithm} to create an array representing a maze,\n\\STATE Create a bitmap $I$,\n\\FORALL{value $v$ in array}\n\t\\IF{$v$ is $1$}\n\t\t\\IF{$r>0$}\n\t\t\t\\IF{random value is less than $0.5$}\n\t\t\t\t\\STATE Create a wall.\n\t\t\t\\ENDIF\n\t\t\\ELSE\n\t\t\t\\STATE Create a wall.\n\t\t\\ENDIF\n\t\\ELSE\n\t\t\\FORALL{neighbor of $v$}\n\t\t\t\\IF{neighbor is $1$}\n\t\t\t\t\\STATE Create a wall.\n\t\t\t\\ENDIF\n\t\t\\ENDFOR\n\t\\ENDIF\n\\ENDFOR\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\nPresented AACA and ABCA algorithms are used in Algorithm \\ref{ALLIN} to create various mazes. However to improve the efficiency of board games creation we have implemented a dedicated stop construction process. This is based on stop condition that is used to verify if it is still necessary to continue to compose of the paths in the maze.\n\\subsection{Stop Condition}\nTo adapt the AACA and ABCA algorithms described in subsection \\ref{AACAsec} and \\ref{ABCAsec}, a dedicated stop condition must be adjusted to create a road from entrance to exit of the maze. For this purpose, the queen (a moving supervisor) is added to each of the algorithms. After each iteration, the queen is called to check whether exists a passage through constructed maze. If the passage exits, the algorithm is complete and the maze is ready. Otherwise, the next iteration begins since the queen is not satisfied with the work of their subordinates.\n\nSeeking for an exit, the queen moves according to the Cartesian metric defined in \\eqref{eq:lengtgh} where we assume that \n\n", "itemtype": "equation", "pos": 17207, "prevtext": "\nwhere $j$ is randomly chosen spatial coordinate of the chosen bee. The implemented algorithm is illustrated in Algorithm \\ref{ABCAAlgorithm}. The algorithm returns an array that is a map on which the bees moved.\n\\begin{algorithm}[!ht]\n\\caption{ABCA to create mazes}\n\\label{ABCAAlgorithm}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Define all coefficients: $n$ size of population, $m$ - number of chosen best bees, $\\zeta$ the minimum value to create a wall, $r$ number of random alleys, \n\\STATE Create position array with value $\\zeta$ and two different exits,\n\\STATE Create population,\n\\WHILE{the queen does not pass the entire maze}\n\t\\STATE{Evaluate the values in array according to \\eqref{mapModification}}\n\t\\STATE{Evaluate population using \\eqref{ABCAwaggle}}\n\t\\STATE{Sort $bees$ according to the value of location,}\n\t\\STATE{Select $m$ best locations among all $bees$,}\n\t\\STATE{Other $bees$ replace with randomly selected bees}\n\t\\STATE{using \\eqref{ABCAmotion} move the $bees$ toward nectar source (exits) defined in \\eqref{ABCAcontact}},\n\\ENDWHILE\n\\STATE Recalculate the value from position array according to \\eqref{eq:map},\n\\STATE Return array,\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\n\n\\subsection{An Adaptation of AACA and ABCA to Create Mazes}\nAn adaptation of presented Swarm Intelligence algorithms to create mazes requires additional operations to obtain picture of the maze. Each of the presented algorithms returns an array of values (ants \u00e2\u0080\u0093 an array of pheromones, bees \u00e2\u0080\u0093 the map of meadow) which represent the maze. Each of these values is calculated by the following function\n\n", "index": 21, "text": "\\begin{equation}\\label{eq:map}\n\\Lambda(y)=\n\\begin{cases}\ny\\in\\langle 0,\\kappa) \\hbox{\\quad empty space} \n\\\\\ny\\in(\\kappa,1\\rangle \\hbox{\\quad walls }\n\\end{cases},\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\Lambda(y)=\\begin{cases}y\\in\\langle 0,\\kappa)\\hbox{\\quad empty space}\\\\&#10;y\\in(\\kappa,1\\rangle\\hbox{\\quad walls }\\end{cases},\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u039b</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>y</mi><mo>\u2208</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mn>0</mn><mo>,</mo><mi>\u03ba</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mtext>\u00a0empty space</mtext></mrow></mrow></mtd><mtd/></mtr><mtr><mtd columnalign=\"left\"><mrow><mi>y</mi><mo>\u2208</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mi>\u03ba</mi><mo>,</mo><mn>1</mn><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2062</mo><mtext>\u00a0walls\u00a0</mtext></mrow></mrow></mtd><mtd/></mtr></mtable></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06580.tex", "nexttext": "\nThe possibility of passing diagonally across the maze is locked in this way. That helps to ensure that the queen moves only in horizontal or vertical line. The whole stop condition algorithm is shown in Algorithm \\ref{march}.\n\\begin{algorithm}[!ht]\n\\caption{The imperial march of the Queen}\n\\label{march}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Create an array in accordance with (\\ref{eq:map}),\n\\STATE Find all the entrances to the maze, \n\\FORALL{entry to the maze}\n\t\\WHILE{there is no other movement}\n\\STATE{Find neighboring fields,}\n\\STATE{Remove fields in a row, in which the Queen was in the previous step,}\n\\FORALL{neighboring fields}\n\t\\IF{equation (\\ref{eq:StopCondition}) is not true or the field is a wall}\n\t\t\\STATE{Delete field,}\n\t\\ENDIF\n\\ENDFOR\n\t\\STATE{Select at random one of the existing movements,}\n\t\\ENDWHILE\n\t\\IF{the last field is one of the entrances}\n\t\t\\STATE{End of the algorithm - there is a way out of the maze,}\n\t\\ENDIF\n\\ENDFOR\n\\STATE{End of the algorithm - there is no way out of the maze,}\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\nFor even more complicated constructions of mazes, the $r$ parameter can be added. Parameter $r$ will represent the number of random alleys which is the number of walls to be removed in random way. In this case, when an initial board is created we can improve efficiency of the swarm to create the passage.\n\\section{Experiments}\nPresented approach was implemented to create various mazes in different resolutions and combinations. We have performed benchmark tests on various dimensions of boards. Let us present sample results for:\n\\begin{itemize}\n\t\\item square mazes (Fig. \\ref{fig:maze1} and Fig. \\ref{fig:maze2}) with parameters values $n=30$, $r=20$, $\\zeta=$, ABCA ($m=10\\%n$), AACA ($\\alpha=0,4$, $\\rho=0,3$),\n\t\\item rectangle mazes (Fig. \\ref{fig:maze3} and Fig. \\ref{fig:maze4}) with parameters values $n=200$, $r=120$, $\\zeta=$, ABCA ($m=10\\%n$), AACA ($\\alpha=0,4$, $\\rho=0,3$).\n\\end{itemize}\n\n\\begin{figure}[!ht]\n \t\\centering\n \t\\includegraphics[width=3.3in]{maze40x15ant}\n  \\caption{An example of $40\\times 15$ maze generated by the AACA.}\\label{fig:maze1}\n\\end{figure}\n\n\\begin{figure}[!ht]\n \t\\centering\n \t\\includegraphics[width=3.3in]{maze40x15bee}\n  \\caption{An example of $40\\times 15$ maze generated by the ABCA.}\\label{fig:maze2}\n\\end{figure}\n\n\\begin{figure*}[!ht]\n \t\\centering\n \t\\includegraphics[width=4.3in]{maze100x100ant}\n  \\caption{An example of $100\\times 100$ maze generated by the AACA.}\\label{fig:maze3}\n\\end{figure*}\n\n\\begin{figure*}[!ht]\n \t\\centering\n \t\\includegraphics[width=4.3in]{maze100x100bee}\n  \\caption{An example of $100\\times 100$ maze generated by the ABCA.}\\label{fig:maze4}\n\\end{figure*}\nFig. \\ref{timeChart} presents a chart of time comparison for creation of mazes by both AACA (blue line) and ABCA (orange line).\n\\begin{figure}[!ht]\n \t\\centering\n \t\\includegraphics[width=3.5in]{gr}\n  \\caption{Time to generate the maze for applied algorithms.}\\label{timeChart}\n\\end{figure}\nUp to 3000 fields in the maze AACA is less efficient in time comparison to ABCA. If the maze we create contains between 3000 and 6000 fields AACA take advantage. From 6000 to 9000 fields both algorithms present similar time efficiency. Above 10000 fields AACA is much faster.\n\n\\section{Final remarks}\nIn the research, many experiments have been realized for different dimensions of mazes. The results allow to conclude that Swarm Intelligence is capable to create mazes. Fig \\ref{timeChart} shows that the maze of complex up to 3000 fields is best to use ABCA presented in section \\ref{ABCAsec}, but for larger mazes AACA presented in section \\ref{AACAsec} seems to be a better choice. \n\nGenerating maze is quite a complex process but the results are very satisfied \u00e2\u0080\u0093 mazes are created randomly which gives a feature of uniqueness. As a result, the algorithms presented in this paper can be used to create not only mazes but environments for 2D or even 3D games and also applicable to smart cities models for prediction and evaluation purposes.\n\n\\section*{Acknowledgements}\nThis work has been partially supported by project PRIME funded by the Italian Ministry of University and Research within POR FESR Sicilia 2007-2013 framework.\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{wozniak_publications_daty,gapublications,slota_publications,otherseswa,rutkowski,mandziuk,RobertasDamasevicius,christian}\n\n\n", "itemtype": "equation", "pos": 19136, "prevtext": "\nwhere $\\kappa$ is the limit value for which it will create a wall of the maze.\n\\begin{algorithm}[!ht]\n\\caption{The algorithm for maze design using Swarm Intelligence}\n\\label{ALLIN}\n\\begin{algorithmic}[1]\n\\STATE Start,\n\\STATE Use Algorithm \\ref{AACAAlgorithm} or Algorithm \\ref{ABCAAlgorithm} to create an array representing a maze,\n\\STATE Create a bitmap $I$,\n\\FORALL{value $v$ in array}\n\t\\IF{$v$ is $1$}\n\t\t\\IF{$r>0$}\n\t\t\t\\IF{random value is less than $0.5$}\n\t\t\t\t\\STATE Create a wall.\n\t\t\t\\ENDIF\n\t\t\\ELSE\n\t\t\t\\STATE Create a wall.\n\t\t\\ENDIF\n\t\\ELSE\n\t\t\\FORALL{neighbor of $v$}\n\t\t\t\\IF{neighbor is $1$}\n\t\t\t\t\\STATE Create a wall.\n\t\t\t\\ENDIF\n\t\t\\ENDFOR\n\t\\ENDIF\n\\ENDFOR\n\\STATE Stop.\n\\end{algorithmic}\n\\end{algorithm}\nPresented AACA and ABCA algorithms are used in Algorithm \\ref{ALLIN} to create various mazes. However to improve the efficiency of board games creation we have implemented a dedicated stop construction process. This is based on stop condition that is used to verify if it is still necessary to continue to compose of the paths in the maze.\n\\subsection{Stop Condition}\nTo adapt the AACA and ABCA algorithms described in subsection \\ref{AACAsec} and \\ref{ABCAsec}, a dedicated stop condition must be adjusted to create a road from entrance to exit of the maze. For this purpose, the queen (a moving supervisor) is added to each of the algorithms. After each iteration, the queen is called to check whether exists a passage through constructed maze. If the passage exits, the algorithm is complete and the maze is ready. Otherwise, the next iteration begins since the queen is not satisfied with the work of their subordinates.\n\nSeeking for an exit, the queen moves according to the Cartesian metric defined in \\eqref{eq:lengtgh} where we assume that \n\n", "index": 23, "text": "\\begin{equation}\\label{eq:StopCondition}\nL_{ij}=1.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"L_{ij}=1.\" display=\"block\"><mrow><mrow><msub><mi>L</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><mo>.</mo></mrow></math>", "type": "latex"}]