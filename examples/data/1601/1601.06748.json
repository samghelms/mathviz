[{"file": "1601.06748.tex", "nexttext": "\nNote that the actual encoding bitrate for bitrate index $m$ is given by $S_m/p$ bits/second.\n\n\\emph{Video Player:}\nThe video player downloads successive chunks of the video file from the server and plays back the downloaded chunks to the user. Each chunk must be downloaded in its entirety before it can be played back. We assume that the player sends requests to the server to download one chunk at a time. Also, the chunks are downloaded in the same order as they are played back.\tThe video player has a finite buffer of size $Q_{\\max}$ chunks\\footnote{It is common practice for video players to measure the buffer in seconds of playback time rather than in bits.} to store the downloaded but yet-to-be-played-back chunks. Measuring the buffer in chunks is equivalent to measuring it in seconds since the chunk duration $p$ is fixed. If the buffer is full the player cannot download any new chunks and waits for a fixed period of time given by $\\Delta$ seconds before attempting to download a new chunk. The chunks that are fully downloaded are played back at a fixed rate of $1/p$ chunks/second without any idling.\n\nWhen sending a download request for a new chunk, the player also specifies the desired bitrate for that chunk. This enables the player to tradeoff the overall video quality with the likelihood of rebuffering that occurs when there are no chunks in the buffer for playback. Note that while each chunk has a fixed playback time of $p$ seconds, the size of the chunk (in bits) can be different depending on its bitrate. Thus, the choice of bitrate for a chunk impacts its download time.\n\n\\emph{Network Model:}\nThe available bandwidth (in bits/second) between the server and player is assumed to vary continuously in time according to a stationary random process $\\omega(t)$. We do not make any assumptions about knowing the statistical properties or probability distribution of $\\omega(t)$ except that it has finite first and second moments as well as a finite inverse second moment. Suppose the player starts to download a chunk of bitrate index $m$ at time $t$. Then the time $t'$ when the download finishes satisfies the following:\n\n", "itemtype": "equation", "pos": 14118, "prevtext": "\n\\title{\\fontsize{21pt}{0pt}\\selectfont{BOLA: Near-Optimal Bitrate Adaptation for Online Videos\n\\thanks{A preliminary version of this paper will appear at INFOCOM 2016.}\n\n}}\n\\author{\n  \\IEEEauthorblockN{\n    Kevin Spiteri\\textsuperscript{1}\\IEEEauthorrefmark{1}\\thanks{\\IEEEauthorrefmark{1}Supported in part by NSF grant CNS-1413998.},\n    Rahul Urgaonkar\\,\\textsuperscript{2}\\IEEEauthorrefmark{2}\\thanks{\\IEEEauthorrefmark{2}This work was performed when Rahul Urgaonkar was at IBM Research.},\n    Ramesh K.~Sitaraman\\textsuperscript{1,3}}\n  \\IEEEauthorblockA{\n    \\textsuperscript{1}University of Massachusetts Amherst, \\textsuperscript{2}Amazon Inc, \\textsuperscript{3}Akamai Technologies Inc\\\\\n    \\{kspiteri,ramesh\\}@cs.umass.edu, urgaonka@amazon.com}\n}\n\n\\maketitle\n\n\\begin{abstract}\n\nModern video players employ complex algorithms to adapt the bitrate of the video that is shown to the user. Bitrate adaptation requires a tradeoff between reducing the probability that the video freezes and enhancing the quality of the video shown to the user. A bitrate that is too high leads to frequent video freezes (i.e., rebuffering), while a bitrate that is too low leads to poor video quality. Video providers segment the video into short chunks and encode each chunk at multiple bitrates. The video player adaptively chooses the bitrate of each chunk that is downloaded, possibly choosing different bitrates for successive chunks. While bitrate adaptation holds the key to a good quality of experience for the user, current video players use ad-hoc algorithms that are poorly understood. We formulate bitrate adaptation as a utility maximization problem and devise an online control algorithm called \\mbox{BOLA} that uses Lyapunov optimization techniques to minimize rebuffering and maximize video quality. We prove that \\mbox{BOLA} achieves a time-average utility that is within an additive term O(1/V) of the optimal value, for a control parameter V related to the video buffer size. Further, unlike prior work, our algorithm does not require any prediction of available network bandwidth. We empirically validate our algorithm in a simulated network environment using an extensive collection of network traces. We show that our algorithm achieves near-optimal utility and in many cases significantly higher utility than current state-of-the-art algorithms. Our work has immediate impact on real-world video players and for the evolving DASH standard for video transmission.\n\n\\end{abstract}\n\n\\begin{IEEEkeywords}\nInternet Video, Video Quality, Adaptive Bitrate Streaming, Lyapunov Optimization, Optimal Control\n\\end{IEEEkeywords}\n\n\\section{Introduction}\n\\label{section:intro}\n\nOnline videos are the ``killer'' application of the Internet with videos currently accounting for more than half of the Internet traffic. Video viewership is growing at a torrid pace and videos are expected to account for more than 85\\% of all Internet traffic within a few years \\cite{cisco-videogrowth}. As all forms of traditional media migrate to the Internet, video providers face the daunting challenge of providing a good quality of experience (QoE) for users watching their videos. Video providers are diverse and include major media companies (e.g., NBC, CBS), news outlets (e.g., CNN), sports organizations (e.g., NFL, MLB), and video subscription services (e.g., Netflix, Hulu). Recent research has shown that low-performing videos that start slowly, play at lower bitrates, and freeze frequently can cause viewers to abandon the videos or watch fewer minutes of the videos, significantly decreasing the opportunity for generating revenue for the video providers \\cite{DobrianSASJGZZ11, KrishnanS2012, sitaraman2013network}, underscoring the need for a high-quality user experience.\n\nProviding a high-quality experience for video users requires balancing two contrasting requirements. The user would like to watch the highest-quality version of the video possible, where video quality can be quantified by the bitrate at which the video is encoded. For instance, watching a movie in high definition (HD) encoded at 2 Mbps arguably provides a better user experience than watching the same movie in standard definition (SD) encoded at a bitrate of 800 kbps. In fact, there is empirical evidence that the user is more engaged and watches longer when the video is presented at a higher bitrate. However, it is not always possible for users to watch videos at the highest encoded bitrate, since the bandwidth available on the network connection between the video player on the user's device and the video server constrains what bitrates can be watched. In fact, choosing a bitrate that is higher than the available network bandwidth\\footnote{ Throughout this paper, we say \\textbf{bandwidth} when talking about network throughput and \\textbf{bitrate} when talking about encoding quality. } will lead to video freezes in the middle of the playback, since the rate at which the video is being played exceeds the rate at which the video can be downloaded. Such video freezes are called {\\em rebuffers} and playing the video continuously {\\em without rebuffers} is a key factor in the QoE perceived by the user \\cite{KrishnanS2012}. Thus, balancing the contrasting requirements of playing videos at a high bitrate while at the same time avoiding rebuffers is central to providing a high-quality video watching experience.\n\n\\subsection{Adaptive Bitrate (ABR) Streaming}\n\nAchieving a high QoE for video streaming is a major challenge due to the sheer diversity of video-capable devices that include smartphones, tablets, desktops, and televisions. Further, the devices themselves can be connected to the Internet in a multitude of ways, including cable, fiber, DSL, WiFi and mobile wireless, each providing different bandwidth characteristics. The need to adjust the video playback to the characteristics of the device and the network has led to the evolution of adaptive bitrate (ABR) streaming that is now the de facto standard for delivering videos on the Internet.\n\nABR streaming requires that each video is partitioned into {\\em chunks,} where each chunk corresponds to a few seconds of play. Each chunk is then encoded in a number of different bitrates to accommodate a range of device types and network connectivities. When the user plays a video, the video player can download each chunk at a bitrate that is appropriate for the available bandwidth of the network connection. Thus, the player can switch to a chunk with a lower bitrate when the available bandwidth is low to avoid rebuffering. If more bandwidth becomes available at a future time, the player can switch back to a higher bitrate to provide a richer experience. The video player has a buffer that allows it to fetch and store chunks {\\em before} they need to be rendered on the screen. Thus, the video player can tolerate brief network disruptions without interrupting the playback of the user by using the buffered chunks. A large disruption, however, will empty the buffer, resulting in rebuffering. The decision of which chunks to download at what bitrates is made by a {\\em bitrate adaptation algorithm} within the video player, the design of such algorithms being the primary focus of our work.\n\nSeveral popular implementations of ABR streaming exist, including Apple's HTTP Live Streaming (HLS)~\\cite{apple}, Microsoft's Live Smooth Streaming (Smooth)~\\cite{smooth} and Adobe's Adaptive Streaming (HDS)~\\cite{adobe}. Each has its own proprietary implementation and slight modifications to the basic ABR technique described above. A key recent development is a unifying open-source standard for ABR streaming called MPEG-DASH~\\cite{Stockhammer2011}. DASH is broadly similar to the other ABR protocols and is a particular focus in our empirical evaluation.\n\n\\subsection{Our Contributions}\n\nOur primary contribution is a principled approach to the design of bitrate adaptation algorithms for ABR streaming. In particular, we formulate bitrate adaptation as a utility maximization problem that incorporates both key components of QoE: the average bitrate of the video experienced by the user and the duration of the rebuffer events. An increase in the average bitrate increases utility, whereas rebuffering decreases it. A strength of our framework is that utility can be defined in arbitrary ways, say, depending on the content, video provider, or user device. This contrasts with bitrate adaptation algorithms currently in use that provide no such flexibility.\n\nUsing Lyapunov optimization, we derive an online bitrate adaptation algorithm called \\mbox{BOLA} (Buffer Occupancy based Lyapunov Algorithm) that provably achieves utility that is within an additive factor of the maximum possible utility. While numerous bitrate adaptation algorithms have been proposed \\cite{decicco2013elastic, li2014panda,Huang+14,yin2015ccontrol} and implemented within video players, our algorithm is the first to provide a {\\em theoretical guarantee} on the achieved utility. Further, \\mbox{BOLA} provides an explicit knob for video providers to set the relative importance of a high video quality in relation to the probability of rebuffering.\n\nWhile not an explicit part of the Lyapunov optimization framework, we also show how \\mbox{BOLA} can be adapted to avoid frequent bitrate switches during video playback. Bitrate switches are arguably less annoying than rebuffering, but it is still of some concern to video providers and users alike if such switches occur too frequently.\n\nMost algorithms implemented in practice use a {\\em bandwidth-based} approach where the available bandwidth between the server and the video player is predicted and the predicted value is used to determine the bitrate of the next chunk that is to be downloaded. A complementary approach is a {\\em buffer-based} approach that does not predict the bandwidth, but only uses the amount of data that is currently stored in the buffer of the video player. Recently, there has been empirical evidence that a buffer-based approach has desirable properties that bandwidth-based approaches lack and has been adopted by Netflix \\cite{Huang+14}. An intriguing outcome of our work is that the optimal algorithm within our utility maximization framework requires only knowledge of the amount of data in the buffer and no estimate of the available bandwidth. Thus, our work provides the first theoretical justification for why buffer-based algorithms perform well in practice and adds new insights to the ongoing debate \\cite{yin2015ccontrol} within the video streaming and DASH standards communities of relative efficacy of the two approaches. Further, since our algorithm BOLA is buffer-based, it avoids the overheads of more complex bandwidth prediction present in current video player implementations and is more stable under bandwidth fluctuations. Note that our results imply that the buffer level is a {\\em sufficient statistic} that indirectly provides all information about past bandwidth variations required for choosing the next bitrate.\n\nWe also {\\em empirically} evaluate \\mbox{BOLA} on a wide set of network traces that include 12 test cases provided by the DASH industry forum \\cite{dashtest} and 85 publicly-available 3G mobile bandwidth traces \\cite{riiser2013}. As a benchmark for comparison, we develop an optimal {\\em offline} algorithm that uses dynamic programming and is guaranteed to produce the maximum achievable time-average utility for any given set of network traces. Unlike \\mbox{BOLA} that works in an online fashion, the offline optimal algorithm makes decision based on perfect knowledge of future bandwidth variations. Remarkably, the utility achieved by \\mbox{BOLA} is within 84--95\\% of offline optimal utility for all the tested traces.\n\nBesides comparing \\mbox{BOLA} with the offline optimal, we also empirically compared our algorithm with two state-of-the-art algorithms proposed in the literature. In {\\em all} test cases, \\mbox{BOLA} achieved a utility that is as good as or better than the best state-of-the-art algorithm. In half of the tested scenarios, \\mbox{BOLA} did even better by achieving a utility that is nearly 1.75 times the utility of the best state-of-the-art algorithm.\n\nWe are also implementing BOLA as the default ABR algorithm in dash.js, the open-source DASH reference player~\\cite{dashjs}.\n\n\\section{System Model}\n\\label{sec:model}\n\nOur system model closely captures how ABR streaming works on the Internet today. We consider a video player that downloads a video file from a server over the Internet and plays it back to the user. The video file is segmented into chunks that are downloaded in succession. The available bandwidth between the server and the player varies over time. This can be due to reasons such as network congestion and wireless fading among others. The viewing experience of the user is determined by both the video quality as quantified by the bitrates of the chunks that are played back and the playback characteristics such as rebuffering. The objective of the player is to maximize a utility associated with the user's viewing experience while adapting to time-varying (and possibly unpredictable) changes in the available bandwidth.\n\n\\emph{Video Model:}\nThe video file is segmented into $N$ chunks indexed as $\\{1, 2, \\ldots, N\\}$ where each chunk represents $p$ seconds of the video. On the server, each chunk is available in $M$ different bitrates where a chunk encoded at a higher bitrate has a larger size in bits and its playback provides a better user experience and higher utility. Suppose the size (in bits) of a chunk encoded at bitrate index $m$ is $S_m$ bits\\footnote{For simplicity, we assume that the chunk size (in bits) is $S_m$ for all chunks of a given bitrate index $m$. However, our framework can be easily extended to the case where the chunk size for the same bitrate can vary across chunks.} and suppose the utility derived by the user from viewing it is given by $\\upsilon_m$ where $m \\in \\{1, 2, \\ldots, M\\}$. WLOG, let the chunk bitrates be non-increasing in index $m$. Then, the following holds.\n\n", "index": 1, "text": "\\begin{align}\n\\upsilon_1 \\geq \\upsilon_2 \\geq \\ldots \\geq \\upsilon_M \\Longleftrightarrow S_1 \\geq S_2 \\geq \\ldots \\geq S_M.\n\\label{eq:upsilon}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\upsilon_{1}\\geq\\upsilon_{2}\\geq\\ldots\\geq\\upsilon_{M}%&#10;\\Longleftrightarrow S_{1}\\geq S_{2}\\geq\\ldots\\geq S_{M}.\" display=\"inline\"><mrow><mrow><mrow><msub><mi>\u03c5</mi><mn>1</mn></msub><mo>\u2265</mo><msub><mi>\u03c5</mi><mn>2</mn></msub><mo>\u2265</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2265</mo><msub><mi>\u03c5</mi><mi>M</mi></msub></mrow><mo>\u27fa</mo><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>\u2265</mo><msub><mi>S</mi><mn>2</mn></msub><mo>\u2265</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u2265</mo><msub><mi>S</mi><mi>M</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nLet $\\mathbb{E}\\left\\{{\\omega(t)}\\right\\} = \\omega_{\\mathrm{avg}}$. Then, $\\mathbb{E}\\left\\{{t' - t}\\right\\} = {S_m}/{\\omega_{\\mathrm{avg}}}$.\n\n\\section{Problem Formulation}\n\\label{sec:formulation}\n\nWe consider two primary performance metrics\\footnote{We do not include the secondary objective of avoiding frequent bitrate switches in our formulation, but we deal with it empirically in Section~\\ref{subsec:oscillations}.} that affect the overall QoE of the user: (1) time-average playback quality which is a function of the bitrates of the chunks viewed by the user and (2) fraction of time spent not rebuffering. To formalize these metrics, we consider a time-slotted representation of our system model. The timeline is divided into non-overlapping consecutive slots of variable length and indexed by $k \\in \\{1, 2, \\ldots\\}$. Slot $k$ starts at time $t_k$ and is $T_k = t_{k+1} - t_k$ seconds long. We assume that $t_1 = 0$. At the beginning of each slot, the video player makes a control decision on whether it should start downloading a new chunk, and if yes, its bitrate. If a download decision is made, then a request is sent to the server and the download starts immediately\\footnote{Any delays associated with sending the request can be added to the overall download time.}. This download takes $T_k$ seconds and is completed at the end of slot $k$. Note that $T_k$ is a random variable whose actual value depends on the realization of the $\\omega(t)$ process as well as the choice of chunk bitrate. If the player decides not to download a new chunk in slot $k$ (for example, when the buffer is full), then this slot lasts for a fixed duration of $\\Delta$ seconds.\n\nWe define the following indicator variable for each slot $k$:\n\n", "itemtype": "equation", "pos": 16424, "prevtext": "\nNote that the actual encoding bitrate for bitrate index $m$ is given by $S_m/p$ bits/second.\n\n\\emph{Video Player:}\nThe video player downloads successive chunks of the video file from the server and plays back the downloaded chunks to the user. Each chunk must be downloaded in its entirety before it can be played back. We assume that the player sends requests to the server to download one chunk at a time. Also, the chunks are downloaded in the same order as they are played back.\tThe video player has a finite buffer of size $Q_{\\max}$ chunks\\footnote{It is common practice for video players to measure the buffer in seconds of playback time rather than in bits.} to store the downloaded but yet-to-be-played-back chunks. Measuring the buffer in chunks is equivalent to measuring it in seconds since the chunk duration $p$ is fixed. If the buffer is full the player cannot download any new chunks and waits for a fixed period of time given by $\\Delta$ seconds before attempting to download a new chunk. The chunks that are fully downloaded are played back at a fixed rate of $1/p$ chunks/second without any idling.\n\nWhen sending a download request for a new chunk, the player also specifies the desired bitrate for that chunk. This enables the player to tradeoff the overall video quality with the likelihood of rebuffering that occurs when there are no chunks in the buffer for playback. Note that while each chunk has a fixed playback time of $p$ seconds, the size of the chunk (in bits) can be different depending on its bitrate. Thus, the choice of bitrate for a chunk impacts its download time.\n\n\\emph{Network Model:}\nThe available bandwidth (in bits/second) between the server and player is assumed to vary continuously in time according to a stationary random process $\\omega(t)$. We do not make any assumptions about knowing the statistical properties or probability distribution of $\\omega(t)$ except that it has finite first and second moments as well as a finite inverse second moment. Suppose the player starts to download a chunk of bitrate index $m$ at time $t$. Then the time $t'$ when the download finishes satisfies the following:\n\n", "index": 3, "text": "\\begin{align}\nS_m = \\int_t^{t'} \\omega(\\tau) d\\tau\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle S_{m}=\\int_{t}^{t^{\\prime}}\\omega(\\tau)d\\tau\" display=\"inline\"><mrow><msub><mi>S</mi><mi>m</mi></msub><mo>=</mo><mrow><mstyle displaystyle=\"true\"><msubsup><mo largeop=\"true\" symmetric=\"true\">\u222b</mo><mi>t</mi><msup><mi>t</mi><mo>\u2032</mo></msup></msubsup></mstyle><mrow><mi>\u03c9</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c4</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo>\ud835\udc51</mo><mi>\u03c4</mi></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nThen, for all $k$, we must have $\\sum_{m=1}^M a_{m}(t_k) \\leq 1$. Moreover, when $\\sum_{m=1}^M a_{m}(t_k) = 0$, then no chunks are downloaded. Let $K_N$ denote the index of the slot in which the $N^{\\textrm{th}}$ (i.e., last) chunk is downloaded. Also, denote the time at which the player finishes playing back the last chunk by $T_{\\mathrm{end}}$. Then the first performance metric of interest is the time-average expected {\\em playback utility} $\\overline{\\upsilon}_N$ which is defined as\n\n", "itemtype": "equation", "pos": 18224, "prevtext": "\nLet $\\mathbb{E}\\left\\{{\\omega(t)}\\right\\} = \\omega_{\\mathrm{avg}}$. Then, $\\mathbb{E}\\left\\{{t' - t}\\right\\} = {S_m}/{\\omega_{\\mathrm{avg}}}$.\n\n\\section{Problem Formulation}\n\\label{sec:formulation}\n\nWe consider two primary performance metrics\\footnote{We do not include the secondary objective of avoiding frequent bitrate switches in our formulation, but we deal with it empirically in Section~\\ref{subsec:oscillations}.} that affect the overall QoE of the user: (1) time-average playback quality which is a function of the bitrates of the chunks viewed by the user and (2) fraction of time spent not rebuffering. To formalize these metrics, we consider a time-slotted representation of our system model. The timeline is divided into non-overlapping consecutive slots of variable length and indexed by $k \\in \\{1, 2, \\ldots\\}$. Slot $k$ starts at time $t_k$ and is $T_k = t_{k+1} - t_k$ seconds long. We assume that $t_1 = 0$. At the beginning of each slot, the video player makes a control decision on whether it should start downloading a new chunk, and if yes, its bitrate. If a download decision is made, then a request is sent to the server and the download starts immediately\\footnote{Any delays associated with sending the request can be added to the overall download time.}. This download takes $T_k$ seconds and is completed at the end of slot $k$. Note that $T_k$ is a random variable whose actual value depends on the realization of the $\\omega(t)$ process as well as the choice of chunk bitrate. If the player decides not to download a new chunk in slot $k$ (for example, when the buffer is full), then this slot lasts for a fixed duration of $\\Delta$ seconds.\n\nWe define the following indicator variable for each slot $k$:\n\n", "index": 5, "text": "\\begin{equation}\na_{m}(t_k) = \\left\\{ \\begin{array}{ll}\n1  & \\textrm{if the player downloads a chunk }\\\\\n   &  \\textrm{of bitrate $m$ in slot $k$, and}\\\\\n0  & \\textrm{otherwise.}\n\\end{array} \\right.\n\\label{eq:a_m}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"a_{m}(t_{k})=\\left\\{\\begin{array}[]{ll}1&amp;\\textrm{if the player downloads a %&#10;chunk }\\\\&#10;&amp;\\textrm{of bitrate $m$ in slot $k$, and}\\\\&#10;0&amp;\\textrm{otherwise.}\\end{array}\\right.\" display=\"block\"><mrow><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mtext>if the player downloads a chunk\u00a0</mtext></mtd></mtr><mtr><mtd/><mtd columnalign=\"left\"><mrow><mtext>of bitrate\u00a0</mtext><mi>m</mi><mtext>\u00a0in slot\u00a0</mtext><mi>k</mi><mtext>, and</mtext></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise.</mtext></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere the numerator denotes the expected total utility across all $N$ chunks. Note that a chunk can only be played back after it has been downloaded entirely. Thus, $T_{\\mathrm{end}}$ is greater than the last chunk's download finish time, i.e., $T_{\\mathrm{end}} > t_{K_N} + T_{K_N}$.\n\nThe second performance metric of interest is the expected fraction of time $\\overline{s}_N$ that is spent not rebuffering and can be interpreted as a measure of the average playback ``smoothness''. This can be calculated by observing that the actual playback time for all $N$ chunks is $Np$ seconds. Thus, the expected {\\em playback smoothness} $\\overline{s}_N$ is given by\n\n", "itemtype": "equation", "pos": 18944, "prevtext": "\nThen, for all $k$, we must have $\\sum_{m=1}^M a_{m}(t_k) \\leq 1$. Moreover, when $\\sum_{m=1}^M a_{m}(t_k) = 0$, then no chunks are downloaded. Let $K_N$ denote the index of the slot in which the $N^{\\textrm{th}}$ (i.e., last) chunk is downloaded. Also, denote the time at which the player finishes playing back the last chunk by $T_{\\mathrm{end}}$. Then the first performance metric of interest is the time-average expected {\\em playback utility} $\\overline{\\upsilon}_N$ which is defined as\n\n", "index": 7, "text": "\\begin{align}\n\\overline{\\upsilon}_N {\\mathbin{\\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}} \\frac{\\mathbb{E}\\left\\{{ \\sum_{k=1}^{K_N} \\sum_{m=1}^M a_{m}(t_k) \\upsilon_m}\\right\\}} {\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{\\upsilon}_{N}{\\mathbin{\\mbox{\\raisebox{-1.29pt}{$%&#10;\\overset{\\vartriangle}{=}$}}}}\\frac{\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_{N}}\\sum_{%&#10;m=1}^{M}a_{m}(t_{k})\\upsilon_{m}}\\right\\}}{\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}%&#10;\\right\\}}\" display=\"inline\"><mrow><mpadded depth=\"+1.3pt\" height=\"-1.3pt\" voffset=\"-1.3pt\"><mover accent=\"true\"><mo>=</mo><mo>\u25b3</mo></mover></mpadded><mo>\u2061</mo><msub><mover accent=\"true\"><mi>\u03c5</mi><mo>\u00af</mo></mover><mi>N</mi></msub><mstyle displaystyle=\"true\"><mfrac><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03c5</mi><mi>m</mi></msub></mrow></mrow></mrow><mo>}</mo></mrow></mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msub><mi>T</mi><mi>end</mi></msub><mo>}</mo></mrow></mrow></mfrac></mstyle></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere in the last step we use the relation that $Np = \\sum_{k=1}^{K_N} \\sum_{m=1}^M a_{m}(t_k) p$. Note that $T_{\\mathrm{end}} \\geq Np$ (since at most one chunk can be played back at any time), so that $\\overline{s}_N \\leq 1$.\n\n\\emph{Performance Objective}:\nWe want to design a control algorithm that maximizes the joint utility $\\overline{\\upsilon}_N + \\gamma \\overline{s}_N$ subject to the constraints of the model. $\\gamma > 0$ is an input weight parameter for prioritizing playback utility with the playback smoothness.\n\nThis problem can be formulated as a stochastic optimization problem with a time-average objective over a finite horizon and dynamic programming (DP) based approaches can be used to solve it \\cite{bertsekas1995dynamic}. However, traditional DP-based methods have two major disadvantages. First, they require knowledge of the distribution of the $\\omega(t)$ process which may be hard to obtain. Second, even when such knowledge is available, the resulting DP can have a very large state space. This is because the state space for this problem under a DP formulation would consist of not only the timeslot index $k$ and value $t_k$, but also the buffer occupancy and the quality types of the chunks in the buffer. Further, an appropriate discretization of the $\\omega(t)$ process would be required to obtain a tractable solution.\n\n\\subsection{Problem Relaxation}\n\\label{section:relax}\n\nIn order to overcome the above mentioned challenges associated with traditional DP based methods, we take the following approach. We consider this problem in the limiting regime when the video size becomes large, i.e., $N \\to \\infty$. In this regime, we can get the following two simplifications. First, the optimal control policy becomes independent of the slot index $k$. That is, it is sufficient to consider the class of stationary (and potentially randomized) algorithms that make control decisions only as a function of the buffer occupancy. Second, instead of considering the total playback finish time $T_{\\mathrm{end}}$, we can consider total download finish time in the objective. Specifically, in the limit $N \\to \\infty$, the metrics $\\overline{\\upsilon}_N $ and $\\overline{s}_N$ can be expressed as\n\n", "itemtype": "equation", "pos": 19850, "prevtext": "\nwhere the numerator denotes the expected total utility across all $N$ chunks. Note that a chunk can only be played back after it has been downloaded entirely. Thus, $T_{\\mathrm{end}}$ is greater than the last chunk's download finish time, i.e., $T_{\\mathrm{end}} > t_{K_N} + T_{K_N}$.\n\nThe second performance metric of interest is the expected fraction of time $\\overline{s}_N$ that is spent not rebuffering and can be interpreted as a measure of the average playback ``smoothness''. This can be calculated by observing that the actual playback time for all $N$ chunks is $Np$ seconds. Thus, the expected {\\em playback smoothness} $\\overline{s}_N$ is given by\n\n", "index": 9, "text": "\\begin{align}\n\\overline{s}_N {\\mathbin{\\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}} \\frac{Np} {\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}} = \\frac{\\mathbb{E}\\left\\{{ \\sum_{k=1}^{K_N} \\sum_{m=1}^M a_{m}(t_k) p}\\right\\}} {\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{s}_{N}{\\mathbin{\\mbox{\\raisebox{-1.29pt}{$\\overset{%&#10;\\vartriangle}{=}$}}}}\\frac{Np}{\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}}=%&#10;\\frac{\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_{N}}\\sum_{m=1}^{M}a_{m}(t_{k})p}\\right\\}%&#10;}{\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}}\" display=\"inline\"><mrow><mrow><mpadded depth=\"+1.3pt\" height=\"-1.3pt\" voffset=\"-1.3pt\"><mover accent=\"true\"><mo>=</mo><mo>\u25b3</mo></mover></mpadded><mo>\u2061</mo><msub><mover accent=\"true\"><mi>s</mi><mo>\u00af</mo></mover><mi>N</mi></msub><mstyle displaystyle=\"true\"><mfrac><mrow><mi>N</mi><mo>\u2062</mo><mi>p</mi></mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msub><mi>T</mi><mi>end</mi></msub><mo>}</mo></mrow></mrow></mfrac></mstyle></mrow><mo>=</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>p</mi></mrow></mrow></mrow><mo>}</mo></mrow></mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msub><mi>T</mi><mi>end</mi></msub><mo>}</mo></mrow></mrow></mfrac></mstyle></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nThis follows by noting that the difference between the expected total playback finish time $\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}$ and the expected total download finish time $\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_N} {T_{k}}}\\right\\}$ is upper bounded by a finite value due to the finite buffer size $Q_{\\max}$. Specifically, this upper bound is given by $Q_{\\max} p$.\n\nLet us denote the optimal time-average values of these metrics in the large $N$ regime under an optimal policy by $\\upsilon^*$ and $s^*$ respectively. Note that while the optimal policy in the large $N$ regime does not depend on the slot index, it can still depend on the buffer occupancy state. To address this, we temporarily replace the finite buffer constraint of our model with a \\emph{rate stability} constraint \\cite{neely2010}. This constraint only requires that the time-average arrival rate into the buffer is equal to the time-average playback rate. It is clear that optimal time-average values of the metrics under this relaxation cannot be smaller than $\\upsilon^*$ and $s^*$ respectively since the optimal policy for the finite buffer constrained model is rate stable. Moreover, the following can be shown under this relaxation.\n\\begin{lem}\n\\label{lem:policy}\nIn the large $N$ regime, there exists a \\emph{buffer-state-independent} stationary policy that makes i.i.d. control decisions in every slot and satisfies the rate stability constraint while achieving time-average utility no smaller than $\\upsilon^* + \\gamma s^*$.\n\\end{lem}\n\\begin{IEEEproof}\nThis follows from Theorem $4.5$ in \\cite{neely2010} and is omitted for brevity.\n\\end{IEEEproof}\nNote that such a {buffer-state-independent} stationary policy is not necessarily feasible for our finite buffer system. Further, calculating it explicitly would require knowledge of the distribution of $\\omega(t)$. However, instead of calculating this policy explicitly, we will use its existence and characterization per Lemma~\\ref{lem:policy} to design an \\emph{online} control algorithm using Lyapunov optimization \\cite{neely2010}. We will show that this online algorithm is feasible for our finite buffer system and achieves a time-average utility that is within $O(1/Q_{\\max})$ of $\\upsilon^* + \\gamma s^*$ without requiring any knowledge of the distribution of $\\omega(t)$.\n\n\\section{BOLA: An Online Control Algorithm}\n\\label{section:online_algo}\n\nOur online control algorithm for bitrate adaptation makes use of the current buffer level (measured in number of chunks) that we denote by $Q(t_k)$. This is updated at the start of each slot using the following equation:\n\n", "itemtype": "equation", "pos": 22358, "prevtext": "\nwhere in the last step we use the relation that $Np = \\sum_{k=1}^{K_N} \\sum_{m=1}^M a_{m}(t_k) p$. Note that $T_{\\mathrm{end}} \\geq Np$ (since at most one chunk can be played back at any time), so that $\\overline{s}_N \\leq 1$.\n\n\\emph{Performance Objective}:\nWe want to design a control algorithm that maximizes the joint utility $\\overline{\\upsilon}_N + \\gamma \\overline{s}_N$ subject to the constraints of the model. $\\gamma > 0$ is an input weight parameter for prioritizing playback utility with the playback smoothness.\n\nThis problem can be formulated as a stochastic optimization problem with a time-average objective over a finite horizon and dynamic programming (DP) based approaches can be used to solve it \\cite{bertsekas1995dynamic}. However, traditional DP-based methods have two major disadvantages. First, they require knowledge of the distribution of the $\\omega(t)$ process which may be hard to obtain. Second, even when such knowledge is available, the resulting DP can have a very large state space. This is because the state space for this problem under a DP formulation would consist of not only the timeslot index $k$ and value $t_k$, but also the buffer occupancy and the quality types of the chunks in the buffer. Further, an appropriate discretization of the $\\omega(t)$ process would be required to obtain a tractable solution.\n\n\\subsection{Problem Relaxation}\n\\label{section:relax}\n\nIn order to overcome the above mentioned challenges associated with traditional DP based methods, we take the following approach. We consider this problem in the limiting regime when the video size becomes large, i.e., $N \\to \\infty$. In this regime, we can get the following two simplifications. First, the optimal control policy becomes independent of the slot index $k$. That is, it is sufficient to consider the class of stationary (and potentially randomized) algorithms that make control decisions only as a function of the buffer occupancy. Second, instead of considering the total playback finish time $T_{\\mathrm{end}}$, we can consider total download finish time in the objective. Specifically, in the limit $N \\to \\infty$, the metrics $\\overline{\\upsilon}_N $ and $\\overline{s}_N$ can be expressed as\n\n", "index": 11, "text": "\\begin{align}\n&\\overline{\\upsilon}  {\\mathbin{\\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}}  \\lim_{N \\to \\infty} \\overline{\\upsilon}_N  = \\frac{ {\\displaystyle \\lim_{N \\to \\infty}} \\mathbb{E}\\left\\{{\\! \\frac{1}{K_N}  \\sum_{k=1}^{K_N} \\sum_{m=1}^M a_{m}(t_k) \\upsilon_m \\!}\\right\\}} {{\\displaystyle \\lim_{N \\to \\infty}} \\mathbb{E}\\left\\{{\\frac{1}{K_N} \\sum_{k=1}^{K_N} T_{k}}\\right\\}} \\label{eq:inf_u} \\\\\n& \\overline{s}  {\\mathbin{\\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}}  \\lim_{N \\to \\infty} \\overline{s}_N  = \\frac{{\\displaystyle \\lim_{N \\to \\infty}} \\mathbb{E}\\left\\{{\\frac{1}{K_N}  \\sum_{k=1}^{K_N}  \\sum_{m=1}^M a_{m}(t_k) p}\\right\\}} {{\\displaystyle \\lim_{N \\to \\infty}} \\mathbb{E}\\left\\{{\\frac{1}{K_N}  \\sum_{k=1}^{K_N}  T_{k}}\\right\\}} \\label{eq:inf_s}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{\\upsilon}{\\mathbin{\\mbox{\\raisebox{-1.29pt}{$\\overset{%&#10;\\vartriangle}{=}$}}}}\\lim_{N\\to\\infty}\\overline{\\upsilon}_{N}=\\frac{{%&#10;\\displaystyle\\lim_{N\\to\\infty}}\\mathbb{E}\\left\\{{\\!\\frac{1}{K_{N}}\\sum_{k=1}^{%&#10;K_{N}}\\sum_{m=1}^{M}a_{m}(t_{k})\\upsilon_{m}\\!}\\right\\}}{{\\displaystyle\\lim_{N%&#10;\\to\\infty}}\\mathbb{E}\\left\\{{\\frac{1}{K_{N}}\\sum_{k=1}^{K_{N}}T_{k}}\\right\\}}\" display=\"inline\"><mrow><mrow><mpadded depth=\"+1.3pt\" height=\"-1.3pt\" voffset=\"-1.3pt\"><mover accent=\"true\"><mo>=</mo><mo>\u25b3</mo></mover></mpadded><mo>\u2061</mo><mover accent=\"true\"><mi>\u03c5</mi><mo>\u00af</mo></mover><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><msub><mover accent=\"true\"><mi>\u03c5</mi><mo>\u00af</mo></mover><mi>N</mi></msub></mrow></mrow><mo>=</mo><mstyle displaystyle=\"true\"><mfrac><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo rspace=\"0.8pt\">{</mo><mrow><mfrac><mn>1</mn><msub><mi>K</mi><mi>N</mi></msub></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mpadded width=\"-1.7pt\"><msub><mi>\u03c5</mi><mi>m</mi></msub></mpadded></mrow></mrow></mrow></mrow><mo>}</mo></mrow></mrow></mrow><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mfrac><mn>1</mn><msub><mi>K</mi><mi>N</mi></msub></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><msub><mi>T</mi><mi>k</mi></msub></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mfrac></mstyle></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{s}{\\mathbin{\\mbox{\\raisebox{-1.29pt}{$\\overset{%&#10;\\vartriangle}{=}$}}}}\\lim_{N\\to\\infty}\\overline{s}_{N}=\\frac{{\\displaystyle%&#10;\\lim_{N\\to\\infty}}\\mathbb{E}\\left\\{{\\frac{1}{K_{N}}\\sum_{k=1}^{K_{N}}\\sum_{m=1%&#10;}^{M}a_{m}(t_{k})p}\\right\\}}{{\\displaystyle\\lim_{N\\to\\infty}}\\mathbb{E}\\left\\{%&#10;{\\frac{1}{K_{N}}\\sum_{k=1}^{K_{N}}T_{k}}\\right\\}}\" display=\"inline\"><mrow><mrow><mpadded depth=\"+1.3pt\" height=\"-1.3pt\" voffset=\"-1.3pt\"><mover accent=\"true\"><mo>=</mo><mo>\u25b3</mo></mover></mpadded><mo>\u2061</mo><mover accent=\"true\"><mi>s</mi><mo>\u00af</mo></mover><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><msub><mover accent=\"true\"><mi>s</mi><mo>\u00af</mo></mover><mi>N</mi></msub></mrow></mrow><mo>=</mo><mstyle displaystyle=\"true\"><mfrac><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mfrac><mn>1</mn><msub><mi>K</mi><mi>N</mi></msub></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>p</mi></mrow></mrow></mrow></mrow><mo>}</mo></mrow></mrow></mrow><mrow><munder><mo movablelimits=\"false\">lim</mo><mrow><mi>N</mi><mo>\u2192</mo><mi mathvariant=\"normal\">\u221e</mi></mrow></munder><mo>\u2061</mo><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mfrac><mn>1</mn><msub><mi>K</mi><mi>N</mi></msub></mfrac><mo>\u2062</mo><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></msubsup><msub><mi>T</mi><mi>k</mi></msub></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mfrac></mstyle></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nHere, the arrival value into this queue in slot $k$ is given by $\\sum_{m=1}^M a_m(t_k)$ which is $1$ if a download decision is made in slot $k$ and $0$ otherwise. The departure value is $T_k/p$ which represents the total number of chunks (including fractional chunks) that could have departed the buffer in slot $k$. Note that the  actual value of $T_k$ is revealed at the end of slot $k$. We assume that the buffer level is initialized to $0$, i.e., $Q(t_1) = 0$.\n\nThe \\emph{Lyapunov optimization-over-renewal-frames} method \\cite{neely2010} can be used to derive an algorithm that optimizes the metrics in \\eqref{eq:inf_u}--\\eqref{eq:Q}. The method greedily minimizes the ratio of \\emph{drift plus penalty} to \\emph{frame length} over each slot. We now give a high-level intuition of how to derive the algorithm. In slot $k$, the buffer is kept stable by minimizing the drift defined as $\\mathbb{E}\\left\\{{(Q(t_{k+1})^2-Q(t_k)^2)/2 \\mid Q(t_k)}\\right\\}$. Using \\eqref{eq:Q}, we achieve buffer stability by minimizing \\mbox{$Q(t_k)(\\sum_{m=1}^{M}a_m-T_k/p)$}. Using \\eqref{eq:inf_u}--\\eqref{eq:inf_s}, the performance objective to maximize \\mbox{$\\overline{\\upsilon} + \\gamma \\overline{s}$} is achieved by maximizing $(\\sum_{m=1}^{M}a_m(t_k)(\\upsilon_m + \\gamma p))$. The expected frame (slot) length has a linear relation to $\\sum_{m=1}^{M}a_m(t_k)S_m$. We use a control parameter $V > 0$ related to the maximum buffer size to allow a tradeoff between the buffer size and the distance from the optimal utility.\n\nIn every slot $k$, given the buffer level $Q(t_k)$ at the start of the slot, our algorithm makes a control decision by solving the following deterministic optimization problem:\n\n", "itemtype": "equation", "pos": 25761, "prevtext": "\nThis follows by noting that the difference between the expected total playback finish time $\\mathbb{E}\\left\\{{T_{\\mathrm{end}}}\\right\\}$ and the expected total download finish time $\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_N} {T_{k}}}\\right\\}$ is upper bounded by a finite value due to the finite buffer size $Q_{\\max}$. Specifically, this upper bound is given by $Q_{\\max} p$.\n\nLet us denote the optimal time-average values of these metrics in the large $N$ regime under an optimal policy by $\\upsilon^*$ and $s^*$ respectively. Note that while the optimal policy in the large $N$ regime does not depend on the slot index, it can still depend on the buffer occupancy state. To address this, we temporarily replace the finite buffer constraint of our model with a \\emph{rate stability} constraint \\cite{neely2010}. This constraint only requires that the time-average arrival rate into the buffer is equal to the time-average playback rate. It is clear that optimal time-average values of the metrics under this relaxation cannot be smaller than $\\upsilon^*$ and $s^*$ respectively since the optimal policy for the finite buffer constrained model is rate stable. Moreover, the following can be shown under this relaxation.\n\\begin{lem}\n\\label{lem:policy}\nIn the large $N$ regime, there exists a \\emph{buffer-state-independent} stationary policy that makes i.i.d. control decisions in every slot and satisfies the rate stability constraint while achieving time-average utility no smaller than $\\upsilon^* + \\gamma s^*$.\n\\end{lem}\n\\begin{IEEEproof}\nThis follows from Theorem $4.5$ in \\cite{neely2010} and is omitted for brevity.\n\\end{IEEEproof}\nNote that such a {buffer-state-independent} stationary policy is not necessarily feasible for our finite buffer system. Further, calculating it explicitly would require knowledge of the distribution of $\\omega(t)$. However, instead of calculating this policy explicitly, we will use its existence and characterization per Lemma~\\ref{lem:policy} to design an \\emph{online} control algorithm using Lyapunov optimization \\cite{neely2010}. We will show that this online algorithm is feasible for our finite buffer system and achieves a time-average utility that is within $O(1/Q_{\\max})$ of $\\upsilon^* + \\gamma s^*$ without requiring any knowledge of the distribution of $\\omega(t)$.\n\n\\section{BOLA: An Online Control Algorithm}\n\\label{section:online_algo}\n\nOur online control algorithm for bitrate adaptation makes use of the current buffer level (measured in number of chunks) that we denote by $Q(t_k)$. This is updated at the start of each slot using the following equation:\n\n", "index": 13, "text": "\\begin{align}\nQ(t_{k+1}) = \\max[Q(t_k) - \\frac{T_k}{p}, 0] + \\sum_{m=1}^M a_m(t_k)\n\\label{eq:Q}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle Q(t_{k+1})=\\max[Q(t_{k})-\\frac{T_{k}}{p},0]+\\sum_{m=1}^{M}a_{m}(%&#10;t_{k})\" display=\"inline\"><mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><msub><mi>T</mi><mi>k</mi></msub><mi>p</mi></mfrac></mstyle></mrow><mo>,</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow></mrow><mo>+</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nThe constraints of this problem result in a very simple solution structure. Specifically, the optimal solution is given by:\n\\begin{enumerate}\n\\item\nIf $Q(t_k) > V ( \\upsilon_m + \\gamma p)$ for all $m \\in \\{1, 2, \\ldots, M\\}$, then the no-download option is chosen, i.e., $a_m(t_k) = 0$ for all $m$. Note that in this case $T_k = \\Delta$.\n\\item\nElse, the optimal solution is to download the next chunk at quality index $m^*$ where $m^*$ is the index that maximizes the ratio $\\big(V\\upsilon_m + V \\gamma p - Q(t_k)\\big)/{S_m}$ among all $m$ for which this ratio is positive.\n\\end{enumerate}\n\nNotice that solving this problem does not require any knowledge of the $\\omega(t)$ process. Further, the optimal solution depends only on the buffer level $Q(t_k)$. That's why we call our algorithm \\emph{BOLA: Buffer Occupancy based Lyapunov Algorithm}. These properties of \\mbox{BOLA} should be contrasted with the bandwidth prediction based strategies that have been recently proposed for this problem that require explicit prediction of the available bandwidth for control decisions.\n\nThe following theorem characterizes the theoretical performance guarantees provided by \\mbox{BOLA}.\n\\begin{thm}\n\\label{thm:BOLA}\nSuppose \\mbox{BOLA} as defined by (\\ref{eq:lyp_algo}) is implemented in every slot using a control parameter $0 < V \\leq \\frac{Q_{\\max} - 1}{\\upsilon_1 + \\gamma p}$. Assume $Q(0) = 0$. Then, the following hold.\n\\begin{enumerate}\n\\item\nThe queue backlog satisfies $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ for all slots $k$. Further, the buffer occupancy in chunks never exceeds $Q_{\\max}$.\n\\item\nThe time-average utility achieved by \\mbox{BOLA} satisfies\n\n", "itemtype": "equation", "pos": 27560, "prevtext": "\nHere, the arrival value into this queue in slot $k$ is given by $\\sum_{m=1}^M a_m(t_k)$ which is $1$ if a download decision is made in slot $k$ and $0$ otherwise. The departure value is $T_k/p$ which represents the total number of chunks (including fractional chunks) that could have departed the buffer in slot $k$. Note that the  actual value of $T_k$ is revealed at the end of slot $k$. We assume that the buffer level is initialized to $0$, i.e., $Q(t_1) = 0$.\n\nThe \\emph{Lyapunov optimization-over-renewal-frames} method \\cite{neely2010} can be used to derive an algorithm that optimizes the metrics in \\eqref{eq:inf_u}--\\eqref{eq:Q}. The method greedily minimizes the ratio of \\emph{drift plus penalty} to \\emph{frame length} over each slot. We now give a high-level intuition of how to derive the algorithm. In slot $k$, the buffer is kept stable by minimizing the drift defined as $\\mathbb{E}\\left\\{{(Q(t_{k+1})^2-Q(t_k)^2)/2 \\mid Q(t_k)}\\right\\}$. Using \\eqref{eq:Q}, we achieve buffer stability by minimizing \\mbox{$Q(t_k)(\\sum_{m=1}^{M}a_m-T_k/p)$}. Using \\eqref{eq:inf_u}--\\eqref{eq:inf_s}, the performance objective to maximize \\mbox{$\\overline{\\upsilon} + \\gamma \\overline{s}$} is achieved by maximizing $(\\sum_{m=1}^{M}a_m(t_k)(\\upsilon_m + \\gamma p))$. The expected frame (slot) length has a linear relation to $\\sum_{m=1}^{M}a_m(t_k)S_m$. We use a control parameter $V > 0$ related to the maximum buffer size to allow a tradeoff between the buffer size and the distance from the optimal utility.\n\nIn every slot $k$, given the buffer level $Q(t_k)$ at the start of the slot, our algorithm makes a control decision by solving the following deterministic optimization problem:\n\n", "index": 15, "text": "\\begin{align}\n\\textrm{Maximize} \\;\\;\\; & \\frac{\\sum_{m=1}^M  a_m(t_k) \\big(V\\upsilon_m + V \\gamma p - Q(t_k) \\big)}{\\sum_{m=1}^M  a_m(t_k) S_m}    \\nonumber \\\\\n\\textrm{subject to} \\;\\;\\;  & \\sum_{m=1}^M a_{m}(t_k) \\leq 1, a_{m}(t_k) \\in \\{0, 1\\}\n\\label{eq:lyp_algo}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\frac{\\sum_{m=1}^{M}a_{m}(t_{k})\\big{(}V\\upsilon_{m}+V\\gamma p-Q(%&#10;t_{k})\\big{)}}{\\sum_{m=1}^{M}a_{m}(t_{k})S_{m}}\" display=\"inline\"><mstyle displaystyle=\"true\"><mfrac><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo maxsize=\"120%\" minsize=\"120%\">(</mo><mrow><mrow><mrow><mi>V</mi><mo>\u2062</mo><msub><mi>\u03c5</mi><mi>m</mi></msub></mrow><mo>+</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo>-</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"120%\" minsize=\"120%\">)</mo></mrow></mrow></mrow><mrow><msubsup><mo largeop=\"true\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>S</mi><mi>m</mi></msub></mrow></mrow></mfrac></mstyle></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{m=1}^{M}a_{m}(t_{k})\\leq 1,a_{m}(t_{k})\\in\\{0,1\\}\" display=\"inline\"><mrow><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>\u2264</mo><mn>1</mn></mrow><mo>,</mo><mrow><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2208</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere $\\Psi$ is an upper bound on $\\mathbb{E}\\left\\{{T_k^2}\\right\\}$ under any control algorithm and is assumed to be finite.\n\\end{enumerate}\n\\label{thm:perf_bounds}\n\\end{thm}\n\\begin{IEEEproof}\nSee the \\hyperref[sec:NP-proof]{Appendix}.\n\\end{IEEEproof}\n\\emph{Remarks:}\nThe performance bounds in Theorem \\ref{thm:perf_bounds} show a $O(1/V, V)$ utility and backlog tradeoff that is typical of Lyapunov based control algorithms for similar utility maximization problems. Specifically, the time-average utility of \\mbox{BOLA} is within an $O(1/V)$ additive term of the optimal utility and this gap may be made smaller by  choosing a larger value of $V$. However, the largest feasible value of $V$ is constrained by the buffer size and there is a linear relation between them.\n\n\\subsection{Understanding BOLA With an Example}\n\\label{subsec:example}\n\nWe now present a sample run to illustrate how BOLA works. We slice a 99-second video using 3-second chunks and encode it at five different bitrates. While BOLA only requires the utilities to be a non-decreasing function of the chunk bitrate, it is natural to consider concave utility functions with diminishing returns, e.g., a 1 Mbps increase in chunk bitrate likely provides a larger utility gain for the user when that increase is from 0.5~Mbps to 1.5~Mbps than when it is from 5~Mbps to 6 Mbps. A natural choice for our example is the logarithmic utility function: let $\\upsilon_m = \\ln(S_m / S_M)$. Pick $\\gamma=5.0 / p$ and $V=0.93$. The bitrates and utilities are below.\n\n\\begin{center}\n  \\scriptsize\n  \\begin{tabular}{|c||c|c|c|c|c|}\n    \\hline\n    bitrate (Mbps) & 6.000 & 2.962 & 1.427 & 0.688 & 0.331 \\\\\n    \\hline\n    $S$ (Mb)       & 18.00 & 8.886 & 4.281 & 2.064 & 0.993 \\\\\n    \\hline\n    $\\upsilon$     & 2.897 & 2.192 & 1.461 & 0.732 & 0.000 \\\\\n    \\hline\n  \\end{tabular}\n\n\\end{center}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_threshold}\n  \\caption{The value of $(V \\upsilon_m + V \\gamma p - Q) / S_m$ for different bitrates depends on buffer level. ($\\gamma p = 5$ and $V = 0.93$.) Note that the buffer level is $Qp$ seconds.}\n  \\label{fig:DemoThreshold}\n\\end{figure}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_decision}\n  \\caption{\\mbox{BOLA}'s bitrate choice as function of buffer level. ($\\gamma p = 5$,$V = 0.93$.) Note that the buffer level is $Qp$ seconds.}\n  \\label{fig:DemoDecision}\n\\end{figure}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_bitrate} \\\\\n  \\includegraphics{fig_demo_buffer}\n  \\caption{Sample video download and playback using \\mbox{BOLA}. (a) The video is encoded at 5 different bitrates. The network bandwidth varies from high to low and back to high. The downloaded chunk bitrate adapts to the network bandwidth. (b) The buffer level variation triggers bitrate changes when it crosses the thresholds.}\n  \\label{fig:Demo}\n\\end{figure}\n\nFor any slot we choose the chunk bitrate to maximize $(V \\upsilon_m + V \\gamma p - Q) / S_m$ for $1 \\leq m \\leq M$. Fig.~\\ref{fig:DemoThreshold} shows the relationship between the expression and the buffer level $Q$ for different $m$. The line intersections mark the buffer levels that correspond to decision thresholds. Fig.~\\ref{fig:DemoDecision} summarizes \\mbox{BOLA}'s bitrate choices as a function of the buffer level. \n\nFig.~\\ref{fig:Demo} shows how \\mbox{BOLA} works. We use a synthetic network bandwidth profile as shown in Fig.~\\ref{fig:Demo}(a). We can see the feedback loop involving the bitrate in (a) and the buffer level in (b). \\mbox{BOLA} chooses the bitrate based directly on the buffer level using Fig.~\\ref{fig:DemoDecision}. The bitrate affects the download time, thus it indirectly affects the buffer level at the beginning of the following slot. Finally, when all the chunks are downloaded, the video player plays out the chunks remaining in the buffer.\n\n\\subsection{\\texorpdfstring{Choosing Utility and Parameters $\\gamma$ and $V$}{Choosing Utility and Parameters g and V}}\n\\label{subsec:param}\n\nWhile we chose a logarithmic utility function for the example, a video provider can use any utility function satisfying~\\eqref{eq:upsilon}. The utility function might also take into account system characteristics such as the type of device a viewer is using.\n\n$\\gamma$ corresponds to how strongly we want to avoid rebuffering. Increasing $\\gamma$ translates the graphs in Figs.~\\ref{fig:DemoThreshold} and~\\ref{fig:DemoDecision} to the right, effectively shifting the thresholds higher without changing their relative distance. \\mbox{BOLA} will thus download more low-bitrate chunks to maintain a larger (and safer) buffer level.\n\nIncreasing $V$ expands the graphs in Figs.~\\ref{fig:DemoThreshold} and~\\ref{fig:DemoDecision} horizontally about the origin. If we have a maximum buffer level $Q_{\\max}$ we want to avoid downloading unless there is enough space for one full chunk on the buffer, that is unless $Q \\leq Q_{\\max} - 1$. For a given $Q_{\\max}$ we can set $V = (Q_{\\max} - 1) / (\\upsilon_1 + \\gamma p)$.\n\nAfter choosing a utility function, a video provider might want to specify a safe buffer level such that \\mbox{BOLA} will always choose the lowest bitrate when the buffer falls below the level. $\\gamma$ and $V$ can be calculated to satisfy the safe buffer level constraint and a maximum buffer level constraint.\n\n\\section{Implementation and Empirical Evaluation}\n\n\\label{sec:empirical}\n\nWe first implemented a basic version of \\mbox{BOLA}, named \\mbox{BOLA-BASIC}, directly from \\eqref{eq:lyp_algo}. Recall that when the buffer level is full \\mbox{BOLA} does not download a chunk but waits for $\\Delta$~seconds. Rather than picking an arbitrary value for $\\Delta$, we use a dynamic wait until $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p)$. This has the same effect as picking a fixed but very small $\\Delta$, so the theoretical analysis still holds. We also implemented other versions of \\mbox{BOLA}, namely \\mbox{BOLA-FINITE}, \\mbox{BOLA-O}, and \\mbox{BOLA-U}, that we describe later in this section.\n\n\\subsection{Test Methodology}\n\nWe simulated all versions of \\mbox{BOLA} using the Big Buck Bunny movie \\cite{bigbuckbunny}. The 10-minute movie was encoded at 10 different bitrates and sliced in 3-second chunks. Although each quality index has a specified average bitrate, chunks may have variable bitrate (VBR) because of the varying nature of the movie. We simulate playback times longer than 10 minutes by repeating the movie. Again we choose a logarithmic utility function: $\\upsilon_m = \\ln(S_m / S_M)$. Table~\\ref{tab:bitrates} shows the mean and standard deviation of the bitrate and chunk size for each quality index and the respective utility values.\n\n\\begin{table}\n  \\caption{Bitrates used for Big Buck Bunny Test Video}\n  \\label{tab:bitrates}\n  \\centering\n  \\scriptsize\n  \\begin{tabular}{r|cc|cc|c}\n    \\hline\n    \\multicolumn{1}{c|}{Bitrate} &\n    \\multicolumn{2}{c|}{Bitrate (Mbps)} &\n    \\multicolumn{2}{c|}{Chunk Size $S$ (Mb)} &\n    Utility \\\\\n    \\multicolumn{1}{c|}{Index} &\n    Mean & Standard & Mean   & Standard & $\\upsilon$ \\\\\n    \\multicolumn{1}{c|}{$m$} &\n    & Deviation & & Deviation & ${}=\\ln(S/S_M)$ \\\\\n    \\hline\n    1        & 6.000   & 1.078    & 18.00 & 3.232    &  3.261   \\\\\n    2        & 5.027   & 0.891    & 15.08 & 2.673    &  3.084   \\\\\n    3        & 2.962   & 0.564    & 8.886 & 1.691    &  2.556   \\\\\n    4        & 2.056   & 0.394    & 6.168 & 1.182    &  2.190   \\\\\n    5        & 1.427   & 0.275    & 4.281 & 0.825    &  1.825   \\\\\n    6        & 0.991   & 0.182    & 2.973 & 0.545    &  1.461   \\\\\n    7        & 0.688   & 0.120    & 2.064 & 0.360    &  1.096   \\\\\n    8        & 0.477   & 0.096    & 1.431 & 0.287    &  0.729   \\\\\n    9        & 0.331   & 0.054    & 0.993 & 0.162    &  0.364   \\\\\n    $M={}$10 & 0.230   & 0.038    & 0.690 & 0.113    &  0.000   \\\\\n    \\hline\n  \\end{tabular}\n\\end{table}\n\n\\begin{table}\n  \\caption{Network Profiles for the Dash Benchmarks}\n  \\label{tab:profiles}\n  \\centering\n  \\scriptsize\n  \\begin{tabular}{r@{~(}r@{)}r|r@{~(}r@{)}r|r@{~(}r@{)}r||r@{~(}r@{)}r|r@{~(}r@{)}r|r@{~(}r@{)}r}\n    \\hline\n    \\multicolumn{3}{c|}{1} & \\multicolumn{3}{c|}{3} & \\multicolumn{3}{c||}{5} & \\multicolumn{3}{c|}{7} & \\multicolumn{3}{c|}{9} & \\multicolumn{3}{c}{11} \\\\\n    \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c||}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c}{Mbps\\,(ms)\\!} \\\\\n    \\hline\n    5.0 &  38 && 5.0 &  13 && 5.0 &  11 &&  \\multicolumn{2}{}{} && \\multicolumn{2}{}{} && \\multicolumn{2}{}{} \\\\\n    4.0 &  50 && 4.0 &  18 && 4.0 &  13 &&  9.0 &  25 && 9.0 &  10 && 9.0 &   6 \\\\\n    3.0 &  75 && 3.0 &  28 && 3.0 &  15 &&  4.0 &  50 && 4.0 &  50 && 4.0 &  13 \\\\\n    2.0 &  88 && 2.0 &  58 && 2.0 &  20 &&  2.0 &  75 && 2.0 & 150 && 2.0 &  20 \\\\\n    1.5 & 100 && 1.5 & 200 && 1.5 &  25 &&  1.0 & 100 && 1.0 & 200 && 1.0 &  25 \\\\\n    2.0 &  88 && 2.0 &  58 && 2.0 &  20 &&  2.0 &  75 && 2.0 & 150 && 2.0 &  20 \\\\\n    3.0 &  75 && 3.0 &  28 && 3.0 &  15 &&  4.0 &  50 && 4.0 &  50 && 4.0 &  13 \\\\\n    4.0 &  50 && 4.0 &  18 && 4.0 &  13 &&  \\multicolumn{2}{}{} && \\multicolumn{2}{}{} && \\multicolumn{2}{}{} \\\\\n    \\hline\n  \\end{tabular}\n\\end{table}\n\nThe DASH Industry Forum provides benchmarks for various aspects of the DASH standard \\cite{dashtest}. The benchmarks include twelve different network profiles. Profiles 1--6 have network bandwidths ranging from 1.5 to 5~Mbps while profiles 7--12 have bandwidths ranging from 1 to 9~Mbps. Different latencies are provided for each bandwidth, where the latency is half the round-trip time (RTT). Table~\\ref{tab:profiles} shows the odd-numbered bandwidth characteristics. Profile 1 spends 30s at each of 5, 4, 3, 2, 1.5, 2, 3 and 4~Mbps respectively, then starts back at the top. Even-numbered profiles are similar to the preceding odd-numbered profiles but start at the low bandwidth stage. For example, profile~2 starts at 1.5~Mbps.\n\nIn addition, we also tested our algorithms using a set of 86 3G mobile bandwidth traces that are publicly available \\cite{riiser2013}. One trace was excluded because it had an average bandwidth of 80~kbps; our lowest video bitrate is 230~kbps. Since the traces do not include latency measurements, we used 50~ms latency giving a RTT of 100~ms throughout. This is the median RTT measured empirically in \\cite{romirer2009network}.\n\n\\subsection{Computing an Upper Bound on the Maximum Utility}\n\n\\label{subsec:bound}\n\nIn order to evaluate how well \\mbox{BOLA} performs on the traces, it is important to derive an upper bound on the maximum utility that is obtainable by {\\em any} algorithm on a given trace. We derive an {\\em offline} optimal algorithm that provides the maximum achievable utility using dynamic programming. We define a table $r(n,t,b)$ that contains the maximum utility possible when we download the $n^{\\text{th}}$ chunk and finish at time $t$ with buffer level $b$. We initialize the table with $r(0,0,0) = 0$. Let $x(n,t,m)$ be the time to download the $n^{\\text{th}}$ chunk at bitrate index $m$ starting at time $t$. Note that the dependency of $x$ on $n$ is due to VBR. We quantize the time with granularity $\\delta$. While some accuracy is lost, we ensure the final result will still be an upper bound by rounding the download time down.\n\n", "itemtype": "equation", "pos": 29502, "prevtext": "\nThe constraints of this problem result in a very simple solution structure. Specifically, the optimal solution is given by:\n\\begin{enumerate}\n\\item\nIf $Q(t_k) > V ( \\upsilon_m + \\gamma p)$ for all $m \\in \\{1, 2, \\ldots, M\\}$, then the no-download option is chosen, i.e., $a_m(t_k) = 0$ for all $m$. Note that in this case $T_k = \\Delta$.\n\\item\nElse, the optimal solution is to download the next chunk at quality index $m^*$ where $m^*$ is the index that maximizes the ratio $\\big(V\\upsilon_m + V \\gamma p - Q(t_k)\\big)/{S_m}$ among all $m$ for which this ratio is positive.\n\\end{enumerate}\n\nNotice that solving this problem does not require any knowledge of the $\\omega(t)$ process. Further, the optimal solution depends only on the buffer level $Q(t_k)$. That's why we call our algorithm \\emph{BOLA: Buffer Occupancy based Lyapunov Algorithm}. These properties of \\mbox{BOLA} should be contrasted with the bandwidth prediction based strategies that have been recently proposed for this problem that require explicit prediction of the available bandwidth for control decisions.\n\nThe following theorem characterizes the theoretical performance guarantees provided by \\mbox{BOLA}.\n\\begin{thm}\n\\label{thm:BOLA}\nSuppose \\mbox{BOLA} as defined by (\\ref{eq:lyp_algo}) is implemented in every slot using a control parameter $0 < V \\leq \\frac{Q_{\\max} - 1}{\\upsilon_1 + \\gamma p}$. Assume $Q(0) = 0$. Then, the following hold.\n\\begin{enumerate}\n\\item\nThe queue backlog satisfies $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ for all slots $k$. Further, the buffer occupancy in chunks never exceeds $Q_{\\max}$.\n\\item\nThe time-average utility achieved by \\mbox{BOLA} satisfies\n\n", "index": 17, "text": "\\begin{align}\n\\overline{\\upsilon}^{\\mathrm{BOLA}} + \\gamma \\overline{s}^{\\mathrm{BOLA}} \\geq  \\upsilon^* + \\gamma s^* - \\frac{p^2 + \\Psi}{2p^2V}\n\\label{eq:bound2}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{\\upsilon}^{\\mathrm{BOLA}}+\\gamma\\overline{s}^{\\mathrm{%&#10;BOLA}}\\geq\\upsilon^{*}+\\gamma s^{*}-\\frac{p^{2}+\\Psi}{2p^{2}V}\" display=\"inline\"><mrow><mrow><msup><mover accent=\"true\"><mi>\u03c5</mi><mo>\u00af</mo></mover><mi>BOLA</mi></msup><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mover accent=\"true\"><mi>s</mi><mo>\u00af</mo></mover><mi>BOLA</mi></msup></mrow></mrow><mo>\u2265</mo><mrow><mrow><msup><mi>\u03c5</mi><mo>*</mo></msup><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mi>s</mi><mo>*</mo></msup></mrow></mrow><mo>-</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup><mo>\u2062</mo><mi>V</mi></mrow></mfrac></mstyle></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nWe cap the buffer level at $b_{\\max}$.\n\n", "itemtype": "equation", "pos": 40992, "prevtext": "\nwhere $\\Psi$ is an upper bound on $\\mathbb{E}\\left\\{{T_k^2}\\right\\}$ under any control algorithm and is assumed to be finite.\n\\end{enumerate}\n\\label{thm:perf_bounds}\n\\end{thm}\n\\begin{IEEEproof}\nSee the \\hyperref[sec:NP-proof]{Appendix}.\n\\end{IEEEproof}\n\\emph{Remarks:}\nThe performance bounds in Theorem \\ref{thm:perf_bounds} show a $O(1/V, V)$ utility and backlog tradeoff that is typical of Lyapunov based control algorithms for similar utility maximization problems. Specifically, the time-average utility of \\mbox{BOLA} is within an $O(1/V)$ additive term of the optimal utility and this gap may be made smaller by  choosing a larger value of $V$. However, the largest feasible value of $V$ is constrained by the buffer size and there is a linear relation between them.\n\n\\subsection{Understanding BOLA With an Example}\n\\label{subsec:example}\n\nWe now present a sample run to illustrate how BOLA works. We slice a 99-second video using 3-second chunks and encode it at five different bitrates. While BOLA only requires the utilities to be a non-decreasing function of the chunk bitrate, it is natural to consider concave utility functions with diminishing returns, e.g., a 1 Mbps increase in chunk bitrate likely provides a larger utility gain for the user when that increase is from 0.5~Mbps to 1.5~Mbps than when it is from 5~Mbps to 6 Mbps. A natural choice for our example is the logarithmic utility function: let $\\upsilon_m = \\ln(S_m / S_M)$. Pick $\\gamma=5.0 / p$ and $V=0.93$. The bitrates and utilities are below.\n\n\\begin{center}\n  \\scriptsize\n  \\begin{tabular}{|c||c|c|c|c|c|}\n    \\hline\n    bitrate (Mbps) & 6.000 & 2.962 & 1.427 & 0.688 & 0.331 \\\\\n    \\hline\n    $S$ (Mb)       & 18.00 & 8.886 & 4.281 & 2.064 & 0.993 \\\\\n    \\hline\n    $\\upsilon$     & 2.897 & 2.192 & 1.461 & 0.732 & 0.000 \\\\\n    \\hline\n  \\end{tabular}\n\n\\end{center}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_threshold}\n  \\caption{The value of $(V \\upsilon_m + V \\gamma p - Q) / S_m$ for different bitrates depends on buffer level. ($\\gamma p = 5$ and $V = 0.93$.) Note that the buffer level is $Qp$ seconds.}\n  \\label{fig:DemoThreshold}\n\\end{figure}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_decision}\n  \\caption{\\mbox{BOLA}'s bitrate choice as function of buffer level. ($\\gamma p = 5$,$V = 0.93$.) Note that the buffer level is $Qp$ seconds.}\n  \\label{fig:DemoDecision}\n\\end{figure}\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_demo_bitrate} \\\\\n  \\includegraphics{fig_demo_buffer}\n  \\caption{Sample video download and playback using \\mbox{BOLA}. (a) The video is encoded at 5 different bitrates. The network bandwidth varies from high to low and back to high. The downloaded chunk bitrate adapts to the network bandwidth. (b) The buffer level variation triggers bitrate changes when it crosses the thresholds.}\n  \\label{fig:Demo}\n\\end{figure}\n\nFor any slot we choose the chunk bitrate to maximize $(V \\upsilon_m + V \\gamma p - Q) / S_m$ for $1 \\leq m \\leq M$. Fig.~\\ref{fig:DemoThreshold} shows the relationship between the expression and the buffer level $Q$ for different $m$. The line intersections mark the buffer levels that correspond to decision thresholds. Fig.~\\ref{fig:DemoDecision} summarizes \\mbox{BOLA}'s bitrate choices as a function of the buffer level. \n\nFig.~\\ref{fig:Demo} shows how \\mbox{BOLA} works. We use a synthetic network bandwidth profile as shown in Fig.~\\ref{fig:Demo}(a). We can see the feedback loop involving the bitrate in (a) and the buffer level in (b). \\mbox{BOLA} chooses the bitrate based directly on the buffer level using Fig.~\\ref{fig:DemoDecision}. The bitrate affects the download time, thus it indirectly affects the buffer level at the beginning of the following slot. Finally, when all the chunks are downloaded, the video player plays out the chunks remaining in the buffer.\n\n\\subsection{\\texorpdfstring{Choosing Utility and Parameters $\\gamma$ and $V$}{Choosing Utility and Parameters g and V}}\n\\label{subsec:param}\n\nWhile we chose a logarithmic utility function for the example, a video provider can use any utility function satisfying~\\eqref{eq:upsilon}. The utility function might also take into account system characteristics such as the type of device a viewer is using.\n\n$\\gamma$ corresponds to how strongly we want to avoid rebuffering. Increasing $\\gamma$ translates the graphs in Figs.~\\ref{fig:DemoThreshold} and~\\ref{fig:DemoDecision} to the right, effectively shifting the thresholds higher without changing their relative distance. \\mbox{BOLA} will thus download more low-bitrate chunks to maintain a larger (and safer) buffer level.\n\nIncreasing $V$ expands the graphs in Figs.~\\ref{fig:DemoThreshold} and~\\ref{fig:DemoDecision} horizontally about the origin. If we have a maximum buffer level $Q_{\\max}$ we want to avoid downloading unless there is enough space for one full chunk on the buffer, that is unless $Q \\leq Q_{\\max} - 1$. For a given $Q_{\\max}$ we can set $V = (Q_{\\max} - 1) / (\\upsilon_1 + \\gamma p)$.\n\nAfter choosing a utility function, a video provider might want to specify a safe buffer level such that \\mbox{BOLA} will always choose the lowest bitrate when the buffer falls below the level. $\\gamma$ and $V$ can be calculated to satisfy the safe buffer level constraint and a maximum buffer level constraint.\n\n\\section{Implementation and Empirical Evaluation}\n\n\\label{sec:empirical}\n\nWe first implemented a basic version of \\mbox{BOLA}, named \\mbox{BOLA-BASIC}, directly from \\eqref{eq:lyp_algo}. Recall that when the buffer level is full \\mbox{BOLA} does not download a chunk but waits for $\\Delta$~seconds. Rather than picking an arbitrary value for $\\Delta$, we use a dynamic wait until $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p)$. This has the same effect as picking a fixed but very small $\\Delta$, so the theoretical analysis still holds. We also implemented other versions of \\mbox{BOLA}, namely \\mbox{BOLA-FINITE}, \\mbox{BOLA-O}, and \\mbox{BOLA-U}, that we describe later in this section.\n\n\\subsection{Test Methodology}\n\nWe simulated all versions of \\mbox{BOLA} using the Big Buck Bunny movie \\cite{bigbuckbunny}. The 10-minute movie was encoded at 10 different bitrates and sliced in 3-second chunks. Although each quality index has a specified average bitrate, chunks may have variable bitrate (VBR) because of the varying nature of the movie. We simulate playback times longer than 10 minutes by repeating the movie. Again we choose a logarithmic utility function: $\\upsilon_m = \\ln(S_m / S_M)$. Table~\\ref{tab:bitrates} shows the mean and standard deviation of the bitrate and chunk size for each quality index and the respective utility values.\n\n\\begin{table}\n  \\caption{Bitrates used for Big Buck Bunny Test Video}\n  \\label{tab:bitrates}\n  \\centering\n  \\scriptsize\n  \\begin{tabular}{r|cc|cc|c}\n    \\hline\n    \\multicolumn{1}{c|}{Bitrate} &\n    \\multicolumn{2}{c|}{Bitrate (Mbps)} &\n    \\multicolumn{2}{c|}{Chunk Size $S$ (Mb)} &\n    Utility \\\\\n    \\multicolumn{1}{c|}{Index} &\n    Mean & Standard & Mean   & Standard & $\\upsilon$ \\\\\n    \\multicolumn{1}{c|}{$m$} &\n    & Deviation & & Deviation & ${}=\\ln(S/S_M)$ \\\\\n    \\hline\n    1        & 6.000   & 1.078    & 18.00 & 3.232    &  3.261   \\\\\n    2        & 5.027   & 0.891    & 15.08 & 2.673    &  3.084   \\\\\n    3        & 2.962   & 0.564    & 8.886 & 1.691    &  2.556   \\\\\n    4        & 2.056   & 0.394    & 6.168 & 1.182    &  2.190   \\\\\n    5        & 1.427   & 0.275    & 4.281 & 0.825    &  1.825   \\\\\n    6        & 0.991   & 0.182    & 2.973 & 0.545    &  1.461   \\\\\n    7        & 0.688   & 0.120    & 2.064 & 0.360    &  1.096   \\\\\n    8        & 0.477   & 0.096    & 1.431 & 0.287    &  0.729   \\\\\n    9        & 0.331   & 0.054    & 0.993 & 0.162    &  0.364   \\\\\n    $M={}$10 & 0.230   & 0.038    & 0.690 & 0.113    &  0.000   \\\\\n    \\hline\n  \\end{tabular}\n\\end{table}\n\n\\begin{table}\n  \\caption{Network Profiles for the Dash Benchmarks}\n  \\label{tab:profiles}\n  \\centering\n  \\scriptsize\n  \\begin{tabular}{r@{~(}r@{)}r|r@{~(}r@{)}r|r@{~(}r@{)}r||r@{~(}r@{)}r|r@{~(}r@{)}r|r@{~(}r@{)}r}\n    \\hline\n    \\multicolumn{3}{c|}{1} & \\multicolumn{3}{c|}{3} & \\multicolumn{3}{c||}{5} & \\multicolumn{3}{c|}{7} & \\multicolumn{3}{c|}{9} & \\multicolumn{3}{c}{11} \\\\\n    \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c||}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c|}{Mbps\\,(ms)\\!} & \\multicolumn{3}{c}{Mbps\\,(ms)\\!} \\\\\n    \\hline\n    5.0 &  38 && 5.0 &  13 && 5.0 &  11 &&  \\multicolumn{2}{}{} && \\multicolumn{2}{}{} && \\multicolumn{2}{}{} \\\\\n    4.0 &  50 && 4.0 &  18 && 4.0 &  13 &&  9.0 &  25 && 9.0 &  10 && 9.0 &   6 \\\\\n    3.0 &  75 && 3.0 &  28 && 3.0 &  15 &&  4.0 &  50 && 4.0 &  50 && 4.0 &  13 \\\\\n    2.0 &  88 && 2.0 &  58 && 2.0 &  20 &&  2.0 &  75 && 2.0 & 150 && 2.0 &  20 \\\\\n    1.5 & 100 && 1.5 & 200 && 1.5 &  25 &&  1.0 & 100 && 1.0 & 200 && 1.0 &  25 \\\\\n    2.0 &  88 && 2.0 &  58 && 2.0 &  20 &&  2.0 &  75 && 2.0 & 150 && 2.0 &  20 \\\\\n    3.0 &  75 && 3.0 &  28 && 3.0 &  15 &&  4.0 &  50 && 4.0 &  50 && 4.0 &  13 \\\\\n    4.0 &  50 && 4.0 &  18 && 4.0 &  13 &&  \\multicolumn{2}{}{} && \\multicolumn{2}{}{} && \\multicolumn{2}{}{} \\\\\n    \\hline\n  \\end{tabular}\n\\end{table}\n\nThe DASH Industry Forum provides benchmarks for various aspects of the DASH standard \\cite{dashtest}. The benchmarks include twelve different network profiles. Profiles 1--6 have network bandwidths ranging from 1.5 to 5~Mbps while profiles 7--12 have bandwidths ranging from 1 to 9~Mbps. Different latencies are provided for each bandwidth, where the latency is half the round-trip time (RTT). Table~\\ref{tab:profiles} shows the odd-numbered bandwidth characteristics. Profile 1 spends 30s at each of 5, 4, 3, 2, 1.5, 2, 3 and 4~Mbps respectively, then starts back at the top. Even-numbered profiles are similar to the preceding odd-numbered profiles but start at the low bandwidth stage. For example, profile~2 starts at 1.5~Mbps.\n\nIn addition, we also tested our algorithms using a set of 86 3G mobile bandwidth traces that are publicly available \\cite{riiser2013}. One trace was excluded because it had an average bandwidth of 80~kbps; our lowest video bitrate is 230~kbps. Since the traces do not include latency measurements, we used 50~ms latency giving a RTT of 100~ms throughout. This is the median RTT measured empirically in \\cite{romirer2009network}.\n\n\\subsection{Computing an Upper Bound on the Maximum Utility}\n\n\\label{subsec:bound}\n\nIn order to evaluate how well \\mbox{BOLA} performs on the traces, it is important to derive an upper bound on the maximum utility that is obtainable by {\\em any} algorithm on a given trace. We derive an {\\em offline} optimal algorithm that provides the maximum achievable utility using dynamic programming. We define a table $r(n,t,b)$ that contains the maximum utility possible when we download the $n^{\\text{th}}$ chunk and finish at time $t$ with buffer level $b$. We initialize the table with $r(0,0,0) = 0$. Let $x(n,t,m)$ be the time to download the $n^{\\text{th}}$ chunk at bitrate index $m$ starting at time $t$. Note that the dependency of $x$ on $n$ is due to VBR. We quantize the time with granularity $\\delta$. While some accuracy is lost, we ensure the final result will still be an upper bound by rounding the download time down.\n\n", "index": 19, "text": "\\begin{equation*}\n  x_{\\delta}(n, t, m) = \\lfloor x(n, t, m) / \\delta \\rfloor \\cdot \\delta\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"x_{\\delta}(n,t,m)=\\lfloor x(n,t,m)/\\delta\\rfloor\\cdot\\delta\" display=\"block\"><mrow><mrow><msub><mi>x</mi><mi>\u03b4</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">\u230a</mo><mrow><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>/</mo><mi>\u03b4</mi></mrow><mo stretchy=\"false\">\u230b</mo></mrow><mo>\u22c5</mo><mi>\u03b4</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nLet $y(n,t,b,m)$ be the rebuffering time.\n\n", "itemtype": "equation", "pos": 41138, "prevtext": "\nWe cap the buffer level at $b_{\\max}$.\n\n", "index": 21, "text": "\\begin{equation*}\n  x'_{\\delta}(n, t, b, m) = \\max [ x_{\\delta}(n, t, m), b + p - b_{\\max} ]\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"x^{\\prime}_{\\delta}(n,t,b,m)=\\max[x_{\\delta}(n,t,m),b+p-b_{\\max}]\" display=\"block\"><mrow><mrow><msubsup><mi>x</mi><mi>\u03b4</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msub><mi>x</mi><mi>\u03b4</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mrow><mi>b</mi><mo>+</mo><mi>p</mi></mrow><mo>-</mo><msub><mi>b</mi><mi>max</mi></msub></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nWe generate entries for $r(n,\\cdot,\\cdot)$ from $r(n-1,\\cdot,\\cdot)$ using\n\n", "itemtype": "equation", "pos": 41289, "prevtext": "\nLet $y(n,t,b,m)$ be the rebuffering time.\n\n", "index": 23, "text": "\\begin{equation*}\n  y(n, t, b, m) = \\max [ x'_{\\delta}(n, t, b, m) - b, 0 ]\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"y(n,t,b,m)=\\max[x^{\\prime}_{\\delta}(n,t,b,m)-b,0]\" display=\"block\"><mrow><mrow><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><msubsup><mi>x</mi><mi>\u03b4</mi><mo>\u2032</mo></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>b</mi></mrow><mo>,</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nsuch that $t = t' + x'_{\\delta}(n,t',b',m)$ and \\\\\n$b = b' - x'_{\\delta}(n,t',b',m) + y(n,t',b',m)$.\n\n\\begin{figure}\n\\hrule\n\\begin{algorithmic}[1]\n  \\footnotesize\n  \\State $r(0, t, b) \\gets \\{0$ for $t = b = 0$, $-\\infty$ otherwise$\\}$\n  \\For {$n$ in $[1, N]$}\n    \\State initialize $r(n, t, b) \\gets -\\infty$ for all $t, b$\n    \\For {all $(t', b')$ such that $r(n-1, t', b') > -\\infty$}\n      \\For {$m$ in $[1, M]$}\n        \\State $x \\gets \\text{ download time}(n, t', m)$\n        \\State $x_{\\delta} \\gets \\lfloor x / \\delta \\rfloor \\cdot \\delta$\n        \\State $x'_{\\delta} \\gets \\max[x_{\\delta}, b' + p - b_{\\max}]$\n        \\State $y \\gets \\max[x'_{\\delta} - b', 0]$\n        \\State $t \\gets t' + x'_{\\delta}$\n        \\State $b \\gets b' - x'_{\\delta} + y$\n        \\State $r' \\gets r(n-1, t', b') + \\upsilon_m - \\gamma y$\n        \\State $r(n, t, b) \\gets \\max[r(n, t, b), r']$\n      \\EndFor\n    \\EndFor\n  \\EndFor\n  \\State $\\displaystyle r^* \\gets \\max_{(t,b)} \\frac{r(N, t, b)}{(t + b)}$\n\\end{algorithmic}\n\\hrule\n  \\caption{Calculating the Offline Optimal Utility Upper Bound}\n  \\label{alg:offline}\n\\end{figure}\n\nThe dynamic programming algorithm is shown in Fig.~\\ref{alg:offline}.\n\n\\subsection{Evaluating BOLA-BASIC}\n\\label{subsec:bolaBasic}\n\nFig.~\\ref{fig:BolaBasic} shows the time-average utility of \\mbox{BOLA-BASIC} when the video length is 10, 30 and 120 minutes. We set $\\gamma p = 5$ and varied $V$ for different buffer sizes. We compared the utility of \\mbox{BOLA-BASIC} with the offline optimal bound described in Section~\\ref{subsec:bound}. The offline optimal gave nearly the same utility for the different video lengths. However, \\mbox{BOLA-BASIC} only obtains about 80\\% of the offline optimal bound. Also, the utility of \\mbox{BOLA-BASIC} decreases slightly when the buffer size is increased because it must download more lower-bitrate chunks during startup before it can reach the buffer levels required to switch to higher-bitrate chunks. Our results suggests that there is room to improve \\mbox{BOLA-BASIC} that motivates our next version.\n\n\\begin{figure}\n  \\centering\n    \\includegraphics{fig_bola_basic}\n \\caption{Time-average utility for $\\gamma p =5$ using profile 1 for \\mbox{BOLA-BASIC}.}\n  \\label{fig:BolaBasic}\n\\end{figure}\n\n\\subsection{Adapting BOLA to Finite-Sized Videos}\n\\label{subsec:bolaFinite}\n\n\\mbox{BOLA-BASIC} was derived under the assumption that the videos are infinite. Thus, some adaptations are needed for \\mbox{BOLA} to work effectively with smaller videos. Motivated by our initial experiments, we implemeted the following two adaptations to \\mbox{BOLA-BASIC} to derive a version we call \\mbox{BOLA-FINITE}.\n\n\\begin{figure}\n  \\hrule\n  \\begin{algorithmic}[1]\n    \\footnotesize\n    \\For {$n$ in $[1, N]$}\n    \\State $t \\gets \\min[\\text{playtime from begin}, \\text{playtime to end}]$\n    \\State $t' \\gets \\max[3p, t/2]$\n    \\State $Q_{\\max}' \\gets \\min[Q_{\\max}, t' / p]$\n    \\State $V^{\\mathrm{D}} \\gets Q_{\\text{max}}' / (\\upsilon_1 + \\gamma p)$\n    \\State $\\displaystyle m^*[n] \\gets {\\operatorname{arg\\,max}}_{m} (V^{\\mathrm{D}} \\upsilon_{m} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m}$\n    \\If {$m^*[n] < m^*[n-1]$}\n      \\State $r \\gets \\text{bandwidth measured when downloading chunk $(n-1)$}$\n      \\State $m' \\gets \\text{$\\min m$ s.t. $m \\geq m^*[n]$ and bitrate$[m] \\leq \\min[r,S_M/p]$}$\n      \\If {$m' > m^*[n-1]$}\n        \\State $m' \\gets m^*[n-1]$\n      \\ElsIf {some utility sacrificed for fewer oscillations}\n        \\State \\hspace{-1em} $\\begin{array}{rl}\n          \\text{pause until}\\hspace{-1em} & (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m'} \\geq \\\\\n          & (V^{\\mathrm{D}}\\! \\upsilon_{m'\\!-1} + V^{\\mathrm{D}}\\! \\gamma p - Q) / S_{m'\\!-1}\n        \\end{array}$ \\Comment{\\mbox{BOLA-O}}\n      \\Else\n        \\State $m' \\gets \\max(m^*[n], m' - 1)$ \\Comment{\\mbox{BOLA-U}}\n      \\EndIf\n      \\State $m^*[n] \\gets m'$  \n    \\EndIf\n    \\If {$(V^{\\mathrm{D}} \\upsilon_{1} + V^{\\mathrm{D}} \\gamma p - Q) / S_{1} < 0$}\n      \\State pause for $p \\cdot (Q - V^{\\mathrm{D}} \\upsilon_1 - V^{\\mathrm{D}} \\gamma p)$\n    \\EndIf\n    \\State download chunk $n$ at bitrate index $m^*[n]$, possibly abandoning\n  \\EndFor\n\\end{algorithmic}\n\\hrule\n  \\caption{The \\mbox{BOLA} Algorithm.}\n  \\label{alg:mainalgo}\n\\end{figure}\n\n1) Dynamic $V$ value for startup and wind down:\nA large buffer allows \\mbox{BOLA-BASIC} to perform better but it has two drawbacks. First, it takes longer to prime a large buffer during startup. Lower bitrate chunks are preferred until the buffer level reaches steady state. Second, at some late stage all downloads are complete and any remaining buffered video is played out. Any available bandwidth during this period is not utilized. Shortening this period would result in less unutilized available bandwidth. We mitigate these effects by introducing a dynamic $V^{\\mathrm{D}}$ which corresponds to a dynamic buffer size $Q_{\\text{max}}'$, shown in lines 2--5 in Fig.~\\ref{alg:mainalgo}. \\mbox{BOLA-FINITE} does not try to fill the whole buffer too soon and does not try to maintain a full buffer too long. We still need a minimum buffer size $3p$ for the algorithm to work effectively.\n\n\\begin{figure}\n\\hrule\n\\begin{algorithmic}[1]\n  \\footnotesize\n  \\Function{ShallAbandon}{$m, S^{\\mathrm{R}}$}\n    \\State $r_m \\gets (V^{\\mathrm{D}} \\upsilon_m + V^{\\mathrm{D}} \\gamma p - Q) / S^{\\mathrm{R}}$\n    \\State $r_{m'} \\gets (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m'}$\n    \\State \\textbf{return} \\textit{true} if $r_{m'} > r_m$ for some $m'$ subject to $m < m' \\leq M$\n  \\EndFunction\n\\end{algorithmic}\n\\hrule\n  \\caption{\\mbox{BOLA-FINITE}'s Download Abandonment Heuristic: $m$ is the current chunk bitrate and $S^{\\mathrm{R}}$ is the number of bits remaining to download in the current chunk.}\n  \\label{alg:abandon}\n\\end{figure}\n\n2) Download abandonment:\n\\mbox{BOLA-BASIC} takes control decisions just before the download of each chunk. Consider a scenario where the player is downloading high-bitrate 6~Mbps chunks in good network conditions. The network bandwidth suddenly drops to 1~Mbps as the player has just started a new chunk download. The chunk will take $6p$~seconds to download, depleting the buffer and possibly causing rebuffering. \\mbox{BOLA-FINITE} mitigates this problem by monitoring download progress and possibly abandoning a download. Fig.~\\ref{alg:abandon} shows how \\mbox{BOLA-FINITE} decides whether or not to abandon the download. If a chunk at bitrate index $m$ is being downloaded, the remaining size $S^{\\mathrm{R}}$ is less than $S_m$. The chunk can be abandoned and downloaded at some bitrate index $m'$ subject to $m < m' \\leq M$ when $(V^{\\mathrm{D}} \\upsilon_m + V^{\\mathrm{D}} \\gamma p - Q)/S^{\\mathrm{R}} < (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q)/S_{m'}$. The control idea remains the same, but the current bitrate $m$ has a smaller corresponding size $S^{\\mathrm{R}}$ because part of the chunk has already been downloaded. Fig.~\\ref{fig:Demo} illustrates a scenario where abandonment might help. At 46s a 3~Mbps chunk download starts. Since there is a bandwidth drop at the time, the chunk takes almost 9s to download. The buffer is depleted and \\mbox{BOLA-BASIC} switches to downloading at a bitrate of 0.3~Mbps. \\mbox{BOLA-FINITE} with abandonment logic would have detected the rapidly depleting buffer and stopped the long download, with the system only dropping to the 1.4 and 0.7~Mbps download bitrates in the low-bandwidth period.\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_bola_finite}\n \\caption{Time-average utility for $\\gamma p =5$ using profile 1 for \\mbox{BOLA-FINITE} and \\mbox{BOLA-U}.}\n  \\label{fig:BolaFinite}\n\\end{figure}\n\nFig.~\\ref{fig:BolaFinite} shows the time-average utility of \\mbox{BOLA-FINITE} for 10, 30 and 120 minutes of playback time with $\\gamma p=5$. Comparing with \\mbox{BOLA-BASIC} in Fig.~\\ref{fig:BolaBasic}, we see that the time-average utility is much closer to the offline optimal bound. The benefit of the adjustments is also evident as the buffer grows larger, as there is no significant decrease in utility caused by filling the buffer with low-bitrate chunks in the earlier stages of the video.\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_utility_a}\n  \\caption{The time-average utility of \\mbox{BOLA-O} and \\mbox{BOLA-U} with $\\gamma p = 5$ and a 25-second buffer playing a 30-minute video for the DASH test network profiles 1--12 and mobile traces (3G). \\mbox{BOLA} utility is within 84--95\\% of offline optimal utility.}\n  \\label{fig:UtilityA}\n\\end{figure*}\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_bitrate_change}\n  \\caption{The average bitrate change between adjacent chunks was smaller for BOLA-O than for BOLA-U, but some bitrate change is needed to accurately track the network bandwidth. In our experiments, ELASTIC and PANDA tracked the bandwidth less accurately than BOLA-O.}\n  \\label{fig:BitrateChange}\n\\end{figure*}\n\n\\subsection{Avoiding Bitrate Oscillations}\n\\label{subsec:oscillations}\n\nWhile our performance objective optimizes playback utility and playback smoothness, users are also sensitive to excessive bitrate switching. We discuss three causes of bitrate switches.\n\n1) Bandwidth variation:\nAs the network conditions change, the player varies the bitrate, effectively tracking the network bandwidth. These switches are acceptable; the player has no control over the available bandwidth and needs to adapt to different network conditions.\n\n2) Dense buffer thresholds:\nEither a large number of bitrate levels and/or a smaller buffer size may push the threshold levels closer. If the differences between threshold levels are less than the chunk duration $p$, adding one downloaded chunk to the buffer may push the buffer level over several threshold levels at once. This might cause \\mbox{BOLA-FINITE} to overshoot and choose a bitrate that is too high for the available bandwidth. Consequently, the chunk download would take much more than $p$ seconds, leading to excessive buffer depletion, causing \\mbox{BOLA-FINITE} to switch down its bitrate by more than one level. In such a scenario \\mbox{BOLA-FINITE} can oscillate between bitrates, even when the available bandwidth is stable.\n\n3) Bitrate quantization:\nHaving a stable network bandwidth and widely-spaced thresholds still does not avoid all bitrate switching. Suppose the bandwidth is 2.0~Mbps and it lies between two encoded bitrates of 1.5 and 3.0~Mbps. While the player downloads 1.5~Mbps chunks, the buffer keeps growing. When the buffer crosses the threshold the player switches to 3.0~Mbps, depleting the buffer. After the buffer gets sufficiently depleted, the player switches back to 1.5~Mbps, and the cycle repeats. In this example, a viewer might prefer the video player to stick to the 1.5~Mbps bitrate, sacrificing some utility in order to have fewer oscillations. Or, a viewer might want to maximize utility and play a part of the video in the higher bitrate of 3.0~Mbps at the cost of more oscillations. We describe two variants of \\mbox{BOLA} below to suit either viewer.\n\nThe first variant that we call \\mbox{BOLA-O} mitigates \\textbf{o}scillations by introducing bitrate capping (lines 7--18 in Fig.~\\ref{alg:mainalgo}) when switching to a higher bitrate. \\mbox{BOLA-O} verifies that the higher bitrate is sustainable by comparing it to the bandwidth as measured when downloading the previous chunk (lines 8--9). Since the motive is to limit oscillations rather than to predict future bandwidth, this adaptation does not drop the bitrate to a lower level than in the previous download (lines 10--11). Continuous downloading at a bitrate lower than the bandwidth would cause the buffer to keep growing. \\mbox{BOLA-O} avoids this by allowing the buffer to slip to the appropriate threshold before starting the download (line 13).\n\nThe second variant that we call \\mbox{BOLA-U} does not sacrifice \\textbf{u}tility. Excessive buffer growth is avoided by allowing the bitrate to be one level higher than the sustainable bandwidth (line 15). This allows the player to choose 3~Mbps in the example. While \\mbox{BOLA-U} does not handle the third type of oscillations, it handles the more severe second type.\n\nLooking back at Fig.~\\ref{fig:BolaFinite}, we see that the added stability of \\mbox{BOLA-U} pays off when using a small buffer size and BOLA-U achieves a larger utility than BOLA-FINITE. Fig.~\\ref{fig:UtilityA} shows the time-average utility of \\mbox{BOLA-O} and \\mbox{BOLA-U} with $\\gamma p = 5$ and a 25-second buffer playing a 30-minute video. The utility lost by \\mbox{BOLA-O} to avoid oscillations is clearly evident. In practice the lost utility is limited by the distance between encoded bitrates; if the next lower bitrate is not far from the bandwidth, then little utility will be lost.\n\nWe measure oscillations by comparing consecutive chunks. The change in bitrate between a chunk and the next is the absolute difference between bitrates (in Mbps) of the two chunks. Fig.~\\ref{fig:BitrateChange} shows the bitrate change averaged across all the chunks. While \\mbox{BOLA-U} has a high average bitrate change because of the quantization, \\mbox{BOLA-O} only switches bitrate because of network bandwidth variations.\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_utility_b}\n  \\caption{The time-average utility of \\mbox{BOLA-U}, ELASTIC and PANDA with $\\gamma p = 5$ playing a 30-minute video for the DASH test network profiles 1--12 and mobile traces (3G). Compared with ELASTIC and PANDA, \\mbox{BOLA-U} has  about 1.75 times the utility of the other algorithms in roughly half the cases.}\n  \\label{fig:UtilityB}\n\\end{figure*}\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_average_bitrate} \\\\\n  \\includegraphics{fig_rebuffer}\n  \\caption{Comparing \\mbox{BOLA} with ELASTIC and PANDA using raw metrics: average bitrate and rebuffer-to-play ratio. \\mbox{BOLA} and PANDA do not rebuffer for profiles 1--12. ELASTIC has almost no rebuffering for profiles 1--6, but it has a rebuffer-to-play ratio greater than 20\\% for profiles 7--12.}\n  \\label{fig:AverageBitrateRebuffer}\n\\end{figure*}\n\n\\subsection{Comparison With State-of-the-Art Algorithms}\n\nWe now compare \\mbox{BOLA} with two state-of-the art algorithms, ELASTIC \\cite{decicco2013elastic} and PANDA \\cite{li2014panda}. We use the default design parameters in \\cite{decicco2013elastic} and \\cite{li2014panda}. We test both \\mbox{BOLA-O} and \\mbox{BOLA-U}. Although \\mbox{BOLA} performs better with larger buffers, we limited the buffer size to 25s for the tests to ensure fairness. ELASTIC targets a buffer level of 15s but the buffer level varies higher. PANDA targets a minimum buffer level of 26s.\n\nFig.~\\ref{fig:UtilityB} compares the algorithms using each of the 12 network profiles and the mobile traces. \\mbox{BOLA-U} consistently performs significantly better than PANDA. While \\mbox{BOLA-U} and ELASTIC perform similarly for profiles 1--6, \\mbox{BOLA-U} performs significantly better for the other profiles that have larger bandwidth variations. Recall that \\mbox{BOLA-O} always performs within a small margin of \\mbox{BOLA-U} in Fig.~\\ref{fig:UtilityA}.\n\nSince ELASTIC and PANDA were not designed for the utility score we repeat the comparison using the average bitrate and rebuffering metrics in Fig.~\\ref{fig:AverageBitrateRebuffer}. For profiles 1--6, \\mbox{BOLA-U} has approximately the same bitrate as ELASTIC. ELASTIC has a higher bitrate for profiles 7--12, but that comes at a significant cost in terms of rebuffering. For these profiles, the ratio of the rebuffering time to the play time is more than 20\\% for ELASTIC, while \\mbox{BOLA-U} has no rebuffering. For the 3G traces, ELASTIC has marginally higher bitrate than \\mbox{BOLA-U} but has a 12.0\\% rebuffer-to-play ratio compared with \\mbox{BOLA-U}'s 3.5\\%. ELASTIC rebuffers significantly more because it does not react in time when the bandwidth drops. \n\nComparing \\mbox{BOLA-U} with PANDA, both do not rebuffer for profiles 1--12.  For the 3G traces, \\mbox{BOLA-U}  and PANDA have a rebuffer-to-play ratio of 3.5\\% and 2.6\\% respectively. However, PANDA has significantly lower bitrate than \\mbox{BOLA-U}. The reason is that PANDA is more conservative and in some cases does not change to a higher bitrate even if it is sustainable.\n\nIn Fig.~\\ref{fig:BitrateChange} we show our results for our secondary metric of bitrate oscillations. \\mbox{BOLA-U} does not perform well in this metric, since it attempts to maximize utility at the cost of increased oscillations. Comparing \\mbox{BOLA-O} with ELASTIC and PANDA,  ELASTIC has a lower average change than \\mbox{BOLA-O} only in the cases where it has a slow reaction and excessive rebuffering. PANDA has a lower average change because it is more conservative and in some cases does not change to a higher bitrate even if that bitrate is sustainable.\n\n{\\em Thus, from our empirical analysis, we can conclude that \\mbox{BOLA} achieves higher utility, and performs more consistently across different scenarios in comparison with ELASTIC and PANDA.} One reason for the consistency of \\mbox{BOLA} is that it does not have a large number of parameters. \\mbox{BOLA} has two design parameters $\\gamma$ and $V$, which have an intuitive significance as discussed in Section~\\ref{subsec:param}, and an option of whether or not to trade off some utility to reduce oscillations. Other algorithms have a number of different parameters and tuning the parameters for a particular scenario might make the system less suited for other scenarios.\n\n\n\\section{Related Work}\n\\label{sec:related}\n\nThere has been a lot of recent work on bitrate adaptation algorithms, much of which is based on estimating the bandwidth of the network connection.\nNotable among this is ELASTIC \\cite{decicco2013elastic} that uses control theory to adjust the bitrate so as to keep the buffer occupancy at a constant level.\nAnother notable algorithm is PANDA \\cite{li2014panda} which also estimates the network bandwidth. PANDA drops the download bitrate as soon as low bandwidth is detected but only increases the bitrate slowly to probe the real capacity when a higher bandwidth is detected.\nIn \\cite{yin2015ccontrol}, an algorithm using model predictive control (MPC) is proposed to optimize a comprehensive set of metrics. In this approach, the bitrate for the current chunk is chosen based on a network  bandwidth prediction for the next few chunks. But, its performance depends on the accuracy of such a prediction. The approach also requires significant offline optimization to be performed outside of the client for an exhaustive set of scenarios.\nIn \\cite{Huang+14}, a buffer-based algorithm is proposed, but assumes that the buffer size is large (in the order of minutes), thereby making it not suitable for short videos. Further, it does not provide any theoretical guarantees for its buffer-based approach. Unlike prior work, we derive a buffer-based algorithm with theoretical guarantees that is simple to implement within the client and we empirically show its efficacy on extensive network traces.\n\n\\section{Conclusion}\n\\label{sec:conclusion}\n\nWe formulated video bitrate adaptation for ABR streaming as a utility maximization problem and derived \\mbox{BOLA}, an online control algorithm that is provably near-optimal. Further, we empirically demonstrated the efficacy of \\mbox{BOLA} using extensive traces. In particular, we showed that our online algorithm achieves utility close to the optimal offline algorithm. We also showed that our algorithm significantly outperformed two well-known algorithms in nearly half the test scenarios. We are also implementing BOLA as the default ABR algorithm in dash.js, the open-source DASH reference player \\cite{dashjs}, and testing BOLA ``in the wild'' with actual users.\n\n\\appendix[\\texorpdfstring{Proof of Theorem~\\ref{thm:BOLA}}{Proof or Theorem 2}]\n\\label{sec:NP-proof}\n\nWe first show part $1$ using induction. Note that the bound $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ holds for $k=1$ since $Q(t_1) = Q(0) = 0$. Now suppose it holds for some $k$. We will show that it will also hold for $k+1$. We have two cases.\n\n\\emph{Case 1:} $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p)$ \\\\\nFrom the queueing equation (\\ref{eq:Q}), it follows that the maximum that $Q(t_k)$ can increase in slot $k$ is by $1$. This implies that $Q(t_{k+1}) \\leq V(\\upsilon_1 + \\gamma p) + 1$.\n\n\\emph{Case 2:} $V(\\upsilon_1 + \\gamma p) < Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ \\\\\nWe have $Q(t_k) > V ( \\upsilon_m + \\gamma p)$ for all $m \\in \\{1, 2, \\ldots, M\\}$ (using (\\ref{eq:upsilon})). It follows from the structure of optimal solution to (\\ref{eq:lyp_algo}) that \\mbox{BOLA} will choose the no-download option in this case. As a result, $Q(t_{k})$ cannot increase and we have that $Q(t_{k+1}) \\leq V(\\upsilon_1 + \\gamma p) + 1$.\n\n$Q(t_k)$ denotes the total number of chunks in the buffer. This can be at most $Q_{\\max}$ using the relation $V \\leq \\frac{Q_{\\max} - 1}{\\upsilon_1 + \\gamma p}$.\n\nIn part 2, we show the bound in (\\ref{eq:bound2}) using the technique of Lyapounov optimization over variable size frames \\cite{neely2010}. We first define a Lyapunov function $L(Q(t_k))$ as\n\n", "itemtype": "equation", "pos": 41456, "prevtext": "\nWe generate entries for $r(n,\\cdot,\\cdot)$ from $r(n-1,\\cdot,\\cdot)$ using\n\n", "index": 25, "text": "\\begin{equation*}\n  r(n, t, b) = \\max_{m, t', b'} \\Big( r(n-1, t', b') + \\upsilon_m - \\gamma y(n, t', b', m) \\Big)\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"r(n,t,b)=\\max_{m,t^{\\prime},b^{\\prime}}\\Big{(}r(n-1,t^{\\prime},b^{\\prime})+%&#10;\\upsilon_{m}-\\gamma y(n,t^{\\prime},b^{\\prime},m)\\Big{)}\" display=\"block\"><mrow><mrow><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><munder><mi>max</mi><mrow><mi>m</mi><mo>,</mo><msup><mi>t</mi><mo>\u2032</mo></msup><mo>,</mo><msup><mi>b</mi><mo>\u2032</mo></msup></mrow></munder><mo>\u2061</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mrow><mrow><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo>,</mo><msup><mi>t</mi><mo>\u2032</mo></msup><mo>,</mo><msup><mi>b</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><msub><mi>\u03c5</mi><mi>m</mi></msub></mrow><mo>-</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><msup><mi>t</mi><mo>\u2032</mo></msup><mo>,</mo><msup><mi>b</mi><mo>\u2032</mo></msup><mo>,</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nand define the per-slot conditional Lyapunov drift $D(t_k)$ as\n\n", "itemtype": "equation", "pos": 62790, "prevtext": "\nsuch that $t = t' + x'_{\\delta}(n,t',b',m)$ and \\\\\n$b = b' - x'_{\\delta}(n,t',b',m) + y(n,t',b',m)$.\n\n\\begin{figure}\n\\hrule\n\\begin{algorithmic}[1]\n  \\footnotesize\n  \\State $r(0, t, b) \\gets \\{0$ for $t = b = 0$, $-\\infty$ otherwise$\\}$\n  \\For {$n$ in $[1, N]$}\n    \\State initialize $r(n, t, b) \\gets -\\infty$ for all $t, b$\n    \\For {all $(t', b')$ such that $r(n-1, t', b') > -\\infty$}\n      \\For {$m$ in $[1, M]$}\n        \\State $x \\gets \\text{ download time}(n, t', m)$\n        \\State $x_{\\delta} \\gets \\lfloor x / \\delta \\rfloor \\cdot \\delta$\n        \\State $x'_{\\delta} \\gets \\max[x_{\\delta}, b' + p - b_{\\max}]$\n        \\State $y \\gets \\max[x'_{\\delta} - b', 0]$\n        \\State $t \\gets t' + x'_{\\delta}$\n        \\State $b \\gets b' - x'_{\\delta} + y$\n        \\State $r' \\gets r(n-1, t', b') + \\upsilon_m - \\gamma y$\n        \\State $r(n, t, b) \\gets \\max[r(n, t, b), r']$\n      \\EndFor\n    \\EndFor\n  \\EndFor\n  \\State $\\displaystyle r^* \\gets \\max_{(t,b)} \\frac{r(N, t, b)}{(t + b)}$\n\\end{algorithmic}\n\\hrule\n  \\caption{Calculating the Offline Optimal Utility Upper Bound}\n  \\label{alg:offline}\n\\end{figure}\n\nThe dynamic programming algorithm is shown in Fig.~\\ref{alg:offline}.\n\n\\subsection{Evaluating BOLA-BASIC}\n\\label{subsec:bolaBasic}\n\nFig.~\\ref{fig:BolaBasic} shows the time-average utility of \\mbox{BOLA-BASIC} when the video length is 10, 30 and 120 minutes. We set $\\gamma p = 5$ and varied $V$ for different buffer sizes. We compared the utility of \\mbox{BOLA-BASIC} with the offline optimal bound described in Section~\\ref{subsec:bound}. The offline optimal gave nearly the same utility for the different video lengths. However, \\mbox{BOLA-BASIC} only obtains about 80\\% of the offline optimal bound. Also, the utility of \\mbox{BOLA-BASIC} decreases slightly when the buffer size is increased because it must download more lower-bitrate chunks during startup before it can reach the buffer levels required to switch to higher-bitrate chunks. Our results suggests that there is room to improve \\mbox{BOLA-BASIC} that motivates our next version.\n\n\\begin{figure}\n  \\centering\n    \\includegraphics{fig_bola_basic}\n \\caption{Time-average utility for $\\gamma p =5$ using profile 1 for \\mbox{BOLA-BASIC}.}\n  \\label{fig:BolaBasic}\n\\end{figure}\n\n\\subsection{Adapting BOLA to Finite-Sized Videos}\n\\label{subsec:bolaFinite}\n\n\\mbox{BOLA-BASIC} was derived under the assumption that the videos are infinite. Thus, some adaptations are needed for \\mbox{BOLA} to work effectively with smaller videos. Motivated by our initial experiments, we implemeted the following two adaptations to \\mbox{BOLA-BASIC} to derive a version we call \\mbox{BOLA-FINITE}.\n\n\\begin{figure}\n  \\hrule\n  \\begin{algorithmic}[1]\n    \\footnotesize\n    \\For {$n$ in $[1, N]$}\n    \\State $t \\gets \\min[\\text{playtime from begin}, \\text{playtime to end}]$\n    \\State $t' \\gets \\max[3p, t/2]$\n    \\State $Q_{\\max}' \\gets \\min[Q_{\\max}, t' / p]$\n    \\State $V^{\\mathrm{D}} \\gets Q_{\\text{max}}' / (\\upsilon_1 + \\gamma p)$\n    \\State $\\displaystyle m^*[n] \\gets {\\operatorname{arg\\,max}}_{m} (V^{\\mathrm{D}} \\upsilon_{m} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m}$\n    \\If {$m^*[n] < m^*[n-1]$}\n      \\State $r \\gets \\text{bandwidth measured when downloading chunk $(n-1)$}$\n      \\State $m' \\gets \\text{$\\min m$ s.t. $m \\geq m^*[n]$ and bitrate$[m] \\leq \\min[r,S_M/p]$}$\n      \\If {$m' > m^*[n-1]$}\n        \\State $m' \\gets m^*[n-1]$\n      \\ElsIf {some utility sacrificed for fewer oscillations}\n        \\State \\hspace{-1em} $\\begin{array}{rl}\n          \\text{pause until}\\hspace{-1em} & (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m'} \\geq \\\\\n          & (V^{\\mathrm{D}}\\! \\upsilon_{m'\\!-1} + V^{\\mathrm{D}}\\! \\gamma p - Q) / S_{m'\\!-1}\n        \\end{array}$ \\Comment{\\mbox{BOLA-O}}\n      \\Else\n        \\State $m' \\gets \\max(m^*[n], m' - 1)$ \\Comment{\\mbox{BOLA-U}}\n      \\EndIf\n      \\State $m^*[n] \\gets m'$  \n    \\EndIf\n    \\If {$(V^{\\mathrm{D}} \\upsilon_{1} + V^{\\mathrm{D}} \\gamma p - Q) / S_{1} < 0$}\n      \\State pause for $p \\cdot (Q - V^{\\mathrm{D}} \\upsilon_1 - V^{\\mathrm{D}} \\gamma p)$\n    \\EndIf\n    \\State download chunk $n$ at bitrate index $m^*[n]$, possibly abandoning\n  \\EndFor\n\\end{algorithmic}\n\\hrule\n  \\caption{The \\mbox{BOLA} Algorithm.}\n  \\label{alg:mainalgo}\n\\end{figure}\n\n1) Dynamic $V$ value for startup and wind down:\nA large buffer allows \\mbox{BOLA-BASIC} to perform better but it has two drawbacks. First, it takes longer to prime a large buffer during startup. Lower bitrate chunks are preferred until the buffer level reaches steady state. Second, at some late stage all downloads are complete and any remaining buffered video is played out. Any available bandwidth during this period is not utilized. Shortening this period would result in less unutilized available bandwidth. We mitigate these effects by introducing a dynamic $V^{\\mathrm{D}}$ which corresponds to a dynamic buffer size $Q_{\\text{max}}'$, shown in lines 2--5 in Fig.~\\ref{alg:mainalgo}. \\mbox{BOLA-FINITE} does not try to fill the whole buffer too soon and does not try to maintain a full buffer too long. We still need a minimum buffer size $3p$ for the algorithm to work effectively.\n\n\\begin{figure}\n\\hrule\n\\begin{algorithmic}[1]\n  \\footnotesize\n  \\Function{ShallAbandon}{$m, S^{\\mathrm{R}}$}\n    \\State $r_m \\gets (V^{\\mathrm{D}} \\upsilon_m + V^{\\mathrm{D}} \\gamma p - Q) / S^{\\mathrm{R}}$\n    \\State $r_{m'} \\gets (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q) / S_{m'}$\n    \\State \\textbf{return} \\textit{true} if $r_{m'} > r_m$ for some $m'$ subject to $m < m' \\leq M$\n  \\EndFunction\n\\end{algorithmic}\n\\hrule\n  \\caption{\\mbox{BOLA-FINITE}'s Download Abandonment Heuristic: $m$ is the current chunk bitrate and $S^{\\mathrm{R}}$ is the number of bits remaining to download in the current chunk.}\n  \\label{alg:abandon}\n\\end{figure}\n\n2) Download abandonment:\n\\mbox{BOLA-BASIC} takes control decisions just before the download of each chunk. Consider a scenario where the player is downloading high-bitrate 6~Mbps chunks in good network conditions. The network bandwidth suddenly drops to 1~Mbps as the player has just started a new chunk download. The chunk will take $6p$~seconds to download, depleting the buffer and possibly causing rebuffering. \\mbox{BOLA-FINITE} mitigates this problem by monitoring download progress and possibly abandoning a download. Fig.~\\ref{alg:abandon} shows how \\mbox{BOLA-FINITE} decides whether or not to abandon the download. If a chunk at bitrate index $m$ is being downloaded, the remaining size $S^{\\mathrm{R}}$ is less than $S_m$. The chunk can be abandoned and downloaded at some bitrate index $m'$ subject to $m < m' \\leq M$ when $(V^{\\mathrm{D}} \\upsilon_m + V^{\\mathrm{D}} \\gamma p - Q)/S^{\\mathrm{R}} < (V^{\\mathrm{D}} \\upsilon_{m'} + V^{\\mathrm{D}} \\gamma p - Q)/S_{m'}$. The control idea remains the same, but the current bitrate $m$ has a smaller corresponding size $S^{\\mathrm{R}}$ because part of the chunk has already been downloaded. Fig.~\\ref{fig:Demo} illustrates a scenario where abandonment might help. At 46s a 3~Mbps chunk download starts. Since there is a bandwidth drop at the time, the chunk takes almost 9s to download. The buffer is depleted and \\mbox{BOLA-BASIC} switches to downloading at a bitrate of 0.3~Mbps. \\mbox{BOLA-FINITE} with abandonment logic would have detected the rapidly depleting buffer and stopped the long download, with the system only dropping to the 1.4 and 0.7~Mbps download bitrates in the low-bandwidth period.\n\n\\begin{figure}\n  \\centering\n  \\includegraphics{fig_bola_finite}\n \\caption{Time-average utility for $\\gamma p =5$ using profile 1 for \\mbox{BOLA-FINITE} and \\mbox{BOLA-U}.}\n  \\label{fig:BolaFinite}\n\\end{figure}\n\nFig.~\\ref{fig:BolaFinite} shows the time-average utility of \\mbox{BOLA-FINITE} for 10, 30 and 120 minutes of playback time with $\\gamma p=5$. Comparing with \\mbox{BOLA-BASIC} in Fig.~\\ref{fig:BolaBasic}, we see that the time-average utility is much closer to the offline optimal bound. The benefit of the adjustments is also evident as the buffer grows larger, as there is no significant decrease in utility caused by filling the buffer with low-bitrate chunks in the earlier stages of the video.\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_utility_a}\n  \\caption{The time-average utility of \\mbox{BOLA-O} and \\mbox{BOLA-U} with $\\gamma p = 5$ and a 25-second buffer playing a 30-minute video for the DASH test network profiles 1--12 and mobile traces (3G). \\mbox{BOLA} utility is within 84--95\\% of offline optimal utility.}\n  \\label{fig:UtilityA}\n\\end{figure*}\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_bitrate_change}\n  \\caption{The average bitrate change between adjacent chunks was smaller for BOLA-O than for BOLA-U, but some bitrate change is needed to accurately track the network bandwidth. In our experiments, ELASTIC and PANDA tracked the bandwidth less accurately than BOLA-O.}\n  \\label{fig:BitrateChange}\n\\end{figure*}\n\n\\subsection{Avoiding Bitrate Oscillations}\n\\label{subsec:oscillations}\n\nWhile our performance objective optimizes playback utility and playback smoothness, users are also sensitive to excessive bitrate switching. We discuss three causes of bitrate switches.\n\n1) Bandwidth variation:\nAs the network conditions change, the player varies the bitrate, effectively tracking the network bandwidth. These switches are acceptable; the player has no control over the available bandwidth and needs to adapt to different network conditions.\n\n2) Dense buffer thresholds:\nEither a large number of bitrate levels and/or a smaller buffer size may push the threshold levels closer. If the differences between threshold levels are less than the chunk duration $p$, adding one downloaded chunk to the buffer may push the buffer level over several threshold levels at once. This might cause \\mbox{BOLA-FINITE} to overshoot and choose a bitrate that is too high for the available bandwidth. Consequently, the chunk download would take much more than $p$ seconds, leading to excessive buffer depletion, causing \\mbox{BOLA-FINITE} to switch down its bitrate by more than one level. In such a scenario \\mbox{BOLA-FINITE} can oscillate between bitrates, even when the available bandwidth is stable.\n\n3) Bitrate quantization:\nHaving a stable network bandwidth and widely-spaced thresholds still does not avoid all bitrate switching. Suppose the bandwidth is 2.0~Mbps and it lies between two encoded bitrates of 1.5 and 3.0~Mbps. While the player downloads 1.5~Mbps chunks, the buffer keeps growing. When the buffer crosses the threshold the player switches to 3.0~Mbps, depleting the buffer. After the buffer gets sufficiently depleted, the player switches back to 1.5~Mbps, and the cycle repeats. In this example, a viewer might prefer the video player to stick to the 1.5~Mbps bitrate, sacrificing some utility in order to have fewer oscillations. Or, a viewer might want to maximize utility and play a part of the video in the higher bitrate of 3.0~Mbps at the cost of more oscillations. We describe two variants of \\mbox{BOLA} below to suit either viewer.\n\nThe first variant that we call \\mbox{BOLA-O} mitigates \\textbf{o}scillations by introducing bitrate capping (lines 7--18 in Fig.~\\ref{alg:mainalgo}) when switching to a higher bitrate. \\mbox{BOLA-O} verifies that the higher bitrate is sustainable by comparing it to the bandwidth as measured when downloading the previous chunk (lines 8--9). Since the motive is to limit oscillations rather than to predict future bandwidth, this adaptation does not drop the bitrate to a lower level than in the previous download (lines 10--11). Continuous downloading at a bitrate lower than the bandwidth would cause the buffer to keep growing. \\mbox{BOLA-O} avoids this by allowing the buffer to slip to the appropriate threshold before starting the download (line 13).\n\nThe second variant that we call \\mbox{BOLA-U} does not sacrifice \\textbf{u}tility. Excessive buffer growth is avoided by allowing the bitrate to be one level higher than the sustainable bandwidth (line 15). This allows the player to choose 3~Mbps in the example. While \\mbox{BOLA-U} does not handle the third type of oscillations, it handles the more severe second type.\n\nLooking back at Fig.~\\ref{fig:BolaFinite}, we see that the added stability of \\mbox{BOLA-U} pays off when using a small buffer size and BOLA-U achieves a larger utility than BOLA-FINITE. Fig.~\\ref{fig:UtilityA} shows the time-average utility of \\mbox{BOLA-O} and \\mbox{BOLA-U} with $\\gamma p = 5$ and a 25-second buffer playing a 30-minute video. The utility lost by \\mbox{BOLA-O} to avoid oscillations is clearly evident. In practice the lost utility is limited by the distance between encoded bitrates; if the next lower bitrate is not far from the bandwidth, then little utility will be lost.\n\nWe measure oscillations by comparing consecutive chunks. The change in bitrate between a chunk and the next is the absolute difference between bitrates (in Mbps) of the two chunks. Fig.~\\ref{fig:BitrateChange} shows the bitrate change averaged across all the chunks. While \\mbox{BOLA-U} has a high average bitrate change because of the quantization, \\mbox{BOLA-O} only switches bitrate because of network bandwidth variations.\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_utility_b}\n  \\caption{The time-average utility of \\mbox{BOLA-U}, ELASTIC and PANDA with $\\gamma p = 5$ playing a 30-minute video for the DASH test network profiles 1--12 and mobile traces (3G). Compared with ELASTIC and PANDA, \\mbox{BOLA-U} has  about 1.75 times the utility of the other algorithms in roughly half the cases.}\n  \\label{fig:UtilityB}\n\\end{figure*}\n\n\\begin{figure*}\n  \\centering\n  \\includegraphics{fig_average_bitrate} \\\\\n  \\includegraphics{fig_rebuffer}\n  \\caption{Comparing \\mbox{BOLA} with ELASTIC and PANDA using raw metrics: average bitrate and rebuffer-to-play ratio. \\mbox{BOLA} and PANDA do not rebuffer for profiles 1--12. ELASTIC has almost no rebuffering for profiles 1--6, but it has a rebuffer-to-play ratio greater than 20\\% for profiles 7--12.}\n  \\label{fig:AverageBitrateRebuffer}\n\\end{figure*}\n\n\\subsection{Comparison With State-of-the-Art Algorithms}\n\nWe now compare \\mbox{BOLA} with two state-of-the art algorithms, ELASTIC \\cite{decicco2013elastic} and PANDA \\cite{li2014panda}. We use the default design parameters in \\cite{decicco2013elastic} and \\cite{li2014panda}. We test both \\mbox{BOLA-O} and \\mbox{BOLA-U}. Although \\mbox{BOLA} performs better with larger buffers, we limited the buffer size to 25s for the tests to ensure fairness. ELASTIC targets a buffer level of 15s but the buffer level varies higher. PANDA targets a minimum buffer level of 26s.\n\nFig.~\\ref{fig:UtilityB} compares the algorithms using each of the 12 network profiles and the mobile traces. \\mbox{BOLA-U} consistently performs significantly better than PANDA. While \\mbox{BOLA-U} and ELASTIC perform similarly for profiles 1--6, \\mbox{BOLA-U} performs significantly better for the other profiles that have larger bandwidth variations. Recall that \\mbox{BOLA-O} always performs within a small margin of \\mbox{BOLA-U} in Fig.~\\ref{fig:UtilityA}.\n\nSince ELASTIC and PANDA were not designed for the utility score we repeat the comparison using the average bitrate and rebuffering metrics in Fig.~\\ref{fig:AverageBitrateRebuffer}. For profiles 1--6, \\mbox{BOLA-U} has approximately the same bitrate as ELASTIC. ELASTIC has a higher bitrate for profiles 7--12, but that comes at a significant cost in terms of rebuffering. For these profiles, the ratio of the rebuffering time to the play time is more than 20\\% for ELASTIC, while \\mbox{BOLA-U} has no rebuffering. For the 3G traces, ELASTIC has marginally higher bitrate than \\mbox{BOLA-U} but has a 12.0\\% rebuffer-to-play ratio compared with \\mbox{BOLA-U}'s 3.5\\%. ELASTIC rebuffers significantly more because it does not react in time when the bandwidth drops. \n\nComparing \\mbox{BOLA-U} with PANDA, both do not rebuffer for profiles 1--12.  For the 3G traces, \\mbox{BOLA-U}  and PANDA have a rebuffer-to-play ratio of 3.5\\% and 2.6\\% respectively. However, PANDA has significantly lower bitrate than \\mbox{BOLA-U}. The reason is that PANDA is more conservative and in some cases does not change to a higher bitrate even if it is sustainable.\n\nIn Fig.~\\ref{fig:BitrateChange} we show our results for our secondary metric of bitrate oscillations. \\mbox{BOLA-U} does not perform well in this metric, since it attempts to maximize utility at the cost of increased oscillations. Comparing \\mbox{BOLA-O} with ELASTIC and PANDA,  ELASTIC has a lower average change than \\mbox{BOLA-O} only in the cases where it has a slow reaction and excessive rebuffering. PANDA has a lower average change because it is more conservative and in some cases does not change to a higher bitrate even if that bitrate is sustainable.\n\n{\\em Thus, from our empirical analysis, we can conclude that \\mbox{BOLA} achieves higher utility, and performs more consistently across different scenarios in comparison with ELASTIC and PANDA.} One reason for the consistency of \\mbox{BOLA} is that it does not have a large number of parameters. \\mbox{BOLA} has two design parameters $\\gamma$ and $V$, which have an intuitive significance as discussed in Section~\\ref{subsec:param}, and an option of whether or not to trade off some utility to reduce oscillations. Other algorithms have a number of different parameters and tuning the parameters for a particular scenario might make the system less suited for other scenarios.\n\n\n\\section{Related Work}\n\\label{sec:related}\n\nThere has been a lot of recent work on bitrate adaptation algorithms, much of which is based on estimating the bandwidth of the network connection.\nNotable among this is ELASTIC \\cite{decicco2013elastic} that uses control theory to adjust the bitrate so as to keep the buffer occupancy at a constant level.\nAnother notable algorithm is PANDA \\cite{li2014panda} which also estimates the network bandwidth. PANDA drops the download bitrate as soon as low bandwidth is detected but only increases the bitrate slowly to probe the real capacity when a higher bandwidth is detected.\nIn \\cite{yin2015ccontrol}, an algorithm using model predictive control (MPC) is proposed to optimize a comprehensive set of metrics. In this approach, the bitrate for the current chunk is chosen based on a network  bandwidth prediction for the next few chunks. But, its performance depends on the accuracy of such a prediction. The approach also requires significant offline optimization to be performed outside of the client for an exhaustive set of scenarios.\nIn \\cite{Huang+14}, a buffer-based algorithm is proposed, but assumes that the buffer size is large (in the order of minutes), thereby making it not suitable for short videos. Further, it does not provide any theoretical guarantees for its buffer-based approach. Unlike prior work, we derive a buffer-based algorithm with theoretical guarantees that is simple to implement within the client and we empirically show its efficacy on extensive network traces.\n\n\\section{Conclusion}\n\\label{sec:conclusion}\n\nWe formulated video bitrate adaptation for ABR streaming as a utility maximization problem and derived \\mbox{BOLA}, an online control algorithm that is provably near-optimal. Further, we empirically demonstrated the efficacy of \\mbox{BOLA} using extensive traces. In particular, we showed that our online algorithm achieves utility close to the optimal offline algorithm. We also showed that our algorithm significantly outperformed two well-known algorithms in nearly half the test scenarios. We are also implementing BOLA as the default ABR algorithm in dash.js, the open-source DASH reference player \\cite{dashjs}, and testing BOLA ``in the wild'' with actual users.\n\n\\appendix[\\texorpdfstring{Proof of Theorem~\\ref{thm:BOLA}}{Proof or Theorem 2}]\n\\label{sec:NP-proof}\n\nWe first show part $1$ using induction. Note that the bound $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ holds for $k=1$ since $Q(t_1) = Q(0) = 0$. Now suppose it holds for some $k$. We will show that it will also hold for $k+1$. We have two cases.\n\n\\emph{Case 1:} $Q(t_k) \\leq V(\\upsilon_1 + \\gamma p)$ \\\\\nFrom the queueing equation (\\ref{eq:Q}), it follows that the maximum that $Q(t_k)$ can increase in slot $k$ is by $1$. This implies that $Q(t_{k+1}) \\leq V(\\upsilon_1 + \\gamma p) + 1$.\n\n\\emph{Case 2:} $V(\\upsilon_1 + \\gamma p) < Q(t_k) \\leq V(\\upsilon_1 + \\gamma p) + 1$ \\\\\nWe have $Q(t_k) > V ( \\upsilon_m + \\gamma p)$ for all $m \\in \\{1, 2, \\ldots, M\\}$ (using (\\ref{eq:upsilon})). It follows from the structure of optimal solution to (\\ref{eq:lyp_algo}) that \\mbox{BOLA} will choose the no-download option in this case. As a result, $Q(t_{k})$ cannot increase and we have that $Q(t_{k+1}) \\leq V(\\upsilon_1 + \\gamma p) + 1$.\n\n$Q(t_k)$ denotes the total number of chunks in the buffer. This can be at most $Q_{\\max}$ using the relation $V \\leq \\frac{Q_{\\max} - 1}{\\upsilon_1 + \\gamma p}$.\n\nIn part 2, we show the bound in (\\ref{eq:bound2}) using the technique of Lyapounov optimization over variable size frames \\cite{neely2010}. We first define a Lyapunov function $L(Q(t_k))$ as\n\n", "index": 27, "text": "\\begin{equation*}\n  L(Q(t_k)) = \\frac{1}{2} Q^2(t_k)\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"L(Q(t_{k}))=\\frac{1}{2}Q^{2}(t_{k})\" display=\"block\"><mrow><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>\u2062</mo><msup><mi>Q</mi><mn>2</mn></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nWe use the queueing equation \\eqref{eq:Q}, to bound $D(t_k)$. We consider two cases for \\eqref{eq:Q}: $Q(t_k) \\leq T_k/p$ and $Q(t_k) > T_k/p$. In the first case we have\n\n", "itemtype": "equation", "pos": 62922, "prevtext": "\nand define the per-slot conditional Lyapunov drift $D(t_k)$ as\n\n", "index": 29, "text": "\\begin{equation*}\n  D(t_k) {\\mathbin{\\mbox{\\raisebox{-.3ex}{$\\overset{\\vartriangle}{=}$}}}} \\mathbb{E}\\left\\{{L(Q(t_{k+1})) - L(Q(t_k)) | Q(t_k)}\\right\\}.\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"D(t_{k}){\\mathbin{\\mbox{\\raisebox{-1.29pt}{$\\overset{\\vartriangle}{=}$}}}}%&#10;\\mathbb{E}\\left\\{{L(Q(t_{k+1}))-L(Q(t_{k}))|Q(t_{k})}\\right\\}.\" display=\"block\"><mrow><mrow><mrow><mpadded depth=\"+1.3pt\" height=\"-1.3pt\" voffset=\"-1.3pt\"><mover accent=\"true\"><mo>=</mo><mo>\u25b3</mo></mover></mpadded><mo>\u2061</mo><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mi>\ud835\udd3c</mi></mrow><mo>\u2062</mo><mrow><mo>{</mo><mrow><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nIn the second case we have\n\n", "itemtype": "equation", "pos": 63263, "prevtext": "\nWe use the queueing equation \\eqref{eq:Q}, to bound $D(t_k)$. We consider two cases for \\eqref{eq:Q}: $Q(t_k) \\leq T_k/p$ and $Q(t_k) > T_k/p$. In the first case we have\n\n", "index": 31, "text": "\\begin{equation*}\n  D(t_k) = \\mathbb{E} \\Bigg\\{ \\frac{1}{2}\\left(\\sum_{m=1}^M a_m(t_k)\\right)^2 - \\frac{1}{2}Q^2(t_k) | Q(t_k) \\Bigg\\}.\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"D(t_{k})=\\mathbb{E}\\Bigg{\\{}\\frac{1}{2}\\left(\\sum_{m=1}^{M}a_{m}(t_{k})\\right)%&#10;^{2}-\\frac{1}{2}Q^{2}(t_{k})|Q(t_{k})\\Bigg{\\}}.\" display=\"block\"><mrow><mrow><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo maxsize=\"260%\" minsize=\"260%\">{</mo><mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>\u2062</mo><msup><mrow><mo>(</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>)</mo></mrow><mn>2</mn></msup></mrow><mo>-</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>\u2062</mo><msup><mi>Q</mi><mn>2</mn></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo maxsize=\"260%\" minsize=\"260%\">}</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nIn both cases, $D(t_k)$ is bounded by\n\n", "itemtype": "equation", "pos": 63442, "prevtext": "\nIn the second case we have\n\n", "index": 33, "text": "\\begin{multline*}\n  D(t_k) = \\mathbb{E} \\Bigg\\{\\frac{1}{2}\\left(\\frac{T_k}{p} - \\sum_{m=1}^M a_m(t_k) \\right)^2 \\\\\n  - Q(t_k) \\left(\\frac{T_k}{p} - \\sum_{m=1}^M a_m(t_k) \\right) | Q(t_k) \\Bigg\\}\n\\end{multline*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"p17.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D(t_{k})=\\mathbb{E}\\Bigg{\\{}\\frac{1}{2}\\left(\\frac{T_{k}}{p}-%&#10;\\sum_{m=1}^{M}a_{m}(t_{k})\\right)^{2}\\\\&#10;\\displaystyle-Q(t_{k})\\left(\\frac{T_{k}}{p}-\\sum_{m=1}^{M}a_{m}(t_{k})\\right)|%&#10;Q(t_{k})\\Bigg{\\}}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>D</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>\ud835\udd3c</mi><mrow><mo maxsize=\"260%\" minsize=\"260%\">{</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo>(</mo><mfrac><msub><mi>T</mi><mi>k</mi></msub><mi>p</mi></mfrac><mo>-</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>m</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mn>2</mn></msup></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mo>-</mo><mi>Q</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mo>(</mo><mfrac><msub><mi>T</mi><mi>k</mi></msub><mi>p</mi></mfrac><mo>-</mo><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msub><mi>a</mi><mi>m</mi></msub><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo stretchy=\"false\">|</mo><mi>Q</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo maxsize=\"260%\" minsize=\"260%\">}</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere $\\Psi$ is an upper bound on $\\mathbb{E}\\left\\{{T_k^2}\\right\\}$ under any control algorithm and is assumed to be finite.\n\nFollowing the methodology of the Lyapunov optimization technique, we subtract $V \\times \\textrm{reward term}$ from both sides of the above to get\n\n", "itemtype": "equation", "pos": 63691, "prevtext": "\nIn both cases, $D(t_k)$ is bounded by\n\n", "index": 35, "text": "\\begin{align*}\nD(t_k) \\leq \\frac{p^2 + \\Psi}{2p^2} - Q(t_k) \\mathbb{E}\\left\\{{\\frac{T_k}{p} - \\sum_{m=1}^M a_m(t_k) | Q(t_k)}\\right\\}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D(t_{k})\\leq\\frac{p^{2}+\\Psi}{2p^{2}}-Q(t_{k})\\mathbb{E}\\left\\{{%&#10;\\frac{T_{k}}{p}-\\sum_{m=1}^{M}a_{m}(t_{k})|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><mfrac><msub><mi>T</mi><mi>k</mi></msub><mi>p</mi></mfrac></mstyle><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nLet us denote the control decisions (and resulting slot lengths) under our control algorithm by the superscript \\mbox{BOLA} while those under the stationary policy of Lemma~\\ref{lem:policy} by STAT. Since \\mbox{BOLA} greedily maximizes over a frame, it ensures that\n\n", "itemtype": "equation", "pos": 64111, "prevtext": "\nwhere $\\Psi$ is an upper bound on $\\mathbb{E}\\left\\{{T_k^2}\\right\\}$ under any control algorithm and is assumed to be finite.\n\nFollowing the methodology of the Lyapunov optimization technique, we subtract $V \\times \\textrm{reward term}$ from both sides of the above to get\n\n", "index": 37, "text": "\\begin{align}\nD(t_k) &- V \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}  \\nonumber\\\\\n& \\leq \\frac{p^2 + \\Psi}{2p^2} - Q(t_k) \\mathbb{E}\\left\\{{\\frac{T_k}{p} - \\sum_{m=1}^M a_m(t_k) | Q(t_k)}\\right\\} \\nonumber\\\\\n&- V \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}\n\\label{eq:drift1}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D(t_{k})\" display=\"inline\"><mrow><mi>D</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-V\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}(t_{k})(\\upsilon_{m}+%&#10;\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{p^{2}+\\Psi}{2p^{2}}-Q(t_{k})\\mathbb{E}\\left\\{{\\frac{T_{%&#10;k}}{p}-\\sum_{m=1}^{M}a_{m}(t_{k})|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><mfrac><msub><mi>T</mi><mi>k</mi></msub><mi>p</mi></mfrac></mstyle><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-V\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}(t_{k})(\\upsilon_{m}+%&#10;\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msub><mi>a</mi><mi>m</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere $\\eta = \\frac{\\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}} | Q(t_k)}\\right\\}}{\\mathbb{E}\\left\\{{T_k^{\\mathrm{STAT}} | Q(t_k)}\\right\\}}$. To see this, compare the ratio on the left hand side above with the objective in (\\ref{eq:lyp_algo}) while noting that we can express the denominator as $\\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}} | Q(t_k)}\\right\\} = (\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k) S_m )/\\omega_{\\mathrm{avg}}$. It should be noted that this ratio can be minimized without requiring knowledge of $\\omega_{\\mathrm{avg}}$. Then we use \\eqref{eq:bolastat} to express \\eqref{eq:drift1} as\n\n", "itemtype": "equation", "pos": 64741, "prevtext": "\nLet us denote the control decisions (and resulting slot lengths) under our control algorithm by the superscript \\mbox{BOLA} while those under the stationary policy of Lemma~\\ref{lem:policy} by STAT. Since \\mbox{BOLA} greedily maximizes over a frame, it ensures that\n\n", "index": 39, "text": "\\begin{multline}\n{\\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k) (Q(t_k) - V (\\upsilon_m + \\gamma p))  | Q(t_k)}\\right\\}}  \\\\\n\\leq  \\eta \\times {\\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{STAT}}(t_k) (Q(t_k) - V (\\upsilon_m + \\gamma p))  | Q(t_k)}\\right\\}}\n\\label{eq:bolastat}\n \\end{multline}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^{\\mathrm{BOLA}}(t_{k})(Q(t%&#10;_{k})-V(\\upsilon_{m}+\\gamma p))|Q(t_{k})}\\right\\}}\\\\&#10;\\displaystyle\\leq\\eta\\times{\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^{\\mathrm{%&#10;STAT}}(t_{k})(Q(t_{k})-V(\\upsilon_{m}+\\gamma p))|Q(t_{k})}\\right\\}}\" display=\"block\"><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><msubsup><mi>a</mi><mi>m</mi><mi>BOLA</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mi>\u03b7</mi><mo>\u00d7</mo><mi>\ud835\udd3c</mi></mrow><mo>\u2062</mo><mrow><mo>{</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><mrow><msubsup><mi>a</mi><mi>m</mi><mi>STAT</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nSubstituting the time-average values for the stationary policy we get\n\n", "itemtype": "equation", "pos": 65633, "prevtext": "\nwhere $\\eta = \\frac{\\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}} | Q(t_k)}\\right\\}}{\\mathbb{E}\\left\\{{T_k^{\\mathrm{STAT}} | Q(t_k)}\\right\\}}$. To see this, compare the ratio on the left hand side above with the objective in (\\ref{eq:lyp_algo}) while noting that we can express the denominator as $\\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}} | Q(t_k)}\\right\\} = (\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k) S_m )/\\omega_{\\mathrm{avg}}$. It should be noted that this ratio can be minimized without requiring knowledge of $\\omega_{\\mathrm{avg}}$. Then we use \\eqref{eq:bolastat} to express \\eqref{eq:drift1} as\n\n", "index": 41, "text": "\\begin{align*}\n&D^{\\mathrm{BOLA}}(t_k) - V \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}  \\nonumber\\\\\n& \\leq \\frac{p^2 + \\Psi}{2p^2} - Q(t_k) \\mathbb{E}\\left\\{{\\frac{T_k^{\\mathrm{BOLA}}}{p} - \\eta \\sum_{m=1}^M a_m^{\\mathrm{STAT}}(t_k) | Q(t_k)}\\right\\} \\nonumber\\\\\n  &\\;\\; - V \\eta \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{STAT}}(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}\\nonumber\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D^{\\mathrm{BOLA}}(t_{k})-V\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^%&#10;{\\mathrm{BOLA}}(t_{k})(\\upsilon_{m}+\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mrow><msup><mi>D</mi><mi>BOLA</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>BOLA</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{p^{2}+\\Psi}{2p^{2}}-Q(t_{k})\\mathbb{E}\\left\\{{\\frac{T_{%&#10;k}^{\\mathrm{BOLA}}}{p}-\\eta\\sum_{m=1}^{M}a_{m}^{\\mathrm{STAT}}(t_{k})|Q(t_{k})%&#10;}\\right\\}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><mfrac><msubsup><mi>T</mi><mi>k</mi><mi>BOLA</mi></msubsup><mi>p</mi></mfrac></mstyle><mo>-</mo><mrow><mi>\u03b7</mi><mo>\u2062</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>STAT</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\;\\;-V\\eta\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^{\\mathrm{STAT}}(t%&#10;_{k})(\\upsilon_{m}+\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mpadded width=\"+2.8pt\"><mi mathvariant=\"normal\">\u2004</mi></mpadded><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\u03b7</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>STAT</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nwhere $r^{\\mathrm{STAT}}$ denotes the expected arrival rate under the stationary policy and cannot exceed $1/p$ since it is rate stable. Thus we have\n\n", "itemtype": "equation", "pos": 66157, "prevtext": "\nSubstituting the time-average values for the stationary policy we get\n\n", "index": 43, "text": "\\begin{align}\n&D^{\\mathrm{BOLA}}(t_k) - V \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}  \\nonumber\\\\\n& \\leq \\frac{p^2 + \\Psi}{2p^2} - Q(t_k) \\Big(\\frac{1}{p} - r^{\\mathrm{STAT}}\\Big) \\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}}| Q(t_k)}\\right\\} \\nonumber\\\\\n&\\;\\; - V (\\upsilon^* + \\gamma s^*) \\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}}| Q(t_k)}\\right\\}\n\\label{eq:drift3}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D^{\\mathrm{BOLA}}(t_{k})-V\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^%&#10;{\\mathrm{BOLA}}(t_{k})(\\upsilon_{m}+\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mrow><msup><mi>D</mi><mi>BOLA</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>BOLA</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{p^{2}+\\Psi}{2p^{2}}-Q(t_{k})\\Big{(}\\frac{1}{p}-r^{%&#10;\\mathrm{STAT}}\\Big{)}\\mathbb{E}\\left\\{{T_{k}^{\\mathrm{BOLA}}|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo maxsize=\"160%\" minsize=\"160%\">(</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><mi>p</mi></mfrac></mstyle><mo>-</mo><msup><mi>r</mi><mi>STAT</mi></msup></mrow><mo maxsize=\"160%\" minsize=\"160%\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msubsup><mi>T</mi><mi>k</mi><mi>BOLA</mi></msubsup><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\;\\;-V(\\upsilon^{*}+\\gamma s^{*})\\mathbb{E}\\left\\{{T_{k}^{\\mathrm%&#10;{BOLA}}|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mpadded width=\"+2.8pt\"><mi mathvariant=\"normal\">\u2004</mi></mpadded><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\u03c5</mi><mo>*</mo></msup><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mi>s</mi><mo>*</mo></msup></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msubsup><mi>T</mi><mi>k</mi><mi>BOLA</mi></msubsup><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nTaking conditional expectation of both sides and summing over $k \\in \\{1, 2, \\ldots, K_N\\}$, we get\n\n\\break\n\\noindent\n\n", "itemtype": "equation", "pos": 66730, "prevtext": "\nwhere $r^{\\mathrm{STAT}}$ denotes the expected arrival rate under the stationary policy and cannot exceed $1/p$ since it is rate stable. Thus we have\n\n", "index": 45, "text": "\\begin{align}\n&D^{\\mathrm{BOLA}}(t_k) - V \\mathbb{E}\\left\\{{\\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k)(\\upsilon_m + \\gamma p) |  Q(t_k)}\\right\\}  \\nonumber\\\\\n& \\leq \\frac{p^2 + \\Psi}{2p^2} - V (\\upsilon^* + \\gamma s^*) \\mathbb{E}\\left\\{{T_k^{\\mathrm{BOLA}}| Q(t_k)}\\right\\}\n\\label{eq:drift4}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D^{\\mathrm{BOLA}}(t_{k})-V\\mathbb{E}\\left\\{{\\sum_{m=1}^{M}a_{m}^%&#10;{\\mathrm{BOLA}}(t_{k})(\\upsilon_{m}+\\gamma p)|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mrow><msup><mi>D</mi><mi>BOLA</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>BOLA</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E14.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{p^{2}+\\Psi}{2p^{2}}-V(\\upsilon^{*}+\\gamma s^{*})\\mathbb%&#10;{E}\\left\\{{T_{k}^{\\mathrm{BOLA}}|Q(t_{k})}\\right\\}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\u03c5</mi><mo>*</mo></msup><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mi>s</mi><mo>*</mo></msup></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><msubsup><mi>T</mi><mi>k</mi><mi>BOLA</mi></msubsup><mo stretchy=\"false\">|</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06748.tex", "nexttext": "\nDividing both sides by $V\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_N} T_k^{\\mathrm{BOLA}}}\\right\\}$ and taking the limit as $N \\to \\infty$ yields the bound in (\\ref{eq:bound2}).\n\n\n\\bibliographystyle{IEEEtran}\n\\bibliography{bola}\n\n\\null \n\n\n", "itemtype": "equation", "pos": 67147, "prevtext": "\nTaking conditional expectation of both sides and summing over $k \\in \\{1, 2, \\ldots, K_N\\}$, we get\n\n\\break\n\\noindent\n\n", "index": 47, "text": "\\begin{align}\n&\\mathbb{E}\\left\\{{L(Q(t_{K_{N+1}}))}\\right\\} - V \\mathbb{E}\\left\\{{\\sum_{k=1}^{K_N} \\sum_{m=1}^M a_m^{\\mathrm{BOLA}}(t_k)(\\upsilon_m + \\gamma p)}\\right\\}  \\nonumber\\\\\n& \\leq \\frac{(p^2 + \\Psi)K_N}{2p^2} - V (\\upsilon^* + \\gamma s^*) \\mathbb{E}\\left\\{{\\sum_{k=1}^{K_N} T_k^{\\mathrm{BOLA}}}\\right\\}\n\\label{eq:drift5}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\mathbb{E}\\left\\{{L(Q(t_{K_{N+1}}))}\\right\\}-V\\mathbb{E}\\left\\{{%&#10;\\sum_{k=1}^{K_{N}}\\sum_{m=1}^{M}a_{m}^{\\mathrm{BOLA}}(t_{k})(\\upsilon_{m}+%&#10;\\gamma p)}\\right\\}\" display=\"inline\"><mrow><mrow><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mi>L</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><msub><mi>K</mi><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>}</mo></mrow></mrow><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></munderover></mstyle><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover></mstyle><mrow><msubsup><mi>a</mi><mi>m</mi><mi>BOLA</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c5</mi><mi>m</mi></msub><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><mi>p</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>}</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E15.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\frac{(p^{2}+\\Psi)K_{N}}{2p^{2}}-V(\\upsilon^{*}+\\gamma s^{*})%&#10;\\mathbb{E}\\left\\{{\\sum_{k=1}^{K_{N}}T_{k}^{\\mathrm{BOLA}}}\\right\\}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>p</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant=\"normal\">\u03a8</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>K</mi><mi>N</mi></msub></mrow><mrow><mn>2</mn><mo>\u2062</mo><msup><mi>p</mi><mn>2</mn></msup></mrow></mfrac></mstyle><mo>-</mo><mrow><mi>V</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\u03c5</mi><mo>*</mo></msup><mo>+</mo><mrow><mi>\u03b3</mi><mo>\u2062</mo><msup><mi>s</mi><mo>*</mo></msup></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udd3c</mi><mo>\u2062</mo><mrow><mo>{</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>K</mi><mi>N</mi></msub></munderover></mstyle><msubsup><mi>T</mi><mi>k</mi><mi>BOLA</mi></msubsup></mrow><mo>}</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}]