[{"file": "1601.00517.tex", "nexttext": "\n\\noindent where $C$ is the total number of channels available, $N$ is the number of neighboring APs, $T_{\\mathrm{Beacon-IE}}$  and $R_{\\mathrm{Beacon}}$ are the additional beacon overhead and beacon interval (10\\,Hz) respectively. The first term represents the overhead due to the additional transmission of IE in beacon frames. Note, that due to multi-channel environment the APs are operating on different radio channels, hence to get the per channel overhead we have to divide by the number of channels. The second term represents the overhead due to scanning deafness.\n\n\\subsubsection{ResFi}\n\nNext, we analyze the overhead of the ResFi approach:\n\n", "itemtype": "equation", "pos": 55737, "prevtext": "\n\n\n\n\n\n\n{\n\\sffamily\n\n\\thispagestyle{empty}\n\n\\begin{tabularx}{\\columnwidth}{cXc}\n  \\includegraphics[height=1cm]{TU-Logo-3D-rot.pdf}\n  & &\n  \\includegraphics[height=1cm]{tknlogo.pdf}\n  \\\\\n\\end{tabularx}\n\n\n\\vspace{1.0cm}\n\n\\begin{center}\n{\\huge\n\\noindent\nTechnische Universit\u00c3\u00a4t Berlin\n\n\\vspace{0.5cm}\n\n\\noindent\nTelecommunication Networks Group\n\n\\begin{center}\n\\rule{15.5cm}{0.4pt}\n\\end{center}\n}\n\\end{center}\n\n\\begin{minipage}[][11.0cm][c]{14.5cm}\n{\\Huge\n\n\\begin{center}\n{ResFi: A Secure Framework for Self Organized Radio Resource Management in Residential WiFi Networks}\n\\end{center}\n\n\\begin{center}\n{\\LARGE {Sven Zehl, Anatolij Zubow, Adam Wolisz and Michael D\u00c3\u00b6ring}} \\\\\n{\\Large \\tremail}\n\\end{center}\n\n\n\\begin{center}\nBerlin, {Dezember 2015}\n\\end{center}\n\n\n\\vspace{0.5cm}\n\n}\n\n\n\\begin{center}\n\\setlength{\\fboxrule}{2pt}\\setlength{\\fboxsep}{2mm}\n\\fbox{TKN Technical Report {TKN-15-0005}}\n\\end{center}\n\n\\end{minipage}\n\n\\setlength{\\fboxrule}{0.4pt}\n\\setlength{\\fboxsep}{0.4pt}\n\n\\begin{center}\n\n  \\rule{15.5cm}{0.4pt}\n\n  \\vspace{0.5cm}\n\n  {\\huge {TKN Technical Reports Series}}\n\n  \\vspace{0.5cm}\n\n  {\\huge Editor: Prof. Dr.-Ing. Adam Wolisz}\n\n  \\vspace{0.5cm}\n\n \\end{center}\n\n\n}\n\n\n\\begin{abstract}\n\\subsection*{\\abstractname}\n\n\nIn dense deployments of residential WiFi networks individual users suffer performance degradation due to both contention and interference. While Radio Resource Management (RRM) is known to mitigate this effects its application in residential WiFi networks being by nature  unplanned and individually managed creates a big challenge.\n\nWe propose ResFi - a framework supporting creation of RRM functionality in legacy deployments. The radio interfaces are used for efficient discovery of adjacent APs and as a side-channel to establish a secure communication among the individual Access Point Management Applications within a neighborhood over the wired Internet backbone.\n\nWe have implemented a prototype of ResFi and studied its performance in our testbed. As a showcase we have implemented various RRM applications among others a distributed channel assignment algorithm using ResFi. ResFi is provided to the community as open source.\n\n\\end{abstract}\n\n\\tableofcontents\n\n\n\n\n\n\n\n\n\n\\chapter{Introduction}\\label{sec:introduction}\n\nIn recent years we have seen a rapid growth in the use of wireless devices such as laptops, tablets and smart phones in all environments e.g., enterprise and homes. Especially, the IEEE 802.11 (WiFi) wireless technology gained lot of popularity as a comfortable way to connect a multitude of devices. As applications like mobile HD video \\& cloud storage require high QoS, dense deployments of wireless technologies observed nowadays cause performance issues due to high contention and interference within the limited set of radio frequencies.\nIn enterprise networks remaining within a single administrative domain this issue is commonly solved by installing a centralized controller which manages the usage radio resources by all APs~\\cite{murty2008designing,Zubow15bigap_seamless_handover}. \nThe performance of this controller depends on the scope of information used \u00e2\u0080\u0093 this is at least the sum of the traffic and channel usage observations by all the APs but gradually a trend to use also information provided by the end systems (using e.g. 802.11k) becomes also visible.  It has been widely demonstrated that the coordinated usage of radio resources has led to very significant improvement of the QoS, and in fact it is a fundamental condition to achieve satisfactory QoS in dense, heavily used environments. \nIn contrast apartment house deployments usually consist of multiple autonomous APs remaining under administration of individual users. Indeed, each AP is usually installed by a resident who due to lack of technical skills attempts to minimize the configuration effort. While in the past this led to the well known phenomenon of using mostly the single, pre-set channel, manufacturers started increasing the scope of self-configuration functions provided. \nThe scope of this self-configuration is, however, still limited to functions depending exclusively on local observations within this AP and local controls.  In the residential deployment the individual APs - even located in close proximity do not have a direct way to enter an organized information exchange and negotiations. In addition the usual consumer electronic devices expected in an apartment usually do not support management features like those provided by 802.11k, so that no additional information from them can be obtained. \n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this paper we present ResFi - a set of basic self configuration functionalities enabling radio resource management in residential WiFi.\nResFi offers the following functionalities:\n\\begin{enumerate}\n\\item Discovery of the immediate neighborhood \u00e2\u0080\u0093 any active APs within the radio coverage. \n\\item Setting up secured point-to-point control channels between any pair of immediate neighbors over the wired Internet backbone.\n\\item Exchange of N-hop neighborhood information and continuous monitoring of the neighborhood using the above channels.  \n\\end{enumerate} \nResFi is specified and implemented in form of platform independent source code which can be used on top of the legacy APs. Up to our best knowledge this is a first attempt to suggest such a platform. We believe that this set of basic function creates a good foundation to develop management application algorithms which itself is explicitly a NON goal of this paper.\nAs a proof of concept we provide however \n\\begin{itemize}\n\\item A description, implementation and evaluation of a simple distributed AP channel assignment algorithm.\n\\item A description, implementation and evaluation of a simple distributed clustering algorithm to show how one could select a group of access point subjects to joint RRM.\n\\end{itemize} \nThe performance of the proposed approach is evaluated by means of experiments in a real testbed. Moreover, we provide an emulation in Mininet~\\cite{mininetUrl} which gives the developer an easy way to test own algorithms before  deploying  them  in  a  real  testbed.  Finally  ResFi  is  provided to the community as open source under GPL license on Github \\url{https://github.com/resfi}.\n\n\n\n\n\n\\chapter{Related Work}\\label{sec:related_work}\n\n\n\nWiFi enterprise networks are already widely deployed in companies, universities and public spaces like airports and fairgrounds. \n\nCommercial enterprise WiFi solutions mostly feature a centralized controller which performs RRM for all\nattached APs. For example the widespread CISCO solution~\\cite{cisco-rrm} works as follows: each of the APs sends  periodically on all the radio channels \"neighbor search\"  messages including the Internet protocol address of their responsible\ncontroller and the identifier of the group they belong to within this controller. Neighboring APs forward the received\n\"neighbor search\" message including their own AP identifier to their responsible controller (frequently via the wired control connection). This enables the controller to build a hearing map, group APs in RRM groups or to elect a leader controller for the RRM process.\nDistributed approaches are less frequent - e.g. Aerohive~\\cite{aerohive-rrm} uses a classical distributed leader election algorithm for RF channel assignment. If a newly started AP discovers other APs on his RF channel, it advertises its neighbor count via the wireless channel while listening for the advertisment of the other APs. Finally the AP with the most neighbors wins the right to use the channel. All others switch to the next RF channel and the aforementioned procedure repeats.\n\n\n\n\nDifferent options to optimize the RRM in enterprise WiFi networks have been addressed in research papers. Again the use of a central controller using wireless propagation data, \ncollected from all deployed APs~\\cite{murty2008designing,murty2008architecture,shrivastava2009centaur2,yiakoumis2014behop,Zubow15bigap_seamless_handover} dominate the field. \nThe centralized view is then used to make global decisions in terms of e.g. channel assignment. In addition, more advanced approaches also provide the possibility of load balancing and handover operations~\\cite{murty2008designing, yiakoumis2014behop,Zubow15bigap_seamless_handover} or transmit power and rate adaption control \\cite{murty2008architecture}.\n\n\n\nA typical residential WiFi deployment usually consists of\nstatically deployed APs and mobile client STAs. As the APs are not administered by a single authority but rather\nas each AP is independently managed by another unexperienced\nuser, residential WiFi deployments can be assumed as\nchaotic~\\cite{Akella-2005}. The density of APs is highly correlated with the residential density and large-scale measurements~\\cite{biswas2015large} showed\nthat the number of neighboring APs is relatively high in\nurban environments, i.e. each AP has on average around 16.8\nneighboring APs in the 2.4 GHz band.\n\n\nIn this chaotic deployment there does NOT exist a natural way to establish the information exchange between each of them. There does not exist a dedicated controller, and the skills of the \u00e2\u0080\u009chuman administrator\u00e2\u0080\u009d are usually limited.\n\nPatro et al.~\\cite{Patro-2015} have postulated the use of a  cloud-based controller for channel assignment and airtime management. They propose to run one controller per building either funded by an Internet service provider (ISP) or the building manager. Further, the interaction between the residential APs and the controller is enabled by an extended version of the OpenFlow protocol. This approach seems promising for single administered apartment houses (single ISP or single building manager) but due to the lack of an auto configuration possibility it has its difficulties for all other deployment scenarios. Besides, the funding of the centralized controller and the payment of its operational costs is not easy to clarify. A controller-less solution would be favorable. \n\n\n\n\n\n\n\nIn RxIP~\\cite{manweiler-2012} a novel approach: direct communication between neighboring APs is introduced for the first time. Each home AP transmits a globally-routable IP address through additional information embedded within the periodically broadcasted beacon frames. This allows passively listening neighbor APs to communicate with the transmitter over the wired Internet, thus featuring a P2P fashion of interaction. RxIP does not aim RRM in general but rather targets the specific use-case of hidden terminal discovery and mitigation of its effect. In dialog with its neighbors, each AP collects independently the information about potential hidden terminals related to him. Therefore the RxIP approach is by definition restricted to discovery of only those neighboring APs which use the \n\nsame RF channel. Nevertheless a more global view seems to be desirable.\n\n\n\nUsing large-scale measurement data from several cities Akella et al.~\\cite{Akella-2005} showed that end-client experience in home WiFi networks could be significantly improved by managing the transmit power in such chaotic wireless networks. Using their proposed load-sensitive rate fallback implementation (LPERF) in which transmitters reduce their transmit power even if it reduces their transmission rate, they were able to show significant throughput enhancement through interference reduction among neighboring APs in dense deployments by incorporating among others the traffic demands of neighboring APs. They did, however not provide suggestions how the relevant stations are to be selected and how should they exchange the necessary coordination information. \n\n\n\n\n\n\nFinally numerous papers have addressed distributed radio resource management. For example in~\\cite{Kubisch-2003}\n\npower assignment in arbitrary wireless topologies has been assigned in a distributed way. \nNevertheless none of these papers investigates specifically HOW to assure connectivity needed for information exchange among the involved nodes.\n\n\n\\chapter{IEEE 802.11 Primer}\\label{sec:dot11primer}\n\nThis section gives a brief overview of the relevant aspects of the IEEE 802.11 standard.\n\n\\section{AP Discovery (i.e. scanning)}\nTwo approaches are possible. \n\n\\subsection{Passive Scanning}\nAll IEEE 802.11 APs are broadcasting beacon frames in a fixed time interval to announce the existence of the 802.11 network. This includes advertising the Service Set Identifier (SSID) as well as all parameters needed for STAs to identify whether a connection to the network is possible. Upon activation/arrival, client STAs move to each available RF channel, listen for beacon frames, buffer the embedded information and create a map of available APs (obviously an AP can passively scan the environment in the same way). Passive scanning requires spending quite a significant time while listening to each channel! Due to security consideration APs may, however, suppress the announcement of the SSID, therefore passive scanning does NOT assure discovery of ALL available networks.\n\n\\subsection{Active Scanning}\\label{sec:probe}\nSTAs searching for 802.11 networks can send out \\textit{probe request} frames. If an AP receives a probe request with a matching SSID and suggested data rates within the scope supported by this AP, it replies with a probe response including all parameters of the normal beacon frame. Interestingly, an STA (or AP interested in his neighborhood) can use in the request frame a broadcast SSID which triggers an response from all networks which have been able to receive this request.\n\n\n\n\\ \n\n\n\n\n\n\n\n\\section{Information Elements}\\label{sec:ie}\n\nBeacon, probe request and probe response frames are defined as management frames. The frame body of a management frame is built up of fixed length fields and variable length fields which are called \\textit{information elements (IE)}. \nIn addition to the standard IE(s) which are used e.g. to transport the SSID or the supported data rates, the standard describes a specific one called \\textit{vendor specific information} and allowing to transport up to 255 bytes of custom data. We will denote this specific IE(s) as IEV.\n\n\n\n\n\\chapter{ResFi Design Principles}\\label{sec:bigap_design}\n\n\\section{System Model}\n\n \\begin{figure}\n \\centering\n \\begin{minipage}[b]{0.75\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.7\\linewidth]{sys_model}\n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{A residential WiFi network consists of client Stations (STA) and Access Points (AP). Each AP is connected via wired broadband access to the Internet.}\n    \\label{fig:sys_model}\n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\n\n\n\nOur view of the \u00e2\u0080\u009cchaotically deployed\u00e2\u0080\u009d WiFis is presented in Fig.~\\ref{fig:sys_model}.\n\nEach static AP is assumed to have two network interfaces, namely, an WiFi compliant air interface used for wireless communication towards STAs and a wired broadband access interface with a globally-routable IP address to connect to the Internet usually via DSL or cable modem. As we assume DSL/cable as the wired access technology there is a significant last-mile latency on the wired link to the first hop inside the ISP\u00e2\u0080\u0099s network~\\cite{sundaresan2011broadband}.\n\nWe assume that the APs in a given neighborhood are deployed gradually (meaning they are switched on for the first time one by one), Any AP might also be switched off at any time \u00e2\u0080\u0093 temporarily or for good.\n\nWe assume also that every AP is controlled by a AP management unit (APMU) which consists of several functional blocks such as client access control and operational parameter setting (like beacon interval setting). In classical deployment each AP has some - rather simplistic - local radio resource management e.g. setting of a fixed transmission channel, or simple selection of the transmission channel.\n \nWe postulate introducing in each AP a dedicated process called RRMU which is assumed to have IP connectivity over the wired Internet backhaul. Moreover, the RRMU is assumed to have an API (called southbound API) making it possible to access radio statistics and parameters within the AP. \n\n \n\n\n\n\n\n\n\n\n\n\n\\section{Principles of the ResFi Framework}\nThe goal of ResFi is to define a self organized creation of a secured connectivity among the RRMU of all APs within a given neighborhood without: \n\\begin{itemize}\n\\item Violating the assumptions of keeping each of the \nparticipating APs under separate local management\n\\item Any changes in the hardware and drivers of commercially available access points\n\\end{itemize}\nThe approach can be presented in a nutshell as follows: During the boot-up phase of any AP a broadcast scan request \nincluding a ResFi specific IEV containing so called \"contact data\" is triggered sequentially on each of the supported channels. Any AP within the coverage of this scan request is expected to answer with the respective \"contact data\" of the responder. These contact data, embedded in the IEV of both the active scan probe and response consists of the globally-routeable IP address and port number of the AP's RRMU (on the fixed internet) as well as of a transient 1-hop group encryption key and a public cryptography key individual to this RRMU.\n\nAfter having completed the scan and having received the answers, the RRMU of the newly booted AP can establish a secure, point-to-point control channel to the RRMUs of all the \"discovered\" APs over the wired backbone Internet. Placing the control channel into the wired connectivity has several advantages. Notably there is no additional load on the wireless interfaces, and there is obviously a lower error rate. On the other hand longer message exchange delays have to be taken into account. This does not seem to be really a big issue, as the radio resource management does not take place in very short time scales.\n\nThus a coordination within one-hop neighborhood would be available at this point. \nIt is, however, well known that RRM (e.g. channel selection) can achieve better efficiency if performed over a cluster of APs larger than one hop neighborhood. Therefore ResFi requires that each RRMU is able to act as a forwarder enabling to extend secure connectivity towards up to N hops (N can be set individually for every message sent via ResFi's northbound framework API). ResFi does not define the precise policy to create an RRM cluster within the scope of the connectivity borders mentioned above, neither does it feature a specific RRM approach. Both of these decisions are delegated to an RRM APPLICATION  which is not a part of the platform itself. We will provide in Section \\ref{sec:resfi_applications} some examples of such applications. \n\nThe security of the control channel is not constrained to the establishment with the use of proper cryptographic keys, in addition the keys are occasionally exchanged (see the following part).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{ResFi Security Model}\n\nWhy do we care about the security of the control channel for cooperative RRM? The reason is very simple. Divisive action might severely harm the wireless access of some users, and lead to an unfair advantage of some AP owners. While \"unfair cheating\" behaviors can not be completely eliminated (e.g some AP might claim that there are numerous APs in his vicinity thus luring neighbors to leave a channel for him alone) we offer within our framework a set of measures leading to clear identification of the source and destination of any information as well assuring the integrity of any information exchanged via the control channel. \nBy the set of this means we can at least be sure, that the possible malicious behavior of any of the participants might be - after detection - uniquely traced back to this participant. And there will be no way this participant might claim his innocence. We will discuss below the threats we are considering - i.e the security model - adding a \"rough outline\" of the countermeasures. \n\nThe primary exchange of security material for establishing a secure control channel takes place over the wireless channel within the exchange of the IEV in the probe request and probe reply frames. Therefore the possibility to get the security material is very constrained in space to the local observers.\n \n\\subsection{Thread: Eavesdropping or man in the middle attack on the wired control channel} \n\\begin{itemize}\n\\item An attacker may be able to sniff the whole control traffic of multiple RRMUs which would allow him to get inside views of future behavior or configuration of the APs.\n\\item \\textit{Countermeasure:} The communication over the control channel is encrypted by utilizing a 1-hop cryptography key. Every RRMU embeds its currently used symmetric group key within its probe request and response frames and uses this key for all outgoing traffic. Enhanced security between distinct peers is achieved by encrypting unicast messages using the public keys exchanged during the discovery phase.\n\\end{itemize}\n\\subsection{Thread: Rogue Attack} \n\\begin{itemize}\n\\item A malicious user may be able to drive through an area and collect the credentials to build up the wired control channel to multiple local RRMUs which would allow him to influence their behavior in a malicious way.\n\\item \\textit{Countermeasure:} ResFi RRMUs periodically\nchange the utilized group encryption session keys in\nirregular time  intervals via the local wireless channel. The interceptor would have to place a local \"spy device\" remaining in a continuous connection with him. Nevertheless, on the other hand if he will try to act as his fixed IP address could be checked in any case of doubt (irregular or suspicious behavior). \n\\end{itemize}\n\n\\subsection{Authenticity of the transmitting party}\n\\begin{itemize}\n\\item Again, even \"drive-through\" interception of the primary security material will not help. ResFi provides authenticity by the requirement that all outgoing ResFi messages sent via the wired backhaul have to be signed with the private key of the sender which allows the receiver to validate the signature with the corresponding public key exchanged during the discovery phase.\n\\end{itemize}\n\n\\subsection{Thread: Replay Attack} \n\\begin{itemize}\n\\item If an attacker may be able to sniff control packets and send them unaltered but delayed to the original receivers this could result in confusion or misbehavior of the receiver APs RRMUs.\n\\item \\textit{Countermeasure:} All sent ResFi messages are equipped with a unique\nsequence number\n\\end{itemize}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\chapter{ResFi -- Detailed Specification}\\label{sec:resfi_arch}\n\n\\section{Bootstrapping}\\label{sec:boot}\n\nAfter an ResFi enabled residential WiFi AP has booted up, the ResFi agent is started, the first symmetric group key and the RSA key pairs are generated and the discovery process is initiated. For each detected adjacent AP a mutual key and public IP exchange is performed over the wireless channel. This process is also depicted in Fig. \\ref{fig:arch}.\\\\\nIn a first step the ResFi agent of the newly booted up AP ($AP_{0}$) performs a full active scan on all available IEEE 802.11 RF channels. This step includes the sending of a probe request\\footnote{$\\approx$ 212 octets standard probe response size or $\\approx$ 64 octets standard probe request (depends on number of capabilities broadcasted in general by AP), plus each time the size of the vendor specific big ResFi IE (IE header 6 octets + transient group encryption key and IV 32 octets + 15 octets IP address + 162 octets DER encoded RSA public key)\\label{fn:probesize}} including $AP_{0}$'s ResFi credentials (public IP of the RRM unit, currently used encryption key and public RSA key, embedded in an IE within the probe request) on each available RF channel which in turn triggers all ResFi APs in vicinity ($AP_{1..n}$) to send out their ResFi credentials embedded in an IE within a probe response\\textsuperscript{\\ref{fn:probesize}} back to $AP_{0}$, cf. Fig. \\ref{fig:arch} tag 1. $AP_{0}$ subscribes itself to the publish (Pub) sockets of $AP_{1..n}$ using the public IP provided by the Probe Responses and $AP_{1..n}$ subscribe themselves to the publish (Pub) socket of $AP_{0}$ using the public IP provided by the Probe Request. Now $AP_{0}$ is able to successfully receive, validate and decrypt all messages sent via the wired backhaul by $AP_{1..n}$ and $AP_{1..n}$ are able to successfully receive, validate and decrypt all messages sent via the wired backhaul by $AP_{0}$. \n\n\n\n\n\nThe formation of the secure bidirectional control channel is completed. Broadcast messages to all neighbors are encrypted using the transient symmetric group key, cf. Fig. \\ref{fig:arch}, tag 2 while unicast messages are in advance encrypted using the public RSA key of the corresponding receiver, cf. Fig. \\ref{fig:arch}, tag 3. Moreover, all sent messages are signed using the private RSA key of the corresponding sender. This process is also described in Fig.~\\ref{fig:fsm_1} as UML state machine.\n\n\n \\begin{figure}\n \\centering\n \\begin{minipage}[h!]{1\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.75\\linewidth]{design}\n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Overview of the system architecture of ResFi: the wireless channel is used for exchange of configuration parameters (global IP of RRM unit, transient group encryption key and public RSA key) which are afterwards used for setting up the secure P2P out-of-band control channels over the Internet.}\n    \\label{fig:arch}\n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n    \n\\subsection{Standard Mode of Operation}\n\nIn the standard mode of operation the secure bidirectional control channel was already successfully established. All participating ResFi AP RRMUs are able to broadcast messages encrypted with their own group session key and signed with their own private RSA key to all of its one-hop ResFi neighbor RRMUs via the backhaul overlay network. All participating ResFi neighbor RRMUs are able to decrypt these messages, verify their integrity and the authenticity of the sender AP as a result of the mutual configuration data exchange in the bootstrapping phase. \n\nIn addition to the standard operation of encrypting and signing outgoing messages and decrypting and verifying incoming messages, ResFi APs enable to broadcast messages to N-hop neighbors by performing TTL based forwarding.\nUnicast messages which are in addition encrypted with the public RSA key of the corresponding receiver can only be sent within the one-hop neighbor group. If needed, multi hop unicast messaging with end-to-end encryption can be implemented on application level, cf. Sec. \\ref{sec:cluster}.\n\n\n\n\\subsection{Transient Group Encryption Key}\nDuring the standard mode of operation no specific control messages except the key change messages (KCM) have to be exchanged to enable the work of the distributed network. The object of the random periodic KCM and therefore of the group encryption key change is twofold, first it provides confidentiality on the wired backhaul channel and second it ensures that every group participant is a real physical neighbor located in wireless transmission range.\\\\ \nAll ResFi agents have the obligation to periodically change their group encryption key and inform the other group members by sending a KCM as broadcast via the wired backhaul channel. The key change interval is bounded to $\\text{KCMI}$ plus an randomly generated jitter. If a participating ResFi AP has not sent a KCM during $2 \\cdot \\text{KCMI}$ all other group members are removing the subscription to its publish socket.\n\n\n\n\n\nA KCM always includes the current radio channel and the SSID of the sender to allow the other group members to use a single active frequency scan to obtain the new group session encryption key.\n\nFor the KCM always the old group key is used, while all messages sent after the KCM are encrypted using the new group key.\nIn advance the new group key is set within the probe response and probe request ResFi IEs for all new probe response and probe request messages.\\\\ ResFi APs that receive a KCM perform a single frequency active scan for the given RF channel and the given SSID which results in the reception of the new group key as described in the bootstrapping section. For the single frequency scans during runtime a empty probe request is used to trigger the KCM sender to reply with a probe response including the new group session key\\footnote{small ResFi IE (IE header 6 octets + transient group encryption key and IV 32 octets)}. As ResFi relies on FIFO sockets and the scan procedure is blocking, all messages following the KCM, encrypted with the new group key, can always be decrypted successfully. Using the KCM scheme and single frequency / SSID scans performed by neighbor APs, the necessity of performing a new full active scan by the key changing AP is avoided. This prevents long deafness times due to active scanning on other RF channels.\n\n\\subsection{IP Address Change}\n\nIf the public IP address of a ResFi agent changes, the connectivity to all neighboring ResFi APs is broken. To overcome the connectivity loss, the affected ResFi agent repeats the bootstrap procedure described in Section \\ref{sec:boot}.\n\n\\subsection{Radio Channel Change}\nAs the wireless channel after the boot-up phase is only used to obtain the symmetric group encryption key updates whose retrieval is always triggered by a KCM, which always includes the currently used radio channel, radio channel changing does not interfere the standard mode of operation of ResFi.\n\n\n\n\\begin{table*}[t]\n\\caption{ResFi north-bound API description}\n\\centering\n\\footnotesize\n\\begin{tabular}{ | p{.35\\linewidth}p{.58\\linewidth} | }\n\\hline\n\\rowcolor{BgGray2} \\textbf{North-bound general framework API} & \\textbf{Description}\\\\\n\n\\textit{getNeighbors()} & returns list of current neighbor IDs.\\\\\n\n\\textit{sendToNeighbor(nodeID, json\\_msg)} & sends a JSON message to particular neighboring AP additionally encrypted using the public key of the receiver.\\\\\n\n\\textit{sendToNeighbors(json\\_msg, TTL)} & sends JSON broadcast message to each direct neighboring AP, if TTL is used, flooding to N-Hop neighbors is performed.\\\\\n\n\\textit{regCallbacks(rxCb. newLinkCb, linkFailureCb)} & register callback functions used to deliver data to application (rxCallback $\\rightarrow$ new message for application was received, newLinkCallback $\\rightarrow$ a new neighbor detected, linkFailureCallback $\\rightarrow$ neighbor was disconnected).\\\\\n\n\\textit{registerNewApplication(naming\\_pattern)} & To handle parallel ResFi applications, name space separation for message handling is used.\\\\\n\n\\textit{getResFiCredentials(param)} & if \\textit{param} == 1 returns public IP of RRMU, if \\textit{param} == 2 returns public RSA key\\\\\n\n\\textit{usePrivateRSAKey(data, mode)} & enables to utilize the private key of the RRMU. If \\textit{mode} == 1, returns signature computed over \\textit{data}, if mode == 2, function decrypts \\textit{data} and returns plaintext.\\\\\n\n\\rowcolor{BgGray2} \\textbf{North-bound RRM API (suggestion)} & \\textbf{Description}\\\\\n\n\\textit{getNetworkLoad(type)} & returns current network load: 1=number of served STAs, 2=total TX Bytes in DL, etc.\\\\\n\n\\textit{getChannels()} & returns available RF channels.\\\\\n\n\\textit{setChannel(chan)} & set (primary) RF channel to be used\\\\\n\n\\textit{setTxPower(mac\\_addr, dbm)} & set transmit power towards STA with mac\\_addr\\\\\n\n\\textit{setChannelWidth(mac\\_addr, value)} & set channel BW for transmission to STA mac\\_addr, e.g. 20, 40, 80, 160 MHz in 802.11ac\\\\\n\n\\textit{injectFrame(data)} & inject raw 802.11 frame\\\\\n\n\\textit{enableRTSCTS(mac\\_addr, bool)} & enable usage of RTS/CTS towards STA with mac\\_addr\\\\\n\n\\textit{startVAP(ssid, rxcb)} & start virtual AP with SSID, rxcb callback delivers received raw 802.11 frames.\\\\\n\\textit{deauthenticateSTA(mac)} & deauthenticate currently associated STA\\\\\n\\hline\n\\end{tabular}\n\\label{table:northboundapi}\n\\vspace{-10pt}\n\\end{table*}\n\n\n\n\\begin{table*}[t]\n\\caption{ResFi south-bound API description}\n\\centering\n\\footnotesize\n\\begin{tabular}{ | p{.35\\linewidth}p{.58\\linewidth} | }\n\\hline\n\\rowcolor{BgGray2} \\textbf{South-bound framework API} & \\textbf{Description}\\\\\n\n\\textit{getWiredInterface()} & enables ResFi to get the wired interface with IP access to backhaul Internet.\\\\\n\n\\textit{subscribeToProbeRequests()} & enables ResFi to retrieve the probe request payload from incoming probe requests.\\\\\n\n\\textit{addIEtoProbeResponses()} & enables ResFi to add/modify additional IE(s) to probe responses\\\\\n\n\\textit{performActiveScan()} & enables ResFi to start full/single active scan, takes add. IE which is added to probe req.\\\\\n\n\\rowcolor{BgGray2} \\textbf{South-bound RRM API (suggestion)} & \\textbf{Description}\\\\\n\n\\textit{\\{set$|$get\\}RfChannel()} & get/set currently used RF channel\\\\\n\n\\textit{\\{set$|$get\\}txPower(mac\\_addr)} & get/set transmission power to be used to STA mac\\_addr\\\\\n\n\\textit{\\{set$|$get\\}channelWidth(mac\\_addr)} & get/set channel bandwidth to be used towards STA mac\\_addr\\\\\n\n\\textit{\\{set$|$get\\}ClientInfo()} & get information about associated STAs (e.g. MAC, capabilities, RSSI, RX/TX count, rate statistics) or modify settings (e.g. set fixed rate, disconnect, priority, RTS/CTS usage, disassociate STA, associate STA, blacklist/whitelist STA)\\\\\n\n\n\n\\textit{\\{getRx$|$getTx\\}Stats(mac\\_addr)} & get information about sent/received packets and bytes towards STA mac\\_addr\\\\\n\n\\textit{injectRawFrame(data)} & inject raw 802.11 frame into wireless interface\\\\\n\n\\textit{startVAP(ssid, buffer)} & start new virtual AP with given SSID, all incoming data is saved in buffer.\\\\\n\n\n\\hline\n\\end{tabular}\n\\label{table:southboundapi}\n\\vspace{-10pt}\n\\end{table*}\n\n\n\\section{North-bound API}\\label{sec:northboundapi}\n\nThe northbound algorithm/application API provided by ResFi is shown in Table~\\ref{table:northboundapi}. The API is quite simple. Using the API any application is able to disseminate JSON messages to either APs in direct wireless communication range or to perform a general N-Hop TTL based flooding operation. Furthermore, unicast communication to direct peers is also available. If a new message via the framework is received the message processing can be controlled by registering a callback. ResFi determines the wireless context transparently for the user. \n\n\n\n\n\\section{South-bound API}\nThe ResFi framework can be easily integrated in existing AP solutions by connecting the existing platform to the ResFi southbound framework API listed in Table~\\ref{table:southboundapi}. While the framework south-bound API is mandatory, the southbound API for the RRM is only a suggestion and can be extended to meet further application or algorithm needs. For this reason Table~\\ref{table:southboundapi} only provides a subset of possible functions, in particular the RRM related part of the northbound API shows the required functions needed for the example applications in Section~\\ref{sec:resfi_applications}.\\\\ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\chapter{ResFi -- Implementation Details}\\label{sec:bigap_implementation}\n\nThe ResFi implementation consists of the three components shown in Fig. \\ref{fig:imp}. The ResFi framework agent is connected via the framework southbound API to a modified version of the software AP implementation \\textit{Hostapd} \\cite{hostapd-2013} via the also modified interface \\textit{Hostapd\\_CLI} which enables the embedding of additional IE(s) within probe responses, and the \\textit{IW tool} which is used as an interface to trigger a new WiFi scan and to retrieve its results. Further the retrieval of the probe request payloads is realized using inter process communication (IPC) between hostapd and the ResFi agent. For our prototype we utilized standard x86 machines running Ubuntu 14.04 LTS. As the ResFi agent is programmed using platform independent Python code, it can be easily ported to various platforms. As the southbound API prototype realization is Linux specific it can be easily installed on all Linux based systems e.g. OpenWRT based APs or mobile AP solutions like Android smart-phones in tethering mode. \nThe following sections describe the single prototype parts in more detail.\n\n\\begin{figure}\n\\centering\n\\begin{minipage}[h!]{0.75\\linewidth}\n\t\\begin{center}\n\t\t\t\\includegraphics[width=0.6\\linewidth]{implementation}\n\t\\end{center}\n\t \\vspace{-15pt}\n\t\\caption{Overview of components in the ResFi prototype.}\n\t\\label{fig:imp}\n\\end{minipage}\n\\vspace{-10pt}\n\\end{figure}\n\n\\section{ResFi Agent}\n\nThe ResFi Agent is implemented in Python and runs in user-space. The publish/subscribe (Pub/Sub) sockets for the back-haul wired overlay network are implemented using the Python \\textit{\\O{}MQ} library \\cite{zeromq-2014}. On top of \\O{}MQ the \\textit{JavaScript Object Notation (JSON)} is used to serialize the data. Detection of IP address changes is implemented via a Netlink event callback. To provide authenticity, integrity and unicast confidentiality, 1024 bit \\textit{RSA} key pairs are used and for group communication confidentiality, symmetric session encryption is performed using the \\textit{Advanced Encryption Standard (AES)} in \\textit{Cipher Feedback Mode (CFB)} with 128 bit key size. All security related functionality has been implemented by utilizing the \\textit{PyCrypto Library} \\cite{pycrypto-2015} and can be easily adapted to the needed purpose (e.g. different key-size, cipher mode or algorithm).\n\n\\section{Hostapd and Hostapd\\_CLI}\n\nHostapd is responsible for performing all the AP management functionality on Linux based platforms. This includes the handling of probe requests and sending the probe responses. We modified hostapd in version 2.1 and the runtime interface hostapd\\_cli to enable first, the embedding of additional IE(s) to all probe responses and second, the retrieval of the IE(s) from all received probe requests. Besides also the retrieval of the current AP parameters is enabled. The ResFi Agent calls hostapd\\_cli to embed the public IP and the security keys into the probe response frames and to read the AP parameters. The probe request payload is retrieved using an additional \\O{}MQ Pub/Sub socket to allow IPC between hostapd and the ResFi agent. The UML state diagram in Fig. \\ref{fig:fsm_1} describes this inter-working in more detail.\n\n\\section{IW Tool}\\label{sec:iw}\nThe Linux wireless WiFi configuration utility (IW) tool \\cite{iw-2015} can be used to configure the WiFi driver in kernel-space from user-space. IW internally uses Netlink communication and the nl80211 library to enable user-space / kernel-space communication. We utilized the IW tool in version 4.3. The ResFi Agent calls IW to start and retrieve the results of a active WiFi scan on a single or over multiple channels and for a specific or unspecific SSID. Moreover, the IW tool is used to embed the additional ResFi IE(s) within the probe request messages used during the boot process.\n\n\n\n\n\n\\begin{figure}\n\\centering\n\\begin{minipage}[h!]{1\\linewidth}\n\t\\begin{center}\n\t\t\t\\includegraphics[width=0.95\\linewidth]{fsm_1c}\n\t\\end{center}\n\t \\vspace{-15pt}\n\t\\caption{UML state machines describing the behaviour of the ResFi agent.}\n\t\\label{fig:fsm_1}\n\\end{minipage}\n\\vspace{-10pt}\n\\end{figure}\n\n\\chapter{ResFi Mininet Emulation}\n\nIn order to offer the application developer an easy way to test own RRM algorithms, before deploying them in a real testbed, the ResFi framework allows the emulation of typical residential networks taking both the wireless access as well as the wired backbone network into account. This is achieved by running ResFi in Mininet~\\cite{mininetUrl}, a container-based emulation which is able to emulate large network topologies on a single computer. Specifically, we emulate the wired Internet backhaul using the reported last-mile latencies and throughput values from~\\cite{sundaresan2011broadband}. Moreover, the wireless channel which is used by ResFi for exchanging wireless management frames is also emulated. This is achieved using the following model: all APs in mutual wireless reception range are connected via a bidirectional link with fixed bandwidth (6 Mbps in case of 802.11g/a), delay (depending on distance) and loss characteristics (configurable parameter) to the same switch. Finally, the AP density which defines the wireless topology is a configurable parameter.\n\nNote, any application code which was tested in the emulation environment can be used afterwards to be deployed on real hardware without any modifications. The ResFi Mininet Emulation is part of the ResFi framework which is provided as open-source under \\url{https://github.com/resfi}.\n\n\n\n\\chapter{ResFi Application Examples}\\label{sec:resfi_applications}\n\nNext we present examples for applications supported by ResFi as a showcase.\n\n\\section{Network Clustering}\\label{sec:cluster}\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn order to reduce the information update overhead and to optimize the use of the network bandwidth obtaining a hierarchical organization of the residential AP network is desired. This can be achived by clustering algorithms that partition the AP nodes of network into clusters~\\cite{basagni1999distributed}. A clustering is crucial for controlling the spatial reuse of the shared wireless channel (e.g., in terms of time division or frequency division schemes).\n\nAs a proof of concept we implemented both the Distributed Clustering Algorithm (DCA) and the Distributed Mobility-Adaptive Clustering (DMAC) proposed by Basagni~\\cite{basagni1999distributed}\nas applications in ResFi.\n\\section{End-to-End Security for N-Hop Neighbors}\\label{sec:end-to-end-sec}\nBasically, ResFi provides one-hop encryption by utilizing a group encryption key between all one-hop neighbors. In addition unicast messages to one-hop neighbors are encrypted using the public key of the receiver. For N-hop messages, all intermediate hops decrypt the forwarding message locally with the last hop group encryption key and forward it encrypted with their own group encryption key. If end-to-end security is needed between N-hop neighbors, this functionality can be easily implemented as ResFi application. E.g. to enable encrypted communication in a established cluster, cf. Sec. \\ref{sec:cluster}, the cluster head can utilize the \\textit{getResFiCredentials()} function to obtain its public key and propagate it to all cluster nodes and vice versa. As now all participants know the public key of each other end-to-end signing and en/decrypting of messages is possible using the function \\textit{usePrivateRSAkey()}, see Table~\\ref{table:northboundapi}.\n\n\n\n\n\n\n\n\\section{Dynamic Channel Selection}\n\\label{sec:chansec}\n\n\nThe ResFi framework allows an easy implementation of distributed dynamic channel selection schemes for WiFi APs. According to the approach proposed by Mishra et al.~\\cite{mishra2005weighted} each AP may periodically inform its direct neighbor APs about its network load (e.g., number of served clients or flows), recent airtime utilization on different channels, the presence of WiFi and non-WiFi networks and its own radio channel. Such information can be combined at each AP to select the least congested channel. As a proof-of-concept we implemented the aforementioned algorithm (Lst.~\\ref{dist_chan_algo}).\n\n\\lstset{language=Python, \n        basicstyle=\\ttfamily\\scriptsize, \n        keywordstyle=\\color{deepblue},\n        commentstyle=\\color{comments},\n        stringstyle=\\color{deepgreen},\n\t\t\t\temphstyle=\\ttb\\color{deepred},    \n        showstringspaces=false,\n        \n        procnamekeys={def,class}}\n \n\\begin{lstlisting}[caption=Distributed channel assignment implemented using ResFi., label=dist_chan_algo]\ndef channelSelection():\n  agent = ResFiAgent() # init ResFi agent\n  agent.regCallbacks(rx_cb, Null, Null)\n  agent.registerNewApplication(de.tu-berlin.ch-assign)\n  apNode = agent.getResFiCredentials(1) # get node ID (IP)\n  channel = 0 # init with channel 0\n  load = getNetworkLoad() # get network load\n  chs = getChannels() # number of radio channels available\n  nbInfo = {} # neighbor info\n\n  while True:\n    msg = {'node': apNode, 'ch': channel, 'load': load}\n    agent.sendToNeighbors(msg) # API call\n    time.sleep(random.uniform(0, jitter/2)) # backoff\n\ndef rx_cb(json_msg): # receive callback function\n  sender = json_msg['node'], nb_channel = json_msg['ch']\n  nb_load = json_msg['load']\n  nbInfo[sender] = {'load': nb_load, 'ch': nb_channel}\n\n  # calc Hc according to Hminmax algorithm:\n  Hc = {}\n  for c in range(chs): # for each channel\n    Hc[c] = 0 # reset to zero\n    for entry in nbInfo: # for each neighbor\n      tmpCh = nbInfo[entry]['ch']\n      if tmpCh == c: # same channel\n        # select the max() weight; here load\n        Hc[c] = max(Hc[c], load + nbInfo[entry]['load'])\n\n  # choose channel with minimum Hc\n  channel = getChannelWithMinConflictWeight(Hc)\n  agent.setChannel(channel)\n\\end{lstlisting}\n\n\n\n\n\n\n\n\n\n\n\\section{Interference Management}\nThe well-known hidden terminal problem~\\cite{shrivastava2009centaur} causes severe co-channel interference (and thus packet loss) in dense WiFi networks with multiple APs operating on the same radio channel. While the use of virtual channel reservation has a potential to reduce the number of hidden nodes it creates significant overhead by exchange of IEEE 802.11 RTS/CTS packets. Therefore, an adaptive RTS/CTS scheme activated only on wirleess links suffering from hidden terminal problem would be favorable. This can be easily achieved using our ResFi platform. For this purpose each AP could perform passive hidden terminal detection as proposed in~\\cite{li2006passive} and inform its neighboring APs about links potentially affected by hidden terminals for which the RTC/CTS handshake would be enabled, see function \\textit{enableRTSCTS()} in Table~\\ref{table:northboundapi}.\n\n\n\n\n\n\\section{Virtual Access Points (VAP)}\\label{sec:vap}\n\nThe spatial area covered by a single WiFi AP is limited especially when using the 5\\,GHz ISM band with unfavorable propagation characteristics. In dense residential areas there is a high probability that a significant parts of a residential apartment is in excellent coverage of neighbor's AP rather than within the range of its own home AP~\\cite{Shi-2015}. A way to utilize the neighboring AP is to deploy on-demand a virtual AP on the neighboring AP and to tunnel all encrypted WiFi traffic to the home AP~\\cite{vestin2013cloudmac}. This allows the client devices to always authenticate against the home AP using the WPA passphrase already stored in the device. There is no registration process; no software to install on the device; not even any settings to change.\n\nThe on-demand deployment of VAPs can be easily achieved using the ResFi framework. Specifically, each AP has to disseminate information about the configured SSIDs in its home AP to the neighboring AP where dynamically a VAP is configured, see function \\textit{startVAP()} in Table~\\ref{table:northboundapi}.\n\n\n\\section{Client STA Handover for Load Balancing and Mobility Support}\nThe BIGAP approach~\\cite{Zubow15bigap_seamless_handover} which enables soft handover operations in centralized enterprise WiFi networks, can also be implemented as ResFi application. If combined with the VAP application (cf. Sec.~\\ref{sec:vap}), soft handover between the home AP and the neighboring AP to enable mobility and load-balancing support without network outage, can be realized. If the client STA supports dynamic frequency selection (DFS) and both, the current AP and the target AP are operating on different RF channels, soft handover operations are possible by injecting an additional beacon frame including a channel switch announcement IE with the RF channel of the target AP via the function \\textit{injectFrame()} executed on the current AP. If no DFS support on the client STA is available, hard-handover using the function \\textit{deauthenticateSTA()} on current AP enables a controlled handover. All aforementioned functions are part of ResFi's NB API, see Table~\\ref{table:northboundapi}.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\chapter{Evaluation}\\label{sec:evaluation}\n\nOur proposed framework is analyzed and evaluated by means of experiments in a WiFi testbed. Moreover, the expected control overhead in the wireless channel is analyzed analytically. \nAn overview in which the overhead generated by the ResFi framework in its different mode of operation caused by channel switching and sending messages either via the wired backhaul or via the wireless channel is given in Table \\ref{table:overhead}.\nThe evaluation results of our proposed ResFi approach are further compared with the approach proposed by Manweiler~\\cite{manweiler-2012} extended to multi-channel environments to which refer as RxIP++.\n\n\n\n\n\n\n\\section{Active vs. passive Scanning}\\label{sec:scan}\nAs described in Section \\ref{sec:resfi_arch}, ResFi uses different modes of scanning depending on its operation state. In the boot-up phase in which the deafness of the AP is not as important as during the standard mode of operation, a full scan is used. After the boot-up is completed, a single frequency scan for a single SSID is utilized to keep the AP deafness as short as possible. To enable the analysis of the overhead of this approach we measured the timing of different active and passive scanning procedures (cf. Sec. \\ref{sec:dot11primer}) using diverse WiFi hardware. The results of this experiment are later used in Sec.~\\ref{sec:reclat} to calculate the overhead due to our frequent symmetric group encryption key change via the wireless channel.\n\\subsection{Methodology}\nIn this experiment we used different commercial off-the-shelf (COTS) WiFi hardware two connected via PCI and two connected via USB. The utilized WiFi chips are listed in Fig.~\\ref{fig:eval_scanning_times_full} and~\\ref{fig:eval_scanning_times_single}. The experiments were executed on x86 machines with Ubuntu 14.04 LTS. The scanning calls were started using the command-line tool iw (cf. Sec. \\ref{sec:iw}).\n\n\n\n\n\n\n\n\\subsection{Results}\nThe timing results of full WiFi scans are shown in Fig.~\\ref{fig:eval_scanning_times_full}. We see that independent of the scanning mode, the scanning durations strongly vary between different WiFi chips and connection technology. in general, chipsets connected via PCI show shorter scanning durations while USB connected chips are slower. However, when the two different scanning modes (passive or active) are evaluated it is obvious that active scanning is always superior to passive scanning w.r.t. to the scanning latency.\n\nThe results of the latency experiment of single frequency scans is depicted in Fig.~\\ref{fig:eval_scanning_times_single}, interestingly the connection type whether USB or PCI does not effect the scanning latency. Nevertheless, for single frequency scans active scanning is also always faster than passive scanning.\n\n\\textbf{Takeaways:} Single frequency scans always provide the shortest latency in comparison to full scans (e.g. 30ms vs. 6300ms for AR9170). Active scanning is always faster than passive scanning.\n \n\\begin{figure}\n \\centering\n \\begin{minipage}[b]{1\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.7\\linewidth]{eval_scanning_times_full} \n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Scanning duration of a full scan (performed over all available WiFi channels, errorbar shows the standard deviation).}\n    \\label{fig:eval_scanning_times_full}\n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\n\n \\begin{figure}\n \\centering\n \\begin{minipage}[b]{1\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.7\\linewidth]{eval_scanning_times} \n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Scanning duration on single channel (errorbar shows the standard deviation).}\n    \\label{fig:eval_scanning_times_single}\n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\n\n\n\n\n\\section{Reconfiguration Overhead}\\label{sec:reclat}\nIn the following we are analyzing the overhead in the wireless channel due to frequently changing the transient symmetric group encryption key.\n\n\\subsection{Methodology}\n\nThe overhead in the wireless channel is due to the transmission of probe request and reply packets which are sent on a basic bitrate (e.g. 6\\,Mbps in 802.11a/g). Moreover, during a scanning operation for neighboring nodes the AP is deaf and cannot handle data transmissions of its associated client stations and hence is wasting valuable airtime. Moreover, an associated station may disassociate if it misses too many beacon frames.\nAs shown in Section \\ref{sec:scan}, the duration of a single active WiFi scan for a given SSID on a particular radio channel takes depending on the hardware between $30\\,$ms and $100\\,$ms.    \n\nHence, there is a tradeoff between the rate at which the reconfiguration takes place and the available airtime in the wireless channel for data communication.\n\nBecause in ResFi a reconfiguration at a single AP triggers the scanning operation of each neighboring AP the expected AP density plays a major role. For our analysis we analyzed the data provided bv the large-scale measurement campaign of Biswas et al.~\\cite{biswas2015large, merakii-2015} whereas the number of neighboring APs in the 2.4 and 5\\,GHz band is on average 16.8 and 5.1 respectively. To pay attention to virtual WiFi networks in which one physical AP broadcasts multiple SSID and BSSIDs, we only included BSSIDs into the results in which the RSSI, the OUI and the WiFi capabilities are different. Note, the overhead in 2.4\\,Ghz is also larger because the management frames (here probe requests and replies) are sent on a lower PHY bitrate, i.e. 1 vs. 6\\,Mbps.\n\n\n\n\n\n\\begin{table*}[t]\n\\caption{Overhead analysis.}\n\\centering\n\\footnotesize\n\\begin{tabular}{ |p{.11\\linewidth}p{.17\\linewidth}p{.30\\linewidth}p{.30\\linewidth}| }\n\\hline\n\\rowcolor{BgGray2} \\multicolumn{2}{|c}{\\textbf{Operation}} & \\multicolumn{1}{c}{Radio (IEEE 802.11)} & \\multicolumn{1}{c|}{Backhaul}\\\\\n\\hline\n\\multirow{6}{*}{Standard mode} & \\multirow{2}{*}{\\parbox{2.8cm}{change own group key}}& \\multirow{2}{*}{\\parbox{4.4cm}{for-each neighboring AP: send probe response + small ResFi IE}} & \\multirow{2}{*}{\\parbox{4.4cm}{for-each neighboring AP: send Key Change Message (KCM)}} \\\\\n & & & \\\\\n \n & \\multirow{2}{*}{rec. KCM}& \\multirow{2}{*}{\\parbox{4.4cm}{channel switch \\& send probe req. (no ResFi IE)}} & \\multirow{2}{*}{\\parbox{4.4cm}{zero}} \\\\\n & & & \\\\ \n \n  & \\multirow{2}{*}{\\parbox{2.8cm}{rec. probe req. + big ResFi IE}}& \\multirow{2}{*}{send probe response + big ResFi IE} & \\multirow{2}{*}{\\parbox{5.4cm}{zero}} \\\\\n  & & & \\\\\n  \n & \\multirow{2}{*}{\\parbox{2.8cm}{rec. probe req. (no ResFi IE)}}& \\multirow{2}{*}{send probe response + small ResFi IE} & \\multirow{2}{*}{\\parbox{5.4cm}{zero}} \\\\\n    & & & \\\\\n \n \\hline\n \n \n\\multirow{2}{*}{Bootstrapping} & & for-each available Rf channel: channel switch \\& send probe request + big ResFi IE & \\multirow{3}{*}{\\parbox{6cm}{zero}} \\\\\n \\hline\n\\end{tabular}\n\\label{table:overhead}\n\\vspace{-10pt}\n\\end{table*}\n\nNext, we give a detailed description of the overhead analysis for both the beacon stuffing approach used in RxIP++ which serves as baseline and the ResFi approach using probe request and reply management frames.\n\n\\subsubsection{RxIP++}\n\nWhen using the approach from RxIP for dissemination of configuration data the overhead is due to the transmission of additional IEs in the beacon frames and the required scanning overhead in multi-channel environments. The overhead depends on the AP density as each AP performs a reconfiguration, i.e. the larger it is the more wireless frames need to be exchanged and more scanning operations need to be performed. For a network of $N$ co-located, i.e. in communication range, APs the relative overhead for each AP can be computed as follows:\n\n", "index": 1, "text": "\\begin{align}\\label{eq:beacon_eq}\nO_{\\mathrm{RxIP++}} &= \\frac{1}{C} \\times N \\times T_{\\mathrm{Beacon-IE}} \\times R_{\\mathrm{Beacon}} + (N-1) T_{\\mathrm{scan}}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle O_{\\mathrm{RxIP++}}\" display=\"inline\"><msub><mi>O</mi><mrow><mrow><mi>RxIP</mi><mo>+</mo></mrow><mo>\u2063</mo><mo>+</mo></mrow></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\frac{1}{C}\\times N\\times T_{\\mathrm{Beacon-IE}}\\times R_{%&#10;\\mathrm{Beacon}}+(N-1)T_{\\mathrm{scan}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><mi>C</mi></mfrac></mstyle><mo>\u00d7</mo><mi>N</mi><mo>\u00d7</mo><msub><mi>T</mi><mrow><mi>Beacon</mi><mo>-</mo><mi>IE</mi></mrow></msub><mo>\u00d7</mo><msub><mi>R</mi><mi>Beacon</mi></msub></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>T</mi><mi>scan</mi></msub></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.00517.tex", "nexttext": "\n\\noindent where the first and third term represent the overhead due to transmission of probe request and reply messages and the second term accounts for deafness due to scanning procedure.\n\n\\subsection{Results}\n\n \\begin{figure}\n \\centering\n \\begin{minipage}[b]{0.85\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.9\\linewidth]{overhead_analytical}\n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Impact of periodic group encryption key change ($\\Delta=60\\,s$) on the available airtime in the data channel.}\n    \\label{fig:overhead_analytical}\n        \n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\nUsing equations \\ref{eq:beacon_eq} and \\ref{eq:proposed_eq} we are able to calculate the overhead for different AP densities, i.e. number of neighboring APs. Here we assume that each AP performs a single group encryption key update. Fig.~\\ref{fig:overhead_analytical} shows the relative available airtime in the wireless data channel with a update interval of 60s, i.e. $1-O_{\\mathrm{proposed}}$ and $1-O_{\\mathrm{Beacon}}$ respectively.\n\nThe results can be summarized as follows. In the 2.4 Ghz and the 5 Ghz band the overhead for a single reconfiguration is highest with RxIP++, whereas using the proposed ResFi approach which relies on probe request and probe response frames is superior in both bands for a reconfiguration period of $60\\,$s and AP densities between 0 and 40.\n\n \\begin{figure}\n \\centering\n \\begin{minipage}[b]{0.8\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.95\\linewidth]{key_change_rate} \n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Tradeoff between encryption key change interval and available airtime in the data channel ($N$ represents the number of neighbors each AP has).}\n    \\label{fig:key_change_rate}\n        \n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\nNext, we analyze the impact of the reconfiguration rate on the available airtime in the wireless data channel. The results are shown in Fig.~\\ref{fig:key_change_rate}. From a practical point of view a maximum overhead of 1\\% is tolerable. Hence the maximum reconfiguration rate is pretty low, i.e. update every 60 and 20\\,s for the 2.4 and the 5\\,GHz band respectively. However, for the envisioned residential AP szenario it is still sufficient as we suggest to change the group encryption key every minute. Again the proposed ResFi approach is superior in both bands. \n\n\n\n\n\n\\textbf{Takeaways:} There is a clear tradeoff between reconfiguration rate and overhead in the wireless channel. The beacon-stuffing approach (RxIP++) is not feasible in real residential deployments with high AP densities.\n\n\\section{Reconfiguration Latency}\n\n\\subsection{Methodology}\n\nIn this experiment we analyze reconfiguration latency in ResFi due to changing configuration data, e.g. group encryption session key. The reconfiguration latency is composed of the delay due to transmission of the key change message (KCM) over the wired out-of-band control channel as well as the scanning delay due to active scanning on a particular channel and given SSID.\n\nWe considered two different wired backhaul technologies. First, Gigabit Ethernet as a very low latency backhaul which we use in our testbed. It serves as a baseline. Second, the typically used backhaul technology in residential WiFi deployment, i.e. cable/DSL. For the latter we used the traffic control tool~\\cite{tcUrl} to emulate the last-mile latency in residential WiFi deployments as reported by~\\cite{sundaresan2011broadband}. Note, the last-mile latency is the latency to the first hop inside the ISP\u00e2\u0080\u0099s network and hence captures the latency of the access link (DSL/cable). According to~\\cite{sundaresan2011broadband} most users of cable ISPs are in the 0\u00e2\u0080\u009310 ms interval whereas a significant proportion of DSL users have last-mile latencies of more than 20 ms, with some users seeing last-mile latencies up to 60 ms.\n\nFor the experiments we used x86 machines with Ubuntu 14.04 LTS and Linksys AE1000 WiFi USB sticks using Ralink rt2800 chipsets as APs.\n\n\\subsection{Results}\\label{sec-scanning}\n\nThe results are shown in Fig.~\\ref{fig:reconfig_latency}. We see that in the worst case, i.e. DSL, the reconfiguration latency is around 165\\,ms which is 58\\,\\% higher as compared to Gigabit LAN. \n\n \\begin{figure}\n \\centering\n \\begin{minipage}[b]{0.8\\linewidth}\n    \\begin{center}\n        \\includegraphics[width=0.8\\linewidth]{reconfig_latency} \n    \\end{center}\n     \\vspace{-15pt}\n    \\caption{Reconfiguration latency due to changing encryption key (Confidence $\\geq95\\%$).}\n    \\label{fig:reconfig_latency}\n \\end{minipage}\n \\vspace{-10pt}\n \\end{figure}\n\n\\textbf{Takeaways:} Due to the reconfiguration latency configuration data like the used group encryption session key exchanged on the wireless channel can be changed at most $6 \\times$ per second when assuming the scenario with worst-case DSL backhaul access. This is more than sufficient to achieve a high level of security.\n\n\n\n\\chapter{Conclusions and Areas for further research}\\label{sec:conclusions}\n\n\n\n\n\nUp to our knowledge we have presented the first proposal of a holistic platform supporting automatic establishment of secure connectivity within a definable scope of neighborhood and set of resource management supporting functions for residential WiFi networks. Our proposal allows usage of legacy hardware and avoids violation of the existing management borders following out of the fragmented ownership structure. ResFi was prototypically implemented and the source code is provided to the community as open source. We believe that there is a clear need for such a solution. \n\nOn our side the following further areas of work on this framework have been already identified:\n\\begin{enumerate}\n\\item Many RRM require rather tight time synchronization among the nodes. So far ResFi relies on Network Time Protocol (NTP~\\cite{mills2010network}) to time synchronize over the Internet backhaul which achieves only an accuracy of 10s of ms in WAN networks. We intend to extend ResFi to provide over-the-air time synchronization using either 802.11 beacons~\\cite{manweiler-2012} or using 802.11 management frames for exchanging IEEE 1588 Precision Time Protocol (PTP) frames~\\cite{lee2005ieee}.\n\n\\item The semantics of the network load - a notion introduced in our API - is not unique. Different function of the air time utilization, number of neighbors etc. have been used in the past in this context. \nWhile in the actual version we consider the air time utilization on the actually used channel as the metric of the network load, we consider offering a possibility to introduce in a flexible way a definition of this parameter. \n\n\\item The notion of one-hop neighborhood is not unique, either. At this moment we include in the one-hop neighborhood any AP which provides a decodable probe response to a probe request broadcasted with the lowest bit rate. This notion might be generalized by attributing to the probe exchange some constraints on power with which this exchange is performed.  \n \n\\end{enumerate}\n\nWhile we believe to have covered a reasonable set of requirements while keeping the solution relatively simple, we have so far verified its merits only using a few very simple case studied. We hope that usage of this framework (enhanced by the open source approach) for more complex RRM functions might lead to its further improvement.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\bibliography{biblio}\n\n", "itemtype": "equation", "pos": 56560, "prevtext": "\n\\noindent where $C$ is the total number of channels available, $N$ is the number of neighboring APs, $T_{\\mathrm{Beacon-IE}}$  and $R_{\\mathrm{Beacon}}$ are the additional beacon overhead and beacon interval (10\\,Hz) respectively. The first term represents the overhead due to the additional transmission of IE in beacon frames. Note, that due to multi-channel environment the APs are operating on different radio channels, hence to get the per channel overhead we have to divide by the number of channels. The second term represents the overhead due to scanning deafness.\n\n\\subsubsection{ResFi}\n\nNext, we analyze the overhead of the ResFi approach:\n\n", "index": 3, "text": "\\begin{align}\\label{eq:proposed_eq}\nO_{\\mathrm{ResFi}} &= (N-1) (T_{\\mathrm{PReq}} + T_{\\mathrm{PRep}}) + (N-1) T_{\\mathrm{scan}} \\nonumber \\\\\n& + \\frac{1}{C} \\times (N-1) \\times (N-2) \\times (T_{\\mathrm{PReq}} + T_{\\mathrm{PRep}})\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle O_{\\mathrm{ResFi}}\" display=\"inline\"><msub><mi>O</mi><mi>ResFi</mi></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(N-1)(T_{\\mathrm{PReq}}+T_{\\mathrm{PRep}})+(N-1)T_{\\mathrm{scan}}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>T</mi><mi>PReq</mi></msub><mo>+</mo><msub><mi>T</mi><mi>PRep</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>T</mi><mi>scan</mi></msub></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+\\frac{1}{C}\\times(N-1)\\times(N-2)\\times(T_{\\mathrm{PReq}}+T_{%&#10;\\mathrm{PRep}})\" display=\"inline\"><mrow><mo>+</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mn>1</mn><mi>C</mi></mfrac></mstyle><mo>\u00d7</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>N</mi><mo>-</mo><mn>2</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u00d7</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>T</mi><mi>PReq</mi></msub><mo>+</mo><msub><mi>T</mi><mi>PRep</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}]