[{"file": "1601.03240.tex", "nexttext": "\n As a first simplification step, we bring \n disjunction to the outermost level in $\\phi$:\n \n", "itemtype": "equation", "pos": 37676, "prevtext": "\n\n\n\n\n\n\n\n\\title{\nCounting Answers to\nExistential Positive Queries:\\\\\nA Complexity Classification\n}\n\n\n\n\n\n\n\n\n\n\n\n\n{{{ \\author{ Hubie Chen\\\\Universidad del Pa\\'{i}s Vasco, E-20018 San Sebasti\\'{a}n, Spain\\\\ \\emph{and} IKERBASQUE, Basque Foundation for Science, E-48011 Bilbao, Spain  \\and Stefan Mengel\\\\CNRS, CRIL UMR 8188, France }}}}\\confversion{{ \\author{ \\IEEEauthorblockN{Hubie Chen} \\IEEEauthorblockA{Departamento LSI,  Universidad del Pa\\'{i}s Vasco\\\\ \\emph{and} IKERBASQUE, Basque Foundation for Science\\\\ E-20018 San Sebasti\\'{a}n, Spain } \\and \\IEEEauthorblockN{Stefan Mengel} \\IEEEauthorblockA{ LIX UMR 7161\\\\ \\'{E}cole Polytechnique\\\\ Universit\\'{e} Paris Saclay, France} } }}\n\n\n\n\n\n\n\n\n\n\\date{ }\n\n\\maketitle\n\n\n\n\\begin{abstract}\n\nExistential positive formulas form a fragment of first-order logic that\nincludes and is \nsemantically\nequivalent to unions of conjunctive queries, one of the most important and well-studied classes of queries in database theory.\nWe consider the complexity of counting the number of answers to \nexistential positive formulas on finite structures and give a \ntrichotomy theorem on query classes, in the setting of bounded arity. \nThis theorem generalizes and unifies\n several known results on the complexity of conjunctive queries and unions of conjunctive queries. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\end{abstract}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\confversion{\\IEEEpeerreviewmaketitle}\n\n\n\n\n\\newtheorem{theorem}{Theorem}[section]\n\\newtheorem{conjecture}[theorem]{Conjecture}\n\\newtheorem{corollary}[theorem]{Corollary}\n\n\\newtheorem{examples}[theorem]{Examples}\n\\newtheorem{proposition}[theorem]{Proposition}\n\\newtheorem{prop}[theorem]{Proposition}\n\\newtheorem{lemma}[theorem]{Lemma}\n\\newtheorem{definition}[theorem]{Definition}\n\\newtheorem{observation}[theorem]{Observation}\n\n\\newtheorem{remark}[theorem]{Remark}\n\n\\newtheorem{examplecore}[theorem]{Example}\n\n\\newenvironment{example}\n  {\\begin{examplecore}\\rm}\n  {\\hfill $\\Box$\\end{examplecore}}\n\n\n  \n  \n\n\n\n\n\n\n\n\n\n\n\\newenvironment{proof}{\\noindent\\textbf{Proof\\/}.}{\\hfill$\\Box$\\medskip}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Introduction}\n\n\\subsection{Background}\nThe computational problem of evaluating a formula (of some logic)\non a finite relational structure is of central interest in \ndatabase theory and logic.\nIn the context of database theory, this problem is\noften referred to as \\emph{query evaluation}, as\nit models the posing of a query to a database, in a well-acknowledged way: \nthe formula is the query,\nand the structure represents the database.\nWe will refer to the results of such an evaluation as\n\\emph{answers}; \nlogically, these are the satisfying assignments of the formula on the structure.\nThe particular case of this problem where the formula is a sentence \nis often referred to as \\emph{model checking},\nand even in just the case of first-order sentences,\ncan capture a variety of well-known decision problems\nfrom all throughout computer science~\\cite{FlumGrohe06-parameterizedcomplexity}.\n\nIn this article, we study the counting version of\nthis problem, namely, given a formula and a structure,\noutput the \\emph{number} of answers\n(see for example~\\cite{PichlerSkritek11-counting,GrecoScarcello14-counting,DurandMengel13-structuralcounting,ChenMengel14-pp-arxiv} for previous studies).\nThis problem \nof \\emph{counting query answers}\ngeneralizes model checking, which can be viewed as the \nparticular case thereof where one is given a sentence and structure,\nand wants to decide if the number of answers is $1$ or $0$, \ncorresponding to whether or not the empty assignment is satisfying.\n\n\nIn addition to the counting problem's basic and fundamental interest, \nit can be pointed out that all practical query languages\nsupported by database management systems have\na counting operator.\nIndeed, it has been argued that database queries with counting\nare at the basis of decision support systems \nthat handle large data volume~\\cite{GrecoScarcello14-counting}.\n\n\n\nAs has been previously articulated,\na typical situation in the database setting is the evaluation of a relatively short formula on a relatively large structure.  Consequently, it has been argued that, in measuring the time complexity of query evaluation tasks, one could reasonably allow a slow (non-polynomial-time) preprocessing of the formula, so long as the desired evaluation can be performed in polynomial time following the preprocessing~\\cite{PapadimitriouYannakakis99-database,FlumGrohe06-parameterizedcomplexity}.\nRelaxing polynomial-time computation to allow arbitrary preprocessing of a \\emph{parameter} of a problem instance yields, in essence, the notion of \\emph{fixed-parameter tractability}.\nThis notion of tractability is at the core of \\emph{parameterized complexity theory}, which provides a taxonomy for classifying problems where each instance has an associated parameter.  We utilize this paradigm in this article; here, the formula is the parameter.\n\n\n\n\\subsection{Contribution}\n\n\\emph{Existential positive queries}\nare the first-order formulas built from\nthe two binary connectives ($\\wedge, \\vee$)\nand existential quantification.  \nThey include and are semantically equivalent to so-called\n\\emph{unions of conjunctive queries}, also known as\n\\emph{select-project-join-union queries},\nwhich have been argued to be the most \ncommon database queries~\\cite{AbiteboulHullVianu95-foundationsdatabases}.\nIndeed, each union of conjunctive queries \ncan be viewed as\nan existential positive query having a particular form, namely,\na disjunction of primitive positive formulas;\nrecall that a \\emph{primitive positive} query is an existential positive\nquery that does not use disjunction.\n\n\n\nWe study the problem of counting query answers\non existential positive queries.\nAn established way to understand which types of queries are \ncomputationally well-behaved and exhibit desirable,\ntractable behavior is to consider this problem relative to a set\nof queries,\nand to attempt to understand on which sets \nthis problem is tractable.\nPrecisely,\n\n\neach set $\\Phi$ of existential positive queries \nyields a restricted version of the general problem,\nnamely: count the number of answers of a given formula $\\phi \\in \\Phi$\non a given finite structure~${\\mathbf{B}}$.\nWe hence have a family of problems, one problem for each such set $\\Phi$.\nOur study focuses on formula sets that have\n\\emph{bounded arity}\n(by which is meant that there is a constant that upper bounds the arity of all relation symbols used in formulas);\nlet us assume this property of all formula sets in this discussion.\\footnote\n{\nNote that in the case of unbounded arity, complexity may depend on the choice of representation of\nrelations~\\cite{ChenGrohe10-succinct}.\n}\n\nIn this article, \nwe  prove a trichotomy theorem \n(Theorem~\\ref{thm:trichotomy})\non the parameterized complexity of the\ndiscussed family of problems,\nwhich describes the complexity of every such problem.\nIn particular, our trichotomy theorem \nshows that---in a sense made precise---each such problem\n is fixed-parameter tractable,\nequivalent to the \\emph{clique} problem, \nor as hard as the \\emph{counting clique} problem (which generalizes the clique problem).\nNote that the hypothesis that the clique problem is not fixed-parameter\ntractable is an established one\nin parameterized complexity;\\footnote{It can be phrased in terms of complexity classes: FPT $\\neq$ W[1].} \nunder this hypothesis, our trichotomy theorem\nyields a precise description of the problems (from those under consideration)\nthat are fixed-parameter tractable.\nOur trichotomy theorem is in fact derived by invoking two theorems:\n\\begin{itemize}\n\n\\item A new theorem\nshowing that,\nfor each\nset of existential positive queries, there exists\na set of primitive positive queries such that the\ntwo sets exhibit the same complexity behavior\n(see Theorem~\\ref{thm:equivalence-theorem}).\nThis new theorem,\nwhich we call the \\emph{equivalence theorem}, \ncan be conceived of as the primary technical\ncontribution of this article.\n\n\\item \nA previously presented trichotomy\non primitive positive queries~\\cite{ChenMengel14-pp-arxiv,ChenMengel15-pp-icdt} (discussed in Section~\\ref{sct:ppclassification}.)\n\n\\end{itemize}\n\n\n\n\n\n\\subsection{Related work}\n\n\n\nThe statement of our new trichotomy theorem \ngeneralizes, unifies, and strengthens a number of existing \nparameterized complexity classification results in the literature, namely:\n\\begin{itemize}\n\n\\item The dichotomy for model checking primitive positive formulas~\\cite{Grohe07-otherside}, \nwhich built on a previous dichotomy~\\cite{GroheSchwentickSegoufin01-conjunctivequeries}; see also~\\cite{ChenMueller14-hierarchy}.\n\n\\item The dichotomy for model checking existential positive formulas~\\cite{Chen14-existentialpositive}.\n\n\\item The dichotomy for counting answers to quantifier-free primitive positive formulas~\\cite{DalmauJonsson04-counting} (phrased as the problem of counting homomorphisms between relational structures).\n\n\\item The trichotomy for \ncounting answers to primitive positive formulas~\\cite{ChenMengel14-pp-arxiv,ChenMengel15-pp-icdt}, which built on the previous work~\\cite{DurandMengel13-structuralcounting}.\n\n\\end{itemize}\n\nLet us emphasize that we only claim to generalize the parameterized\ncomplexity versions of the presented results.  In\nsome of the above works, such as \nthe works \\cite{Grohe07-otherside}\nand~\\cite{DalmauJonsson04-counting},\nthe problems that are\nclassified as\nfixed-parameter tractable are also polynomial-time tractable.\nWe can further remark that \nthere are problems\nfrom the dichotomy theorem \non model checking existential positive formulas~\\cite{Chen14-existentialpositive} that are shown to be fixed-parameter tractable\nbut also NP-complete.\n\n\nThe techniques used to prove our equivalence theorem \nare algebraic and combinatorial,\nand are quite different in nature from and contrast with\nthose used to prove the previous classifications,\nwhich were more graph-theoretic and logical in flavor.\nIndeed, while the graph-theoretic measure of\n\\emph{treewidth} played a key role in the \nstatement and proof of the previous trichotomy\nas well as of the previous dichotomies on primitive positive queries,\nit is not at all needed to prove our equivalence theorem.\nTo establish the equivalence theorem, we make a key application\nof the inclusion-exclusion counting principle\nto translate an existential positive formula to \na finite set of primitive positive formulas\n(see Section~\\ref{subsect:all-free}),\nwhich, in the setup considered by the article,\nis crucial to handling and understanding disjunction.\nWe believe that the developed theory that supports \nsaid application should provide a valuable foundation\nfor coping with disjunction in logics that are\nmore expressive than the one considered here. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Preliminaries}\n\n\\subsection{Basic definitions and notions}\n\nNote that $\\cdot$ is sometimes used for multiplication of \nreal\nnumbers.\n\n\n{\\bf Polynomials.}\nWe remind the reader of some basic facts about polynomials\n which we will use throughout the paper.  \nHere, a univariate polynomial $p$ in a variable $x$ is a \nfunction $p(x) =\\sum_{i=0}^d a_i x^i$ where $d \\geq 0$,\neach $a_i \\in \\mathbb{R}$\nand\n$a_d\\ne 0$, or the \\emph{zero polynomial} $p(x) = 0$.\nThe $a_i$ are called \\emph{coefficients} of $p$.\nThe degree of a polynomial is defined as $-\\infty$ \nin the case of the zero polynomial, and as $d$ otherwise.\nLet $(x_0, y_0), \\ldots, (x_n, y_n)$ be $n+1$ pairs of real numbers. Then there is a uniquely determined polynomial of degree at most $n$ such that $p(x_i)=y_i$ for each $i$;\nconsequently,\na polynomial $p$ of degree $n$ that has at least $n+1$ zeroes \n(where a \\emph{zero} is a value $x$ such that $p(x) = 0$)\nis the zero polynomial.\nIf all $x_i$ and $y_i$ are rational numbers, then the coefficients $a_i$ of this polynomial are rational numbers as well;\nmoreover, the $a_i$ can be computed in polynomial time. \n\n\n\n\n\n\n\n{\\bf Logic.}\nWe assume basic familiarity with the syntax and semantics of first-order logic.\nIn this article, we focus on relational first-order logic\nwhere equality is not built-in to the logic.\nHence, each \\emph{vocabulary/signature} under discussion consists\nonly of relation symbols.\nWe assume structures under discussion to be \\emph{finite}\n(that is, have finite universe);\nnonetheless, \nwe sometimes describe structures as \\emph{finite} for emphasis.\nWe assume that the relations of structures are represented\nas lists of tuples.\nWe use the letters ${\\mathbf{A}}$, ${\\mathbf{B}}$, $\\ldots$ to denote structures,\nand the corresponding letters $A$, $B$, $\\ldots$\nto denote their respective universes.\nWhen $\\tau$ is a signature, we use ${\\mathbf{I}}_{\\tau}$ \nto denote \nthe $\\tau$-structure \nwith universe $\\{ a \\}$ and where\neach relation symbol $R\\in \\tau$ has $R^{\\mathbf{I}} =\\{ (a,\\ldots, a)\\}$. \nWhen ${\\mathbf{A}}, {\\mathbf{B}}$ are structures over the same signature $\\tau$,\na \\emph{homomorphism} from ${\\mathbf{A}}$ to ${\\mathbf{B}}$\nis a mapping $h: A \\to B$ such that, for each $R \\in \\tau$\nand each tuple $(a_1, \\ldots, a_k) \\in R^{{\\mathbf{A}}}$,\nit holds that $(h(a_1), \\ldots, h(a_k)) \\in R^{{\\mathbf{B}}}$.\n\n\nWe use the term \\emph{fo-formula} to refer to a first-order formula.\nAn \\emph{ep-formula} (short for \\emph{existential positive formula}) \nis a fo-formula built from\n\\emph{atoms} \n(by which we refer to predicate applications of the form $R(v_1, \\ldots, v_k)$, where $R$ is a relation symbol and the $v_i$ are variables),\nconjunction ($\\wedge$), disjunction ($\\vee$),\nand existential quantification ($\\exists$).\nA \\emph{pp-formula}\n(short for \\emph{primitive positive formula}) \nis an ep-formula where disjunction does not occur.\nAn fo-formula is \\emph{prenex} if it has the form\n$Q_1 v_1 \\ldots Q_n v_n \\theta$ where $\\theta$ is quantifier-free,\nthat is, if all quantifiers occur in the front of the formula.\nThe set of free variables of a formula $\\phi$ is denoted by\n${\\mathrm{free}}(\\phi)$ and is defined as usual;\na formula $\\phi$ is a \\emph{sentence} if ${\\mathrm{free}}(\\phi) = \\emptyset$.\n\n\nWe now present some definitions and conventions that\nare not totally standard.\nA primary concern in this article \nis in counting satisfying assignments of fo-formulas\non a finite structure.\nThe count is sensitive to the set of variables over which\nassignments are considered; and, we will sometimes \n(but not always) want to count\nrelative to a set of variables that is strictly larger than\nthe set of free variables.\nHence, we will often associate with each fo-formula $\\phi$\na set $V$ of variables called the \\emph{liberal variables},\ndenoted by ${\\mathrm{lib}}(\\phi)$,\nwhich is required to be~a \nsuperset of ${\\mathrm{free}}(\\phi)$, that is, \nwe require ${\\mathrm{lib}}(\\phi) \\supseteq {\\mathrm{free}}(\\phi)$.\nNote that ${\\mathrm{lib}}(\\phi)$ may contain variables that do not\noccur at all in $\\phi$.\nTo indicate that $V$ is the set of liberal variables of $\\phi$,\nwe often use the notation $\\phi(V)$;\nwe also use $\\phi(v_1, \\ldots, v_n)$, where the $v_i$ \nare a listing of the elements of $V$.\nRelative to a formula $\\phi(V)$, when~${\\mathbf{B}}$ is a structure,\nwe will use $\\phi({\\mathbf{B}})$ to denote the set of\nassignments $f: V \\to B$ such that ${\\mathbf{B}}, f \\models \\phi$.\n\\emph{We assume that, in each prenex formula\nwith\nliberal variables associated with it,\nno variable is both liberal and quantified.}\nWe call an fo-formula $\\phi$ \\emph{free} if ${\\mathrm{free}}(\\phi) \\neq \\emptyset$,\nand\n\\emph{liberal} if \n${\\mathrm{lib}}(\\phi)$ is defined and ${\\mathrm{lib}}(\\phi) \\neq \\emptyset$.\n\n\\begin{example}\nLet us consider the formula $\\phi(x,y,z) = R(x,y) \\vee S(y,z)$.\nAs indicated above, the notation $\\phi(x,y,z)$ is used to indicate\nthat ${\\mathrm{lib}}(\\phi) = \\{ x, y, z \\}$.  \nAs ${\\mathrm{free}}(\\phi) = \\{ x, y, z \\}$, we have ${\\mathrm{lib}}(\\phi) = {\\mathrm{free}}(\\phi)$.\nDefine $\\psi(x,y,z) = R(x,y)$ and $\\psi'(x,y,z) = S(y,z)$.\nBy the notation $\\psi(x,y,z)$, we indicate that\n${\\mathrm{lib}}(\\psi) = \\{ x, y, z \\}$; likewise, we have \n${\\mathrm{lib}}(\\psi') = \\{ x, y, z \\}$.\nNotice that ${\\mathrm{free}}(\\psi) = \\{ x, y \\}$, so we have that\n${\\mathrm{lib}}(\\psi)$ is a proper superset of ${\\mathrm{free}}(\\psi)$;\nin fact, the variable $z \\in {\\mathrm{lib}}(\\psi)$ does not occur\nat all in an atom of $\\psi$.\nDefine also $\\theta(x,y) = R(x,y)$; by the notation\n$\\theta(x,y)$, we indicate that ${\\mathrm{lib}}(\\theta) = \\{ x, y \\}$.\n\nObserve that, for any structure ${\\mathbf{B}}$, we have\n$\\phi({\\mathbf{B}}) = \\psi({\\mathbf{B}}) \\cup \\psi'({\\mathbf{B}})$\n(and hence $|\\phi({\\mathbf{B}})| = |\\psi({\\mathbf{B}}) \\cup \\psi'({\\mathbf{B}})|$).\nObserve, however, that for any structure ${\\mathbf{B}}$\nwhere $\\theta({\\mathbf{B}})$ is non-empty, it does not\nhold that \n$\\phi({\\mathbf{B}}) = \\theta({\\mathbf{B}}) \\cup \\psi'({\\mathbf{B}})$,\nsince $\\phi({\\mathbf{B}})$ contains only assignments defined on \n${\\mathrm{lib}}(\\phi) = \\{ x, y, z \\}$, whereas\n$\\theta({\\mathbf{B}})$ contains only assignments defined on\n${\\mathrm{lib}}(\\theta) = \\{ x, y \\}$.\n\\end{example}\n\n\n\n{\\bf pp-formulas.}\nIt is well-known~\\cite{ChandraMerlin77-optimal}\nthat there is a correspondence between prenex pp-formulas\nand relational structures.\nIn particular, \neach prenex pp-formula $\\phi(S)$ (on signature $\\tau$) \nwith ${\\mathrm{lib}}(\\phi) = S$\nmay be viewed as a\npair $({\\mathbf{A}}, S)$ \nconsisting of a structure ${\\mathbf{A}}$ (on $\\tau$) \nand a set $S$;\nthe universe $A$ of ${\\mathbf{A}}$ is\nthe union of $S$ with the variables appearing in $\\phi$,\nand the following condition \ndefines the relations of ${\\mathbf{A}}$: for each $R \\in \\tau$,\na tuple $(a_1, \\ldots, a_k) \\in A^k$\nis in $R^{{\\mathbf{A}}}$ \nif and only if $R(a_1, \\ldots, a_k)$ appears in $\\phi$.\nIn the other direction, \nsuch a pair $({\\mathbf{A}}, S)$ can be viewed as a prenex pp-formula $\\phi(S)$\nwhere all variables in $A \\setminus S$ are quantified\nand the atoms of $\\phi$ are defined according to the above condition.\nA basic known fact~\\cite{ChandraMerlin77-optimal}\nthat we will use\nis that\nwhen $\\phi(S)$ is a pp-formula corresponding to the pair $({\\mathbf{A}}, S)$,\n${\\mathbf{B}}$ is an arbitrary structure, and $f: S \\to B$ is an arbitrary map,\nit holds that \n${\\mathbf{B}}, f \\models \\phi(S)$ if and only if\nthere is an extension $f'$ of $f$ that is a homomorphism\nfrom~${\\mathbf{A}}$ to ${\\mathbf{B}}$.\n\\emph{We will freely interchange between the\n structure view\nand the usual notion\nof a prenex pp-formula.}\nFor a pp-formula specified as a \npair $({\\mathbf{A}},S)$, we typically assume that $S \\subseteq A$.\n\n\\begin{example}\n\\label{ex:pp-formula}\nConsider the  pp-formula\n$\\phi(x,x',y,z) = \\exists y' \\exists u \\exists v \\exists w (E(x, x') \\wedge E(y,y') \\wedge F(u,v) \\wedge G(u,w)).$\nThe notation $\\phi(x, x',y,z)$ \nindicates that ${\\mathrm{lib}}(\\phi) = \\{ x, x', y, z \\}$.\nNote that ${\\mathrm{free}}(\\phi) = \\{ x, x', y \\}$.\nTo convert $\\phi$ to a structure ${\\mathbf{A}}$, \nwe take the universe $A$ of ${\\mathbf{A}}$ to be\nthe union of ${\\mathrm{lib}}(\\phi)$ with all variables appearing in $\\phi$,\nso $A = \\{ x, x',y,z, y', u, v, w \\}$.\nThen, we define the relations as just described above,\nso $E^{{\\mathbf{A}}} = \\{ (x, x'), (y, y') \\}$, \n$F^{{\\mathbf{A}}} = \\{ (u,v) \\}$, and\n$G^{{\\mathbf{A}}} = \\{ (u,w) \\}$.\nThe resulting pair representation of $\\phi$ \nis $({\\mathbf{A}}, \\{ x, x', y, z \\})$.\n\\end{example}\n\nTwo structures are \\emph{homomorphically equivalent} if\neach has a homomorphism to the other.\nA  structure is a \\emph{core} if it is not homomorphically equivalent to a proper substructure of itself.  A structure ${\\mathbf{B}}$ is a \n\\emph{core} of a structure ${\\mathbf{A}}$ if ${\\mathbf{B}}$ is a substructure of ${\\mathbf{A}}$ that is a core and is homomorphically equivalent to ${\\mathbf{A}}$.\nIt is known that all cores of a structure are isomorphic and hence one sometimes speaks of \\emph{the} core of a structure.\n\nFor a prenex pp-formula $({\\mathbf{A}},S)$ \non signature $\\tau$,\nwe define its \\emph{augmented structure},\ndenoted by\n${\\mathsf{aug}}({\\mathbf{A}},S)$,\nto be the structure\n over the expanded vocabulary $\\tau\\cup \\{R_a\\mid a\\in S\\}$ (understood to be a disjoint union)\n\nwhere $R_a^{{\\mathsf{aug}}({\\mathbf{A}},S)} =\\{a\\}$;\nwe define the \\emph{core} of the pp-formula $({\\mathbf{A}},S)$\nto be the core of~${\\mathsf{aug}}({\\mathbf{A}},S)$.\n\nThe following fundamental facts on pp-formulas\n will be used throughout.\n\n\\begin{theorem}[follows from \\cite{ChandraMerlin77-optimal}]\\label{thm:ChandraMerlin}\nLet the pairs $({\\mathbf{A}},V)$, $({\\mathbf{B}},V)$ be prenex pp-formulas.\nThe formula $({\\mathbf{B}},V)$ logically entails\nthe formula $({\\mathbf{A}},V)$ if and only if\nthere exists a homomorphism from\n${\\mathsf{aug}}({\\mathbf{A}},V)$ to ${\\mathsf{aug}}({\\mathbf{B}},V)$.\nThe formulas $({\\mathbf{A}}, V)$, $({\\mathbf{B}},V)$ are\nlogically equivalent if and only if\nthey have isomorphic cores, or equivalently, when\n${\\mathsf{aug}}({\\mathbf{A}},V)$ and ${\\mathsf{aug}}({\\mathbf{B}},V)$ are homomorphically equivalent.\n\\end{theorem}\n\n\n\n\n{\\bf ep-formulas.}\nIn order to discuss ep-formulas, we will employ the following\nterminology.\nAn ep-formula is \\emph{disjunctive} \nif it is the disjunction of prenex pp-formulas;\nwhen $\\phi$ is a disjunctive ep-formula\nwith ${\\mathrm{lib}}(\\phi)$ defined, we typically assume\nthat each of the pp-formulas $\\psi$ that appear as disjuncts\nof $\\phi$ has ${\\mathrm{lib}}(\\psi)$ defined as ${\\mathrm{lib}}(\\phi)$.\n(In this way, for an arbitrary finite structure ${\\mathbf{B}}$,\nit holds that $|\\phi({\\mathbf{B}})| = |\\bigcup_{\\psi} \\psi({\\mathbf{B}})|$,\nwhere the union is over all such disjuncts $\\psi$.)\n\n\nAn ep-formula is \\emph{all-free} if it is disjunctive\nand each pp-formula appearing as a disjunct is free.\nAn ep-formula $\\phi(S)$ is \\emph{normalized} if it is disjunctive\nand for each sentence disjunct\n$({\\mathbf{A}}, S)$ and any other disjunct $({\\mathbf{A}}', S)$,\nthere is no homomorphism from \n${\\mathsf{aug}}({\\mathbf{A}}, S)$ to ${\\mathsf{aug}}({\\mathbf{A}}', S)$\n(equivalently, there is no homomorphism from ${\\mathbf{A}}$ to ${\\mathbf{A}}'$).\nIt is straightforward to verify that there is an algorithm that,\ngiven an ep-formula, outputs a logically equivalent normalized ep-formula.\n\n\n\n{\\bf Graphs.}\n\nTo every prenex pp-formula $({\\mathbf{A}}, S)$\nwe assign a graph \nwhose vertex set is $A \\cup S$ \nand where two vertices are connected by an edge if they appear together in a tuple of a relation of ${\\mathbf{A}}$.\nA prenex pp-formula $({\\mathbf{A}}, S)$ is called \\emph{connected} if its graph is connected. \nA prenex pp-formula $({\\mathbf{A}}', S')$ is a\n\\emph{component} of a prenex pp-formula $({\\mathbf{A}}, S)$\nover the same signature $\\tau$\nif there exists a set $C$ that forms a connected component\nof the graph of $({\\mathbf{A}}, S)$, where:\n\\begin{itemize}\n\n\\item $S' = S \\cap C.$\n\n\\item For each relation $R \\in \\tau$, \na tuple $(a_1, \\ldots, a_k)$ is in $R^{{\\mathbf{A}}'}$\nif and only if \n $(a_1, \\ldots, a_k) \\in R^{{\\mathbf{A}}} \\cap C^k$.\n\n\\end{itemize}\nNote that when this holds, the graph of $({\\mathbf{A}}', S')$\nis the connected component of the graph of $({\\mathbf{A}}, S)$ on vertices $C$.\nWe will use the fact that, if $\\phi(V)$ is a prenex pp-formula\nand $\\phi_1(V_1), \\ldots, \\phi_c(V_c)$ is a list of its components,\nthen for any finite structure ${\\mathbf{B}}$,\nit holds that \n$|\\phi({\\mathbf{B}})| = \\prod_{i=1}^c |\\phi_i({\\mathbf{B}})|$.\n\n\n\n\\begin{example}\n\\label{ex:pp-formula-components}\nLet $\\phi$ be the free prenex pp-formula \nfrom Example~\\ref{ex:pp-formula}, and let $({\\mathbf{A}}, S)$ be the \npair representation given there.\nThe connected components of the graph of $({\\mathbf{A}}, S)$\nare \n$\\{ x, x'\\}$, $\\{ y, y'\\}$, $\\{ z \\}$,\nand\n$\\{u, v, w\\}$.\nThere are thus four components of the formula $({\\mathbf{A}}, S)$;\nthey are\n$({\\mathbf{A}}'_{\\{x,x'\\}},  \\{ x, x' \\})$,\n$({\\mathbf{A}}'_{\\{y,y'\\}},  \\{ y \\})$, \n$({\\mathbf{A}}'_{\\{z\\}},     \\{ z \\})$, and\n$({\\mathbf{A}}'_{\\{u,v,w\\}}, \\emptyset)$\n(respectively),\nwhere each ${\\mathbf{A}}'_C$ is the structure ${\\mathbf{A}}'$ defined above,\nwith respect to the set $C$.\n\nWritten logically, these four components are\n$\\psi_1(x, x') =  E(x,x')$,\n$\\psi_2(y) = \\exists y' E(y,y')$,\n$\\psi_3(z) = \\top$, \nand\n$\\psi_4(\\emptyset) = \\exists u \\exists v \\exists w (F(u,v) \\wedge G(u,w))$,\nrespectively.\nHere, $\\top$ denotes the empty conjunction (considered to be true).\n\\end{example}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Counting complexity}\n\nThroughout, we use $\\Sigma$ to denote an alphabet over which\nstrings are formed.\nAll problems to be considered are viewed as counting problems.\nSo, a \\emph{problem} is a mapping $Q: \\Sigma^* \\to {\\mathbb{N}}$.\nWe view decision problems as problems where,\nfor each $x \\in  \\Sigma^*$, it holds that $Q(x)$ is equal to $0$ or $1$.\n\n\n\nA \\emph{parameterization} is a mapping\n$\\kappa: \\Sigma^* \\to \\Sigma^*$.\nA parameterized problem is a pair $(Q, \\kappa)$\nconsisting of a problem $Q$ and a parameterization~$\\kappa$.\nThroughout, by $\\pi_i$ we denote the operator\nthat projects a tuple onto its $i$th coordinate.\n\n\nA partial function $T: \\Sigma^* \\to {\\mathbb{N}}$\nis \\emph{polynomial-multiplied} \nwith respect to a parameterization~$\\kappa$\nif there exists a computable function $f: \\Sigma^* \\to {\\mathbb{N}}$\nand a polynomial $p: {\\mathbb{N}} \\to {\\mathbb{N}}$ such that,\nfor each $x \\in {\\mathrm{dom}}(T)$, \nit holds that $T(x) \\leq f(\\kappa(x)) p(|x|)$.\n\nWe now give a definition of FPT-computability for partial mappings.\n\n\\begin{definition}\nLet $\\kappa: \\Sigma^* \\to \\Sigma^*$\nbe a parameterization.\nA partial mapping $r: \\Sigma^* \\to \\Sigma^*$\nis \\emph{FPT-computable} with respect to $\\kappa$\nif there exist a polynomial-multiplied function $T: \\Sigma^* \\to {\\mathbb{N}}$\n(with respect to $\\kappa$)\nwith ${\\mathrm{dom}}(T) = {\\mathrm{dom}}(r)$\nand an algorithm $A$ such that,\nfor each string $x \\in {\\mathrm{dom}}(r)$,\nthe algorithm $A$ computes $r(x)$ within time $T(x)$;\nwhen this holds, we also say that $r$ is \\emph{FPT-computable}\nwith respect to $\\kappa$ \\emph{via $A$}.\n\\end{definition}\n\nAs is standard, we may and do freely interchange among\nelements of $\\Sigma^*$, $\\Sigma^* \\times \\Sigma^*$, and ${\\mathbb{N}}$.\nWe define FPT to be the class \nthat contains a parameterized problem $(Q, \\kappa)$\nif and only if $Q$ is FPT-computable with respect to $\\kappa$.\n\nWe now introduce a notion of reduction for counting problems,\nwhich is a form of Turing reduction.\nWe use ${\\wp_{\\mathsf{fin}}}(A)$ to denote the set containing all finite subsets of\n$A$.\n\n\\begin{definition}\nA \\emph{counting FPT-reduction} from a parameterized problem\n$(Q, \\kappa)$ to another $(Q', \\kappa')$\n\nconsists of \n a computable function $h: \\Sigma^* \\to {\\wp_{\\mathsf{fin}}}(\\Sigma^*)$,\nand\nan algorithm $A$ such that:\n\n\n\\begin{itemize}\n\\item  on an input $x$,\n$A$ may make oracle queries of the form\n$Q'(y)$ with $\\kappa'(y) \\in  h(\\kappa(x))$, and\n\\item $Q$ is FPT-computable with respect to $\\kappa$ via $A$.\n\\end{itemize}\n\\end{definition}\n\n\nWe use ${\\textsc{{Clique}}}$ to denote the decision problem  where $(k, G)$ is a\nyes-instance when $G$ is a graph that contains a clique of size $k\\in\n\\mathbb{N}$. By ${\\textsc{{\\#Clique}}}$ we denote the problem of counting, given\n$(k, G)$, the number of $k$-cliques in the graph $G$.\nThe parameterized versions of these problems,\ndenoted by ${\\ensuremath{p\\textup{-}}}{\\textsc{{Clique}}}$ and ${\\ensuremath{p\\textup{-}}}{\\textsc{{\\#Clique}}}$, are defined\nvia the parameterization $\\pi_1(k,G) = k$.\n\n\n\n\n\n\n\\subsection{Counting case complexity}\n\nWe employ the framework of \\emph{case complexity} to\ndevelop some of our complexity results.\nWe present the needed elements of this\nframework for counting problems.\nThe definitions and results here are due to~\\cite{ChenMengel14-pp-arxiv,ChenMengel15-pp-icdt},\nare based on the theory of~\\cite{Chen14-frontier},\nand are presented here for the sake of self-containment;\nsee those articles for motivation and further discussion of the framework.\n\n\n\n\n\n\n\nA \\emph{case problem} consists of a problem\n$Q: \\Sigma^* \\times \\Sigma^* \\to {\\mathbb{N}}$\nand a subset $S \\subseteq \\Sigma^*$,\nand is denoted $Q[S]$.\nNote that, although a problem above is defined as a mapping\nfrom $\\Sigma^*$ to ${\\mathbb{N}}$, here we work with a problem\nthat is a mapping from $\\Sigma^* \\times \\Sigma^*$ to ${\\mathbb{N}}$;\nthis is natural in the current paper, where\nan input to the studied problem consists of two parts,\na formula and a structure.  Note that a mapping\n$\\Sigma^* \\times \\Sigma^* \\to {\\mathbb{N}}$ can be naturally viewed\nas a mapping $\\Sigma^* \\to {\\mathbb{N}}$, as there are natural and well-known\nways to encode\nthe elements of $\\Sigma^* \\times \\Sigma^*$ as elements of $\\Sigma^*$.\nFor each case problem $Q[S]$, we define\n${\\mathsf{param}\\textup{-}{Q[S]}}$ as the parameterized problem $(P, \\pi_1)$\nwhere $P(s, x)$ is defined as equal to \n$Q(s, x)$ if $s \\in S$, and as $0$ otherwise.\n\n\n\n\n\n\n\n\n\n\n\nWe have the following reduction notion for case problems.\n\n\\begin{definition}\nA \\emph{counting slice reduction} from a case problem $Q[S]$ to a second case problem $Q'[S']$ consists of\n\\begin{itemize}\n \\item a computably enumerable language $U\\subseteq \\Sigma^* \\times {\\wp_{\\mathsf{fin}}}(\\Sigma^*)$, and\n \\item a partial function \n$r: \\Sigma^* \\times {\\wp_{\\mathsf{fin}}}(\\Sigma^*) \\times \\Sigma^*\\rightarrow \\Sigma^*$ \nthat has domain $U\\times \\Sigma^*$ and is \nFPT-computable with respect to $(\\pi_1, \\pi_2)$ via\nan algorithm $A$ that, on input $(s, T, y)$, \nmay make queries of the form $Q'(t,z)$\nwhere $t \\in T$,\n\\end{itemize}\nsuch that the following conditions hold:\n\\begin{itemize}\n \\item (coverage) for each $s\\in S$, there exists $T \\subseteq S'$\nsuch that $(s, T)\\in U$, and \n \\item (correctness) for each $(s, T) \\in U$, it holds (for each $y\\in \\Sigma^*$) that \n$Q(s,y) = r(s, T, y).$\n\\end{itemize}\n\\end{definition}\n\n\\begin{theorem} \\label{thm:transitivity}\n\\cite{ChenMengel14-pp-arxiv}\nCounting slice reducibility is transitive.\n\\end{theorem}\n\nThe following theorem\nshows that, from a counting slice reduction,\none can obtain \ncomplexity results for the corresponding\nparameterized problems.\n\n\n\\begin{theorem}\n\\label{thm:slice-red-gives-fpt-red}\n\\cite{ChenMengel14-pp-arxiv}\nLet $Q[S]$ and $Q'[S']$ be case problems.\nSuppose that $Q[S]$ counting slice reduces to $Q'[S']$,\nand that both $S$ and $S'$ are computable.\nThen ${\\mathsf{param}\\textup{-}{Q[S]}}$ counting FPT-reduces to ${\\mathsf{param}\\textup{-}{Q'[S']}}$.\n\\end{theorem}\n\n\n\n\\subsection{Classification of pp-formulas}\n\\label{sct:ppclassification}\n\n\nWe present the complexity classification of pp-formulas\npreviously presented in~\\cite{ChenMengel14-pp-arxiv,ChenMengel15-pp-icdt}.\nThe following definitions are adapted from that article.\nLet $({\\mathbf{A}},S)$ be a prenex pp-formula,\nlet ${\\mathbf{D}}$ be the core thereof, and let $G = (D,E)$ be the\ngraph of ${\\mathbf{D}}$.\nAn\n\\emph{$\\exists$-component} of $({\\mathbf{A}},S)$ is a graph of the form \n$G[V']$ where there exists\n$V \\subseteq D$ that is the vertex set of a component of\n$G[D \\setminus S]$ and $V'$ is the union of $V$\nwith all vertices in $S$ having an edge to $V$.\nDefine ${\\mathsf{contract}}({\\mathbf{A}},S)$ \nto be the graph on vertex set $S$\nobtained by starting from $G[S]$ \nand adding an edge between any two vertices that appear together\nin an $\\exists$-component of $({\\mathbf{A}},S)$.\n\n\nLet $\\Phi$ be a set of prenex pp-formulas.\nLet us say that $\\Phi$ satisfies the\n\\emph{contraction condition} if\nthe graphs in ${\\mathsf{contract}}(\\Phi) := \\{ {\\mathsf{contract}}(\\phi) ~|~ \\phi \\in \\Phi \\}$\nare of bounded treewidth.\nLet us say that $\\Phi$ satisfies the\n\\emph{tractability condition}\nif it satisfies the contraction condition \nand, in addition,\nthe cores of $\\Phi$ are of bounded treewidth;\nhere, the treewidth of a prenex pp-formula is defined\nas that of its graph. \nWe omit the definition of treewidth,\nas it is both well-known and not needed\nto understand the main technical proof of this \narticle (which is in Section~\\ref{sect:proof-equiv-theorem}).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{definition}\nWe define ${\\mathsf{count}}$ to be the problem that maps a pair\n$(\\phi(V),{\\mathbf{B}})$ consisting of a fo-formula and a finite structure\nto the value $|\\phi({\\mathbf{B}})|$.\n\\end{definition}\n\n\n\\begin{theorem}\n\\label{thm:pp-tractability-condition} \\cite{ChenMengel14-pp-arxiv}\nLet $\\Phi$ be a set of prenex pp-formulas\nthat satisfies the tractability condition.\nThen, the restriction of ${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$ to $\\Phi \\times \\Sigma^*$\nis an FPT-computable partial function.\n\\end{theorem}\n\n\n\n\\begin{theorem} \\cite{ChenMengel14-pp-arxiv}\n\\label{thm:pp-complexity-results}\nLet $\\Phi$ be a set of prenex pp-formulas of bounded arity\nthat does not satisfy the tractability condition.\n\\begin{enumerate}\n\n\n\n\\item If $\\Phi$ satisfies the contraction condition,\nthen it holds that\n${\\mathsf{count}}[\\Phi]$ and ${\\textsc{{Clique}}}[\\mathbb{N}]$ are interreducible,\n  under\ncounting slice reductions.\n\n\\item \nOtherwise,\n there is a counting slice reduction \n from ${\\textsc{{\\#Clique}}}[\\mathbb{N}]$ to ${\\mathsf{count}}[\\Phi]$.\n\n\\end{enumerate}\n\\end{theorem}\n\nWe say that a set of formulas $\\Phi$ has \\emph{bounded arity} if\nthere exists a constant $k \\geq 1$ that upper bounds the\narity of each relation symbol appearing in a formula in $\\Phi$.\n\n\n\n\\section{Main theorems}\n\n\n\n\nThe following theorem, which we call the \\emph{equivalence theorem}\nand which is proved in Section~\\ref{sect:proof-equiv-theorem},\nis our  primary technical result; it is used to derive our\ncomplexity trichotomy on ep-formulas from the\nknown complexity trichotomy on pp-formulas\n(which was presented in Section~\\ref{sct:ppclassification}).\n\n\\begin{theorem}\n\\label{thm:equivalence-theorem} \n(Equivalence theorem)\nLet $\\Phi$ be a set of ep-formulas.  \nThere exists a set $\\Phi^+$ of prenex pp-formulas\nwith the following property: the counting case problems\n${\\mathsf{count}}[\\Phi]$ and ${\\mathsf{count}}[\\Phi^+]$\nare interreducible under counting slice reductions.\nIn particular, there exists an algorithm that computes,\ngiven an ep-formula $\\phi$, a finite set $\\phi^+$ of prenex pp-formulas\nsuch that for any set $\\Phi$ of ep-formulas, the \nset $\\Phi^+$ defined as $\\bigcup \\{ \\phi^+ ~|~ \\phi \\in \\Phi \\}$\nhas the presented property.\n\\end{theorem}\n\n\n\n\n\n\n\n\nWe now state our trichotomy theorem\non the complexity of counting answers to ep-formulas,\nand show how to prove it using\nthe equivalence theorem.\n\n\n\n\n\n\n\n\n\\begin{theorem}\n\\label{thm:trichotomy}\n(Trichotomy theorem)\nLet $\\Phi$ be a computable set of ep-formulas of bounded arity,\nand let $\\Phi^+$ be the set of pp-formulas\ngiven by Theorem~\\ref{thm:equivalence-theorem}.\n\\begin{enumerate}\n\n\\item If $\\Phi^+$ satisfies the tractability condition,\nthen it holds that ${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$ is in FPT.\n\n\\item If $\\Phi^+$ does not satisfy the tractability condition\nbut satisfies the contraction condition,\nthen it holds that ${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$ is interreducible with\n${\\ensuremath{p\\textup{-}}}{\\textsc{{Clique}}}$ under counting FPT-reduction.\n\n\n\\item Otherwise, there is a counting FPT-reduction from\n${\\ensuremath{p\\textup{-}}}{\\textsc{{\\#Clique}}}$ to ${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$.\n\n\\end{enumerate}\n\\end{theorem}\n\n\\begin{proof}\nFor (1), \nwe use the counting slice reduction $(U, r)$ from\n${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^+]$\ngiven by Theorem~\\ref{thm:equivalence-theorem}.\nIn particular, given as input $(\\phi, {\\mathbf{B}})$,\nit is first checked if $\\phi \\in \\Phi$; if not, $0$ is output.\nOtherwise,\nthe algorithm for $r$\nis invoked on $(\\phi, \\phi^+, {\\mathbf{B}})$,\nwhere $\\phi^+$ is as defined in \nthe statement of Theorem~\\ref{thm:equivalence-theorem};\nqueries to ${\\mathsf{count}}(\\psi, {\\mathbf{B}})$ where $\\psi \\in \\Phi^+$ are\nresolved according to the algorithm of\nTheorem~\\ref{thm:pp-tractability-condition}.\n\nFor (2) and (3), we make use of the result\n(Theorem~\\ref{thm:equivalence-theorem})\nthat the problems ${\\mathsf{count}}[\\Phi]$ and ${\\mathsf{count}}[\\Phi^+]$ \nare interreducible under counting slice reductions.\nFor (2), we have from Theorem~\\ref{thm:pp-complexity-results}\nthat ${\\mathsf{count}}[\\Phi^+]$ and ${\\textsc{{Clique}}}[{\\mathbb{N}}]$ are interreducible under\ncounting slice reductions.\nHence, ${\\textsc{{Clique}}}[{\\mathbb{N}}]$ and ${\\mathsf{count}}[\\Phi]$ are interreducible\nunder counting slice reductions, and the result follows from \nTheorem~\\ref{thm:slice-red-gives-fpt-red}.\nFor (3), we have from Theorem~\\ref{thm:pp-complexity-results}\nthat there is a counting slice reduction\nfrom ${\\textsc{{\\#Clique}}}[{\\mathbb{N}}]$ to ${\\mathsf{count}}[\\Phi^+]$, and hence\nfrom ${\\textsc{{\\#Clique}}}[{\\mathbb{N}}]$ to ${\\mathsf{count}}[\\Phi]$;\nthe result then follows from \nTheorem~\\ref{thm:slice-red-gives-fpt-red}.\n\\end{proof}\n\nLet us remark that when case (2) applies, \na consequence of this theorem is that\nthe problem \n${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$ is not in FPT unless W[1] is in FPT,\nsince ${\\ensuremath{p\\textup{-}}}{\\textsc{{Clique}}}$ is W[1]-complete;\nsimilarly, when case (3) applies,\nthe problem \n${\\mathsf{param}\\textup{-}{{\\mathsf{count}}[\\Phi]}}$ is not in FPT unless ${\\sharp}$W[1] is in FPT,\nsince ${\\ensuremath{p\\textup{-}}}{\\textsc{{\\#Clique}}}$ is ${\\sharp}$W[1]-complete.\n\n\n\n\n\n\n\n\n\n\\section{Examples}\\label{sct:examples}\n\nBefore presenting the classification result for ep-for\\-mu\\-las in full generality, we discuss some example\nep-formulas to illustrate and preview \nsome of the issues and difficulties\nwith which the argument needs to cope.\n\n\n\\begin{example}\\label{ex:eqfirst}\n Consider the formula \n\n", "index": 1, "text": "\\[\\phi(w,x,y,z) := E(x,y) \\land (E(w,x) \\lor (E(y, z) \\land E(z,z))).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\phi(w,x,y,z):=E(x,y)\\land(E(w,x)\\lor(E(y,z)\\land E(z,z))).\" display=\"block\"><mrow><mrow><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n Now set $\\phi_1(w,x,y,z)\\equiv E(x,y) \\land E(w,x)$ and also set $\\phi_2(w,x,y,z)\\equiv E(x,y) \\land E(y,z) \\land E(z,z)$.\n We can use inclusion-exclusion to count the number of satisfying assignments of $\\phi$ on a structure ${\\mathbf{B}}$ by \n\n", "itemtype": "equation", "pos": 37839, "prevtext": "\n As a first simplification step, we bring \n disjunction to the outermost level in $\\phi$:\n \n", "index": 3, "text": "\\begin{align*} &\\phi(w,x,y,z) \\\\&\\equiv(E(x,y) \\land E(w,x)) \\lor (E(x,y) \\land E(y,z) \\land E(z,z)).\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\phi(w,x,y,z)\" display=\"inline\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\equiv(E(x,y)\\land E(w,x))\\lor(E(x,y)\\land E(y,z)\\land E(z,z)).\" display=\"inline\"><mrow><mrow><mi/><mo>\u2261</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>w</mi><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2228</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\nOne point to observe is that, in this last expression,\nthe count $|\\phi_1({\\mathbf{B}})|$ needs to be determined with respect to\nits set of liberal variabes ${\\mathrm{lib}}(\\phi_1) = \\{ w, x, y, z \\}$, even though $z$\ndoes not appear in any atom of $\\phi_1$.\nIf the count $|\\phi_1({\\mathbf{B}})|$ is not computed in this way,\nthe above expression for $|\\phi({\\mathbf{B}})|$ fails\nto hold in general.\nThe situation is analogous for the formula $\\phi_2$, where \n$w$ does not appear in any atom.\n\n \n\n\\end{example}\n\n\\begin{example}\\label{ex:eqsecond}\n In general, if we are given an ep-for\\-mula $\\phi= \\phi_1 \\lor \\ldots \\lor \\phi_n$ where the $\\phi_i$ are pp-formulas, then to compute the count \n $|\\phi({\\mathbf{B}})|$ of $\\phi$ relative to ${\\mathbf{B}}$,\n it suffices to know the count  for each of the $2^n - 1$ pp-formulas \n obtained by taking a conjunction of a non-empty subset of the $\\phi_i$. \n In this example, we will see that, in fact, one does not always need to consider all of these conjunctions. \n To this end, set $V = \\{ w,x,y,z \\}$ and set\n\n\n", "itemtype": "equation", "pos": 38200, "prevtext": "\n Now set $\\phi_1(w,x,y,z)\\equiv E(x,y) \\land E(w,x)$ and also set $\\phi_2(w,x,y,z)\\equiv E(x,y) \\land E(y,z) \\land E(z,z)$.\n We can use inclusion-exclusion to count the number of satisfying assignments of $\\phi$ on a structure ${\\mathbf{B}}$ by \n\n", "index": 5, "text": "\\[|\\phi({\\mathbf{B}})| = |\\phi_1({\\mathbf{B}})| + |\\phi_2({\\mathbf{B}})| - |(\\phi_1\\land \\phi_2)({\\mathbf{B}})|.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"|\\phi({\\mathbf{B}})|=|\\phi_{1}({\\mathbf{B}})|+|\\phi_{2}({\\mathbf{B}})|-|(\\phi_%&#10;{1}\\land\\phi_{2})({\\mathbf{B}})|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " \n\nwhere \n$\\phi_1(V) = E(x,y) \\land E(y,z)$, \n$\\phi_2(V) = E(z,w) \\land E(w,x)$ and \n$\\phi_3(V) = E(w,x) \\land E(x,y)$. \nApplying in\\-clu\\-sion-ex\\-clu\\-sion, we obtain\n \n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nOne point to observe is that, in this last expression,\nthe count $|\\phi_1({\\mathbf{B}})|$ needs to be determined with respect to\nits set of liberal variabes ${\\mathrm{lib}}(\\phi_1) = \\{ w, x, y, z \\}$, even though $z$\ndoes not appear in any atom of $\\phi_1$.\nIf the count $|\\phi_1({\\mathbf{B}})|$ is not computed in this way,\nthe above expression for $|\\phi({\\mathbf{B}})|$ fails\nto hold in general.\nThe situation is analogous for the formula $\\phi_2$, where \n$w$ does not appear in any atom.\n\n \n\n\\end{example}\n\n\\begin{example}\\label{ex:eqsecond}\n In general, if we are given an ep-for\\-mula $\\phi= \\phi_1 \\lor \\ldots \\lor \\phi_n$ where the $\\phi_i$ are pp-formulas, then to compute the count \n $|\\phi({\\mathbf{B}})|$ of $\\phi$ relative to ${\\mathbf{B}}$,\n it suffices to know the count  for each of the $2^n - 1$ pp-formulas \n obtained by taking a conjunction of a non-empty subset of the $\\phi_i$. \n In this example, we will see that, in fact, one does not always need to consider all of these conjunctions. \n To this end, set $V = \\{ w,x,y,z \\}$ and set\n\n\n", "index": 7, "text": "$$\\phi(V)= \\phi_1(V) \\lor \\phi_2(V) \\lor \\phi_3(V)$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\phi(V)=\\phi_{1}(V)\\lor\\phi_{2}(V)\\lor\\phi_{3}(V)\" display=\"block\"><mrow><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><msub><mi>\u03d5</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\n Now observe that the formulas $\\phi_1$, $\\phi_2$ and $\\phi_3$ \nare actually equivalent to each other up to renaming variables;\nconsequently,  these formulas\nare equivalent in that,\nfor any structure ${\\mathbf{B}}$,\nthey\nyield the same count: $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})| = |\\phi_3({\\mathbf{B}})|$.\nIn Section~\\ref{subsect:counting-equivalence}, we formalize\nand give a characterization of this notion of equivalence\n(on pp-formulas).\nThe formulas $\\phi_1 \\land \\phi_3$ and $\\phi_2 \\land \\phi_3$\nare also equivalent in this sense.  We may thus obtain\nthe following expression for $|\\phi({\\mathbf{B}})|$.\n\n \n", "itemtype": "equation", "pos": 39596, "prevtext": " \n\nwhere \n$\\phi_1(V) = E(x,y) \\land E(y,z)$, \n$\\phi_2(V) = E(z,w) \\land E(w,x)$ and \n$\\phi_3(V) = E(w,x) \\land E(x,y)$. \nApplying in\\-clu\\-sion-ex\\-clu\\-sion, we obtain\n \n", "index": 9, "text": "\\begin{align*}|\\phi({\\mathbf{B}})| = &|\\phi_1({\\mathbf{B}})| + |\\phi_2({\\mathbf{B}})| + |\\phi_3({\\mathbf{B}})|\\\\\n  &- |(\\phi_1\\land \\phi_2)({\\mathbf{B}})| - |(\\phi_1\\land \\phi_3)({\\mathbf{B}})|  \\\\&- |(\\phi_2 \\land \\phi_3)({\\mathbf{B}})|+ |(\\phi_1 \\land \\phi_2 \\land \\phi_3)({\\mathbf{B}})|. \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi({\\mathbf{B}})|=\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi_{1}({\\mathbf{B}})|+|\\phi_{2}({\\mathbf{B}})|+|\\phi_{3}({%&#10;\\mathbf{B}})|\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-|(\\phi_{1}\\land\\phi_{2})({\\mathbf{B}})|-|(\\phi_{1}\\land\\phi_{3})%&#10;({\\mathbf{B}})|\" display=\"inline\"><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-|(\\phi_{2}\\land\\phi_{3})({\\mathbf{B}})|+|(\\phi_{1}\\land\\phi_{2}%&#10;\\land\\phi_{3})({\\mathbf{B}})|.\" display=\"inline\"><mrow><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\n\n\nSo far, we have only unified formulas that are equivalent up to renaming variables.  \nIn our parameterized complexity setting where $\\phi$ is the parameter,\nthis does not yield a significant decrease\nin the complexity of computing  $|\\phi({\\mathbf{B}})|$.\nHowever, we will now observe a simplification that is more substantial\nin this sense.  \nNamely, one can verify that the formulas\n$\\phi_1 \\land \\phi_2$ and $\\phi_1\\land \\phi_2\\land \\phi_3$\nare identical.  So, if we identify their terms in this last \nexpression for $|\\phi({\\mathbf{B}})|$, we obtain a cancellation\nand arrive to the following expression:\n\n", "itemtype": "equation", "pos": 40527, "prevtext": "\n\n Now observe that the formulas $\\phi_1$, $\\phi_2$ and $\\phi_3$ \nare actually equivalent to each other up to renaming variables;\nconsequently,  these formulas\nare equivalent in that,\nfor any structure ${\\mathbf{B}}$,\nthey\nyield the same count: $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})| = |\\phi_3({\\mathbf{B}})|$.\nIn Section~\\ref{subsect:counting-equivalence}, we formalize\nand give a characterization of this notion of equivalence\n(on pp-formulas).\nThe formulas $\\phi_1 \\land \\phi_3$ and $\\phi_2 \\land \\phi_3$\nare also equivalent in this sense.  We may thus obtain\nthe following expression for $|\\phi({\\mathbf{B}})|$.\n\n \n", "index": 11, "text": "\\begin{align*}|\\phi({\\mathbf{B}})| = &3 \\cdot |\\phi_1({\\mathbf{B}})| - |(\\phi_1\\land \\phi_2)({\\mathbf{B}})| \\\\&- 2\\cdot |(\\phi_1\\land \\phi_3)({\\mathbf{B}})| + \n |(\\phi_1 \\land \\phi_2 \\land \\phi_3)({\\mathbf{B}})|. \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi({\\mathbf{B}})|=\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle 3\\cdot|\\phi_{1}({\\mathbf{B}})|-|(\\phi_{1}\\land\\phi_{2})({\\mathbf%&#10;{B}})|\" display=\"inline\"><mrow><mrow><mn>3</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-2\\cdot|(\\phi_{1}\\land\\phi_{3})({\\mathbf{B}})|+|(\\phi_{1}\\land%&#10;\\phi_{2}\\land\\phi_{3})({\\mathbf{B}})|.\" display=\"inline\"><mrow><mrow><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\nThe savings obtained by observing this cancellation are \nsignificant, in the following sense.\nThe  pp-formulas $\\phi_1 \\land \\phi_2$\nand $\\phi_1 \\land \\phi_2 \\land \\phi_3$, \nwhich were cancelled,\nwere the only formulas in the expression for $|\\phi({\\mathbf{B}})|$\nwhich did not have treewidth $1$; they had treewidth $2$.\nAs it is known that the runtime of evaluation algorithms\nfor quantifier-free pp-formulas scales with their treewidth~\\cite{Marx10-canyoubeat},\nthis reduction in treewidth yields a superior runtime for evaluating \n$|\\phi({\\mathbf{B}})|$.\n\n\n \n\n \n\\end{example}\n\nAs we have seen in the above examples, \ncounting on an ep-formula can, via inclusion-exclusion,\nreduces to counting on a finite set of pp-formulas.\n(This is carried out in our argument; see Section~\\ref{subsect:all-free}).\nAs just seen in Example~\\ref{ex:eqsecond}, there can be some subtlety\nin choosing a desirable set of pp-formulas to reduce to.\nOne question not addressed so far is how one can reduce\nfrom counting on a such obtained set of pp-formulas\nto counting on the original ep-formula.\nTo this end, let us revisit our first example.\n\n\n\\begin{example}\\label{ex:eqfirstrevisited}\n Consider again the formulas of Example~\\ref{ex:eqfirst}. \n  Assume that we are given access to an oracle \n  that lets us compute $|\\phi({\\mathbf{D}})|$,\n  for any structure ${\\mathbf{D}}$ of our choice. \n  We will see that, given a structure ${\\mathbf{B}}$, \n  we can compute $|\\phi_1({\\mathbf{B}})|$, $|\\phi_2({\\mathbf{B}})|$, and $|(\\phi_1\\land \\phi_2)({\\mathbf{B}})|$ efficiently using this oracle. \n\n  To see this, consider the structure ${\\mathbf{C}}$ with $E^{\\mathbf{C}} = \\{(1,2),(2,3),(3,4),(4,4)\\}$. It is easy to check that the formulas $\\phi_1$, $\\phi_2$ and $\\phi_1\\land \\phi_2$ all have a different number of answers with respect to ${\\mathbf{C}}$.  \n  Now note \n  that for every pp-formula $\\psi$ and every pair of structures \n  ${\\mathbf{D}}_1$, ${\\mathbf{D}}_2$ we have \n  $|\\psi({\\mathbf{D}}_1\\times {\\mathbf{D}}_2)|= |\\psi({\\mathbf{D}}_1)| \\cdot |\\psi({\\mathbf{D}}_2)|$. Querying the oracle for $|\\phi(\\cdot)|$ \n  on ${\\mathbf{B}} \\times {\\mathbf{C}}^i$ for \n  the values $i=0, 1, 2$,\n   we obtain the linear system\n\n", "itemtype": "equation", "pos": 41365, "prevtext": "\n\n\n\nSo far, we have only unified formulas that are equivalent up to renaming variables.  \nIn our parameterized complexity setting where $\\phi$ is the parameter,\nthis does not yield a significant decrease\nin the complexity of computing  $|\\phi({\\mathbf{B}})|$.\nHowever, we will now observe a simplification that is more substantial\nin this sense.  \nNamely, one can verify that the formulas\n$\\phi_1 \\land \\phi_2$ and $\\phi_1\\land \\phi_2\\land \\phi_3$\nare identical.  So, if we identify their terms in this last \nexpression for $|\\phi({\\mathbf{B}})|$, we obtain a cancellation\nand arrive to the following expression:\n\n", "index": 13, "text": "\n\\[|\\phi({\\mathbf{B}})| = 3 \\cdot |\\phi_1({\\mathbf{B}})| - 2\\cdot |(\\phi_1\\land \\phi_3)({\\mathbf{B}})| . \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"|\\phi({\\mathbf{B}})|=3\\cdot|\\phi_{1}({\\mathbf{B}})|-2\\cdot|(\\phi_{1}\\land\\phi_%&#10;{3})({\\mathbf{B}})|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mrow><mn>3</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " with\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nThe savings obtained by observing this cancellation are \nsignificant, in the following sense.\nThe  pp-formulas $\\phi_1 \\land \\phi_2$\nand $\\phi_1 \\land \\phi_2 \\land \\phi_3$, \nwhich were cancelled,\nwere the only formulas in the expression for $|\\phi({\\mathbf{B}})|$\nwhich did not have treewidth $1$; they had treewidth $2$.\nAs it is known that the runtime of evaluation algorithms\nfor quantifier-free pp-formulas scales with their treewidth~\\cite{Marx10-canyoubeat},\nthis reduction in treewidth yields a superior runtime for evaluating \n$|\\phi({\\mathbf{B}})|$.\n\n\n \n\n \n\\end{example}\n\nAs we have seen in the above examples, \ncounting on an ep-formula can, via inclusion-exclusion,\nreduces to counting on a finite set of pp-formulas.\n(This is carried out in our argument; see Section~\\ref{subsect:all-free}).\nAs just seen in Example~\\ref{ex:eqsecond}, there can be some subtlety\nin choosing a desirable set of pp-formulas to reduce to.\nOne question not addressed so far is how one can reduce\nfrom counting on a such obtained set of pp-formulas\nto counting on the original ep-formula.\nTo this end, let us revisit our first example.\n\n\n\\begin{example}\\label{ex:eqfirstrevisited}\n Consider again the formulas of Example~\\ref{ex:eqfirst}. \n  Assume that we are given access to an oracle \n  that lets us compute $|\\phi({\\mathbf{D}})|$,\n  for any structure ${\\mathbf{D}}$ of our choice. \n  We will see that, given a structure ${\\mathbf{B}}$, \n  we can compute $|\\phi_1({\\mathbf{B}})|$, $|\\phi_2({\\mathbf{B}})|$, and $|(\\phi_1\\land \\phi_2)({\\mathbf{B}})|$ efficiently using this oracle. \n\n  To see this, consider the structure ${\\mathbf{C}}$ with $E^{\\mathbf{C}} = \\{(1,2),(2,3),(3,4),(4,4)\\}$. It is easy to check that the formulas $\\phi_1$, $\\phi_2$ and $\\phi_1\\land \\phi_2$ all have a different number of answers with respect to ${\\mathbf{C}}$.  \n  Now note \n  that for every pp-formula $\\psi$ and every pair of structures \n  ${\\mathbf{D}}_1$, ${\\mathbf{D}}_2$ we have \n  $|\\psi({\\mathbf{D}}_1\\times {\\mathbf{D}}_2)|= |\\psi({\\mathbf{D}}_1)| \\cdot |\\psi({\\mathbf{D}}_2)|$. Querying the oracle for $|\\phi(\\cdot)|$ \n  on ${\\mathbf{B}} \\times {\\mathbf{C}}^i$ for \n  the values $i=0, 1, 2$,\n   we obtain the linear system\n\n", "index": 15, "text": "\\[ A\\begin{pmatrix} |\\phi_1({\\mathbf{B}})|\\\\ |\\phi_2({\\mathbf{B}})|\\\\ -|(\\phi_1\\land \\phi_2)({\\mathbf{B}})|\\end{pmatrix} = \\begin{pmatrix}(\\phi({\\mathbf{B}})\\\\ \\phi({\\mathbf{B}} \\times{\\mathbf{C}}) \\\\ \\phi({\\mathbf{B}} \\times{\\mathbf{C}}^2)\\end{pmatrix}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"A\\begin{pmatrix}|\\phi_{1}({\\mathbf{B}})|\\\\&#10;|\\phi_{2}({\\mathbf{B}})|\\\\&#10;-|(\\phi_{1}\\land\\phi_{2})({\\mathbf{B}})|\\end{pmatrix}=\\begin{pmatrix}(\\phi({%&#10;\\mathbf{B}})\\\\&#10;\\phi({\\mathbf{B}}\\times{\\mathbf{C}})\\\\&#10;\\phi({\\mathbf{B}}\\times{\\mathbf{C}}^{2})\\end{pmatrix}\" display=\"block\"><mrow><mrow><mi>A</mi><mo>\u2062</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc01</mi><mo>\u00d7</mo><mi>\ud835\udc02</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc01</mi><mo>\u00d7</mo><msup><mi>\ud835\udc02</mi><mn>2</mn></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n    Note that the entries of \n    \n    $A$\n    can be computed efficiently, and  the vector on the right-hand-side of the equation\n    can be provided by our oracle. The matrix $A$ is a Vandermonde matrix,\n    as a consequence of the choice of ${\\mathbf{C}}$. \nThus, the system has a unique solution and can be solved to \n determine $|\\phi_1({\\mathbf{B}})|$, $|\\phi_2({\\mathbf{B}})|$, and $|(\\phi_1\\land \\phi_2)({\\mathbf{B}})|$, as desired.\n\\end{example}\n\nIn Example~\\ref{ex:eqfirstrevisited} we have seen that,\nfor the particular ep-formula $\\phi$ discussed, counting on $\\phi$ is \nin a certain sense interreducible with counting\non the pp-formulas $\\{ \\phi_1, \\phi_2, \\phi_1 \\wedge \\phi_2 \\}$.\nThe statement of the\nequivalence theorem (Theorem~\\ref{thm:equivalence-theorem})\nholds that for \\emph{any} ep-formula $\\phi$, there \nis a finite set $\\phi^+$ of pp-formulas such that\none has this interreducibility.\n\n\n\n\n\\section{Proof of equivalence theorem}\n\\label{sect:proof-equiv-theorem}\n\n\n\nIn this section, we give a decidable characterization\nof \\emph{counting equivalence} \n(Section~\\ref{subsect:counting-equivalence});\nwe study a relaxation thereof which we call\n\\emph{semi-counting equivalence}\n(Section~\\ref{subsect:semi-counting-equivalence});\nwe prove the equivalence theorem\nin the particular case of all-free ep-formulas\n(Section~\\ref{subsect:all-free});\nand, we end by proving the equivalence theorem\nin its full generality\n(Section~\\ref{subsect:general-equivalence-theorem}).\nThroughout this section, we generally assume pp-formulas to be prenex.\n\n\\subsection{Counting equivalence}\n\\label{subsect:counting-equivalence}\n\nAs we have seen in the examples of Section~\\ref{sct:examples}, it will be important to see when two different pp-formulas give same number of answers for every structure, because it will allow us to make simplifications in formulas we get by inclusion-exclusion. To this end, we make the following definition.\n\n\\begin{definition}\nDefine two fo-formulas $\\phi(V), \\phi'(V')$ to be\n \\emph{counting equivalent} if they are over the same vocabulary $\\tau$\n and for each finite $\\tau$-structure ${\\mathbf{B}}$ \n it holds that $|\\phi({\\mathbf{B}})| = |\\phi'({\\mathbf{B}})|$.\n\\end{definition}\n\nIn this subsection, we characterize counting equivalence \nfor pp-formulas. To approach the characterization, we start off with an example.\n\n\\begin{example}\\label{ex:rename}\nIt is apparent that logically equivalent formulas are counting equivalent, but the converse direction is not true. To see this, consider the pp-formulas $\\phi_1(x,y) = E(x, y)$ and $\\phi_2(w,z)= E(w,z)$. Obviously, $\\phi_1$ and $\\phi_2$ are counting equivalent (they just count the number of tuples in the relation $E$ of a structure ${\\mathbf{B}}$). But $\\phi_1$ and $\\phi_2$ are not logically equivalent;\nindeed, the assignments in $\\phi_1({\\mathbf{B}})$ and $\\phi_2({\\mathbf{B}})$ assign values to different variables. \n\nNote that one way of witnessing the counting equivalence of $\\phi_1$ and $\\phi_2$ is simply renaming the variable $w$ to $x$ and $z$ to $y$ to get equivalent formulas. Since this syntactic renaming \nobviously does not change the number of satisfying assignments, \none can conclude that $\\phi_1$ and $\\phi_2$ are counting equivalent.\n\\end{example}\n\nExample~\\ref{ex:rename} motivates the following definition.\n\n\\begin{definition}\nWe say that\ntwo pp-formulas\n$({\\mathbf{A}}, S)$, $({\\mathbf{A}}', S')$ \n over the same signature\n are \\emph{renaming equivalent}\nif there exist surjections \n$h: S \\to S'$ and $h': S' \\to S$\n that can be extended to homomorphisms \n $\\bar{h} : {\\mathbf{A}} \\rightarrow {\\mathbf{A}}'$ and \n $\\bar{h'}:{\\mathbf{A}}'\\rightarrow {\\mathbf{A}}$, respectively.\n\\end{definition}\n\nInformally speaking, on pp-formulas, \n \n\n\ntwo formulas are renaming equivalent\nif they become logically equivalent after a renaming of variables,\nas occurred in \nExample~\\ref{ex:rename}.\nHence, renaming equivalence is a relaxation of logical equivalence.\nRecall that logical equivalence of pp-formulas was characterized,\nin Theorem~\\ref{thm:ChandraMerlin}.\n\n\n\nThe main theorem of this subsection is that renaming equivalence does not only imply counting equivalence but is actually equivalent to it.\n\n\\begin{theorem}\\label{thm:renamingandcounting}\nTwo pp-formulas $\\phi_1(S_1), \\phi_2(S_2)$ are counting equivalent\nif and only if they are renaming equivalent.\n\\end{theorem}\n\nNote that Theorem~\\ref{thm:renamingandcounting} gives a syntactic/algebraic characterization of counting equivalence which makes counting equivalence decidable by a straightforward algorithm and in fact even puts it into $\\mathrm{NP}$.\n\nBefore we prove Theorem \\ref{thm:renamingandcounting}, \n we start off with an simple observation that will be helpful in the proof.\n\n\\begin{observation}\\label{obs:samevariables}\n Let $\\phi$ and $\\phi'$ be counting equivalent pp-formulas. Then $|{\\mathrm{lib}}(\\phi)| =|{\\mathrm{lib}}(\\phi')|$.\n\\end{observation}\n\n\\begin{proof}\n Let ${\\mathbf{C}}$ be a structure that interprets every relation symbol in $R$ of $\\phi$ by $R^{\\mathbf{C}} := \\{0,1\\}^{\\mathsf{arity}(R)}$. Then $|\\phi({\\mathbf{C}})| = 2^{|{\\mathrm{lib}}(\\phi)|}$ and $|\\phi'({\\mathbf{C}})|= 2^{|{\\mathrm{lib}}(\\phi')|}$ and the claim follows directly.\n\\end{proof}\n\n\n\\begin{proof} (Theorem~\\ref{thm:renamingandcounting})\nWe begin with the backward direction;\nlet $h_1: S_1 \\to S_2$ and $h_2: S_2 \\to S_1$ be the surjections\nfrom the definition of renaming equivalence.\nThe existence of these surjections implies that $|S_1| = |S_2|$\nand that each of $h_1$, $h_2$ is a bijection.\nLet ${\\mathbf{B}}$ be an arbitrary structure.\nFor each $f: S_2 \\to B$ in  $\\phi_2({\\mathbf{B}})$,\nit is straightforward to verify that the\ncomposition $f(h_1)$ is in $\\phi_1({\\mathbf{B}})$.\nSince the mapping that takes each such $f$ to $f(h_1)$\nis injective (due to $h_1$ being a bijection), \nwe obtain that $|\\phi_1({\\mathbf{B}})| \\geq |\\phi_2({\\mathbf{B}})|$.\nBy symmetric reasoning, we can obtain that\n$|\\phi_1({\\mathbf{B}})| \\leq |\\phi_2({\\mathbf{B}})|$,\nand we conclude that\n$|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$.\n\n For the other direction, let $\\phi_1(S_1)$ and $\\phi_2(S_2)$ be two pp-formulas over a common vocabulary $\\tau$ \n that are not renaming equivalent; \n let $({\\mathbf{A}}_1, S_1)$ and $({\\mathbf{A}}_2, S_2)$ \n be the corresponding structures. \n By way of contradiction, assume that $\\phi_1$ and $\\phi_2$ are counting equivalent. \n If it holds that\n $|{\\mathrm{lib}}(\\phi_1)| \\ne |{\\mathrm{lib}}(\\phi_2)|$, we are done by \n Observation~\\ref{obs:samevariables}. So we may assume, after potentially renaming some variables, that ${\\mathrm{lib}}(\\phi_1)={\\mathrm{lib}}(\\phi_2)=:S$.\n \nWhen ${\\mathbf{C}}$, ${\\mathbf{D}}$ are structures \nwith $S \\subseteq C \\cap D$,\ndefine $\\hom({\\mathbf{C}}, {\\mathbf{D}}, S)$ to be the set of mappings\nfrom $S$ to $D$ that can be extended to a homomorphism \nfrom ${\\mathbf{C}}$ to ${\\mathbf{D}}$;\n denote by ${\\mathrm{surj}}({\\mathbf{C}}, {\\mathbf{D}}, S)$ \n the surjections $h :S\\rightarrow S$ that lie in $\\hom({\\mathbf{C}}, {\\mathbf{D}}, S)$. \n\n\n As $({\\mathbf{A}}_1, S_1)$ and $({\\mathbf{A}}_2, S_2)$ are by hypothesis\n not renaming equivalent, \n we may assume, without loss of generality, that ${\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)= \\emptyset$. For $T\\subseteq S$ let us use\n $\\hom_T({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)$ to denote the set of mappings $h\\in \\hom({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)$ such that $h(S)\\subseteq  T$. By inclusion-exclusion we get \n\n", "itemtype": "equation", "pos": 43943, "prevtext": " with\n", "index": 17, "text": "\\[A = \\begin{pmatrix} 1 & 1 & 1 \\\\ |\\phi_1({\\mathbf{C}})| & |\\phi_2({\\mathbf{C}})| & |(\\phi_1\\land \\phi_2)({\\mathbf{C}})|\\\\ |\\phi_1({\\mathbf{C}})|^2 & |\\phi_2({\\mathbf{C}})|^2 & |(\\phi_1\\land \\phi_2)({\\mathbf{C}})|^2\n    \\end{pmatrix}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"A=\\begin{pmatrix}1&amp;1&amp;1\\\\&#10;|\\phi_{1}({\\mathbf{C}})|&amp;|\\phi_{2}({\\mathbf{C}})|&amp;|(\\phi_{1}\\land\\phi_{2})({%&#10;\\mathbf{C}})|\\\\&#10;|\\phi_{1}({\\mathbf{C}})|^{2}&amp;|\\phi_{2}({\\mathbf{C}})|^{2}&amp;|(\\phi_{1}\\land\\phi_%&#10;{2})({\\mathbf{C}})|^{2}\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mtd><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mtd><mtd columnalign=\"center\"><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mn>2</mn></msup></mtd><mtd columnalign=\"center\"><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mn>2</mn></msup></mtd><mtd columnalign=\"center\"><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc02</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mn>2</mn></msup></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n \nFor $i\\ge 0$ let $\\hom_{i,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ be the set of mappings $h\\in \\hom({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ such that $h$ maps exactly $i$ variables from $S$ into $T$. Now for each $j=1,\\ldots , |S|$ we construct a new structure ${\\mathbf{D}}_{j,T}$ over the domain $D_{j,T}$. To this end, let $a^{(1)}, \\ldots, a^{(j)}$ be copies of $a\\in T$ that are not in $A_2$. Then we set \n", "itemtype": "equation", "pos": 51686, "prevtext": "\n    Note that the entries of \n    \n    $A$\n    can be computed efficiently, and  the vector on the right-hand-side of the equation\n    can be provided by our oracle. The matrix $A$ is a Vandermonde matrix,\n    as a consequence of the choice of ${\\mathbf{C}}$. \nThus, the system has a unique solution and can be solved to \n determine $|\\phi_1({\\mathbf{B}})|$, $|\\phi_2({\\mathbf{B}})|$, and $|(\\phi_1\\land \\phi_2)({\\mathbf{B}})|$, as desired.\n\\end{example}\n\nIn Example~\\ref{ex:eqfirstrevisited} we have seen that,\nfor the particular ep-formula $\\phi$ discussed, counting on $\\phi$ is \nin a certain sense interreducible with counting\non the pp-formulas $\\{ \\phi_1, \\phi_2, \\phi_1 \\wedge \\phi_2 \\}$.\nThe statement of the\nequivalence theorem (Theorem~\\ref{thm:equivalence-theorem})\nholds that for \\emph{any} ep-formula $\\phi$, there \nis a finite set $\\phi^+$ of pp-formulas such that\none has this interreducibility.\n\n\n\n\n\\section{Proof of equivalence theorem}\n\\label{sect:proof-equiv-theorem}\n\n\n\nIn this section, we give a decidable characterization\nof \\emph{counting equivalence} \n(Section~\\ref{subsect:counting-equivalence});\nwe study a relaxation thereof which we call\n\\emph{semi-counting equivalence}\n(Section~\\ref{subsect:semi-counting-equivalence});\nwe prove the equivalence theorem\nin the particular case of all-free ep-formulas\n(Section~\\ref{subsect:all-free});\nand, we end by proving the equivalence theorem\nin its full generality\n(Section~\\ref{subsect:general-equivalence-theorem}).\nThroughout this section, we generally assume pp-formulas to be prenex.\n\n\\subsection{Counting equivalence}\n\\label{subsect:counting-equivalence}\n\nAs we have seen in the examples of Section~\\ref{sct:examples}, it will be important to see when two different pp-formulas give same number of answers for every structure, because it will allow us to make simplifications in formulas we get by inclusion-exclusion. To this end, we make the following definition.\n\n\\begin{definition}\nDefine two fo-formulas $\\phi(V), \\phi'(V')$ to be\n \\emph{counting equivalent} if they are over the same vocabulary $\\tau$\n and for each finite $\\tau$-structure ${\\mathbf{B}}$ \n it holds that $|\\phi({\\mathbf{B}})| = |\\phi'({\\mathbf{B}})|$.\n\\end{definition}\n\nIn this subsection, we characterize counting equivalence \nfor pp-formulas. To approach the characterization, we start off with an example.\n\n\\begin{example}\\label{ex:rename}\nIt is apparent that logically equivalent formulas are counting equivalent, but the converse direction is not true. To see this, consider the pp-formulas $\\phi_1(x,y) = E(x, y)$ and $\\phi_2(w,z)= E(w,z)$. Obviously, $\\phi_1$ and $\\phi_2$ are counting equivalent (they just count the number of tuples in the relation $E$ of a structure ${\\mathbf{B}}$). But $\\phi_1$ and $\\phi_2$ are not logically equivalent;\nindeed, the assignments in $\\phi_1({\\mathbf{B}})$ and $\\phi_2({\\mathbf{B}})$ assign values to different variables. \n\nNote that one way of witnessing the counting equivalence of $\\phi_1$ and $\\phi_2$ is simply renaming the variable $w$ to $x$ and $z$ to $y$ to get equivalent formulas. Since this syntactic renaming \nobviously does not change the number of satisfying assignments, \none can conclude that $\\phi_1$ and $\\phi_2$ are counting equivalent.\n\\end{example}\n\nExample~\\ref{ex:rename} motivates the following definition.\n\n\\begin{definition}\nWe say that\ntwo pp-formulas\n$({\\mathbf{A}}, S)$, $({\\mathbf{A}}', S')$ \n over the same signature\n are \\emph{renaming equivalent}\nif there exist surjections \n$h: S \\to S'$ and $h': S' \\to S$\n that can be extended to homomorphisms \n $\\bar{h} : {\\mathbf{A}} \\rightarrow {\\mathbf{A}}'$ and \n $\\bar{h'}:{\\mathbf{A}}'\\rightarrow {\\mathbf{A}}$, respectively.\n\\end{definition}\n\nInformally speaking, on pp-formulas, \n \n\n\ntwo formulas are renaming equivalent\nif they become logically equivalent after a renaming of variables,\nas occurred in \nExample~\\ref{ex:rename}.\nHence, renaming equivalence is a relaxation of logical equivalence.\nRecall that logical equivalence of pp-formulas was characterized,\nin Theorem~\\ref{thm:ChandraMerlin}.\n\n\n\nThe main theorem of this subsection is that renaming equivalence does not only imply counting equivalence but is actually equivalent to it.\n\n\\begin{theorem}\\label{thm:renamingandcounting}\nTwo pp-formulas $\\phi_1(S_1), \\phi_2(S_2)$ are counting equivalent\nif and only if they are renaming equivalent.\n\\end{theorem}\n\nNote that Theorem~\\ref{thm:renamingandcounting} gives a syntactic/algebraic characterization of counting equivalence which makes counting equivalence decidable by a straightforward algorithm and in fact even puts it into $\\mathrm{NP}$.\n\nBefore we prove Theorem \\ref{thm:renamingandcounting}, \n we start off with an simple observation that will be helpful in the proof.\n\n\\begin{observation}\\label{obs:samevariables}\n Let $\\phi$ and $\\phi'$ be counting equivalent pp-formulas. Then $|{\\mathrm{lib}}(\\phi)| =|{\\mathrm{lib}}(\\phi')|$.\n\\end{observation}\n\n\\begin{proof}\n Let ${\\mathbf{C}}$ be a structure that interprets every relation symbol in $R$ of $\\phi$ by $R^{\\mathbf{C}} := \\{0,1\\}^{\\mathsf{arity}(R)}$. Then $|\\phi({\\mathbf{C}})| = 2^{|{\\mathrm{lib}}(\\phi)|}$ and $|\\phi'({\\mathbf{C}})|= 2^{|{\\mathrm{lib}}(\\phi')|}$ and the claim follows directly.\n\\end{proof}\n\n\n\\begin{proof} (Theorem~\\ref{thm:renamingandcounting})\nWe begin with the backward direction;\nlet $h_1: S_1 \\to S_2$ and $h_2: S_2 \\to S_1$ be the surjections\nfrom the definition of renaming equivalence.\nThe existence of these surjections implies that $|S_1| = |S_2|$\nand that each of $h_1$, $h_2$ is a bijection.\nLet ${\\mathbf{B}}$ be an arbitrary structure.\nFor each $f: S_2 \\to B$ in  $\\phi_2({\\mathbf{B}})$,\nit is straightforward to verify that the\ncomposition $f(h_1)$ is in $\\phi_1({\\mathbf{B}})$.\nSince the mapping that takes each such $f$ to $f(h_1)$\nis injective (due to $h_1$ being a bijection), \nwe obtain that $|\\phi_1({\\mathbf{B}})| \\geq |\\phi_2({\\mathbf{B}})|$.\nBy symmetric reasoning, we can obtain that\n$|\\phi_1({\\mathbf{B}})| \\leq |\\phi_2({\\mathbf{B}})|$,\nand we conclude that\n$|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$.\n\n For the other direction, let $\\phi_1(S_1)$ and $\\phi_2(S_2)$ be two pp-formulas over a common vocabulary $\\tau$ \n that are not renaming equivalent; \n let $({\\mathbf{A}}_1, S_1)$ and $({\\mathbf{A}}_2, S_2)$ \n be the corresponding structures. \n By way of contradiction, assume that $\\phi_1$ and $\\phi_2$ are counting equivalent. \n If it holds that\n $|{\\mathrm{lib}}(\\phi_1)| \\ne |{\\mathrm{lib}}(\\phi_2)|$, we are done by \n Observation~\\ref{obs:samevariables}. So we may assume, after potentially renaming some variables, that ${\\mathrm{lib}}(\\phi_1)={\\mathrm{lib}}(\\phi_2)=:S$.\n \nWhen ${\\mathbf{C}}$, ${\\mathbf{D}}$ are structures \nwith $S \\subseteq C \\cap D$,\ndefine $\\hom({\\mathbf{C}}, {\\mathbf{D}}, S)$ to be the set of mappings\nfrom $S$ to $D$ that can be extended to a homomorphism \nfrom ${\\mathbf{C}}$ to ${\\mathbf{D}}$;\n denote by ${\\mathrm{surj}}({\\mathbf{C}}, {\\mathbf{D}}, S)$ \n the surjections $h :S\\rightarrow S$ that lie in $\\hom({\\mathbf{C}}, {\\mathbf{D}}, S)$. \n\n\n As $({\\mathbf{A}}_1, S_1)$ and $({\\mathbf{A}}_2, S_2)$ are by hypothesis\n not renaming equivalent, \n we may assume, without loss of generality, that ${\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)= \\emptyset$. For $T\\subseteq S$ let us use\n $\\hom_T({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)$ to denote the set of mappings $h\\in \\hom({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)$ such that $h(S)\\subseteq  T$. By inclusion-exclusion we get \n\n", "index": 19, "text": "\\[|{\\mathrm{surj}}({\\phi_1},{\\phi_2},S)| = \\sum_{T\\subseteq S} (-1)^{|S|-|T|} |\\hom_T({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)|.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"|{\\mathrm{surj}}({\\phi_{1}},{\\phi_{2}},S)|=\\sum_{T\\subseteq S}(-1)^{|S|-|T|}|%&#10;\\hom_{T}({\\mathbf{A}}_{1},{\\mathbf{A}}_{2},S)|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>surj</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>,</mo><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>T</mi><mo>\u2286</mo><mi>S</mi></mrow></munder><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mi>T</mi><mo stretchy=\"false\">|</mo></mrow></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>hom</mi><mi>T</mi></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc00</mi><mn>1</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mn>2</mn></msub><mo>,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " We define a mapping $B:A_2\\rightarrow {\\mathcal{P}}(D_{j,T})$, where ${\\mathcal{P}}(D_{j,T})$ is the power set of $D_{j,T}$, by\n", "itemtype": "equation", "pos": -1, "prevtext": "\n \nFor $i\\ge 0$ let $\\hom_{i,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ be the set of mappings $h\\in \\hom({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ such that $h$ maps exactly $i$ variables from $S$ into $T$. Now for each $j=1,\\ldots , |S|$ we construct a new structure ${\\mathbf{D}}_{j,T}$ over the domain $D_{j,T}$. To this end, let $a^{(1)}, \\ldots, a^{(j)}$ be copies of $a\\in T$ that are not in $A_2$. Then we set \n", "index": 21, "text": "\\begin{align*}D_{j,T}:= \\{a^{(k)}\\mid a\\in A_2, a\\in T, k\\in [j]\\} \\cup (A_2\\setminus T).\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle D_{j,T}:=\\{a^{(k)}\\mid a\\in A_{2},a\\in T,k\\in[j]\\}\\cup(A_{2}%&#10;\\setminus T).\" display=\"inline\"><mrow><mrow><msub><mi>D</mi><mrow><mi>j</mi><mo>,</mo><mi>T</mi></mrow></msub><mo>:=</mo><mrow><mrow><mo stretchy=\"false\">{</mo><msup><mi>a</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo>\u2223</mo><mrow><mrow><mi>a</mi><mo>\u2208</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>,</mo><mrow><mrow><mi>a</mi><mo>\u2208</mo><mi>T</mi></mrow><mo>,</mo><mrow><mi>k</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow><mo>\u222a</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>A</mi><mn>2</mn></msub><mo>\u2216</mo><mi>T</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nFor every relation symbol $R\\in \\tau$ we define\n", "itemtype": "equation", "pos": 52444, "prevtext": " We define a mapping $B:A_2\\rightarrow {\\mathcal{P}}(D_{j,T})$, where ${\\mathcal{P}}(D_{j,T})$ is the power set of $D_{j,T}$, by\n", "index": 23, "text": "\n\\[B(a):= \\begin{cases}\n            \\{a^{(k)}\\mid k\\in [j]\\}\\}, & \\text{if } a\\in T\\\\\n            \\{a\\}, & \\text{otherwise}.\n           \\end{cases}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"B(a):=\\begin{cases}\\{a^{(k)}\\mid k\\in[j]\\}\\},&amp;\\text{if }a\\in T\\\\&#10;\\{a\\},&amp;\\text{otherwise}.\\end{cases}\" display=\"block\"><mrow><mrow><mi>B</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">{</mo><msup><mi>a</mi><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></msup><mo>\u2223</mo><mi>k</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">}</mo></mrow><mo stretchy=\"false\">}</mo><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>a</mi></mrow><mo>\u2208</mo><mi>T</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo stretchy=\"false\">{</mo><mi>a</mi><mo stretchy=\"false\">}</mo></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"left\"><mrow><mtext>otherwise</mtext><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\nThen every $h\\in \\hom_{i,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ corresponds to $j^i$ mappings in $\\hom({\\mathbf{A}}_1, {\\mathbf{D}}_{j,T},S)$. Thus for each $j$ we get\n", "itemtype": "equation", "pos": 52641, "prevtext": "\nFor every relation symbol $R\\in \\tau$ we define\n", "index": 25, "text": "\n\\[ R^{{\\mathbf{D}}_{T,j}} := \\bigcup_{(d_1, \\ldots, d_s)\\in R^{{\\mathbf{A}}_2}} B(d_1)\\times \\ldots \\times B(d_s).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"R^{{\\mathbf{D}}_{T,j}}:=\\bigcup_{(d_{1},\\ldots,d_{s})\\in R^{{\\mathbf{A}}_{2}}}%&#10;B(d_{1})\\times\\ldots\\times B(d_{s}).\" display=\"block\"><mrow><mrow><msup><mi>R</mi><msub><mi>\ud835\udc03</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub></msup><mo>:=</mo><mrow><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c3</mo><mrow><mrow><mo stretchy=\"false\">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><msup><mi>R</mi><msub><mi>\ud835\udc00</mi><mn>2</mn></msub></msup></mrow></munder><mrow><mrow><mrow><mi>B</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u00d7</mo><mi mathvariant=\"normal\">\u2026</mi><mo>\u00d7</mo><mi>B</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>d</mi><mi>s</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " This is a linear system of equations and the corresponding matrix is a Vandermonde matrix; consequently, the value $\\hom_{T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S) = \\hom_{|S|,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ can {{efficiently}} be computed from $|\\hom({\\mathbf{A}}_1, {\\mathbf{D}},S)|=|\\phi_1({\\mathbf{D}})|$ for some structures ${\\mathbf{D}}$. \n\nWe can similarly determine \n{{the values}} $|\\hom_T({\\mathbf{A}}_2, {\\mathbf{D}}, S)|$\nas a function of $|\\phi_2({\\mathbf{D}})|$ for the same structures ${\\mathbf{D}}$.\nSince $|\\phi_1({\\mathbf{D}})| = |\\phi_2({\\mathbf{D}})|$ for every structure ${\\mathbf{D}}$ by assumption, it follows that for every $T\\subseteq S$ we have \n$|\\hom_{T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)| = |\\hom_{T}({\\mathbf{A}}_2, {\\mathbf{A}}_2,S)|.$\n\nBut then we have \n$|{\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)| = |{\\mathrm{surj}}({\\mathbf{A}}_2, {\\mathbf{A}}_2, S)|.$\n\nSince \n${\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)= \\emptyset$ and ${\\mathrm{id}}\\in {\\mathrm{surj}}({\\mathbf{A}}_2, {\\mathbf{A}}_2, S)$, this is a contradiction. Consequently, $\\phi_1$ and $\\phi_2$ are not counting equivalent.\n\\end{proof}\n\n\n\\subsection{Semi-counting equivalence}\n\\label{subsect:semi-counting-equivalence}\n\nIn this subsection, we study a\nrelaxation of the notion of \\emph{counting equivalence}. This notion will be necessary when we emulate the approach of Example~\\ref{ex:eqfirstrevisited} in the proof of the Equivalence theorem: we will again construct a system of linear equations that we want to solve. In order to ensure solvability, we will make sure that the matrix of the system is again a Vandermonde matrix which in particular means that all its entries must be positive. Consequently, since the entries are of the form $|\\phi({\\mathbf{C}})|^k$ for pp-formulas $\\phi$ some carefully chosen structure ${\\mathbf{C}}$ and integers $k$, it will be necessary to understand counting equivalence in the case where $\\phi({\\mathbf{C}})$ is non-empty. The necessary notion is formalized by the following definition.\n\n\\begin{definition}\nCall two prenex pp-formulas $\\phi_1(V_1)$, $\\phi_2(V_2)$ \non the same vocabulary\n\\emph{semi-counting equivalent}\nif for each finite structure ${\\mathbf{B}}$\nsuch that $|\\phi_1({\\mathbf{B}})| > 0$ and $|\\phi_2({\\mathbf{B}})| > 0$,\nit holds that $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$.\n\\end{definition}\n\n\\begin{example}\n The pp-formulas $\\phi_1(x,y)= E(x,y)$ and \n $\\phi_2(x,y)=\\exists z (E(x,y)\\land F(z))$ are not counting equivalent, because for every structure ${\\mathbf{B}}$ for which $F^{\\mathbf{B}}=\\emptyset$, we have $|\\phi_2({\\mathbf{B}})| = 0$ while $|\\phi_1({\\mathbf{B}})|$ may be non-zero if $E^{{\\mathbf{B}}}$ is non-empty. But if we have for a structure ${\\mathbf{B}}$ such that $|\\phi_2({\\mathbf{B}})|>0$, then $F^{\\mathbf{B}}\\ne \\emptyset$ and it is straightforward to verify that $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$. Consequently, $\\phi_1$ and $\\phi_2$ are semi-counting equivalent.\n\\end{example}\n\n\nFor each free prenex pp-formula $\\phi(V)$, define $\\widehat{\\phi}(V)$ \nto be the pp-formula\nobtained from $\\phi$ \nby removing each atom\nthat occurs in a non-liberal component of $\\phi$\n(a component of $\\phi$ not having liberal variables).\n\n\n\n\n\n\\begin{example}\nConsider the pp-formula $\\phi$ discussed\n in Examples~\\ref{ex:pp-formula}\nand~\\ref{ex:pp-formula-components}.\nThis pp-formula has $4$ components, namely, the pp-formulas\n$\\psi_1(x, x')$,\n$\\psi_2(y)$,\n$\\psi_3(z)$,\nand\n$\\psi_4(\\emptyset)$\ndefined in Example~\\ref{ex:pp-formula-components}.\nThe formulas $\\psi_1$, $\\psi_2$, and $\\psi_3$ are liberal,\nbut the formula $\\psi_4$ is not liberal.\nRecall that \n$\\phi(x,x',y,z) = \\exists y' \\exists u \\exists v \\exists w (E(x, x') \\wedge E(y,y') \\wedge F(u,v) \\wedge G(u,w))$\nand that we have\n$\\psi_4(\\emptyset) = \\exists u \\exists v \\exists w (F(u,v) \\wedge G(u,w))$.\nHence, $\\widehat{\\phi}(x,x',y,z)$ is the formula\n$\\exists y' \\exists u \\exists v \\exists w \n(E(x, x') \\wedge E(y,y')).$\n\\end{example}\n\n\nThe following characterization of semi-counting equivalence\n is the main theorem of this subsection.\n\n\\begin{theorem}\\label{thm:semiequichar}\nLet $\\phi_1(V_1), \\phi_2(V_2)$ be two free prenex pp-formulas.\nIt holds that $\\phi_1(V_1)$ and $\\phi_2(V_2)$\nare semi-counting equivalent\nif and only if $\\widehat{\\phi_1}(V_1)$ and $\\widehat{\\phi_2}(V_2)$ are counting equivalent.\n\\end{theorem}\n\nWe will use the following proposition in the proof of Theorem~\\ref{thm:semiequichar}.\n\n\\begin{proposition}\\label{prop:samesolutions}\n Let $\\phi(V)$ be a free prenex pp-for\\-mula. Then for every structure ${\\mathbf{B}}$ we have $\\phi({\\mathbf{B}})=\\emptyset$ or $\\phi({\\mathbf{B}})=\\widehat{\\phi}({\\mathbf{B}})$.\n\\end{proposition}\n\n\\begin{proof}\n Let ${\\mathbf{B}}$ be a structure. \nLet $\\psi$ be the conjunction of the components deleted from $\\phi$\nto obtain $\\widehat{\\phi}$.\nIf $\\psi$ is false on ${\\mathbf{B}}$, then obviously $\\phi({\\mathbf{B}}) = \\emptyset$.\nOtherwise, $\\psi$ is true on ${\\mathbf{B}}$, and for any assignment $f: V \\to B$,\nit holds that ${\\mathbf{B}}, f \\models \\phi$ if and only if ${\\mathbf{B}}, f \\models \\widehat{\\phi}$.\n\\end{proof}\n\n\n\\begin{proof}  (Theorem~\\ref{thm:semiequichar})\n Assume first that $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ are counting equivalent. Let ${\\mathbf{B}}$ be a structure. Then if $|\\phi_1({\\mathbf{B}})|> 0$ and $|\\phi_2({\\mathbf{B}})|> 0$, we have by Proposition~\\ref{prop:samesolutions} and counting equivalence of $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ that \n \n$|\\phi_1({\\mathbf{B}})| = |\\widehat{\\phi_1}({\\mathbf{B}})| = |\\widehat{\\phi_2}({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$,\n so $\\phi_1$ and $\\phi_2$ are semi-counting equivalent.\n \n For the other direction let now $\\phi_1$ and $\\phi_2$ be semi-counting equivalent. By way of contradiction, we assume that $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ are not counting equivalent. Then by definition there is a structure ${\\mathbf{B}}$ such that $|\\widehat{\\phi_1}({\\mathbf{B}})|\\ne |\\widehat{\\phi_2}({\\mathbf{B}})|$. \n Note that each component of $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$\n  has a liberal variable.\n \nLet ${\\mathbf{I}} = {\\mathbf{I}}_{\\tau}$,\nwhere $\\tau$ is the vocabulary of $\\phi_1$ and $\\phi_2$.\nFor each $k\\in \\mathbb{N}$ we denote by ${\\mathbf{B}}+k{\\mathbf{I}}$ the structure we get from ${\\mathbf{B}}$ by disjoint union with $k$ copies of ${\\mathbf{I}}$. Note that for $k>0$ we have $|\\phi({\\mathbf{B}} +k{\\mathbf{I}})| > 0$ for every pp-formula $\\phi$. Consequently, for every $k>0$ we have $|\\phi_1({\\mathbf{B}}+k{\\mathbf{I}})| = |\\widehat{\\phi_1}({\\mathbf{B}}+k{\\mathbf{I}})|$ and $|\\phi_2({\\mathbf{B}}+k{\\mathbf{I}})| = |\\widehat{\\phi_2}({\\mathbf{B}}+k{\\mathbf{I}})|$ by Proposition~\\ref{prop:samesolutions}. By the semi-counting equivalence of $\\phi_1$ and $\\phi_2$ we also have $|\\phi_1({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\phi_2({\\mathbf{B}} +k{\\mathbf{I}})|$ for all $k>0$. It follows that $|\\widehat{\\phi_1}({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\widehat{\\phi_2}({\\mathbf{B}} +k{\\mathbf{I}})|$ for $k>0$.\n\nLet $\\phi_{1,1}, \\ldots, \\phi_{1,n}$ be \nthe components of $\\widehat{\\phi_1}$ and \nlet $\\phi_{2,1}, \\ldots , \\phi_{2,m}$ be \nthe  components of $\\widehat{\\phi_2}$. \nBecause every component of $\\widehat{\\phi_1}$ has a liberal variable, \nwe have \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\nThen every $h\\in \\hom_{i,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ corresponds to $j^i$ mappings in $\\hom({\\mathbf{A}}_1, {\\mathbf{D}}_{j,T},S)$. Thus for each $j$ we get\n", "index": 27, "text": "\\[\\sum_{i=1}^{|S|} j^i |\\hom_{i,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)| = |\\hom({\\mathbf{A}}_1,{\\mathbf{D}}_{j,T}, S)|.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"\\sum_{i=1}^{|S|}j^{i}|\\hom_{i,T}({\\mathbf{A}}_{1},{\\mathbf{A}}_{2},S)|=|\\hom({%&#10;\\mathbf{A}}_{1},{\\mathbf{D}}_{j,T},S)|.\" display=\"block\"><mrow><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo stretchy=\"false\">|</mo><mi>S</mi><mo stretchy=\"false\">|</mo></mrow></munderover><mrow><msup><mi>j</mi><mi>i</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>hom</mi><mrow><mi>i</mi><mo>,</mo><mi>T</mi></mrow></msub><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc00</mi><mn>1</mn></msub><mo>,</mo><msub><mi>\ud835\udc00</mi><mn>2</mn></msub><mo>,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mi>hom</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc00</mi><mn>1</mn></msub><mo>,</mo><msub><mi>\ud835\udc03</mi><mrow><mi>j</mi><mo>,</mo><mi>T</mi></mrow></msub><mo>,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nWe can express\n$|\\widehat{\\phi_2}({\\mathbf{B}}+k{\\mathbf{I}})|$ analogously.\n\n\nThe expressions are polynomials in $k$ and they are equal for every positive integer $k$ by the observations above;\nthus the coefficients of the polynomials must coincide.\n\nThe coefficients of $k^0$, namely \nthe values\n$\\prod_{j\\in [n]}|\\phi_{1,j}({\\mathbf{B}})|$ and\n$\\prod_{j\\in [m]}|\\phi_{2,j}({\\mathbf{B}})|$, are thus equal. But then we get \n", "itemtype": "equation", "pos": 60338, "prevtext": " This is a linear system of equations and the corresponding matrix is a Vandermonde matrix; consequently, the value $\\hom_{T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S) = \\hom_{|S|,T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)$ can {{efficiently}} be computed from $|\\hom({\\mathbf{A}}_1, {\\mathbf{D}},S)|=|\\phi_1({\\mathbf{D}})|$ for some structures ${\\mathbf{D}}$. \n\nWe can similarly determine \n{{the values}} $|\\hom_T({\\mathbf{A}}_2, {\\mathbf{D}}, S)|$\nas a function of $|\\phi_2({\\mathbf{D}})|$ for the same structures ${\\mathbf{D}}$.\nSince $|\\phi_1({\\mathbf{D}})| = |\\phi_2({\\mathbf{D}})|$ for every structure ${\\mathbf{D}}$ by assumption, it follows that for every $T\\subseteq S$ we have \n$|\\hom_{T}({\\mathbf{A}}_1, {\\mathbf{A}}_2,S)| = |\\hom_{T}({\\mathbf{A}}_2, {\\mathbf{A}}_2,S)|.$\n\nBut then we have \n$|{\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)| = |{\\mathrm{surj}}({\\mathbf{A}}_2, {\\mathbf{A}}_2, S)|.$\n\nSince \n${\\mathrm{surj}}({\\mathbf{A}}_1, {\\mathbf{A}}_2, S)= \\emptyset$ and ${\\mathrm{id}}\\in {\\mathrm{surj}}({\\mathbf{A}}_2, {\\mathbf{A}}_2, S)$, this is a contradiction. Consequently, $\\phi_1$ and $\\phi_2$ are not counting equivalent.\n\\end{proof}\n\n\n\\subsection{Semi-counting equivalence}\n\\label{subsect:semi-counting-equivalence}\n\nIn this subsection, we study a\nrelaxation of the notion of \\emph{counting equivalence}. This notion will be necessary when we emulate the approach of Example~\\ref{ex:eqfirstrevisited} in the proof of the Equivalence theorem: we will again construct a system of linear equations that we want to solve. In order to ensure solvability, we will make sure that the matrix of the system is again a Vandermonde matrix which in particular means that all its entries must be positive. Consequently, since the entries are of the form $|\\phi({\\mathbf{C}})|^k$ for pp-formulas $\\phi$ some carefully chosen structure ${\\mathbf{C}}$ and integers $k$, it will be necessary to understand counting equivalence in the case where $\\phi({\\mathbf{C}})$ is non-empty. The necessary notion is formalized by the following definition.\n\n\\begin{definition}\nCall two prenex pp-formulas $\\phi_1(V_1)$, $\\phi_2(V_2)$ \non the same vocabulary\n\\emph{semi-counting equivalent}\nif for each finite structure ${\\mathbf{B}}$\nsuch that $|\\phi_1({\\mathbf{B}})| > 0$ and $|\\phi_2({\\mathbf{B}})| > 0$,\nit holds that $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$.\n\\end{definition}\n\n\\begin{example}\n The pp-formulas $\\phi_1(x,y)= E(x,y)$ and \n $\\phi_2(x,y)=\\exists z (E(x,y)\\land F(z))$ are not counting equivalent, because for every structure ${\\mathbf{B}}$ for which $F^{\\mathbf{B}}=\\emptyset$, we have $|\\phi_2({\\mathbf{B}})| = 0$ while $|\\phi_1({\\mathbf{B}})|$ may be non-zero if $E^{{\\mathbf{B}}}$ is non-empty. But if we have for a structure ${\\mathbf{B}}$ such that $|\\phi_2({\\mathbf{B}})|>0$, then $F^{\\mathbf{B}}\\ne \\emptyset$ and it is straightforward to verify that $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$. Consequently, $\\phi_1$ and $\\phi_2$ are semi-counting equivalent.\n\\end{example}\n\n\nFor each free prenex pp-formula $\\phi(V)$, define $\\widehat{\\phi}(V)$ \nto be the pp-formula\nobtained from $\\phi$ \nby removing each atom\nthat occurs in a non-liberal component of $\\phi$\n(a component of $\\phi$ not having liberal variables).\n\n\n\n\n\n\\begin{example}\nConsider the pp-formula $\\phi$ discussed\n in Examples~\\ref{ex:pp-formula}\nand~\\ref{ex:pp-formula-components}.\nThis pp-formula has $4$ components, namely, the pp-formulas\n$\\psi_1(x, x')$,\n$\\psi_2(y)$,\n$\\psi_3(z)$,\nand\n$\\psi_4(\\emptyset)$\ndefined in Example~\\ref{ex:pp-formula-components}.\nThe formulas $\\psi_1$, $\\psi_2$, and $\\psi_3$ are liberal,\nbut the formula $\\psi_4$ is not liberal.\nRecall that \n$\\phi(x,x',y,z) = \\exists y' \\exists u \\exists v \\exists w (E(x, x') \\wedge E(y,y') \\wedge F(u,v) \\wedge G(u,w))$\nand that we have\n$\\psi_4(\\emptyset) = \\exists u \\exists v \\exists w (F(u,v) \\wedge G(u,w))$.\nHence, $\\widehat{\\phi}(x,x',y,z)$ is the formula\n$\\exists y' \\exists u \\exists v \\exists w \n(E(x, x') \\wedge E(y,y')).$\n\\end{example}\n\n\nThe following characterization of semi-counting equivalence\n is the main theorem of this subsection.\n\n\\begin{theorem}\\label{thm:semiequichar}\nLet $\\phi_1(V_1), \\phi_2(V_2)$ be two free prenex pp-formulas.\nIt holds that $\\phi_1(V_1)$ and $\\phi_2(V_2)$\nare semi-counting equivalent\nif and only if $\\widehat{\\phi_1}(V_1)$ and $\\widehat{\\phi_2}(V_2)$ are counting equivalent.\n\\end{theorem}\n\nWe will use the following proposition in the proof of Theorem~\\ref{thm:semiequichar}.\n\n\\begin{proposition}\\label{prop:samesolutions}\n Let $\\phi(V)$ be a free prenex pp-for\\-mula. Then for every structure ${\\mathbf{B}}$ we have $\\phi({\\mathbf{B}})=\\emptyset$ or $\\phi({\\mathbf{B}})=\\widehat{\\phi}({\\mathbf{B}})$.\n\\end{proposition}\n\n\\begin{proof}\n Let ${\\mathbf{B}}$ be a structure. \nLet $\\psi$ be the conjunction of the components deleted from $\\phi$\nto obtain $\\widehat{\\phi}$.\nIf $\\psi$ is false on ${\\mathbf{B}}$, then obviously $\\phi({\\mathbf{B}}) = \\emptyset$.\nOtherwise, $\\psi$ is true on ${\\mathbf{B}}$, and for any assignment $f: V \\to B$,\nit holds that ${\\mathbf{B}}, f \\models \\phi$ if and only if ${\\mathbf{B}}, f \\models \\widehat{\\phi}$.\n\\end{proof}\n\n\n\\begin{proof}  (Theorem~\\ref{thm:semiequichar})\n Assume first that $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ are counting equivalent. Let ${\\mathbf{B}}$ be a structure. Then if $|\\phi_1({\\mathbf{B}})|> 0$ and $|\\phi_2({\\mathbf{B}})|> 0$, we have by Proposition~\\ref{prop:samesolutions} and counting equivalence of $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ that \n \n$|\\phi_1({\\mathbf{B}})| = |\\widehat{\\phi_1}({\\mathbf{B}})| = |\\widehat{\\phi_2}({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})|$,\n so $\\phi_1$ and $\\phi_2$ are semi-counting equivalent.\n \n For the other direction let now $\\phi_1$ and $\\phi_2$ be semi-counting equivalent. By way of contradiction, we assume that $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$ are not counting equivalent. Then by definition there is a structure ${\\mathbf{B}}$ such that $|\\widehat{\\phi_1}({\\mathbf{B}})|\\ne |\\widehat{\\phi_2}({\\mathbf{B}})|$. \n Note that each component of $\\widehat{\\phi_1}$ and $\\widehat{\\phi_2}$\n  has a liberal variable.\n \nLet ${\\mathbf{I}} = {\\mathbf{I}}_{\\tau}$,\nwhere $\\tau$ is the vocabulary of $\\phi_1$ and $\\phi_2$.\nFor each $k\\in \\mathbb{N}$ we denote by ${\\mathbf{B}}+k{\\mathbf{I}}$ the structure we get from ${\\mathbf{B}}$ by disjoint union with $k$ copies of ${\\mathbf{I}}$. Note that for $k>0$ we have $|\\phi({\\mathbf{B}} +k{\\mathbf{I}})| > 0$ for every pp-formula $\\phi$. Consequently, for every $k>0$ we have $|\\phi_1({\\mathbf{B}}+k{\\mathbf{I}})| = |\\widehat{\\phi_1}({\\mathbf{B}}+k{\\mathbf{I}})|$ and $|\\phi_2({\\mathbf{B}}+k{\\mathbf{I}})| = |\\widehat{\\phi_2}({\\mathbf{B}}+k{\\mathbf{I}})|$ by Proposition~\\ref{prop:samesolutions}. By the semi-counting equivalence of $\\phi_1$ and $\\phi_2$ we also have $|\\phi_1({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\phi_2({\\mathbf{B}} +k{\\mathbf{I}})|$ for all $k>0$. It follows that $|\\widehat{\\phi_1}({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\widehat{\\phi_2}({\\mathbf{B}} +k{\\mathbf{I}})|$ for $k>0$.\n\nLet $\\phi_{1,1}, \\ldots, \\phi_{1,n}$ be \nthe components of $\\widehat{\\phi_1}$ and \nlet $\\phi_{2,1}, \\ldots , \\phi_{2,m}$ be \nthe  components of $\\widehat{\\phi_2}$. \nBecause every component of $\\widehat{\\phi_1}$ has a liberal variable, \nwe have \n\n", "index": 29, "text": "\\begin{align*}\n|\\widehat{\\phi_1}({\\mathbf{B}}+k{\\mathbf{I}})| &= \\sum_{J\\subseteq [n]} k^{n-|J|} \\prod_{j\\in J}|\\phi_{1,j}({\\mathbf{B}})| \\\\\n & =\\sum_{\\ell=0}^n k^{n-\\ell} \\sum_{J\\subseteq [n], |J|=\\ell}  \\prod_{j\\in J}|\\phi_{1,j}({\\mathbf{B}})|.\n \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\widehat{\\phi_{1}}({\\mathbf{B}}+k{\\mathbf{I}})|\" display=\"inline\"><mrow><mo stretchy=\"false\">|</mo><mrow><mover accent=\"true\"><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc01</mi><mo>+</mo><mrow><mi>k</mi><mo>\u2062</mo><mi>\ud835\udc08</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{J\\subseteq[n]}k^{n-|J|}\\prod_{j\\in J}|\\phi_{1,j}({\\mathbf{%&#10;B}})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>J</mi><mo>\u2286</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow></munder></mstyle><mrow><msup><mi>k</mi><mrow><mi>n</mi><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mi>J</mi><mo stretchy=\"false\">|</mo></mrow></mrow></msup><mo>\u2062</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>j</mi><mo>\u2208</mo><mi>J</mi></mrow></munder></mstyle><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{\\ell=0}^{n}k^{n-\\ell}\\sum_{J\\subseteq[n],|J|=\\ell}\\prod_{j%&#10;\\in J}|\\phi_{1,j}({\\mathbf{B}})|.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi mathvariant=\"normal\">\u2113</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover></mstyle><mrow><msup><mi>k</mi><mrow><mi>n</mi><mo>-</mo><mi mathvariant=\"normal\">\u2113</mi></mrow></msup><mo>\u2062</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mrow><mi>J</mi><mo>\u2286</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mo>,</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mi>J</mi><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mi mathvariant=\"normal\">\u2113</mi></mrow></mrow></munder></mstyle><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>j</mi><mo>\u2208</mo><mi>J</mi></mrow></munder></mstyle><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " which is a contradiction to our assumption.\n\\end{proof}\n\n\\begin{corollary}\n Semi-counting equivalence of pp-for\\-mulas is an equivalence relation.\n\n\\end{corollary}\n\nWe now present a lemma that will be of utility; it is proved by induction.\n\n\n\n\n\\begin{lemma}\\label{lem:semigeneral}\n Let $\\phi_1(S_1), \\ldots, \\phi_n(S_n)$ be pp-formulas over the same vocabulary $\\tau$, with each $|S_i| > 0$. Then there is a structure ${\\mathbf{C}}$ (over $\\tau$) such that \n\\begin{itemize}\n\\item for all pp-formulas $\\phi$ (over $\\tau$) it holds\nthat $|\\phi({\\mathbf{C}})|>0$, and \n\n\\item\nfor all $i,j\\in [n]$ such that $\\phi_i$ and $\\phi_j$ are not semi-counting equivalent, it holds that $|\\phi_i({\\mathbf{C}})|\\ne |\\phi_j({\\mathbf{C}})|$.\n\\end{itemize}\n\\end{lemma}\n\n\n\n\\subsection{The all-free case}\n\\label{subsect:all-free}\n\nThe aim of this subsection is the proof of Theorem~\\ref{thm:equivalence-theorem} in the special case of all-free ep-formulas.\nRecall that an ep-formula is \\emph{all-free} if\nit is the disjunction of prenex pp-formulas, each of which\nis \\emph{free} in that it has a non-empty set of free variables. We will later in Section~\\ref{subsect:general-equivalence-theorem} use the result on all-free formulas to prove the general version of Theorem~\\ref{thm:equivalence-theorem}.\n\nFor every $\\phi(V) \\in \\Phi$ we define a set $\\phi^*$ of free pp-formulas;\nthen, we define $\\Phi^* = \\bigcup_{\\phi \\in \\Phi} \\phi^*(V)$.\nLet $\\phi(V)= \\phi_1(V) \\lor \\ldots \\lor \\phi_s(V)$ where the \n$\\phi_i(V)$ are free pp-formulas. By inclusion-exclusion we have for every structure ${\\mathbf{B}}$ that \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWe can express\n$|\\widehat{\\phi_2}({\\mathbf{B}}+k{\\mathbf{I}})|$ analogously.\n\n\nThe expressions are polynomials in $k$ and they are equal for every positive integer $k$ by the observations above;\nthus the coefficients of the polynomials must coincide.\n\nThe coefficients of $k^0$, namely \nthe values\n$\\prod_{j\\in [n]}|\\phi_{1,j}({\\mathbf{B}})|$ and\n$\\prod_{j\\in [m]}|\\phi_{2,j}({\\mathbf{B}})|$, are thus equal. But then we get \n", "index": 31, "text": "\n\\[|\\widehat{\\phi_1}({\\mathbf{B}})|= \\prod_{j\\in [n]}|\\phi_{1,j}({\\mathbf{B}})|= \\prod_{j\\in [m]}|\\phi_{2,j}({\\mathbf{B}})|=|\\widehat{\\phi_2}({\\mathbf{B}})|,\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"|\\widehat{\\phi_{1}}({\\mathbf{B}})|=\\prod_{j\\in[n]}|\\phi_{1,j}({\\mathbf{B}})|=%&#10;\\prod_{j\\in[m]}|\\phi_{2,j}({\\mathbf{B}})|=|\\widehat{\\phi_{2}}({\\mathbf{B}})|,\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mover accent=\"true\"><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>j</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow></mrow></munder><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>=</mo><mrow><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u220f</mo><mrow><mi>j</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>m</mi><mo stretchy=\"false\">]</mo></mrow></mrow></munder><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mover accent=\"true\"><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>^</mo></mover><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " \n\nwhere the $\\phi_J(V) = \\bigwedge_{j\\in J} \\phi_j(V)$ are pp-formulas. \nNow iteratively do the following: If there are two summands $c |\\phi_J({\\mathbf{B}})|$ and $c' |\\phi_{J'}({\\mathbf{B}})|$ such that $\\phi_J$ and $\\phi_{J'}$ are counting equivalent, delete both summands and add $(c+c')|\\phi_J|$ to the sum. \nWhen this operation can no longer be applied, delete all summands with coefficient zero. The pp-formulas that remain in the sum form the set $\\phi^*$. \n\n\\begin{example}\n It is useful to again consider Example~\\ref{ex:eqsecond}. There we started off with\n", "itemtype": "equation", "pos": -1, "prevtext": " which is a contradiction to our assumption.\n\\end{proof}\n\n\\begin{corollary}\n Semi-counting equivalence of pp-for\\-mulas is an equivalence relation.\n\n\\end{corollary}\n\nWe now present a lemma that will be of utility; it is proved by induction.\n\n\n\n\n\\begin{lemma}\\label{lem:semigeneral}\n Let $\\phi_1(S_1), \\ldots, \\phi_n(S_n)$ be pp-formulas over the same vocabulary $\\tau$, with each $|S_i| > 0$. Then there is a structure ${\\mathbf{C}}$ (over $\\tau$) such that \n\\begin{itemize}\n\\item for all pp-formulas $\\phi$ (over $\\tau$) it holds\nthat $|\\phi({\\mathbf{C}})|>0$, and \n\n\\item\nfor all $i,j\\in [n]$ such that $\\phi_i$ and $\\phi_j$ are not semi-counting equivalent, it holds that $|\\phi_i({\\mathbf{C}})|\\ne |\\phi_j({\\mathbf{C}})|$.\n\\end{itemize}\n\\end{lemma}\n\n\n\n\\subsection{The all-free case}\n\\label{subsect:all-free}\n\nThe aim of this subsection is the proof of Theorem~\\ref{thm:equivalence-theorem} in the special case of all-free ep-formulas.\nRecall that an ep-formula is \\emph{all-free} if\nit is the disjunction of prenex pp-formulas, each of which\nis \\emph{free} in that it has a non-empty set of free variables. We will later in Section~\\ref{subsect:general-equivalence-theorem} use the result on all-free formulas to prove the general version of Theorem~\\ref{thm:equivalence-theorem}.\n\nFor every $\\phi(V) \\in \\Phi$ we define a set $\\phi^*$ of free pp-formulas;\nthen, we define $\\Phi^* = \\bigcup_{\\phi \\in \\Phi} \\phi^*(V)$.\nLet $\\phi(V)= \\phi_1(V) \\lor \\ldots \\lor \\phi_s(V)$ where the \n$\\phi_i(V)$ are free pp-formulas. By inclusion-exclusion we have for every structure ${\\mathbf{B}}$ that \n\n", "index": 33, "text": "\\begin{align}|\\phi({\\mathbf{B}})| &= \\sum_{J\\in [s]} (-1)^{|J|+1}|(\\bigwedge_{j\\in J} \\phi_j)({\\mathbf{B}})| \\nonumber\\\\ & = \\sum_{J\\in [s]} (-1)^{|J|+1}|\\phi_J({\\mathbf{B}})|,\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi({\\mathbf{B}})|\" display=\"inline\"><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{J\\in[s]}(-1)^{|J|+1}|(\\bigwedge_{j\\in J}\\phi_{j})({\\mathbf%&#10;{B}})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>J</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>s</mi><mo stretchy=\"false\">]</mo></mrow></mrow></munder></mstyle><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>J</mi><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mrow><mi>j</mi><mo>\u2208</mo><mi>J</mi></mrow></munder></mstyle><msub><mi>\u03d5</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\sum_{J\\in[s]}(-1)^{|J|+1}|\\phi_{J}({\\mathbf{B}})|,\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>J</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>s</mi><mo stretchy=\"false\">]</mo></mrow></mrow></munder></mstyle><mrow><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mi>J</mi><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mn>1</mn></mrow></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>J</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": " Inclusion-exclusion yields \n \n", "itemtype": "equation", "pos": -1, "prevtext": " \n\nwhere the $\\phi_J(V) = \\bigwedge_{j\\in J} \\phi_j(V)$ are pp-formulas. \nNow iteratively do the following: If there are two summands $c |\\phi_J({\\mathbf{B}})|$ and $c' |\\phi_{J'}({\\mathbf{B}})|$ such that $\\phi_J$ and $\\phi_{J'}$ are counting equivalent, delete both summands and add $(c+c')|\\phi_J|$ to the sum. \nWhen this operation can no longer be applied, delete all summands with coefficient zero. The pp-formulas that remain in the sum form the set $\\phi^*$. \n\n\\begin{example}\n It is useful to again consider Example~\\ref{ex:eqsecond}. There we started off with\n", "index": 35, "text": "\\[\\phi(V)= \\phi_1(V) \\lor \\phi_2(V) \\lor \\phi_3(V).\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"\\phi(V)=\\phi_{1}(V)\\lor\\phi_{2}(V)\\lor\\phi_{3}(V).\" display=\"block\"><mrow><mrow><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><msub><mi>\u03d5</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\n Now observe that the formulas $\\phi_1$, $\\phi_2$ and $\\phi_3$ \nare actually equivalent to each other up to renaming variables;\nconsequently,  these formulas\nare equivalent in that,\nfor any structure ${\\mathbf{B}}$,\nthey\nyield the same count: $|\\phi_1({\\mathbf{B}})| = |\\phi_2({\\mathbf{B}})| = |\\phi_3({\\mathbf{B}})|$.\nIn Section~\\ref{subsect:counting-equivalence}, we formalize\nand give a characterization of this notion of equivalence\n(on pp-formulas).\nThe formulas $\\phi_1 \\land \\phi_3$ and $\\phi_2 \\land \\phi_3$\nare also equivalent in this sense.  We may thus obtain\nthe following expression for $|\\phi({\\mathbf{B}})|$.\n\n \n", "itemtype": "equation", "pos": 39596, "prevtext": " \n\nwhere \n$\\phi_1(V) = E(x,y) \\land E(y,z)$, \n$\\phi_2(V) = E(z,w) \\land E(w,x)$ and \n$\\phi_3(V) = E(w,x) \\land E(x,y)$. \nApplying in\\-clu\\-sion-ex\\-clu\\-sion, we obtain\n \n", "index": 9, "text": "\\begin{align*}|\\phi({\\mathbf{B}})| = &|\\phi_1({\\mathbf{B}})| + |\\phi_2({\\mathbf{B}})| + |\\phi_3({\\mathbf{B}})|\\\\\n  &- |(\\phi_1\\land \\phi_2)({\\mathbf{B}})| - |(\\phi_1\\land \\phi_3)({\\mathbf{B}})|  \\\\&- |(\\phi_2 \\land \\phi_3)({\\mathbf{B}})|+ |(\\phi_1 \\land \\phi_2 \\land \\phi_3)({\\mathbf{B}})|. \\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi({\\mathbf{B}})|=\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi_{1}({\\mathbf{B}})|+|\\phi_{2}({\\mathbf{B}})|+|\\phi_{3}({%&#10;\\mathbf{B}})|\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>3</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-|(\\phi_{1}\\land\\phi_{2})({\\mathbf{B}})|-|(\\phi_{1}\\land\\phi_{3})%&#10;({\\mathbf{B}})|\" display=\"inline\"><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle-|(\\phi_{2}\\land\\phi_{3})({\\mathbf{B}})|+|(\\phi_{1}\\land\\phi_{2}%&#10;\\land\\phi_{3})({\\mathbf{B}})|.\" display=\"inline\"><mrow><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n Consequently, for this example we have\n", "itemtype": "equation", "pos": 41366, "prevtext": "\n Now we simplify as described above and get\n\n", "index": 39, "text": "\\[|\\phi({\\mathbf{B}})| = 3 \\cdot |\\phi_1({\\mathbf{B}})| - 2\\cdot |(\\phi_1\\land \\phi_3)({\\mathbf{B}})| . \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"|\\phi({\\mathbf{B}})|=3\\cdot|\\phi_{1}({\\mathbf{B}})|-2\\cdot|(\\phi_{1}\\land\\phi_%&#10;{3})({\\mathbf{B}})|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mrow><mn>3</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>-</mo><mrow><mn>2</mn><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc01</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\\end{example}\n\nThe algorithm discussed above directly yields the following proposition.\n\n\\begin{proposition}\\label{prop:sumwithcoeffs}\nThere exists an algorithm that, \\\\when\nan all-free ep-formula $\\phi$ is given as input, outputs\na set \n $\\phi^*:=\\{\\phi_1^*, \\ldots, \\phi_\\ell^*\\}$ of free pp-formulas,\n which are pairwise not counting equivalent,\n and coefficients $c_1, \\ldots, c_\\ell\\in \\mathbb{Z}\\setminus\\{0\\}$ such that for every structure ${\\mathbf{B}}$,\n$|\\phi({\\mathbf{B}})|= \\sum_{i=1}^\\ell c_i |\\phi^*_i({\\mathbf{B}})|$.\n\n\n\n\\end{proposition}\n\nWe will also require the following two facts for our proof.\n\n\\begin{proposition}\\label{prop:nothomeq}\n Let $\\phi(S)$ and $\\phi'(S')$ be two semi-counting equivalent free pp-formulas that are not counting equivalent and let \n $({\\mathbf{A}},S)$ and $({\\mathbf{A}}',S')$ \n be the structures of $\\phi$ and $\\phi'$, respectively. Then ${\\mathbf{A}}$ and ${\\mathbf{A}}'$ are not homomorphically equivalent.\n\\end{proposition}\n\n\n\n\n\n\\begin{lemma}\\label{lem:splitsemieq}\nThere is an oracle FPT-algorithm that performs the following: \ngiven a set $\\phi_1, \\ldots, \\phi_s$ of semi-counting equivalent free pp-formulas that are pairwise not counting equivalent, a sequence $c_1, \\ldots, c_s\\in \\mathbb{Z}\\setminus \\{0\\}$, and a structure ${\\mathbf{B}}$, \nthe algorithm computes $|\\phi_i({\\mathbf{B}})|$ for every $i\\in [s]$;\nit may make calls to an oracle that provides\n$\\sum_{i=1}^s c_i \\cdot |\\phi_i({\\mathbf{B}}')|$ upon being given a structure ${\\mathbf{B}}'$.\nHere, the $\\phi_i$ with the $c_i$ constitute the parameter.\n\\end{lemma}\n\n\nWe can now prove Theorem~\\ref{thm:equivalence-theorem} for all-free ep-formulas.\n\n\\begin{theorem}\\label{thm:reductionallfree}\nLet $\\Phi$ be a set of all-free ep-formulas.\nThere exists a set $\\Phi^*$ of free prenex pp-formulas\nsuch that the counting case problems\n${\\mathsf{count}}[\\Phi]$ and ${\\mathsf{count}}[\\Phi^*]$\nare equivalent under counting slice reductions.\n\\end{theorem}\n\nBefore giving the technical details of the proof of Theorem~\\ref{thm:reductionallfree}, let us first descibe the ideas. The proof follows the approach presented in the examples of Section~\\ref{sct:examples}. In particular, the less straightforward reduction from ${\\mathsf{count}}[\\Phi^*]$ to ${\\mathsf{count}}[\\Phi]$ proceeds as we did in Example~\\ref{ex:eqfirstrevisited}. Given $\\phi$ and $\\phi^*$, we can evaluate $|\\phi'({\\mathbf{B}})|$ for $\\phi'\\in \\phi^*$ with an oracle for $|\\phi({\\mathbf{B}}\\times {\\mathbf{C}}^\\ell)|$ for a suitable structure ${\\mathbf{C}}$ as in that example. The main difference is that, instead of having ${\\mathbf{C}}$ explicitly as in Example~\\ref{ex:eqfirstrevisited}, we here know from Lemma~\\ref{lem:semigeneral} that a structure ${\\mathbf{C}}$ exists for which all formulas in $\\phi^*$ have a different number of satisfying assignments. We can then compute ${\\mathbf{C}}$ by brute force as it depends only on $\\phi$. This then allows to compute $\\phi'({\\mathbf{B}})$ by solving a system of linear equations.\n\nWe now give the technical detail of the proof.\n\n\\begin{proof}  \n\n The reduction from ${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^*]$ is straightforward.\n The relation $U$ is the set of pairs\n $(\\phi, \\phi^*)$\nsuch that $\\phi$ is an all-free ep-formula\nand $\\phi^*$ is the output of the algorithm of\nProposition~\\ref{prop:sumwithcoeffs} on input $\\phi$.\nObviously, this satisfies the coverage condition. Then the oracle-FPT-algorithm to compute $\\phi({\\mathbf{B}})$ given $\\phi, \\phi^*$ and  ${\\mathbf{B}}$ first computes all of the $|\\phi_i^*({\\mathbf{B}})|$ by oracle calls and then uses Proposition~\\ref{prop:sumwithcoeffs}. This completes the reduction.\n\nFor the other direction, let $\\phi'\\in \\Phi^*$. \nWe set $U$\nto be the set of all pairs\n$(\\phi', \\{ \\phi \\})$\nsuch that $\\phi$ is an all-free ep-formula and $\\phi' \\in \\phi^*$.\nGiven $\\phi'$, $\\phi$ and ${\\mathbf{B}}$, \nwe compute $|\\phi'({\\mathbf{B}})|:=r(\\phi', \\{ \\phi \\}, {\\mathbf{B}})$ as follows: \nLet $\\phi_1^*, \\ldots, \\phi_s^*$ be the equivalence classes of $\\phi^*$ with respect to semi-counting equivalence. Now choose a strucuture ${\\mathbf{C}}$ as in Lemma~\\ref{lem:semigeneral}. Then for $\\psi, \\psi'\\in \\phi^*$ we have $|\\psi({\\mathbf{C}})|\\ne |\\psi'({\\mathbf{C}})|$ if $\\psi$ and $\\psi'$ are from different equivalence classes with respect to semi-counting equivalence, and otherwise $|\\psi({\\mathbf{C}})|= |\\psi'({\\mathbf{C}})| >0$. \nFix for each $j\\in [s]$ a formula in $\\phi_j^*$ and call it $\\psi_j$. Moreover, denote by $c_\\psi$ the coefficiencent of $\\psi$ in Proposition~\\ref{prop:sumwithcoeffs}. Using this notation and Proposition~\\ref{prop:sumwithcoeffs} we get for every $\\ell \\in {\\mathbb{N}}$\nthat\n$|\\phi({\\mathbf{B}}\\times {\\mathbf{C}}^\\ell)| \n= \\sum_{j=1}^s |\\psi_j({\\mathbf{C}})|^\\ell(\\sum_{\\psi\\in \\phi^*_j} c_\\psi |\\psi({\\mathbf{B}})|).$\n\n\n\nNote that this is a linear equation with coefficients $|\\psi_j({\\mathbf{C}})|^\\ell$ which can be computed by brute force. Letting $\\ell$ range from $0$ to $s-1$ thus yields a system of linear equations whose coefficient matrix is a Vandermonde matrix. Consequently, with $s$ oracle calls we can compute\n $\\sum_{\\psi\\in \\phi^*_j} c_\\psi |\\psi({\\mathbf{B}})|$ for each $j$. \n We use Lemma~\\ref{lem:splitsemieq} to compute $\\phi'({\\mathbf{B}})$.\n\\end{proof}\n\n\\subsection{The general case}\n\\label{subsect:general-equivalence-theorem}\n\n\n\n\n\nWe may assume that each ep-formula $\\phi \\in \\Phi$ is normalized.\nFor each ep-formula $\\phi$, define $\\phi_{{\\mathrm{af}}}$ to be the\nall-free part of $\\phi$, that is, the\ndisjunction of the $\\phi$-disjuncts that are free;\ndefine $\\Phi_{{\\mathrm{af}}}$ to be $\\{ \\phi_{{\\mathrm{af}}} ~|~ \\phi \\in \\Phi \\}$;\nand,\ndefine $\\phi_{{\\mathrm{af}}}^-$ to be \nthe formulas in $\\phi_{{\\mathrm{af}}}^*$ \nthat do not logically entail a sentence disjunct of $\\phi$.\nWe define $\\phi^+$ to be \nthe union of $\\phi_{{\\mathrm{af}}}^-$ and\nthe set containing each pp-sentence disjunct of $\\phi$;\nand, we define $\\Phi^+$ to be $\\bigcup_{\\phi \\in \\Phi} \\phi^+$.\n\n\\hnote{put in example!}\n\nThe idea of the proof of Theorem~\\ref{thm:equivalence-theorem}\nis as follows.\n(See Section~\\ref{subsect:proof-of-equiv-theorem} for the full proof.)\nThe counting slice reduction\nfrom ${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^+]$ has\n$U$ as the set of pairs $(\\phi, \\phi^+)$ where $\\phi$\nis a normalized ep-formula; $r$ on $(\\phi(V), \\phi^+, {\\mathbf{B}})$\nbehaves as follows.\nFirst, it checks if there is a sentence disjunct $\\theta$ of $\\phi$\nthat is true on ${\\mathbf{B}}$; if so, it outputs $|V|^{|B|}$;\notherwise, it makes use of the counting slice reduction \nfrom \n${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}^*]$.\nThe counting slice reduction from\n${\\mathsf{count}}[\\Phi^+]$ to ${\\mathsf{count}}[\\Phi]$\nhas $U$ as the set $\\{(\\psi, \\{\\phi\\}) ~|~ \\psi \\in \\phi^+ \\}$;\n$r$ on $(\\psi(V), \\phi(V), {\\mathbf{B}})$ is defined as follows.\nWhen $\\psi \\in \\phi^-_{{\\mathrm{af}}}$, the counting slice reduction $(U', r')$\nfrom\n${\\mathsf{count}}[\\Phi^*_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$\nis used to determine $|\\psi({\\mathbf{B}})|$; this is performed\nby passing to $r'$ a treated version of ${\\mathbf{B}}$,\non which no sentence disjunct of $\\phi$ may hold.\nWhen $\\psi$ is a sentence disjunct of $\\phi$, \nan oracle query is made\nto obtain the count of $\\phi$ on a treated version of ${\\mathbf{B}}$;\non this treated version, it is proved that\nall assignments satisfy $\\phi$ \nif and only if ${\\mathbf{B}} \\models \\psi$.\n\n\n\n\\section{Conclusion}\n\n\n\n\nWe have shown a trichotomy for the parameterized complexity of counting satisfying assignments to  existential positive formulas of bounded arity. To this end, the main technical contribution was the equivalence theorem (Theorem~\\ref{thm:equivalence-theorem}) stating that for every set of existential positive formulas there is a set of  primitive positive formulas that is computationally equivalent with respect to \nthe counting problem studied. After showing this equivalence theorem, we could derive our trichotomy in a rather straightforward fashion by \ninvoking a previous trichotomy for primitive positive formulas as a black-box.\n\nIn order to prove the equivalence theorem, we gave a syntactic characterization for when two pp-formulas are counting equivalent, that is, have the same number of satisfying assignments with respect to every finite structure. \nThis result can be seen as an adaption, to the counting setting,\n of classical work of Chandra and Merlin~\\cite{ChandraMerlin77-optimal} that characterizes logical equivalence of primitive positive formulas. \n\nLet us note that the assumption of bounded arity is not needed in the proof of the equivalence theorem. It only appears in our trichotomy theorem because it is already present in the previous trichotomy on primitive positive formulas that we use. Consequently, if one could adapt the work of Marx~\\cite{Marx10-tractablehypergraph} on model checking unbounded arity primitive positive formulas to counting to show a dichotomy or trichotomy for counting, this would directly give the corresponding result for existential positive formulas by applying our equivalence theorem.\n\nFinally, let us remark that we are not aware of any \nfragment of first-order logic extending existential positive queries\nfor which even model checking is understood, from the viewpoint of classifying the complexity of all sets of queries\n(for more information, see the discussion in\nthe introduction of the article~\\cite{Chen14-frontier}).\nHence,\nthe research project of extending our \ncomplexity classification beyond existential positive queries\nwould first require an advance in the study of model checking\nin first-order logic.\n\n\n\n\n\n\n\n\n\n\\newpage\n\n{{{\\bibliographystyle{alpha}}}}\\confversion{{\\bibliographystyle{plain}}}\n\n\\bibliography{../../hubiebib}\n\n\n\n\\newpage\n\\appendix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{{{ \\section{Proof of Lemma~\\ref{lem:semigeneral}}}}}\\confversion{{\\subsection{Proof of Lemma~\\ref{lem:semigeneral}}}}\n\nWe first prove the following lemma.\n\n\\begin{lemma}\\label{lem:twocasesemi}\n Let $\\phi_1(S_1)$ and $\\phi_2(S_2)$ be two pp-for\\-mu\\-las \n over a vocabulary $\\tau$ that are not semi-counting equivalent. Then there is a structure ${\\mathbf{D}}$ such that for every primitive positive formula $\\phi$ over $\\tau$ we have $|\\phi({\\mathbf{D}})|> 0$ and $|\\phi_1({\\mathbf{D}})|\\ne |\\phi_2({\\mathbf{D}})|$.\n\\end{lemma}\n\n\\begin{proof}\n Let ${\\mathbf{B}}$ be any structure on which $\\phi_1$ and $\\phi_2$ have a non-zero but different number of solutions. Such a structure exists by definition of semi-counting equivalence. We claim that we can choose ${\\mathbf{D}} = {\\mathbf{B}} + k{\\mathbf{I}}$ for some $k\\in {\\mathbb{N}}, k>0$ where ${\\mathbf{B}} +k{\\mathbf{I}}$ is defined as in the proof of Theorem~\\ref{thm:semiequichar}. By way of contradiction, assume that $|\\phi_1({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\phi_2({\\mathbf{B}} +k{\\mathbf{I}})|$ for all $k\\in \\mathbb{N}, k>0$. Then with the same argument as in the proof of Theorem~\\ref{thm:semiequichar} we get the contradiction that $|\\phi_1({\\mathbf{B}})| =  |\\phi_2({\\mathbf{B}})|$. \n\\end{proof}\n\n\\begin{proof} (Lemma~\\ref{lem:semigeneral})\nWe prove this by induction on $n$;\nthe case $n=2$ is implied by Lemma~\\ref{lem:twocasesemi}.\n\nWhen $n > 2$, we first observe that it suffices to prove the result \nwhen the $\\phi_i$ are pairwise not semi-counting equivalent,\nso we assume that this holds.\nLet ${\\mathbf{D}}$ be the structure that we get by induction \nfor\n$\\phi_1, \\ldots, \\phi_{n-1}$.\nWe may assume w.l.o.g.~that $|\\phi_1({\\mathbf{D}})|<|\\phi_2({\\mathbf{D}})|<\\ldots < |\\phi_{n-1}({\\mathbf{D}})|$.\nIf it holds that \n$|\\phi_n({\\mathbf{D}})|\\ne |\\phi_i({\\mathbf{D}})|$ for every $i\\in [n-1]$,\nthen we are done.\nSo we assume that \nthere is an index $i \\in [n-1]$ \nsuch that $|\\phi_n({\\mathbf{D}})|= |\\phi_i({\\mathbf{D}})|$.\n\n\n\nLet ${\\mathbf{D}}'$ be the structure we get by applying Lemma~\\ref{lem:twocasesemi} to $\\phi_n$ and $\\phi_i$.\n\nNow choose $k$ such that for every $j$ with $1< j\\le i$ we have\n", "itemtype": "equation", "pos": 64110, "prevtext": "\n Consequently, for this example we have\n", "index": 41, "text": "\\[\\phi^* =\\{\\phi_1, \\phi_1\\land \\phi_3\\}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"\\phi^{*}=\\{\\phi_{1},\\phi_{1}\\land\\phi_{3}\\}.\" display=\"block\"><mrow><mrow><msup><mi>\u03d5</mi><mo>*</mo></msup><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>,</mo><mrow><msub><mi>\u03d5</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>\u03d5</mi><mn>3</mn></msub></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nThen we have for every $\\ell\\ge k$ and $1< j<i$\n\n", "itemtype": "equation", "pos": 76248, "prevtext": "\n\\end{example}\n\nThe algorithm discussed above directly yields the following proposition.\n\n\\begin{proposition}\\label{prop:sumwithcoeffs}\nThere exists an algorithm that, \\\\when\nan all-free ep-formula $\\phi$ is given as input, outputs\na set \n $\\phi^*:=\\{\\phi_1^*, \\ldots, \\phi_\\ell^*\\}$ of free pp-formulas,\n which are pairwise not counting equivalent,\n and coefficients $c_1, \\ldots, c_\\ell\\in \\mathbb{Z}\\setminus\\{0\\}$ such that for every structure ${\\mathbf{B}}$,\n$|\\phi({\\mathbf{B}})|= \\sum_{i=1}^\\ell c_i |\\phi^*_i({\\mathbf{B}})|$.\n\n\n\n\\end{proposition}\n\nWe will also require the following two facts for our proof.\n\n\\begin{proposition}\\label{prop:nothomeq}\n Let $\\phi(S)$ and $\\phi'(S')$ be two semi-counting equivalent free pp-formulas that are not counting equivalent and let \n $({\\mathbf{A}},S)$ and $({\\mathbf{A}}',S')$ \n be the structures of $\\phi$ and $\\phi'$, respectively. Then ${\\mathbf{A}}$ and ${\\mathbf{A}}'$ are not homomorphically equivalent.\n\\end{proposition}\n\n\n\n\n\n\\begin{lemma}\\label{lem:splitsemieq}\nThere is an oracle FPT-algorithm that performs the following: \ngiven a set $\\phi_1, \\ldots, \\phi_s$ of semi-counting equivalent free pp-formulas that are pairwise not counting equivalent, a sequence $c_1, \\ldots, c_s\\in \\mathbb{Z}\\setminus \\{0\\}$, and a structure ${\\mathbf{B}}$, \nthe algorithm computes $|\\phi_i({\\mathbf{B}})|$ for every $i\\in [s]$;\nit may make calls to an oracle that provides\n$\\sum_{i=1}^s c_i \\cdot |\\phi_i({\\mathbf{B}}')|$ upon being given a structure ${\\mathbf{B}}'$.\nHere, the $\\phi_i$ with the $c_i$ constitute the parameter.\n\\end{lemma}\n\n\nWe can now prove Theorem~\\ref{thm:equivalence-theorem} for all-free ep-formulas.\n\n\\begin{theorem}\\label{thm:reductionallfree}\nLet $\\Phi$ be a set of all-free ep-formulas.\nThere exists a set $\\Phi^*$ of free prenex pp-formulas\nsuch that the counting case problems\n${\\mathsf{count}}[\\Phi]$ and ${\\mathsf{count}}[\\Phi^*]$\nare equivalent under counting slice reductions.\n\\end{theorem}\n\nBefore giving the technical details of the proof of Theorem~\\ref{thm:reductionallfree}, let us first descibe the ideas. The proof follows the approach presented in the examples of Section~\\ref{sct:examples}. In particular, the less straightforward reduction from ${\\mathsf{count}}[\\Phi^*]$ to ${\\mathsf{count}}[\\Phi]$ proceeds as we did in Example~\\ref{ex:eqfirstrevisited}. Given $\\phi$ and $\\phi^*$, we can evaluate $|\\phi'({\\mathbf{B}})|$ for $\\phi'\\in \\phi^*$ with an oracle for $|\\phi({\\mathbf{B}}\\times {\\mathbf{C}}^\\ell)|$ for a suitable structure ${\\mathbf{C}}$ as in that example. The main difference is that, instead of having ${\\mathbf{C}}$ explicitly as in Example~\\ref{ex:eqfirstrevisited}, we here know from Lemma~\\ref{lem:semigeneral} that a structure ${\\mathbf{C}}$ exists for which all formulas in $\\phi^*$ have a different number of satisfying assignments. We can then compute ${\\mathbf{C}}$ by brute force as it depends only on $\\phi$. This then allows to compute $\\phi'({\\mathbf{B}})$ by solving a system of linear equations.\n\nWe now give the technical detail of the proof.\n\n\\begin{proof}  \n\n The reduction from ${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^*]$ is straightforward.\n The relation $U$ is the set of pairs\n $(\\phi, \\phi^*)$\nsuch that $\\phi$ is an all-free ep-formula\nand $\\phi^*$ is the output of the algorithm of\nProposition~\\ref{prop:sumwithcoeffs} on input $\\phi$.\nObviously, this satisfies the coverage condition. Then the oracle-FPT-algorithm to compute $\\phi({\\mathbf{B}})$ given $\\phi, \\phi^*$ and  ${\\mathbf{B}}$ first computes all of the $|\\phi_i^*({\\mathbf{B}})|$ by oracle calls and then uses Proposition~\\ref{prop:sumwithcoeffs}. This completes the reduction.\n\nFor the other direction, let $\\phi'\\in \\Phi^*$. \nWe set $U$\nto be the set of all pairs\n$(\\phi', \\{ \\phi \\})$\nsuch that $\\phi$ is an all-free ep-formula and $\\phi' \\in \\phi^*$.\nGiven $\\phi'$, $\\phi$ and ${\\mathbf{B}}$, \nwe compute $|\\phi'({\\mathbf{B}})|:=r(\\phi', \\{ \\phi \\}, {\\mathbf{B}})$ as follows: \nLet $\\phi_1^*, \\ldots, \\phi_s^*$ be the equivalence classes of $\\phi^*$ with respect to semi-counting equivalence. Now choose a strucuture ${\\mathbf{C}}$ as in Lemma~\\ref{lem:semigeneral}. Then for $\\psi, \\psi'\\in \\phi^*$ we have $|\\psi({\\mathbf{C}})|\\ne |\\psi'({\\mathbf{C}})|$ if $\\psi$ and $\\psi'$ are from different equivalence classes with respect to semi-counting equivalence, and otherwise $|\\psi({\\mathbf{C}})|= |\\psi'({\\mathbf{C}})| >0$. \nFix for each $j\\in [s]$ a formula in $\\phi_j^*$ and call it $\\psi_j$. Moreover, denote by $c_\\psi$ the coefficiencent of $\\psi$ in Proposition~\\ref{prop:sumwithcoeffs}. Using this notation and Proposition~\\ref{prop:sumwithcoeffs} we get for every $\\ell \\in {\\mathbb{N}}$\nthat\n$|\\phi({\\mathbf{B}}\\times {\\mathbf{C}}^\\ell)| \n= \\sum_{j=1}^s |\\psi_j({\\mathbf{C}})|^\\ell(\\sum_{\\psi\\in \\phi^*_j} c_\\psi |\\psi({\\mathbf{B}})|).$\n\n\n\nNote that this is a linear equation with coefficients $|\\psi_j({\\mathbf{C}})|^\\ell$ which can be computed by brute force. Letting $\\ell$ range from $0$ to $s-1$ thus yields a system of linear equations whose coefficient matrix is a Vandermonde matrix. Consequently, with $s$ oracle calls we can compute\n $\\sum_{\\psi\\in \\phi^*_j} c_\\psi |\\psi({\\mathbf{B}})|$ for each $j$. \n We use Lemma~\\ref{lem:splitsemieq} to compute $\\phi'({\\mathbf{B}})$.\n\\end{proof}\n\n\\subsection{The general case}\n\\label{subsect:general-equivalence-theorem}\n\n\n\n\n\nWe may assume that each ep-formula $\\phi \\in \\Phi$ is normalized.\nFor each ep-formula $\\phi$, define $\\phi_{{\\mathrm{af}}}$ to be the\nall-free part of $\\phi$, that is, the\ndisjunction of the $\\phi$-disjuncts that are free;\ndefine $\\Phi_{{\\mathrm{af}}}$ to be $\\{ \\phi_{{\\mathrm{af}}} ~|~ \\phi \\in \\Phi \\}$;\nand,\ndefine $\\phi_{{\\mathrm{af}}}^-$ to be \nthe formulas in $\\phi_{{\\mathrm{af}}}^*$ \nthat do not logically entail a sentence disjunct of $\\phi$.\nWe define $\\phi^+$ to be \nthe union of $\\phi_{{\\mathrm{af}}}^-$ and\nthe set containing each pp-sentence disjunct of $\\phi$;\nand, we define $\\Phi^+$ to be $\\bigcup_{\\phi \\in \\Phi} \\phi^+$.\n\n\\hnote{put in example!}\n\nThe idea of the proof of Theorem~\\ref{thm:equivalence-theorem}\nis as follows.\n(See Section~\\ref{subsect:proof-of-equiv-theorem} for the full proof.)\nThe counting slice reduction\nfrom ${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^+]$ has\n$U$ as the set of pairs $(\\phi, \\phi^+)$ where $\\phi$\nis a normalized ep-formula; $r$ on $(\\phi(V), \\phi^+, {\\mathbf{B}})$\nbehaves as follows.\nFirst, it checks if there is a sentence disjunct $\\theta$ of $\\phi$\nthat is true on ${\\mathbf{B}}$; if so, it outputs $|V|^{|B|}$;\notherwise, it makes use of the counting slice reduction \nfrom \n${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}^*]$.\nThe counting slice reduction from\n${\\mathsf{count}}[\\Phi^+]$ to ${\\mathsf{count}}[\\Phi]$\nhas $U$ as the set $\\{(\\psi, \\{\\phi\\}) ~|~ \\psi \\in \\phi^+ \\}$;\n$r$ on $(\\psi(V), \\phi(V), {\\mathbf{B}})$ is defined as follows.\nWhen $\\psi \\in \\phi^-_{{\\mathrm{af}}}$, the counting slice reduction $(U', r')$\nfrom\n${\\mathsf{count}}[\\Phi^*_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$\nis used to determine $|\\psi({\\mathbf{B}})|$; this is performed\nby passing to $r'$ a treated version of ${\\mathbf{B}}$,\non which no sentence disjunct of $\\phi$ may hold.\nWhen $\\psi$ is a sentence disjunct of $\\phi$, \nan oracle query is made\nto obtain the count of $\\phi$ on a treated version of ${\\mathbf{B}}$;\non this treated version, it is proved that\nall assignments satisfy $\\phi$ \nif and only if ${\\mathbf{B}} \\models \\psi$.\n\n\n\n\\section{Conclusion}\n\n\n\n\nWe have shown a trichotomy for the parameterized complexity of counting satisfying assignments to  existential positive formulas of bounded arity. To this end, the main technical contribution was the equivalence theorem (Theorem~\\ref{thm:equivalence-theorem}) stating that for every set of existential positive formulas there is a set of  primitive positive formulas that is computationally equivalent with respect to \nthe counting problem studied. After showing this equivalence theorem, we could derive our trichotomy in a rather straightforward fashion by \ninvoking a previous trichotomy for primitive positive formulas as a black-box.\n\nIn order to prove the equivalence theorem, we gave a syntactic characterization for when two pp-formulas are counting equivalent, that is, have the same number of satisfying assignments with respect to every finite structure. \nThis result can be seen as an adaption, to the counting setting,\n of classical work of Chandra and Merlin~\\cite{ChandraMerlin77-optimal} that characterizes logical equivalence of primitive positive formulas. \n\nLet us note that the assumption of bounded arity is not needed in the proof of the equivalence theorem. It only appears in our trichotomy theorem because it is already present in the previous trichotomy on primitive positive formulas that we use. Consequently, if one could adapt the work of Marx~\\cite{Marx10-tractablehypergraph} on model checking unbounded arity primitive positive formulas to counting to show a dichotomy or trichotomy for counting, this would directly give the corresponding result for existential positive formulas by applying our equivalence theorem.\n\nFinally, let us remark that we are not aware of any \nfragment of first-order logic extending existential positive queries\nfor which even model checking is understood, from the viewpoint of classifying the complexity of all sets of queries\n(for more information, see the discussion in\nthe introduction of the article~\\cite{Chen14-frontier}).\nHence,\nthe research project of extending our \ncomplexity classification beyond existential positive queries\nwould first require an advance in the study of model checking\nin first-order logic.\n\n\n\n\n\n\n\n\n\n\\newpage\n\n{{{\\bibliographystyle{alpha}}}}\\confversion{{\\bibliographystyle{plain}}}\n\n\\bibliography{../../hubiebib}\n\n\n\n\\newpage\n\\appendix\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{{{ \\section{Proof of Lemma~\\ref{lem:semigeneral}}}}}\\confversion{{\\subsection{Proof of Lemma~\\ref{lem:semigeneral}}}}\n\nWe first prove the following lemma.\n\n\\begin{lemma}\\label{lem:twocasesemi}\n Let $\\phi_1(S_1)$ and $\\phi_2(S_2)$ be two pp-for\\-mu\\-las \n over a vocabulary $\\tau$ that are not semi-counting equivalent. Then there is a structure ${\\mathbf{D}}$ such that for every primitive positive formula $\\phi$ over $\\tau$ we have $|\\phi({\\mathbf{D}})|> 0$ and $|\\phi_1({\\mathbf{D}})|\\ne |\\phi_2({\\mathbf{D}})|$.\n\\end{lemma}\n\n\\begin{proof}\n Let ${\\mathbf{B}}$ be any structure on which $\\phi_1$ and $\\phi_2$ have a non-zero but different number of solutions. Such a structure exists by definition of semi-counting equivalence. We claim that we can choose ${\\mathbf{D}} = {\\mathbf{B}} + k{\\mathbf{I}}$ for some $k\\in {\\mathbb{N}}, k>0$ where ${\\mathbf{B}} +k{\\mathbf{I}}$ is defined as in the proof of Theorem~\\ref{thm:semiequichar}. By way of contradiction, assume that $|\\phi_1({\\mathbf{B}} +k{\\mathbf{I}})| =  |\\phi_2({\\mathbf{B}} +k{\\mathbf{I}})|$ for all $k\\in \\mathbb{N}, k>0$. Then with the same argument as in the proof of Theorem~\\ref{thm:semiequichar} we get the contradiction that $|\\phi_1({\\mathbf{B}})| =  |\\phi_2({\\mathbf{B}})|$. \n\\end{proof}\n\n\\begin{proof} (Lemma~\\ref{lem:semigeneral})\nWe prove this by induction on $n$;\nthe case $n=2$ is implied by Lemma~\\ref{lem:twocasesemi}.\n\nWhen $n > 2$, we first observe that it suffices to prove the result \nwhen the $\\phi_i$ are pairwise not semi-counting equivalent,\nso we assume that this holds.\nLet ${\\mathbf{D}}$ be the structure that we get by induction \nfor\n$\\phi_1, \\ldots, \\phi_{n-1}$.\nWe may assume w.l.o.g.~that $|\\phi_1({\\mathbf{D}})|<|\\phi_2({\\mathbf{D}})|<\\ldots < |\\phi_{n-1}({\\mathbf{D}})|$.\nIf it holds that \n$|\\phi_n({\\mathbf{D}})|\\ne |\\phi_i({\\mathbf{D}})|$ for every $i\\in [n-1]$,\nthen we are done.\nSo we assume that \nthere is an index $i \\in [n-1]$ \nsuch that $|\\phi_n({\\mathbf{D}})|= |\\phi_i({\\mathbf{D}})|$.\n\n\n\nLet ${\\mathbf{D}}'$ be the structure we get by applying Lemma~\\ref{lem:twocasesemi} to $\\phi_n$ and $\\phi_i$.\n\nNow choose $k$ such that for every $j$ with $1< j\\le i$ we have\n", "index": 43, "text": "\\[\\frac{|\\phi_{j-1}({\\mathbf{D}})|^k}{|\\phi_{j}({\\mathbf{D}})|^k} < \\frac{1}{|{\\mathrm{lib}}(\\phi_{j-1})|^{|D'|}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\frac{|\\phi_{j-1}({\\mathbf{D}})|^{k}}{|\\phi_{j}({\\mathbf{D}})|^{k}}&lt;\\frac{1}{|%&#10;{\\mathrm{lib}}(\\phi_{j-1})|^{|D^{\\prime}|}}.\" display=\"block\"><mrow><mrow><mfrac><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc03</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mi>k</mi></msup><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc03</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mi>k</mi></msup></mfrac><mo>&lt;</mo><mfrac><mn>1</mn><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mi>lib</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>D</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo></mrow></msup></mfrac></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nAnalogously, we get for every $\\ell>k$ that\n", "itemtype": "equation", "pos": 76413, "prevtext": "\nThen we have for every $\\ell\\ge k$ and $1< j<i$\n\n", "index": 45, "text": "\\begin{align*}\n |\\phi_{j-1}({\\mathbf{D}}^\\ell \\times {\\mathbf{D}}')| &= |\\phi_{j-1}({\\mathbf{D}}^\\ell )| \\cdot |\\phi_{j-1}({\\mathbf{D}}')|\\\\\n &\\le |\\phi_{j-1}({\\mathbf{D}}^\\ell )| \\cdot |{\\mathrm{lib}}(\\phi_{j-1})|^{|D'|} \\\\\n &< |\\phi_j({\\mathbf{D}}^\\ell)|\\\\\n &\\le |\\phi_j({\\mathbf{D}}^\\ell)| \\cdot |\\phi_j({\\mathbf{D}}')|\\\\\n &= |\\phi_j({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi_{j-1}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|\" display=\"inline\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{j-1}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{j-1}({\\mathbf{D}}^{%&#10;\\prime})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq|\\phi_{j-1}({\\mathbf{D}}^{\\ell})|\\cdot|{\\mathrm{lib}}(\\phi_{j%&#10;-1})|^{|D^{\\prime}|}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mi>lib</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>D</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo></mrow></msup></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;|\\phi_{j}({\\mathbf{D}}^{\\ell})|\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq|\\phi_{j}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{j}({\\mathbf{D}}^{%&#10;\\prime})|\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{j}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\n\nNow choose $k'$ such that for every $j$ with $i \\le j<n$ we have\n", "itemtype": "equation", "pos": 76848, "prevtext": "\nAnalogously, we get for every $\\ell>k$ that\n", "index": 47, "text": "\\[|\\phi_{i-1}({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|<|\\phi_n({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m1\" class=\"ltx_Math\" alttext=\"|\\phi_{i-1}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|&lt;|\\phi_{n}({%&#10;\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>&lt;</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nThen we have for every $\\ell > k'$ and every $i \\le j<n$\n\n", "itemtype": "equation", "pos": 77019, "prevtext": "\n\nNow choose $k'$ such that for every $j$ with $i \\le j<n$ we have\n", "index": 49, "text": "\\[\\frac{|\\phi_{j+1}({\\mathbf{D}})|^{k'}}{|\\phi_{j}({\\mathbf{D}})|^{k'}} > {|{\\mathrm{lib}}(\\phi_{j})|^{|D'|}}.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m1\" class=\"ltx_Math\" alttext=\"\\frac{|\\phi_{j+1}({\\mathbf{D}})|^{k^{\\prime}}}{|\\phi_{j}({\\mathbf{D}})|^{k^{%&#10;\\prime}}}&gt;{|{\\mathrm{lib}}(\\phi_{j})|^{|D^{\\prime}|}}.\" display=\"block\"><mrow><mrow><mfrac><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc03</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><msup><mi>k</mi><mo>\u2032</mo></msup></msup><msup><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc03</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><msup><mi>k</mi><mo>\u2032</mo></msup></msup></mfrac><mo>&gt;</mo><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mi>lib</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03d5</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>D</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo></mrow></msup></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nSimilarly, we get for every $\\ell >k$ that\n", "itemtype": "equation", "pos": 77189, "prevtext": "\nThen we have for every $\\ell > k'$ and every $i \\le j<n$\n\n", "index": 51, "text": "\\begin{align*}\n  |\\phi_{j}({\\mathbf{D}}^\\ell \\times {\\mathbf{D}}')| &= |\\phi_{j}({\\mathbf{D}}^\\ell )| \\cdot |\\phi_{j}( {\\mathbf{D}}')|\\\\\n &\\le |\\phi_{j}({\\mathbf{D}}^\\ell )| \\cdot |{\\mathrm{lib}}(\\phi_{j})|^{|D'|} \\\\\n &< |\\phi_{j+1}({\\mathbf{D}}^\\ell)|\\\\\n &\\le |\\phi_{j+1}({\\mathbf{D}}^\\ell)| \\cdot |\\phi_j({\\mathbf{D}}')|\\\\\n &= |\\phi_{j+1}({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi_{j}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|\" display=\"inline\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{j}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{j}({\\mathbf{D}}^{%&#10;\\prime})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex38.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq|\\phi_{j}({\\mathbf{D}}^{\\ell})|\\cdot|{\\mathrm{lib}}(\\phi_{j})%&#10;|^{|D^{\\prime}|}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><msup><mrow><mo stretchy=\"false\">|</mo><mrow><mi>lib</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\u03d5</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>D</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo></mrow></msup></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex39.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;|\\phi_{j+1}({\\mathbf{D}}^{\\ell})|\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq|\\phi_{j+1}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{j}({\\mathbf{D}}^%&#10;{\\prime})|\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>j</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex41.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{j+1}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\nNow choosing $\\ell=\\max(k,k')$ and noting that \n\n", "itemtype": "equation", "pos": 77627, "prevtext": "\nSimilarly, we get for every $\\ell >k$ that\n", "index": 53, "text": "\\[|\\phi_{i+1}({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|>|\\phi_n({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|.\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex42.m1\" class=\"ltx_Math\" alttext=\"|\\phi_{i+1}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|&gt;|\\phi_{n}({%&#10;\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|.\" display=\"block\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>&gt;</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.03240.tex", "nexttext": "\ncompletes the proof with ${\\mathbf{C}}= {\\mathbf{D}}^\\ell\\times {\\mathbf{D}}'$.\n\\end{proof}\n\n\n{{{ \\section{Proof of Proposition~\\ref{prop:nothomeq}}}}}\\confversion{{\\subsection{Proof of Proposition~\\ref{prop:nothomeq}}}}\n\n\\begin{proof}\n$\\phi(S)$ and $\\phi'(S')$ \nare semi-counting equivalent, so we have by Theorem~\\ref{thm:semiequichar} and Theorem~\\ref{thm:renamingandcounting} that \n$\\widehat{\\phi(S)}$ and $\\widehat{\\phi'(S')}$ are renaming equivalent. \nIt follows that ${\\mathbf{A}}$ and ${\\mathbf{A}}'$ are homomorphically\nequivalent via homomorphisms\n$h:A \\to A'$, $h':A' \\to A$\n that act as bijections between\n$S$ and $S'$.\n\nIf there exists a homomorphism $g$ from ${\\mathbf{A}}$ to ${\\mathbf{A}}'$,\nthen we can extend $h$ (using the definition of $g$)\nto be defined on the components of $\\phi$ deleted\nin the construction of $\\widehat{\\phi}$, to obtain a \nhomomorphism from ${\\mathbf{A}}$ to ${\\mathbf{A}}'$ extending $h$.\nIf there exists a homomorphism $g'$ from ${\\mathbf{A}}'$ to ${\\mathbf{A}}$,\nwe can extend $h'$ in an analogous way.\nHowever, the existence of both such extensions would \nimply by definition that $\\phi(S)$ and $\\phi'(S')$\nare counting equivalent.\nWe may thus conclude that either \nthere is no homomorphism ${\\mathbf{A}}\\rightarrow {\\mathbf{A}}'$ or \nthere is\nno homomorphism ${\\mathbf{A}}'\\rightarrow{\\mathbf{A}}$.\n\\end{proof}\n\n\n\n{{{ \\section{Proof of Lemma~\\ref{lem:splitsemieq}}}}}\\confversion{{\\subsection{Proof of Lemma~\\ref{lem:splitsemieq}}}}\n\n\\begin{proposition}\\label{prop:findCforsce}\n Let $\\phi_1, \\ldots, \\phi_s$ be a set of semi-counting equivalent pp-formulas that are pairwise not counting equivalent. Then there is a structure ${\\mathbf{C}}$ and $i\\in [s]$ such that ${\\mathbf{C}}\\models \\phi_i$ but ${\\mathbf{C}}\\cancel{\\models} \\phi_j$ for all $j\\in [s]\\setminus \\{i\\}$.\n\\end{proposition}\n\\begin{proof}\nLet ${\\mathbf{A}}_1, \\ldots, {\\mathbf{A}}_n$ be the structures of the que\\-ries $\\phi_1, \\ldots, \\phi_n$. By Proposition~\\ref{prop:nothomeq} the structures ${\\mathbf{A}}_i$ are pairwise not homomorphically equivalent. For $i,j\\in [n]$, we write $\\phi_i < \\phi_j$ if there is a homomorphism from ${\\mathbf{A}}_i$ to ${\\mathbf{A}}_j$. It is easy to check that $<$ induces a partial order on the $\\phi_i$. Let $\\phi_i$ be a minimal element of this partial order, then there is no homomorphism from any ${\\mathbf{A}}_j$ to $\\phi_i$ with $i\\ne j$. Setting ${\\mathbf{C}} = {\\mathbf{A}}_i$ completes the proof.\n\\end{proof}\n\n\n\\begin{proof} (Lemma~\\ref{lem:splitsemieq})\n We give and algorithm that recursively computes the $|\\phi_i({\\mathbf{B}})|$ one after the other. So let the parameter and the input be given as in the statement of the lemma. By Proposition~\\ref{prop:findCforsce}, there is an $i\\in [n]$ and a structure ${\\mathbf{C}}$ such that ${\\mathbf{C}}\\models \\phi_i$ but ${\\mathbf{C}}\\cancel{\\models} \\phi_j$ for all $j\\in [s]\\setminus \\{i\\}$. W.l.o.g.~assume $i=s$. Then $|\\phi_i({\\mathbf{B}}\\times {\\mathbf{C}})| = 0$ for $i<s$. Consequently, we have that the oracle lets us compute $c_s \\cdot |\\phi_n({\\mathbf{B}}\\times {\\mathbf{C}})|=c_s\\cdot|\\phi_n({\\mathbf{B}})| \\cdot |\\phi_n({\\mathbf{C}})|$. Computing $|\\phi_n({\\mathbf{C}})|$ by brute force then yields $|\\phi_s({\\mathbf{B}})|$.\n \n Now note that for every structure ${\\mathbf{B}}'$ we can also compute $\\sum_{i=1}^{s-1} c_i \\cdot |\\phi_i({\\mathbf{B}}')|$ by this approach with one subtraction. So we can apply the algorithm again for $\\phi_1, \\ldots, \\phi_{s-1}$, answering oracle queries for the smaller sum $\\sum_{i=1}^{s-1} c_i \\cdot |\\phi_i({\\mathbf{B}}')|$ with the help of the oracle for $\\sum_{i=1}^s c_i \\cdot |\\phi_i({\\mathbf{B}}')|$.\n\\end{proof}\n\n\n\n\n\n{{{ \\section{Proof of Theorem~\\ref{thm:equivalence-theorem}}}}}\\confversion{{\\subsection{Proof of Theorem~\\ref{thm:equivalence-theorem}}}}\n\\label{subsect:proof-of-equiv-theorem}\n\\begin{proof} (Theorem~\\ref{thm:equivalence-theorem})\nWe first describe a counting slice reduction $(U, r)$ from \n${\\mathsf{count}}[\\Phi]$ to ${\\mathsf{count}}[\\Phi^+]$.\nLet $(U', r')$ be the counting slice reduction from\n${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}^*]$\ngiven by Theorem~\\ref{thm:reductionallfree}.\nDefine $U$ to be the set \n$\\{ (\\phi, \\phi^+) ~|~ \\textup{$\\phi$ is a normalized ep-formula } \\}$.\nWhen $(\\phi, \\phi^+) \\in U$,\nwe define\n$r(\\phi(V), \\phi^+, {\\mathbf{B}})$ to be the result of the following\nalgorithm, which is FPT with respect to $(\\pi_1, \\pi_2)$.\nFor each sentence disjunct $\\theta$ of $\\phi(V)$, \nthe algorithm queries \n${\\mathsf{count}}(\\theta, {\\mathbf{B}})$; if for some such disjunct $\\theta$\nit holds that ${\\mathbf{B}} \\models \\theta$, then the algorithm outputs $|V|^{|B|}$.\nOtherwise, for any assignment $f: V \\to B$,\nit holds that ${\\mathbf{B}}, f \\models \\phi$ \nif and only if ${\\mathbf{B}}, f \\models \\phi_{{\\mathrm{af}}}$.\nSo, the algorithm returns \n$r'(\\phi_{{\\mathrm{af}}}, \\phi_{{\\mathrm{af}}}^*, {\\mathbf{B}})$ by running \nthe corresponding algorithm for $r'$.\nIn this run, the algorithm for $r'$ only makes queries of the form\n$(\\psi, {\\mathbf{B}})$ (with $\\psi \\in \\phi_{{\\mathrm{af}}}^*$);\nsuch queries where $\\psi \\in \\phi^{-}_{{\\mathrm{af}}}$ are resolved using\nthe oracle in the definition of counting slice reduction,\nand queries where $\\psi \\in \\phi_{{\\mathrm{af}}}^* \\setminus \\phi_{{\\mathrm{af}}}^-$\nare answered with $0$.\nCorrectness is straightforward to verify.\n\nWe next describe a counting slice reduction \n$(U, r)$ from\n${\\mathsf{count}}[\\Phi^+]$ to ${\\mathsf{count}}[\\Phi]$.\nLet $(U', r')$ denote the counting slice reduction from\n${\\mathsf{count}}[\\Phi^*_{{\\mathrm{af}}}]$ to ${\\mathsf{count}}[\\Phi_{{\\mathrm{af}}}]$\ngiven by Theorem~\\ref{thm:reductionallfree}.\nWe define $U:=\\{ (\\psi, \\{ \\phi \\}) ~|~ \\psi \\in \\phi^+ \\}$.\nWe need to define\n$r(\\psi(V), \\phi(V), {\\mathbf{B}})$ when $(\\psi, \\phi) \\in U$.\n\nLet us describe first an algorithm for {{the mapping}} $r$\nin the case that $\\psi \\in \\phi^{-}_{{\\mathrm{af}}}$.\nLet $({\\mathbf{C}}_1, V), \\ldots, ({\\mathbf{C}}_m, V)$ denote the \npp-formulas in $\\phi^{-}_{{\\mathrm{af}}}$, and let \n${\\mathbf{C}}$ denote the disjoint union of the structures ${\\mathbf{C}}_i$.\nObserve that for any structure ${\\mathbf{D}}$, it holds that\n${\\mathbf{D}} \\times {\\mathbf{C}}, f \\models \\phi$\nif and only if ${\\mathbf{D}} \\times {\\mathbf{C}}, f \\models \\phi_{{\\mathrm{af}}}$, \nsince no sentence disjunct of $\\phi$ holds on ${\\mathbf{C}}$\n(due to the definitions of ${\\mathbf{C}}$ and $\\phi^{-}_{{\\mathrm{af}}}$).\nCall the algorithm for $r'$ to compute\n$r'(\\psi, \\{ \\phi_{{\\mathrm{af}}} \\}, {\\mathbf{B}} \\times {\\mathbf{C}}) = \n|\\psi({\\mathbf{B}} \\times {\\mathbf{C}})|$;\nnote that the oracle queries made by this algorithm\ncan be resolved by an oracle for ${\\mathsf{count}}(\\phi,\\cdot)$, \nsince all such oracle queries have the form \n${\\mathsf{count}}(\\phi_{{\\mathrm{af}}}, \\cdot \\times  {\\mathbf{C}})$.\nAs $|\\psi({\\mathbf{B}} \\times {\\mathbf{C}})| = |\\psi({\\mathbf{B}})| \\cdot |\\psi({\\mathbf{C}})|$,\nby dividing this quantity by $|\\psi({\\mathbf{C}})|$, \none can determine $|\\psi({\\mathbf{B}})|$, which is the desired value.\nNote that by the definition of ${\\mathbf{C}}$, it holds that \n$|\\psi({\\mathbf{C}})|$ is non-zero.\n\nIn order to describe the behavior of the algorithm for $r$\nin the case that $\\psi$ is a sentence disjunct of $\\phi$,\nwe establish the following claim.\nLet $({\\mathbf{A}}, V)$ be the structure view of $\\psi$.\t\n\n{\\bf Claim:} Let $i: V \\to V$ be the identity map on $V$.\nFor each disjunct $\\theta$ of $\\phi$, it holds that\n${\\mathbf{A}}, i \\models \\theta(V)$ if and only if $\\theta = \\psi$.\n\nThe backwards direction is clear, so we prove the forwards direction.\nIf a disjunct $\\theta$ is a free pp-formula, then \n${\\mathbf{A}}, i \\not\\models \\theta(V)$ since\n$\\theta$ contains an atom using a variable $v \\in V$,\nwhereas no tuple of a relation of ${\\mathbf{A}}$ contains any variable from $V$.\nIf a disjunct $\\theta$ is a pp-sentence $({\\mathbf{A}}', V)$\nnot equal to $\\psi$, then by definition of \\emph{normalized} ep-formula,\nthere is no homomorphism from ${\\mathbf{A}}'$ to ${\\mathbf{A}}$ and hence\n${\\mathbf{A}}, i \\not\\models \\theta(V)$.  This establishes the claim.\n\nNow suppose that $\\psi$ is a sentence disjunct of $\\phi$.\nIn this case, the algorithm for $r(\\psi(V), \\phi(V), {\\mathbf{B}})$ \nbehaves as follows.\nIt queries ${\\mathsf{count}}(\\phi, {\\mathbf{A}} \\times {\\mathbf{B}})$ to determine\n$|\\phi({\\mathbf{A}} \\times {\\mathbf{B}})|$;\nit outputs $|B|^{|V|}$ if $|\\phi({\\mathbf{A}} \\times {\\mathbf{B}})|$ is equal\nto $(|A|\\cdot|B|)^{|V|}$ (the \\emph{maximum count} possible there),\nand outputs $0$ otherwise.\nWe prove that this is correct by \nshowing that $|\\phi({\\mathbf{A}} \\times {\\mathbf{B}})|$ is the maximum count\nif and only if ${\\mathbf{B}} \\models \\psi$.\n\nFor the backwards direction, suppose that ${\\mathbf{B}} \\models \\psi$,\nand denote $\\psi$ by $({\\mathbf{A}}, V)$.  Then, there is a homomorphism\nfrom ${\\mathbf{A}}$ to ${\\mathbf{B}}$, and hence there is a homomorphism\nfrom ${\\mathbf{A}}$ to ${\\mathbf{A}} \\times {\\mathbf{B}}$.\nIt follows that for any assignment $f: V \\to V$,\none has ${\\mathbf{A}} \\times {\\mathbf{B}}, f \\models \\psi(V)$.\nFor the forwards direction, suppose that\n$|\\phi({\\mathbf{A}} \\times {\\mathbf{B}})|$ is the maximum count.\nLet $i': V \\to A \\times B$ be any map\nsuch that for each $v \\in V$, the value\n$i'(v)$ has the form $(i(v),j(v))$\nwhere $j: V \\to B$ is a map.\nWe have that ${\\mathbf{A}} \\times {\\mathbf{B}}, i' \\not\\models \\phi(V)$.\nIt follows that there is a disjunct $\\theta$ of $\\phi$\nsuch that\n${\\mathbf{A}} \\times {\\mathbf{B}}, i' \\models \\theta(V)$.\nIt follows that\n${\\mathbf{A}}, i \\models \\theta(V)$ and ${\\mathbf{B}}, j \\models \\theta(V)$.\nBy the claim established above, we have that $\\theta = \\psi$.\nThen, it holds that ${\\mathbf{B}}, j \\models \\psi$, and we are done.\n\\end{proof}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 77780, "prevtext": "\nNow choosing $\\ell=\\max(k,k')$ and noting that \n\n", "index": 55, "text": "\\begin{align*}|\\phi_{i}({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|&= |\\phi_{i}({\\mathbf{D}}^\\ell)|\\cdot|\\phi_{i}({\\mathbf{D}}')|\\\\ & \\ne |\\phi_n({\\mathbf{D}}^\\ell)| \\cdot |\\phi_n({\\mathbf{D}}')|  \\\\& = |\\phi_n({\\mathbf{D}}^\\ell\\times {\\mathbf{D}}')|\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|\\phi_{i}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|\" display=\"inline\"><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{i}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{i}({\\mathbf{D}}^{%&#10;\\prime})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex44.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\neq|\\phi_{n}({\\mathbf{D}}^{\\ell})|\\cdot|\\phi_{n}({\\mathbf{D}}^{%&#10;\\prime})|\" display=\"inline\"><mrow><mi/><mo>\u2260</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u22c5</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex45.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=|\\phi_{n}({\\mathbf{D}}^{\\ell}\\times{\\mathbf{D}}^{\\prime})|\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>\u03d5</mi><mi>n</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>\ud835\udc03</mi><mi mathvariant=\"normal\">\u2113</mi></msup><mo>\u00d7</mo><msup><mi>\ud835\udc03</mi><mo>\u2032</mo></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></math>", "type": "latex"}]