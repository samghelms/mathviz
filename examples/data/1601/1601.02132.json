[{"file": "1601.02132.tex", "nexttext": "\nwhich samples $y$ twice so that the values of $v$ and $w$ may differ.\n\nReplacing $y$ in the law~(\\ref{law-posvals-y}) with an expression $e$ introduces the complication that \neach variable reference in the evaluation of $e$ in the assignment could be accessed in a different state.\nNote that if $e$ has multiple references to a single variable $y$,\neach reference could be accessed in a different state.\nHowever, if $e$ has only a single reference to a variable $y$ and \nall other variables in $e$ are stable, any evaluation of $e$ is equivalent to evaluating it \nin the state in which $y$ is accessed and the law is valid.\nLet $S$ be a set of variables such that the free variables of $e$ are contained in $S \\union \\{ y \\}$\nand $e$ has only a single reference to $y$ and accesses to $y$ are atomic, then\n\n\\begin{eqnarray}\\label{law-single-reference-posvals}\n  {{\\mathop{\\kw{rely}}} {(x' = x \\And (\\bigwedge z \\in S {\\mathrel{\\suchthat}} z' = z))} \\suchthat {\\Spec{x}{}{x' \\in {\\wideparen{{e}}}}}} \\ \\ & {\\mathrel{\\sqsubseteq}} & \\ \\  x \\gets e\\ .\n\\end{eqnarray}\n\nIf $e$ is of the form $d(f)$ for a mapping $d$ and expression $f$,\nstability is required on the program variables in $f$\nbut stability is not required for the whole of $d$, just $d(f)$,\nbecause the other elements of $d$ have no effect on the expressions value.\n\nIf the expression $e$ contains multiple references to a variable $x$,\nsaving $x$ in a local variable $t$ and then evaluating $e$ in terms of $t$ \nensures that the value used for $x$ is from a single state.\nThe following refinement law ensures $x$ is sampled once.\nIt is assumed that $r$ and $t$ are local variables \n(and hence the environment cannot change them)\nand that $r$ and $t$ do not occur free in $e$. \n\n\n\\begin{eqnarray}\\label{law-posvals-pre-assignment}\n  \\Spec{t,r}{}{ r' \\in {\\wideparen{{e[x/v]}}} } \n  \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \n  {\\langle {t \\gets x} \\rangle} \\ ;\\  \\Spec{r}{}{ r' \\in {\\wideparen{{e[t/v]}}} }\n\\end{eqnarray}\nFor this to be valid one needs to rely on the environment maintaining \n${\\wideparen{{e[t/v]}}} \\subseteq {\\wideparen{{e[x/v]}}}$,\nfor the duration of the command.\nThis holds provided the rely condition\n", "itemtype": "equation", "pos": 23343, "prevtext": "\n\n\\journal{Logical and Algebraic Methods in Programming}\n\n\\begin{frontmatter}\n\n\\title{Possible values:\nexploring a concept for concurrency}\n\\author[nu]{Cliff B. Jones\\corref{cor1}} \n\n\\author[uq]{Ian J. Hayes}\n\n\\cortext[cor1]{Corresponding author}\n\n\\address[nu]{School of Computing Science, Newcastle University, UK}\n\\address[uq]{School of Information Technology and Electrical Engineering, The University of Queensland, Australia}\n\n\\begin{abstract} \nAn important issue in concurrency is interference.\nThis issue manifests itself in both shared-variable\nand communication-based concurrency --- this paper focusses on the former case where interference is caused by the environment of a process changing the values of shared variables.\nRely/guarantee approaches have been shown to be useful in specifying and reasoning\ncompositionally about concurrent programs.\nThis paper explores the use of a ``possible values'' notation for reasoning about variables whose values can be changed multiple times by interference.\nApart from the value  of this concept in providing clear specifications,\nit offers a principled way of avoiding the need for some auxiliary (or ghost) variables\nwhose unwise use can destroy compositionality.\n\n\\end{abstract}\n\n\\begin{keyword}\nConcurrent programming \\sep rely/guarantee conditions \\sep possible values\n\\end{keyword}\n\n\n\\end{frontmatter}\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Introduction} \n\\label{S-intro}\n\nHigh on the list of issues that make the design of concurrent programs difficult to get right is `interference'.\nReproducing a situation that exhibited a `bug' can be frustrating;\nattempting to reason informally about all possible interleavings of interference can be exasperating;\nand designing formal approaches to the verification of concurrent programs is challenging.\n\nRecording post conditions for sequential programs applies the only real tool that we have:\nabstraction is achieved by winnowing out what is inessential in the relationship between the initial and final states of a computation.\nPost conditions record the required relationship without fixing an algorithm to bring about the transformation;\nfurthermore, they record required properties only of those variables which the environment will use.\nThe rely/guarantee approach (see~Section~\\ref{S-RG})\nuses abstraction in the same way to provide specifications of concurrent software components that are more abstract than their implementations:\nfor any component,\nrely conditions are relations that record interference that the component must tolerate and \nguarantee conditions document the interference that the environment of the component must accept.\n\nThis paper explores a concept that fits well with rely/guarantee reasoning but probably has wider applicability.\nIn relational post conditions, it is necessary to be able to refer to the initial value $x$ and final value $x'$ of a variable $x$\n(e.g.~$x \\leq x' \\leq x + 9$).\nIf however it is necessary to record something as simple as the fact that a local variable $x$\ncaptures one of the values of a shared variable $y$,\nit is inadequate to write $x' = y \\Or x' = y'$ in the case where $y$ might be changed many times by the environment.\nEnter `possible values':\nthe suggested notation is that ${\\wideparen{{y}}}$ denotes the set of values which variable $y$  contains during the execution of the operation in whose specification ${\\wideparen{{y}}}$ is written. So,\n(assuming the access to read the value of $y$ is atomic):\n\n\\begin{formula}\npost-Op: x' \\in {\\wideparen{{y}}}\n\\end{formula}\n\n\\noindent\nis satisfied by a simple assignment of $y$ to $x$.\n \n\n\\subsection{Rely/Guarantee thinking}\n\\label{S-RG}\n\nBefore going into more detail on the possible values notation\n(see~Section~\\ref{S-pv}),\na brief overview of background work is offered.\nThe specifications given in Section~\\ref{S-4slot} are written \nin the notation of VDM~\\cite{Jones80a,Jones90a}.\nIt is unlikely that they will present difficulties even to readers unfamiliar with that specific notation because similar ideas for sequential programs are present in\nZ~\\cite{Hayes93},\nB~\\cite{Abrial96},\nEvent-B~\\cite{Abrial10},\nand\nTLA~\\cite{lamport03}.\nThe basic idea is of state-based specifications with operations (or events) \ntransforming the state and  being specified by something like pre and post conditions.\nPre conditions are predicates over states that indicate what can be assumed about states in which an operation can be initiated.\nPost conditions are relations over initial and final states that specify the required relations between the initial and final values of state components.\nGood sequential specifications eschew any details of implementation algorithms:\nthey do not specify anything about intermediate states;\nin fact an implementation might use a state with more components.\nAt first sight, it might appear surprising that there is not a precise functional requirement on the final state but using\nnon-determinism in specifications turns out to be an extremely useful way of postponing design decisions.\n\nThe use of abstract objects in specifications is a crucial tool for larger applications.\nMoreover, datatype invariants can make specifications clearer:\nrestricting types by predicates simplifies pre/post conditions and\nalso offers a way for the specifier to record the intention of a specification.\nAnother useful aspect of VDM is the ability to define more tightly the `frame' of an operation by recording whether access to state components is for (only) reading or for both reading and writing.\n\\footnote{Most of the literature on rely/guarantee conditions\nis limited to normal (or `scoped') variables;~\\cite{SEFM-15-paper} shows how `heap' variables can be viewed as representations of more abstract states.}\n\nThe basic rely/guarantee~\\cite{Jones81d,Jones83a} idea\n\\footnote{The literature on rely/guarantee approaches continues to expand;\nsee~\\cite{FACJexSEFM-14,HayesJonesColvin14TR}  for further references.\nFor a reader who is completely unfamiliar with rely/guarantee concepts,\na useful brief presentation can be found in~\\cite{Jones96a}.}\nis simple:\ninterference is documented and proof rules are given which support reasoning about interference in \nconcurrent threads.\nJust as in sequential specifications,\nthe role of a state is central to recording rely/guarantee specifications.\nFor concurrency,\nit is accepted that the environment of a process can change values in the state during execution of an operation.\n\\footnote{Notice that there is an essential difference here from `actions'~\\cite{BackAtomicityRefinement}\nor `events'~\\cite{Abrial10} which view execution of a guarded action as atomic.}\nSuch changes are however assumed to be constrained by a rely condition.\nIn order to reason about the combined effect of operations,\nthe interference that a process can inflict on its environment is also recorded;\nthis is done in a guarantee condition.\nBoth rely and guarantee conditions are, for obvious reasons,\nrelations over states.\nIn the original form \n--and after many experiments--\n both conditions are reflexive and transitive\ncovering the possibility of zero or many steps.\nSuch relations often indicate monotonic evolution of variables.\n\nIt is useful to compare the roles of rely and guarantee conditions with the better known pre/post conditions.\nPre conditions are essentially an invitation to the designer of a specified component to ignore some starting states;\nin the same way, the developer can ignore the possibility that interference will make state changes that do not satisfy the rely condition.\nIn neither case should a developer include code to test these assumptions;\nthere is an implicit requirement to prove that the component is only used in an appropriate context.\nIn contrast, post conditions and guarantee conditions are obligations on the running code that the developer has to create;\nthese conditions record properties on which the deployer can depend.\n\n\\begin{figure}\n\\begin{center}\n\\begin{eqnarray*}\n\\begin{array}{c}\nf \\gets \\mathsf{wr};\\\\\n \\left.\n  \\begin{array}{l}\n   \\kw{while}\\ \\mathsf{true}\\ \\kw{do}\\\\\n    \\ \\ \\begin{array}{l}\n     \\cdots \\mbox{produce $v$} \\cdots\\\\\n     \\begin{array}{l}\n     \\kw{while}\\ f=\\mathsf{rd}\\ \\kw{do skip od};\\\\\n     b \\gets v;\\\\\n     f \\gets \\mathsf{rd}\n     \\end{array}\\\\\n  \\end{array}\\\\\n   \\kw{od}\n  \\end{array}\n \\ \\ \\right|\\left|\\ \\ \n \\begin{array}{l}\n  \\kw{while}\\ \\mathsf{true}\\ \\kw{do}\\\\\n   \\ \\ \\begin{array}{l}\n     \\begin{array}{l}\n     \\kw{while}\\ f=\\mathsf{wr}\\ \\kw{do skip od};\\\\\n     r \\gets b;\\\\\n     f \\gets \\mathsf{wr}\n     \\end{array}\\\\\n    \\cdots \\mbox{consume $r$} \\cdots\n   \\end{array}\\\\\n   \\kw{od}\n  \\end{array} \n  \\right.\n\\end{array}\n\\end{eqnarray*}\n\n\\begin{eqnarray*}\n \\left.\n  \\begin{array}{l}\n   \\kw{guar} \n     \\begin{array}[t]{l} \n       (f=\\mathsf{rd} \\Implies b'=b) \\And {} \\\\\n       (f=\\mathsf{rd} \\Implies f'=\\mathsf{rd})\n     \\end{array} \\\\\n   \\kw{rely } f=\\mathsf{wr} \\Implies f'=\\mathsf{wr}\n \\end{array}\n \\ \\\n \\begin{array}{l}\n  \\begin{array}{l}\n   \\kw{rely} \n     \\begin{array}[t]{l}\n       (f=\\mathsf{rd} \\Implies b'=b) \\And {} \\\\\n       (f=\\mathsf{rd} \\Implies f'=\\mathsf{rd})\n     \\end{array}\\\\\n   \\kw{guar } f=\\mathsf{wr} \\Implies f'=\\mathsf{wr}\n \\end{array}\n  \\end{array} \n  \\right.\n\\end{eqnarray*}\\end{center}\n\\caption{A one-place buffer}\n\\label{F-1place}\n\\end{figure}\n\nThe simplest form of relation that could be used in rely or guarantee conditions is to state that the value of a variable remains unchanged (e.g.~$b' = b$).\nSuch unconditional constraints are normally better handled by marking an operation\n(or part thereof) as having only read access.\nThere is however an important way to combine `monotonic' changes to flags with assertions about variables remaining unchanged.\nConsider a simple one-place buffer \nin which a producer process places a value in a buffer variable $b$ from which a consumer process extracts values. \nTesting and setting flag $f$ in Figure~\\ref{F-1place}\nensures that the producer and consumer alternate their access to $b$.\nDuring its read phase, the consumer needs to rely on the fact that the value of $b$ cannot change but\nthis is too strong as a rely condition for the whole of the consumer process ---\nthe producer process could never insert anything into the buffer if it were required to achieve a guarantee condition of $b' = b$.\nBut the consumer process can instead rely on $f = \\mathsf{rd} \\Implies b' = b$, which in turn is easy for the \nproducer to guarantee. \nThe `monotonic' behaviour of the flags means that the producer has also to guarantee that $f = \\mathsf{rd} \\Implies f' = \\mathsf{rd}$\nand the consumer must guarantee $f = \\mathsf{wr} \\Implies f' = \\mathsf{wr}$.\nThis example shows one way in which rely/guarantee conditions can be used to reason about race-free programs.\nIt also illustrates a technique that is used in Section~\\ref{S-4slot} to locate what is going on in the environment without adding auxiliary variables.\nThe example tackled in Section~\\ref{S-4slot} is however much more challenging than this simple one-place buffer.\n\n\n\n\\subsection{Law for mutual strengthening of guarantee and rely}\\label{S-strengthening-law} \n\nAs part of the example in Section~\\ref{S-4slot}, \na new facet of rely/guarantee refinement is needed:\nit allows mutual strengthening of both rely and guarantee conditions \nfor a portion of one process.\nThe approach is a contribution to rely/guarantee refinement and \n\nit makes it possible to avoid introducing additional auxiliary variables \n(see~Section~\\ref{s:auxiliary})\nin order to handle the example in Section~\\ref{S-4slot}.\n\nIn the standard approach to rely/guarantee refinement,\nwhen two parallel processes are introduced each has an associated rely/guarantee pair\nand there is an obligation to show that the guarantee of each implies the rely of the other.\nNormally the one rely/guarantee pair suffices to handle the refinement of a process\nbut for the example in Section~\\ref{S-4slot} that is not sufficient.\n\nIn the standard theory, rely/guarantee pairs are often mutually dependent:\nfor the two-process case,\na process $P$ maintaining its guarantee may be dependent on its environment\n(process $Q$) \nmaintaining the rely of $P$ (by $Q$ maintaining its guarantee)\nand vice versa.\nFor example, $P$ may guarantee to maintain $x \\geq 0$\nprovided it can rely on its environment maintaining $x \\geq 0$.\nThe guarantee, $g$, of a process has to hold for every atomic program step it makes\nand hence $g$ has to be weak enough to be maintained by every step.\nHowever, for a subpart $S$ of $P$, \nall the atomic steps of $S$ may imply a stronger guarantee $gs$.\nAs $P$ forms the environment of process $Q$, while $P$ is executing subpart $S$,\n$Q$ may assume a stronger rely condition of $gs$ and as a consequence of this \nits own guarantee may be strengthened from $r$ to $rs$,\nwhich in turn allows process $P$ to assume a stronger rely condition $rs$,\nbut only while it is executing subpart $S$.\nNote that while only a subpart $S$ of $P$ is of concern,\nthe whole of $Q$ has to be considered for the strengthening of its rely and guarantee.\n\nIn order to establish the strengthened rely/guarantee pair for the duration of $S$,\nthe state when $P$ enters $S$ may need to satisfy an initial condition $j$.\n\nFor the example in Section~\\ref{S-4slot} a special case of the above reasoning\napplies in which the guarantee of $P$ is strengthened to state that \n$P$ does not modify any shared variables.\nIn this case one needs to show that process $Q$ maintains the stronger rely $rs$\nfrom any initial state satisfying $j$ provided $Q$ suffers no inference from $P$.\n\n\n\\subsection{Connection to data abstraction/reification}\\label{S-data-reification} \n\nIt  is important to appreciate how rely relations abstract from the detail of the actual environmental interference of an operation. \nObviously, the most detailed information about an environment is the actual state changes it makes.\nBut designing to such concrete detail would create a component that is not robust to change.\nJust as post conditions deliberately omit implementation details of a specified operation,\nit is useful to strive for an abstract documentation of interference.\nIt is clear that relations cannot record certain sorts of information but, if they are adequate for a given task, their use will yield a more compositional development than the detail of the environment.\n\nThe extended example in Section~\\ref{S-4slot} shows the importance of linking rely/guarantee ideas with data abstraction and reification.\nSpecification using abstract mathematical objects and the process of stepwise introduction of more concrete\n(i.e.~closer to hardware)\nobjects is well established for sequential programs and for significant applications is often more telling than the abstraction that comes from post conditions ---\nsee, for example,~\\cite{Jones90a}.\nIn addition to layering design decisions, \ncareful use of abstract objects in the development of concurrent programs \noffers other advantages.\nIn particular, \ndevelopments can appear to allow data races at an abstract level that are removed by careful choice of a concrete representation ---\nthis is discussed in~\\cite{Jones06a}.\nOne reason that this is interesting is Peter O'Hearn's suggested dichotomy in~\\cite{OHearn07}\nthat separation logic is appropriate \nfor reasoning about race avoidance whilst rely/guarantee methods fit `racy' programs.\nThe distinction between abstract and concrete data races is perfectly illustrated in Section~\\ref{S-4slot} but the example is not easy to summarise.\nA  simpler example is searching an array to find the lowest index of an element that satisfies a predicate $P$\nby means of two parallel processes that search the elements with, respectively, even and odd indices\n(for a full development of this example, see~\\cite{HayesJonesColvin14TR}).\nIf a single variable $t$ were used to record the least index of an element that satisfies $P$,\nit would be necessary to have locks in the the two processes \nto avoid a data race on $t$.\nA neat way to avoid the `write/write' race is to represent $t$ by the minimum of two variables, $et$ and $ot$ \nthat record the least value of, respectively, even and odd indices where the array element satisfies $P$.\nThe `write/write' race, which is useful in an abstract description of the design, is reduced to a `read/write' race because the actual code for each process updates only one of the variables\nalthough it reads the other variable in its loop test\n(and on the completion of both processes $t$ can be retrieved as $min(et,ot)$).\n\nThe citations above relate to the original form of rely/guarantee reasoning in which the (potentially) four conditions are combined.\nMore recent work\nhas shown how separate rely and/or guarantee constraints can be wrapped around any command including conventional refinement calculus style specifications.\nThe presentation in~\\cite{FACJexSEFM-14,HayesJonesColvin14TR} of rely/guarantee thinking \nmakes algebraic properties clearer.\n\n\n\\subsection{Plan of this paper}\n\nThis paper  provides evidence of the usefulness of the possible values concept.\nSection~\\ref{S-pv} presents a notation for the concept\nwhile Section~\\ref{S-4slot} is an extended  example using the concept and notation.\nSection~\\ref{S-sem} outlines how a semantic model can be provided and looks at the form of laws that would fit the newer presentation of rely/guarantee \nreasoning~\\cite{HayesJonesColvin14TR,FACJexSEFM-14}.\nThe current authors recognise that this paper  represents the start of an exploration ---\nsome avenues to be investigated are mentioned in Section~\\ref{S-conc}.\n\n\n\n\n\\section{Possible values} \n\\label{S-pv}\n\nIt is argued above that the confessed expressive weakness of rely/guarantee specifications serves the purpose of preserving some form of compositionality in the\ndesign of concurrent programs.\nHowever,\nif notations can be found that increase expressive power,\nthey should be evaluated both for expressiveness and tractability.\n\nThe simple case mentioned above of using one or more possible values terms in a post condition is considered first and issues about extension are deferred to Section~\\ref{S-conc}.\n\n\n\\subsection{Possible values of variables} \n\nIf an operation only has read access to a shared variable $y$\nand $x$ is a local variable of the process, then:\n\n\\begin{eqnarray}\\label{posvals-example1}\npost-Op: x' \\in {\\wideparen{{y}}}\n\\end{eqnarray}\n\n\\noindent\nrequires that the final value of the variable $x$ should contain one of the values that the environment places in the variable $y$ ---\nthis includes the (initial) value of $y$ at the time $Op$ began execution.\nSo ${\\wideparen{{y}}}$ denotes a set of values whose elements have the type of $y$.\n\nNotice that the post condition above is `stable' in the sense that the environment might change the value of $y$ after $Op$ accesses the variable and the post condition is still true.\nIn contrast, it would be unwise to write a post condition that contained\n$x' \\notin {\\wideparen{{y}}}$\nbecause this would not be stable and it would appear to require that every possible change that the environment makes to the value of $y$ is observed.\n(In some cases, it would be possible to establish such a result \nunder a suitable rely condition;\nbut some form of (local) datatype invariant should also be considered in such cases.)\n\nSo, for the straightforward case,\nthe post condition (\\ref{posvals-example1}) can be established by the atomic assignment $x \\gets y$.\nAs is reported in Section~\\ref{S-ACM-approaches},\nan instance of this simple case was the inspiration for the possible values notation.\nThere are however several vectors of extension.\nIf the process in which the ${\\wideparen{{y}}}$ term is written also has write access to the variable $y$,\nit is necessary to take a position on whether both environment assignments to $y$ and those of the component itself are reflected in ${\\wideparen{{y}}}$;\nthe view of the current authors is that ${\\wideparen{{y}}}$ contains \nall values of $y$ that could be observed by the process.\n\n\n\n\\subsection{Semantics and laws}\\label{S-laws} \n\\label{S-sem}\n\n\n\nIt is not difficult to see how a formal meaning can be given to the simple form of \nthe possible values notation in a semantics such as that in~\\cite{HayesJonesColvin14TR}:\n\nbasically, that portion of the sequence of states that corresponds to the execution of an operation \nis distinguished so as to identify the first and last states in order to give a semantics to post conditions.\nIt is only necessary to consider all of the states in that portion and to extract the set of values \nof the relevant variable.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnother interesting semantic issue concerns locking.\nIn fact, the possible values notation forces consideration of a number of facets of `atomicity'.\n\nLocking may be used to ensure mutually exclusive access to a set of variables.\nA process may lock a resource protecting a set of variables.\nWhile it owns the lock, it may make multiple changes to the variables protected by the lock,\nhowever, any other processes accessing the protected variables cannot observe \nany of the intermediate states of the protected variables.\nHence a process in the scope of a resource with a set of protected variables can only \nobserve the initial and final states of a protected block within another process.\n\nThroughout the body of a protected block a process can rely on the protected variables being stable.\nFurthermore, any guarantee involving just the protected variables has to hold only between\nthe initial and final states of the protected block.\n\nJust as the semantics for the straightforward use of possible values terms in a post condition\nposes no difficulties in terms of the underlying traces,\na rather simple law suffices to reason about the notation.\nHere, it is convenient to switch to the refinement calculus style \nof~\\cite{FACJexSEFM-14,HayesJonesColvin14TR}\nin which the specification statement $\\Spec{x}{}{q}$ establishes the postcondition $q$\nand modifies only $x$, \nand the command $c$ in a rely context of $r$ is written ${{\\mathop{\\kw{rely}}} {r} \\suchthat {c}}$.\nAssuming a read of $y$ is atomic, the following law holds.\n\n\\begin{eqnarray}\\label{law-posvals-y}\n  {{\\mathop{\\kw{rely}}} {(x' = x)} \\suchthat {\\Spec{x}{}{ x' \\in {\\wideparen{{y}}}}}} \\ \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \\  x \\gets y\n\\end{eqnarray}\n\n\\noindent\nThe rely condition $x' = x$ is required to ensure that the environment doesn't change $x$\nafter the assignment is made.\nFor example, $x$ may be a local variable or,\nas below in Section~\\ref{S-4-spec}, annotated $\\kw{owns wr}\\ x$.\n\n\n\\subsection{Possible values of expressions} \n\nFor the set of possible values of an expression, ${\\wideparen{{e}}}$, \none needs to consider the corresponding set of states of the execution\nand form the set of values of $e$, each evaluated in one of those states.\nImportantly, all values of program variables used in $e$ are sampled in a single\nstate for each evaluation.\nFor example, for the specification\n\\begin{eqnarray}\\label{posvals-y-plus-y}\n  \\Spec{x}{}{ x' \\in {\\wideparen{{y+y}}} }\n\\end{eqnarray}\nboth occurrences of $y$ are sampled in the same state\nand hence the resultant value is always even\n(assuming the variables are integer valued).\nNote that there is a subtle difference between (\\ref{posvals-y-plus-y}),\nwhich samples $y$ once, and\n", "index": 1, "text": "\n\\[\n  \\Spec{x}{}{ \\exists{v,w}{v \\in {\\wideparen{{y}}} \\And w \\in {\\wideparen{{y}}} \\And x' = v+w} }\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\Spec{x}{}{\\exists{v,w}{v\\in{\\wideparen{{y}}}\\And w\\in{\\wideparen{{y}}}\\And x^%&#10;{\\prime}=v+w}}\" display=\"block\"><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\Spec</mtext></merror><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><mrow><mo>\u2203</mo><mi>v</mi></mrow></mrow><mo>,</mo><mrow><mi>w</mi><mo>\u2062</mo><mi>v</mi></mrow></mrow><mo>\u2208</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\And</mtext></merror><mo>\u2062</mo><mi>w</mi></mrow><mo>\u2208</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mo>\u2062</mo><mi>y</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\And</mtext></merror><mo>\u2062</mo><msup><mi>x</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mrow><mi>v</mi><mo>+</mo><mi>w</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02132.tex", "nexttext": "\nis maintained by the environment,\nwhere $e[t/v]'$ stands for $e[t/v]$ evaluated in the after state,\ni.e.\\ $e'$ is $e$ with every program variable $y$ in $e$ replaced by $y'$.\n\nLaw (\\ref{law-posvals-pre-assignment}) can be justified as follows.\nThe atomic statement ${\\langle {t \\gets x} \\rangle}$ establishes $e[t/v] = e[x/v]$.\nAn environment step that has a final state in which $x' = t$ establishes \n$e[t/v]' = e[x/v]'$\notherwise the environment establishes\n$e[t/v]' = e[t/v] = e[x/v]$.\n\n\nAs an example consider the case in which the expression $e$ is $d(v)$.\nApplying (\\ref{law-posvals-pre-assignment}) gives\n\\begin{eqnarray}\n  \\Spec{t,r}{}{ r' \\in {\\wideparen{{d(x)}}} } \n  \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \n  {\\langle {t \\gets x} \\rangle} \\ ;\\  \\Spec{r}{}{ r' \\in {\\wideparen{{d(t)}}} }\n\\end{eqnarray}\nprovided its environment ensures the condition: $x' \\neq t \\implies d'(t) = d(t)$.\nImmediately after the atomic assignment to $t$, \n\n", "itemtype": "equation", "pos": 25619, "prevtext": "\nwhich samples $y$ twice so that the values of $v$ and $w$ may differ.\n\nReplacing $y$ in the law~(\\ref{law-posvals-y}) with an expression $e$ introduces the complication that \neach variable reference in the evaluation of $e$ in the assignment could be accessed in a different state.\nNote that if $e$ has multiple references to a single variable $y$,\neach reference could be accessed in a different state.\nHowever, if $e$ has only a single reference to a variable $y$ and \nall other variables in $e$ are stable, any evaluation of $e$ is equivalent to evaluating it \nin the state in which $y$ is accessed and the law is valid.\nLet $S$ be a set of variables such that the free variables of $e$ are contained in $S \\union \\{ y \\}$\nand $e$ has only a single reference to $y$ and accesses to $y$ are atomic, then\n\n\\begin{eqnarray}\\label{law-single-reference-posvals}\n  {{\\mathop{\\kw{rely}}} {(x' = x \\And (\\bigwedge z \\in S {\\mathrel{\\suchthat}} z' = z))} \\suchthat {\\Spec{x}{}{x' \\in {\\wideparen{{e}}}}}} \\ \\ & {\\mathrel{\\sqsubseteq}} & \\ \\  x \\gets e\\ .\n\\end{eqnarray}\n\nIf $e$ is of the form $d(f)$ for a mapping $d$ and expression $f$,\nstability is required on the program variables in $f$\nbut stability is not required for the whole of $d$, just $d(f)$,\nbecause the other elements of $d$ have no effect on the expressions value.\n\nIf the expression $e$ contains multiple references to a variable $x$,\nsaving $x$ in a local variable $t$ and then evaluating $e$ in terms of $t$ \nensures that the value used for $x$ is from a single state.\nThe following refinement law ensures $x$ is sampled once.\nIt is assumed that $r$ and $t$ are local variables \n(and hence the environment cannot change them)\nand that $r$ and $t$ do not occur free in $e$. \n\n\n\\begin{eqnarray}\\label{law-posvals-pre-assignment}\n  \\Spec{t,r}{}{ r' \\in {\\wideparen{{e[x/v]}}} } \n  \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \n  {\\langle {t \\gets x} \\rangle} \\ ;\\  \\Spec{r}{}{ r' \\in {\\wideparen{{e[t/v]}}} }\n\\end{eqnarray}\nFor this to be valid one needs to rely on the environment maintaining \n${\\wideparen{{e[t/v]}}} \\subseteq {\\wideparen{{e[x/v]}}}$,\nfor the duration of the command.\nThis holds provided the rely condition\n", "index": 3, "text": "\n\\[\n  x' \\neq t \\land t' = t \\implies e[t/v]' = e[t/v]\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"x^{\\prime}\\neq t\\land t^{\\prime}=t\\implies e[t/v]^{\\prime}=e[t/v]\" display=\"block\"><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>\u2260</mo><mrow><mi>t</mi><mo>\u2227</mo><msup><mi>t</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mrow><mi>t</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\implies</mtext></merror><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">[</mo><mrow><mi>t</mi><mo>/</mo><mi>v</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2032</mo></msup></mrow><mo>=</mo><mrow><mi>e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>t</mi><mo>/</mo><mi>v</mi></mrow><mo stretchy=\"false\">]</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02132.tex", "nexttext": "\nIf the environment makes a step that does not change $x$, \n(\\ref{posvals-d(t)}) is maintained because $d'(t') = d'(x')$\nbut if the environment changes $x$ so that it no longer equals $t$\none can no longer rely on $d'(t')$ being the same as $d'(x')$.\nHowever, if one can rely on $d(t)$ being stable\nand because $d(t) = d(x)$ and $d'(t') = d(t)$,\none can still deduce $d'(t') = d(x)$.\n\n\n\n\n\n\\section{Asynchronous Communication Mechanisms} \n\\label{S-4slot}\n\nAn Asynchronous Communication Mechanism (ACM)\nlogically provides a one-place buffer between a single writer and a single reader\n(see Figure~\\ref{F-loops}).\nThis sounds trivial but the snag is in the adjective:\nACMs are asynchronous in the sense that neither the reader nor the writer \nshould ever be held up by locks.\n\\footnote{\\label{FN-cf}This contrasts with the simple one-place buffer in Section~\\ref{S-intro}\nwhere the code would `busy wait' on the value of a flag to control alternation between the producer and consumer.}\nUnless the value being communicated via the buffer is small enough to be read and written atomically,\nit should be obvious that one slot is not enough to realise the buffer; \na little thought shows that a buffer representation with two slots is also inadequate;\nthe topic of how many slots are required is returned to in Section~\\ref{S-reif1}.\nIn~\\cite{Simpson90}, \nHugo Simpson proposed a `four-slot' algorithm \nto implement an ACM for which,\nwhile the code is short,\nextremely subtle reasoning is required for its justification.\n\n\\begin{figure}\n\\begin{center}\n\\begin{eqnarray*}\n \\left.\n  \\begin{array}{l}\n   \\kw{while } \\mathsf{true} \\kw{ do}\\\\\n    \\ \\ \\begin{array}{l}\n     \\cdots \\mbox{produce $v$} \\cdots\\\\\n     Write(v)\n    \\end{array}\\\\\n   \\kw{od}\n  \\end{array}\n \\ \\ \\right|\\left|\\ \\ \n \\begin{array}{l}\n  \\kw{while } \\mathsf{true} \\kw{ do}\\\\\n   \\ \\ \\begin{array}{l}\n    r \\; \\gets \\; Read()\\\\\n    \\cdots \\mbox{consume $r$} \\cdots\n   \\end{array}\\\\\n   \\kw{od}\n  \\end{array} \n  \\right.\n\\end{eqnarray*}\n\\end{center}\n\n\\caption{Code to clarify reader/writer structure}\n\\label{F-loops}\n\\end{figure}\n\n\n\\subsection{ACM requirements}\\label{S-ACM-requirements}\n\nThe requirement is to \ncommunicate the ``most recent'' value from a single producer to a single consumer via a shared buffer.\nMore precisely, it must satisfy the following.\n  \\begin{itemize}\n  \\item It is assumed that there is only a single reader and a single writer but the reader and writer processes operate completely asynchronously\n  \\item A write puts a new value in the buffer\n  \\item A read gets a completely written value from the buffer\n  \\item The value read is at least as fresh as the last completely written value when the read started -- \n  this implies that, for two consecutive reads, the value read by the second read will be at least as fresh as\n  that read by the first\n  \\item Reads and writes must not block (no locks)\n  \\item Reads and writes of values can't be assumed to be atomic (i.e.\\ a single value may be larger than the atomic changes made by the hardware)\n  \\item The only thing Simpson assumes to be atomic is the setting of single bits (and they are actually realised by wires)\n  \\item The buffer is initialised with a data value (so there is always something to read)\n  \\item The buffer is shared by the reading and writing processes alone (i.e.\\ no third process can modify the buffer)\n  \\end{itemize}\n\n\n\n\n\n\n\n\n\n\n\nIn the terminology of Lamport \\cite{Lamport86II} this can be summarised as\nimplementing a single-reader wait-free atomic register in terms of atomic Boolean control registers.\n\n\\subsection{Approaches to specifying ACM}\\label{S-ACM-approaches}\n\nThere is an interesting range of approaches as to how the requirements that are listed above can be expressed in a formal specification.\nWithout surveying all of them,\nit fits the theme of this paper to review two strands of publications:\n\\footnote{Other approaches include~\\cite{HendersonPhD,Abrial10}.}\none motivated by (Concurrent) Separation Logic~\\cite{Reynolds02,OHearn07} and the other  by rely/guarantee methods.\nSurveying the latter also pinpoints the origin of the possible value notation.\n\nRichard Bornat is an expert on separation logic so it is interesting to look at how he has formalised the specification and development of Simpson's `four slot' algorithm.\nIn~\\cite{BornatAmjad10}, separation logic is certainly used but it is interesting to see that the paper also uses rely/guarantee concepts.\nIn contrast,~\\cite{BornatAmjad13} makes no real use of separation logic and \nthe specification uses the concept of linearisability~\\cite{HW90}.\nThe reason that this history is enlightening is that the essence of Simpson's algorithm is the exchange of `ownership' of the four slots between the reader and writer processes.\nThis is done precisely to ensure (data) race freedom so one would anticipate that separation logic would be in its element.\nThere is, in fact, one paper that uses separation logic for precisely this form of argument;\nunfortunately~\\cite{WangWang-10} does not include an argument that the reader always gets the `freshest' value and a recent private correspondence with one of the authors indicates that they have not extended their work to cover this essential property.\n\nIt is only fair to make an equally critical assessment of two papers~\\cite{JonesPierce08,JonesPierce10} that use rely/guarantee ideas.\n\nIn the development recorded in~\\cite{JonesPierce08},\n\\footnote{The variable names in the Jones/Pierce papers are\n$hold-r/fresh-w$;\nfor the reader's convenience,\nthese have been changed in the extracts in the current paper to match the names used here\n($cr/lw$).}\nit is necessary to assert that the value of one variable ($lw$)  \nis assigned to another variable ($cr$);\nthis assertion was recorded as:\n\n\\begin{formula}\ncr' = lw \\Or cr' = lw'\\ .\n\\end{formula}\n\n\\noindent\nThis plausible attempt says that the final value of $cr$ is either \nthe initial or final value of $lw$.\nUnfortunately, during the operation being specified,\nthe value of $lw$ could potentially be changed more than once.\nThis observation was precisely the stimulus that led to the invention of the notation \nfor possible values.\nIn addition to various improvements and clarifications in the development,\nthe journal version~\\cite{JonesPierce10} resolves the problem by using\n\n\\begin{formula}\ncr' \\in {\\wideparen{{lw}}}\\ .\n\\end{formula}\nRushby~\\cite{RushbySimpsons02} noted a similar issue in model checking Simpson's algorithm:\na version checking for just the before or after values fails in the case of multiple writes overlapping a single read.\nTo handle this in the model checking context, \nRushby restricts the sequence of data values written so that they are strictly increasing in value,\nand then checks that the sequence of values read is nondecreasing,\nwhich he concludes is necessary but may not be sufficient.\nHe concedes that this is a limitation of the expressiveness of the model checking specification language\n(which does not have the (unbounded) expressive power of the possible values notation).\n\nThere is however a deeper objection to both of the Jones/Pierce specifications of ACMs.\nIn both cases, the most abstract specification uses a variable ($data-w$) that contains the entire history \nof values written by the write process.\nThis is in spite of the fact that \na read operation cannot access values in the sequence earlier than the last value added before the read began.\nThis sort of redundancy is deprecated in~\\cite[Sect.~9.3]{Jones90a} as using a `biased' representation:\nthe state contains values that have no influence on subsequent operations.\nWhere there is no bias in the representation underlying a specification,\na homomorphism (retrieve function) relates a representation back to the abstraction;\nin the case of a biased representation, a relation between the abstraction and the representation\nis used to argue that the operations on the latter fit those on the former.\nIn situations where it is necessary to express non-determinism in a specification that can be removed in the design process, \nbiased specifications are sometimes unavoidable ---\nbut, where there is an alternative, unbiased specifications should normally be preferred because they make it easier to see the range of possible implementations.\nOne further surprising fact about the specifications in~\\cite{JonesPierce08,JonesPierce10} \nis that, even at the most abstract level, \nthe specifications of both $Read$ and $Write$ are each split into two sub-operations which are joined by sequential composition.\nAlthough the semantics of such a specification are clear,\nit means that the task of convincing users that their requirements have been adequately captured\ninvolves a rather algorithmic discussion.\n\nHaving been self-critical of these specifications, \nthere is one important positive point that needs preserving in the approach below:\nthe issue of data-race freedom is handled in~\\cite{JonesPierce10} at the level\nof an abstract intermediate representation.\nThis is an important general point: rely/guarantee conditions can be used to record interference on an abstraction where the final code is certainly not `racy'.\n\n\n\\subsection{Specification using possible values}\n\\label{S-4-spec}\n \nIn contrast to the above attempts, \na top-level specification using `possible values' notation appears to be much more natural and perspicuous.\nThe abstract specification uses a state with just a single value buffer $b$ of type $Value$.\nThe use of this intuitively simple state is only made possible by employing the possible value notation in the post condition of $Read$, \nwhere ${\\wideparen{{b}}}$ stands for the set of possible values of $b$ during the execution of $Read$.\n\nThe $Read$ operation is described as returning a value ($r$) \nso the post condition is simply $r' \\in {\\wideparen{{b}}}$.\nThis means that a single read operation can return \nthe value of the write most recently completed at the time the read begins \nor of any write that executes an assignment to $b$ during the execution of the read operation.\nNotice that there is no danger of a subsequent read operation obtaining an older value than the current  read because the reference point for the possible values of the newer read is the start of its execution.\n\nAs in~\\cite{JonesPierce10},\nthe specification can be made clearer by annotating whether the external state variables accessed \nby an operation can be only read ($\\kw{rd}$) \nor both read and written ($\\kw{wr}$).\n\nThus, the specification of $Read$ can be given simply as:\n    \n\\begin{formula}\n   Read()\\ r : Value \\\\\n   \\kw{ext rd } b: Value\\\\\n\n    {\\mathop{\\kw{post}}} r' \\in {\\wideparen{{b}}} \n\\end{formula}\n \n\\noindent\nWhen generating proof obligations,\nthe $\\kw{ext rd}$ is equivalent to a guarantee condition $b' = b$.\n\nThe specification of the $Write$ operation is interesting.\nIf the parameter to $Write$\n\nis $v$,\none would expect the post condition to be $b' = v$ ---\nand this is certainly required.\nIn addition,\nit is necessary to rule out the possibility that $Write(v)$ puts some spurious value(s) into $b$ that might be accessed by $Read$ before the $Write(v)$ corrects its wayward behaviour and achieves its post condition.\nThis can be expressed in a guarantee condition $b' \\neq b \\implies b' = v$.\nExtending \n(again, as in~\\cite{JonesPierce10})\nthe $\\kw{ext}$ annotation to mark write ownership yields a specification:\n\n\\begin{formula}\n   Write(v : Value) \\\\\n   \\kw{ext owns wr } b: Value\\\\\n    {\\mathop{\\kw{guar }}}  b' \\neq b \\implies b' = v \\\\\n    {\\mathop{\\kw{post}}} b' = v \n\\end{formula}\n  \n \\noindent\nHere,\nthe proof obligation expansion of $\\kw{ext owns wr}$ is\na rely condition $b' = b$,\nwhich matches the implicit guarantee of $Read$ courtesy of its $\\kw{ext rd}$ annotation.\n \nThe role of the guarantee of $Write$ here is to provide an intuitive specification;\nthe  more standard use is to show that processes can co-exist and\nthis usage occurs in the development below.\n\nThe guarantee of $Write$ ensures that only valid values are observable in the buffer (by $Read$).\nIt is an important part of the specification of $Write$\nbut note that there is no corresponding rely condition in $Read$.\nFirstly, there is the technical issue that $v$ is local to $Write$\nand hence cannot be referred to in (the rely of) $Read$.\nSecondly, several $Write$ operations might take place during a single $Read$ \nand hence there may be multiple changes to the buffer during a $Read$,\neven though each $Write$ only changes the buffer (at most) once.\nIn fact, the possible multiple changes of the buffer during a $Read$\nmotivates the use of ${\\wideparen{{b}}}$ in its post condition.\nIt is worth observing that ${\\wideparen{{b}}}$ is applied to an abstract variable $b$ ---\nthe development that follows employs a representation of $b$ that is by no means obvious.\n\nThe guarantee of $Write$ requires that the observable effect of the operation\ntakes place in a single atomic step\nand the use of the possible values notation in the post condition of $Read$ \nensures that the observable effect of $Read$ also takes place in a single atomic step.\n\n\n\n\n\n\n\nThe initial value of $b$ \n\nis assumed to contain a valid $Value$ so that it is possible \nfor a $Read$ operation to precede the first $Write$.\n\nThus far, the possible values concept \n--that was devised in order to document an intermediate design-- \nhas here been shown to offer a short and clear overall specification of ACM behaviour.\nFreshness comes from the possible values notation and the effect of it being relative to the start of each $Read$ operation.\nThe implementation has to find a way of achieving the atomic change behaviour of $b$ in the abstraction without such an atomicity assumption.\n\n\n \n\\subsection{Understanding Simpson's representation}\n\\label{S-reif1}\n\nThe challenge of presenting a specification that makes sense to potential users\nis addressed in Section~\\ref{S-4-spec}.\nA development using a single data reification step to a version of Simpson's code is presented in\nSection~\\ref{S-1step} ---\nthat development makes interesting further use of the possible values concept and is thus presented in some detail.\nThe current section attempts to provide an intuition of the `four-slot' data structure.\nThe operations corresponding to $Write$ and $Read$ of Section~\\ref{S-4-spec} are here named\n$Write\\sb{i}$ and $Read\\sb{i}$.\n\nThe importance of data abstraction and reification are commented on in Section~\\ref{S-data-reification}.\nRather than jump immediately to Simpson's decision to use exactly four slots to represent the abstract variable $b$, a useful intermediate refinement step uses a data structure that contains\nan abstract map of an indexed set of `slots'  $\\mapof{X}{Value}$.\nHere, this part of the state is named $dw$.\nThere is also a data type invariant that requires that the\n(potentially partial) map has a value in every slot:\n$\\dom{dw} = X$.\n\\footnote{Note that, in the concurrent context, the data type invariant must hold for every step,\nnot just initially and at the end of each operation.}\n\nAs in~\\cite{JonesPierce10},\nthe index set $X$ is deliberately left unspecified at this stage.\n$Write\\sb{i}$ is decomposed into a three parts:\n\n\\begin{itemize}\n\n\\item $Write-ch\\sb{i}$ chooses an index ($\\in X$) that is safe to use\n\n\\item $Write-upd\\sb{i}(v)$ updates the map $dw$ at the chosen index to $v$\n\n\\item $Write-com\\sb{i}$ commits the index by exposing it to $Read\\sb{i}$\n\n\\end{itemize}\n\n\\noindent\n$Read\\sb{i}$ is split into two parts:\n\n\\begin{itemize}\n\n\\item $Read-sel\\sb{i}$ selects the most recently written index and stores that index in a local variable\n\n\\item $r \\gets Read-acc\\sb{i}$ accesses the indexed slot\n\n\\end{itemize}\n\n$Write\\sb{i}$ must inform $Read\\sb{i}$ of the index of the slot which has been (most recently) written.\nIn addition, $Read\\sb{i}$ must have a way of alerting $Write\\sb{i}$ to the index of the slot that is claimed for reading.\nRemember that the reader and writer processes are in no way synchronised and the implementation is designed to allow (multiple) reads to occur during a write or multiple writes to overlap with a single read.\n\nIt should be clear that the potential number of slots \n(the cardinality of the set $X$)\nmust be at least three because the writer has to select a member of $X$ that is neither the most recently written nor one which the reader might access \n(these could be the same but are not necessarily so).\nIt is possible to build a `three slot' implementation\n{\\em providing} there is an atomic way of communicating index values between $Read$ and $Write$.\n\n\n\nIt is tempting to make $Read\\sb{i}$ reserve a single element of $X$ to $Write\\sb{i}$ but this does not actually provide an abstraction of Simpson's code.\nWhat that code effectively does is to reserve more than one slot.\nThis is shown here as $pr$ being a set of indexes.\n\n\n\nThe intermediate state is thus:\n\n\\begin{record}{\\Sigma\\sb{i}}\n dw: \\mapof{X}{Value}  \\mbox{\\hspace{1em} -- space for values}\\\\\n lw: X \\mbox{\\hspace{4em} -- index of the last committed write} \\\\\n cw: X   \\mbox{\\hspace{4em} -- index claimed by the writer}\\\\% before it releases its chosen $X$ } \\\\\n cr: X \\mbox{\\hspace{4em} -- index claimed by the reader}\\\\\n pr: \\setof{X} \\mbox{\\hspace{2.5em} -- potential elements of $X$ that the reader might use} \n \\end{record}\n \n\n\nIt is an interesting observation that none of the variables can be modified by both operations.\nThe final letter of each variable name records which process,\n\\underline{r}eader or \\underline{w}riter, can write to that variable\n(e.g.~$lw$ can only be modified by $Write\\sb{i}$).\n\nIt is not difficult to see the lines of the data reification required here:\nthe retrieve function is $b = dw(lw)$.\n\n\n\n\n\n\nThe initial state must, of course, satisfy the invariant;\nthe initial value in the buffer must be\n$dw(lw)$ and there must be some arbitrary value in every slot\nto ensure that $\\dom{dw} = X$.\n\nIt is interesting to note that the issue of (data) race freedom on the slots is worked out \nat this level of abstraction\nwith rely/guarantee conditions.\nThis can be contrasted with Peter O'Hearn's view in~\\cite{OHearn07} \nthat separation logic is the tool of choice for reasoning about race freedom and rely/guarantee reasoning is for `racy' programs.\nThe decisive point appears to be that, here, race freedom is established on a data structure that is more abstract than the final representation.\n\n\n\nAlthough the observation is made above\nthat three slots would be adequate to avoid clashing,\n\\footnote{In fact,~\\cite{BornatAmjad13} also considers a three slot implementation.}\nthe genius of the representation proposed by Hugo Simpson is that \n--if four slots are used--\ncommunication can be reduced to using single bits;\nfurthermore, \nin a physical implementation, \nthese bits can be realised as wires connecting the $Read\\sb{f}$ and $Write\\sb{f}$ processes\nrunning on separate processors.\n\nSimpson describes the algorithm in terms of choosing `pairs' and `slots'.\nAs in~\\cite{JonesPierce10},\nthis intuition is followed by using two sets $P$ and $S$ each of which has two possible values.\nHowever, here,\ntoggling between the two values is achieved by a ``$\\Not$'' operator.\nAlthough both sets $P$ and $S$ can be implemented as Booleans,\nthe temptation to use Booleans is resisted at this stage\nbecause separating the types $P$ and $S$ provides useful information\nas to whether each index variable refers to a pair or a slot\n(and has the potential to flag incorrect use as a type error).\n\n\n\nThe final representation ($\\Sigma\\sb{f}$) is given in Figure~\\ref{F-Sigma-f}.\n\nThis is related to $\\Sigma\\sb{i}$ by a retrieve function where: \n\n\\begin{itemize}\n\n\\item $dw$ is directly modelled by $dsw$ with the set $X$ reified to a $(P, S)$ pair\n\n\\item $cw$ is represented by $(cpw, \\lnot sw(cpw))$\n\n\\item $cr$ is represented by $(cpr, csr)$\n\n\\item $lw$ is represented by $(lpw, sw(lpw))$\n\n\\item $pr$ is represented by $\\set{(cpr, sl) | sl \\in S}$\n\n\\end{itemize}\n\n\\begin{figure}\n\\begin{record}{\\Sigma\\sb{f}}\n dsw: \\mapof{P \\x S}{Value}  \\mbox{\\hspace{1em} -- two pairs of two data slots each} \\\\\n sw: \\mapof{P}{S}  \\mbox{\\hspace{3em} -- $sw(p)$ is the last written slot for pair $p$} \\\\\n lpw: P   \\mbox{\\hspace{6em} -- last written pair} \\\\\n cpw: P   \\mbox{\\hspace{6em} -- current write pair} \\\\\n cpr: P   \\mbox{\\hspace{6em} -- current read pair} \\\\\n csr: S   \\mbox{\\hspace{6em} -- current read slot} \n\\end{record}\n\\caption{The final state $\\Sigma\\sb{f}$}\n\\label{F-Sigma-f}\n\\end{figure}\n\n\n\\subsection{One step argument} \n\\label{S-1step}\n\nThis section presents a single-step data refinement from \nthe top level specification using possible values to Simpson's algorithm.\nAlthough the approach to refining the code from the specification is new,\nthe end code comes from Simpson's insights and motivates the approach.\nThe final state representation is as in Figure~\\ref{F-Sigma-f}\nand the relationship between the abstract buffer $b$ and this representation state is\n\\begin{eqnarray*}\n  b = dsw(lpw,sw(lpw))\\ .\n\\end{eqnarray*}\n\\begin{figure}\n\\begin{minipage}{0.43\\textwidth}\n\\begin{formula}\nRead\\sb{f}()r: Value\\T1\n  \\begin{array}{l}\n        {\\mathop{\\kw{var}}} t \\in P ; \\\\\n        {\\langle { t \\gets lpw} \\rangle} ; \\\\\n        {\\langle { cpr \\gets t} \\rangle} ; \\\\\n        {\\langle { csr \\gets sw(cpr) } \\rangle}; \\\\\n         r \\gets dsw(cpr, csr)\n  \\end{array}\n\\end{formula}\n\\end{minipage}\n\\begin{minipage}{0.55\\textwidth}\n\\begin{formula}\nWrite\\sb{f}(v: Value)\\T1\n  \\begin{array}{l}\n           {\\langle { cpw \\gets \\Not cpr } \\rangle} ; \\\\\n           dsw(cpw, \\Not sw(cpw)) \\gets v ; \\\\\n           {\\langle { sw(cpw) \\gets \\Not sw(cpw) } \\rangle} ; \\\\\n           {\\langle { lpw \\gets cpw } \\rangle}\n  \\end{array}\n\\end{formula} \n\\end{minipage}\n\\caption{Code for Simpson's algorithm}\\label{f:Simpsons}\n\\end{figure}\n\nThe code for Simpson's algorithm is given in Figure~\\ref{f:Simpsons}.\nFirst note that the $Write\\sb{f}$ operation has the following guarantee:\n\\footnote{Although \n\nACMs are much more complicated than the one-place buffer,\nthe idea mentioned in Section~\\ref{S-RG} of locating where a key value is unchanged without\nadding auxiliary variables is evident here.}\n\\begin{eqnarray}\n\n\n  & \\forall{i,j}{(i,j) \\neq (cpw,\\Not sw(cpw)) \\implies dsw'(i,j) = dsw(i,j)} \n    \\label{Write-guar-others-stable} \n\n\n\n\\end{eqnarray}\nand that when the write operation is not active, \nthe writing process does not modify any of the variables in the representation.\n\nThe specification of the $Read\\sb{f}$ operation after mapping through the representation relation \nand extending the frame with an appropriate subset of the representation variables is\n\\begin{eqnarray}\\label{dr-read-spec}\n  \\Spec{t,cpr,csr,r}{}{ r' \\in {\\wideparen{{dsw(lpw,sw(lpw))}}} }\n\\end{eqnarray}\nThe first refinement step uses law~(\\ref{law-posvals-pre-assignment}) from Section~\\ref{S-sem}\nwith $lpw$ corresponding to $x$ and $dsw(v,sw(v))$ corresponding to $e$.\nIn fact the law needs to be extended to accommodate extra variables in the frame but that is straightforward.\n\\begin{eqnarray}\n  (\\ref{dr-read-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { t \\gets lpw } \\rangle} ; \\\\\n  && \\Spec{cpr,csr,r}{}{ r' \\in {\\wideparen{{dsw(t,sw(t))}}} } \\label{second-spec}\n\\end{eqnarray}\nFor this one needs to rely on \n\\begin{eqnarray}\\label{rely-1}\nlpw' \\neq t \\implies dsw'(t,sw'(t)) = dsw(t,sw(t))\\ .\n\\end{eqnarray}\nNote that $sw(t)$ is only changed by $Write\\sb{f}$ if $t = cwp$ but the code also\nguarantees that $t = cpw \\implies t = lpw$ and hence $sw(t)$ can be changed only\nif $lpw' = t$ and hence (\\ref{rely-1}) holds.\nIf $sw(t)$ does not change, (\\ref{rely-1}) is guaranteed by $Write\\sb{f}$ \nby (\\ref{Write-guar-others-stable}) because\n$(t,sw(t)) \\neq (cpw,\\Not sw(cpw))$ because\neither $t \\neq cpw$ or if $t = cpw$ then $sw(t) = sw(cpw) \\neq \\Not sw(cpw)$.\nThis use of the slots vector $sw$ in Simpson's algorithm is one of the smart parts of how it works.\n\nThe second refinement step uses law~(\\ref{law-posvals-pre-assignment}) once more to refine (\\ref{second-spec}).\n\\begin{eqnarray}\n  (\\ref{second-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { cpr \\gets t } \\rangle} ; \\\\\n  && \\Spec{csr,r}{}{ r' \\in {\\wideparen{{dsw(cpr,sw(cpr))}}} } \\label{third-spec}\n\\end{eqnarray}\nprovided one can rely on $t' \\neq cpr \\implies dsw'(cpr,sw'(cpr)) = dsw(cpr,sw(cpr))$\nwhich holds trivially as $t = cpr$ is invariant over (\\ref{third-spec}).\n\nThe third refinement step again uses law~(\\ref{law-posvals-pre-assignment}) to refine (\\ref{third-spec}).\n\\begin{eqnarray}\n  (\\ref{third-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { csr \\gets sw(cpr) } \\rangle} ; \\label{assign-csr} \\\\\n  && \\Spec{r}{}{ r' \\in {\\wideparen{{dsw(cpr,csr))}}} } \\label{fourth-spec}\n\\end{eqnarray}\nprovided one can rely on \n\\begin{eqnarray}\\label{third-rely}\n  sw'(cpr) \\neq csr \\implies dsw'(cpr,csr) = dsw(cpr,csr)\n\\end{eqnarray}\nbeing maintained by $Write\\sb{f}$ for the duration of (\\ref{fourth-spec}).\nHere (\\ref{third-rely}) can be strengthened to\n\\begin{eqnarray}\\label{third-rely-rev}\n  dsw'(cpr,csr) = dsw(cpr,csr)\n\\end{eqnarray}\nand this can be shown to be maintained by $Write\\sb{f}$ using the approach outlined\nin Section~\\ref{S-strengthening-law}.\nFor the duration of (\\ref{fourth-spec}), $Read\\sb{f}$ strengthens its guarantee to state\nthat it does not modify any shared variables ($r$ is local to $Read\\sb{f}$).\nBecause (\\ref{assign-csr}) establishes \n\\begin{eqnarray}\\label{read-phase-init}\n (cpr,csr) & \\neq & (cpw,\\lnot sw(cpw))\n\\end{eqnarray}\nit is sufficient to show that $Write\\sb{f}$ maintains (\\ref{third-rely-rev}) from\ninitial states satisfying (\\ref{read-phase-init}) provided there is no interference\non its shared variables.\nIf $Write\\sb{f}$ is executing its write phase from any state satisfying (\\ref{read-phase-init}),\nit guarantees (\\ref{third-rely-rev}) because the slot being written is not $(cpr,csr)$.\nOnce $Write\\sb{f}$ finishes its write phase (or if it is not initially in its write phase)\nit does not modify $dsw$ at all\n(and hence maintains (\\ref{third-rely-rev})) \nuntil after it executes $cpw \\gets \\lnot cpr$ \nwhich re-establishes (\\ref{read-phase-init}) for the next write phase.\n\nThe final refinement step uses law~(\\ref{law-single-reference-posvals}) to refine (\\ref{fourth-spec}).\n\\begin{eqnarray*}\n  (\\ref{fourth-spec}) & {\\mathrel{\\sqsubseteq}} & r \\gets dsw(cpr,csr)\n\\end{eqnarray*}\nThis is valid provided $dsw(cpr,csr)$ is stable,\nwhich follows from the argument given above for the previous refinement step.\n\nA pleasing aspect of the above refinement is that, having started from a specification\n(\\ref{dr-read-spec}) using the possible values concept\n(which allows for non-determinism in the value read),\nthe refinement steps have maintained the use of possible values \n(and hence the non-determinism) \nuntil the last step, when it is clear which slot is being read \n(and that the slot is stable).\n\nUsing the approach of locally strengthening a guarantee \n--and hence indirectly strengthening a rely-- \n(see Section~\\ref{S-strengthening-law})\nobviates the need to introduce and reason about auxiliary variables.\nHowever, a development using auxiliary Boolean variables $reading$ and $writing$ is also possible,\nwhere $reading$ is true if and only if the $Read$ process is actually reading from $dsw$\nand $writing$ is true if and only if the $Write$ process is actually writing $dsw$.\nWith these auxiliary variables the important invariant is,\n\\begin{eqnarray*}\n  reading \\land writing & \\implies &(cpr,csr) \\neq (cpw,\\lnot sw(cpw))\n\\end{eqnarray*}\nwhich ensures that the $Read$ and $Write$ processes are not simultaneously\nusing the same slot.\nThis represents the weakest invariant to ensure correct operation of the algorithm. \n\nBecause the specification of $Write\\sb{f}$ does not make use of possible values notation \nits refinement is not presented in detail here.\nAn important property of $Write\\sb{f}$ is that during its writing phase the slot being written \ndiffers from any slot that could be read concurrently,\nwhich has been covered in the refinement of $Read\\sb{f}$.\nThe other aspect of $Write\\sb{f}$ worth noting is that its guarantee in the abstract\nspecification requires the buffer $b$ to be updated to $v$ atomically.\nRecalling that $b$ is represented by $dsw(lpw,sw(lpw))$, \nthat guarantee is achieved by (non-atomically) assigning to slot $(cpw,\\lnot sw(cpw))$, \nwhich can never correspond to $b$.\nThe switch of $(lpw,sw(lpw))$ to $(cpw,\\lnot sw(cpw))$ is then achieved \neither by the assignment $sw(cpw) \\gets \\lnot sw(cpw)$ if $lpw$ already equals $cpw$,\nor by the following assignment $lpw \\gets cpw$ if they differed initially.\n\nFinally note that all of the atomic assignments in Figure\\ \\ref{f:Simpsons} are now\nin a form in which they can be implemented by the corresponding non-atomic assignment,\nassuming each read and write of a shared variable other than $dsw$ is atomic. \nThis assumption is in line with the requirements because the shared flags can be implemented as single bits (or, indeed, realised as wires).\n\n\n\n\n\\section{Conclusions and further work} \n\\label{S-conc}\n\n\n\n\nThe concept of possible values arose in an attempt to provide a clear design rationale of \ncode which is delicate in the sense that slight changes destroy its correctness.\nA seemingly simple and intuitive notational idea contributed to the description of a layered development.\nThe proposal was clearly motivated by a need in a practical application.\n\nThe next bonus came in the link to the non-deterministic state ideas:\nthis connection is set out in~\\cite{HayesBurnsDongolJones12}.\n\nThe current paper contains the first publication of the specification given in Section~\\ref{S-4-spec}\nand the simplicity of the overall specification comes as strong encouragement\nfor the concept and notation of possible values.\nThis is further reinforced by the development of Simpson's algorithm in Section~\\ref{S-1step}\nwhich retains the use of the possible values notation and \nutilises laws taking advantage of the possible values notation.\n\n\n\n\nThis closing section points to further avenues that appear to have potential but\ncertainly require more work.\nAs with the steps to date,\nthe motivation for the decisions should come from practical examples.\n\n\n\\subsection{Further applications} \n\n\n\n\n\n\n\n\nIt can perhaps be mentioned that the possible values notation appears to have some potential \nfor recording arguments about brain-teaser puzzles.\nAt the March 2015 meeting of IFIP WG~2.3 in Istanbul, \nMichael Jackson posed a hide-and-seek puzzle which is apparently described in several contexts.\nHere, a mole is what must be located.\nThere are five holes in a line;\nthe mole moves each night to an adjacent hole;\nthe seeker can only check one hole per night and must devise a strategy that eventually locates the mole whose non-deterministic nocturnal movements are only constrained at either end of the line of holes.\nThis paper doesn't spoil the reader's fun by providing an answer;\nit only mentions that one of the authors recorded the argument for termination using \nthe possible values notation.\n\nSadly, most of the examples (see~\\cite{SewellEt-11,vafeiadis-11,ridge-10})\nusing `weak memory' \n(a.k.a. `relaxed memory')\nalso give the feeling that they are gratuitous puzzles.\nAt a recent Schloss Dagstuhl meeting (15191),\none of the authors tried to use the possible values notation to record the \nnon-determinism that results from not knowing when the various caches are flushed.\nIt must be conceded that, \non the pure puzzle examples, \npossible values are doing little more than providing an alternative notation for\ndisjunctions.\nA challenge is to find a genuinely useful piece of code that,\ndespite non-determinism,\nsatisfies a coherent overall specification under, say, \ntotal store order (TSO)\nor\npartial store order (PSO) memory models.\nOnly on such an application should the judgement about the usefulness of \npossible values be based.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are also alternative views of the possible values notation itself.\nFor example, ${\\wideparen{{b}}}$ could yield a sequence of values rather than a set.\nThere is however an argument for preserving a (direct) way of denoting the set of possible values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Possible evaluations of expressions} \n\\label{S-epe}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs well as possible values of an expression ${\\wideparen{{e}}}$\nthat is the set of values of $e$ evaluated in each state of the execution,\none can define ${\\wideparen{\\wideparen{{e}}}}$ as the set of all possible evaluations of $e$ over the execution interval:\neach instance of a variable $x$ in $e$ takes on one of the values of $x$ in the interval\nso that different occurrences of $x$ within $e$ may take on different values, and\nthe values of separate variables $x$ and $y$ may be taken from different states.\nThe set of evaluations includes those in which the values of all the variables are taken\nin a single state and hence ${\\wideparen{{e}}} \\subseteq {\\wideparen{\\wideparen{{e}}}}$.\nIn~\\cite{HayesBurnsDongolJones12} the possible values concept was linked to \ndifferent forms of nondeterministic expression evaluation \ncorresponding to ${\\wideparen{{e}}}$ and ${\\wideparen{\\wideparen{{e}}}}$.\n\nThe following simple rule requires no restriction on $e$ \nother than it does not contain references to $x$ because $x$ is in the frame of the specification.\n", "itemtype": "equation", "pos": 26614, "prevtext": "\nis maintained by the environment,\nwhere $e[t/v]'$ stands for $e[t/v]$ evaluated in the after state,\ni.e.\\ $e'$ is $e$ with every program variable $y$ in $e$ replaced by $y'$.\n\nLaw (\\ref{law-posvals-pre-assignment}) can be justified as follows.\nThe atomic statement ${\\langle {t \\gets x} \\rangle}$ establishes $e[t/v] = e[x/v]$.\nAn environment step that has a final state in which $x' = t$ establishes \n$e[t/v]' = e[x/v]'$\notherwise the environment establishes\n$e[t/v]' = e[t/v] = e[x/v]$.\n\n\nAs an example consider the case in which the expression $e$ is $d(v)$.\nApplying (\\ref{law-posvals-pre-assignment}) gives\n\\begin{eqnarray}\n  \\Spec{t,r}{}{ r' \\in {\\wideparen{{d(x)}}} } \n  \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \n  {\\langle {t \\gets x} \\rangle} \\ ;\\  \\Spec{r}{}{ r' \\in {\\wideparen{{d(t)}}} }\n\\end{eqnarray}\nprovided its environment ensures the condition: $x' \\neq t \\implies d'(t) = d(t)$.\nImmediately after the atomic assignment to $t$, \n\n", "index": 5, "text": "\\begin{equation}\\label{posvals-d(t)}\n  d(t) = d(x) \\in {\\wideparen{{d(x)}}}\\ .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"d(t)=d(x)\\in{\\wideparen{{d(x)}}}\\ .\" display=\"block\"><mrow><mrow><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2208</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mo>\u2062</mo><mi>d</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo rspace=\"7.5pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02132.tex", "nexttext": "\n\nIf $e$ satisfies the single reference property over the execution interval \n(as defined earlier)\nthen ${\\wideparen{\\wideparen{{e}}}} = {\\wideparen{{e}}}$ and hence\n", "itemtype": "equation", "pos": 60163, "prevtext": "\nIf the environment makes a step that does not change $x$, \n(\\ref{posvals-d(t)}) is maintained because $d'(t') = d'(x')$\nbut if the environment changes $x$ so that it no longer equals $t$\none can no longer rely on $d'(t')$ being the same as $d'(x')$.\nHowever, if one can rely on $d(t)$ being stable\nand because $d(t) = d(x)$ and $d'(t') = d(t)$,\none can still deduce $d'(t') = d(x)$.\n\n\n\n\n\n\\section{Asynchronous Communication Mechanisms} \n\\label{S-4slot}\n\nAn Asynchronous Communication Mechanism (ACM)\nlogically provides a one-place buffer between a single writer and a single reader\n(see Figure~\\ref{F-loops}).\nThis sounds trivial but the snag is in the adjective:\nACMs are asynchronous in the sense that neither the reader nor the writer \nshould ever be held up by locks.\n\\footnote{\\label{FN-cf}This contrasts with the simple one-place buffer in Section~\\ref{S-intro}\nwhere the code would `busy wait' on the value of a flag to control alternation between the producer and consumer.}\nUnless the value being communicated via the buffer is small enough to be read and written atomically,\nit should be obvious that one slot is not enough to realise the buffer; \na little thought shows that a buffer representation with two slots is also inadequate;\nthe topic of how many slots are required is returned to in Section~\\ref{S-reif1}.\nIn~\\cite{Simpson90}, \nHugo Simpson proposed a `four-slot' algorithm \nto implement an ACM for which,\nwhile the code is short,\nextremely subtle reasoning is required for its justification.\n\n\\begin{figure}\n\\begin{center}\n\\begin{eqnarray*}\n \\left.\n  \\begin{array}{l}\n   \\kw{while } \\mathsf{true} \\kw{ do}\\\\\n    \\ \\ \\begin{array}{l}\n     \\cdots \\mbox{produce $v$} \\cdots\\\\\n     Write(v)\n    \\end{array}\\\\\n   \\kw{od}\n  \\end{array}\n \\ \\ \\right|\\left|\\ \\ \n \\begin{array}{l}\n  \\kw{while } \\mathsf{true} \\kw{ do}\\\\\n   \\ \\ \\begin{array}{l}\n    r \\; \\gets \\; Read()\\\\\n    \\cdots \\mbox{consume $r$} \\cdots\n   \\end{array}\\\\\n   \\kw{od}\n  \\end{array} \n  \\right.\n\\end{eqnarray*}\n\\end{center}\n\n\\caption{Code to clarify reader/writer structure}\n\\label{F-loops}\n\\end{figure}\n\n\n\\subsection{ACM requirements}\\label{S-ACM-requirements}\n\nThe requirement is to \ncommunicate the ``most recent'' value from a single producer to a single consumer via a shared buffer.\nMore precisely, it must satisfy the following.\n  \\begin{itemize}\n  \\item It is assumed that there is only a single reader and a single writer but the reader and writer processes operate completely asynchronously\n  \\item A write puts a new value in the buffer\n  \\item A read gets a completely written value from the buffer\n  \\item The value read is at least as fresh as the last completely written value when the read started -- \n  this implies that, for two consecutive reads, the value read by the second read will be at least as fresh as\n  that read by the first\n  \\item Reads and writes must not block (no locks)\n  \\item Reads and writes of values can't be assumed to be atomic (i.e.\\ a single value may be larger than the atomic changes made by the hardware)\n  \\item The only thing Simpson assumes to be atomic is the setting of single bits (and they are actually realised by wires)\n  \\item The buffer is initialised with a data value (so there is always something to read)\n  \\item The buffer is shared by the reading and writing processes alone (i.e.\\ no third process can modify the buffer)\n  \\end{itemize}\n\n\n\n\n\n\n\n\n\n\n\nIn the terminology of Lamport \\cite{Lamport86II} this can be summarised as\nimplementing a single-reader wait-free atomic register in terms of atomic Boolean control registers.\n\n\\subsection{Approaches to specifying ACM}\\label{S-ACM-approaches}\n\nThere is an interesting range of approaches as to how the requirements that are listed above can be expressed in a formal specification.\nWithout surveying all of them,\nit fits the theme of this paper to review two strands of publications:\n\\footnote{Other approaches include~\\cite{HendersonPhD,Abrial10}.}\none motivated by (Concurrent) Separation Logic~\\cite{Reynolds02,OHearn07} and the other  by rely/guarantee methods.\nSurveying the latter also pinpoints the origin of the possible value notation.\n\nRichard Bornat is an expert on separation logic so it is interesting to look at how he has formalised the specification and development of Simpson's `four slot' algorithm.\nIn~\\cite{BornatAmjad10}, separation logic is certainly used but it is interesting to see that the paper also uses rely/guarantee concepts.\nIn contrast,~\\cite{BornatAmjad13} makes no real use of separation logic and \nthe specification uses the concept of linearisability~\\cite{HW90}.\nThe reason that this history is enlightening is that the essence of Simpson's algorithm is the exchange of `ownership' of the four slots between the reader and writer processes.\nThis is done precisely to ensure (data) race freedom so one would anticipate that separation logic would be in its element.\nThere is, in fact, one paper that uses separation logic for precisely this form of argument;\nunfortunately~\\cite{WangWang-10} does not include an argument that the reader always gets the `freshest' value and a recent private correspondence with one of the authors indicates that they have not extended their work to cover this essential property.\n\nIt is only fair to make an equally critical assessment of two papers~\\cite{JonesPierce08,JonesPierce10} that use rely/guarantee ideas.\n\nIn the development recorded in~\\cite{JonesPierce08},\n\\footnote{The variable names in the Jones/Pierce papers are\n$hold-r/fresh-w$;\nfor the reader's convenience,\nthese have been changed in the extracts in the current paper to match the names used here\n($cr/lw$).}\nit is necessary to assert that the value of one variable ($lw$)  \nis assigned to another variable ($cr$);\nthis assertion was recorded as:\n\n\\begin{formula}\ncr' = lw \\Or cr' = lw'\\ .\n\\end{formula}\n\n\\noindent\nThis plausible attempt says that the final value of $cr$ is either \nthe initial or final value of $lw$.\nUnfortunately, during the operation being specified,\nthe value of $lw$ could potentially be changed more than once.\nThis observation was precisely the stimulus that led to the invention of the notation \nfor possible values.\nIn addition to various improvements and clarifications in the development,\nthe journal version~\\cite{JonesPierce10} resolves the problem by using\n\n\\begin{formula}\ncr' \\in {\\wideparen{{lw}}}\\ .\n\\end{formula}\nRushby~\\cite{RushbySimpsons02} noted a similar issue in model checking Simpson's algorithm:\na version checking for just the before or after values fails in the case of multiple writes overlapping a single read.\nTo handle this in the model checking context, \nRushby restricts the sequence of data values written so that they are strictly increasing in value,\nand then checks that the sequence of values read is nondecreasing,\nwhich he concludes is necessary but may not be sufficient.\nHe concedes that this is a limitation of the expressiveness of the model checking specification language\n(which does not have the (unbounded) expressive power of the possible values notation).\n\nThere is however a deeper objection to both of the Jones/Pierce specifications of ACMs.\nIn both cases, the most abstract specification uses a variable ($data-w$) that contains the entire history \nof values written by the write process.\nThis is in spite of the fact that \na read operation cannot access values in the sequence earlier than the last value added before the read began.\nThis sort of redundancy is deprecated in~\\cite[Sect.~9.3]{Jones90a} as using a `biased' representation:\nthe state contains values that have no influence on subsequent operations.\nWhere there is no bias in the representation underlying a specification,\na homomorphism (retrieve function) relates a representation back to the abstraction;\nin the case of a biased representation, a relation between the abstraction and the representation\nis used to argue that the operations on the latter fit those on the former.\nIn situations where it is necessary to express non-determinism in a specification that can be removed in the design process, \nbiased specifications are sometimes unavoidable ---\nbut, where there is an alternative, unbiased specifications should normally be preferred because they make it easier to see the range of possible implementations.\nOne further surprising fact about the specifications in~\\cite{JonesPierce08,JonesPierce10} \nis that, even at the most abstract level, \nthe specifications of both $Read$ and $Write$ are each split into two sub-operations which are joined by sequential composition.\nAlthough the semantics of such a specification are clear,\nit means that the task of convincing users that their requirements have been adequately captured\ninvolves a rather algorithmic discussion.\n\nHaving been self-critical of these specifications, \nthere is one important positive point that needs preserving in the approach below:\nthe issue of data-race freedom is handled in~\\cite{JonesPierce10} at the level\nof an abstract intermediate representation.\nThis is an important general point: rely/guarantee conditions can be used to record interference on an abstraction where the final code is certainly not `racy'.\n\n\n\\subsection{Specification using possible values}\n\\label{S-4-spec}\n \nIn contrast to the above attempts, \na top-level specification using `possible values' notation appears to be much more natural and perspicuous.\nThe abstract specification uses a state with just a single value buffer $b$ of type $Value$.\nThe use of this intuitively simple state is only made possible by employing the possible value notation in the post condition of $Read$, \nwhere ${\\wideparen{{b}}}$ stands for the set of possible values of $b$ during the execution of $Read$.\n\nThe $Read$ operation is described as returning a value ($r$) \nso the post condition is simply $r' \\in {\\wideparen{{b}}}$.\nThis means that a single read operation can return \nthe value of the write most recently completed at the time the read begins \nor of any write that executes an assignment to $b$ during the execution of the read operation.\nNotice that there is no danger of a subsequent read operation obtaining an older value than the current  read because the reference point for the possible values of the newer read is the start of its execution.\n\nAs in~\\cite{JonesPierce10},\nthe specification can be made clearer by annotating whether the external state variables accessed \nby an operation can be only read ($\\kw{rd}$) \nor both read and written ($\\kw{wr}$).\n\nThus, the specification of $Read$ can be given simply as:\n    \n\\begin{formula}\n   Read()\\ r : Value \\\\\n   \\kw{ext rd } b: Value\\\\\n\n    {\\mathop{\\kw{post}}} r' \\in {\\wideparen{{b}}} \n\\end{formula}\n \n\\noindent\nWhen generating proof obligations,\nthe $\\kw{ext rd}$ is equivalent to a guarantee condition $b' = b$.\n\nThe specification of the $Write$ operation is interesting.\nIf the parameter to $Write$\n\nis $v$,\none would expect the post condition to be $b' = v$ ---\nand this is certainly required.\nIn addition,\nit is necessary to rule out the possibility that $Write(v)$ puts some spurious value(s) into $b$ that might be accessed by $Read$ before the $Write(v)$ corrects its wayward behaviour and achieves its post condition.\nThis can be expressed in a guarantee condition $b' \\neq b \\implies b' = v$.\nExtending \n(again, as in~\\cite{JonesPierce10})\nthe $\\kw{ext}$ annotation to mark write ownership yields a specification:\n\n\\begin{formula}\n   Write(v : Value) \\\\\n   \\kw{ext owns wr } b: Value\\\\\n    {\\mathop{\\kw{guar }}}  b' \\neq b \\implies b' = v \\\\\n    {\\mathop{\\kw{post}}} b' = v \n\\end{formula}\n  \n \\noindent\nHere,\nthe proof obligation expansion of $\\kw{ext owns wr}$ is\na rely condition $b' = b$,\nwhich matches the implicit guarantee of $Read$ courtesy of its $\\kw{ext rd}$ annotation.\n \nThe role of the guarantee of $Write$ here is to provide an intuitive specification;\nthe  more standard use is to show that processes can co-exist and\nthis usage occurs in the development below.\n\nThe guarantee of $Write$ ensures that only valid values are observable in the buffer (by $Read$).\nIt is an important part of the specification of $Write$\nbut note that there is no corresponding rely condition in $Read$.\nFirstly, there is the technical issue that $v$ is local to $Write$\nand hence cannot be referred to in (the rely of) $Read$.\nSecondly, several $Write$ operations might take place during a single $Read$ \nand hence there may be multiple changes to the buffer during a $Read$,\neven though each $Write$ only changes the buffer (at most) once.\nIn fact, the possible multiple changes of the buffer during a $Read$\nmotivates the use of ${\\wideparen{{b}}}$ in its post condition.\nIt is worth observing that ${\\wideparen{{b}}}$ is applied to an abstract variable $b$ ---\nthe development that follows employs a representation of $b$ that is by no means obvious.\n\nThe guarantee of $Write$ requires that the observable effect of the operation\ntakes place in a single atomic step\nand the use of the possible values notation in the post condition of $Read$ \nensures that the observable effect of $Read$ also takes place in a single atomic step.\n\n\n\n\n\n\n\nThe initial value of $b$ \n\nis assumed to contain a valid $Value$ so that it is possible \nfor a $Read$ operation to precede the first $Write$.\n\nThus far, the possible values concept \n--that was devised in order to document an intermediate design-- \nhas here been shown to offer a short and clear overall specification of ACM behaviour.\nFreshness comes from the possible values notation and the effect of it being relative to the start of each $Read$ operation.\nThe implementation has to find a way of achieving the atomic change behaviour of $b$ in the abstraction without such an atomicity assumption.\n\n\n \n\\subsection{Understanding Simpson's representation}\n\\label{S-reif1}\n\nThe challenge of presenting a specification that makes sense to potential users\nis addressed in Section~\\ref{S-4-spec}.\nA development using a single data reification step to a version of Simpson's code is presented in\nSection~\\ref{S-1step} ---\nthat development makes interesting further use of the possible values concept and is thus presented in some detail.\nThe current section attempts to provide an intuition of the `four-slot' data structure.\nThe operations corresponding to $Write$ and $Read$ of Section~\\ref{S-4-spec} are here named\n$Write\\sb{i}$ and $Read\\sb{i}$.\n\nThe importance of data abstraction and reification are commented on in Section~\\ref{S-data-reification}.\nRather than jump immediately to Simpson's decision to use exactly four slots to represent the abstract variable $b$, a useful intermediate refinement step uses a data structure that contains\nan abstract map of an indexed set of `slots'  $\\mapof{X}{Value}$.\nHere, this part of the state is named $dw$.\nThere is also a data type invariant that requires that the\n(potentially partial) map has a value in every slot:\n$\\dom{dw} = X$.\n\\footnote{Note that, in the concurrent context, the data type invariant must hold for every step,\nnot just initially and at the end of each operation.}\n\nAs in~\\cite{JonesPierce10},\nthe index set $X$ is deliberately left unspecified at this stage.\n$Write\\sb{i}$ is decomposed into a three parts:\n\n\\begin{itemize}\n\n\\item $Write-ch\\sb{i}$ chooses an index ($\\in X$) that is safe to use\n\n\\item $Write-upd\\sb{i}(v)$ updates the map $dw$ at the chosen index to $v$\n\n\\item $Write-com\\sb{i}$ commits the index by exposing it to $Read\\sb{i}$\n\n\\end{itemize}\n\n\\noindent\n$Read\\sb{i}$ is split into two parts:\n\n\\begin{itemize}\n\n\\item $Read-sel\\sb{i}$ selects the most recently written index and stores that index in a local variable\n\n\\item $r \\gets Read-acc\\sb{i}$ accesses the indexed slot\n\n\\end{itemize}\n\n$Write\\sb{i}$ must inform $Read\\sb{i}$ of the index of the slot which has been (most recently) written.\nIn addition, $Read\\sb{i}$ must have a way of alerting $Write\\sb{i}$ to the index of the slot that is claimed for reading.\nRemember that the reader and writer processes are in no way synchronised and the implementation is designed to allow (multiple) reads to occur during a write or multiple writes to overlap with a single read.\n\nIt should be clear that the potential number of slots \n(the cardinality of the set $X$)\nmust be at least three because the writer has to select a member of $X$ that is neither the most recently written nor one which the reader might access \n(these could be the same but are not necessarily so).\nIt is possible to build a `three slot' implementation\n{\\em providing} there is an atomic way of communicating index values between $Read$ and $Write$.\n\n\n\nIt is tempting to make $Read\\sb{i}$ reserve a single element of $X$ to $Write\\sb{i}$ but this does not actually provide an abstraction of Simpson's code.\nWhat that code effectively does is to reserve more than one slot.\nThis is shown here as $pr$ being a set of indexes.\n\n\n\nThe intermediate state is thus:\n\n\\begin{record}{\\Sigma\\sb{i}}\n dw: \\mapof{X}{Value}  \\mbox{\\hspace{1em} -- space for values}\\\\\n lw: X \\mbox{\\hspace{4em} -- index of the last committed write} \\\\\n cw: X   \\mbox{\\hspace{4em} -- index claimed by the writer}\\\\% before it releases its chosen $X$ } \\\\\n cr: X \\mbox{\\hspace{4em} -- index claimed by the reader}\\\\\n pr: \\setof{X} \\mbox{\\hspace{2.5em} -- potential elements of $X$ that the reader might use} \n \\end{record}\n \n\n\nIt is an interesting observation that none of the variables can be modified by both operations.\nThe final letter of each variable name records which process,\n\\underline{r}eader or \\underline{w}riter, can write to that variable\n(e.g.~$lw$ can only be modified by $Write\\sb{i}$).\n\nIt is not difficult to see the lines of the data reification required here:\nthe retrieve function is $b = dw(lw)$.\n\n\n\n\n\n\nThe initial state must, of course, satisfy the invariant;\nthe initial value in the buffer must be\n$dw(lw)$ and there must be some arbitrary value in every slot\nto ensure that $\\dom{dw} = X$.\n\nIt is interesting to note that the issue of (data) race freedom on the slots is worked out \nat this level of abstraction\nwith rely/guarantee conditions.\nThis can be contrasted with Peter O'Hearn's view in~\\cite{OHearn07} \nthat separation logic is the tool of choice for reasoning about race freedom and rely/guarantee reasoning is for `racy' programs.\nThe decisive point appears to be that, here, race freedom is established on a data structure that is more abstract than the final representation.\n\n\n\nAlthough the observation is made above\nthat three slots would be adequate to avoid clashing,\n\\footnote{In fact,~\\cite{BornatAmjad13} also considers a three slot implementation.}\nthe genius of the representation proposed by Hugo Simpson is that \n--if four slots are used--\ncommunication can be reduced to using single bits;\nfurthermore, \nin a physical implementation, \nthese bits can be realised as wires connecting the $Read\\sb{f}$ and $Write\\sb{f}$ processes\nrunning on separate processors.\n\nSimpson describes the algorithm in terms of choosing `pairs' and `slots'.\nAs in~\\cite{JonesPierce10},\nthis intuition is followed by using two sets $P$ and $S$ each of which has two possible values.\nHowever, here,\ntoggling between the two values is achieved by a ``$\\Not$'' operator.\nAlthough both sets $P$ and $S$ can be implemented as Booleans,\nthe temptation to use Booleans is resisted at this stage\nbecause separating the types $P$ and $S$ provides useful information\nas to whether each index variable refers to a pair or a slot\n(and has the potential to flag incorrect use as a type error).\n\n\n\nThe final representation ($\\Sigma\\sb{f}$) is given in Figure~\\ref{F-Sigma-f}.\n\nThis is related to $\\Sigma\\sb{i}$ by a retrieve function where: \n\n\\begin{itemize}\n\n\\item $dw$ is directly modelled by $dsw$ with the set $X$ reified to a $(P, S)$ pair\n\n\\item $cw$ is represented by $(cpw, \\lnot sw(cpw))$\n\n\\item $cr$ is represented by $(cpr, csr)$\n\n\\item $lw$ is represented by $(lpw, sw(lpw))$\n\n\\item $pr$ is represented by $\\set{(cpr, sl) | sl \\in S}$\n\n\\end{itemize}\n\n\\begin{figure}\n\\begin{record}{\\Sigma\\sb{f}}\n dsw: \\mapof{P \\x S}{Value}  \\mbox{\\hspace{1em} -- two pairs of two data slots each} \\\\\n sw: \\mapof{P}{S}  \\mbox{\\hspace{3em} -- $sw(p)$ is the last written slot for pair $p$} \\\\\n lpw: P   \\mbox{\\hspace{6em} -- last written pair} \\\\\n cpw: P   \\mbox{\\hspace{6em} -- current write pair} \\\\\n cpr: P   \\mbox{\\hspace{6em} -- current read pair} \\\\\n csr: S   \\mbox{\\hspace{6em} -- current read slot} \n\\end{record}\n\\caption{The final state $\\Sigma\\sb{f}$}\n\\label{F-Sigma-f}\n\\end{figure}\n\n\n\\subsection{One step argument} \n\\label{S-1step}\n\nThis section presents a single-step data refinement from \nthe top level specification using possible values to Simpson's algorithm.\nAlthough the approach to refining the code from the specification is new,\nthe end code comes from Simpson's insights and motivates the approach.\nThe final state representation is as in Figure~\\ref{F-Sigma-f}\nand the relationship between the abstract buffer $b$ and this representation state is\n\\begin{eqnarray*}\n  b = dsw(lpw,sw(lpw))\\ .\n\\end{eqnarray*}\n\\begin{figure}\n\\begin{minipage}{0.43\\textwidth}\n\\begin{formula}\nRead\\sb{f}()r: Value\\T1\n  \\begin{array}{l}\n        {\\mathop{\\kw{var}}} t \\in P ; \\\\\n        {\\langle { t \\gets lpw} \\rangle} ; \\\\\n        {\\langle { cpr \\gets t} \\rangle} ; \\\\\n        {\\langle { csr \\gets sw(cpr) } \\rangle}; \\\\\n         r \\gets dsw(cpr, csr)\n  \\end{array}\n\\end{formula}\n\\end{minipage}\n\\begin{minipage}{0.55\\textwidth}\n\\begin{formula}\nWrite\\sb{f}(v: Value)\\T1\n  \\begin{array}{l}\n           {\\langle { cpw \\gets \\Not cpr } \\rangle} ; \\\\\n           dsw(cpw, \\Not sw(cpw)) \\gets v ; \\\\\n           {\\langle { sw(cpw) \\gets \\Not sw(cpw) } \\rangle} ; \\\\\n           {\\langle { lpw \\gets cpw } \\rangle}\n  \\end{array}\n\\end{formula} \n\\end{minipage}\n\\caption{Code for Simpson's algorithm}\\label{f:Simpsons}\n\\end{figure}\n\nThe code for Simpson's algorithm is given in Figure~\\ref{f:Simpsons}.\nFirst note that the $Write\\sb{f}$ operation has the following guarantee:\n\\footnote{Although \n\nACMs are much more complicated than the one-place buffer,\nthe idea mentioned in Section~\\ref{S-RG} of locating where a key value is unchanged without\nadding auxiliary variables is evident here.}\n\\begin{eqnarray}\n\n\n  & \\forall{i,j}{(i,j) \\neq (cpw,\\Not sw(cpw)) \\implies dsw'(i,j) = dsw(i,j)} \n    \\label{Write-guar-others-stable} \n\n\n\n\\end{eqnarray}\nand that when the write operation is not active, \nthe writing process does not modify any of the variables in the representation.\n\nThe specification of the $Read\\sb{f}$ operation after mapping through the representation relation \nand extending the frame with an appropriate subset of the representation variables is\n\\begin{eqnarray}\\label{dr-read-spec}\n  \\Spec{t,cpr,csr,r}{}{ r' \\in {\\wideparen{{dsw(lpw,sw(lpw))}}} }\n\\end{eqnarray}\nThe first refinement step uses law~(\\ref{law-posvals-pre-assignment}) from Section~\\ref{S-sem}\nwith $lpw$ corresponding to $x$ and $dsw(v,sw(v))$ corresponding to $e$.\nIn fact the law needs to be extended to accommodate extra variables in the frame but that is straightforward.\n\\begin{eqnarray}\n  (\\ref{dr-read-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { t \\gets lpw } \\rangle} ; \\\\\n  && \\Spec{cpr,csr,r}{}{ r' \\in {\\wideparen{{dsw(t,sw(t))}}} } \\label{second-spec}\n\\end{eqnarray}\nFor this one needs to rely on \n\\begin{eqnarray}\\label{rely-1}\nlpw' \\neq t \\implies dsw'(t,sw'(t)) = dsw(t,sw(t))\\ .\n\\end{eqnarray}\nNote that $sw(t)$ is only changed by $Write\\sb{f}$ if $t = cwp$ but the code also\nguarantees that $t = cpw \\implies t = lpw$ and hence $sw(t)$ can be changed only\nif $lpw' = t$ and hence (\\ref{rely-1}) holds.\nIf $sw(t)$ does not change, (\\ref{rely-1}) is guaranteed by $Write\\sb{f}$ \nby (\\ref{Write-guar-others-stable}) because\n$(t,sw(t)) \\neq (cpw,\\Not sw(cpw))$ because\neither $t \\neq cpw$ or if $t = cpw$ then $sw(t) = sw(cpw) \\neq \\Not sw(cpw)$.\nThis use of the slots vector $sw$ in Simpson's algorithm is one of the smart parts of how it works.\n\nThe second refinement step uses law~(\\ref{law-posvals-pre-assignment}) once more to refine (\\ref{second-spec}).\n\\begin{eqnarray}\n  (\\ref{second-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { cpr \\gets t } \\rangle} ; \\\\\n  && \\Spec{csr,r}{}{ r' \\in {\\wideparen{{dsw(cpr,sw(cpr))}}} } \\label{third-spec}\n\\end{eqnarray}\nprovided one can rely on $t' \\neq cpr \\implies dsw'(cpr,sw'(cpr)) = dsw(cpr,sw(cpr))$\nwhich holds trivially as $t = cpr$ is invariant over (\\ref{third-spec}).\n\nThe third refinement step again uses law~(\\ref{law-posvals-pre-assignment}) to refine (\\ref{third-spec}).\n\\begin{eqnarray}\n  (\\ref{third-spec}) & {\\mathrel{\\sqsubseteq}} & {\\langle { csr \\gets sw(cpr) } \\rangle} ; \\label{assign-csr} \\\\\n  && \\Spec{r}{}{ r' \\in {\\wideparen{{dsw(cpr,csr))}}} } \\label{fourth-spec}\n\\end{eqnarray}\nprovided one can rely on \n\\begin{eqnarray}\\label{third-rely}\n  sw'(cpr) \\neq csr \\implies dsw'(cpr,csr) = dsw(cpr,csr)\n\\end{eqnarray}\nbeing maintained by $Write\\sb{f}$ for the duration of (\\ref{fourth-spec}).\nHere (\\ref{third-rely}) can be strengthened to\n\\begin{eqnarray}\\label{third-rely-rev}\n  dsw'(cpr,csr) = dsw(cpr,csr)\n\\end{eqnarray}\nand this can be shown to be maintained by $Write\\sb{f}$ using the approach outlined\nin Section~\\ref{S-strengthening-law}.\nFor the duration of (\\ref{fourth-spec}), $Read\\sb{f}$ strengthens its guarantee to state\nthat it does not modify any shared variables ($r$ is local to $Read\\sb{f}$).\nBecause (\\ref{assign-csr}) establishes \n\\begin{eqnarray}\\label{read-phase-init}\n (cpr,csr) & \\neq & (cpw,\\lnot sw(cpw))\n\\end{eqnarray}\nit is sufficient to show that $Write\\sb{f}$ maintains (\\ref{third-rely-rev}) from\ninitial states satisfying (\\ref{read-phase-init}) provided there is no interference\non its shared variables.\nIf $Write\\sb{f}$ is executing its write phase from any state satisfying (\\ref{read-phase-init}),\nit guarantees (\\ref{third-rely-rev}) because the slot being written is not $(cpr,csr)$.\nOnce $Write\\sb{f}$ finishes its write phase (or if it is not initially in its write phase)\nit does not modify $dsw$ at all\n(and hence maintains (\\ref{third-rely-rev})) \nuntil after it executes $cpw \\gets \\lnot cpr$ \nwhich re-establishes (\\ref{read-phase-init}) for the next write phase.\n\nThe final refinement step uses law~(\\ref{law-single-reference-posvals}) to refine (\\ref{fourth-spec}).\n\\begin{eqnarray*}\n  (\\ref{fourth-spec}) & {\\mathrel{\\sqsubseteq}} & r \\gets dsw(cpr,csr)\n\\end{eqnarray*}\nThis is valid provided $dsw(cpr,csr)$ is stable,\nwhich follows from the argument given above for the previous refinement step.\n\nA pleasing aspect of the above refinement is that, having started from a specification\n(\\ref{dr-read-spec}) using the possible values concept\n(which allows for non-determinism in the value read),\nthe refinement steps have maintained the use of possible values \n(and hence the non-determinism) \nuntil the last step, when it is clear which slot is being read \n(and that the slot is stable).\n\nUsing the approach of locally strengthening a guarantee \n--and hence indirectly strengthening a rely-- \n(see Section~\\ref{S-strengthening-law})\nobviates the need to introduce and reason about auxiliary variables.\nHowever, a development using auxiliary Boolean variables $reading$ and $writing$ is also possible,\nwhere $reading$ is true if and only if the $Read$ process is actually reading from $dsw$\nand $writing$ is true if and only if the $Write$ process is actually writing $dsw$.\nWith these auxiliary variables the important invariant is,\n\\begin{eqnarray*}\n  reading \\land writing & \\implies &(cpr,csr) \\neq (cpw,\\lnot sw(cpw))\n\\end{eqnarray*}\nwhich ensures that the $Read$ and $Write$ processes are not simultaneously\nusing the same slot.\nThis represents the weakest invariant to ensure correct operation of the algorithm. \n\nBecause the specification of $Write\\sb{f}$ does not make use of possible values notation \nits refinement is not presented in detail here.\nAn important property of $Write\\sb{f}$ is that during its writing phase the slot being written \ndiffers from any slot that could be read concurrently,\nwhich has been covered in the refinement of $Read\\sb{f}$.\nThe other aspect of $Write\\sb{f}$ worth noting is that its guarantee in the abstract\nspecification requires the buffer $b$ to be updated to $v$ atomically.\nRecalling that $b$ is represented by $dsw(lpw,sw(lpw))$, \nthat guarantee is achieved by (non-atomically) assigning to slot $(cpw,\\lnot sw(cpw))$, \nwhich can never correspond to $b$.\nThe switch of $(lpw,sw(lpw))$ to $(cpw,\\lnot sw(cpw))$ is then achieved \neither by the assignment $sw(cpw) \\gets \\lnot sw(cpw)$ if $lpw$ already equals $cpw$,\nor by the following assignment $lpw \\gets cpw$ if they differed initially.\n\nFinally note that all of the atomic assignments in Figure\\ \\ref{f:Simpsons} are now\nin a form in which they can be implemented by the corresponding non-atomic assignment,\nassuming each read and write of a shared variable other than $dsw$ is atomic. \nThis assumption is in line with the requirements because the shared flags can be implemented as single bits (or, indeed, realised as wires).\n\n\n\n\n\\section{Conclusions and further work} \n\\label{S-conc}\n\n\n\n\nThe concept of possible values arose in an attempt to provide a clear design rationale of \ncode which is delicate in the sense that slight changes destroy its correctness.\nA seemingly simple and intuitive notational idea contributed to the description of a layered development.\nThe proposal was clearly motivated by a need in a practical application.\n\nThe next bonus came in the link to the non-deterministic state ideas:\nthis connection is set out in~\\cite{HayesBurnsDongolJones12}.\n\nThe current paper contains the first publication of the specification given in Section~\\ref{S-4-spec}\nand the simplicity of the overall specification comes as strong encouragement\nfor the concept and notation of possible values.\nThis is further reinforced by the development of Simpson's algorithm in Section~\\ref{S-1step}\nwhich retains the use of the possible values notation and \nutilises laws taking advantage of the possible values notation.\n\n\n\n\nThis closing section points to further avenues that appear to have potential but\ncertainly require more work.\nAs with the steps to date,\nthe motivation for the decisions should come from practical examples.\n\n\n\\subsection{Further applications} \n\n\n\n\n\n\n\n\nIt can perhaps be mentioned that the possible values notation appears to have some potential \nfor recording arguments about brain-teaser puzzles.\nAt the March 2015 meeting of IFIP WG~2.3 in Istanbul, \nMichael Jackson posed a hide-and-seek puzzle which is apparently described in several contexts.\nHere, a mole is what must be located.\nThere are five holes in a line;\nthe mole moves each night to an adjacent hole;\nthe seeker can only check one hole per night and must devise a strategy that eventually locates the mole whose non-deterministic nocturnal movements are only constrained at either end of the line of holes.\nThis paper doesn't spoil the reader's fun by providing an answer;\nit only mentions that one of the authors recorded the argument for termination using \nthe possible values notation.\n\nSadly, most of the examples (see~\\cite{SewellEt-11,vafeiadis-11,ridge-10})\nusing `weak memory' \n(a.k.a. `relaxed memory')\nalso give the feeling that they are gratuitous puzzles.\nAt a recent Schloss Dagstuhl meeting (15191),\none of the authors tried to use the possible values notation to record the \nnon-determinism that results from not knowing when the various caches are flushed.\nIt must be conceded that, \non the pure puzzle examples, \npossible values are doing little more than providing an alternative notation for\ndisjunctions.\nA challenge is to find a genuinely useful piece of code that,\ndespite non-determinism,\nsatisfies a coherent overall specification under, say, \ntotal store order (TSO)\nor\npartial store order (PSO) memory models.\nOnly on such an application should the judgement about the usefulness of \npossible values be based.\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are also alternative views of the possible values notation itself.\nFor example, ${\\wideparen{{b}}}$ could yield a sequence of values rather than a set.\nThere is however an argument for preserving a (direct) way of denoting the set of possible values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Possible evaluations of expressions} \n\\label{S-epe}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs well as possible values of an expression ${\\wideparen{{e}}}$\nthat is the set of values of $e$ evaluated in each state of the execution,\none can define ${\\wideparen{\\wideparen{{e}}}}$ as the set of all possible evaluations of $e$ over the execution interval:\neach instance of a variable $x$ in $e$ takes on one of the values of $x$ in the interval\nso that different occurrences of $x$ within $e$ may take on different values, and\nthe values of separate variables $x$ and $y$ may be taken from different states.\nThe set of evaluations includes those in which the values of all the variables are taken\nin a single state and hence ${\\wideparen{{e}}} \\subseteq {\\wideparen{\\wideparen{{e}}}}$.\nIn~\\cite{HayesBurnsDongolJones12} the possible values concept was linked to \ndifferent forms of nondeterministic expression evaluation \ncorresponding to ${\\wideparen{{e}}}$ and ${\\wideparen{\\wideparen{{e}}}}$.\n\nThe following simple rule requires no restriction on $e$ \nother than it does not contain references to $x$ because $x$ is in the frame of the specification.\n", "index": 7, "text": "\n\\[\n  {{\\mathop{\\kw{rely}}} {x' = x} \\suchthat {\\Spec{x}{}{ x' \\in {\\wideparen{\\wideparen{{e}}}} } }} \\ \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \\  x \\gets e \\ .\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"{{\\mathop{\\kw{rely}}}{x^{\\prime}=x}\\suchthat{\\Spec{x}{}{x^{\\prime}\\in{%&#10;\\wideparen{\\wideparen{{e}}}}}}}\\ \\ \\ {\\mathrel{\\sqsubseteq}}\\ \\ \\ x\\leftarrow e\\ .\" display=\"block\"><mrow><mrow><mrow><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\kw</mtext></merror><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>y</mi></mrow><msup><mi>x</mi><mo>\u2032</mo></msup></mrow><mo>=</mo><mrow><mi>x</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\suchthat</mtext></merror><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\Spec</mtext></merror><mo>\u2062</mo><mi>x</mi><mo>\u2062</mo><msup><mi>x</mi><mo>\u2032</mo></msup></mrow><mo>\u2208</mo><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mo>\u2062</mo><mi>e</mi></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2006</mo><mrow><mrow><mo>\u2291</mo><mo mathvariant=\"italic\" separator=\"true\">\u2003\u2003\u2006</mo><mi>x</mi></mrow><mo>\u2190</mo><mpadded width=\"+5pt\"><mi>e</mi></mpadded></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02132.tex", "nexttext": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Auxiliary variables} \n\\label{s:auxiliary}\n\nThe statement is made in~\\cite{Jones-CARH-FS-10} that using auxiliary (a.k.a.\\ ghost) variables in the specification of a software component {\\em can} destroy compositionality by encoding too much information about the environment.\nStudying possible values has helped put the position more clearly:\n\n\\begin{itemize}\n\n\\item having the code of the environment gives maximum information ---  but minimal compositionality\n\n\\item the same distinction is actually there with sequential programs where post conditions provide \nan abstract description of functionality without committing to an algorithm\n(they can also leave unconstrained the values left in temporary variables etc.)\n\n\\item  for concurrency, things are much more sensitive:\none ideal is that the visible variables (read and write) of parallel processes are `separate' ---\nthis might be true on a concrete representation even when an abstract description appears to admit interference --- see~\\cite{SEFM-15-paper}\n\n\\item rely/guarantee conditions are an attempt to state only what matters\n\n\\item the expressive `weakness' of rely/guarantee conditions (is conceded and) can be a positive attribute\n\n\\item auxiliary variables can be used to encode extra information about the environment ---\nin the extreme, with use of statement counters, they can encode as much as the program\nbeing executed by the environment\n\n\\end{itemize}\n\nThe advice is to minimise the use of auxiliary variables --- even when writing assertions,\nabstraction from the environment can be lost if gratuitous information is recorded in auxiliary variables.\nThe `possible values' notation appears to offer an intuitive specification tool and \na principled way of avoiding the need for some auxiliary variables.\n\n\n\nOne indication of the compositional nature of rely conditions is that, \nif a component with a rely condition $r$ is refined to a sequential composition,\neach subcomponent inherits the rely condition $r$.\nConversely, a sequential composition guarantees a relation $g$\nif each component of the sequential composition guarantees $g$.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section*{Acknowledgements} \n\nAn earlier version of this paper was prepared for a conference that celebratied Jos\\'{e} Nuno Oliveira's sixtieth birthday.\nThe authors of the current paper thank the organisers of that memorable event in Guimar\\~{a}es and take the opportunity to renew their warmest good wishes to Jos\\'{e}.\n\nOutlines of material on possible values were presented at the 2015 meeting of IFIP WG~2.3\nand at the Schloss Dagstuhl meeting 15191 ---\non both occasions comments were made that have helped clarify the ideas and their explanation.\nIn Dagstuhl, useful discussions with Viktor Vafeiadis helped one author understand \nthe issues around weak memory.\nUseful comments on a draft from Diego Machado Dias are gratefully acknowledged\nas are those of the anonymous journal referees.\n\nThe research reported here is funded by\nthe EPSRC responsive mode grant on ``Taming Concurrency'', \nthe EPSRC Platform Grant ``TrAmS-2''\nand the ARC grant DP130102901; \nthe authors express their thanks for this support.\n\n\n\n\\section*{References}\n\n\\bibliographystyle{alpha}\n\n\n\n\\bibliography{parallel}\n\n\n\n\n", "itemtype": "equation", "pos": 60482, "prevtext": "\n\nIf $e$ satisfies the single reference property over the execution interval \n(as defined earlier)\nthen ${\\wideparen{\\wideparen{{e}}}} = {\\wideparen{{e}}}$ and hence\n", "index": 9, "text": "\n\\[\n \\begin{array}{ll}\n     & {{\\mathop{\\kw{rely}}} {x' = x \\And (\\bigwedge z \\in S \\suchthat z' = z)} \\suchthat { \\Spec{x}{}{ x' \\in {\\wideparen{{e}}} } }} \\\\\n  = & {{\\mathop{\\kw{rely}}} {x'=x \\And (\\bigwedge z \\in S \\suchthat z' = z)} \\suchthat { \\Spec{x}{}{ x' \\in {\\wideparen{\\wideparen{{e}}}} } }} \\\\\n  {\\mathrel{\\sqsubseteq}} & x \\gets e \\ .\n \\end{array}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\begin{array}[]{ll}&amp;{{\\mathop{\\kw{rely}}}{x^{\\prime}=x\\And(\\bigwedge z\\in S%&#10;\\suchthat z^{\\prime}=z)}\\suchthat{\\Spec{x}{}{x^{\\prime}\\in{\\wideparen{{e}}}}}}%&#10;\\\\&#10;=&amp;{{\\mathop{\\kw{rely}}}{x^{\\prime}=x\\And(\\bigwedge z\\in S\\suchthat z^{\\prime}=%&#10;z)}\\suchthat{\\Spec{x}{}{x^{\\prime}\\in{\\wideparen{\\wideparen{{e}}}}}}}\\\\&#10;{\\mathrel{\\sqsubseteq}}&amp;x\\leftarrow e\\ .\\end{array}\" display=\"block\"><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd/><mtd columnalign=\"left\"><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\kw</mtext></merror><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>y</mi></mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>=</mo><mi>x</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\And</mtext></merror><mrow><mo stretchy=\"false\">(</mo><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mi>z</mi><mo>\u2208</mo><mi>S</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\suchthat</mtext></merror><msup><mi>z</mi><mo>\u2032</mo></msup><mo>=</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\suchthat</mtext></merror><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\Spec</mtext></merror><mi>x</mi><msup><mi>x</mi><mo>\u2032</mo></msup><mo>\u2208</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mi>e</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mo>=</mo></mtd><mtd columnalign=\"left\"><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\kw</mtext></merror><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mi>l</mi><mo>\u2062</mo><mi>y</mi></mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>=</mo><mi>x</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\And</mtext></merror><mrow><mo stretchy=\"false\">(</mo><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mi>z</mi><mo>\u2208</mo><mi>S</mi><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\suchthat</mtext></merror><msup><mi>z</mi><mo>\u2032</mo></msup><mo>=</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\suchthat</mtext></merror><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\Spec</mtext></merror><mi>x</mi><msup><mi>x</mi><mo>\u2032</mo></msup><mo>\u2208</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\wideparen</mtext></merror><mi>e</mi></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mo>\u2291</mo></mtd><mtd columnalign=\"left\"><mrow><mrow><mi>x</mi><mo>\u2190</mo><mpadded width=\"+5pt\"><mi>e</mi></mpadded></mrow><mo>.</mo></mrow></mtd></mtr></mtable></math>", "type": "latex"}]