[{"file": "1601.01487.tex", "nexttext": "\nwhere $c$ is a new constant~\\cite{pudlak87}. This rule enables one to\nrefer to an element satisfying $\\phi$ without having to mention\n$\\phi$. The same asymptotic bound is probably true for some other\nsystems where this rule can be simulated.  In particular, in natural\ndeduction systems, we can start with an assumption $\\phi(y)$ and argue\nabout $y$ without having to repeat the assumption in each proof line.\n\nThe idea of the proofs of these lower bounds is to adapt the original\nproof of G\\\"odel for the finite setting. Thus instead of the original\ndiagonal formula, one uses a formula $\\delta(\\bar n)$ with intended\nmeaning {\\it ``I do not have a $T$-proof of length $\\leq n$''}. One\ncan easily prove that $\\delta_T(\\bar n)$ is true and any proof of it\nmust be longer than $n$. Then one proves that $\\delta_T(\\bar n)$ can\nbe derived from $Con_T(\\bar n)$ by a short proof. This is essentially\nthe same as in the proof of G\\\"odel's theorem, except that one has to\nprove good \\emph{upper bounds} on the lengths of proofs of certain\ntrue sentences. The shorter proofs one is able to find, the larger the\nlower bound is.\n\nIn \\cite{pudlak86} a linear upper bound $O(n)$ was proved for sequential\ntheories.\n\\footnote{Sequential theories are, roughly speaking, theories in which one can code any finite sequence of elements of the universe. Already very weak fragments of arithmetic and set theory are known to be sequential.}\nThis bound is based on partial truth definitions. In the\nstandard proofs of the consistency of a theory $T$ (without any bound on\nthe lengths of proofs), one uses a truth definition for all\nformulas. Since in proofs of bounded length only formulas of bounded\ncomplexity can occur, it suffices to use a partial truth definition\nthat define truth only for sentences of limited complexity. The fact\nthat partial truth definition exist is well-known. However, to obtain such bounds\none has to carefully estimate the size of the formulas and the lengths\nof proofs of particular statements.\n\nIn spite of the linear upper bound, we still believe that the incompleteness\nphenomenon of G\\\"odel's theorem should manifest itself also in the\nfinite domain. We conjecture that if $T$ is stronger than a theory\n$S$, then $S$-proofs of $Con_T(\\bar n)$ cannot be\npolynomially bounded. Since it is not clear how much stronger $T$ must\nbe, we proposed the following conjecture in~\\cite{pudlak86}:\n\n\\begin{conjecture}{\\sf CON$^N$}\\label{CONN}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $Con_T(\\bar n)$ cannot be polynomially bounded.\n\\footnote{The superscript $N$ stands for ``nonuniform'' whose meaning will be explained in Section~\\ref{sec6}.}\n\\end{conjecture}\n\n\n\n\n\n\nOf course, we would also like to know how much stronger $T$ must be\nthan $S$ so that there are no polynomial size $S$-proofs of\n$Con_T(n)$. It has been conjectured that it suffices that $T$ proves\nthe consistency of $S$, i.e., the following seems to be true:\n\\begin{conjecture}{\\sf CON$^{N+}$}\n for every $S,T\\in\\cal T$, if $T$ proves $Con_S$, then\n  $S$-proofs of $Con_T(\\bar n)$ cannot be polynomially bounded.\n\\end{conjecture}\n\nIt is well-known~\\cite{ehrenfeucht-mycielski} that if $T$ is stronger (proves more\nsentences) than $S$, then some sentences provable in both theories\nhave much shorter proofs in $T$. This may suggest that it would\nsuffice to make $T$ just a little stronger than $S$ in order to ensure\nthat $S$-proofs of $Con_T(\\bar n)$ do not have polynomial\nproofs. However, recently Pavel Hrube\\v{s} proved, using a Rosser-type\nselfreferential sentence, that in general it is not so [personal communication].\nHis result is even stronger than the mere refutation of that statement.\n\n\\begin{theorem}\n  For every $S,T\\in\\cal T$, there exists a true $\\Pi_1$ sentence $\\pi$\n  such that $\\pi$ is not provable in $T$, yet the lengths of\n  $S$-proofs of $Con_{S+\\pi}(\\bar n)$ can be bounded by a polynomial.\n\\end{theorem}\nIn particular, if $S=T$, we get $\\pi\\in\\Pi_1$ unprovable in $S$ with polynomially bounded $S$-proofs of $Con_{S+\\pi}(\\bar n)$.\n\n\\subsection{A finite reflection principle}\n\nRecall that the sentences expressing consistency of a theory $T$ are\nspecial cases of \\emph{reflection\n  principles} (see~\\cite{smorynski77}). There are many versions of\nreflection principles. Here we will focus on the uniform\n$\\Sigma_1$-reflection principles.\n\n\n\nThe\n\\emph{uniform $\\Sigma_1$-reflection principle for $T$} is the\nfollowing schema for all $\\Sigma_1$ sentences $\\sigma(x)$ with one free variable $x$\n", "itemtype": "equation", "pos": 17591, "prevtext": "\n\\maketitle\n\n\\begin{abstract}\nMotivated by the problem of finding finite versions of classical incompleteness theorems, we present some conjectures that go beyond ${\\bf NP\\neq\n  co NP}$. These conjectures formally connect computational complexity with the difficulty of proving some sentences, which means that high computational complexity of a problem associated with a sentence implies that the sentence is not provable in a weak theory, or requires a long proof. Another reason for putting forward these\nconjectures is that some results in proof complexity seem to be special cases of such general statements and we want to formalize and fully understand these statements. In this paper we review some conjectures that we have presented earlier~\\cite{KP,godel100,kniha,herbr}, introduce new conjectures, systematize them and prove new connections between them and some other statements studied before. \n\n\\end{abstract}\n\n\\section{Introduction}\n\nG\\\"odel's incompleteness theorem is undoubtedly one of the most\nimportant theorems in logic. \n\n\nIt speaks about absolute provability, i.e., about\nproofs without any restriction on their size. The question whether\nthere is a ``finite'' or ``feasible'' version of the incompleteness\ntheorem, where the complexity of proofs is bounded, has certainly intrigued many people, but very little has been \npublished about it. With the advent of computers and theories\ndeveloped for them, in particular complexity theory, the question\nabout a finite version of the incompleteness theorem became even more\ninteresting. The concept of polynomial time computations turned out to\nbe the most important concept in complexity theory. The distinction between functions decidable in polynomial time and those computable only in exponential time plays a similar role as the distinction between computable and non-computable in the computability theory. \nThe successful use\nof polynomial bounds suggested that one should also study which\ntheorems have polynomial size proofs. A natural version of\na finite incompleteness theorem was formulated by Harvey Friedman in~1979. Let\n$Con_T(\\bar n)$ be a natural formalization of the statement\n\\emph{``there is no derivation of contradiction of length $n$ from the\n  axioms of $T$''}. Friedman proved a lower bound of the form $n^\\epsilon$ for some $\\epsilon>0$ and asked whether such sentences have proofs in\n$T$ of polynomial length~\\cite{friedman79}. \nIt turned out that the answer to his question is\nyes~\\cite{pudlak86}, but this is not important, because for natural variations\nof this question it is still possible, and seems very plausible, that\nthere are no polynomial length proofs. Namely, this should be true if\nwe ask about the lengths of proofs of $Con_T(\\bar n)$ in a theory $S$ sufficiently\n\\emph{weaker} than $T$. However, proving such a claim must be\nextremely difficult, because it implies ${\\bf P\\neq NP}$ (and even more\nthan that).\n\nWe have to face the fact that the present-day mathematics lacks\nmethods to solve such problems. Nevertheless there there is something\nwe can do. The fundamental question is \\emph{what is the connection\n  between logical strength of theories and computational complexity?}\nwhich is basically what the field of \\emph{proof complexity} is\nstudying.\n\\footnote{We interpret the name proof complexity in a broad sense, which includes also the study of first order theories called bounded arithmetic.}\n\n\nFor example, Buss's Witnessing Theorem states that one can\nconstruct polynomial time algorithms from proofs of certain sentences\nin the theory $S^1_2$~\\cite{buss86}. Such theorems have been proven\nfor a number of other theories and complexity classes. Another\nconnection is the Feasible Interpolation Theorem of\nKraj\\'{\\i}\\v{c}ek~\\cite{krajicek97}. According to this theorem, one\ncan construct circuits from proofs of certain tautologies in various\nproof systems, in particular, in resolution. (Such theorems have been\nproven also for other proof systems.)  A high level form of these\nresults is that if something is provable in a weak formal system,\ni.e., the logical strength of the system is bounded, we can give\nbounds on some computational problems associated with the systems. If\nwe state it contrapositively it suggest that increasing strength of\nlogical formal systems is correlated with increasing complexity of the\nassociated computational tasks. Thus a more specific question is:\n\\emph{find general principles of which these results are special\n  instances.}\n\nIn constructive mathematics there is a very close connection between\nproofs and computations. There are also results that show interesting\nconnections with computational complexity. For example, Buss and\nMints~\\cite{BussMints} proved that given an intuitionistic proof of a\ndisjunction $\\phi\\vee\\psi$ in propositional logic (say, in the sequent\ncalculus), then one can find \\emph{in polynomial time} a proof of either\n$\\phi$ or $\\psi$. However, in this paper we will only consider\nclassical logic. The reason is that in what we study here, the underlying\nlogic is not important. What is essential are proof systems and axioms\nused. Considering intuitionistic logic would only be a restriction on\nthe systems we could use, while we are interested in formal\nsystems that are as general as possible.\n\nThe general principles that we study are connected with notoriously\nopen and probably very difficult problems in computational complexity\ntheory, so we cannot prove or disprove them with the currently\navailable means. They can only be stated as hypotheses or conjectures\nwithout any formal supporting evidence. Alternatively, we can view\nthem as axioms.\nThere are, essentially, two\nreasons for stating some sentences as conjectures.\nFirst, we believe that some basic theorems of proof theory should also hold true with suitable bounds on the lengths of proofs. The prime example is\nthe Second Incompleteness Theorem discussed above.\nSecond, some results in proof complexity and bounded arithmetic seem to follow a general pattern.\nFor example, as we noted above, polynomial time computations are\nassociated with the theory $S^1_2$ by a witnessing theorem. If we take\n$S^2_2$, which we believe is a stronger theory, then the corresponding\nfunction class is ${\\bf P^{NP}}$, which we believe is a larger class\nthan {\\bf P}. The form of this result suggests that $S^2_2$ requires\nmore complex functions. (We are not able to prove it formally, because a \nformal proof would give us ${\\bf P^{NP}\\neq P}$, which is equivalent\nto ${\\bf NP\\neq P}$.)\n\nAlthough we have to treat the most interesting statements only as hypotheses, there are some interesting problems that we can study and\nsolve with the currently available means. These are problems about\nrelationships among various conjectures.  In particular, we would like\nto know whether there is one general principle that would cover all\ninstances, or there is an infinite hierarchy. If there is a hierarchy, is it\nlinear, or does it branch? If it branches, is there a natural\nclassification of conjectures? We will address some questions of this\nkind in this paper. Furthermore, one can study relativizations of\nthese conjectures. Several results about relativizations have been proven,\nbut much more is needed.\n\nWe are primarily interested in these question, because we want to\nunderstand the essence of fundamental problems. \n\n\nHowever, there is also a practical aspect of this\nresearch. The general conjectures suggest what specific problems in\nproof complexity we should study. Then we can ``test'' the\nconjectures on weak formal systems for which we do have means to prove\nresults connecting them with computational complexity. In fact the main Conjectures~{\\sf CON}  and~{\\sf TFNP} represent what researchers in proof complexity believe is likely to be true. \n\n All conjectures that we consider in this paper state something about\n unprovability, although they often have a natural equivalent\n version stated in purely complexity-theoretical terms. The ``finite\n domain'' in the title refers to the fact that the lengths of\n computations and lengths of proofs of instances of the problems that\n we consider are at most exponential, hence there is a \\emph{finite}\n bound on them. Perhaps, a more precise term would be ``exponential\n domain''. In previous presentations of this topic, in particular\n in~\\cite{kniha}, we used the term \\emph{``feasible incompleteness'',} which\n should be understood as \\emph{``being incomplete with respect to feasible\n proofs''.} In~\\cite{kniha} we also stated \\emph{the feasible\n   incompleteness thesis}, which is an informal statement saying that\n unprovability of a sentence in a weak formal system may be caused by high computational\n complexity of a computational problem naturally associated with the sentence.\n\n\\medskip\nHere is a brief outline of this paper. After two introductory sections, in Section~\\ref{sec3}, we recall the conjecture about finite consistencies and introduce a new conjecture about finite reflection principles. In Section~\\ref{sec4} we present another important conjecture about total polynomial search problems. We discuss equivalent and stronger statements based on propositional proof systems and disjoint {\\bf NP} and {\\bf coNP} pairs of sets in Section~\\ref{sec5}. We introduce a classification of conjectures in Section~\\ref{sec6} and  show that uniform conjectures can be stated as statements about unprovability, which suggests a way towards general conjectures. Section~\\ref{sec8} is about the role of reductions in the statements of conjectures. We conclude the paper with some\nopen problems.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Preliminaries}\\label{sec2}\n\nWe will need the concept of a sufficiently strong arithmetical theory, where theory means a set of axioms in first order logic. This concept appears in the classical incompleteness\ntheorems. Restricting to arithmetical theories is not\nessential. Fragments of arithmetic, as those theories are called, are\nused, because one can easily refer to standard formalizations of basic\nsyntactical concepts. Being able to formalize syntactical concepts,\nsuch as first order formulas and proofs, is the essential property of\nthe theories that we need. The concept of a sufficiently strong arithmetical\ntheory is used in conjectures that we study in this\npaper. The form of these statements guarantees that they do not depend\non a particular formalization of the concept of a sufficiently strong\ntheory; nevertheless, it is good to be more precise. \n\n\\bdf \nWe denote by $\\cal T$ the class of all \\emph{consistent} theories that\nextend Buss's theory $S^1_2$ by a set of axioms that is decidable in\npolynomial time.\n\\edf\n\nFor a lack of a good name, we will only use the symbol $\\cal T$ to\ndenote this class of theories. Theory $S^1_2$ is one of the fragments\nof Bounded Arithmetic $S_2$ defined by Buss~\\cite{buss86} (see also \\cite{HP,krajicek95}). Formally, it is not a fragment of $PA$\n(Peano Arithmetic), because it is formalized in a slightly richer\nlanguage, but it is interpretable in it. It is a natural fragment of\narithmetic in which polynomial time computations can be defined. Since\nthe choice of the base theory is not essential, the reader not\nfamiliar with $S^1_2$ can safely replace it, e.g., by the much\nstronger theory $PA$. The theory $S^1_2$ is a natural choice for the base theory, also because in this theory one can easily define some \nclasses of formulas that we will need. We assume that the theories in $\\cal T$ are formalized in the language of $S_2$. We could allow extensions by symbols representing other polynomial time computable functions and relations, but it would not give any advantage.\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe will assume that proofs are formalized in a standard Hilbert-style\nproof system for first order logic.  We will view the proofs as\nstrings of formulas such that each formula is either an axiom (logical\nor an axiom of the theory in question) or is derived from previous\nformulas by an application of a deduction rule. The particular choice\nof the system makes little difference, but note that we do need to\nconsider proof systems with the rules of modus ponens, or cut, and the\nproofs must be linear, not trees. A proof in a theory $T$ will be\nsimply called a \\emph{$T$-proof}.\n\nAn essential property of our theories and the proof system is that\ngiven a sentence $\\phi$ and a string of symbols $d$, it is possible to\ndecide in polynomial time if $d$ is a proof of $\\phi$. This is also\nthe reason why we only use theories with sets of axioms in {\\bf P}.\n\nFurther we need to define {\\bf NP} and {\\bf P} predicates\nand relations in theories from the class~$\\cal T$. Having $S^1_2$ as the base\ntheory, the natural choice of formulas for {\\bf NP} are $\\Sigma^b_1$ formulas \ndefined by Buss. The hierarchy of formulas $\\Sigma_n^b$ is similar the\nthe arithmetical hierarchy $\\Sigma_n$ the difference being that we\ncount the alternation of \\emph{bounded quantifiers}. \nIn $\\Sigma^b_1$ (and similarly in higher classes) bounded\n  existential quantifiers may alternate with sharply bounded universal\n  quantifiers where sharply bounded means that the bound is\n  polylogarithmic. This complication can be avoided by slightly\n  extending $S^1_2$ with more function symbols and axioms. If we do this, then we can move all sharply bounded universal quantifiers after the bounded existential ones. The $\\Sigma^b_n$ formulas where all sharply bounded quantifiers are after all bounded quantifiers are called {\\it strict-}$\\Sigma^b_n$, or  $\\hat{\\Sigma}^b_n$ formulas.\n\nThe language of $S_2$ has a function symbol for the binary function\n$2^{\\lceil\\log_2 (x+1)\\rceil\\cdot\\lceil\\log_2 (y+1)\\rceil}$ which\nfrom two numbers of length $k$ and $l$ produces a number of length\n$kl$. Thus the terms in bounded quantifiers give polynomial upper\nbounds on the \\emph{binary lengths} of the quantified numbers, rather\nthan polynomial bound on the numbers, as the terms of $PA$ do. \nIn order to simplify formulas we will sometimes use quantifiers with a superscript $\\forall^p,\\exists^p$ to indicate that the lengths of the quantified variables are polynomially bounded in the formula that follows. For example, $\\forall x\\exists^p y.\\phi(x,y)$ means that $\\phi(x,y)$ is equivalent to a formula $|y|\\leq p(|x|)\\wedge\\phi'(x,y)$ for some formula $\\phi'(x,y)$ and some polynomial $p(x)$. \n\nFor {\\bf P}, there is no simple definition of a class of\nformulas. Formulas from the class $\\Sigma^b_0(=\\Pi^b_0)$ have only\nsharply bounded quantifiers. These bounds imply that they define sets\nand relations computable in polynomial time, but we cannot define all\nsets in {\\bf P} by such formulas. The standard approach is to extend\nthe language by function symbols for every polynomial time algorithm\nas it is in Cook's theory $PV$~\\cite{cook75}. This requires also\nadding infinitely many axioms specifying the intended interpretation\nof each function symbols. The relation of $PV$ to $S_2$ is similar to\nthe relation of Primitive Recursive Arithmetic to Peano Arithmetic. In\nthis paper we will use a different approach, one that does not need\nan infinite number of function symbols and axioms. A formula $\\sigma(x)$\nis $\\Delta^b_1$ provably in a theory $T$ if $\\sigma(x)\\in\\Sigma^b_1$\nand, for some $\\pi(x)\\in\\Pi^b_1$, there exists a $T$-proof of the\nsentence $\\forall x.\\sigma(x)\\equiv\\pi(x).$ \\emph{In this paper\n  $\\Delta^b_1$ will always mean provably in $S^1_2$.}  By Buss's\nWitnessing Theorem, the provability of the equivalence in $S^1_2$\nensures that $\\sigma(x)$ defines a set in~{\\bf P}.  We should stress\nthat it is essential that the proof is in $S^1_2$. The equivalence\n$\\vdash\\forall x.\\sigma(x)\\equiv\\pi(x)$ in general only ensures that\n$\\sigma(x)$ defines a set in ${\\bf NP\\cap coNP}$ which is believed to\nbe larger than {\\bf P}.\n\n\n\n(Again, this particular representation of predicates in {\\bf P} is not\nessential.) We will also need to represent binary relations computable in polynomial time. The definition of the corresponding $\\Delta^b_1$ formulas is the same, except that one uses two variables instead of one. Polynomial time computable functions will be formalized by $\\Delta^b_1$ formulas defining the graphs of these functions.\n\n\n\n\nWe will use \\emph{binary numerals}. A binary numeral is a suitably\nchosen closed term $\\bar n$ whose value is $n$ and whose length is\n$O(\\log n)$.  Our computation model is the standard Turing\nmachine, where the inputs are words in the alphabet $\\Sigma:=\\{0,1\\}$. When\ncomputing with numbers, we assume the binary representation. We will\nuse numbers instead of binary strings when we formalize computations.\nFor $n\\in\\N$, we denote by $|n|$ the length of the binary\nrepresentation of $n$. There is a symbol for this function in the\nlanguage of $S^1_2$.\n\n\n\n\\section{The basic paradigm -- finite consistency}\\label{sec3}\n\n\\subsection{Finite consistency}\n\nLet $T\\in\\cal T$. We will denote by $Con_T(x)$ a formula expressing (in\na natural way) the fact that there is no $T$-proof of contradiction of\nlength $x$. In particular, we will need $Con_T(\\bar n)$, for $n\\in\\N$. The question mentioned in the introduction is:\n\n\\begin{que}\nWhat is the length of the shortest $T$-proof of $Con_T(\\bar n)$?\n\\end{que}\n\nUsing the analogy with G\\\"odel's incompleteness theorem, it is\nnatural to conjecture that the proof must be long, specifically, not\npolynomial. Friedman also proved a lower bound $n^\\epsilon$ for some\n$\\epsilon>0$.\n\\footnote{Note that the length of the sentence  $Con_T(\\bar n)$ is $O(\\log n)$.}\n This lower bound was improved to $\\Omega(n/\\log^2 n)$\nfor a proof system with the rule \n", "index": 1, "text": "\n\\[\n\\frac{\\exists x.\\phi(x)}{\\phi(c)}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\frac{\\exists x.\\phi(x)}{\\phi(c)}\" display=\"block\"><mfrac><mrow><mrow><mo>\u2203</mo><mi>x</mi></mrow><mo>.</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>c</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $\\lceil\\phi\\rceil$ denotes the function that assigns the G\\\"odel number to formula  $\\phi$ and\n$Pr_T(u,\\lceil\\phi\\rceil)$ says that $u$ is a proof of $\\phi$ in\n$T$. The principle is true if $T$ is $\\Sigma_1$-sound, i.e., $T$ does not prove a false $\\Sigma_1$ sentence. The schema can be axiomatized by a single sentence using a partial truth definition for $\\Sigma_1$ formulas.\n\n\n\n\n\nIn order to get a meaningful finite version of  $\\Sigma_1 RFN_{T}$ we\nhave to make a couple of modifications. We start by defining a finite\n$\\Sigma_1^b$ reflection principle for one formula.\n\n\\begin{definition}\nLet $T$ be a theory, let $\\alpha(x)$ be a $\\Sigma^b_1$ formula and\nlet $n\\in\\N$. Then\n{$\\Sigma_1^bRfn_T^\\alpha(\\bar n)$} \nwill denote the sentence:\n", "itemtype": "equation", "pos": 22156, "prevtext": "\nwhere $c$ is a new constant~\\cite{pudlak87}. This rule enables one to\nrefer to an element satisfying $\\phi$ without having to mention\n$\\phi$. The same asymptotic bound is probably true for some other\nsystems where this rule can be simulated.  In particular, in natural\ndeduction systems, we can start with an assumption $\\phi(y)$ and argue\nabout $y$ without having to repeat the assumption in each proof line.\n\nThe idea of the proofs of these lower bounds is to adapt the original\nproof of G\\\"odel for the finite setting. Thus instead of the original\ndiagonal formula, one uses a formula $\\delta(\\bar n)$ with intended\nmeaning {\\it ``I do not have a $T$-proof of length $\\leq n$''}. One\ncan easily prove that $\\delta_T(\\bar n)$ is true and any proof of it\nmust be longer than $n$. Then one proves that $\\delta_T(\\bar n)$ can\nbe derived from $Con_T(\\bar n)$ by a short proof. This is essentially\nthe same as in the proof of G\\\"odel's theorem, except that one has to\nprove good \\emph{upper bounds} on the lengths of proofs of certain\ntrue sentences. The shorter proofs one is able to find, the larger the\nlower bound is.\n\nIn \\cite{pudlak86} a linear upper bound $O(n)$ was proved for sequential\ntheories.\n\\footnote{Sequential theories are, roughly speaking, theories in which one can code any finite sequence of elements of the universe. Already very weak fragments of arithmetic and set theory are known to be sequential.}\nThis bound is based on partial truth definitions. In the\nstandard proofs of the consistency of a theory $T$ (without any bound on\nthe lengths of proofs), one uses a truth definition for all\nformulas. Since in proofs of bounded length only formulas of bounded\ncomplexity can occur, it suffices to use a partial truth definition\nthat define truth only for sentences of limited complexity. The fact\nthat partial truth definition exist is well-known. However, to obtain such bounds\none has to carefully estimate the size of the formulas and the lengths\nof proofs of particular statements.\n\nIn spite of the linear upper bound, we still believe that the incompleteness\nphenomenon of G\\\"odel's theorem should manifest itself also in the\nfinite domain. We conjecture that if $T$ is stronger than a theory\n$S$, then $S$-proofs of $Con_T(\\bar n)$ cannot be\npolynomially bounded. Since it is not clear how much stronger $T$ must\nbe, we proposed the following conjecture in~\\cite{pudlak86}:\n\n\\begin{conjecture}{\\sf CON$^N$}\\label{CONN}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $Con_T(\\bar n)$ cannot be polynomially bounded.\n\\footnote{The superscript $N$ stands for ``nonuniform'' whose meaning will be explained in Section~\\ref{sec6}.}\n\\end{conjecture}\n\n\n\n\n\n\nOf course, we would also like to know how much stronger $T$ must be\nthan $S$ so that there are no polynomial size $S$-proofs of\n$Con_T(n)$. It has been conjectured that it suffices that $T$ proves\nthe consistency of $S$, i.e., the following seems to be true:\n\\begin{conjecture}{\\sf CON$^{N+}$}\n for every $S,T\\in\\cal T$, if $T$ proves $Con_S$, then\n  $S$-proofs of $Con_T(\\bar n)$ cannot be polynomially bounded.\n\\end{conjecture}\n\nIt is well-known~\\cite{ehrenfeucht-mycielski} that if $T$ is stronger (proves more\nsentences) than $S$, then some sentences provable in both theories\nhave much shorter proofs in $T$. This may suggest that it would\nsuffice to make $T$ just a little stronger than $S$ in order to ensure\nthat $S$-proofs of $Con_T(\\bar n)$ do not have polynomial\nproofs. However, recently Pavel Hrube\\v{s} proved, using a Rosser-type\nselfreferential sentence, that in general it is not so [personal communication].\nHis result is even stronger than the mere refutation of that statement.\n\n\\begin{theorem}\n  For every $S,T\\in\\cal T$, there exists a true $\\Pi_1$ sentence $\\pi$\n  such that $\\pi$ is not provable in $T$, yet the lengths of\n  $S$-proofs of $Con_{S+\\pi}(\\bar n)$ can be bounded by a polynomial.\n\\end{theorem}\nIn particular, if $S=T$, we get $\\pi\\in\\Pi_1$ unprovable in $S$ with polynomially bounded $S$-proofs of $Con_{S+\\pi}(\\bar n)$.\n\n\\subsection{A finite reflection principle}\n\nRecall that the sentences expressing consistency of a theory $T$ are\nspecial cases of \\emph{reflection\n  principles} (see~\\cite{smorynski77}). There are many versions of\nreflection principles. Here we will focus on the uniform\n$\\Sigma_1$-reflection principles.\n\n\n\nThe\n\\emph{uniform $\\Sigma_1$-reflection principle for $T$} is the\nfollowing schema for all $\\Sigma_1$ sentences $\\sigma(x)$ with one free variable $x$\n", "index": 3, "text": "\n\\[\n\\Sigma_1 RFN_{T}\\ :=\\ \\forall x\\forall u(Pr_T(u,\\lceil\\sigma(\\bar{x})\\rceil)\\to \\sigma(x)),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\Sigma_{1}RFN_{T}\\ :=\\ \\forall x\\forall u(Pr_{T}(u,\\lceil\\sigma(\\bar{x})\\rceil%&#10;)\\to\\sigma(x)),\" display=\"block\"><mrow><msub><mi mathvariant=\"normal\">\u03a3</mi><mn>1</mn></msub><mi>R</mi><mi>F</mi><mpadded width=\"+5pt\"><msub><mi>N</mi><mi>T</mi></msub></mpadded><mo rspace=\"7.5pt\">:=</mo><mo>\u2200</mo><mi>x</mi><mo>\u2200</mo><mi>u</mi><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><msub><mi>r</mi><mi>T</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mrow><mo stretchy=\"false\">\u2308</mo><mi>\u03c3</mi><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">\u00af</mo></mover><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">\u2309</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>\u03c3</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n\\end{definition}\n\n\nHaving defined the reflection principle for one formula, we can study\nthe schema, i.e., the set of sentences \n$\\Sigma_1^bRfn_T^\\alpha(\\bar n)$ for all $\\Sigma^b_1$ formulas, \nbut it is more interesting to have \na single sentence for every $n$ from which all instances are derivable by short proofs. \n\n\n\n\nTo this end we need a universal $\\Sigma^b_1$ formula. One can\nconstruct a formula $\\mu_1$ such that for every $\\Sigma^b_1$ formula\n$\\alpha(x)$ there exist a natural number $e$ and a polynomial $p$\nsuch that \n\\bel{e-univ} \n|z|\\geq p(|x|)\\to(\\alpha(x)\\ \\equiv\\ \\mu_1(\\bar e,x,z)) \n\\ee \nis provable in $S^1_2$ (see~\\cite{HP}). The sentences that we are going to define are essentially $\\Sigma_1^bRfn_T^{\\mu_1}(\\bar n)$.\n\n\n\\begin{definition}\nThe \\emph{finite uniform $\\Sigma^b_1$ principle} is the\nsequence of sentences $\\Sigma_1^bRFN_T(\\bar n)$, $n\\in\\N$, defined by\n", "itemtype": "equation", "pos": 23002, "prevtext": "\nwhere $\\lceil\\phi\\rceil$ denotes the function that assigns the G\\\"odel number to formula  $\\phi$ and\n$Pr_T(u,\\lceil\\phi\\rceil)$ says that $u$ is a proof of $\\phi$ in\n$T$. The principle is true if $T$ is $\\Sigma_1$-sound, i.e., $T$ does not prove a false $\\Sigma_1$ sentence. The schema can be axiomatized by a single sentence using a partial truth definition for $\\Sigma_1$ formulas.\n\n\n\n\n\nIn order to get a meaningful finite version of  $\\Sigma_1 RFN_{T}$ we\nhave to make a couple of modifications. We start by defining a finite\n$\\Sigma_1^b$ reflection principle for one formula.\n\n\\begin{definition}\nLet $T$ be a theory, let $\\alpha(x)$ be a $\\Sigma^b_1$ formula and\nlet $n\\in\\N$. Then\n{$\\Sigma_1^bRfn_T^\\alpha(\\bar n)$} \nwill denote the sentence:\n", "index": 5, "text": "\n\\[\n\\forall u,x, |u|\\leq \\bar{n},|x|\\leq \\bar{n} \n\\left(Pr_T(u,\\lceil\\alpha(\\bar{x})\\rceil)\n\\to \\alpha(x)\\right).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\forall u,x,|u|\\leq\\bar{n},|x|\\leq\\bar{n}\\left(Pr_{T}(u,\\lceil\\alpha(\\bar{x})%&#10;\\rceil)\\to\\alpha(x)\\right).\" display=\"block\"><mrow><mo>\u2200</mo><mi>u</mi><mo>,</mo><mi>x</mi><mo>,</mo><mo stretchy=\"false\">|</mo><mi>u</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">\u00af</mo></mover><mo>,</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">\u00af</mo></mover><mrow><mo>(</mo><mi>P</mi><msub><mi>r</mi><mi>T</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mrow><mo stretchy=\"false\">\u2308</mo><mi>\u03b1</mi><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">\u00af</mo></mover><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">\u2309</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>\u03b1</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n\\end{definition}\n\n\n\n\n\n\\bl\\label{l-3.2}\nFor every $\\Sigma^b_1$ formula $\\alpha(x)$, there exist polynomials $q$\nand $r$\nsuch that  $S^1_2$-proofs of the sentences\n", "itemtype": "equation", "pos": 24005, "prevtext": "\n\\end{definition}\n\n\nHaving defined the reflection principle for one formula, we can study\nthe schema, i.e., the set of sentences \n$\\Sigma_1^bRfn_T^\\alpha(\\bar n)$ for all $\\Sigma^b_1$ formulas, \nbut it is more interesting to have \na single sentence for every $n$ from which all instances are derivable by short proofs. \n\n\n\n\nTo this end we need a universal $\\Sigma^b_1$ formula. One can\nconstruct a formula $\\mu_1$ such that for every $\\Sigma^b_1$ formula\n$\\alpha(x)$ there exist a natural number $e$ and a polynomial $p$\nsuch that \n\\bel{e-univ} \n|z|\\geq p(|x|)\\to(\\alpha(x)\\ \\equiv\\ \\mu_1(\\bar e,x,z)) \n\\ee \nis provable in $S^1_2$ (see~\\cite{HP}). The sentences that we are going to define are essentially $\\Sigma_1^bRfn_T^{\\mu_1}(\\bar n)$.\n\n\n\\begin{definition}\nThe \\emph{finite uniform $\\Sigma^b_1$ principle} is the\nsequence of sentences $\\Sigma_1^bRFN_T(\\bar n)$, $n\\in\\N$, defined by\n", "index": 7, "text": "\n\\[\n\\forall e,u,x,z, |e|,|u|,|x|,|z|\\leq \\bar{n}\n\\left(Pr_T(u,\n\\lceil\\mu_1(\\bar{e},\\bar{x},\\bar{z})\\rceil) \n\\to \\mu_1(e,x,z)\\right).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\forall e,u,x,z,|e|,|u|,|x|,|z|\\leq\\bar{n}\\left(Pr_{T}(u,\\lceil\\mu_{1}(\\bar{e}%&#10;,\\bar{x},\\bar{z})\\rceil)\\to\\mu_{1}(e,x,z)\\right).\" display=\"block\"><mrow><mo>\u2200</mo><mi>e</mi><mo>,</mo><mi>u</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>,</mo><mo stretchy=\"false\">|</mo><mi>e</mi><mo stretchy=\"false\">|</mo><mo>,</mo><mo stretchy=\"false\">|</mo><mi>u</mi><mo stretchy=\"false\">|</mo><mo>,</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo>,</mo><mo stretchy=\"false\">|</mo><mi>z</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">\u00af</mo></mover><mrow><mo>(</mo><mi>P</mi><msub><mi>r</mi><mi>T</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mrow><mo stretchy=\"false\">\u2308</mo><msub><mi>\u03bc</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>e</mi><mo stretchy=\"false\">\u00af</mo></mover><mo>,</mo><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">\u00af</mo></mover><mo>,</mo><mover accent=\"true\"><mi>z</mi><mo stretchy=\"false\">\u00af</mo></mover><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">\u2309</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><msub><mi>\u03bc</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>e</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo>)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\ncan be constructed in time $r(|n|)$.  \n\\el \n\\bprf \n\nLet $e\\in\\N$ and $p$ be such that (\\ref{e-univ}) is provable in\n$S^1_2$. Let $n\\in\\N$ be such that $n\\geq|e|$ and let $m=p(n)$. The\nfollowing argument can be done in $S^1_2$.\n\\begin{quote}\nSuppose $|u|,|x|\\leq n$ and $Pr_T(u,\\lceil\\alpha(\\bar{x})\\rceil)$. Then we also have\n$|u|,|x|\\leq m$ and, since (\\ref{e-univ}) is provable in $T$, we have \n$Pr_T(u',\\lceil\\mu_1(\\bar{e},\\bar{x},\\overline{2^m})\\rceil)$ for\nsome $u'$. The proof $u'$ is constructed from $u$ using the proof of\n(\\ref{e-univ}) in $T$, which adds only a constant to the length and a small\npart in which this sentence is instantiated for the numerals $\\bar{x}$\nand $\\overline{2^m}$. This makes the proof $u'$ at most polynomially\nlonger than $m$. Let $m'$ be this polynomial bound. Applying \n$\\Sigma_1^bRFN_T(\\overline{m'})$, we get \n$\\mu_1(\\bar{e},\\bar{x},\\overline{2^m})$. Then\nusing (\\ref{e-univ}) in $S^1_2$, we finally get \n$\\alpha(\\bar{x})$.\n\\end{quote}\nNow we only need to observe that the above $S^1_2$ proof was\nexplicitly constructed and the number of steps and the size of the\nformulas involved are of length polynomial in $|n|$.\n\\eprf\n\n\n\n\\begin{corollary}\\label{l-rfn}\nLet $S,T\\in\\cal T$. Suppose that \n\\ben\n\\item $T\\vdash \\forall x.\\phi(x)$, where $\\phi\\in\\Sigma^b_1$, and \n\\item $S$-proofs of the sentences $\\Sigma_1^bRFN_T(\\bar n)$ can be\nconstructed in polynomial time. \n\\een\nThen $S$-proofs the sentences \n$\\phi(\\bar m)$ \ncan be constructed in time $r(|m|)$ for some polynomial~$r$.\n\\end{corollary}\n\n\n\n\n\n\\begin{proof}\n  Since $\\forall x.\\phi(x)$ is provable\n  in $T$, the sentences $\\phi(\\bar m)$ have\n  $T$-proofs of length bounded by $q(|m|)$ for some polynomial\n  $q$. This is provable in $S^1_2$, so also in $S$. According to the\n  assumption about $S$ and by Lemma~\\ref{l-3.2}, one can construct in\n  polynomial time proofs of $\\Sigma^b_1Rfn^\\phi_T(\\overline{q(|m|)}$ in\n  polynomial time in $|m|$. Thus we get $S$-proofs of $\\phi(\\bar m)$ in polynomial time.\n\\end{proof}\n\n\n\n\n\n\\bigskip\nUsing $\\Sigma_1^bRFN_T(\\bar n)$, we can state a conjecture similar to our\nconjecture about \n$Con_T(\\bar n)$. \n\n\\begin{conjecture}{\\sf RFN$^N_1$}\\label{RFNN}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that the\n  lengths of \n  $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ cannot be polynomially bounded.\n\\end{conjecture}\n\nWhen $\\alpha$ is $0=1$, then $\\Sigma_1^bRfn_T^\\alpha(\\bar n)$ is equivalent\n to $Con_T(\\bar n)$ with a polynomial size proof in a base theory. Thus\nthere exists a polynomial $p$ such that $\\Sigma_1^bRFN_T(\\overline{p(n)})$\nimplies $Con_T(\\bar n)$ with a polynomial size proof. \n\nConsequently, Conjecture~{\\sf CON$^N$} implies Conjecture~{\\sf RFN$^N_1$}. We will\nprove that Conjecture~{\\sf RFN$^N_1$} implies {\\bf NP$\\neq$\\bf coNP}.\n\n\\begin{proposition}\nIf {\\bf NP$=$\\bf coNP}, then there exists  $S\\in\\cal T$ such that for\nall $T\\in\\cal T$, the lengths of $S$-proofs of $\\Sigma_1^bRFN_T(\\bar\nn)$ can be bounded by a polynomial.\n\\end{proposition}\n\\begin{proof}\n  The basic idea is to take some base theory and add all\n  sentences of the form $\\Sigma_1^bRFN_T(\\bar n)$ that are true as axioms,\n  disregarding whether or not $T$ is consistent. \n\n  Let $T$ be any theory that satisfies all conditions for being in\n  $\\cal T$, except that it does not have to be consistent. There is a computable function that enumerates such theories.\n\\footnote{If the theory is given by an infinite set of axioms, it has\n  to be encoded by a polynomial time algorithm that decides if the\n  sentence is an axiom and the algorithm must be equipped with a clock\n  that ensures a polynomial time upper bound on the running\n  time. These complications can be avoided by focusing on finitely\n  axiomatized theories.}\n\nIf {\\bf NP$=$\\bf coNP}, then there exists a nondeterministic Turing\nmachine $M_T$ that accepts sentences $\\Sigma_1^bRFN_T(\\bar n)$ iff\nthey are true, and $M_T$ runs in time $p_T(n)$ for some polynomial\n$p_T$. In order to get one machine $M$ for all theories, we add\npadding to the sentences $\\Sigma_1^bRFN_T(\\bar n)$. Specifically, we\nconsider sentences of the form\n\n\\bel{e-rfn} \n\\Sigma_1^bRFN_T(\\bar n)\\vee(0=1\\wedge \\beta_{p_T(n)}), \n\\ee \n\nwhere $\\beta_{p_T(n)}$ is some formula of length $p_T(n)$, say a\nconjunction of sentences $0=1$. To define~$S$, we take those sentences\nof the form above for which $M$ verifies that they are true. Thus we\nget an {\\bf NP} axiomatization. Using additional padding (encoding\naccepting computations of $M$), we get a set of axioms decidable in\npolynomial time. This is our theory $S$. Clearly, every true instance\nof $\\Sigma_1^bRFN_T(\\bar n)$ has a polynomial size proof\nfrom~(\\ref{e-rfn}) in the predicate calculus, so it has a polynomial size\n$S$-proof too. For sentences where $T$ is consistent, i.e., $T\\in\\cal\nT$, the instances of the reflection principle are always true, so they\nhave polynomial size $S$-proofs.\n\\end{proof}\n\nThe reason for introducing the conjecture about  $\\Sigma_1^bRFN$  is that it\nenables us to connect diverging branches of so far postulated\nconjectures, as we will see shortly. One can certainly study similar statements based on stronger reflection principles for classes of formulas  $\\Sigma^b_2,\\Sigma^b_3,\\dots$. The strength of these principles decreases with increasing indexes, so they are not interesting if we are looking for stronger conjectures. However, the study of these principles may reveal further interesting connections.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{What is the finite G\\\"odel theorem?}\n\nWe finish this section with a remark concerning the question what\nshould be called the finite G\\\"odel theorem. If Conjecture~{\\sf CON$^N$}\nwere proven true, we would certainly advocate to call it the finite\nG\\\"odel theorem. However, one can also argue that the connection is\ndifferent. Note that if $T$ proves $Con_S$, then $T$-proofs of\n$Con_S(\\bar n)$ are very short; they are of logarithmic length, because\nthe length of $Con_S(\\bar n)$ is logarithmic (recall that we are using\nbinary numerals) and this sentence follows from $Con_S$ by\nsubstitution (if we formalize $Con_S$ as $\\forall x.Con_S(x)$). Using\nthis fact, we can derive G\\\"odel's theorem from Friedman's lower bound\n$n^\\epsilon$  on the lengths of $T$-proofs of $Con_T(\\bar n)$. So\nFriedman's lower bound can also be viewed as the finite G\\\"odel\ntheorem.\n\nProving G\\\"odel's theorem in this roundabout way is certainly not\nnatural, but in some cases it may be useful. Using estimates on finite\nconsistency statements, we proved~\\cite{pudlak90} that $S_2$ does not prove\nbounded consistency of apparently weaker theory $S^1_2$, which ruled\nout an approach to the separation problem of these two theories. (Bounded\nconsistency means that we only consider proofs in which all formulas\nare bounded.)\n\n\n\n\\section{Fast growing functions and hard search problems}\\label{sec4}\n\nAn important property of first-order theories studied in classical\nproof theory is their strength measured by the set of arithmetical\nsentences provable in them. Among the arithmetical sentences the most\nimportant role is played by $\\Pi_1$ and $\\Pi_2$ sentences. \n\n\n\n\n\n\n\n\n A proper $\\Pi_2$ sentence, a\nsentence that is not equivalent to a $\\Pi_1$ sentence, expresses the\nfact that some function is total. Specifically, $\\forall x\\exists\ny.\\phi(x,y)$, where $\\phi$ is a bounded formula, can be interpreted as saying  that there\nexists a computable function such that $\\forall x.\\phi(x,f(x))$. If we\ncannot write it equivalently using a formula $\\forall x.\\psi(x,y)$,\nwhere in $\\psi$ all quantifiers are bounded, then $f$ has to grow\nfaster than all functions defined by the terms of the\ntheory. Moreover, for pairs of natural theories $S$ and $T$ with $T$\nessentially stronger than $S$, there are provably total\ncomputable functions in $T$ that cannot be bounded by computable\nfunctions provably total in $S$. One can say that {\\it ``$T$ proves\n  the existence of larger numbers than $S$''.} This intuition can be\nmade more precise using cuts of nonstandard models of arithmetic in\nwhich the arithmetical theories of $S$ are $T$, are\nsatisfied: in general, $T$ requires longer cuts than $S$.\n\n\\medskip {\\bf Remark.} {\\small It is important to realize what ``provably\ntotal'' means. For a given theory and a computable function $f$, we can\nalways find a $\\Sigma_1$ definition for which the totality of $f$ is\nnot provable (e.g., given a defining formula $\\phi(x,y)$, we can\nextend it by adding the consistency of $T$, i.e.,  $\\phi(x,y)\\wedge\nCon_T(x)$). So when we say that $f$ is provably total, we mean\nthat $f$ is provably total \\emph{for some $\\Sigma_1$ definition of $f$}.}\n\n\n\\subsection{Total polynomial search problems}\\label{subsec4.1}\n\nWe are interested in the exponential domain, which means that we only\nconsider functions $f$ such that the length of $f(x)$ is bounded by\n$p(|x|)$ for some polynomial $p$, so it does not make sense to compare the\ngrowth rate of the functions. Instead, we study the complexity of these\nfunctions. The class of sentences corresponding to $\\Pi_2$ are\n$\\forall\\hat{\\Sigma}^b_1$ sentences---the sentences starting with unbounded\nuniversal quantifier followed by a $\\hat{\\Sigma}^b_1$ sentence. Essentially, this class consists of sentences of the form\n\n\\bel{e-total}\n\\forall x\\exists y, |y|\\leq p(|x|).\\phi(x,y),\n\\ee\nwhere $\\phi$ is a formalization of a polynomial time relation (i.e., $\\phi\\in\\Delta^b_1$) and $p$ is\nsome polynomial. There is a computational task naturally associated\nwith such sentences. Since this is important, we define it formally.\n\n\\begin{definition}\nA \\emph{total polynomial search problem} is given by a pair $(p,R)$,\nwhere $p$ is a polynomial and $R$ is a binary relation such that\n\\ben\n\\item $R$ is decidable in polynomial time,\n\\item $\\N\\models \\forall x\\exists y, |y|\\leq p(|x|).R(x,y)$.\n\\een\nThe computational task is, for a given $x$, find $y$ such that $|y|\\leq\np(|x|)\\wedge R(x,y)$.\n\\end{definition}\nThe class of all total polynomial search problems will be denoted by\n{\\bf TFNP}.\n\\footnote{The abbreviation {\\bf TFNP} is standard, but is\n  rather misleading; the class is not a class of functions and it is\n  not defined using {\\bf NP} relations. Therefore we used {\\bf TPS}\n  in~\\cite{kniha}.} \n Here are two examples of {\\bf TFNP} problems.\n\n\\medskip{\\bf Example 1.} This example is based on the Pigeon-Hole Principle, which says that there is no one-to-one mapping from an $N+1$-element set to an $N$-element set. The computational task associated with this principle is: given a mapping from an $N+1$-element set to an $N$-element set, find a ``collision'', which is a pair $x\\neq x'$ such that $f(x)=f(x')$. This problem is algorithmically trivial if the mapping is given as a list of pairs $(x,f(x))$. In this case $N$ is less than the input size. However, if the problem is presented so that $N$ is exponential in the input size, no polynomial time algorithm is known. Such a representation can be defined using Boolean circuits, or polynomial time algorithms that compute the function $f$. In fact, researchers in cryptography believe that the problem is hard even if the mapping is from $[N]$ to $[M]$ for $M$ much smaller than $N$. These \\emph{hash functions} are used in various protocols.\n\nA {\\bf TFNP} problem based on the Pigeon-Hole Principle can formally be defined as follows. Take a polynomial time computable function $f(r,x)$; think of $f$ as a set of polynomial time computable functions of one variable $x$ parametrized by $r$. Define a binary relation computable in polynomial time by\n", "itemtype": "equation", "pos": 24302, "prevtext": "\n\\end{definition}\n\n\n\n\n\n\\bl\\label{l-3.2}\nFor every $\\Sigma^b_1$ formula $\\alpha(x)$, there exist polynomials $q$\nand $r$\nsuch that  $S^1_2$-proofs of the sentences\n", "index": 9, "text": "\n\\[\n\\Sigma_1^bRFN_T(\\overline{q(n)})\\to\\Sigma_1^bRfn_T^\\alpha(\\bar n)\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\Sigma_{1}^{b}RFN_{T}(\\overline{q(n)})\\to\\Sigma_{1}^{b}Rfn_{T}^{\\alpha}(\\bar{n})\" display=\"block\"><mrow><mrow><msubsup><mi mathvariant=\"normal\">\u03a3</mi><mn>1</mn><mi>b</mi></msubsup><mo>\u2062</mo><mi>R</mi><mo>\u2062</mo><mi>F</mi><mo>\u2062</mo><msub><mi>N</mi><mi>T</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mrow><mi>q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u00af</mo></mover><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2192</mo><mrow><msubsup><mi mathvariant=\"normal\">\u03a3</mi><mn>1</mn><mi>b</mi></msubsup><mo>\u2062</mo><mi>R</mi><mo>\u2062</mo><mi>f</mi><mo>\u2062</mo><msubsup><mi>n</mi><mi>T</mi><mi>\u03b1</mi></msubsup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>n</mi><mo stretchy=\"false\">\u00af</mo></mover><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nIn this formula, $u$ is a witness of the fact that $f$ does not map $\\{0\\dts r\\}$ into $\\{0\\dts r-1\\}$ or a witness of a collision.\nA polynomial bound on $|u|$ is determined by  a polynomial bound on the lengths pairs of elements less than $r$.\n\n\\medskip{\\bf Example 2.} Our second example is based on the problem of factoring integers. Again the problem is nontrivial only if the number to be factored is presented in binary (decimal etc.) notation, in which case it is exponential in the input size. Since the search problem must have a solution for every number $N$, we have to distinguish the cases when $N$ is prime and when it is composite. It is well-known that this is decidable in polynomial time. Formally, we define a binary relation computable in polynomial time by\n", "itemtype": "equation", "pos": 35906, "prevtext": "\ncan be constructed in time $r(|n|)$.  \n\\el \n\\bprf \n\nLet $e\\in\\N$ and $p$ be such that (\\ref{e-univ}) is provable in\n$S^1_2$. Let $n\\in\\N$ be such that $n\\geq|e|$ and let $m=p(n)$. The\nfollowing argument can be done in $S^1_2$.\n\\begin{quote}\nSuppose $|u|,|x|\\leq n$ and $Pr_T(u,\\lceil\\alpha(\\bar{x})\\rceil)$. Then we also have\n$|u|,|x|\\leq m$ and, since (\\ref{e-univ}) is provable in $T$, we have \n$Pr_T(u',\\lceil\\mu_1(\\bar{e},\\bar{x},\\overline{2^m})\\rceil)$ for\nsome $u'$. The proof $u'$ is constructed from $u$ using the proof of\n(\\ref{e-univ}) in $T$, which adds only a constant to the length and a small\npart in which this sentence is instantiated for the numerals $\\bar{x}$\nand $\\overline{2^m}$. This makes the proof $u'$ at most polynomially\nlonger than $m$. Let $m'$ be this polynomial bound. Applying \n$\\Sigma_1^bRFN_T(\\overline{m'})$, we get \n$\\mu_1(\\bar{e},\\bar{x},\\overline{2^m})$. Then\nusing (\\ref{e-univ}) in $S^1_2$, we finally get \n$\\alpha(\\bar{x})$.\n\\end{quote}\nNow we only need to observe that the above $S^1_2$ proof was\nexplicitly constructed and the number of steps and the size of the\nformulas involved are of length polynomial in $|n|$.\n\\eprf\n\n\n\n\\begin{corollary}\\label{l-rfn}\nLet $S,T\\in\\cal T$. Suppose that \n\\ben\n\\item $T\\vdash \\forall x.\\phi(x)$, where $\\phi\\in\\Sigma^b_1$, and \n\\item $S$-proofs of the sentences $\\Sigma_1^bRFN_T(\\bar n)$ can be\nconstructed in polynomial time. \n\\een\nThen $S$-proofs the sentences \n$\\phi(\\bar m)$ \ncan be constructed in time $r(|m|)$ for some polynomial~$r$.\n\\end{corollary}\n\n\n\n\n\n\\begin{proof}\n  Since $\\forall x.\\phi(x)$ is provable\n  in $T$, the sentences $\\phi(\\bar m)$ have\n  $T$-proofs of length bounded by $q(|m|)$ for some polynomial\n  $q$. This is provable in $S^1_2$, so also in $S$. According to the\n  assumption about $S$ and by Lemma~\\ref{l-3.2}, one can construct in\n  polynomial time proofs of $\\Sigma^b_1Rfn^\\phi_T(\\overline{q(|m|)}$ in\n  polynomial time in $|m|$. Thus we get $S$-proofs of $\\phi(\\bar m)$ in polynomial time.\n\\end{proof}\n\n\n\n\n\n\\bigskip\nUsing $\\Sigma_1^bRFN_T(\\bar n)$, we can state a conjecture similar to our\nconjecture about \n$Con_T(\\bar n)$. \n\n\\begin{conjecture}{\\sf RFN$^N_1$}\\label{RFNN}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that the\n  lengths of \n  $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ cannot be polynomially bounded.\n\\end{conjecture}\n\nWhen $\\alpha$ is $0=1$, then $\\Sigma_1^bRfn_T^\\alpha(\\bar n)$ is equivalent\n to $Con_T(\\bar n)$ with a polynomial size proof in a base theory. Thus\nthere exists a polynomial $p$ such that $\\Sigma_1^bRFN_T(\\overline{p(n)})$\nimplies $Con_T(\\bar n)$ with a polynomial size proof. \n\nConsequently, Conjecture~{\\sf CON$^N$} implies Conjecture~{\\sf RFN$^N_1$}. We will\nprove that Conjecture~{\\sf RFN$^N_1$} implies {\\bf NP$\\neq$\\bf coNP}.\n\n\\begin{proposition}\nIf {\\bf NP$=$\\bf coNP}, then there exists  $S\\in\\cal T$ such that for\nall $T\\in\\cal T$, the lengths of $S$-proofs of $\\Sigma_1^bRFN_T(\\bar\nn)$ can be bounded by a polynomial.\n\\end{proposition}\n\\begin{proof}\n  The basic idea is to take some base theory and add all\n  sentences of the form $\\Sigma_1^bRFN_T(\\bar n)$ that are true as axioms,\n  disregarding whether or not $T$ is consistent. \n\n  Let $T$ be any theory that satisfies all conditions for being in\n  $\\cal T$, except that it does not have to be consistent. There is a computable function that enumerates such theories.\n\\footnote{If the theory is given by an infinite set of axioms, it has\n  to be encoded by a polynomial time algorithm that decides if the\n  sentence is an axiom and the algorithm must be equipped with a clock\n  that ensures a polynomial time upper bound on the running\n  time. These complications can be avoided by focusing on finitely\n  axiomatized theories.}\n\nIf {\\bf NP$=$\\bf coNP}, then there exists a nondeterministic Turing\nmachine $M_T$ that accepts sentences $\\Sigma_1^bRFN_T(\\bar n)$ iff\nthey are true, and $M_T$ runs in time $p_T(n)$ for some polynomial\n$p_T$. In order to get one machine $M$ for all theories, we add\npadding to the sentences $\\Sigma_1^bRFN_T(\\bar n)$. Specifically, we\nconsider sentences of the form\n\n\\bel{e-rfn} \n\\Sigma_1^bRFN_T(\\bar n)\\vee(0=1\\wedge \\beta_{p_T(n)}), \n\\ee \n\nwhere $\\beta_{p_T(n)}$ is some formula of length $p_T(n)$, say a\nconjunction of sentences $0=1$. To define~$S$, we take those sentences\nof the form above for which $M$ verifies that they are true. Thus we\nget an {\\bf NP} axiomatization. Using additional padding (encoding\naccepting computations of $M$), we get a set of axioms decidable in\npolynomial time. This is our theory $S$. Clearly, every true instance\nof $\\Sigma_1^bRFN_T(\\bar n)$ has a polynomial size proof\nfrom~(\\ref{e-rfn}) in the predicate calculus, so it has a polynomial size\n$S$-proof too. For sentences where $T$ is consistent, i.e., $T\\in\\cal\nT$, the instances of the reflection principle are always true, so they\nhave polynomial size $S$-proofs.\n\\end{proof}\n\nThe reason for introducing the conjecture about  $\\Sigma_1^bRFN$  is that it\nenables us to connect diverging branches of so far postulated\nconjectures, as we will see shortly. One can certainly study similar statements based on stronger reflection principles for classes of formulas  $\\Sigma^b_2,\\Sigma^b_3,\\dots$. The strength of these principles decreases with increasing indexes, so they are not interesting if we are looking for stronger conjectures. However, the study of these principles may reveal further interesting connections.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{What is the finite G\\\"odel theorem?}\n\nWe finish this section with a remark concerning the question what\nshould be called the finite G\\\"odel theorem. If Conjecture~{\\sf CON$^N$}\nwere proven true, we would certainly advocate to call it the finite\nG\\\"odel theorem. However, one can also argue that the connection is\ndifferent. Note that if $T$ proves $Con_S$, then $T$-proofs of\n$Con_S(\\bar n)$ are very short; they are of logarithmic length, because\nthe length of $Con_S(\\bar n)$ is logarithmic (recall that we are using\nbinary numerals) and this sentence follows from $Con_S$ by\nsubstitution (if we formalize $Con_S$ as $\\forall x.Con_S(x)$). Using\nthis fact, we can derive G\\\"odel's theorem from Friedman's lower bound\n$n^\\epsilon$  on the lengths of $T$-proofs of $Con_T(\\bar n)$. So\nFriedman's lower bound can also be viewed as the finite G\\\"odel\ntheorem.\n\nProving G\\\"odel's theorem in this roundabout way is certainly not\nnatural, but in some cases it may be useful. Using estimates on finite\nconsistency statements, we proved~\\cite{pudlak90} that $S_2$ does not prove\nbounded consistency of apparently weaker theory $S^1_2$, which ruled\nout an approach to the separation problem of these two theories. (Bounded\nconsistency means that we only consider proofs in which all formulas\nare bounded.)\n\n\n\n\\section{Fast growing functions and hard search problems}\\label{sec4}\n\nAn important property of first-order theories studied in classical\nproof theory is their strength measured by the set of arithmetical\nsentences provable in them. Among the arithmetical sentences the most\nimportant role is played by $\\Pi_1$ and $\\Pi_2$ sentences. \n\n\n\n\n\n\n\n\n A proper $\\Pi_2$ sentence, a\nsentence that is not equivalent to a $\\Pi_1$ sentence, expresses the\nfact that some function is total. Specifically, $\\forall x\\exists\ny.\\phi(x,y)$, where $\\phi$ is a bounded formula, can be interpreted as saying  that there\nexists a computable function such that $\\forall x.\\phi(x,f(x))$. If we\ncannot write it equivalently using a formula $\\forall x.\\psi(x,y)$,\nwhere in $\\psi$ all quantifiers are bounded, then $f$ has to grow\nfaster than all functions defined by the terms of the\ntheory. Moreover, for pairs of natural theories $S$ and $T$ with $T$\nessentially stronger than $S$, there are provably total\ncomputable functions in $T$ that cannot be bounded by computable\nfunctions provably total in $S$. One can say that {\\it ``$T$ proves\n  the existence of larger numbers than $S$''.} This intuition can be\nmade more precise using cuts of nonstandard models of arithmetic in\nwhich the arithmetical theories of $S$ are $T$, are\nsatisfied: in general, $T$ requires longer cuts than $S$.\n\n\\medskip {\\bf Remark.} {\\small It is important to realize what ``provably\ntotal'' means. For a given theory and a computable function $f$, we can\nalways find a $\\Sigma_1$ definition for which the totality of $f$ is\nnot provable (e.g., given a defining formula $\\phi(x,y)$, we can\nextend it by adding the consistency of $T$, i.e.,  $\\phi(x,y)\\wedge\nCon_T(x)$). So when we say that $f$ is provably total, we mean\nthat $f$ is provably total \\emph{for some $\\Sigma_1$ definition of $f$}.}\n\n\n\\subsection{Total polynomial search problems}\\label{subsec4.1}\n\nWe are interested in the exponential domain, which means that we only\nconsider functions $f$ such that the length of $f(x)$ is bounded by\n$p(|x|)$ for some polynomial $p$, so it does not make sense to compare the\ngrowth rate of the functions. Instead, we study the complexity of these\nfunctions. The class of sentences corresponding to $\\Pi_2$ are\n$\\forall\\hat{\\Sigma}^b_1$ sentences---the sentences starting with unbounded\nuniversal quantifier followed by a $\\hat{\\Sigma}^b_1$ sentence. Essentially, this class consists of sentences of the form\n\n\\bel{e-total}\n\\forall x\\exists y, |y|\\leq p(|x|).\\phi(x,y),\n\\ee\nwhere $\\phi$ is a formalization of a polynomial time relation (i.e., $\\phi\\in\\Delta^b_1$) and $p$ is\nsome polynomial. There is a computational task naturally associated\nwith such sentences. Since this is important, we define it formally.\n\n\\begin{definition}\nA \\emph{total polynomial search problem} is given by a pair $(p,R)$,\nwhere $p$ is a polynomial and $R$ is a binary relation such that\n\\ben\n\\item $R$ is decidable in polynomial time,\n\\item $\\N\\models \\forall x\\exists y, |y|\\leq p(|x|).R(x,y)$.\n\\een\nThe computational task is, for a given $x$, find $y$ such that $|y|\\leq\np(|x|)\\wedge R(x,y)$.\n\\end{definition}\nThe class of all total polynomial search problems will be denoted by\n{\\bf TFNP}.\n\\footnote{The abbreviation {\\bf TFNP} is standard, but is\n  rather misleading; the class is not a class of functions and it is\n  not defined using {\\bf NP} relations. Therefore we used {\\bf TPS}\n  in~\\cite{kniha}.} \n Here are two examples of {\\bf TFNP} problems.\n\n\\medskip{\\bf Example 1.} This example is based on the Pigeon-Hole Principle, which says that there is no one-to-one mapping from an $N+1$-element set to an $N$-element set. The computational task associated with this principle is: given a mapping from an $N+1$-element set to an $N$-element set, find a ``collision'', which is a pair $x\\neq x'$ such that $f(x)=f(x')$. This problem is algorithmically trivial if the mapping is given as a list of pairs $(x,f(x))$. In this case $N$ is less than the input size. However, if the problem is presented so that $N$ is exponential in the input size, no polynomial time algorithm is known. Such a representation can be defined using Boolean circuits, or polynomial time algorithms that compute the function $f$. In fact, researchers in cryptography believe that the problem is hard even if the mapping is from $[N]$ to $[M]$ for $M$ much smaller than $N$. These \\emph{hash functions} are used in various protocols.\n\nA {\\bf TFNP} problem based on the Pigeon-Hole Principle can formally be defined as follows. Take a polynomial time computable function $f(r,x)$; think of $f$ as a set of polynomial time computable functions of one variable $x$ parametrized by $r$. Define a binary relation computable in polynomial time by\n", "index": 11, "text": "\n\\[\nR(r,u):\\equiv\\ (u\\leq r\\wedge f(r,u)\\geq r)\\ \\vee\\ \\exists x,x'<r (u=(x,x')\\wedge f(r,x)=f(r,x')).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"R(r,u):\\equiv\\ (u\\leq r\\wedge f(r,u)\\geq r)\\ \\vee\\ \\exists x,x^{\\prime}&lt;r(u=(x%&#10;,x^{\\prime})\\wedge f(r,x)=f(r,x^{\\prime})).\" display=\"block\"><mrow><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><mo>:</mo><mo rspace=\"7.5pt\">\u2261</mo><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>\u2264</mo><mi>r</mi><mo>\u2227</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2265</mo><mi>r</mi><mo rspace=\"7.5pt\" stretchy=\"false\">)</mo></mrow><mo rspace=\"7.5pt\">\u2228</mo><mo>\u2203</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo>&lt;</mo><mi>r</mi><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nThe bound on $M$ is simply $|M|\\leq |N|$. A solution is any number if $N$ is prime, or a proper factor if $N$ is composite.\n\n\\medskip\nHaving the concept of a total polynomial search problem, we can now replace the \\emph{growth rate} of\nfunctions by the \\emph{computational complexity} of finding solutions. Not surprisingly, the situation\nis much less clear than in the classical setting. Firstly, we can only\nhypothesize about the computational complexity of specific search\nproblems. But this is what we expected and are ready to face.\nSecondly, we do not have a quantitative measure of complexity that we\ncould apply to this kind of computational problems. We can distinguish\nproblems for which the task is solvable in polynomial time from those\nfor which it isn't, but some evidence suggests that there are also\ndistinct classes of problems that are not solvable in polynomial time\nand have different complexity. To compare the complexity of different\nproblems, we use reductions. Polynomial reductions are known for sets\nand used, in particular, in the theory of {\\bf NP} completeness. For\n{\\bf TFNP} there is also a natural concept of polynomial\nreduction. (Note that {\\bf TFNP} is not a class of sets, so we do need\na different concept.)\n\n\\begin{definition}[\\cite{jpy}]\\label{d-5}\nLet $R$ and $S$ be total polynomial search problems. We say\nthat $R$ is \\emph{polynomially reducible} to $S$ if $R$ can be solved in\npolynomial time using an oracle that gives solutions to $S$. We say\nthat $R$ and $S$ are \\emph{polynomially equivalent} if there are polynomial\nreductions in both ways. We say that $R$ is \\emph{many-one polynomially\n  reducible} to $S$, if it is polynomially reducible using one query\nto the oracle for~$S$. \n\\end{definition}\nMany-one polynomial readability can be equivalently defined by the\ncondition: {\\it there are functions $f$ and $g$ computable in polynomial\ntime such that for all $x$ and $z$,}\n", "itemtype": "equation", "pos": 36789, "prevtext": "\nIn this formula, $u$ is a witness of the fact that $f$ does not map $\\{0\\dts r\\}$ into $\\{0\\dts r-1\\}$ or a witness of a collision.\nA polynomial bound on $|u|$ is determined by  a polynomial bound on the lengths pairs of elements less than $r$.\n\n\\medskip{\\bf Example 2.} Our second example is based on the problem of factoring integers. Again the problem is nontrivial only if the number to be factored is presented in binary (decimal etc.) notation, in which case it is exponential in the input size. Since the search problem must have a solution for every number $N$, we have to distinguish the cases when $N$ is prime and when it is composite. It is well-known that this is decidable in polynomial time. Formally, we define a binary relation computable in polynomial time by\n", "index": 13, "text": "\n\\[\nQ(N,M):\\equiv\\ N\\mbox{ is prime }\\vee\\ (1<M<N\\wedge M\\mbox{ divides }N).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"Q(N,M):\\equiv\\ N\\mbox{ is prime }\\vee\\ (1&lt;M&lt;N\\wedge M\\mbox{ divides }N).\" display=\"block\"><mrow><mi>Q</mi><mrow><mo stretchy=\"false\">(</mo><mi>N</mi><mo>,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><mo>:</mo><mo rspace=\"7.5pt\">\u2261</mo><mi>N</mi><mtext>\u00a0is prime\u00a0</mtext><mo rspace=\"7.5pt\">\u2228</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>&lt;</mo><mi>M</mi><mo>&lt;</mo><mi>N</mi><mo>\u2227</mo><mi>M</mi><mtext>\u00a0divides\u00a0</mtext><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwere we are assuming that polynomial bounds on the lengths of numbers\ninvolved are implicit in the relations $R$ and $S$.\n\nReductions enable us to study the structure of {\\bf TFNP} and define subclasses. We are interested in classes that are closed under polynomial reductions. One important class is {\\bf PHP}, the class of all {\\bf TFNP} problems reducible to an instance of the Pigeon-Hole Problem as described in Example~1 above. Several other classes were defined already in the seminal paper~\\cite{jpy}. They enable one to show that a problem is probably not solvable in polynomial time. Specifically, if one proves that a problem is complete in one of the well-known classes, it implies that the problem is not solvable in polynomial time unless the class collapses to the bottom class consisting of all problems solvable in polynomial time. \n\nFrom the point of view of computational complexity, it is natural to\nidentify polynomially equivalent problems. However, we should bear in\nmind that from the point of view of a particular theory, two\ndefinition of the same problem may behave differently, as we noted\nabove. We will consider definitions of {\\bf TFNP} by $\\Delta^b_1$\nformulas and for a given theory we will take ``the best possible\ndefinition''. Formally, this is defined as follows.\n\n\\begin{definition}\n\\ben\n\n\n\n\n\\item A $\\Delta^b_1$ \\emph{definition of a {\\bf TFNP} problem} $(p,R)$ is a\n  pair $(q,\\phi)$ where $q$ is a polynomial and $\\phi$ is a \n  $\\Delta^b_1$ formula such that \n", "itemtype": "equation", "pos": 38792, "prevtext": "\nThe bound on $M$ is simply $|M|\\leq |N|$. A solution is any number if $N$ is prime, or a proper factor if $N$ is composite.\n\n\\medskip\nHaving the concept of a total polynomial search problem, we can now replace the \\emph{growth rate} of\nfunctions by the \\emph{computational complexity} of finding solutions. Not surprisingly, the situation\nis much less clear than in the classical setting. Firstly, we can only\nhypothesize about the computational complexity of specific search\nproblems. But this is what we expected and are ready to face.\nSecondly, we do not have a quantitative measure of complexity that we\ncould apply to this kind of computational problems. We can distinguish\nproblems for which the task is solvable in polynomial time from those\nfor which it isn't, but some evidence suggests that there are also\ndistinct classes of problems that are not solvable in polynomial time\nand have different complexity. To compare the complexity of different\nproblems, we use reductions. Polynomial reductions are known for sets\nand used, in particular, in the theory of {\\bf NP} completeness. For\n{\\bf TFNP} there is also a natural concept of polynomial\nreduction. (Note that {\\bf TFNP} is not a class of sets, so we do need\na different concept.)\n\n\\begin{definition}[\\cite{jpy}]\\label{d-5}\nLet $R$ and $S$ be total polynomial search problems. We say\nthat $R$ is \\emph{polynomially reducible} to $S$ if $R$ can be solved in\npolynomial time using an oracle that gives solutions to $S$. We say\nthat $R$ and $S$ are \\emph{polynomially equivalent} if there are polynomial\nreductions in both ways. We say that $R$ is \\emph{many-one polynomially\n  reducible} to $S$, if it is polynomially reducible using one query\nto the oracle for~$S$. \n\\end{definition}\nMany-one polynomial readability can be equivalently defined by the\ncondition: {\\it there are functions $f$ and $g$ computable in polynomial\ntime such that for all $x$ and $z$,}\n", "index": 15, "text": "\n\\[\nS(f(x),z)\\ \\Rightarrow\\ R(x,g(x,z)),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"S(f(x),z)\\ \\Rightarrow\\ R(x,g(x,z)),\" display=\"block\"><mrow><mrow><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>z</mi><mo rspace=\"7.5pt\" stretchy=\"false\">)</mo></mrow></mrow><mo rspace=\"7.5pt\">\u21d2</mo><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n\\item We say that $(p,P)\\in${\\bf TFNP} is \\emph{provably total in a theory\n  $T$}, if for some $\\Delta^b_1$ definition $(q,\\phi)$ of $(p,P)$, $T$ proves\nthat \n", "itemtype": "equation", "pos": 40336, "prevtext": "\nwere we are assuming that polynomial bounds on the lengths of numbers\ninvolved are implicit in the relations $R$ and $S$.\n\nReductions enable us to study the structure of {\\bf TFNP} and define subclasses. We are interested in classes that are closed under polynomial reductions. One important class is {\\bf PHP}, the class of all {\\bf TFNP} problems reducible to an instance of the Pigeon-Hole Problem as described in Example~1 above. Several other classes were defined already in the seminal paper~\\cite{jpy}. They enable one to show that a problem is probably not solvable in polynomial time. Specifically, if one proves that a problem is complete in one of the well-known classes, it implies that the problem is not solvable in polynomial time unless the class collapses to the bottom class consisting of all problems solvable in polynomial time. \n\nFrom the point of view of computational complexity, it is natural to\nidentify polynomially equivalent problems. However, we should bear in\nmind that from the point of view of a particular theory, two\ndefinition of the same problem may behave differently, as we noted\nabove. We will consider definitions of {\\bf TFNP} by $\\Delta^b_1$\nformulas and for a given theory we will take ``the best possible\ndefinition''. Formally, this is defined as follows.\n\n\\begin{definition}\n\\ben\n\n\n\n\n\\item A $\\Delta^b_1$ \\emph{definition of a {\\bf TFNP} problem} $(p,R)$ is a\n  pair $(q,\\phi)$ where $q$ is a polynomial and $\\phi$ is a \n  $\\Delta^b_1$ formula such that \n", "index": 17, "text": "\n\\[\n\\N\\models \\forall x,y((|y|\\leq p(|x|)\\wedge R(x,y))\\equiv\n(|y|\\leq q(|x|)\\wedge \\phi(x,y))).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\N\\models\\forall x,y((|y|\\leq p(|x|)\\wedge R(x,y))\\equiv(|y|\\leq q(|x|)\\wedge%&#10;\\phi(x,y))).\" display=\"block\"><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\N</mtext></merror><mo>\u22a7</mo><mo>\u2200</mo><mi>x</mi><mo>,</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>y</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>y</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mi>q</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mi>\u03d5</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n\\item The set of all $(p,P)\\in${\\bf TFNP} provably total in $T$ will be denoted\nby {\\bf TFNP}$(T)$.\nThe set of all $P\\in${\\bf TFNP} polynomially reducible to some\n$Q\\in${\\bf TFNP}$(T)$ will be denoted by ${\\bf TFNP^*}(T)$.\n\\een\n\\end{definition}\nNote that according to our definition of the class $\\Delta^b_1$, the\nformula $\\Phi$ must be a $\\Sigma^p_1$ formula equivalent to a\n$\\Pi^b_1$ \\emph{provably in $S^1_2$} (to ensure that it defines a set\nin {\\bf P} it does not suffice to have a proof in $T$). On the other hand, we do \\emph{not} require that a problem $P$ in ${\\bf TFNP^*}(T)$ is \\emph{provably} reducible to  some  $Q\\in${\\bf TFNP}$(T)$. \nThe difference\nbetween {\\bf TFNP}$(T)$ and ${\\bf TFNP^*}(T)$ is small; in fact, if we\ndefined {\\bf TFNP} using {\\bf NP} relations (see {\\bf TFNP}$^{\\bf NP}$ below), these classes would be the same.\n\n\nTo characterize low complexity theorems of fragments of arithmetic is\nan important problem studied in proof complexity is. In particular, we\nare interested in sentences that are universal closures of\n$\\Sigma^b_1$ formulas. Naturally, we want to identify sentences that express the same fact. The best way to do that is to focus on provably total polynomial search problems. Provably total\npolynomial search problems of all fragments of bounded arithmetic $S^i_2$,\n$i=1,2,\\dots,$  have been characterized using combinatorial\nprinciples~\\cite{skelley-thapen,BB10,pudlak-thapen}. For $S^1_2$ they are all {\\bf TFNP} problems that are solvable in polynomial time (the lowest class in  {\\bf TFNP}). The class of provably total problems of $S^2_2$ turned out to be surprisingly the class \\emph{Polynomial Local Search}, a class that had been introduced in~\\cite{jpy}. \n\nHere is another important conjecture.\n\n\\begin{conjecture}{\\sf TFNP}\\label{TFNP}\nFor every theory $T\\in\\cal T$ there exists a {\\bf TFNP} problem $P$\nthat is not polynomially reducible to any {\\bf TFNP} problem provably total\nin $T$. Stated in symbols  ${\\bf TFNP^*}(T)\\neq{\\bf TFNP}$.\n\\footnote{We distinguish the complexity class {\\bf TFNP} and the conjecture about it {\\sf TFNP} by different fonts.}\n\\end{conjecture}\n\nIn plain words the conjecture says that, for every theory $T\\in\\cal T$, there exists a total polynomial search problem $(p,R)$ such that $T$ cannot prove that the problem is total for any proper definition (definition by a $\\Delta^b_1$ formula) of $(p,R)$. This means that the unprovability in $T$ is not caused by a particular way we define the problem, but by a semantic property of it that we imagine as high computational complexity.\n\nLet us compare this conjecture with the corresponding statement about\nfast growing recursive functions. One can easily prove by\ndiagonalization that for every $T\\in\\cal T$, there exists a computable\nfunction $f$ which grows faster than any computable function provably\ntotal in $T$. This means that for any computable function $g$ provably\ntotal in $T$, there exists an $n_0$ such that $f(n)>g(n)$ for all\n$n\\geq n_0$. Thus for any formalization of $f$ by a $\\Sigma_1$ formula\n$T$ cannot prove that $f$ is total.  In the above conjecture, the\ncondition that $f$ cannot be bounded by provably total functions is\nreplaced by the condition that a {\\bf TFNP} problem is not\npolynomially reducible to {\\bf TFNP} problems that are provably total in $T$.\n\n\n\n\n\nAll conjectures in this area can be stated in purely complexity theoretical\nterms. The above conjecture has an especially simple equivalent form, which\nwe state now.\n\n\\begin{conjecture}{equivalent to {\\sf TFNP}}\nThere is no complete problem in {\\bf TFNP}, i.e., there exist no\n{\\bf TFNP} problem to which all {\\bf TFNP}\nproblems can be reduced.\n\\end{conjecture}\n\nThe proof of the equivalence of the versions is easy. To prove that the first version implies the second, suppose the second is false. Let $P$ be a complete\nproblem in {\\bf TFNP}. Then take a fragment of arithmetic and add the\naxiom that (a formalization of)  $P$ is total. \n\nThe converse\nimplication follows immediately from the following fact.\n\n\\begin{lemma}\\label{l-4.1}\nFor every $T\\in\\cal T$, there exists a {\\bf TFNP} problem $(p,P)$ such that all {\\bf\n  TFNP} problems provably total in $T$ are many-one polynomially reducible to $(p,P)$.\n\\end{lemma}\n\n\\begin{proof}\nThe proof is based on a standard diagonal technique. We\ninclude a proof here, because it demonstrates a method that can be\napplied in other similar situations (in particular, we will use it in Proposition~\\ref{pr-6.2}).\n\nThe basic idea is to connect all provably total problems into one. We\ncan recognize a definition of a provably total problem by finding a\nproof of the totality for this definition. A minor complication is\nthat different provably total problems may require different\npolynomials as bounds on the witnesses and bounds in the $\\Delta^b_1$\nformulas. This can easily be solved by suitable padding.\n\nNow we present the argument in more detail. Recall that from the point of view of provability in a theory, it does not matter if we use $\\Delta^b_1$ formulas or, more generally, $\\Sigma^b_1$ in the definition of the problems. So, for the sake of simplicity, we will diagonalize over $\\Sigma^b_1$ formulas. \n\nGiven a $\\Sigma^b_1$\nformula $\\psi(x)$, we say that $r(n)$ is a\nsyntactic nondeterministic time bound for $\\psi$ if the bounds at quantifiers in the formula ensure that $\\psi(x)$ is decidable by a nondeterministic Turing machine in\ntime $r(n)$ where $n$ is the length of $x$. Since $\\psi$ is a\n$\\Sigma^b_1$ formula, there always exists a polynomial $r$ that is such a bound\nfor $\\psi$.\n\nLet $T\\in\\cal T$ be given. We define a binary relation $R(u,v)$ by\nthe following condition:\n\\bi\n\\item if $u=(x',\\phi,q,d,a)$ is a quintuple such that $\\phi$ is a $\\Sigma^b_1$ formula, $q$\n  is a polynomial, $d$ is\n  $|T|$-proof of $\\forall x\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$\n  and $|a|=r(|x'|)$, where $r$ is a syntactic nondeterministic time bound for\n  $\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$, then $\\phi(x',v)$.\n\\ei\n\nThe relation $R$ is computable in nondeterministic polynomial time, because the\ncondition on  $(x',\\phi,q,d,a)$ is a simple syntactical condition and\nif the condition is satisfied,  $\\phi(x',v)$ can be computed in\nnondeterministic polynomial time bounded by $|a|$. Further, for every\n$u$ there exists some $v$, $|v|\\leq|u|$ such that $R(u,v)$ holds true,\nbecause if the condition on  $(x',\\phi,q,d,a)$ is satisfied, then for\nevery $x'$ there exists $v$, $|v|\\leq|a|$ that satisfies\n$\\phi(x',v)$, and if the condition is not satisfied, then one can take\n$v=0$.\n\nThe fact that we only know that $R$ is computable in\n\\emph{nondeterministic} polynomial time is not a problem. Clearly,\nthere exists a ternary relation $P'$ computable in polynomial time and\na polynomial $p'$\nsuch that \n", "itemtype": "equation", "pos": 40594, "prevtext": "\n\\item We say that $(p,P)\\in${\\bf TFNP} is \\emph{provably total in a theory\n  $T$}, if for some $\\Delta^b_1$ definition $(q,\\phi)$ of $(p,P)$, $T$ proves\nthat \n", "index": 19, "text": "\n\\[\n\\forall x\\exists y, |y|\\leq q(|x|).\\phi(x,y),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\forall x\\exists y,|y|\\leq q(|x|).\\phi(x,y),\" display=\"block\"><mrow><mrow><mrow><mrow><mrow><mo>\u2200</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo>\u2203</mo><mi>y</mi></mrow></mrow></mrow><mo>,</mo><mrow><mo stretchy=\"false\">|</mo><mi>y</mi><mo stretchy=\"false\">|</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nSo we define \n", "itemtype": "equation", "pos": 47428, "prevtext": "\n\\item The set of all $(p,P)\\in${\\bf TFNP} provably total in $T$ will be denoted\nby {\\bf TFNP}$(T)$.\nThe set of all $P\\in${\\bf TFNP} polynomially reducible to some\n$Q\\in${\\bf TFNP}$(T)$ will be denoted by ${\\bf TFNP^*}(T)$.\n\\een\n\\end{definition}\nNote that according to our definition of the class $\\Delta^b_1$, the\nformula $\\Phi$ must be a $\\Sigma^p_1$ formula equivalent to a\n$\\Pi^b_1$ \\emph{provably in $S^1_2$} (to ensure that it defines a set\nin {\\bf P} it does not suffice to have a proof in $T$). On the other hand, we do \\emph{not} require that a problem $P$ in ${\\bf TFNP^*}(T)$ is \\emph{provably} reducible to  some  $Q\\in${\\bf TFNP}$(T)$. \nThe difference\nbetween {\\bf TFNP}$(T)$ and ${\\bf TFNP^*}(T)$ is small; in fact, if we\ndefined {\\bf TFNP} using {\\bf NP} relations (see {\\bf TFNP}$^{\\bf NP}$ below), these classes would be the same.\n\n\nTo characterize low complexity theorems of fragments of arithmetic is\nan important problem studied in proof complexity is. In particular, we\nare interested in sentences that are universal closures of\n$\\Sigma^b_1$ formulas. Naturally, we want to identify sentences that express the same fact. The best way to do that is to focus on provably total polynomial search problems. Provably total\npolynomial search problems of all fragments of bounded arithmetic $S^i_2$,\n$i=1,2,\\dots,$  have been characterized using combinatorial\nprinciples~\\cite{skelley-thapen,BB10,pudlak-thapen}. For $S^1_2$ they are all {\\bf TFNP} problems that are solvable in polynomial time (the lowest class in  {\\bf TFNP}). The class of provably total problems of $S^2_2$ turned out to be surprisingly the class \\emph{Polynomial Local Search}, a class that had been introduced in~\\cite{jpy}. \n\nHere is another important conjecture.\n\n\\begin{conjecture}{\\sf TFNP}\\label{TFNP}\nFor every theory $T\\in\\cal T$ there exists a {\\bf TFNP} problem $P$\nthat is not polynomially reducible to any {\\bf TFNP} problem provably total\nin $T$. Stated in symbols  ${\\bf TFNP^*}(T)\\neq{\\bf TFNP}$.\n\\footnote{We distinguish the complexity class {\\bf TFNP} and the conjecture about it {\\sf TFNP} by different fonts.}\n\\end{conjecture}\n\nIn plain words the conjecture says that, for every theory $T\\in\\cal T$, there exists a total polynomial search problem $(p,R)$ such that $T$ cannot prove that the problem is total for any proper definition (definition by a $\\Delta^b_1$ formula) of $(p,R)$. This means that the unprovability in $T$ is not caused by a particular way we define the problem, but by a semantic property of it that we imagine as high computational complexity.\n\nLet us compare this conjecture with the corresponding statement about\nfast growing recursive functions. One can easily prove by\ndiagonalization that for every $T\\in\\cal T$, there exists a computable\nfunction $f$ which grows faster than any computable function provably\ntotal in $T$. This means that for any computable function $g$ provably\ntotal in $T$, there exists an $n_0$ such that $f(n)>g(n)$ for all\n$n\\geq n_0$. Thus for any formalization of $f$ by a $\\Sigma_1$ formula\n$T$ cannot prove that $f$ is total.  In the above conjecture, the\ncondition that $f$ cannot be bounded by provably total functions is\nreplaced by the condition that a {\\bf TFNP} problem is not\npolynomially reducible to {\\bf TFNP} problems that are provably total in $T$.\n\n\n\n\n\nAll conjectures in this area can be stated in purely complexity theoretical\nterms. The above conjecture has an especially simple equivalent form, which\nwe state now.\n\n\\begin{conjecture}{equivalent to {\\sf TFNP}}\nThere is no complete problem in {\\bf TFNP}, i.e., there exist no\n{\\bf TFNP} problem to which all {\\bf TFNP}\nproblems can be reduced.\n\\end{conjecture}\n\nThe proof of the equivalence of the versions is easy. To prove that the first version implies the second, suppose the second is false. Let $P$ be a complete\nproblem in {\\bf TFNP}. Then take a fragment of arithmetic and add the\naxiom that (a formalization of)  $P$ is total. \n\nThe converse\nimplication follows immediately from the following fact.\n\n\\begin{lemma}\\label{l-4.1}\nFor every $T\\in\\cal T$, there exists a {\\bf TFNP} problem $(p,P)$ such that all {\\bf\n  TFNP} problems provably total in $T$ are many-one polynomially reducible to $(p,P)$.\n\\end{lemma}\n\n\\begin{proof}\nThe proof is based on a standard diagonal technique. We\ninclude a proof here, because it demonstrates a method that can be\napplied in other similar situations (in particular, we will use it in Proposition~\\ref{pr-6.2}).\n\nThe basic idea is to connect all provably total problems into one. We\ncan recognize a definition of a provably total problem by finding a\nproof of the totality for this definition. A minor complication is\nthat different provably total problems may require different\npolynomials as bounds on the witnesses and bounds in the $\\Delta^b_1$\nformulas. This can easily be solved by suitable padding.\n\nNow we present the argument in more detail. Recall that from the point of view of provability in a theory, it does not matter if we use $\\Delta^b_1$ formulas or, more generally, $\\Sigma^b_1$ in the definition of the problems. So, for the sake of simplicity, we will diagonalize over $\\Sigma^b_1$ formulas. \n\nGiven a $\\Sigma^b_1$\nformula $\\psi(x)$, we say that $r(n)$ is a\nsyntactic nondeterministic time bound for $\\psi$ if the bounds at quantifiers in the formula ensure that $\\psi(x)$ is decidable by a nondeterministic Turing machine in\ntime $r(n)$ where $n$ is the length of $x$. Since $\\psi$ is a\n$\\Sigma^b_1$ formula, there always exists a polynomial $r$ that is such a bound\nfor $\\psi$.\n\nLet $T\\in\\cal T$ be given. We define a binary relation $R(u,v)$ by\nthe following condition:\n\\bi\n\\item if $u=(x',\\phi,q,d,a)$ is a quintuple such that $\\phi$ is a $\\Sigma^b_1$ formula, $q$\n  is a polynomial, $d$ is\n  $|T|$-proof of $\\forall x\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$\n  and $|a|=r(|x'|)$, where $r$ is a syntactic nondeterministic time bound for\n  $\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$, then $\\phi(x',v)$.\n\\ei\n\nThe relation $R$ is computable in nondeterministic polynomial time, because the\ncondition on  $(x',\\phi,q,d,a)$ is a simple syntactical condition and\nif the condition is satisfied,  $\\phi(x',v)$ can be computed in\nnondeterministic polynomial time bounded by $|a|$. Further, for every\n$u$ there exists some $v$, $|v|\\leq|u|$ such that $R(u,v)$ holds true,\nbecause if the condition on  $(x',\\phi,q,d,a)$ is satisfied, then for\nevery $x'$ there exists $v$, $|v|\\leq|a|$ that satisfies\n$\\phi(x',v)$, and if the condition is not satisfied, then one can take\n$v=0$.\n\nThe fact that we only know that $R$ is computable in\n\\emph{nondeterministic} polynomial time is not a problem. Clearly,\nthere exists a ternary relation $P'$ computable in polynomial time and\na polynomial $p'$\nsuch that \n", "index": 21, "text": "\n\\[\nR(u,v)\\equiv \\exists w(|w|\\leq p(|u|,|v|)\\wedge P'(u,v,w)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"R(u,v)\\equiv\\exists w(|w|\\leq p(|u|,|v|)\\wedge P^{\\prime}(u,v,w)).\" display=\"block\"><mrow><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2261</mo><mo>\u2203</mo><mi>w</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>w</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>u</mi><mo stretchy=\"false\">|</mo><mo>,</mo><mo stretchy=\"false\">|</mo><mi>v</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><msup><mi>P</mi><mo>\u2032</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n\nLet a  {\\bf TFNP} problem $(q,Q)$ be given and suppose that it\nis provably total in $T$. We have a \n$\\Sigma^b_1$ formula $\\phi$ and a polynomial $q$ that defines the\nproblem and a $T$-proof of totality $d$ for this\nrepresentation. Also we have a nondeterministic polynomial time bound $r$\nfor $\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$. We define a reduction\nof $(q,Q)$ to $(p,P)$ by\n", "itemtype": "equation", "pos": 47508, "prevtext": "\nSo we define \n", "index": 23, "text": "\n\\[\nP(u,y):\\equiv \\exists v,w(y=(v,w)\\wedge P'(u,v,w))\n\\quad\\mbox{ and }\\quad\np(n)=p'(n,n).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"P(u,y):\\equiv\\exists v,w(y=(v,w)\\wedge P^{\\prime}(u,v,w))\\quad\\mbox{ and }%&#10;\\quad p(n)=p^{\\prime}(n,n).\" display=\"block\"><mrow><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>:</mo><mo>\u2261</mo><mo>\u2203</mo><mi>v</mi><mo>,</mo><mi>w</mi><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><msup><mi>P</mi><mo>\u2032</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mtext>\u00a0and\u00a0</mtext><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mi>p</mi><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><msup><mi>p</mi><mo>\u2032</mo></msup><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nGiven a witness $(v,w)$ for $P(f(x),(v,w))$ we get a witness for\n$Q(x,v)$ simply by taking the first element from the pair $(v,w)$.\n\\end{proof}\n\nWe are indebted to to Emil Je\\v{r}\\'abek for the following proposition.\n\n\\bpr\nThere exists a complete problem in {\\bf TFNP} w.r.t. polynomial reductions if and only if there exists a complete problem in {\\bf TFNP} w.r.t. \\emph{many-one} polynomial reductions.\n\\epr\n\nThe proposition is an immediate corollary of the following lemma.\n\n\\bl\nFor every {\\bf TFNP} problem $P$, there exists a {\\bf TFNP} problem $P'$ such that for every  {\\bf TFNP} problem $Q$, if $Q$ is polynomially reducible to $P$, then $Q$ is many-one polynomially reducible to $P'$.\n\\el\n\n\\bprf\nLet $P$ be given by a relation $R$ (w.l.o.g. we will assume that the polynomial bound is implicit in $R$). We define a binary relation $R'(u,v)$ as follows. Interpret a string $u$ as an encoding of a string $x$ and an oracle Boolean circuit $C$. Then $R'((x,C),v)$ will be defined to be true if $v$ encodes a computation of $C$ on input $x$ with the oracle queries and answers to be pairs $r,s$ such that $R(r,s)$ holds true.\n\nSuppose $Q$ is reducible to $P$ using a polynomial time query machine $M$. For each input $x$ for the problem $P$, we can construct in polynomial time an oracle Boolean circuit $C$ that simulates computations of $M$ on $x$. Given a string $v$ such that $R'((x,C),v)$, we get an output string $y$ of the computation of $M$ that satisfies $Q(x,y)$, because $M$ is a polynomial reduction of $Q$ to $R$.\n\\eprf\n\nFurthermore, Je\\v{r}\\'abek noted that we also get an equivalent conjecture if we use the following modification. Let us denote by {\\bf TFNP}$^{\\bf NP}$ the class of search problems defined in the same way as {\\bf TFNP} except that the binary relations are only required to be in {\\bf NP}.\n\\footnote{It would be more logical to use {\\bf TFP} for what is\n  called {\\bf TFNP} and reserve {\\bf TFNP} for the version where the\n  relation $R$ is in {\\bf NP}.}\nMany-one polynomial reductions for {\\bf TFNP}$^{\\bf NP}$ are defined exactly in the same way as for {\\bf TFNP}.\n\n\\bpr\nThere exists a complete problem in {\\bf TFNP} if and only if there exists a complete problem in {\\bf TFNP}$^{\\bf NP}$.\n\\epr\n\n\\bprf\nEvery problem $P$ in  {\\bf TFNP} is, by definition, also in {\\bf TFNP}$^{\\bf NP}$. Let $Q\\in{\\bf TFNP^{NP}}$. Let $Q$ be given by a binary relation  $\\exists^p z.R(x,y,z)$. Then the binary relation $R'$ defined by \n", "itemtype": "equation", "pos": 47987, "prevtext": "\n\nLet a  {\\bf TFNP} problem $(q,Q)$ be given and suppose that it\nis provably total in $T$. We have a \n$\\Sigma^b_1$ formula $\\phi$ and a polynomial $q$ that defines the\nproblem and a $T$-proof of totality $d$ for this\nrepresentation. Also we have a nondeterministic polynomial time bound $r$\nfor $\\exists y(|y|\\leq q(|x|)\\wedge\\phi(x,y))$. We define a reduction\nof $(q,Q)$ to $(p,P)$ by\n", "index": 25, "text": "\n\\[\nx\\mapsto f(x):=(x,\\phi,q,d,r(|x|)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"x\\mapsto f(x):=(x,\\phi,q,d,r(|x|)).\" display=\"block\"><mrow><mrow><mi>x</mi><mo>\u21a6</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>\u03d5</mi><mo>,</mo><mi>q</mi><mo>,</mo><mi>d</mi><mo>,</mo><mrow><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\ndefines a problem in {\\bf TFNP}. Using these two observations as a hint, it is very easy to finish the proof. We leave it to the reader.\n\\eprf\n\n\n\n\\subsection{Some arguments supporting the conjecture}\n\n\nIt is always difficult to justify a mathematical conjecture. Either the sentence is true, or it is false, but unlike in physics, in mathematics there are no experiments that may support one or the other. Thus the belief in a conjecture is based on subjective feelings. \nHere are our reasons why we believe that the conjecture should be true.\n\n\\ben\n\\item Every {\\bf TFNP} problem is based on some mathematical principle\n  that ensures that for every input there exists a solution. Although\n  theses principles are simple for the basic classes of {\\bf TFNP}\n  problems, it seems likely that there is no universal mathematical\n  principle that would work for every {\\bf TFNP} problem.\n\\item Combinatorial characterizations of provably total polynomial search problems have been characterized for some fragments of Bounded Arithmetic. \n The \n  description of these combinatorial problems suggest that their strength\n  increases with increasing strength of the theories.\n\\footnote{We only hypothesize that the strength of fragments $S^i_2$ of Bounded Arithmetic increases with increasing~$i$, but this hypothesis is supported by a connection with the Polynomial Hierarchy in computational complexity~\\cite{kpt}.}\n\\item  An oracle has been\n  constructed relative to which the conjecture holds true~\\cite{herbr}. \n\\item The connection with search problems verifying the consistency\n  of a theory that we describe below can also be viewed as a\n  supporting argument.\n\\een\n\n\n\\subsection{Herbrand Consistency Search}\n\nConjecture~{\\sf TFNP} has another equivalent form in which the concept\nof consistency plays a key role. According to Herbrand's theorem a\nuniversal sentence $\\Phi:=\\forall x_1\\dts x_k\\phi(x_1\\dts x_k)$ is\nconsistent if and only if for every family of terms $\\tau_{ij}$,\n$i=1\\dts n$, $j=1\\dts k,$\n$\n\\bigwedge_{i=1}^n\\phi(\\tau_{i1}\\dts \\tau_{ik})\n$\nis satisfiable as a propositional formula. Thus every consistent\nuniversal sentence defines a natural {\\bf TFNP} problem.\n\n\\begin{definition}\n  Let $\\Phi:=\\forall x_1\\dts x_k\\phi(x_1\\dts x_k)$ be a consistent\n  universal sentence.  Then $HCS(\\Phi)$, the \\emph{Herbrand\n    Consistency Search for $\\Phi$}, is the following total polynomial\n  search problem. Given terms $\\tau_{ij}$ in the language of $\\Phi$,\n  $i=1\\dts n$, $j=1\\dts k$, find a truth assignment to the atomic\n  subformulas occurring in $\\phi(\\tau_{i1}\\dts \\tau_{ik})$, for\n  $i=1\\dts n$, that makes $\\bigwedge_{i=1}^n \\phi(\\tau_{i1}\\dts\n  \\tau_{ik})$ true.\n\\end{definition}\n\nFor simplicity, we define Herbrand consistency search only for\nuniversal sentences in this paper, but  using Skolemization, one can easily extend this\ndefinition to conjunctions of prenex formulas.  In\n\\cite{herbr} we proved the following theorem.\n\n\\begin{theorem}\\label{t-hcon}\n  For every total polynomial search problem $P$, there exist a\n  consistent universal sentence $\\Phi$ such that the problem $P$ is\n  many-one polynomially reducible to $HCS(\\Phi)$.\n\\end{theorem}\n\nUsing this theorem we can state Conjecture~{\\sf TFNP} in the following\nequivalent form.\n\n\\begin{conjecture}{equivalent to {\\sf TFNP}}\nFor every theory $T\\in\\cal T$ there exists a consistent universal\nsentence $\\Phi$ such that $HCS(\\Phi)$ is not polynomially reducible to\nany {\\bf TFNP} problem provably total in $T$, i.e.,\n$HCS(\\Phi)\\not\\in{\\bf TFNP^*}(T)$.\n\\end{conjecture}\n\nAs with Conjecture~{\\sf CON$^N$}, one can ask how much stronger $T$ must be\nthan $S$ in order to be able to prove the totality of more polynomial\nsearch problems. But we can also ask: what is a search problem whose\ntotality is not provable in $T$? The following could be an answer to\nboth questions.\n\n\\begin{conjecture}{\\sf TFNP$^+$}\nSuppose $T\\in\\cal T$ is axiomatized by a universal \nsentence. Then $T$ does not prove that $HCS(T)$ is total for any\nformalization of it by a $\\Delta^b_1$ formula. \n\n\\end{conjecture}\n\nNote that if $T$ is strong enough to prove Herbrand's theorem, then it\ndoes not prove the totality of $HCS(T)$ formalized in a natural way,\nbecause if it did, it would prove its own consistency. However, this\ndoes not exclude the possibility that it proves the totality for some\ncontrived definition. Although we call it a conjecture, we are not\nvery confident that it is true. But suppose it were true and suppose\nthat $S\\in\\cal T$ is axiomatized by a universal formula and $T$ is a theory that proves Herbrand's Theorem and the consistency of $S$. Then we would have $HCS(S)\\in{\\bf TFNP^*}(T)\\setminus{\\bf\n  TFNP^*}(S)$. Thus according to this conjecture, adding the\nconsistency of a theory to itself produces more provably total\npolynomial search problems.\n\n\n\\subsection{Generalized polynomial search problems}\n\nIn Bounded Arithmetic we are interested not only in $\\forall\\hat{\\Sigma}^b_1$ sentences, but also in sentences of higher complexity, namely, sentences of the form $\\forall\\hat{\\Sigma}^b_n$ for $n=2,3,\\dots$. In~\\cite{thapen11}, N. Thapen noted that one can view these sentences as generalized polynomial search problems. For the sake of simplicity, we will only consider $\\forall\\hat{\\Sigma}^b_2$ sentences as an example; the reader is invited to  generalize it to higher complexity sentences. Let $\\Phi\\in\\forall\\hat{\\Sigma}^b_2$ be the sentence \n\n", "itemtype": "equation", "pos": 50486, "prevtext": "\nGiven a witness $(v,w)$ for $P(f(x),(v,w))$ we get a witness for\n$Q(x,v)$ simply by taking the first element from the pair $(v,w)$.\n\\end{proof}\n\nWe are indebted to to Emil Je\\v{r}\\'abek for the following proposition.\n\n\\bpr\nThere exists a complete problem in {\\bf TFNP} w.r.t. polynomial reductions if and only if there exists a complete problem in {\\bf TFNP} w.r.t. \\emph{many-one} polynomial reductions.\n\\epr\n\nThe proposition is an immediate corollary of the following lemma.\n\n\\bl\nFor every {\\bf TFNP} problem $P$, there exists a {\\bf TFNP} problem $P'$ such that for every  {\\bf TFNP} problem $Q$, if $Q$ is polynomially reducible to $P$, then $Q$ is many-one polynomially reducible to $P'$.\n\\el\n\n\\bprf\nLet $P$ be given by a relation $R$ (w.l.o.g. we will assume that the polynomial bound is implicit in $R$). We define a binary relation $R'(u,v)$ as follows. Interpret a string $u$ as an encoding of a string $x$ and an oracle Boolean circuit $C$. Then $R'((x,C),v)$ will be defined to be true if $v$ encodes a computation of $C$ on input $x$ with the oracle queries and answers to be pairs $r,s$ such that $R(r,s)$ holds true.\n\nSuppose $Q$ is reducible to $P$ using a polynomial time query machine $M$. For each input $x$ for the problem $P$, we can construct in polynomial time an oracle Boolean circuit $C$ that simulates computations of $M$ on $x$. Given a string $v$ such that $R'((x,C),v)$, we get an output string $y$ of the computation of $M$ that satisfies $Q(x,y)$, because $M$ is a polynomial reduction of $Q$ to $R$.\n\\eprf\n\nFurthermore, Je\\v{r}\\'abek noted that we also get an equivalent conjecture if we use the following modification. Let us denote by {\\bf TFNP}$^{\\bf NP}$ the class of search problems defined in the same way as {\\bf TFNP} except that the binary relations are only required to be in {\\bf NP}.\n\\footnote{It would be more logical to use {\\bf TFP} for what is\n  called {\\bf TFNP} and reserve {\\bf TFNP} for the version where the\n  relation $R$ is in {\\bf NP}.}\nMany-one polynomial reductions for {\\bf TFNP}$^{\\bf NP}$ are defined exactly in the same way as for {\\bf TFNP}.\n\n\\bpr\nThere exists a complete problem in {\\bf TFNP} if and only if there exists a complete problem in {\\bf TFNP}$^{\\bf NP}$.\n\\epr\n\n\\bprf\nEvery problem $P$ in  {\\bf TFNP} is, by definition, also in {\\bf TFNP}$^{\\bf NP}$. Let $Q\\in{\\bf TFNP^{NP}}$. Let $Q$ be given by a binary relation  $\\exists^p z.R(x,y,z)$. Then the binary relation $R'$ defined by \n", "index": 27, "text": "\n\\[\nR'(x,(y_1,y_2)):= R(x,y_1,y_2)\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"R^{\\prime}(x,(y_{1},y_{2})):=R(x,y_{1},y_{2})\" display=\"block\"><mrow><mrow><msup><mi>R</mi><mo>\u2032</mo></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $\\phi\\in\\Sigma^b_0$.\nThe computational task associated with $\\Phi$ is, for a given $x$, to find some $y_1$ such that $\\forall y_2\\leq s_2.\\phi(x,y_1,y_2)$ holds true.  Let another sentence $\\Psi\\in\\forall\\hat{\\Sigma}^b_2$ of the form \n\n", "itemtype": "equation", "pos": 55953, "prevtext": "\ndefines a problem in {\\bf TFNP}. Using these two observations as a hint, it is very easy to finish the proof. We leave it to the reader.\n\\eprf\n\n\n\n\\subsection{Some arguments supporting the conjecture}\n\n\nIt is always difficult to justify a mathematical conjecture. Either the sentence is true, or it is false, but unlike in physics, in mathematics there are no experiments that may support one or the other. Thus the belief in a conjecture is based on subjective feelings. \nHere are our reasons why we believe that the conjecture should be true.\n\n\\ben\n\\item Every {\\bf TFNP} problem is based on some mathematical principle\n  that ensures that for every input there exists a solution. Although\n  theses principles are simple for the basic classes of {\\bf TFNP}\n  problems, it seems likely that there is no universal mathematical\n  principle that would work for every {\\bf TFNP} problem.\n\\item Combinatorial characterizations of provably total polynomial search problems have been characterized for some fragments of Bounded Arithmetic. \n The \n  description of these combinatorial problems suggest that their strength\n  increases with increasing strength of the theories.\n\\footnote{We only hypothesize that the strength of fragments $S^i_2$ of Bounded Arithmetic increases with increasing~$i$, but this hypothesis is supported by a connection with the Polynomial Hierarchy in computational complexity~\\cite{kpt}.}\n\\item  An oracle has been\n  constructed relative to which the conjecture holds true~\\cite{herbr}. \n\\item The connection with search problems verifying the consistency\n  of a theory that we describe below can also be viewed as a\n  supporting argument.\n\\een\n\n\n\\subsection{Herbrand Consistency Search}\n\nConjecture~{\\sf TFNP} has another equivalent form in which the concept\nof consistency plays a key role. According to Herbrand's theorem a\nuniversal sentence $\\Phi:=\\forall x_1\\dts x_k\\phi(x_1\\dts x_k)$ is\nconsistent if and only if for every family of terms $\\tau_{ij}$,\n$i=1\\dts n$, $j=1\\dts k,$\n$\n\\bigwedge_{i=1}^n\\phi(\\tau_{i1}\\dts \\tau_{ik})\n$\nis satisfiable as a propositional formula. Thus every consistent\nuniversal sentence defines a natural {\\bf TFNP} problem.\n\n\\begin{definition}\n  Let $\\Phi:=\\forall x_1\\dts x_k\\phi(x_1\\dts x_k)$ be a consistent\n  universal sentence.  Then $HCS(\\Phi)$, the \\emph{Herbrand\n    Consistency Search for $\\Phi$}, is the following total polynomial\n  search problem. Given terms $\\tau_{ij}$ in the language of $\\Phi$,\n  $i=1\\dts n$, $j=1\\dts k$, find a truth assignment to the atomic\n  subformulas occurring in $\\phi(\\tau_{i1}\\dts \\tau_{ik})$, for\n  $i=1\\dts n$, that makes $\\bigwedge_{i=1}^n \\phi(\\tau_{i1}\\dts\n  \\tau_{ik})$ true.\n\\end{definition}\n\nFor simplicity, we define Herbrand consistency search only for\nuniversal sentences in this paper, but  using Skolemization, one can easily extend this\ndefinition to conjunctions of prenex formulas.  In\n\\cite{herbr} we proved the following theorem.\n\n\\begin{theorem}\\label{t-hcon}\n  For every total polynomial search problem $P$, there exist a\n  consistent universal sentence $\\Phi$ such that the problem $P$ is\n  many-one polynomially reducible to $HCS(\\Phi)$.\n\\end{theorem}\n\nUsing this theorem we can state Conjecture~{\\sf TFNP} in the following\nequivalent form.\n\n\\begin{conjecture}{equivalent to {\\sf TFNP}}\nFor every theory $T\\in\\cal T$ there exists a consistent universal\nsentence $\\Phi$ such that $HCS(\\Phi)$ is not polynomially reducible to\nany {\\bf TFNP} problem provably total in $T$, i.e.,\n$HCS(\\Phi)\\not\\in{\\bf TFNP^*}(T)$.\n\\end{conjecture}\n\nAs with Conjecture~{\\sf CON$^N$}, one can ask how much stronger $T$ must be\nthan $S$ in order to be able to prove the totality of more polynomial\nsearch problems. But we can also ask: what is a search problem whose\ntotality is not provable in $T$? The following could be an answer to\nboth questions.\n\n\\begin{conjecture}{\\sf TFNP$^+$}\nSuppose $T\\in\\cal T$ is axiomatized by a universal \nsentence. Then $T$ does not prove that $HCS(T)$ is total for any\nformalization of it by a $\\Delta^b_1$ formula. \n\n\\end{conjecture}\n\nNote that if $T$ is strong enough to prove Herbrand's theorem, then it\ndoes not prove the totality of $HCS(T)$ formalized in a natural way,\nbecause if it did, it would prove its own consistency. However, this\ndoes not exclude the possibility that it proves the totality for some\ncontrived definition. Although we call it a conjecture, we are not\nvery confident that it is true. But suppose it were true and suppose\nthat $S\\in\\cal T$ is axiomatized by a universal formula and $T$ is a theory that proves Herbrand's Theorem and the consistency of $S$. Then we would have $HCS(S)\\in{\\bf TFNP^*}(T)\\setminus{\\bf\n  TFNP^*}(S)$. Thus according to this conjecture, adding the\nconsistency of a theory to itself produces more provably total\npolynomial search problems.\n\n\n\\subsection{Generalized polynomial search problems}\n\nIn Bounded Arithmetic we are interested not only in $\\forall\\hat{\\Sigma}^b_1$ sentences, but also in sentences of higher complexity, namely, sentences of the form $\\forall\\hat{\\Sigma}^b_n$ for $n=2,3,\\dots$. In~\\cite{thapen11}, N. Thapen noted that one can view these sentences as generalized polynomial search problems. For the sake of simplicity, we will only consider $\\forall\\hat{\\Sigma}^b_2$ sentences as an example; the reader is invited to  generalize it to higher complexity sentences. Let $\\Phi\\in\\forall\\hat{\\Sigma}^b_2$ be the sentence \n\n", "index": 29, "text": "$$\\forall x\\exists y_1\\leq s_1\\forall y_2\\leq s_2.\\phi(x,y_1,y_2),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\forall x\\exists y_{1}\\leq s_{1}\\forall y_{2}\\leq s_{2}.\\phi(x,y_{1},y_{2}),\" display=\"block\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo>\u2203</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mrow></mrow><mo>\u2264</mo><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo>\u2200</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mrow><mo>\u2264</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><mo>.</mo><mrow><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $\\psi\\in\\Sigma^b_0$, be given. We can define a reduction of $\\Phi$ to $\\Psi$ in the same way as we defined it for {\\bf TFNP} in Definition~\\ref{d-5} using the binary relations  $\\forall y_2\\leq s_2.\\phi(x,y_1,y_2)$ and  $\\forall y_2\\leq t_2.\\psi(x,y_1,y_2)$, but a more natural concept is the following one. Say that \n\\emph{$\\Phi$ is many-one reducible to $\\Psi$} if there are polynomial time computable functions $f(x),g(x,y_1),h(x,y_1,y_2)$ such that \n", "itemtype": "equation", "pos": 56263, "prevtext": "\nwhere $\\phi\\in\\Sigma^b_0$.\nThe computational task associated with $\\Phi$ is, for a given $x$, to find some $y_1$ such that $\\forall y_2\\leq s_2.\\phi(x,y_1,y_2)$ holds true.  Let another sentence $\\Psi\\in\\forall\\hat{\\Sigma}^b_2$ of the form \n\n", "index": 31, "text": "$$\\forall x\\exists y_1\\leq t_1\\forall y_2\\leq t_2.\\psi(x,y_1,y_2),$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\forall x\\exists y_{1}\\leq t_{1}\\forall y_{2}\\leq t_{2}.\\psi(x,y_{1},y_{2}),\" display=\"block\"><mrow><mrow><mrow><mrow><mo>\u2200</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo>\u2203</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mrow></mrow><mo>\u2264</mo><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo>\u2200</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mrow><mo>\u2264</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><mo>.</mo><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nIf we ignore sharply bounded quantifiers in $\\phi$ and $\\psi$, then we can view the sentence above as a Skolemization of $\\Psi\\to\\Phi$.\n\nOne can now state similar conjectures as Conjecture~{\\sf TFNP}, but we will not do it in this paper.\n\n\n\n\\subsection{Quantitative measures of complexity}\n\n\nWe conclude this section with a remark about quantitative measures of\ncomplexity of {\\bf TFNP}s. In Subsection~\\ref{subsec4.1} we noted that we probably cannot classify problems in  {\\bf TFNP} by time or space complexities. Therefore we only use the quasiorder by polynomial reductions. However, the hypothesized connection with first order theories suggests another possibility.\nIn classical proof theory the growth rate\nof computable functions is measured by constructive ordinals. In a\ntypical situation, the provably total computable functions of a theory\n$T$ have ordinals less than the proof-theoretic ordinal of $T$. \n\n\nIn principle, we can use proof-theoretical ordinals to also measure\nthe complexity of total polynomial search problems.  Define the\nordinal of a polynomial search problem $P$ to be the least proof\ntheoretical ordinal $\\alpha$ of a theory $T$ such that $P\\in{\\bf\n  TFNP}(T)$. Of course, this only makes sense if the computational\ncomplexity increases with increasing ordinals. In order to prove it,\nwe would need to assume more than just some connection of\ncomputational complexity with provability.\n\nFor example, if\nConjecture~{\\sf TFNP$^+$} were true, we would obtain an increasing hierarchy\nindexed by constructive ordinals by using transfinite progressions\nbased on adding consistency.\nHowever, this scale would be very coarse and would not\ndistinguish problems near the bottom of the hierarchy, where there are\nproblems we are most interested in and which we can describe\nexplicitly.  For fragments of Bounded Arithmetic, the jump $T\\mapsto T+Con_T$\nis too big. ($Con_{S^1_2}$ is not provable in the full bounded\narithmetic $S_2$, even if we add an axiom saying that exponentiation is\ntotal~\\cite{wilkie-paris}.) We need a smaller jump and a plausible stronger conjecture\n  corresponding to this jump. Then we may be able to define a hierarchy of total\npolynomial search problems based on transfinite ordinals that would\nclassify problems provably total in fragments of Bounded Arithmetic.\n\n\n\n\n\n\\section{Propositional proof systems, disjoint {\\bf NP}-pairs and\n  disjoint {\\bf coNP}-pairs}\\label{sec5}\n\nSo far we were concerned with first order theories. In this section we\nwill show that one can also use other formal systems, namely,\npropositional proof systems, in order to state and study conjectures\nabout incompleteness in the finite domain.\n\nLet a language for classical propositional logic be fixed; say, we\ntake connectives $\\neg,\\wedge,\\vee$ and variables $p_1,p_2,\\dots$. Let\n{\\it TAUT} be the set of all tautologies and {\\it SAT} be the set of\nall satisfiable propositions.\nFollowing~\\cite{cook-reckhow}, we say that \\emph{a proof system is a\n  polynomial time computable function $P$ from $\\Sigma^*$ onto {\\bf\n    TAUT}}.\n\\footnote{Recall that \n$\\Sigma$ denotes $\\{0,1\\}$, but in principle it can be any finite alphabet of size at least 2.} \nIf $P(w)=\\phi$, we say that $w$ is a proof of $\\phi$ in\nthe proof system $P$. This elegant definition captures three basic\nproperties of proof systems: \\ben\n\\item the relation \\emph{``$w$ is a proof of $\\phi$''} is decidable in\n  polynomial time;\n\\item the system is sound;\n\\item the system is complete.\n\\een\nIn the rest of this section the term ``proof system'' will\nalways refer to ``\\emph{propositional} proof system''.\n\nAccording to this definition, a proof can be any evidence that shows\nlogical validity of a proposition. \n\n\n\nThe standard formalizations of propositional\ncalculus based on axioms and logical rules are systems from a special\nclass of proof systems, called \\emph{Frege systems.}\n\nWe say that \\emph{a proof system $P$ is polynomially bounded} if there\nexists a polynomial $p$ such that every tautology $\\phi$ has a\n$P$-proof of length at most $p(|\\phi|)$. Since {\\it TAUT} is {\\bf\n  coNP}-complete, the existence of a polynomially bounded proof system\nis equivalent to {\\bf NP}={\\bf coNP}.\n\nA weaker concept is length optimality. We say that \\emph{a proof\n  system $P$ is length-optimal} if for every proof\nsystem $Q$, there exists a polynomial $p$ such that if $\\phi$ has a\nproof of length $n$ in $P$, then it has a proof of length at most\n$p(n)$ in $Q$. In~\\cite{KP} we showed that Conjecture~{\\sf CON}$^N$ is\nequivalent to the following one.\n\n\\begin{conjecture}{equivalent to {\\sf CON}$^N$}\nThere exists no length-optimal proof system.\n\\end{conjecture}\n\nWhy do we believe that this conjecture is true? An argument that we can give is based on a construction of proof systems used to prove that the two statements of Conjecture~{\\sf CON}$^N$ are equivalent. Given an arithmetical theory $T$, we can formalize the concept of a propositional tautology by some formula $\\tau(x)$. For a given tautology $t$ we take its G\\\"odel number $n$ and treat any first order proof of $\\tau(\\bar{n})$ as a proof in a propositional proof system. Then it seem plausible that in stronger theories we can prove some tautologies by shorter proofs. Moreover, one can show that these proof systems are in a sense universal. So the fact that the logical strength of theories cannot be bounded is likely to be projected into these proof systems.\n\nAnother argument supporting the conjecture is from our experience with specific proof systems studied in proof complexity. Most systems are based on some class of formulas and deduction rules. If we enlarge the class of formulas then, usually, the system becomes stronger. For example, if we use quantified Boolean formulas instead of ordinary Boolean formulas, the system seems much stronger. For some weak systems, in particular, bounded depth Frege systems, this has actually been proven~\\cite{Impagliazzo-Krajicek}. As, apparently, there is no limit on how strong expressive power formulas can have, we also believe that there is no limit on how efficient a proof system can be. \n\n\n\n\n\n\\subsection{Disjoint {\\bf NP} pairs}\n\nIn \\cite{Razborov94} Razborov defined the \\emph{canonical\n  pair of a proof system} $P$ to be the pair of sets $(PR(P),NSAT^*)$\nwhere $PR(P)=\\{(\\phi,2^m);\\ \\phi\\mbox{ has a $P$-proof of length at\n  most }m\\}$, and  $NSAT^*=\\{(\\phi,2^m);\\ \\neg\\phi\\mbox{ is satisfiable\n}\\}$. Note that it is a pair of two disjoint {\\bf NP} sets. If a proof\nsystem $P$ simulates a proof system $Q$, then  $(PR(Q),NSAT^*)$ is\npolynomially reducible to  $(PR(P),NSAT^*)$ in the following sense.\n\nWe say that \\emph{a disjoint {\\bf NP} pair $(A,B)$ is polynomially reducible\nto  a disjoint {\\bf NP} pair $(C,D)$} if there exists a polynomial\ntime computable function $f$ that maps $A$ into $C$ and $B$ into $D$.\n\nIt is not difficult to show that canonical pairs of proof systems are\nuniversal in the class of all disjoint {\\bf NP} pairs, which means\nthat every disjoint {\\bf NP} pair $(A,B)$ is polynomially reducible to\nthe canonical pair of some proof system $P$. In fact, even more is true.\n\n\\begin{proposition}[\\cite{GSZ}]\nFor every disjoint {\\bf NP} pair $(A,B)$, there exists a proof system whose\ncanonical pair is polynomially \\emph{equivalent} to $(A,B)$.\n\\end{proposition}\n\n\n\n\n\n\n\n\n\n\nFurthermore, if $P$ and $Q$ are proof systems and there exists a polynomial\n$p$ such that for every tautology $\\phi$, if $\\phi$ has a $P$-proof of\nlength $n$, then $\\phi$ has a $Q$-proof of length at most $p(n)$, then\nthe canonical pair of $P$ is polynomially reducible to the canonical\npair of~$Q$. Indeed, the mapping $(\\phi,2^n)\\mapsto (\\phi,2^{p(n)})$\nis such a reduction. Thus we get:\n\n\\begin{proposition}[\\cite{Razborov94,KMT}]\\label{disjNP-CON-N}\nIf $P$ is a length-optimal proof system, then its canonical pair is a complete\ndisjoint {\\bf NP} pair with respect to polynomial reductions\n(i.e., every disjoint {\\bf NP} pair is reducible to it).\\footnote{Razborov proved this fact for p-optimal proof systems (see Definition~\\ref{def8} below); K\\\"obler, Messner and Tor\\'an improved it to length optimal proof systems.}\n\\end{proposition}\n\nTherefore the following conjecture is a strengthening of\nConjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf DisjNP}\n  There exist no complete disjoint {\\bf NP} pair (with respect to\n  polynomial reductions).\n\\end{conjecture}\n\nGla{\\ss}er et al.~\\cite{GSSZ} constructed an oracle relative to which there\nis no complete disjoint {\\bf NP}-pair. Other than that, we have little\nsupporting evidence. A combinatorial characterization of the canonical\npair has only been found for the resolution proof system. \nIn~\\cite{GSSZ} they also constructed an oracle relative to which there\nexists a complete disjoint {\\bf NP}-pair, but no length-optimal proof system\nexists, i.e., Conjecture~{\\sf DisjNP} fails, but Conjecture~{\\sf CON$^N$}\nholds true.\n\n\n\n\\subsection{Disjoint {\\bf coNP} pairs}\n\nWe now turn to disjoint {\\bf coNP} pairs. When comparing different\ndisjoint {\\bf coNP}-pairs, one can use the same\npolynomial reduction as used for disjoint {\\bf NP}-pairs; \nhence one can also ask similar questions. In particular, are there\ndisjoint {\\bf coNP} pairs inseparable by a set in {\\bf P}? Are there\ncomplete disjoint {\\bf coNP} pairs? We believe that the answer to the\nfirst question is yes, because we accept ${\\bf NP\\cap coNP}\\neq{\\bf P}$\nas a very likely fact. The answer to the second question is less\nclear, but we still lean to the negative answer.\n\n\\begin{conjecture}{\\sf DisjCoNP}\n  There exist no complete disjoint {\\bf coNP} pair (with respect to\n  polynomial reductions).\n\\end{conjecture}\n\nNext proposition states that \nConjecture~{\\sf TFNP} is a consequence of the above conjecture. \n\n\\bpr\\label{TFNP-coNP}\nIf there exists a complete {\\bf TFNP} problem, then there exists a\ncomplete disjoint {\\bf coNP} pair.\n\\epr\n\nThe proposition follows from the two lemmas below. First we need a definition.\n\n\\begin{definition}\nLet a {\\bf TFNP} problem $(p,R)$ be\ngiven. Assume that $R(x,y){\\Rightarrow} |y|=p(|x|)$. The \\emph{canonical disjoint {\\bf coNP} pair of $(p,R)$} is the pair  $(A_0,A_1)$ defined as\nfollows. The elements of $A_0\\cup A_1$ are pairs $(x,C)$ where $x$\nis an arbitrary binary string and $C$ is a Boolean circuit with\n$p(|x|)$ bit-inputs and one bit-output. The sets $A_0$ and $A_1$ are defined\nby\n\\bel{canonical-coNP}\n(x,C)\\in A_i\\ \\equiv\\ \\forall y (R(x,y)\\to C(y)= i).\n\\ee\n\\end{definition}\nThe condition that, for a given $x$, all elements $y$ satisfying $R(x,y)$ have the same length is, clearly, not essential, because we can always pad the string $y$ to the maximal length $p(|x|)$.\n\n\\bl\nFor every disjoint {\\bf coNP} pair  $(B_0,B_1)$ there exists a {\\bf TFNP} problem $(p,R)$ such that  $(B_0,B_1)$ is polynomially reducible to the canonical disjoint {\\bf coNP} pair of $(p,R)$.\n\\el\n\n\\bprf\nLet a disjoint {\\bf coNP} pair $(B_0,B_1)$ be given. Suppose that $B_i$s are  defined by\n", "itemtype": "equation", "pos": 56791, "prevtext": "\nwhere $\\psi\\in\\Sigma^b_0$, be given. We can define a reduction of $\\Phi$ to $\\Psi$ in the same way as we defined it for {\\bf TFNP} in Definition~\\ref{d-5} using the binary relations  $\\forall y_2\\leq s_2.\\phi(x,y_1,y_2)$ and  $\\forall y_2\\leq t_2.\\psi(x,y_1,y_2)$, but a more natural concept is the following one. Say that \n\\emph{$\\Phi$ is many-one reducible to $\\Psi$} if there are polynomial time computable functions $f(x),g(x,y_1),h(x,y_1,y_2)$ such that \n", "index": 33, "text": "\n\\[\n\\N\\models\\forall x,y_1,y_2(\\psi(f(x),y_1,h(x,y_1,y_2))\\to\\phi(x,g(x,y_1),y_2)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\N\\models\\forall x,y_{1},y_{2}(\\psi(f(x),y_{1},h(x,y_{1},y_{2}))\\to\\phi(x,g(x,%&#10;y_{1}),y_{2})).\" display=\"block\"><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\N</mtext></merror><mo>\u22a7</mo><mo>\u2200</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>\u03c8</mi><mrow><mo stretchy=\"false\">(</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>\u03d5</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>g</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nfor $i=0,1$, where $\\beta_i$ is computable in polynomial time and\n$r_i$ is a polynomial. Let the\nbinary relation $R$ be defined by\n", "itemtype": "equation", "pos": 67837, "prevtext": "\nIf we ignore sharply bounded quantifiers in $\\phi$ and $\\psi$, then we can view the sentence above as a Skolemization of $\\Psi\\to\\Phi$.\n\nOne can now state similar conjectures as Conjecture~{\\sf TFNP}, but we will not do it in this paper.\n\n\n\n\\subsection{Quantitative measures of complexity}\n\n\nWe conclude this section with a remark about quantitative measures of\ncomplexity of {\\bf TFNP}s. In Subsection~\\ref{subsec4.1} we noted that we probably cannot classify problems in  {\\bf TFNP} by time or space complexities. Therefore we only use the quasiorder by polynomial reductions. However, the hypothesized connection with first order theories suggests another possibility.\nIn classical proof theory the growth rate\nof computable functions is measured by constructive ordinals. In a\ntypical situation, the provably total computable functions of a theory\n$T$ have ordinals less than the proof-theoretic ordinal of $T$. \n\n\nIn principle, we can use proof-theoretical ordinals to also measure\nthe complexity of total polynomial search problems.  Define the\nordinal of a polynomial search problem $P$ to be the least proof\ntheoretical ordinal $\\alpha$ of a theory $T$ such that $P\\in{\\bf\n  TFNP}(T)$. Of course, this only makes sense if the computational\ncomplexity increases with increasing ordinals. In order to prove it,\nwe would need to assume more than just some connection of\ncomputational complexity with provability.\n\nFor example, if\nConjecture~{\\sf TFNP$^+$} were true, we would obtain an increasing hierarchy\nindexed by constructive ordinals by using transfinite progressions\nbased on adding consistency.\nHowever, this scale would be very coarse and would not\ndistinguish problems near the bottom of the hierarchy, where there are\nproblems we are most interested in and which we can describe\nexplicitly.  For fragments of Bounded Arithmetic, the jump $T\\mapsto T+Con_T$\nis too big. ($Con_{S^1_2}$ is not provable in the full bounded\narithmetic $S_2$, even if we add an axiom saying that exponentiation is\ntotal~\\cite{wilkie-paris}.) We need a smaller jump and a plausible stronger conjecture\n  corresponding to this jump. Then we may be able to define a hierarchy of total\npolynomial search problems based on transfinite ordinals that would\nclassify problems provably total in fragments of Bounded Arithmetic.\n\n\n\n\n\n\\section{Propositional proof systems, disjoint {\\bf NP}-pairs and\n  disjoint {\\bf coNP}-pairs}\\label{sec5}\n\nSo far we were concerned with first order theories. In this section we\nwill show that one can also use other formal systems, namely,\npropositional proof systems, in order to state and study conjectures\nabout incompleteness in the finite domain.\n\nLet a language for classical propositional logic be fixed; say, we\ntake connectives $\\neg,\\wedge,\\vee$ and variables $p_1,p_2,\\dots$. Let\n{\\it TAUT} be the set of all tautologies and {\\it SAT} be the set of\nall satisfiable propositions.\nFollowing~\\cite{cook-reckhow}, we say that \\emph{a proof system is a\n  polynomial time computable function $P$ from $\\Sigma^*$ onto {\\bf\n    TAUT}}.\n\\footnote{Recall that \n$\\Sigma$ denotes $\\{0,1\\}$, but in principle it can be any finite alphabet of size at least 2.} \nIf $P(w)=\\phi$, we say that $w$ is a proof of $\\phi$ in\nthe proof system $P$. This elegant definition captures three basic\nproperties of proof systems: \\ben\n\\item the relation \\emph{``$w$ is a proof of $\\phi$''} is decidable in\n  polynomial time;\n\\item the system is sound;\n\\item the system is complete.\n\\een\nIn the rest of this section the term ``proof system'' will\nalways refer to ``\\emph{propositional} proof system''.\n\nAccording to this definition, a proof can be any evidence that shows\nlogical validity of a proposition. \n\n\n\nThe standard formalizations of propositional\ncalculus based on axioms and logical rules are systems from a special\nclass of proof systems, called \\emph{Frege systems.}\n\nWe say that \\emph{a proof system $P$ is polynomially bounded} if there\nexists a polynomial $p$ such that every tautology $\\phi$ has a\n$P$-proof of length at most $p(|\\phi|)$. Since {\\it TAUT} is {\\bf\n  coNP}-complete, the existence of a polynomially bounded proof system\nis equivalent to {\\bf NP}={\\bf coNP}.\n\nA weaker concept is length optimality. We say that \\emph{a proof\n  system $P$ is length-optimal} if for every proof\nsystem $Q$, there exists a polynomial $p$ such that if $\\phi$ has a\nproof of length $n$ in $P$, then it has a proof of length at most\n$p(n)$ in $Q$. In~\\cite{KP} we showed that Conjecture~{\\sf CON}$^N$ is\nequivalent to the following one.\n\n\\begin{conjecture}{equivalent to {\\sf CON}$^N$}\nThere exists no length-optimal proof system.\n\\end{conjecture}\n\nWhy do we believe that this conjecture is true? An argument that we can give is based on a construction of proof systems used to prove that the two statements of Conjecture~{\\sf CON}$^N$ are equivalent. Given an arithmetical theory $T$, we can formalize the concept of a propositional tautology by some formula $\\tau(x)$. For a given tautology $t$ we take its G\\\"odel number $n$ and treat any first order proof of $\\tau(\\bar{n})$ as a proof in a propositional proof system. Then it seem plausible that in stronger theories we can prove some tautologies by shorter proofs. Moreover, one can show that these proof systems are in a sense universal. So the fact that the logical strength of theories cannot be bounded is likely to be projected into these proof systems.\n\nAnother argument supporting the conjecture is from our experience with specific proof systems studied in proof complexity. Most systems are based on some class of formulas and deduction rules. If we enlarge the class of formulas then, usually, the system becomes stronger. For example, if we use quantified Boolean formulas instead of ordinary Boolean formulas, the system seems much stronger. For some weak systems, in particular, bounded depth Frege systems, this has actually been proven~\\cite{Impagliazzo-Krajicek}. As, apparently, there is no limit on how strong expressive power formulas can have, we also believe that there is no limit on how efficient a proof system can be. \n\n\n\n\n\n\\subsection{Disjoint {\\bf NP} pairs}\n\nIn \\cite{Razborov94} Razborov defined the \\emph{canonical\n  pair of a proof system} $P$ to be the pair of sets $(PR(P),NSAT^*)$\nwhere $PR(P)=\\{(\\phi,2^m);\\ \\phi\\mbox{ has a $P$-proof of length at\n  most }m\\}$, and  $NSAT^*=\\{(\\phi,2^m);\\ \\neg\\phi\\mbox{ is satisfiable\n}\\}$. Note that it is a pair of two disjoint {\\bf NP} sets. If a proof\nsystem $P$ simulates a proof system $Q$, then  $(PR(Q),NSAT^*)$ is\npolynomially reducible to  $(PR(P),NSAT^*)$ in the following sense.\n\nWe say that \\emph{a disjoint {\\bf NP} pair $(A,B)$ is polynomially reducible\nto  a disjoint {\\bf NP} pair $(C,D)$} if there exists a polynomial\ntime computable function $f$ that maps $A$ into $C$ and $B$ into $D$.\n\nIt is not difficult to show that canonical pairs of proof systems are\nuniversal in the class of all disjoint {\\bf NP} pairs, which means\nthat every disjoint {\\bf NP} pair $(A,B)$ is polynomially reducible to\nthe canonical pair of some proof system $P$. In fact, even more is true.\n\n\\begin{proposition}[\\cite{GSZ}]\nFor every disjoint {\\bf NP} pair $(A,B)$, there exists a proof system whose\ncanonical pair is polynomially \\emph{equivalent} to $(A,B)$.\n\\end{proposition}\n\n\n\n\n\n\n\n\n\n\nFurthermore, if $P$ and $Q$ are proof systems and there exists a polynomial\n$p$ such that for every tautology $\\phi$, if $\\phi$ has a $P$-proof of\nlength $n$, then $\\phi$ has a $Q$-proof of length at most $p(n)$, then\nthe canonical pair of $P$ is polynomially reducible to the canonical\npair of~$Q$. Indeed, the mapping $(\\phi,2^n)\\mapsto (\\phi,2^{p(n)})$\nis such a reduction. Thus we get:\n\n\\begin{proposition}[\\cite{Razborov94,KMT}]\\label{disjNP-CON-N}\nIf $P$ is a length-optimal proof system, then its canonical pair is a complete\ndisjoint {\\bf NP} pair with respect to polynomial reductions\n(i.e., every disjoint {\\bf NP} pair is reducible to it).\\footnote{Razborov proved this fact for p-optimal proof systems (see Definition~\\ref{def8} below); K\\\"obler, Messner and Tor\\'an improved it to length optimal proof systems.}\n\\end{proposition}\n\nTherefore the following conjecture is a strengthening of\nConjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf DisjNP}\n  There exist no complete disjoint {\\bf NP} pair (with respect to\n  polynomial reductions).\n\\end{conjecture}\n\nGla{\\ss}er et al.~\\cite{GSSZ} constructed an oracle relative to which there\nis no complete disjoint {\\bf NP}-pair. Other than that, we have little\nsupporting evidence. A combinatorial characterization of the canonical\npair has only been found for the resolution proof system. \nIn~\\cite{GSSZ} they also constructed an oracle relative to which there\nexists a complete disjoint {\\bf NP}-pair, but no length-optimal proof system\nexists, i.e., Conjecture~{\\sf DisjNP} fails, but Conjecture~{\\sf CON$^N$}\nholds true.\n\n\n\n\\subsection{Disjoint {\\bf coNP} pairs}\n\nWe now turn to disjoint {\\bf coNP} pairs. When comparing different\ndisjoint {\\bf coNP}-pairs, one can use the same\npolynomial reduction as used for disjoint {\\bf NP}-pairs; \nhence one can also ask similar questions. In particular, are there\ndisjoint {\\bf coNP} pairs inseparable by a set in {\\bf P}? Are there\ncomplete disjoint {\\bf coNP} pairs? We believe that the answer to the\nfirst question is yes, because we accept ${\\bf NP\\cap coNP}\\neq{\\bf P}$\nas a very likely fact. The answer to the second question is less\nclear, but we still lean to the negative answer.\n\n\\begin{conjecture}{\\sf DisjCoNP}\n  There exist no complete disjoint {\\bf coNP} pair (with respect to\n  polynomial reductions).\n\\end{conjecture}\n\nNext proposition states that \nConjecture~{\\sf TFNP} is a consequence of the above conjecture. \n\n\\bpr\\label{TFNP-coNP}\nIf there exists a complete {\\bf TFNP} problem, then there exists a\ncomplete disjoint {\\bf coNP} pair.\n\\epr\n\nThe proposition follows from the two lemmas below. First we need a definition.\n\n\\begin{definition}\nLet a {\\bf TFNP} problem $(p,R)$ be\ngiven. Assume that $R(x,y){\\Rightarrow} |y|=p(|x|)$. The \\emph{canonical disjoint {\\bf coNP} pair of $(p,R)$} is the pair  $(A_0,A_1)$ defined as\nfollows. The elements of $A_0\\cup A_1$ are pairs $(x,C)$ where $x$\nis an arbitrary binary string and $C$ is a Boolean circuit with\n$p(|x|)$ bit-inputs and one bit-output. The sets $A_0$ and $A_1$ are defined\nby\n\\bel{canonical-coNP}\n(x,C)\\in A_i\\ \\equiv\\ \\forall y (R(x,y)\\to C(y)= i).\n\\ee\n\\end{definition}\nThe condition that, for a given $x$, all elements $y$ satisfying $R(x,y)$ have the same length is, clearly, not essential, because we can always pad the string $y$ to the maximal length $p(|x|)$.\n\n\\bl\nFor every disjoint {\\bf coNP} pair  $(B_0,B_1)$ there exists a {\\bf TFNP} problem $(p,R)$ such that  $(B_0,B_1)$ is polynomially reducible to the canonical disjoint {\\bf coNP} pair of $(p,R)$.\n\\el\n\n\\bprf\nLet a disjoint {\\bf coNP} pair $(B_0,B_1)$ be given. Suppose that $B_i$s are  defined by\n", "index": 35, "text": "\n\\[\nx\\in B_i\\ \\equiv\\ \\forall y(|y|\\leq r_i(|x|)\\to\\beta_i(x,y))\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"x\\in B_{i}\\ \\equiv\\ \\forall y(|y|\\leq r_{i}(|x|)\\to\\beta_{i}(x,y))\" display=\"block\"><mrow><mi>x</mi><mo>\u2208</mo><mpadded width=\"+5pt\"><msub><mi>B</mi><mi>i</mi></msub></mpadded><mo rspace=\"7.5pt\">\u2261</mo><mo>\u2200</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>y</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><msub><mi>r</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><msub><mi>\u03b2</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nSince $\\beta_i$s are computable in polynomial time, so is also $R$ and\nthe length of every $z$ satisfying $R(x,z)$ is polynomially bounded in\nthe length of $x$. Furthermore, since $B_0$ and $B_1$ are disjoint,\n$R$ is total. Again, by suitably padding $z$ we may ensure that  \n$R(x,z){\\Rightarrow} |z|=p(|x|)$ for some polynomial $p$. \nLet $(A_0,A_1)$ be the canonical pair of $(p,R)$. \nThe pair $(B_0,B_1)$ is reducible to $(A_0,A_1)$  by the mapping\n", "itemtype": "equation", "pos": 68035, "prevtext": "\nfor $i=0,1$, where $\\beta_i$ is computable in polynomial time and\n$r_i$ is a polynomial. Let the\nbinary relation $R$ be defined by\n", "index": 37, "text": "\n\\[\nR(x,z)\\ \\equiv\\ \\exists i\\in\\{0,1\\}\\exists y\n(z=(i,y)\\wedge |y|\\leq r_i(|x|)\\wedge \\neg\\beta_i(x,y)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"R(x,z)\\ \\equiv\\ \\exists i\\in\\{0,1\\}\\exists y(z=(i,y)\\wedge|y|\\leq r_{i}(|x|)%&#10;\\wedge\\neg\\beta_{i}(x,y)).\" display=\"block\"><mrow><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo rspace=\"7.5pt\" stretchy=\"false\">)</mo></mrow><mo rspace=\"7.5pt\">\u2261</mo><mo>\u2203</mo><mi>i</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><mo>\u2203</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mi>z</mi><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mo stretchy=\"false\">|</mo><mi>y</mi><mo stretchy=\"false\">|</mo><mo>\u2264</mo><msub><mi>r</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">|</mo><mi>x</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mi mathvariant=\"normal\">\u00ac</mi><msub><mi>\u03b2</mi><mi>i</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $C$ is a circuit such that $C(i,y)=1-i$, because for this $C$, $(x,C)\\in A_j$ iff $x\\in B_j$.\n\\eprf\n\n\n\\bl\nLet $(P,p)$ and $(Q,q)$ be two {\\bf TFNP} problems such that $R(x,y){\\Rightarrow} |y|=p(|x|)$ and $Q(x,y){\\Rightarrow} |y|=q(|x|)$. Let $(A_0,A_1)$\nrespectively $(B_0,B_1)$ be their canonical {\\bf coNP} pairs and\nsuppose that \n$(P,p)$ is polynomially many-one reducible to $(Q,q)$. Then $(A_0,A_1)$\nis reducible to $(B_0,B_1)$.\n\\el\n\\bprf\n\nLet $(P,p)$, $(Q,q)$ and a polynomial many-one reduction $(f,g)$ of\n$(P,p)$ to $(Q,q)$ be given.  Let $(A_0,A_1)$ and $(B_0,B_1)$ be the\ncanonical {\\bf coNP} pairs of $(P,p)$ and $(Q,q)$. We define a\npolynomial reduction of $(A_0,A_1)$ to $(B_0,B_1)$ as follows. For an\ninput of the form $(x,C)$ where $C$ is a Boolean circuit, we put\n", "itemtype": "equation", "pos": 68594, "prevtext": "\nSince $\\beta_i$s are computable in polynomial time, so is also $R$ and\nthe length of every $z$ satisfying $R(x,z)$ is polynomially bounded in\nthe length of $x$. Furthermore, since $B_0$ and $B_1$ are disjoint,\n$R$ is total. Again, by suitably padding $z$ we may ensure that  \n$R(x,z){\\Rightarrow} |z|=p(|x|)$ for some polynomial $p$. \nLet $(A_0,A_1)$ be the canonical pair of $(p,R)$. \nThe pair $(B_0,B_1)$ is reducible to $(A_0,A_1)$  by the mapping\n", "index": 39, "text": "\n\\[\nx\\ \\mapsto\\ (x,C),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"x\\ \\mapsto\\ (x,C),\" display=\"block\"><mrow><mrow><mpadded width=\"+5pt\"><mi>x</mi></mpadded><mo rspace=\"7.5pt\">\u21a6</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $D_x$ is a Boolean circuit with $q(|f(x)|)$ bit inputs such that for all\n$y$ of length $q(|f(x)|)$,\n\\bel{e54}\nD_x(y) = C(g(x,y)).\n\\ee\nIf an input $z$ does not have the required form, we put $h(z)=0$. We will check that this defines a polynomial reduction of  $(A_0,A_1)$ to $(B_0,B_1)$. Let $(x,C)\\in A_i$ and let $y$ be any number such that $|y|=q(|f(x)|)$ and $Q(f(x),y)$. Since $P(x,g(x,y))$, we have $C(g(x,y))=i$ by the definition of $A_i$. By (\\ref{e54}), $D_x(y)=i$. This proves that $f(x)\\in B_i$. \n\\eprf\n\n\\subsection{Multivalued functions}\n\nA class closely related to {\\bf TFNP} and the question whether there\nexists a complete problem in this class were studied by Beyersdorff, K\\\"obler and Messner~\\cite{BKM}. We need a couple of preliminary definitions.\n\nA multivalued partial function $f$ is called \\emph{{\\bf NP}\n  multivalued function} if it is computed by a nondeterministic\npolynomial time Turing machine $M$ in the following sense. $M$ stops\nin two possible states: ACCEPT and REJECT. For a given input value $x$,\nthe values of $f$ are those words on the output tape which appear when\nthe state ACCEPT is reached. For a function $f\\in{\\bf NPMV}$ we denote\nby $f\\{ x \\}$ the set of all values for the input $x$. Thus $f$ is total iff $f\\{x\\}\\neq\\emptyset$ for all $x$. \nThe class of {\\bf NP} \\emph{multivalued\nfunctions} is denoted by {\\bf NPMV}.  The class of \\emph{total} {\\bf\n  NP} \\emph{multivalued functions} is denoted by {\\bf NPMV}$_t$. \n\nBy their nature, {\\bf NPMV}$_t$ functions are {\\bf TFNP}\nproblems, but there is an essential \ndifference in how one defines reduction. For $f,g\\in{\\bf\nNPMV}$, we say that $f$ is polynomially reducible to $g$ if there\nexists a polynomial time computable function $h$ such that for all $x$,\n", "itemtype": "equation", "pos": 69405, "prevtext": "\nwhere $C$ is a circuit such that $C(i,y)=1-i$, because for this $C$, $(x,C)\\in A_j$ iff $x\\in B_j$.\n\\eprf\n\n\n\\bl\nLet $(P,p)$ and $(Q,q)$ be two {\\bf TFNP} problems such that $R(x,y){\\Rightarrow} |y|=p(|x|)$ and $Q(x,y){\\Rightarrow} |y|=q(|x|)$. Let $(A_0,A_1)$\nrespectively $(B_0,B_1)$ be their canonical {\\bf coNP} pairs and\nsuppose that \n$(P,p)$ is polynomially many-one reducible to $(Q,q)$. Then $(A_0,A_1)$\nis reducible to $(B_0,B_1)$.\n\\el\n\\bprf\n\nLet $(P,p)$, $(Q,q)$ and a polynomial many-one reduction $(f,g)$ of\n$(P,p)$ to $(Q,q)$ be given.  Let $(A_0,A_1)$ and $(B_0,B_1)$ be the\ncanonical {\\bf coNP} pairs of $(P,p)$ and $(Q,q)$. We define a\npolynomial reduction of $(A_0,A_1)$ to $(B_0,B_1)$ as follows. For an\ninput of the form $(x,C)$ where $C$ is a Boolean circuit, we put\n", "index": 41, "text": "\n\\[\nh(x,C)=(f(x),D_x),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m1\" class=\"ltx_Math\" alttext=\"h(x,C)=(f(x),D_{x}),\" display=\"block\"><mrow><mrow><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><msub><mi>D</mi><mi>x</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": " \n\nA relation to our Conjecture~{\\sf TFNP} is given by the following\nproposition. \n \n\\bpr\\label{TFNP-NPMV}\nThe existence of a complete function in {\\bf NPMV}$_t$\nimplies the existence of a complete {\\bf TFNP} problem. \n\\epr\n\\bprf Let\n$g$ be a complete function in {\\bf NPMV}$_t$. We can represent $g$\nusing a polynomial time computable ternary relation as follows.\n", "itemtype": "equation", "pos": -1, "prevtext": "\nwhere $D_x$ is a Boolean circuit with $q(|f(x)|)$ bit inputs such that for all\n$y$ of length $q(|f(x)|)$,\n\\bel{e54}\nD_x(y) = C(g(x,y)).\n\\ee\nIf an input $z$ does not have the required form, we put $h(z)=0$. We will check that this defines a polynomial reduction of  $(A_0,A_1)$ to $(B_0,B_1)$. Let $(x,C)\\in A_i$ and let $y$ be any number such that $|y|=q(|f(x)|)$ and $Q(f(x),y)$. Since $P(x,g(x,y))$, we have $C(g(x,y))=i$ by the definition of $A_i$. By (\\ref{e54}), $D_x(y)=i$. This proves that $f(x)\\in B_i$. \n\\eprf\n\n\\subsection{Multivalued functions}\n\nA class closely related to {\\bf TFNP} and the question whether there\nexists a complete problem in this class were studied by Beyersdorff, K\\\"obler and Messner~\\cite{BKM}. We need a couple of preliminary definitions.\n\nA multivalued partial function $f$ is called \\emph{{\\bf NP}\n  multivalued function} if it is computed by a nondeterministic\npolynomial time Turing machine $M$ in the following sense. $M$ stops\nin two possible states: ACCEPT and REJECT. For a given input value $x$,\nthe values of $f$ are those words on the output tape which appear when\nthe state ACCEPT is reached. For a function $f\\in{\\bf NPMV}$ we denote\nby $f\\{ x \\}$ the set of all values for the input $x$. Thus $f$ is total iff $f\\{x\\}\\neq\\emptyset$ for all $x$. \nThe class of {\\bf NP} \\emph{multivalued\nfunctions} is denoted by {\\bf NPMV}.  The class of \\emph{total} {\\bf\n  NP} \\emph{multivalued functions} is denoted by {\\bf NPMV}$_t$. \n\nBy their nature, {\\bf NPMV}$_t$ functions are {\\bf TFNP}\nproblems, but there is an essential \ndifference in how one defines reduction. For $f,g\\in{\\bf\nNPMV}$, we say that $f$ is polynomially reducible to $g$ if there\nexists a polynomial time computable function $h$ such that for all $x$,\n", "index": 43, "text": "\n\\[\nf\\{x\\}=g\\{h(x)\\} .\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"f\\{x\\}=g\\{h(x)\\}.\" display=\"block\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>h</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nRecall that the superscript at the existential quantifier means that we tacitly assume that there exists a polynomial bound $p$ such that\n$R(x,y,z)$ is satisfied only if the lengths of $y$ and $z$ are bounded \nby $p(|x|)$. Define\n", "itemtype": "equation", "pos": 71577, "prevtext": " \n\nA relation to our Conjecture~{\\sf TFNP} is given by the following\nproposition. \n \n\\bpr\\label{TFNP-NPMV}\nThe existence of a complete function in {\\bf NPMV}$_t$\nimplies the existence of a complete {\\bf TFNP} problem. \n\\epr\n\\bprf Let\n$g$ be a complete function in {\\bf NPMV}$_t$. We can represent $g$\nusing a polynomial time computable ternary relation as follows.\n", "index": 45, "text": "\n\\[\ng\\{x\\}=\\{y;\\ \\exists^p z.R(x,y,z)\\}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m1\" class=\"ltx_Math\" alttext=\"g\\{x\\}=\\{y;\\ \\exists^{p}z.R(x,y,z)\\}.\" display=\"block\"><mrow><mi>g</mi><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo rspace=\"7.5pt\">;</mo><msup><mo>\u2203</mo><mi>p</mi></msup><mi>z</mi><mo>.</mo><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nWe claim that $Q$ defines a complete {\\bf TFNP} problem. Let $S(x,y)$\nbe a binary relation computable in polynomial time viewed as a {\\bf\n  TFNP} problem (again, we tacitly assume an implicit polynomial bound on the\nlength of $y$). Define a function $f\\in \\mbox{\\bf NPMV}_t$ by\n", "itemtype": "equation", "pos": 71850, "prevtext": "\nRecall that the superscript at the existential quantifier means that we tacitly assume that there exists a polynomial bound $p$ such that\n$R(x,y,z)$ is satisfied only if the lengths of $y$ and $z$ are bounded \nby $p(|x|)$. Define\n", "index": 47, "text": "\n\\[\nQ(x,u):= R(x,(u)_1,(u)_2).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"Q(x,u):=R(x,(u)_{1},(u)_{2}).\" display=\"block\"><mrow><mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>:=</mo><mrow><mi>R</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><mn>1</mn></msub><mo>,</mo><msub><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nSince $f$ is reducible to the complete function $g$, there exists a\npolynomial time computable function $h$ such that $f\\{x\\}=g\\{h(x)\\}$,\nwhich is equivalent to\n", "itemtype": "equation", "pos": 72161, "prevtext": "\nWe claim that $Q$ defines a complete {\\bf TFNP} problem. Let $S(x,y)$\nbe a binary relation computable in polynomial time viewed as a {\\bf\n  TFNP} problem (again, we tacitly assume an implicit polynomial bound on the\nlength of $y$). Define a function $f\\in \\mbox{\\bf NPMV}_t$ by\n", "index": 49, "text": "\n\\[\nf\\{x\\}:=\\{y;\\ S(x,y)\\}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"f\\{x\\}:=\\{y;\\ S(x,y)\\}.\" display=\"block\"><mrow><mrow><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow></mrow><mo>:=</mo><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo rspace=\"7.5pt\">;</mo><mrow><mi>S</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nThus the pair of functions $h,k$, where $k(u):=(u)_1$, is a polynomial\nreduction of $S$ to $Q$.\n\\eprf\n\nWe do not know if the opposite implication holds true. \nBeyersdorff et al. \\cite{BKM} \nproved that if there exists a complete function in {\\bf NPMV}$_t$, then there\nexists a complete disjoint {\\bf coNP} pair. This is now a consequence\nof Propositions \\ref{TFNP-coNP} and  \\ref{TFNP-NPMV}.\n\n\n\n\n\n\n\\section{Classification of conjectures}\\label{sec6}\n\n\n\n\n\n\n\\subsection{Uniform and nonuniform}\n\nA more natural way to compare proof systems than just comparing the\nlengths of proofs is polynomial simulation. This is a concept,\nintroduced in~\\cite{cook75}, is similar to polynomial reductions used in\nthe theory of {\\bf NP}-completeness and those we used to compare {\\bf\n  TFNP} problems.\n\n\\begin{definition}\\label{def8}\nWe say that \\emph{a proof $P$ system polynomially simulates a proof\n  system $Q$} if there exists a polynomial time computable function\nsuch that given a $Q$-proof $d$ of $\\phi$, $f(d)$ is a $P$-proof of\n(the same) $\\phi$.  We say that \\emph{a proof system $P$ is p-optimal}\nif it polynomially simulates every proof system.\n\\end{definition}\n\nUsing this concept we can state a conjecture slightly weaker than Conjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf CON}\nThere exists no p-optimal proof system.\n\\end{conjecture}\n \nIn~\\cite{KP} we proved that this conjecture is equivalent to the\nfollowing uniform version of Conjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf equivalent to {\\sf CON}}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $Con_T(\\bar n)$ cannot be constructed in polynomial time.\n\\end{conjecture}\n\nA uniform version of Conjecture~{\\sf RFN$^N_1$} is obtained in the same\nway.\n\n\\begin{conjecture}{\\sf RFN$_1$}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ cannot be constructed in\n  polynomial time.\n\\end{conjecture}\n\nExcept for modifications of these conjectures, such as Conjecture~{\\sf CON$^{N+}$}, we do not know of any other pair of uniform and nonuniform conjectures. In particular, {\\sf TFNP} is apparently uniform, but we do not know if it has a nonuniform companion.\n\nIt may seem strange that according to this classification ${\\bf NP}\\neq{\\bf coNP}$ should be a nonuniform conjecture, in spite of the fact that both {\\bf NP} and {\\bf coNP} are uniform complexity classes. Indeed, ${\\bf NP}\\neq{\\bf coNP}$ is implied by the nonuniform conjectures {\\sf CON$^N$} and {\\sf RFN$^N_1$}, while the uniform versions {\\sf CON} and {\\sf RFN$_1$} are only known to imply ${\\bf P}\\neq{\\bf NP}$. But if we look at  ${\\bf NP}\\neq{\\bf coNP}$ from the point of view of proof complexity, then it is clearly a nonuniform version of ${\\bf P}\\neq{\\bf NP}$. Just consider the following equivalent formulations of these conjectures:\n\\bi\n\\item  ${\\bf P}\\neq{\\bf NP}$ $\\Leftrightarrow$ there exists a proof system $P$ such that for every tautology $\\tau$ a $P$-proof of $\\tau$ can be constructed in polynomial time;\n\\item ${\\bf NP}\\neq{\\bf coNP}$ $\\Leftrightarrow$ there exists a proof system $P$ such that  every tautology $\\tau$ has a $P$-proof of polynomial length.\n\\ei\nHowever, although Conjecture~{\\sf DisjNP} seems to be uniform, it does imply the nonuniform Conjecture~{\\sf CON$^N$} (see Proposition~\\ref{disjNP-CON-N}). We do not have an explanation for this.\n\n\n\\subsection{Logical complexity}\n\n\nWe started with statements about finite consistency, statements that\nexpress facts about logic, and eventually arrived at statements about\ndisjoint sets of certain complexity, statements from \nstructural complexity theory that apparently have nothing to do with\nthe main theme of incompleteness. But one should realize that\nexpressing these conjectures using concepts from computational\ncomplexity theory is just a convenient way to state them. It seems that it should be possible  to present all uniform conjectures as statements about unprovability of\ncertain sentences in theories from the class $\\cal T$. The following proposition shows how to state Conjecture~{\\sf CON} in this way.\n\n\\bpr\\label{pr-6.1}\nThere exists a $p$-optimal proof system (for {\\it TAUT}) if and only if there exists a\ntheory $T\\in\\cal T$ such that for every proof system $P$ there exists\na definition of $P$ by a $\\Delta^b_1$ formula \nsuch that $T$ proves the soundness of $P$ represented by this formula.\n\\epr\nFor the proof, see \\cite{kniha}, pages 578-9.\nNext proposition shows how to express Conjecture~{\\sf DisjNP} as a statement about unprovability of certain sentences.\n\n\\bpr\\label{pr-6.2}\nThere exists a complete disjoint {\\bf NP} pair if and only if there exists\na theory $T\\in\\cal T$ such that for every disjoint {\\bf NP} pair\n$(B_0,B_1)$ there are $\\Sigma^b_1$ definitions of $B_0$ and $B_1$ for\nwhich $T$ proves that they define disjoint sets.\n\\epr\n\\bprf\nSuppose that there exists a complete disjoint {\\bf NP} pair $(A_0,A_1)$. Let\n$\\exists^py.\\alpha_i(x,y)$ be $\\Sigma^b_1$ definitions of $A_i$,\n$i=0,1$. Define a theory $T$ to be \n\n", "itemtype": "equation", "pos": 72352, "prevtext": "\nSince $f$ is reducible to the complete function $g$, there exists a\npolynomial time computable function $h$ such that $f\\{x\\}=g\\{h(x)\\}$,\nwhich is equivalent to\n", "index": 51, "text": "\n\\[\n\\{y;\\ S(x,y)\\}=\\{y;\\ \\exists z.R(h(x),y,z)\\}=\\{y;\\ \\exists z.Q(h(x),(y,z))\\}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"\\{y;\\ S(x,y)\\}=\\{y;\\ \\exists z.R(h(x),y,z)\\}=\\{y;\\ \\exists z.Q(h(x),(y,z))\\}.\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo rspace=\"7.5pt\">;</mo><mi>S</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo rspace=\"7.5pt\">;</mo><mo>\u2203</mo><mi>z</mi><mo>.</mo><mi>R</mi><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo rspace=\"7.5pt\">;</mo><mo>\u2203</mo><mi>z</mi><mo>.</mo><mi>Q</mi><mrow><mo stretchy=\"false\">(</mo><mi>h</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nLet $(B_0,B_1)$ be an arbitrary disjoint {\\bf NP} pair. Let\n$\\exists^py.\\beta_i(x,y)$ be some $\\Sigma^b_1$ definitions of $B_i$,\n$i=0,1$. Since  $(A_0,A_1)$ is complete, there exists a polynomial\ntime reduction $f$ of $(B_0,B_1)$ to $(A_0,A_1)$. Consider the\nfollowing definitions of $B_i$, $i=0,1$, by $\\Sigma^b_1$ formulas:\n", "itemtype": "equation", "pos": 77468, "prevtext": "\nThus the pair of functions $h,k$, where $k(u):=(u)_1$, is a polynomial\nreduction of $S$ to $Q$.\n\\eprf\n\nWe do not know if the opposite implication holds true. \nBeyersdorff et al. \\cite{BKM} \nproved that if there exists a complete function in {\\bf NPMV}$_t$, then there\nexists a complete disjoint {\\bf coNP} pair. This is now a consequence\nof Propositions \\ref{TFNP-coNP} and  \\ref{TFNP-NPMV}.\n\n\n\n\n\n\n\\section{Classification of conjectures}\\label{sec6}\n\n\n\n\n\n\n\\subsection{Uniform and nonuniform}\n\nA more natural way to compare proof systems than just comparing the\nlengths of proofs is polynomial simulation. This is a concept,\nintroduced in~\\cite{cook75}, is similar to polynomial reductions used in\nthe theory of {\\bf NP}-completeness and those we used to compare {\\bf\n  TFNP} problems.\n\n\\begin{definition}\\label{def8}\nWe say that \\emph{a proof $P$ system polynomially simulates a proof\n  system $Q$} if there exists a polynomial time computable function\nsuch that given a $Q$-proof $d$ of $\\phi$, $f(d)$ is a $P$-proof of\n(the same) $\\phi$.  We say that \\emph{a proof system $P$ is p-optimal}\nif it polynomially simulates every proof system.\n\\end{definition}\n\nUsing this concept we can state a conjecture slightly weaker than Conjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf CON}\nThere exists no p-optimal proof system.\n\\end{conjecture}\n \nIn~\\cite{KP} we proved that this conjecture is equivalent to the\nfollowing uniform version of Conjecture~{\\sf CON$^N$}.\n\n\\begin{conjecture}{\\sf equivalent to {\\sf CON}}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $Con_T(\\bar n)$ cannot be constructed in polynomial time.\n\\end{conjecture}\n\nA uniform version of Conjecture~{\\sf RFN$^N_1$} is obtained in the same\nway.\n\n\\begin{conjecture}{\\sf RFN$_1$}\n  For every $S\\in\\cal T$, there exists $T\\in\\cal T$ such that\n  $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ cannot be constructed in\n  polynomial time.\n\\end{conjecture}\n\nExcept for modifications of these conjectures, such as Conjecture~{\\sf CON$^{N+}$}, we do not know of any other pair of uniform and nonuniform conjectures. In particular, {\\sf TFNP} is apparently uniform, but we do not know if it has a nonuniform companion.\n\nIt may seem strange that according to this classification ${\\bf NP}\\neq{\\bf coNP}$ should be a nonuniform conjecture, in spite of the fact that both {\\bf NP} and {\\bf coNP} are uniform complexity classes. Indeed, ${\\bf NP}\\neq{\\bf coNP}$ is implied by the nonuniform conjectures {\\sf CON$^N$} and {\\sf RFN$^N_1$}, while the uniform versions {\\sf CON} and {\\sf RFN$_1$} are only known to imply ${\\bf P}\\neq{\\bf NP}$. But if we look at  ${\\bf NP}\\neq{\\bf coNP}$ from the point of view of proof complexity, then it is clearly a nonuniform version of ${\\bf P}\\neq{\\bf NP}$. Just consider the following equivalent formulations of these conjectures:\n\\bi\n\\item  ${\\bf P}\\neq{\\bf NP}$ $\\Leftrightarrow$ there exists a proof system $P$ such that for every tautology $\\tau$ a $P$-proof of $\\tau$ can be constructed in polynomial time;\n\\item ${\\bf NP}\\neq{\\bf coNP}$ $\\Leftrightarrow$ there exists a proof system $P$ such that  every tautology $\\tau$ has a $P$-proof of polynomial length.\n\\ei\nHowever, although Conjecture~{\\sf DisjNP} seems to be uniform, it does imply the nonuniform Conjecture~{\\sf CON$^N$} (see Proposition~\\ref{disjNP-CON-N}). We do not have an explanation for this.\n\n\n\\subsection{Logical complexity}\n\n\nWe started with statements about finite consistency, statements that\nexpress facts about logic, and eventually arrived at statements about\ndisjoint sets of certain complexity, statements from \nstructural complexity theory that apparently have nothing to do with\nthe main theme of incompleteness. But one should realize that\nexpressing these conjectures using concepts from computational\ncomplexity theory is just a convenient way to state them. It seems that it should be possible  to present all uniform conjectures as statements about unprovability of\ncertain sentences in theories from the class $\\cal T$. The following proposition shows how to state Conjecture~{\\sf CON} in this way.\n\n\\bpr\\label{pr-6.1}\nThere exists a $p$-optimal proof system (for {\\it TAUT}) if and only if there exists a\ntheory $T\\in\\cal T$ such that for every proof system $P$ there exists\na definition of $P$ by a $\\Delta^b_1$ formula \nsuch that $T$ proves the soundness of $P$ represented by this formula.\n\\epr\nFor the proof, see \\cite{kniha}, pages 578-9.\nNext proposition shows how to express Conjecture~{\\sf DisjNP} as a statement about unprovability of certain sentences.\n\n\\bpr\\label{pr-6.2}\nThere exists a complete disjoint {\\bf NP} pair if and only if there exists\na theory $T\\in\\cal T$ such that for every disjoint {\\bf NP} pair\n$(B_0,B_1)$ there are $\\Sigma^b_1$ definitions of $B_0$ and $B_1$ for\nwhich $T$ proves that they define disjoint sets.\n\\epr\n\\bprf\nSuppose that there exists a complete disjoint {\\bf NP} pair $(A_0,A_1)$. Let\n$\\exists^py.\\alpha_i(x,y)$ be $\\Sigma^b_1$ definitions of $A_i$,\n$i=0,1$. Define a theory $T$ to be \n\n", "index": 53, "text": "\n\\[\nS^1_2\\ +\\ \\forall x(\\neg\\exists^py.\\alpha_0(x,y)\\vee\\neg\\exists^py.\\alpha_1(x,y)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m1\" class=\"ltx_Math\" alttext=\"S^{1}_{2}\\ +\\ \\forall x(\\neg\\exists^{p}y.\\alpha_{0}(x,y)\\vee\\neg\\exists^{p}y.%&#10;\\alpha_{1}(x,y)).\" display=\"block\"><mrow><mpadded width=\"+5pt\"><msubsup><mi>S</mi><mn>2</mn><mn>1</mn></msubsup></mpadded><mo rspace=\"7.5pt\">+</mo><mo>\u2200</mo><mi>x</mi><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">\u00ac</mi><msup><mo>\u2203</mo><mi>p</mi></msup><mi>y</mi><mo>.</mo><msub><mi>\u03b1</mi><mn>0</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2228</mo><mi mathvariant=\"normal\">\u00ac</mi><msup><mo>\u2203</mo><mi>p</mi></msup><mi>y</mi><mo>.</mo><msub><mi>\u03b1</mi><mn>1</mn></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nIt is clear that they define the sets  $B_i$ correctly and that $T$\nproves that sets defined by these formulas are disjoint.\n\nThe proof of the converse implication is a standard diagonalization\nargument that we have already presented in the proof of\nLemma~\\ref{l-4.1}, so we will be very brief.\n\nLet $T$ be a theory with the property stated in the proposition. For\n$i=0,1$, let $A_i$ be the set of tuples $(x,\\beta_0,\\beta_1,d,a)$ such\nthat \n\\bi\n\\item $\\beta_0$ and $\\beta_1$ are $\\Sigma^b_1$ formulas, $d$ is a\n$T$-proof of the disjointness of the sets defined by $\\beta_0$ and $\\beta_1$,\n$a$ is a nondeterministic time bound for $\\beta_0$ and $\\beta_1$, and\n$\\exists^py.\\beta_i(x,y)$ holds true.\n\\ei\nWe leave to the reader to verify that these conditions define a\ndisjoint {\\bf NP} pair and that every disjoint {\\bf NP} pair is\npolynomially reducible to it.\n\\eprf\nThe non-existence of a complete disjoint {\\bf coNP} pair, Conjecture~{\\sf DisjCoNP}, can be expressed as a statement about provability in the same way. Conjecture~{\\sf TFNP} was, in fact, introduced as a sentence about unprovability in theories in $\\cal T$. \n\nThus a natural way to classify such conjectures is according to the logical complexity of sentences that are claimed to be unprovable. The two most important classes are $\\forall\\Pi^b_1$ and $\\forall\\Sigma^b_1$ (i.e., the sentences of the form: universally quantified $\\Pi^b_1$ and $\\Sigma^b_11$ formulas). Our uniform conjectures are classified as follows:\n\n\\medskip\n$\\forall\\Pi^b_1$ -- {\\sf CON, DisjNP};\n\n\\medskip\n$\\forall\\Sigma^b_1$ -- {\\sf RFN$_1$, TFNP, DisjCoNP}.\n\n\\medskip\n\n\n\\subsection{Some related statements}\n\nSeveral concepts related to our conjectures have been studied. We will present some of these sentences here. We will call them conjectures, since we believe that they are true, but we do not have essentially any supporting argument for their truth.\n\nWe have observed that Conjecture~{\\sf CON$^N$} can be strengthened to Conjecture~{\\sf DisjNP}. Its uniform version, Conjecture~{\\sf CON}, can, furthermore, be strengthened in a different way. Recall that {\\bf UP}, \\emph{unambiguous} {\\bf P}, is the class of languages that are accepted by polynomial time \\emph{nondeterministic} Turing machines that satisfy the property that for every accepted input, there is a \\emph{unique} accepting computation.  K\\\"obler, Messner and Tor\\'an~\\cite{KMT} proved that if there exists a p-optimal proof system, then {\\bf UP} has a complete set with respect to many-one reductions. Hence the following is a strengthening of Conjecture~{\\sf CON}.\n\n\\begin{conjecture}{\\sf UP}\nThere is no complete set, with respect to many-one reductions, in {\\bf UP}.\n\\end{conjecture}\n\nSo far we only talked about proof systems for {\\it TAUT}. In the same way one\ncan define proof systems and polynomial simulations for any set. In\nparticular, a \\emph{proof systems for {\\it SAT}} is a polynomial time\ncomputable function from $\\Sigma^*$ onto {\\it SAT}. There is one\nessential difference between proof systems for {\\it TAUT} and {\\it\n  SAT}---the latter does have polynomially bounded proof systems. In\nfact, the definition of {\\it SAT} itself gives one such proof system; in this\nsystem a satisfying assignment of a formula $\\phi$ is a proof (of the\nsatisfiability of) $\\phi$. This is called the \\emph{standard} proof\nsystem for {\\it SAT}.\n\nHere is an example of a nonstandard proof system $P$ for {\\it SAT}. In\n$P$ a proof of $\\phi$ is either a satisfying assignment, or it is\n$\\phi$ itself in the case when $\\phi$ is a proposition $\\gamma_n$\nexpressing, in a natural way, the fact that $n$ is a composite \nnumber. Note that in the standard proof system the proof of $\\gamma_n$\nencodes a nontrivial factor of $n$. Hence, if the standard proof\nsystem simulated $P$, then factoring would be in polynomial time.\n\nBeyersdorff et al.~\\cite{BKM} proved that the existence of a p-optimal\nproof system for {\\it SAT} implies the existence of a complete\nfunction in {\\bf NPMV}$_t$. \nHence, by our Proposition~\\ref{TFNP-NPMV}, it also implies the existence\nof a complete problem in {\\bf TFNP}. \nTo put the conjecture about complete sets\nin {\\it SAT} into a context, we need the following proposition.\n\n\\bpr\nLet $S\\in\\cal T$ be a theory such that for every \ntheory $T\\in\\cal T$, $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ can be\nconstructed in polynomial time. \nThen there exists a p-optimal proof system for {\\it SAT}.\n\\epr\n\n\\begin{proof}\n  Let $sat(x,y)$ be a $\\Delta^b_1$ formula expressing the fact that\n  $y$ is a satisfying assignment of a propositional formula $x$.  Suppose\n  that $S$ satisfies the assumption of the proposition. We define a\n  proof system $P$ for {\\it SAT} by:\n", "itemtype": "equation", "pos": 77883, "prevtext": "\nLet $(B_0,B_1)$ be an arbitrary disjoint {\\bf NP} pair. Let\n$\\exists^py.\\beta_i(x,y)$ be some $\\Sigma^b_1$ definitions of $B_i$,\n$i=0,1$. Since  $(A_0,A_1)$ is complete, there exists a polynomial\ntime reduction $f$ of $(B_0,B_1)$ to $(A_0,A_1)$. Consider the\nfollowing definitions of $B_i$, $i=0,1$, by $\\Sigma^b_1$ formulas:\n", "index": 55, "text": "\n\\[\n\\exists^py.\\beta_i(x,y)\\wedge\\exists^pz.\\alpha_i(f(x),z).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"\\exists^{p}y.\\beta_{i}(x,y)\\wedge\\exists^{p}z.\\alpha_{i}(f(x),z).\" display=\"block\"><mrow><mrow><mrow><msup><mo>\u2203</mo><mi>p</mi></msup><mi>y</mi></mrow><mo>.</mo><mrow><mrow><msub><mi>\u03b2</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2227</mo><mrow><msup><mo>\u2203</mo><mi>p</mi></msup><mi>z</mi></mrow></mrow><mo>.</mo><mrow><msub><mi>\u03b1</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>f</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nGiven a proof system $f$ for {\\it SAT}, we take $T\\in\\cal T$ such that\nit proves the soundness of $f$, i.e.,\n\\bel{e-sound}\nT\\vdash\\ \\forall y\\exists z.sat(f(y),z).\n\\ee\nBy Corollary~\\ref{l-rfn}, $S$-proofs of $\\exists z.sat(f(\\bar d),z)$\ncan be constructed in polynomial time for every~$d$. Thus, given an\n$f$-proof $d$ of $f(d)$, we can construct in polynomial time a proof\nin~$P$. Hence $P$ is a p-optimal proof system for {\\it SAT}.\n\\end{proof}\n\nThe above two conjectures are related to our main conjectures {\\sf CON} and {\\sf TFNP}. Here is an example of a plausible conjecture that is apparently incomparable with {\\sf CON} and {\\sf TFNP}.\n\n\\begin{conjecture}{\\sf NP$\\cap$coNP}\nThere is no complete set in ${\\bf NP\\cap coNP}$.\n\\end{conjecture}\n\nBeyersdorff et al.~\\cite{BKM} proved that if both {\\it TAUT} and {\\it\n  SAT} have p-optimal proof systems, then there exists a complete set in\n${\\bf NP\\cap coNP}$. Hence Conjecture~{\\sf NP$\\cap$coNP} is above\nConjecture~{\\sf RFN$_1$}. \n\nThe implications between the most important uniform conjectures considered in this paper are\ndepicted in the figure below. Recall that {\\sf CON} is equivalent to the nonexistence of a p-optimal proof system for {\\it TAUT}.\n\n{\\footnotesize\n", "itemtype": "equation", "pos": 82634, "prevtext": "\nIt is clear that they define the sets  $B_i$ correctly and that $T$\nproves that sets defined by these formulas are disjoint.\n\nThe proof of the converse implication is a standard diagonalization\nargument that we have already presented in the proof of\nLemma~\\ref{l-4.1}, so we will be very brief.\n\nLet $T$ be a theory with the property stated in the proposition. For\n$i=0,1$, let $A_i$ be the set of tuples $(x,\\beta_0,\\beta_1,d,a)$ such\nthat \n\\bi\n\\item $\\beta_0$ and $\\beta_1$ are $\\Sigma^b_1$ formulas, $d$ is a\n$T$-proof of the disjointness of the sets defined by $\\beta_0$ and $\\beta_1$,\n$a$ is a nondeterministic time bound for $\\beta_0$ and $\\beta_1$, and\n$\\exists^py.\\beta_i(x,y)$ holds true.\n\\ei\nWe leave to the reader to verify that these conditions define a\ndisjoint {\\bf NP} pair and that every disjoint {\\bf NP} pair is\npolynomially reducible to it.\n\\eprf\nThe non-existence of a complete disjoint {\\bf coNP} pair, Conjecture~{\\sf DisjCoNP}, can be expressed as a statement about provability in the same way. Conjecture~{\\sf TFNP} was, in fact, introduced as a sentence about unprovability in theories in $\\cal T$. \n\nThus a natural way to classify such conjectures is according to the logical complexity of sentences that are claimed to be unprovable. The two most important classes are $\\forall\\Pi^b_1$ and $\\forall\\Sigma^b_1$ (i.e., the sentences of the form: universally quantified $\\Pi^b_1$ and $\\Sigma^b_11$ formulas). Our uniform conjectures are classified as follows:\n\n\\medskip\n$\\forall\\Pi^b_1$ -- {\\sf CON, DisjNP};\n\n\\medskip\n$\\forall\\Sigma^b_1$ -- {\\sf RFN$_1$, TFNP, DisjCoNP}.\n\n\\medskip\n\n\n\\subsection{Some related statements}\n\nSeveral concepts related to our conjectures have been studied. We will present some of these sentences here. We will call them conjectures, since we believe that they are true, but we do not have essentially any supporting argument for their truth.\n\nWe have observed that Conjecture~{\\sf CON$^N$} can be strengthened to Conjecture~{\\sf DisjNP}. Its uniform version, Conjecture~{\\sf CON}, can, furthermore, be strengthened in a different way. Recall that {\\bf UP}, \\emph{unambiguous} {\\bf P}, is the class of languages that are accepted by polynomial time \\emph{nondeterministic} Turing machines that satisfy the property that for every accepted input, there is a \\emph{unique} accepting computation.  K\\\"obler, Messner and Tor\\'an~\\cite{KMT} proved that if there exists a p-optimal proof system, then {\\bf UP} has a complete set with respect to many-one reductions. Hence the following is a strengthening of Conjecture~{\\sf CON}.\n\n\\begin{conjecture}{\\sf UP}\nThere is no complete set, with respect to many-one reductions, in {\\bf UP}.\n\\end{conjecture}\n\nSo far we only talked about proof systems for {\\it TAUT}. In the same way one\ncan define proof systems and polynomial simulations for any set. In\nparticular, a \\emph{proof systems for {\\it SAT}} is a polynomial time\ncomputable function from $\\Sigma^*$ onto {\\it SAT}. There is one\nessential difference between proof systems for {\\it TAUT} and {\\it\n  SAT}---the latter does have polynomially bounded proof systems. In\nfact, the definition of {\\it SAT} itself gives one such proof system; in this\nsystem a satisfying assignment of a formula $\\phi$ is a proof (of the\nsatisfiability of) $\\phi$. This is called the \\emph{standard} proof\nsystem for {\\it SAT}.\n\nHere is an example of a nonstandard proof system $P$ for {\\it SAT}. In\n$P$ a proof of $\\phi$ is either a satisfying assignment, or it is\n$\\phi$ itself in the case when $\\phi$ is a proposition $\\gamma_n$\nexpressing, in a natural way, the fact that $n$ is a composite \nnumber. Note that in the standard proof system the proof of $\\gamma_n$\nencodes a nontrivial factor of $n$. Hence, if the standard proof\nsystem simulated $P$, then factoring would be in polynomial time.\n\nBeyersdorff et al.~\\cite{BKM} proved that the existence of a p-optimal\nproof system for {\\it SAT} implies the existence of a complete\nfunction in {\\bf NPMV}$_t$. \nHence, by our Proposition~\\ref{TFNP-NPMV}, it also implies the existence\nof a complete problem in {\\bf TFNP}. \nTo put the conjecture about complete sets\nin {\\it SAT} into a context, we need the following proposition.\n\n\\bpr\nLet $S\\in\\cal T$ be a theory such that for every \ntheory $T\\in\\cal T$, $S$-proofs of $\\Sigma_1^bRFN_T(\\bar n)$ can be\nconstructed in polynomial time. \nThen there exists a p-optimal proof system for {\\it SAT}.\n\\epr\n\n\\begin{proof}\n  Let $sat(x,y)$ be a $\\Delta^b_1$ formula expressing the fact that\n  $y$ is a satisfying assignment of a propositional formula $x$.  Suppose\n  that $S$ satisfies the assumption of the proposition. We define a\n  proof system $P$ for {\\it SAT} by:\n", "index": 57, "text": "\n\\[\n\\mbox{$y$ is a $P$-proof of $x$ $\\Leftrightarrow$ $y$ is an $S$-proof\n  of $\\exists z.sat(\\bar{x},z)$.} \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m1\" class=\"ltx_Math\" alttext=\"y\" display=\"inline\"><mi>y</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m2\" class=\"ltx_Math\" alttext=\"P\" display=\"inline\"><mi>P</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m3\" class=\"ltx_Math\" alttext=\"x\" display=\"inline\"><mi>x</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m4\" class=\"ltx_Math\" alttext=\"\\Leftrightarrow\" display=\"inline\"><mo>\u21d4</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m5\" class=\"ltx_Math\" alttext=\"y\" display=\"inline\"><mi>y</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m6\" class=\"ltx_Math\" alttext=\"S\" display=\"inline\"><mi>S</mi></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1.m7\" class=\"ltx_Math\" alttext=\"\\exists z.sat(\\bar{x},z)\" display=\"inline\"><mrow><mrow><mo>\u2203</mo><mi>z</mi></mrow><mo>.</mo><mrow><mi>s</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>t</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">\u00af</mo></mover><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\n}\n\n\n\n\n\\subsection{Towards general conjectures}\\label{sec-general}\n\n\nWe will focus on uniform conjectures, because the situation there seems to be clearer.\nWe have seen that our uniform conjectures are statements about unprovability of particular\nsentences. The structure of these sentences is determined by\n\\ben\n\\item some class $\\cal C$ of sentences \n\\item associated with computational\n  problems $\\cal P$, and \n\\item some complexity hierarchy $\\cal H$ of the associated problems.\n\\een\nThe conjectures say that the more difficult the associated\ncomputational problem is, the more difficult is to prove the\nsentence. \n\nConsider, for example, Conjecture~{\\sf DisjNP}. In this conjecture we have \nsentences expressing that two sets defined by\n$\\Sigma^b_1$ sentences are disjoint. These sentences are of the form: \n", "itemtype": "equation", "pos": 83970, "prevtext": "\nGiven a proof system $f$ for {\\it SAT}, we take $T\\in\\cal T$ such that\nit proves the soundness of $f$, i.e.,\n\\bel{e-sound}\nT\\vdash\\ \\forall y\\exists z.sat(f(y),z).\n\\ee\nBy Corollary~\\ref{l-rfn}, $S$-proofs of $\\exists z.sat(f(\\bar d),z)$\ncan be constructed in polynomial time for every~$d$. Thus, given an\n$f$-proof $d$ of $f(d)$, we can construct in polynomial time a proof\nin~$P$. Hence $P$ is a p-optimal proof system for {\\it SAT}.\n\\end{proof}\n\nThe above two conjectures are related to our main conjectures {\\sf CON} and {\\sf TFNP}. Here is an example of a plausible conjecture that is apparently incomparable with {\\sf CON} and {\\sf TFNP}.\n\n\\begin{conjecture}{\\sf NP$\\cap$coNP}\nThere is no complete set in ${\\bf NP\\cap coNP}$.\n\\end{conjecture}\n\nBeyersdorff et al.~\\cite{BKM} proved that if both {\\it TAUT} and {\\it\n  SAT} have p-optimal proof systems, then there exists a complete set in\n${\\bf NP\\cap coNP}$. Hence Conjecture~{\\sf NP$\\cap$coNP} is above\nConjecture~{\\sf RFN$_1$}. \n\nThe implications between the most important uniform conjectures considered in this paper are\ndepicted in the figure below. Recall that {\\sf CON} is equivalent to the nonexistence of a p-optimal proof system for {\\it TAUT}.\n\n{\\footnotesize\n", "index": 59, "text": "\n\\[\\xymatrix@C=5mm{            \n  &&&&& {\\sf DisjCoNP}\\ar[ld]\\\\\n {\\sf DisjNP}\\ar[rd]&{\\sf UP}\\ar[d]& & & {\\sf TFNP}\\ar[ld]&\\\\\n & {\\sf CON} \\ar[rd]&{\\sf NP}\\cap{\\sf coNP}\\ar[d] & {\\sf SAT}\\ar[ld]&&\\\\\n & & {\\sf CON}\\vee{\\sf SAT}\\ar[d]&&&\\\\\n& & {\\sf RFN}_1\\ar[d]&&&\\\\\n& &{\\bf P}\\neq{\\bf NP}&&&\n}\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m1\" class=\"ltx_Math\" alttext=\"\\xymatrix@C=5mm{&amp;&amp;&amp;&amp;&amp;{\\sf DisjCoNP}\\ar[ld]\\\\&#10;{\\sf DisjNP}\\ar[rd]&amp;{\\sf UP}\\ar[d]&amp;&amp;&amp;{\\sf TFNP}\\ar[ld]&amp;\\\\&#10;&amp;{\\sf CON}\\ar[rd]&amp;{\\sf NP}\\cap{\\sf coNP}\\ar[d]&amp;{\\sf SAT}\\ar[ld]&amp;&amp;\\\\&#10;&amp;&amp;{\\sf CON}\\vee{\\sf SAT}\\ar[d]&amp;&amp;&amp;\\\\&#10;&amp;&amp;{\\sf RFN}_{1}\\ar[d]&amp;&amp;&amp;\\\\&#10;&amp;&amp;{\\bf P}\\neq{\\bf NP}&amp;&amp;&amp;}\" display=\"block\"><mrow><mrow><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\xymatrix</mtext></merror><mo>\u2062</mo><mi mathvariant=\"normal\">@</mi><mo>\u2062</mo><mi>C</mi></mrow><mo>=</mo><mrow><mrow><mrow><mn>5</mn><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi>m</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\udda3\ud835\uddc2\ud835\uddcc\ud835\uddc3\ud835\udda2\ud835\uddc8\ud835\uddad\ud835\uddaf</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>l</mi><mo>\u2062</mo><mi>d</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi>\ud835\udda3\ud835\uddc2\ud835\uddcc\ud835\uddc3\ud835\uddad\ud835\uddaf</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>r</mi><mo>\u2062</mo><mi>d</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\uddb4\ud835\uddaf</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>d</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\uddb3\ud835\udda5\ud835\uddad\ud835\uddaf</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>l</mi><mo>\u2062</mo><mi>d</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\udda2\ud835\uddae\ud835\uddad</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>r</mi><mo>\u2062</mo><mi>d</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\uddad\ud835\uddaf</mi></mrow><mo>\u2229</mo><mrow><mi>\ud835\uddbc\ud835\uddc8\ud835\uddad\ud835\uddaf</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>d</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\uddb2\ud835\udda0\ud835\uddb3</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mi>l</mi><mo>\u2062</mo><mi>d</mi></mrow><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\udda2\ud835\uddae\ud835\uddad</mi></mrow></mrow><mo>\u2228</mo><mrow><mi>\ud835\uddb2\ud835\udda0\ud835\uddb3</mi><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>d</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><msub><mi>\ud835\uddb1\ud835\udda5\ud835\uddad</mi><mn>1</mn></msub><mo>\u2062</mo><merror class=\"ltx_ERROR undefined undefined\"><mtext>\\ar</mtext></merror><mo>\u2062</mo><mrow><mo stretchy=\"false\">[</mo><mi>d</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi>\ud835\udc0f</mi></mrow></mrow><mo>\u2260</mo><mrow><mi>\ud835\udc0d\ud835\udc0f</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $\\phi$ and $\\psi$ are $\\Sigma^b_1$ sentences defining the two sets. These sentences are equivalent to universally quantified $\\Pi^b_1$ sentence, but they are just some specific universally quantified $\\Pi^b_1$ sentences. For such sentences, a natural task is, for a given $x$, to decide which of the two $\\neg\\phi(x)$ or $\\neg\\psi(x)$ is true. The complexity hierarchy of the computational problems is defined using polynomial time reductions. \n\nIn Conjecture~{\\sf CON}, the sentences expressing that a propositional proof system $P$ is sound are also universally quantified $\\Pi^b_1$ sentences. They have the form\n", "itemtype": "equation", "pos": 85077, "prevtext": "\n}\n\n\n\n\n\\subsection{Towards general conjectures}\\label{sec-general}\n\n\nWe will focus on uniform conjectures, because the situation there seems to be clearer.\nWe have seen that our uniform conjectures are statements about unprovability of particular\nsentences. The structure of these sentences is determined by\n\\ben\n\\item some class $\\cal C$ of sentences \n\\item associated with computational\n  problems $\\cal P$, and \n\\item some complexity hierarchy $\\cal H$ of the associated problems.\n\\een\nThe conjectures say that the more difficult the associated\ncomputational problem is, the more difficult is to prove the\nsentence. \n\nConsider, for example, Conjecture~{\\sf DisjNP}. In this conjecture we have \nsentences expressing that two sets defined by\n$\\Sigma^b_1$ sentences are disjoint. These sentences are of the form: \n", "index": 61, "text": "\n\\[\n\\forall x(\\neg\\phi(x)\\vee\\neg\\psi(x)),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m1\" class=\"ltx_Math\" alttext=\"\\forall x(\\neg\\phi(x)\\vee\\neg\\psi(x)),\" display=\"block\"><mrow><mrow><mo>\u2200</mo><mrow><mi>x</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><mi>\u03d5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nwhere $proof_P(x,y)$ is a $\\Delta^b_1$ formula expressing that $y$ is\na $P$-proof of $x$. The structure of these sentences is similar, but\nthe length of $y$ in the second formula is not polynomially bounded in the length of $x$.  \nWe associate with these formulas the same computational task, but we use a different kind or reductions to define the hierarchy (in the first case, a reduction can map $x$ to another element, but we do not care about the witnesses of the $\\Sigma^b_1$ formulas; in the\nsecond case, $x$ does not change, but we map a witness $y$ to another\nwitness).  \n\nIdeally, we would like to state a general conjecture from which our current conjectures would follow as special cases. However, to be able to do that, we first need to fully understand\nwhat are the classes $\\cal C$ whose sentences can be associated with computational tasks,\nwhat are the computational problems $\\cal P$, and \nwhat are the complexity hierarchies $\\cal H$.\nSo far we only have examples.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{The role of reductions}\\label{sec8}\n\n\nIn Propositions~\\ref{pr-6.1} and~\\ref{pr-6.2} we saw that conjectures whose statements used reductions can be equivalently stated without referring to any concept of polynomial reduction. In this section we will explain how polynomial reductions naturally appear when we compare the logical strength of sentences.\n\nWhen we are comparing sentences from some class $\\cal C$, we do it\nwith respect to some base theory $T$. Thus for some $\\phi,\\psi\\in\\cal\nC$, we are asking whether $T\\vdash\\phi\\to\\psi$. One can show that at\nleast for some type of sentences and some theory $T$, the provability\nimplies the existence of a reduction.\n\nLet the base theory be $S^1_2$ and the sentences have the form\n$\\forall x\\exists^py.\\phi(x,y)$, where $\\phi$ is $\\Sigma^b_1$. We will\nshow that provability of one sentence from the other implies the\nexistence of a polynomial reduction of one {\\bf TFNP} problem to the\nother. The following is a well-known fact (see~\\cite{hanika}), but we\nwill still give a proof, because we want to argue that it can be\ngeneralized to stronger theories.\n\n\\bpr\nSuppose that $\\N\\models\\forall x\\exists^py.\\phi(x,y)\\wedge\\forall u\\exists^pv.\\psi(u,v)$ and \n\\bel{pr-red}\nS^1_2\\vdash \\forall x\\exists^py.\\phi(x,y)\\to\\forall u\\exists^pv.\\psi(u,v),\n\\ee\nwhere $\\phi$ and $\\psi$ define polynomial time computable relations. Then the {\\bf TFNP} problem defined by $\\psi$ is polynomially reducible to the {\\bf TFNP} problem defined by $\\psi$.\n\\epr\n\\bprf\nThis proposition is an immediate consequence of the following result (see~\\cite{pudlak92}).\n\\bl\nIf $S^1_2\\vdash \\forall x\\exists y\\forall^p z.\\alpha(x,y,z)$, \n\nwhere $\\alpha$ is $\\Pi^b_0$, then for a given $x$, one can compute $y$ such that $\\forall^p z.\\alpha(x,y,z)$ using a polynomial time oracle Turing machine with any oracle that, for a given $x$ and $y$ such that $\\exists^p z.\\neg\\alpha(x,y,z)$ holds true, produces some $z$ such that $\\neg\\alpha(x,y,z)$ holds true.\n\\el\nWrite the implication in~(\\ref{pr-red}) in the following prenex form\n", "itemtype": "equation", "pos": 85743, "prevtext": "\nwhere $\\phi$ and $\\psi$ are $\\Sigma^b_1$ sentences defining the two sets. These sentences are equivalent to universally quantified $\\Pi^b_1$ sentence, but they are just some specific universally quantified $\\Pi^b_1$ sentences. For such sentences, a natural task is, for a given $x$, to decide which of the two $\\neg\\phi(x)$ or $\\neg\\psi(x)$ is true. The complexity hierarchy of the computational problems is defined using polynomial time reductions. \n\nIn Conjecture~{\\sf CON}, the sentences expressing that a propositional proof system $P$ is sound are also universally quantified $\\Pi^b_1$ sentences. They have the form\n", "index": 63, "text": "\n\\[\n\\forall x,y,z({ proof}_P(x,y)\\to sat(x,z)),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m1\" class=\"ltx_Math\" alttext=\"\\forall x,y,z({proof}_{P}(x,y)\\to sat(x,z)),\" display=\"block\"><mrow><mo>\u2200</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>o</mi><msub><mi>f</mi><mi>P</mi></msub><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>s</mi><mi>a</mi><mi>t</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.01487.tex", "nexttext": "\nBy the lemma, there is a polynomial time Turing machine $M$ that computes $x$ and $v$ from a given $u$ using any oracle  that whenever $\\exists y(\\phi(x,y)\\wedge\\neg\\psi(u,v))$ holds true produces a witness for $y$. We want to use an oracle that only produces witnesses for  $\\exists y.\\phi(x,y)$. Clearly, such an oracle suffices. If $M$ asks a query $(x,v)$ such that $\\psi(u,v)$ is true, then we can stop, because we already have a witness for $\\exists^pv.\\psi(u,v)$. If no such query occurs during the computation of $M$, we get $x$ and $v$ such that $\\forall y(\\phi(x,y)\\to\\psi(u,v))$ is true, which is equivalent to $\\exists y.\\phi(x,y)\\to\\psi(u,v)$. But the antecedent is always true, so we have $\\psi(u,v)$.\n\\eprf\n\nIf the base theory $T$ is stronger than $S^1_2$, we believe that\nwe nevertheless get some class of reductions that is probably stronger\nthan polynomial time computable reductions, but still somewhat restricted so that the classes of {\\bf TFNP} equivalent with respect to these reductions do not completely collapse. These reductions should be defined\nusing the provably total search problems of~$T$. \nThe idea is that the provably total polynomial search problems of $S^1_2$ are the problems solvable in polynomial time and this gives us reductions that are polynomial time computations with oracle queries to which we substitute solutions of the problem to which we are reducing the given problem. Similarly, if $\\cal S$ is the class of provably total polynomial search problems of $T$, then provability in $T$ should give us reductions that are problems from $\\cal S$ with oracle queries. A special case of this appeared in~\\cite{BKT14} (not quite explicitly) where the theory was $T^1_2$ and the class of search problems was {\\bf PLS}. Although it may be interesting to study such reductions in general, we believe that they would give the same conjectures if used instead of polynomial reductions.\n\n\n\n\n\n\n\n\n\\section{Conclusions and open problems}\n\nIn this paper we put forward the thesis that there exists a connection between the complexity of problems associated with first order sentences and their logical strength manifested as impossibility to prove them in weak theories. If we interpret this thesis in a broad sense, then the thesis is true; e.g., we cannot prove in a weak theory that some computation stops if the problem requires extremely long time to be solved. However, our argument here is that there may be such a connection already on the very low level, namely in the domain of problems solvable in nondeterministic polynomial time. Since the current state of research into such low complexity classes does not have means to prove separations of low complexity classes, we can only state and compare hypotheses about such a connection. \n\nThere are two basic conjectures which have equivalent formulations and come in some flavors. The first one is about finite consistency statements and was proposed already a long time ago~\\cite{KP}. The second one is more recent and concerns provably total polynomial search problems. We showed how they are related to some weaker statements and some stronger ones. Some of these statements had already been studied before. There are still may problems that need to be solved if we want to fully understand this topic; some are of a fundamental nature, some are more specific. Some problems have already been mentioned in previous sections. Below we briefly mention some more.\n\n\\ben\n\\item The main problem, mentioned in Subsection~\\ref{sec-general}, is to find a general conjecture about incompleteness and computational complexity. The conjectures we studied in this paper should be special cases of it.\n\\item Propose a natural and plausible conjecture that implies two main  Conjectures~{\\sf CON} and~{\\sf TFNP}, or prove that one of these conjectures implies the other, or show that their relativizations are independent. \n\n\\item Construct an oracle with respect to which Conjecture~{\\sf DisjCoNP} is true. Construct oracles that show that relativized conjectures are different or show that they are equivalent for pairs of conjectures presented in this paper. Apparently the only separation that is known is a separation of Conjectures~{\\sf CON} and~{\\sf DisjNP}, see~\\cite{GSSZ}.\n\\item In order to get more evidence for Conjecture~{\\sf TFNP}, characterize provably total polynomial search problems in stronger systems of Bounded Arithmetic. The strongest theory for which a combinatorial characterization has been found is $V^1_2$, see~\\cite{KNT11,BB14}.\n\\item Characterize more canonical pairs of propositional proof systems in order to get more evidence for Conjecture~{\\sf DisjNP}. A combinatorial characterization of the canonical pair has only been found for Resolution, see~\\cite{BPT14}. Characterize canonical pairs of some total polynomial search problems (as defined in this paper) in order to get some evidence for Conjecture~{\\sf DisjCoNP}. Nothing is known in this direction.\n\\item We would also be interested in seeing connections between the non-existence of complete problems in some probabilistic classes and our main conjectures. K\\\"obler et al~\\cite{KMT} proved that if {\\it TAUT$_2$} (or {\\it SAT$_2$}) have a p-optimal proof system, then {\\bf BPP}, {\\bf RP} and {\\bf ZPP} have many-one complete problems. ({\\it TAUT$_2$} and {\\it SAT$_2$} are the sets of $\\Pi_2$ and $\\Sigma_2$ quantified Boolean tautologies.) But most researchers believe that these probabilistic classes do have complete problems, because they are in fact equal to {\\bf P}.\n\\een\n\n\n\\subsection*{Acknowledgment}\nI would like to thank Emil Je\\v{r}\\'abek, Jan Kraj\\'{\\i}\\v{c}ek and Neil Thapen for their useful comments on the draft of this paper.\n\n\n\n\n\n\\begin{thebibliography}{11}\n\n\n\\bibitem{BB10} A. Beckmann and S.R. Buss: Characterizing Definable Search Problems in Bounded Arithmetic via Proof Notations. \n    In: Ways of Proof Theory, Ontos Series in Mathematical Logic, 65--134 (2010)\n\n\\bibitem{BB14} A. Beckmann and S.R. Buss: Improved Witnessing and Local Improvement Principles for Second-Order Bounded Arithmetic. ACM Transactions on Computational Logic 15, 1 Article 2  (2014)\n\\bibitem{BPT14} A. Beckmann, P. Pudl\\'ak and N. Thapen: Parity games and propositional proofs. ACM Transactions on Computational Logic, Vol 15:2, article 17 (2014)\n\n\\bibitem{BKM} O. Beyersdorff, J. K\\\"obler and J. Messner: Nondeterministic functions and the existence of optimal proof systems. Theoretical Computer Science 410:3839-3855 (2009)\n\n\\bibitem{BKT14} S.R. Buss, L. Ko{\\l}odziejczyk and N. Thapen: Fragments of approximate counting. ACM Transactions on Computational Logic, Vol 15:4, article 29 (2014)\n\n\\bibitem{buss86} S.R. Buss: Bounded Arithmetic. Bibliopolis, Naples\n  (1986)\n\\bibitem{BussMints} S.R. Buss and G. Mints: The Complexity of the Disjunction and Existence Properties in Intuitionistic Logic. Pure and Applied Logic 99, 93--104, (1999). \n\\bibitem{cook75} S.A. Cook: Feasibly constructive proofs and the\n  propositional calculus. In: Proc. seventh annual ACM symposium on\n  Theory of computing, ACM New York, 83--97 (1975)\n\\bibitem{cook-reckhow} S.A. Cook and R.A. Reckhow: The relative efficiency of\n  propositional proof systems. J. Symbolic Logic\n  44(1), 36--50, (1979)\n\\bibitem{ehrenfeucht-mycielski} A. Ehrenfeucht and J. Mycielski:\nAbbreviating proofs by adding new axioms. Bulletin of the American Mathematical\nSociety, 77, pp. 366--367 (1971)\n\\bibitem{friedman79} Friedman, H.: On the consistency, completeness and\n  correctness. Unpublished typescript, (1979)\n\n\\bibitem{GSZ} C. Gla{\\ss}er, A. L. Selman, and L. Zhang.  Canonical\n  disjoint NP-pairs of propositional proof\n  systems. Theor. Comput. Sci., 370(1-3):60--73 (2007)\n\\bibitem{GSSZ} C. Gla{\\ss}er, A. L. Selman, S. Sengupta and L. Zhang.\n  Disjoint NP-pairs. SIAM J. Computing, 33(6), 1369-1416\n  (2004)\n\\bibitem{HP} P. H\\'ajek and P. Pudl\\'ak: Metamathematics of first order arithmetic, Springer-Verlag/ASL Perspectives in Logic (1993)\n\\bibitem{hanika} J. Hanika: Herbrandizing Search Problems in Bounded Arithmetic. Mathematical Logic Quarterly 50 (6):577--586 (2004)\n\\bibitem{jpy} Johnson, D., Papadimitriou, C., Yannakakis, M.: How\n  easy is local search? J. Comput. System Sci. 37, 79--100, (1988)\n\\bibitem{Impagliazzo-Krajicek}  J. Kraj\\'{\\i}\\v{c}ek and R. Impagliazzo: A note on conservativity relations among bounded arithmetic theories. Mathematical Logic Quarterly, 48(3), 375--7  (2002)\n\\bibitem{KMT} J. K\\\"obler, J. Messner and J. Tor\\'an: Optimal proof systems imply complete sets for promise classes.\nInformation and Computation 184, 71--92  (2003)\n\\bibitem{KNT11} L. Ko{\\l}odziejczyk, P. Nguyen and N. Thapen. The provably total NP search problems of weak second order bounded arithmetic. Annals of Pure and Applied Logic, Vol 162:6, 419--446 (2011)\n\n\\bibitem{krajicek95} Kraj\\'{\\i}\\v{c}ek, J.: Bounded arithmetic,\n  propositional logic, and complexity theory. Encyclopedia of\n  Mathematics and Its Applications, Vol.60, Cambridge University\n  Press, Cambridge - New York - Melbourne, (1995)\n\\bibitem{krajicek97} J. Kraj\\'{\\i}\\v{c}ek: Interpolation theorems,\n  lower bounds for proof systems, and independence results for bounded\n  arithmetic. J.  Symbolic Logic 62(2), 457--486 (1997)\n\\bibitem{KP} J. Kraj\\'{\\i}\\v{c}ek, P. Pudl\\'ak: Propositional proof systems, the consistency of first order theories and the complexity of computations.  J.  Symbolic Logic 54(3),\n  1063--1079 (1989)\n\\bibitem{kpt} J. Kraj\\'{\\i}\\v{c}ek, P. Pudl\\'ak and G. Takeuti: Bounded\n  arithmetic and polynomial hierarchy. Ann. Pure Appl. Logic\n  52, 143--154 (1991)\n\\bibitem{pudlak86} P. Pudl\\'ak: On the length of proofs of finitistic\n  consistency statements in first order theories. In: Logic Colloquium\n  84. North Holland, 165--196 (1986)\n\\bibitem{pudlak87} P. Pudl\\'ak: Improved bounds to the length of\n  proofs of finitistic consistency statements. In: Contemporary\n  mathematics Vol.65, American Math. Soc., 309-331 (1987)\n\n\\bibitem{pudlak90} P. Pudl\\'ak: A note on bounded arithmetic, Fundamenta Mathematicae, Vol.136, No.2, 86--89  (1990)\n\\bibitem{pudlak92} P. Pudl\\'ak: Some relations between subsystems of arithmetic and the complexity theory, Proc. Conf. Logic from Computer Science, Springer-Verlag, 499--519 (1992)\n\\bibitem{godel100}  P. Pudl\\'ak: G\\\"odel and computations. ACM SIGACT News Vol. 37/4, 13--21 (2006)  \n\\bibitem{kniha} P. Pudl\\'ak: Logical Foundations of Mathematics and Computational Complexity, a gentle introduction. Springer-Verlag, (2013)\n\\bibitem{herbr} P. Pudl\\'ak: On the complexity of finding falsifying assignments for Herbrand disjunctions. Archive for Mathematical Logic 54(7), 769--783 (2015)\n\\bibitem{pudlak-thapen} P. Pudl\\'ak and N. Thapen: Alternating minima and maxima, Nash equilibria and Bounded Arithmetic. Annals of Pure and Applied Logic, Vol 163(5), 604--614 (2012)\n\\bibitem{Razborov94} A.A. Razborov: On provably disjoint NP-pairs. ECCC Technical Report TRR94-006 (1994)\n\\bibitem{skelley-thapen} A. Skelley and N. Thapen: The provably total search problems of bounded arithmetic. Proceedings of the London Mathematical Society, Vol 103(1), 106--138 (2011)\n\\bibitem{smorynski77} C. Smory\\'nski: The incompleteness\n  theorems. In: Barwise, J. (ed.) Handbook of Mathematical\n  Logic. North-Holland, 821--865 (1977)\n\\bibitem{thapen11} N. Thapen: Higher complexity search problems for bounded arithmetic and a formalized no-gap theorem. Archive for Mathematical Logic, Vol 50(7-8), 665--680, (2011)\n\\bibitem{wilkie-paris} A.J. Wilkie and J.B. Paris: On the schema of induction for bounded arithmetical formulas. Annals of Pure and Applied Logic, 35:261--302, (1987)\n\\end{thebibliography}\n\n\n", "itemtype": "equation", "pos": 88844, "prevtext": "\nwhere $proof_P(x,y)$ is a $\\Delta^b_1$ formula expressing that $y$ is\na $P$-proof of $x$. The structure of these sentences is similar, but\nthe length of $y$ in the second formula is not polynomially bounded in the length of $x$.  \nWe associate with these formulas the same computational task, but we use a different kind or reductions to define the hierarchy (in the first case, a reduction can map $x$ to another element, but we do not care about the witnesses of the $\\Sigma^b_1$ formulas; in the\nsecond case, $x$ does not change, but we map a witness $y$ to another\nwitness).  \n\nIdeally, we would like to state a general conjecture from which our current conjectures would follow as special cases. However, to be able to do that, we first need to fully understand\nwhat are the classes $\\cal C$ whose sentences can be associated with computational tasks,\nwhat are the computational problems $\\cal P$, and \nwhat are the complexity hierarchies $\\cal H$.\nSo far we only have examples.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{The role of reductions}\\label{sec8}\n\n\nIn Propositions~\\ref{pr-6.1} and~\\ref{pr-6.2} we saw that conjectures whose statements used reductions can be equivalently stated without referring to any concept of polynomial reduction. In this section we will explain how polynomial reductions naturally appear when we compare the logical strength of sentences.\n\nWhen we are comparing sentences from some class $\\cal C$, we do it\nwith respect to some base theory $T$. Thus for some $\\phi,\\psi\\in\\cal\nC$, we are asking whether $T\\vdash\\phi\\to\\psi$. One can show that at\nleast for some type of sentences and some theory $T$, the provability\nimplies the existence of a reduction.\n\nLet the base theory be $S^1_2$ and the sentences have the form\n$\\forall x\\exists^py.\\phi(x,y)$, where $\\phi$ is $\\Sigma^b_1$. We will\nshow that provability of one sentence from the other implies the\nexistence of a polynomial reduction of one {\\bf TFNP} problem to the\nother. The following is a well-known fact (see~\\cite{hanika}), but we\nwill still give a proof, because we want to argue that it can be\ngeneralized to stronger theories.\n\n\\bpr\nSuppose that $\\N\\models\\forall x\\exists^py.\\phi(x,y)\\wedge\\forall u\\exists^pv.\\psi(u,v)$ and \n\\bel{pr-red}\nS^1_2\\vdash \\forall x\\exists^py.\\phi(x,y)\\to\\forall u\\exists^pv.\\psi(u,v),\n\\ee\nwhere $\\phi$ and $\\psi$ define polynomial time computable relations. Then the {\\bf TFNP} problem defined by $\\psi$ is polynomially reducible to the {\\bf TFNP} problem defined by $\\psi$.\n\\epr\n\\bprf\nThis proposition is an immediate consequence of the following result (see~\\cite{pudlak92}).\n\\bl\nIf $S^1_2\\vdash \\forall x\\exists y\\forall^p z.\\alpha(x,y,z)$, \n\nwhere $\\alpha$ is $\\Pi^b_0$, then for a given $x$, one can compute $y$ such that $\\forall^p z.\\alpha(x,y,z)$ using a polynomial time oracle Turing machine with any oracle that, for a given $x$ and $y$ such that $\\exists^p z.\\neg\\alpha(x,y,z)$ holds true, produces some $z$ such that $\\neg\\alpha(x,y,z)$ holds true.\n\\el\nWrite the implication in~(\\ref{pr-red}) in the following prenex form\n", "index": 65, "text": "\n\\[\n\\forall u\\exists x\\exists v\\forall y(\\phi(x,y)\\to\\psi(u,v)).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m1\" class=\"ltx_Math\" alttext=\"\\forall u\\exists x\\exists v\\forall y(\\phi(x,y)\\to\\psi(u,v)).\" display=\"block\"><mrow><mo>\u2200</mo><mi>u</mi><mo>\u2203</mo><mi>x</mi><mo>\u2203</mo><mi>v</mi><mo>\u2200</mo><mi>y</mi><mrow><mo stretchy=\"false\">(</mo><mi>\u03d5</mi><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2192</mo><mi>\u03c8</mi><mrow><mo stretchy=\"false\">(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>.</mo></mrow></math>", "type": "latex"}]