[{"file": "1601.03378.tex", "nexttext": "\nwhere $|\\mathbb{I}(Y)|$ denotes the cardinality of a set $\\mathbb{I}(Y)$.\n\nThough $k$-anonymity is an effective metric, it is often too simplistic because it does not take underlying probability distributions into account. If among a given cluster, one element is much more probable than all the rest, then it defeats the intuitive privacy offered by this metric. Similarly, $k$-anonymity does not resist adaptive composition attacks~\\cite{ganta2008composition}. Since the formalization of $k$-anonymity, metrics such as $l$-diversity~\\cite{ldiversity} and $t$-closeness~\\cite{tcloseness} have been studied as potential modifications for it. \n\n\n\n\\begin{figure*}\n\\centering\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\columnwidth]{imperfect.png}\n\\caption{}\\label{DPoramA}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\columnwidth]{diffpriv.png}\n\\caption{}\\label{DPoramB}\n\\end{subfigure}\n\\caption{\\textbf{These figures show the intuitions behind general statistically private ORAMs. Fig.~\\ref{DPoramA} shows a way to define a statistical ORAM using KL-divergence as a metric, whereas Fig.~\\ref{DPoramB} shows the intuition behind a differentially private ORAM.}}\\label{fig:imperfectoram}\n\\end{figure*}\n\n\n\n\n\\textbf{2. KL divergence : }Next, we consider first order metrics which take into account the underlying probability distributions on the access sequences. The most natural candidate is Kullback-Leibler divergence\\footnote{Also known as \\textit{information gain} or \\textit{relative entropy}}, which measures the distance between two probability distributions. KL-divergence is formally defined as :\n", "itemtype": "equation", "pos": 13837, "prevtext": "\n\n\n\n\n\n\n\n\\title{Root ORAM: \\\\A Tunable Differentially Private Oblivious RAM}\n\n\\author{\\IEEEauthorblockN{Sameer Wagh}\n\\IEEEauthorblockA{Princeton University\\\\\nswagh@princeton.edu}\n\\and\n\\IEEEauthorblockN{Paul Cuff}\n\\IEEEauthorblockA{Princeton University\\\\\ncuff@princeton.edu}\n\\and\n\\IEEEauthorblockN{Prateek Mittal}\n\\IEEEauthorblockA{Princeton University\\\\\npmittal@princeton.edu}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\maketitle\n\\thispagestyle{plain}\n\\pagestyle{plain}\n\n\n\\IEEEpeerreviewmaketitle\n\n\n\\begin{abstract}\nState-of-the-art mechanisms for oblivious RAM (ORAM) suffer from significant bandwidth overheads (greater than 100x) that impact the throughput and latency of memory accesses. This renders their deployment in high-performance and bandwidth-constrained applications difficult, motivating the design of low-overhead approaches for memory access obfuscation. \n\nWe introduce and formalize the notion of a differentially private ORAM that provides statistical privacy guarantees, and which to the extent of our knowledge, is the first of its kind. The formalization of differentially private ORAM opens up a large design space of low-bandwidth ORAM protocols that can be deployed in bandwidth constrained applications. \n\nWe present Root ORAM, a family of practical ORAMs that provide a tunable trade-off between the desired bandwidth overhead and system security, and that provide the rigorous privacy guarantees of differentially private ORAMs.  Our Root ORAM family can be tuned to achieve application-specific bandwidth constraints, enabling practical deployment, at the cost of statistical privacy guarantees which are quantified under the differential privacy framework. \n\nWe demonstrate the practicality of Root ORAM using theoretical analysis, simulations, as well as real world experiments on Amazon EC2.  Our theoretical analysis rigorously quantifies the privacy offered by Root ORAM, and provably bounds the information leaked from observing memory access patterns. Our experimental analysis shows that the simplest protocol in the Root ORAM  family requires a bandwidth of a mere 10 blocks, at the cost of rigorously quantified security loss, and that this number is independent of the number of outsourced blocks N. This is an order of magnitude improvement over the existing state-of-the-art ORAM schemes such as Path ORAM, which incurs a bandwidth overhead of $10\\cdot \\log N$ blocks.  \n\\end{abstract}\n\n\n\n\\graphicspath{{./Images/}}\n\\DeclareGraphicsExtensions{.pdf,.jpg,.png}\n\\newtheorem{defn}{Definition}\n\n\n\\section{Introduction}\\label{introduction}\n\nCloud storage and computing are important tools to outsource data but have given rise to significant privacy concerns due to the non-local nature of data storage. Though encryption goes a long way in assuring data confidentiality, recent work~\\cite{accesspatterndisclosure,dautrich2013compromising} has shown that encryption is not sufficient. Encryption does not hide memory access patterns; an untrusted storage server can thus perform traffic analysis of memory access patterns to compromise client privacy. The work of Islam \\textit{et al.} has shown the leakage of sensitive keyword information by performing traffic analysis of access patterns over encrypted email~\\cite{accesspatterndisclosure}. Similarly, Dautrich \\textit{et al.} have shown that access patterns over database tuples can leak ordering information~\\cite{dautrich2013compromising}.\n\nOblivious RAM (ORAM), first introduced by Goldreich and Ostrovsky\\cite{goldreichoram,Goldreich:1987:TTS:28395.28416}, is a cryptographic primitive which allows a client to protect its data access pattern from an untrusted server storing the data. Since its introduction, substantial progress has been made by the research community in developing novel and efficient ORAM schemes~\\cite{pathoram,ringoram,gentryoramSC,burstoram,SSSoram,ren15constants,oblivistore}. Recent work has also shown the promise of using ORAMs as a critical component in developing protocols for other cryptographic primitives such as Secure Multi-Party Computation~\\cite{gentryoramSC}.\n\nHowever, ORAM schemes incur a large overhead in terms of bandwidth that renders them impractical. \nFor example, even the most efficient ORAM protocols~\\cite{pathoram,SSSoram,ringoram} incur a logarithmic overhead compared to conventional RAMs (greater than 100x including constants). This significantly impacts the throughput and latency of memory accesses, and presents a bottleneck for real-world deployment of oblivious RAMs in high-performance and bandwidth constrained applications. The lack of low-bandwidth ORAMs, despite considerable efforts from the security community, is an undeniable indicator that we need a fundamentally new approach.\n\nHence, we propose a novel approach for developing practical ORAM protocols that can support even a constant bandwidth overhead compared to conventional RAMs. Our key approach is to trade-off reduction in bandwidth at the cost of privacy offered by the ORAM. We first formalize the notion of a \\emph{differentially private ORAM} that provides statistical privacy guarantees, and which to the extent of our knowledge, is the first of its kind. As the name suggests, we use the differential privacy framework developed by Dwork \\textit{et al.}~\\cite{differentialprivacy} with its $(\\epsilon,\\delta)$-differential privacy modification~\\cite{epsilondelta}. In the current formulation of an ORAM (perfect), the output is computationally indistinguishable for any two input sequences. In a differentially private ORAM, we characterize the effect of a small change in the ORAM input to the change in the probability distribution at the output.\n\nWe present Root ORAM\\footnote{The protocol family is called Root ORAM because in the lowest bandwidth regime, the data structure reduces to just the root and the leaves (tree of depth 1). Refer to Sec.~\\ref{newmodel} for details.}, a family of practical ORAM schemes that provide a tunable trade-off between the desired bandwidth overhead and system security, including a design point that supports constant bandwidth construction and that provide the rigorous privacy guarantees of differentially private ORAMs. The low bandwidth protocols are an order of magnitude improvement over previous work in which the protocols still incur a logarithmic bandwidth~\\cite{pathoram,gentryoramSC,SSSoram}. \n\nThe formalization of a differentially private ORAM opens up a large underlying design space currently not considered by the community. With a rigorously quantified privacy-utility trade-off, we propose Root ORAM as the first step in this direction of statistically private ORAMs. \\\\\n\n\n\n\\subsection{Our Contributions}\nRoot ORAM introduces a number of paradigm shifts in the designing of ORAM protocols while at the same time building on the prevailing ideas of contemporary ORAM constructions\\footnote{This work is inspired by the Path ORAM paper~\\cite{pathoram} and we would like to give the authors of the paper all due credit. At the same time, we would like to bring it to the reader's attention that there are considerable differences between the two protocols as highlighted in section~\\ref{overview}.}. Our main contributions can be summarized as follows : \n\n\\textbf{The notion of a \\emph{differentially private ORAM} : }We formalize the notion of a \\emph{differentially private ORAM}, which to the extent of our knowledge is the first of its kind. Formally defined in Section~\\ref{imperfectoram}, a differentially private ORAM is a way to characterize an ORAM protocol that bounds the information leakage from memory access patterns. \n\n\\textbf{Tunable/parametric protocol family : }In bandwidth constraint applications, large bandwidth overhead ($\\textgreater$100x) of conventional ORAM schemes is be a significant bottleneck. We propose to reduce bandwidth overhead at the cost of a rigorously quantified privacy loss. We provide a new family of ORAM schemes called Root ORAM, that can achieve tunable trade-offs between bandwidth and privacy while at the same time providing security guarantees of differentially private ORAMs. This allows Root ORAM to be tailored as per the needs and constraints of the application, serving as an enabler for practical deployment.  \n\n\\textbf{Security : }We theoretically analyze the security offered by Root ORAM, and prove that Root ORAM provides the rigorous privacy guarantee of differentially private ORAMs. Thus, Root ORAM provably bounds the information leakage from observed memory access patterns. Our theoretical security analysis also gives a novel proof of the security of the Path ORAM protocol in the framework of differentially private ORAMs. We believe that our approach is general, and will be useful to rigorously reason about the security of alternative differentially private ORAM schemes in the future. \n \n\\textbf{Performance : }Root ORAM introduces a new design point with constant bandwidth overhead. The simplest protocol of the family has bandwidth usage per access as low as a constant around 10 data blocks\\footnote{Achieved for $\\lambda = 4$ and $Z=2$.} compared to $10 \\cdot \\log N$ blocks in the case of Path ORAM. At the same time, the server-side storage efficiency can be as high as 1:2, i.e., one fake block per real block outsourced (compared to Path ORAM which uses around 1:4). We implement Root ORAM and demonstrate its practicality using simulations as well as real world experiments on Amazon EC2.  \n\nSome of these are order of magnitude improvements in performance over state-of-the-art, though we would like to remind the reader that these come at the cost of a rigorously quantified privacy loss. Finally, Root ORAM does not assume any server-side computation and uses low, practical amounts of client-side storage at the same time being extremely simple to implement at both the client and the server side.\n\n\n\n\n\n\\subsection{Paper organization}\n\nThe paper is organized as follows : \n\\begin{itemize}\n\\itemsep0em\n\\item We begin by motivating the formulation of ORAMs with statistical privacy guarantees in Section~\\ref{prelimnaries} along with different metrics that we considered.\n\\item Section~\\ref{imperfectoram} formalizes the notion of a differentially private ORAM.\n\\item Section~\\ref{overview} gives an overview of the Root ORAM protocol and Section~\\ref{newmodel} presents a detailed description of the Root ORAM family.\n\\item We theoretically evaluate the security offered by Root ORAM in Section~\\ref{security} and present our systems evaluation in Section~\\ref{systems}.\n\\item Section~\\ref{relatedwork} contrasts Root ORAM with related work.\n\\item Limitations and directions for future work are addressed in Section~\\ref{futurework}.\n\\item Finally, we conclude in Section~\\ref{conclusion}.\n\\end{itemize}\n\\mbox{ }\\\\\n\n\n\\section{Preliminaries: Statistical Privacy}\\label{prelimnaries}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=\\linewidth]{orambox}\n\\caption{\\textbf{A representation of an ORAM. The protocol box translates an input access sequence into an output access sequence.}}\n\\label{fig:orambox}\n\\end{figure}\n\n\nThe significant bandwidth overhead in conventional ORAM schemes necessitates our design of reducing the protocol bandwidth at the cost of rigorously quantified privacy loss. The lack of deployed ORAM schemes despite considerable efforts from the security community to develop low-overhead approaches is a strong indicator that we need a paradigm shift in our approach. To this extent, we formulate the concept of statistical privacy in ORAMs.\n\nIn this section, we give an overview of the notion of a \\textit{differentially private ORAM}. A perfect ORAM roughly\\footnote{We say roughly because ORAMs could leak information such as timing of accesses/access pattern size.} leaks no information about the input access sequence. In other words, we can consider an ORAM to be a black-box with an input sequence as $X$ and an output sequence as $Y$ as shown in Fig.~\\ref{fig:orambox}. An ORAM with perfect privacy would guarantee the independence of $X$ and $Y$. A slightly stronger condition could be to say that the distribution of the output sequence is uniform over its space for any given input\\footnote{This is stronger because conventional definitions of perfect ORAMs involve outputs being computationally indistinguishable which hides a small detail which we shall see in Sec.~\\ref{security}.}. \n\nThe most natural way to extend the latter condition for designing statistically private ORAMs is to consider ORAM schemes that give non-uniform distributions of the output sequences $Y$ (for a given input $X$) and use security metrics that quantify the ``non-uniformness\" of this distribution. This is graphically illustrated in Fig.~\\ref{fig:imperfectoram}, where an attacker aims to guess the original access pattern after observing the output access pattern $o$. Next, we discuss a number of metrics that can be used to quantify the statistical privacy guarantees offered by ORAMs with non-uniform output distributions.\n\n\n\\textbf{1. $k$-Anonymity : }k-Anonymity was first formulated by Sweeney in~\\cite{kanonymity}. It refers to the largest set within which a data point is anonymous. In the ORAM setting, the adversary will try to infer the input sequence of the ORAM after observing its output sequence. Given an outcome, we cluster the set of all inputs into two sets, the set of potential inputs which can lead to the observed sequence, and the set of improbable inputs which cannot lead to the observed sequence. Now if the smallest of the potential input sets is of size $k$ for any observed access pattern, then we can define the ORAM as $k$-anonymous. \n\nMore formally, for a given observed access sequence $Y$, if we denote its potential set by $\\mathbb{I}(Y)$ then we can define an ORAM protocol as $k$-anonymous if \n", "index": 1, "text": "\n\\[\nk \\leq \\min\\limits_{\\forall Y} |\\mathbb{I}(Y)|\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"k\\leq\\min\\limits_{\\forall Y}|\\mathbb{I}(Y)|\" display=\"block\"><mrow><mi>k</mi><mo>\u2264</mo><mrow><munder><mi>min</mi><mrow><mo>\u2200</mo><mi>Y</mi></mrow></munder><mo>\u2061</mo><mrow><mo stretchy=\"false\">|</mo><mrow><mi>\ud835\udd40</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nIn the context of ORAMs, we can define a metric as follows : Given the observed access sequence as $Y$, the attacker has a distribution over the original access sequence (which in general will not be uniform). Denoting this distribution by $P$ and a uniform distribution over the original access sequence as $U$, we can quantify the privacy loss using $\\gamma$ given by,\n\n", "itemtype": "equation", "pos": 15568, "prevtext": "\nwhere $|\\mathbb{I}(Y)|$ denotes the cardinality of a set $\\mathbb{I}(Y)$.\n\nThough $k$-anonymity is an effective metric, it is often too simplistic because it does not take underlying probability distributions into account. If among a given cluster, one element is much more probable than all the rest, then it defeats the intuitive privacy offered by this metric. Similarly, $k$-anonymity does not resist adaptive composition attacks~\\cite{ganta2008composition}. Since the formalization of $k$-anonymity, metrics such as $l$-diversity~\\cite{ldiversity} and $t$-closeness~\\cite{tcloseness} have been studied as potential modifications for it. \n\n\n\n\\begin{figure*}\n\\centering\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\columnwidth]{imperfect.png}\n\\caption{}\\label{DPoramA}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\columnwidth]{diffpriv.png}\n\\caption{}\\label{DPoramB}\n\\end{subfigure}\n\\caption{\\textbf{These figures show the intuitions behind general statistically private ORAMs. Fig.~\\ref{DPoramA} shows a way to define a statistical ORAM using KL-divergence as a metric, whereas Fig.~\\ref{DPoramB} shows the intuition behind a differentially private ORAM.}}\\label{fig:imperfectoram}\n\\end{figure*}\n\n\n\n\n\\textbf{2. KL divergence : }Next, we consider first order metrics which take into account the underlying probability distributions on the access sequences. The most natural candidate is Kullback-Leibler divergence\\footnote{Also known as \\textit{information gain} or \\textit{relative entropy}}, which measures the distance between two probability distributions. KL-divergence is formally defined as :\n", "index": 3, "text": "\n\\[\nD_{KL}(P||Q) = \\sum\\limits_i P(i) \\log \\frac{P(i)}{Q(i)}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"D_{KL}(P||Q)=\\sum\\limits_{i}P(i)\\log\\frac{P(i)}{Q(i)}\" display=\"block\"><mrow><msub><mi>D</mi><mrow><mi>K</mi><mo>\u2062</mo><mi>L</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">|</mo><mi>Q</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder><mi>P</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mi>log</mi><mfrac><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><mi>Q</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mfrac></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nThe KL divergence between a distribution $P$ and a uniform distribution $U$ is directly related to the entropy of the distribution as in Eq.~\\ref{eqn:KLtoShannon}. And hence, KL-divergence metric is directly related to a metric using Shannon entropy.\n\n\n\\textbf{3. Entropy \\& Min-entropy : }Shannon entropy as well as min-entropy are very well studied metrics in information theory\\footnote{Renyi entropy of order $1$ and $\\infty$ respectively.}. They have been used frequently to quantify security and privacy~\\cite{kopf2007information,hubaux2004security,mittal2012information} by different research communities. Formally, these are defined as :\n\n\n", "itemtype": "equation", "pos": 16003, "prevtext": "\nIn the context of ORAMs, we can define a metric as follows : Given the observed access sequence as $Y$, the attacker has a distribution over the original access sequence (which in general will not be uniform). Denoting this distribution by $P$ and a uniform distribution over the original access sequence as $U$, we can quantify the privacy loss using $\\gamma$ given by,\n\n", "index": 5, "text": "\\begin{equation}\n\\gamma = D_{KL}(P||U)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\gamma=D_{KL}(P||U)\" display=\"block\"><mrow><mi>\u03b3</mi><mo>=</mo><msub><mi>D</mi><mrow><mi>K</mi><mo>\u2062</mo><mi>L</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">|</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\n\nIf we denote by $A$ the set of points in the sample space of output access sequences and by $U$ a uniform distribution over this space, then in the context of ORAMs, we can define this metric using the KL-divergence by noting the simple relation between KL-divergence and Shannon entropy.\n\n", "itemtype": "equation", "pos": 16704, "prevtext": "\nThe KL divergence between a distribution $P$ and a uniform distribution $U$ is directly related to the entropy of the distribution as in Eq.~\\ref{eqn:KLtoShannon}. And hence, KL-divergence metric is directly related to a metric using Shannon entropy.\n\n\n\\textbf{3. Entropy \\& Min-entropy : }Shannon entropy as well as min-entropy are very well studied metrics in information theory\\footnote{Renyi entropy of order $1$ and $\\infty$ respectively.}. They have been used frequently to quantify security and privacy~\\cite{kopf2007information,hubaux2004security,mittal2012information} by different research communities. Formally, these are defined as :\n\n\n", "index": 7, "text": "\\begin{align}\n\n\\begin{split}\nH_1(P) = H(P) & = \\sum\\limits_i - P(i) \\log P(i) \\\\\nH_{\\infty}(P) & = - \\log \\max_i P(i)\n\\end{split}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\par&#10;\\begin{split}\\displaystyle H_{1}(P)=H(P)&amp;\\displaystyle=\\sum%&#10;\\limits_{i}-P(i)\\log P(i)\\\\&#10;\\displaystyle H_{\\infty}(P)&amp;\\displaystyle=-\\log\\max_{i}P(i)\\end{split}\" display=\"inline\"><mtable columnspacing=\"0pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"right\"><mrow><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>H</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mi>i</mi></munder></mstyle><mo>-</mo><mrow><mi>P</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mi>log</mi><mo>\u2061</mo><mi>P</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"right\"><mrow><msub><mi>H</mi><mi mathvariant=\"normal\">\u221e</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>=</mo><mrow><mo>-</mo><mrow><mrow><mi>log</mi><mo>\u2061</mo><mrow><munder><mi>max</mi><mi>i</mi></munder><mo>\u2061</mo><mi>P</mi></mrow></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></mtd></mtr></mtable></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nwhere $H(Q)$ is the Shannon entropy of a distribution $Q$. Hence, $H(P)$ can be suitably used to give a metric of the privacy loss in ORAMs.\n\nMin-entropy lower bounds Shannon entropy and can hence be used to derive a lower bounds on statistical security defined using Shannon entropy. Min-entropy has also been used in the past to characterize statistical security~\\cite{shmatikov2006measuring,mittal2012information}. \n\n\n\n\\textbf{4. Differential Privacy : }Differential Privacy is the state-of-the-art privacy metric and there is an emerging consensus among the security and privacy community about its use. First formulated in a seminal paper by Dwork \\textit{et al.}~\\cite{differentialprivacy}, differential privacy was introduced in the context of security for publishing databases~\\cite{nofreelunch,dwork2008differential,dwork2009differential}. We leverage this framework in our setting, and use it to define a metric for quantifying the privacy offered by statistical ORAMs. Differential privacy is defined as follows : \n\n\\vspace{2mm}\n\\begin{defn}\\label{def:differentialprivacy}\n\\bm{$\\epsilon$}-Differential Privacy : \\textit{A randomized algorithm K gives} $\\epsilon$-differential privacy \\textit{if for all data sets $D_1$ and $D_2$ differing on at most one element, and all $S \\subset Range(K)$,}\n\n", "itemtype": "equation", "pos": 17136, "prevtext": "\n\nIf we denote by $A$ the set of points in the sample space of output access sequences and by $U$ a uniform distribution over this space, then in the context of ORAMs, we can define this metric using the KL-divergence by noting the simple relation between KL-divergence and Shannon entropy.\n\n", "index": 9, "text": "\\begin{equation}\\label{eqn:KLtoShannon}\nD_{KL}(P||U) = \\log |A| - H(P)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"D_{KL}(P||U)=\\log|A|-H(P)\" display=\"block\"><mrow><msub><mi>D</mi><mrow><mi>K</mi><mo>\u2062</mo><mi>L</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">|</mo><mo stretchy=\"false\">|</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>log</mi><mo stretchy=\"false\">|</mo><mi>A</mi><mo stretchy=\"false\">|</mo><mo>-</mo><mi>H</mi><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\n\\end{defn}\n\\vspace{2mm}\n\nThe definition characterizes the amplification of input change on the change in the distribution of the output sequence. In other words, if the input is perturbed slightly i.e $|D_1-D_2| = 1$, the output probability distribution changes only slightly. For more in depth reading, we refer the reader to the differential privacy paper by Dwork \\textit{et al.}~\\cite{differentialprivacy}. As we will see later in Sec.~\\ref{security}, $\\epsilon$-differential privacy alone is inadequate to completely capture the ORAM security for subtle reasons\\footnote{For ex: For a fixed stash size, even Path ORAM is not differentially private for any $\\epsilon$. Refer to Sec.~\\ref{attack}.}. It turns out that the extension of differential privacy called $(\\epsilon,\\delta)$-differential privacy is extremely apt and fitting to characterize ORAM security. $(\\epsilon,\\delta)$-Differential Privacy was first defined by Dwork \\textit{et. al.}~\\cite{epsilondelta} and was formalized by Nissim \\textit{et. al.}~\\cite{smoothsensitivity} can be stated as follows :\n\n\\vspace{2mm}\n\\begin{defn}\\label{def:epsilondelta}\n\\bm{$(\\epsilon,\\delta)$}-Differential Privacy : \\textit{A randomized algorithm K is} $(\\epsilon,\\delta)$-differentially private \\textit{if for all data sets $D_1$ and $D_2$ differing on at most one element, and for all $S \\subset Range(K)$,}\n\n", "itemtype": "equation", "pos": 18527, "prevtext": "\nwhere $H(Q)$ is the Shannon entropy of a distribution $Q$. Hence, $H(P)$ can be suitably used to give a metric of the privacy loss in ORAMs.\n\nMin-entropy lower bounds Shannon entropy and can hence be used to derive a lower bounds on statistical security defined using Shannon entropy. Min-entropy has also been used in the past to characterize statistical security~\\cite{shmatikov2006measuring,mittal2012information}. \n\n\n\n\\textbf{4. Differential Privacy : }Differential Privacy is the state-of-the-art privacy metric and there is an emerging consensus among the security and privacy community about its use. First formulated in a seminal paper by Dwork \\textit{et al.}~\\cite{differentialprivacy}, differential privacy was introduced in the context of security for publishing databases~\\cite{nofreelunch,dwork2008differential,dwork2009differential}. We leverage this framework in our setting, and use it to define a metric for quantifying the privacy offered by statistical ORAMs. Differential privacy is defined as follows : \n\n\\vspace{2mm}\n\\begin{defn}\\label{def:differentialprivacy}\n\\bm{$\\epsilon$}-Differential Privacy : \\textit{A randomized algorithm K gives} $\\epsilon$-differential privacy \\textit{if for all data sets $D_1$ and $D_2$ differing on at most one element, and all $S \\subset Range(K)$,}\n\n", "index": 11, "text": "\\begin{equation}\\label{eqn:epsilonDP}\nPr[K(D_1) \\in S] \\leq e^{\\epsilon} \u00c3\u0097 Pr[K(D_2) \\in S]\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"Pr[K(D_{1})\\in S]\\leq e^{\\epsilon}\u00c3\u0097Pr[K(D_{2})\\in S]\" display=\"block\"><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>K</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><msup><mi>e</mi><mi>\u03f5</mi></msup><mi>\u00c3</mi><mi mathvariant=\"normal\">\u0083</mi><mi>\u00c2</mi><mi mathvariant=\"normal\">\u0097</mi><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>K</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\n\\textit{When $\\delta = 0$, the algorithm is $\\epsilon$-differentially private.}\n\\end{defn}\n\\vspace{2mm}\n\n\nBoth $\\epsilon$-differential privacy and $(\\epsilon,\\delta)$-differential privacy have an interesting composability property. Given two independent mechanisms with privacy guarantees $(\\epsilon_1,\\delta_1)$ and $(\\epsilon_2,\\delta_2)$, any function of them is a $(\\epsilon_1+\\epsilon_2,\\delta_1+\\delta_2)$-differentially private mechanism.\n\n\n\n\n\n\n\\section{A Differentially Private ORAM}\\label{imperfectoram}\n\nThe notion of probabilistic security has been commonly used across security/privacy applications in the literature~\\cite{bellare1993efficient,liang2009information}. But in the context of ORAMs, this notion of having statistical privacy has not been rigorously explored. We believe formulating such a framework would greatly expand the ability to develop novel ORAM protocols with low-bandwidth overhead, serving as an enabler for real-world deployment. \n\n\n\nA large number of papers have been published over the last few years in the ORAM domain which adopt quite a few different definitions to quantify ORAM bandwidth. Hence it is important to mention the definition we use in this paper. We will stick to the original and straightforward definition of bandwidth as the average number of blocks transferred for one access~\\cite{burstoram}.\n\n\\vspace{2mm}\n\\begin{defn}\\label{def:bandwidth}\n\\textit{The bandwidth cost of a storage scheme is given by the average number of blocks transferred in order to read or write a single block.}\n\\end{defn}\n\\vspace*{2mm}\n\n\nFormally, an ORAM can be defined as a mechanism (possibly randomized) which takes an input access sequence $\\overrightarrow{y}$ as given below,\n\n", "itemtype": "equation", "pos": 19998, "prevtext": "\n\\end{defn}\n\\vspace{2mm}\n\nThe definition characterizes the amplification of input change on the change in the distribution of the output sequence. In other words, if the input is perturbed slightly i.e $|D_1-D_2| = 1$, the output probability distribution changes only slightly. For more in depth reading, we refer the reader to the differential privacy paper by Dwork \\textit{et al.}~\\cite{differentialprivacy}. As we will see later in Sec.~\\ref{security}, $\\epsilon$-differential privacy alone is inadequate to completely capture the ORAM security for subtle reasons\\footnote{For ex: For a fixed stash size, even Path ORAM is not differentially private for any $\\epsilon$. Refer to Sec.~\\ref{attack}.}. It turns out that the extension of differential privacy called $(\\epsilon,\\delta)$-differential privacy is extremely apt and fitting to characterize ORAM security. $(\\epsilon,\\delta)$-Differential Privacy was first defined by Dwork \\textit{et. al.}~\\cite{epsilondelta} and was formalized by Nissim \\textit{et. al.}~\\cite{smoothsensitivity} can be stated as follows :\n\n\\vspace{2mm}\n\\begin{defn}\\label{def:epsilondelta}\n\\bm{$(\\epsilon,\\delta)$}-Differential Privacy : \\textit{A randomized algorithm K is} $(\\epsilon,\\delta)$-differentially private \\textit{if for all data sets $D_1$ and $D_2$ differing on at most one element, and for all $S \\subset Range(K)$,}\n\n", "index": 13, "text": "\\begin{equation}\\label{eqn:epsilondeltaDP}\nPr[K(D_1) \\in S] \\leq e^{\\epsilon} Pr[K(D_2) \\in S] + \\delta \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"Pr[K(D_{1})\\in S]\\leq e^{\\epsilon}Pr[K(D_{2})\\in S]+\\delta\" display=\"block\"><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>K</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><msup><mi>e</mi><mi>\u03f5</mi></msup><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>K</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mi>\u03b4</mi></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nand outputs a resulting output sequence denoted by ${\\tt ORAM(\\overrightarrow{y})}$. Here $M$ is the length of the access sequence, ${\\tt op_i}$ denotes whether the i-th operation is a read or a write, ${\\tt addr_i}$ denotes the address for that access, and ${\\tt data_i}$ denotes the data (if ${\\tt op_i}$ is a write). Denoting by $|\\overrightarrow{y}|$ the length of the access sequence $\\overrightarrow{y}$, the currently accepted security definition for ORAM security can be summarized as follows :\n\n\\vspace{2mm}\n\\begin{defn}\n\\textbf{(Currently accepted ORAM Security) : } \\textit{Let $\\overrightarrow{y}$ as denoted in Eq.~\\ref{eqn:y}, denote an access sequence. Let ${\\tt ORAM(\\overrightarrow{y})}$ be the resulting randomized data request sequence of an ORAM algorithm. The ORAM protocol guarantees that for any $\\overrightarrow{y}$ and $\\overrightarrow{y}'$, ${\\tt ORAM(\\overrightarrow{y})}$ and ${\\tt ORAM(\\overrightarrow{y}')}$ are computationally indistinguishable if $|\\overrightarrow{y}| = |\\overrightarrow{y}'|$, and also that for any $\\overrightarrow{y}$ the data returned to the client by ORAM is consistent with $\\overrightarrow{y}$ (i.e the ORAM behaves like a valid RAM) with high probability.}\n\\end{defn}\n\\vspace*{2mm}\n\nThe existing frameworks for ORAM security are constructed with complete security at their core~\\cite{pathoram,ringoram,gentryoramSC,burstoram}. There is no natural way to extend these frameworks to incorporate a statistical privacy notion. Hence, we formalize the notion of a \\emph{differentially private ORAM} as follows.\n\n\n\n\\subsection{Formalizing Differentially Private ORAMs}\n\nThe intuition behind a statistically private ORAM is that given any two input sequences that differ by a single access, the distributions of their output sequences should be ``close\". In other words, a differentially private ORAM can be thought of as a mechanism whose output distributions are ``close enough\" if the input sequence is changed slightly. We formally define it as follows :\n\n\\vspace{2mm}\n\\begin{defn}\n\\textbf{Differentially Private ORAM : } \\textit{Let $\\overrightarrow{y}$, as defined in Eq.~\\ref{eqn:y}, denote the input to an ORAM. Let ${\\tt ORAM(\\overrightarrow{y})}$ be the resulting randomized data request sequence of an ORAM algorithm. We say that a ORAM protocol is $(\\epsilon,\\delta)$-differentially private if for all input access sequences $\\overrightarrow{y_1}$ and $\\overrightarrow{y_2}$, which differ in at most one access, the following condition is satisfied by the ORAM protocol,\n\n", "itemtype": "equation", "pos": 21834, "prevtext": "\n\\textit{When $\\delta = 0$, the algorithm is $\\epsilon$-differentially private.}\n\\end{defn}\n\\vspace{2mm}\n\n\nBoth $\\epsilon$-differential privacy and $(\\epsilon,\\delta)$-differential privacy have an interesting composability property. Given two independent mechanisms with privacy guarantees $(\\epsilon_1,\\delta_1)$ and $(\\epsilon_2,\\delta_2)$, any function of them is a $(\\epsilon_1+\\epsilon_2,\\delta_1+\\delta_2)$-differentially private mechanism.\n\n\n\n\n\n\n\\section{A Differentially Private ORAM}\\label{imperfectoram}\n\nThe notion of probabilistic security has been commonly used across security/privacy applications in the literature~\\cite{bellare1993efficient,liang2009information}. But in the context of ORAMs, this notion of having statistical privacy has not been rigorously explored. We believe formulating such a framework would greatly expand the ability to develop novel ORAM protocols with low-bandwidth overhead, serving as an enabler for real-world deployment. \n\n\n\nA large number of papers have been published over the last few years in the ORAM domain which adopt quite a few different definitions to quantify ORAM bandwidth. Hence it is important to mention the definition we use in this paper. We will stick to the original and straightforward definition of bandwidth as the average number of blocks transferred for one access~\\cite{burstoram}.\n\n\\vspace{2mm}\n\\begin{defn}\\label{def:bandwidth}\n\\textit{The bandwidth cost of a storage scheme is given by the average number of blocks transferred in order to read or write a single block.}\n\\end{defn}\n\\vspace*{2mm}\n\n\nFormally, an ORAM can be defined as a mechanism (possibly randomized) which takes an input access sequence $\\overrightarrow{y}$ as given below,\n\n", "index": 15, "text": "\\begin{equation}\\label{eqn:y}\n\\overrightarrow{y} = {\\tt ((op_{M},addr_{M},data_{M}),. . . , (op_1,addr_1,data_1)) }\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"\\overrightarrow{y}={\\tt((op_{M},addr_{M},data_{M}),...,(op_{1},addr_{1},data_{%&#10;1}))}\" display=\"block\"><mrow><mover accent=\"true\"><mi>y</mi><mo>\u2192</mo></mover><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude98\ud835\ude99</mi><mi>\ud835\ude7c</mi></msub><mo>,</mo><msub><mi>\ud835\ude8a\ud835\ude8d\ud835\ude8d\ud835\ude9b</mi><mi>\ud835\ude7c</mi></msub><mo>,</mo><msub><mi>\ud835\ude8d\ud835\ude8a\ud835\ude9d\ud835\ude8a</mi><mi>\ud835\ude7c</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude98\ud835\ude99</mi><mn>\ud835\udff7</mn></msub><mo>,</mo><msub><mi>\ud835\ude8a\ud835\ude8d\ud835\ude8d\ud835\ude9b</mi><mn>\ud835\udff7</mn></msub><mo>,</mo><msub><mi>\ud835\ude8d\ud835\ude8a\ud835\ude9d\ud835\ude8a</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nwhere $S$ is any set of output sequences of the ORAM.}\n\\end{defn}\n\\vspace*{2mm}\n\n\nWe note that the definition does not make any assumption about the size of the output sequences in $S$. Thus, if the input to the ORAM is changed by a single access tuple ${\\tt (op_{i},addr_{i},data_{i})}$, the output distribution does not change significantly. Fig.~\\ref{fig:imperfectoram} graphically represents this intuition. Given the two sequences $r_1$ and $r_2$, the two distributions generated (the red and the blue) are close to each other in the differential privacy sense.\n\n\n\\section{Root ORAM overview}\\label{overview}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.45\\textwidth}{!}\n{\\begin{tabular}{cll|} \\toprule\nSymbol  & Description \\\\\n\\midrule\n$k \\geq 1$        & Model parameter (to tune trade-off)\\\\\n$p = 1-1/2^k$\t\t& Derived model parameter\\\\\n$N = 2^L$        & Number of real data blocks outsourced\\\\\n$Z$        & Number of blocks in each bucket\\\\\n$B$\t\t& Size of each block (in bits)\\\\\n$P(x)$        & Path from leaf $x$ to the root\\\\\n$P(x,i)$\t\t& Node at level $i$ in $P(x)$\\\\\n$x := {\\tt position[a]}$ \t& Data block ${\\tt a}$ is currently mapped to leaf\\\\\n\t\t\t\t\t\t\t\t& $x$ i.e. ${\\tt a}$ resides in some bucket in $P(x)$\\\\\n\\bottomrule \\\\\n\\end{tabular}}\n\\caption{Notation for Root ORAM}\n\\label{table:notationrootoram}\n\\end{table}\n\n\nIn this section, we briefly describe our key design goals and give a high level overview of the Root ORAM protocol. Notation is briefly given in Table~\\ref{table:notationrootoram}.\n\n\\subsection{Design Goals}\n\\subsubsection{Tunable ORAM scheme}We target a tunable architecture with explicit privacy-utility trade-off which can be used to design ORAM protocols for bandwidth constraint applications. In general, we would like be able to tune the protocol parameters based on the systemic constraints and explicitly demonstrate the security-bandwidth trade-off.\n\\subsubsection{Framework for security}We target a protocol that provides rigorous privacy guarantees viz. that of differentially private ORAMs formalized in Sec.~\\ref{imperfectoram}. \n\\subsubsection{Low Storage and Computation}The design should use as low storage as possible both on the client as well as the server side. Similarly, we would like to avoid assuming any server-side computation.\n\n\n\n\\subsection{Approach Overview}\nRoot ORAM protocol can be split into three components, the access, the new mapping and the eviction. These are briefly described below. As Path ORAM is an instantiation of Root ORAM, the protocols are very similar in their structure.\n\nThe server-side storage is a partial binary tree where each node is a bucket which can hold up to $Z$ data blocks. A stash at the client is used to store a small amount of data whenever needed. Data elements are mapped to leaves of the tree and a local mapping is used to store this mapping. \n\n\\textbf{Access : }The main invariant (same as Path ORAM) is that any data block is along the path from the root to the leaf it is mapped or is in the stash. To access a data element, the client looks up the local mapping to find the leaf that the data element is mapped onto. This completes the access part.\n\n\\textbf{New Mapping : }The relevant data block is then read or written with the new data and a new mapping is generated. The crucial difference here is that the new mapping is not uniform among all the leaves, the new mapping is slightly more likely to be be the same as the old mapping than any other random leaf. The exact distribution is given by Eq.~\\ref{eqn:distributionD}.\n\nFinally, new randomized encryptions are generated and all the data is written back with elements being pushed down further in the tree if possible (towards the leaf) and if new elements can be written back to the tree. \n\n\\textbf{Eviction : }The eviction scheme used in Root ORAM is that of fake accesses. The client machine independently sends fake access queries to the server, completely indistinguishable from normal requests, through a Poisson process with parameter $\\lambda$. The eviction process ensures that the stash size remains low. \n\n\n\n\\subsection{Comparison with Path ORAM~\\cite{pathoram}}\nRoot ORAM is inspired by the Path ORAM protocol and we would like to give the authors all due credit. At the same time, in this subsection, we would like to highlight the critical differences between the two papers.\n\n\\textbf{Differentially Private ORAM : }Root ORAM introduces a new rigorous metric to quantify ORAM security, which extends current formalism to include the notion of a statistically private ORAM. We rigorously bound the statistical privacy offered by the Root ORAM family of protocols using this metric.\n\n\n\\textbf{Storage structure : }Root ORAM uses a partial binary tree as the storage structure at the server where the height of the tree is a model parameter $k$. This is represented in Fig~\\ref{fig:rootoram}. The parameter $k$ governs the security-bandwidth trade-off. The Path ORAM protocol on the contrary has a fixed height binary tree (complete binary tree).\n\n\n\\textbf{Tunability : }The ability to tune the protocol as per the system constraints is a stark difference between Root ORAM and Path ORAM. There is no way to optimize Path ORAM when the bandwidth is constrained and statistical security is acceptable. Root ORAM introduces the novel notion of non-uniform mapping, a specific choice which allows Root ORAM to give statistical privacy guarantees. Path ORAM's update mapping scheme then turns out to be simple case of this generalized mapping. \n\nSimply by tuning the parameters, Root ORAM matches or exceeds the performance of Path ORAM. We provide the ability to operate in the low bandwidth regime which Path ORAM cannot support. The eviction scheme allows Root ORAM to achieve perfect security ($\\epsilon = 0$) at even lower bandwidth than the Path ORAM protocol as can be seen in the Fig.~\\ref{fig:tradeoff}. Path ORAM uses a bandwidth of $\\sim 10 \\log N$ data blocks per access\\footnote{For bucket size $Z=5$.} whereas Root ORAM can perform the same with around $\\sim 8 \\log N$.\n\n\n\\textbf{Eviction scheme : }The eviction schemes of the two protocols are very different. Path ORAM relies on a sufficiently large bucket size to achieve its goals. In contrast, Root ORAM uses an eviction scheme of fake accesses. Root ORAM parameters can be tuned to achieve Path ORAM protocol, but the latter is not the lowest bandwidth full security ($\\epsilon=0$) protocol in the Root ORAM family. \n\n\n\\textbf{Multi-dimensional trade-off space : }Root ORAM can be tuned as per the user's requirements not just in the security-bandwidth space but also in terms of the server storage used, and the local stash size required. Thus, Root ORAM offers attractive design points that can support a diverse range of multi-dimensional trade-offs just by tuning its parameters. \n\n\n\n\n\n\n\n\\section{Root ORAM details}\\label{newmodel}\n\nIn this section, we provide the details of Root ORAM. We begin by describing the basics of the protocol. The required notation is tabulated in Table \\ref{table:notationrootoram}.\n\n\\begin{figure*}\n\\center\n\\includegraphics[width=400pt]{rootoram}\n\\caption{\\textbf{\\textit{Root ORAM server storage} : The figure illustrates the server side storage. The level $0$ to $k-1$ form a binary tree and the last level of the tree contains $N = 2^L$ leaves evenly distributed over the binary tree leaves.}}\n\\label{fig:rootoram}\n\\end{figure*}\n\n\n\n\n\\subsection{Server Storage}\n\\textbf{Server Storage :} The server stores data in the form of a partial binary tree consisting of buckets\\footnote{A bucket contains multiple blocks of data storage which can be real or dummy.} as nodes. In other words, given a integer $k$, we first construct a binary tree of depth $k-1$ i.e the root is level $0$ and the lowest level is level $k-1$ (this tree will have $2^{k-1}$ leaves). Then each of the $2^{k-1}$ leaves of this tree has $2^{L-k+1}$ children each (From here on, we shall refer to these $N=2^L$ nodes as the \\emph{leaves} of the tree). This set-up is illustrated in Fig. \\ref{fig:rootoram}.\n\n\n\\textbf{Bucket structure : }Each node is a bucket consisting of $Z$ blocks (each block can either be real or dummy (encryptions of $0$). Note that, the bucket size directly affects the bandwidth of the ORAM scheme and Root ORAM demonstrates practicality of bucket sizes as low as $Z=2$.\n\n\n\\textbf{Path structure : }The leaves are numbered in the set $\\{0,1,. . ., 2^L - 1\\}$. $P(x)$ denotes the path (set of buckets along the way) from leaf $x$ to the root and $P(x,i)$ denotes the bucket in $P(x)$ at level $i$. It is important to emphasize here that the path length in Root ORAM is $(k+1)$ blocks compared to the $(\\log N)+1$ in Path ORAM.\n\n\n\\textbf{Dummy blocks and randomized encryption : }We use the standard padding technique (fill buckets with dummy blocks when needed) along with randomized encryption to ensure indistinguishability of real and dummy blocks.\n\n\n\n\n\n\\subsection{Invariants of the scheme}\n\\textbf{Main Invariant (same as Path ORAM) :} The main invariant is that each \\textit{real} data block ${\\tt a}$ is mapped to a leaf $x := {\\tt position[a]} , x \\in \\{ 0,1,2,. . . 2^L-1\\}$ and at any point in the execution of the ORAM, the real block will be somewhere in a bucket $\\in P(x)$ or in the local Stash.\\footnote{It is important to note that the invariant does not say that the position each data block is uniform over the set of leaves.}\n\n\n\\textbf{Secondary Invariant : }We maintain the secondary invariant that after each access to an element, its new mapping is governed by a constant non-uniform distribution $D$ given by the following equation and shown graphically in Fig.~\\ref{fig:distributionD}.\n\n", "itemtype": "equation", "pos": 24498, "prevtext": "\nand outputs a resulting output sequence denoted by ${\\tt ORAM(\\overrightarrow{y})}$. Here $M$ is the length of the access sequence, ${\\tt op_i}$ denotes whether the i-th operation is a read or a write, ${\\tt addr_i}$ denotes the address for that access, and ${\\tt data_i}$ denotes the data (if ${\\tt op_i}$ is a write). Denoting by $|\\overrightarrow{y}|$ the length of the access sequence $\\overrightarrow{y}$, the currently accepted security definition for ORAM security can be summarized as follows :\n\n\\vspace{2mm}\n\\begin{defn}\n\\textbf{(Currently accepted ORAM Security) : } \\textit{Let $\\overrightarrow{y}$ as denoted in Eq.~\\ref{eqn:y}, denote an access sequence. Let ${\\tt ORAM(\\overrightarrow{y})}$ be the resulting randomized data request sequence of an ORAM algorithm. The ORAM protocol guarantees that for any $\\overrightarrow{y}$ and $\\overrightarrow{y}'$, ${\\tt ORAM(\\overrightarrow{y})}$ and ${\\tt ORAM(\\overrightarrow{y}')}$ are computationally indistinguishable if $|\\overrightarrow{y}| = |\\overrightarrow{y}'|$, and also that for any $\\overrightarrow{y}$ the data returned to the client by ORAM is consistent with $\\overrightarrow{y}$ (i.e the ORAM behaves like a valid RAM) with high probability.}\n\\end{defn}\n\\vspace*{2mm}\n\nThe existing frameworks for ORAM security are constructed with complete security at their core~\\cite{pathoram,ringoram,gentryoramSC,burstoram}. There is no natural way to extend these frameworks to incorporate a statistical privacy notion. Hence, we formalize the notion of a \\emph{differentially private ORAM} as follows.\n\n\n\n\\subsection{Formalizing Differentially Private ORAMs}\n\nThe intuition behind a statistically private ORAM is that given any two input sequences that differ by a single access, the distributions of their output sequences should be ``close\". In other words, a differentially private ORAM can be thought of as a mechanism whose output distributions are ``close enough\" if the input sequence is changed slightly. We formally define it as follows :\n\n\\vspace{2mm}\n\\begin{defn}\n\\textbf{Differentially Private ORAM : } \\textit{Let $\\overrightarrow{y}$, as defined in Eq.~\\ref{eqn:y}, denote the input to an ORAM. Let ${\\tt ORAM(\\overrightarrow{y})}$ be the resulting randomized data request sequence of an ORAM algorithm. We say that a ORAM protocol is $(\\epsilon,\\delta)$-differentially private if for all input access sequences $\\overrightarrow{y_1}$ and $\\overrightarrow{y_2}$, which differ in at most one access, the following condition is satisfied by the ORAM protocol,\n\n", "index": 17, "text": "\\begin{equation}\\label{eqn:DPoram}\nPr[{\\tt ORAM(\\overrightarrow{y_1})} \\in S] \\leq e^{\\epsilon} Pr[{\\tt ORAM(\\overrightarrow{y_2})} \\in S] + \\delta \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"Pr[{\\tt ORAM(\\overrightarrow{y_{1}})}\\in S]\\leq e^{\\epsilon}Pr[{\\tt ORAM(%&#10;\\overrightarrow{y_{2}})}\\in S]+\\delta\" display=\"block\"><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><msub><mi>\ud835\udea2</mi><mn>\ud835\udff7</mn></msub><mo>\u2192</mo></mover><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2264</mo><msup><mi>e</mi><mi>\u03f5</mi></msup><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><msub><mi>\ud835\udea2</mi><mn>\ud835\udff8</mn></msub><mo>\u2192</mo></mover><mo stretchy=\"false\">)</mo></mrow><mo>\u2208</mo><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mi>\u03b4</mi></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nWhere $P_{z,x}$ is the probability that an element accessed from leaf $x$ is mapped to a leaf $z$, $\\delta_{ij}$ is the Kronecker delta\\footnote{Kronecker delta is defined as \n\n", "itemtype": "equation", "pos": 34336, "prevtext": "\nwhere $S$ is any set of output sequences of the ORAM.}\n\\end{defn}\n\\vspace*{2mm}\n\n\nWe note that the definition does not make any assumption about the size of the output sequences in $S$. Thus, if the input to the ORAM is changed by a single access tuple ${\\tt (op_{i},addr_{i},data_{i})}$, the output distribution does not change significantly. Fig.~\\ref{fig:imperfectoram} graphically represents this intuition. Given the two sequences $r_1$ and $r_2$, the two distributions generated (the red and the blue) are close to each other in the differential privacy sense.\n\n\n\\section{Root ORAM overview}\\label{overview}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.45\\textwidth}{!}\n{\\begin{tabular}{cll|} \\toprule\nSymbol  & Description \\\\\n\\midrule\n$k \\geq 1$        & Model parameter (to tune trade-off)\\\\\n$p = 1-1/2^k$\t\t& Derived model parameter\\\\\n$N = 2^L$        & Number of real data blocks outsourced\\\\\n$Z$        & Number of blocks in each bucket\\\\\n$B$\t\t& Size of each block (in bits)\\\\\n$P(x)$        & Path from leaf $x$ to the root\\\\\n$P(x,i)$\t\t& Node at level $i$ in $P(x)$\\\\\n$x := {\\tt position[a]}$ \t& Data block ${\\tt a}$ is currently mapped to leaf\\\\\n\t\t\t\t\t\t\t\t& $x$ i.e. ${\\tt a}$ resides in some bucket in $P(x)$\\\\\n\\bottomrule \\\\\n\\end{tabular}}\n\\caption{Notation for Root ORAM}\n\\label{table:notationrootoram}\n\\end{table}\n\n\nIn this section, we briefly describe our key design goals and give a high level overview of the Root ORAM protocol. Notation is briefly given in Table~\\ref{table:notationrootoram}.\n\n\\subsection{Design Goals}\n\\subsubsection{Tunable ORAM scheme}We target a tunable architecture with explicit privacy-utility trade-off which can be used to design ORAM protocols for bandwidth constraint applications. In general, we would like be able to tune the protocol parameters based on the systemic constraints and explicitly demonstrate the security-bandwidth trade-off.\n\\subsubsection{Framework for security}We target a protocol that provides rigorous privacy guarantees viz. that of differentially private ORAMs formalized in Sec.~\\ref{imperfectoram}. \n\\subsubsection{Low Storage and Computation}The design should use as low storage as possible both on the client as well as the server side. Similarly, we would like to avoid assuming any server-side computation.\n\n\n\n\\subsection{Approach Overview}\nRoot ORAM protocol can be split into three components, the access, the new mapping and the eviction. These are briefly described below. As Path ORAM is an instantiation of Root ORAM, the protocols are very similar in their structure.\n\nThe server-side storage is a partial binary tree where each node is a bucket which can hold up to $Z$ data blocks. A stash at the client is used to store a small amount of data whenever needed. Data elements are mapped to leaves of the tree and a local mapping is used to store this mapping. \n\n\\textbf{Access : }The main invariant (same as Path ORAM) is that any data block is along the path from the root to the leaf it is mapped or is in the stash. To access a data element, the client looks up the local mapping to find the leaf that the data element is mapped onto. This completes the access part.\n\n\\textbf{New Mapping : }The relevant data block is then read or written with the new data and a new mapping is generated. The crucial difference here is that the new mapping is not uniform among all the leaves, the new mapping is slightly more likely to be be the same as the old mapping than any other random leaf. The exact distribution is given by Eq.~\\ref{eqn:distributionD}.\n\nFinally, new randomized encryptions are generated and all the data is written back with elements being pushed down further in the tree if possible (towards the leaf) and if new elements can be written back to the tree. \n\n\\textbf{Eviction : }The eviction scheme used in Root ORAM is that of fake accesses. The client machine independently sends fake access queries to the server, completely indistinguishable from normal requests, through a Poisson process with parameter $\\lambda$. The eviction process ensures that the stash size remains low. \n\n\n\n\\subsection{Comparison with Path ORAM~\\cite{pathoram}}\nRoot ORAM is inspired by the Path ORAM protocol and we would like to give the authors all due credit. At the same time, in this subsection, we would like to highlight the critical differences between the two papers.\n\n\\textbf{Differentially Private ORAM : }Root ORAM introduces a new rigorous metric to quantify ORAM security, which extends current formalism to include the notion of a statistically private ORAM. We rigorously bound the statistical privacy offered by the Root ORAM family of protocols using this metric.\n\n\n\\textbf{Storage structure : }Root ORAM uses a partial binary tree as the storage structure at the server where the height of the tree is a model parameter $k$. This is represented in Fig~\\ref{fig:rootoram}. The parameter $k$ governs the security-bandwidth trade-off. The Path ORAM protocol on the contrary has a fixed height binary tree (complete binary tree).\n\n\n\\textbf{Tunability : }The ability to tune the protocol as per the system constraints is a stark difference between Root ORAM and Path ORAM. There is no way to optimize Path ORAM when the bandwidth is constrained and statistical security is acceptable. Root ORAM introduces the novel notion of non-uniform mapping, a specific choice which allows Root ORAM to give statistical privacy guarantees. Path ORAM's update mapping scheme then turns out to be simple case of this generalized mapping. \n\nSimply by tuning the parameters, Root ORAM matches or exceeds the performance of Path ORAM. We provide the ability to operate in the low bandwidth regime which Path ORAM cannot support. The eviction scheme allows Root ORAM to achieve perfect security ($\\epsilon = 0$) at even lower bandwidth than the Path ORAM protocol as can be seen in the Fig.~\\ref{fig:tradeoff}. Path ORAM uses a bandwidth of $\\sim 10 \\log N$ data blocks per access\\footnote{For bucket size $Z=5$.} whereas Root ORAM can perform the same with around $\\sim 8 \\log N$.\n\n\n\\textbf{Eviction scheme : }The eviction schemes of the two protocols are very different. Path ORAM relies on a sufficiently large bucket size to achieve its goals. In contrast, Root ORAM uses an eviction scheme of fake accesses. Root ORAM parameters can be tuned to achieve Path ORAM protocol, but the latter is not the lowest bandwidth full security ($\\epsilon=0$) protocol in the Root ORAM family. \n\n\n\\textbf{Multi-dimensional trade-off space : }Root ORAM can be tuned as per the user's requirements not just in the security-bandwidth space but also in terms of the server storage used, and the local stash size required. Thus, Root ORAM offers attractive design points that can support a diverse range of multi-dimensional trade-offs just by tuning its parameters. \n\n\n\n\n\n\n\n\\section{Root ORAM details}\\label{newmodel}\n\nIn this section, we provide the details of Root ORAM. We begin by describing the basics of the protocol. The required notation is tabulated in Table \\ref{table:notationrootoram}.\n\n\\begin{figure*}\n\\center\n\\includegraphics[width=400pt]{rootoram}\n\\caption{\\textbf{\\textit{Root ORAM server storage} : The figure illustrates the server side storage. The level $0$ to $k-1$ form a binary tree and the last level of the tree contains $N = 2^L$ leaves evenly distributed over the binary tree leaves.}}\n\\label{fig:rootoram}\n\\end{figure*}\n\n\n\n\n\\subsection{Server Storage}\n\\textbf{Server Storage :} The server stores data in the form of a partial binary tree consisting of buckets\\footnote{A bucket contains multiple blocks of data storage which can be real or dummy.} as nodes. In other words, given a integer $k$, we first construct a binary tree of depth $k-1$ i.e the root is level $0$ and the lowest level is level $k-1$ (this tree will have $2^{k-1}$ leaves). Then each of the $2^{k-1}$ leaves of this tree has $2^{L-k+1}$ children each (From here on, we shall refer to these $N=2^L$ nodes as the \\emph{leaves} of the tree). This set-up is illustrated in Fig. \\ref{fig:rootoram}.\n\n\n\\textbf{Bucket structure : }Each node is a bucket consisting of $Z$ blocks (each block can either be real or dummy (encryptions of $0$). Note that, the bucket size directly affects the bandwidth of the ORAM scheme and Root ORAM demonstrates practicality of bucket sizes as low as $Z=2$.\n\n\n\\textbf{Path structure : }The leaves are numbered in the set $\\{0,1,. . ., 2^L - 1\\}$. $P(x)$ denotes the path (set of buckets along the way) from leaf $x$ to the root and $P(x,i)$ denotes the bucket in $P(x)$ at level $i$. It is important to emphasize here that the path length in Root ORAM is $(k+1)$ blocks compared to the $(\\log N)+1$ in Path ORAM.\n\n\n\\textbf{Dummy blocks and randomized encryption : }We use the standard padding technique (fill buckets with dummy blocks when needed) along with randomized encryption to ensure indistinguishability of real and dummy blocks.\n\n\n\n\n\n\\subsection{Invariants of the scheme}\n\\textbf{Main Invariant (same as Path ORAM) :} The main invariant is that each \\textit{real} data block ${\\tt a}$ is mapped to a leaf $x := {\\tt position[a]} , x \\in \\{ 0,1,2,. . . 2^L-1\\}$ and at any point in the execution of the ORAM, the real block will be somewhere in a bucket $\\in P(x)$ or in the local Stash.\\footnote{It is important to note that the invariant does not say that the position each data block is uniform over the set of leaves.}\n\n\n\\textbf{Secondary Invariant : }We maintain the secondary invariant that after each access to an element, its new mapping is governed by a constant non-uniform distribution $D$ given by the following equation and shown graphically in Fig.~\\ref{fig:distributionD}.\n\n", "index": 19, "text": "\\begin{equation}\\label{eqn:distributionD}\nP_{z,x} = p_{2} + (p_{1} - p_{2}) \\delta_{zx}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"P_{z,x}=p_{2}+(p_{1}-p_{2})\\delta_{zx}\" display=\"block\"><mrow><msub><mi>P</mi><mrow><mi>z</mi><mo>,</mo><mi>x</mi></mrow></msub><mo>=</mo><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>-</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03b4</mi><mrow><mi>z</mi><mo>\u2062</mo><mi>x</mi></mrow></msub></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "}, $p_{1} = (1-p)$ and $p_{2} = p/(N-1)$ where $p$ is the model parameter probability as defined in Table.~\\ref{table:notationrootoram}.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{distributionD}\n\\caption{\\textbf{The new position of a data block is in general non-uniform according to this distribution. Note that $p = 1-2^{-k}$ and hence, the distribution reduces to uniform if $k=L$.}}\n\\label{fig:distributionD}\n\\end{figure}\n\n\n\n\\subsection{Client Storage}\n\\textbf{Position Map : }The client side stores a position map which maps each real data block to a leaf at the server side tree. This can be stored recursively by the technique introduced in the Path ORAM paper~\\cite{pathoram}. \n\n\\textbf{Stash : }As in the Path ORAM protocol, the client maintains a local Stash, which is a small amount of storage locally at the client. The purpose of the stash is to store overflown data blocks locally. \n\n\n\n\n\\subsection{Main idea}\nThe main idea of the protocol is very simple, we read data along a path, try to write data back to the same path (with some modifications and new encryptions) and if there is insufficient storage, we retain those overflown data elements back in the local Stash.\n\nAlong with this, there is an independent access process of fake accesses\\footnote{This is the similar to the eviction scheme described in~\\cite{ren2013design,logN3} with the crucial difference that our fake accesses are completely indistinguishable from real accesses.}. These accesses are made by the user to the server and are indistinguishable from real accesses. Fake accesses are drawn from a Poisson process with a parameter $\\lambda$. It is important to note that the real access made by the client and the fake accesses by the client machine are exactly the same and hence are indistinguishable from the server\u00e2\u0080\u0099s perspective.\n\n\n\n\n\\subsection{Details of the protocol}\n\nAn access is defined as a 3-tuple \n\\begin{displaymath}\n\\begin{tt}\nAccess_i = (data_i, element_i, operation_i)\n\\end{tt}\n\\end{displaymath}\n\nFor a real access, given a particular access 3-tuple, the user finds the mapping of the data block needed using his local position map. He then requests the whole path of that leaf from the server tree. After processing the data and generating new randomized encryptions, the user writes the data back to the tree with the element that was accessed at a new location along the path. But the key idea here is that the element that was accessed has a non-uniform distribution\\footnote{The distribution becomes uniform if $k = L = \\log N$.} of it being mapped to other leaves. It is more likely to be mapped to the same leaf than to others and the probabilities involved are decided by the security parameter $k$.\n\nThe broader picture of the protocol is as follows. The client systems makes real as well as fake accesses to the server. The real access is as described in the previous paragraph. There is a parameter $\\lambda$ which controls the amount of fake accesses. One way of implementing the protocol is in the following way.\\footnote{It should be noted that the code has been structured in the following way for clarity of understanding and hence can be optimized in a number of ways.} \\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{Access(${\\tt op,a,data^*)}$ :}]\n\\item[]\n\\While{ORAM is under use} \n\t\\State $\\alpha \\leftarrow$ Poisson($\\lambda$)\n\t\\For {$i = 1:\\alpha$}\n\t\t\\State normal\\_access(${\\tt a}$)\n\t\\EndFor\n\t\\State fake\\_access()\n\\EndWhile \n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\\textbf{normal\\_access(a) : }A normal access consists of the following functions in order: read(${\\tt a}$), push\\_down(${\\tt position[a]}$), update\\_mapping(${\\tt a}$) and finally a write(${\\tt a}$). \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\textbf{read(${\\tt a}$) : }The reading phase is the same as that in Path ORAM; Using the local client side mapping, the client finds out the leaf to which the data element ${\\tt a}$ is currently mapped i.e find $x$ such that $x:= {\\tt position[a]}$. We then request all the data blocks in the buckets along path $P(x)$. The invariant ensures that the client can retrieve ${\\tt a}$, its data element, from these. This completes the reading phase of the protocol. \\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{read(${\\tt a}$) :}]\n\\item[]\n\\State $x \\leftarrow {\\tt position[a]}$\n\\item[]\n\\For {$i \\in \\{0,1,...,k\\}$}\n\t\\State $S \\leftarrow S \\ \\cup \\ $ReadBucket$(P(x,i))$\n\\EndFor\n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\textbf{update\\_mapping(${\\tt a}$) : }After reading a data block, we modify its mapping using the distribution mentioned in Eq.\\ref{eqn:distributionD} i.e update\\_mapping keeps the mapping same with probability $(1-p)$ and with the remaining probability changes it to a uniformly random leaf among the remaining leaves.\\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{update\\_mapping(${\\tt a}$) :}]\n\\item[]\n\\State $x \\leftarrow {\\tt position[a]}$\n\\If {Bernoulli(p) = 0}\n\t\\State \\Return $x$\n\\Else\n\t\\State \\Return UniformRandom$\\left( \\{0,1,2,. . 2^L {\\scalebox{0.75}[1.0]{$-$}} 1\\} \\setminus \\{{x}\\} \\right)$\n\\EndIf\n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\n\\textbf{push\\_down(${\\tt position[a]}$) : }When any path is accessed, this function tries to place any data blocks along the path $P({\\tt position[a]}$) or in the Stash to lower positions on the same path if possible.\n\n\n\\textbf{write(a) : }Once the mapping is updated, say initially $x := {\\tt position[a]}$ and after updating the mapping $z := {\\tt position[a]}$, we try to write the data block back into the bucket which is the lowest intersection of the two paths in consideration i.e. lowest bucket in $P(x) \\bigcap P(z)$ (with the convention that bucket with the highest level number is the root at level $0$) which has an empty/dummy block.\n\n\n\\textbf{fake\\_access() : }A fake access is issued to push back elements from the stash to the tree.  More precisely, a fake access is issued on a non-empty stash. One data block, say ${\\tt a'}$, is chosen at random from those in the Stash and a normal access is performed on ${\\tt a'}$, i.e., : read(${\\tt a'}$) followed by push\\_down(${\\tt position[a']}$) followed by an update\\_mapping(${\\tt a'}$) followed by a write(${\\tt a'}$).\\\\\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Theoretical evaluation}\\label{security}\n\nIn this section, we shall state our main theorems, their proofs and a few interesting special cases.\n\n\\vspace{2mm}\n\\begin{theorem}[\\textbf{Main theorem}]\\label{thm:main}\n\\textbf{Given a stash size $C$, the Root ORAM with parameters $k,Z$ and $\\lambda$ is $(\\epsilon, \\delta)$-differentially private for $\\epsilon = 2 \\log \\left( \\frac{N-1}{2^k - 1} \\right)$ and $\\delta = 0.5^{M_k}$ where $M_k = (C+Z(k+1)+1)$}\n\\end{theorem}\n\\vspace*{2mm}\n\n\n\\textbf{Proof : }The theorem has two parts, the $\\epsilon$ bound and the $\\delta$ bound. Firstly, we give a brief insight into the two security parameters $\\epsilon$ and $\\delta$. The proof is then structured as follows : \n\n\\textbf{The $\\epsilon$ bound :}\n\\begin{itemize}\n\\itemsep0em\n\\item We set up the differential privacy framework in the ORAM setting.\n\\item Then we set up the probability evaluation model which takes the real and observed access sequences as inputs and finds the probability of that real sequence leading to that output sequence by the ORAM. \n\\item Finally, we compute the maximum change that one access in the input sequence can have on the probability of the output sequence over all possible output sequences. \n\\item These together give the $\\epsilon$ bound.\n\\end{itemize}\n\n\\textbf{The $\\delta$ bound :}\n\\begin{itemize}\n\\itemsep0em\n\\item We begin by showing the need for $\\delta$ in the security framework. \n\\item We then conservatively evaluate a bound on $\\delta$.\n\\end{itemize}\n\\mbox{ }\\\\\n\n$\\epsilon$ and $\\delta$ can be interpret as follows: Given an ORAM scheme with an unbounded amount of local stash, we show that such a scheme is $\\epsilon$-differentially private. But the moment we introduce a finite amount of stash, this is no longer true as is shown in Sec.~\\ref{attack}. And the privacy loss under such a situation is precisely the quantity that is bounded by $\\delta$. \n\nIn the context of Path ORAM, $\\delta$ characterizes the privacy loss if the stash size exceeds its bounds. Another quantity of interest is the probability of the stash overflow. Similarly, in Root ORAM, $\\delta$ quantifies the privacy loss if the stash size is exceeded.\n\n\n\\begin{center}\n\\textbf{The $\\epsilon$ bound}\n\\end{center}\n\n\\subsection{Framework set-up}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.45\\textwidth}{!}\n{\\begin{tabular}{cll|} \\toprule\nSymbol  & Description \\\\\n\\midrule\n$k \\geq 1$        & Model parameter\\\\\n$p = 1-1/2^k$\t\t& Derived model parameter\\\\\n$N = 2^L$        & Number of real data blocks outsourced\\\\\n$M$        & Access pattern size\\\\\n$C$ \t\t& Stash size\\\\\n$p_1$\t& $(1-p)$\\\\\n$p_2$ \t&  $p/(N-1)$\\\\\n$M_k$\t\t& $M_k = Z(k+1) + C$\\\\\n\\bottomrule \\\\\n\\end{tabular}}\n\\caption{Notation for analysis of Root ORAM}\n\\label{table:analysis}\n\\end{table}\n\n\nThe notation used is specified in Table~\\ref{table:analysis}. Recall that a fake access in Root ORAM is indistinguishable from a real access. Hence, for our theoretical analysis, we make a conservative assumption that the sequence of accesses requested by the client machine were all real accesses. In other words, among M access, some are real and some are fake. We conservatively assume that these can be distinguished. In practice, the security offered by our approach is higher since the untrusted server storage cannot differentiate fake accesses from real accesses in practice.\n\nMore formally, let $f_i$ denote the set of fake accesses and $r_i$ denotes the real set of accesses made by the ORAM. We denote by $R_i$, the complete set of accesses made ($r_i$ along with $f_i$). Thus we have that : \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nWhere $P_{z,x}$ is the probability that an element accessed from leaf $x$ is mapped to a leaf $z$, $\\delta_{ij}$ is the Kronecker delta\\footnote{Kronecker delta is defined as \n\n", "index": 21, "text": "\\begin{equation*}\n\\delta_{ij} = \n\\begin{cases}\n0 \t& \\text{if $i \\neq j$}\\\\\n1\t& \\text{if $i=j$}\n\\end{cases}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\delta_{ij}=\\begin{cases}0&amp;\\text{if $i\\neq j$}\\\\&#10;1&amp;\\text{if $i=j$}\\end{cases}\" display=\"block\"><mrow><msub><mi>\u03b4</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>i</mi><mo>\u2260</mo><mi>j</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nwhere ${\\tt \\overline{ORAM}(R_i)}$ denotes the ORAM protocol output on sequence $R_i$ without any additional fake accesses. But to prove the bounds of differential privacy in the theorem, we need to bound the following term :\n", "itemtype": "equation", "pos": 44867, "prevtext": "}, $p_{1} = (1-p)$ and $p_{2} = p/(N-1)$ where $p$ is the model parameter probability as defined in Table.~\\ref{table:notationrootoram}.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{distributionD}\n\\caption{\\textbf{The new position of a data block is in general non-uniform according to this distribution. Note that $p = 1-2^{-k}$ and hence, the distribution reduces to uniform if $k=L$.}}\n\\label{fig:distributionD}\n\\end{figure}\n\n\n\n\\subsection{Client Storage}\n\\textbf{Position Map : }The client side stores a position map which maps each real data block to a leaf at the server side tree. This can be stored recursively by the technique introduced in the Path ORAM paper~\\cite{pathoram}. \n\n\\textbf{Stash : }As in the Path ORAM protocol, the client maintains a local Stash, which is a small amount of storage locally at the client. The purpose of the stash is to store overflown data blocks locally. \n\n\n\n\n\\subsection{Main idea}\nThe main idea of the protocol is very simple, we read data along a path, try to write data back to the same path (with some modifications and new encryptions) and if there is insufficient storage, we retain those overflown data elements back in the local Stash.\n\nAlong with this, there is an independent access process of fake accesses\\footnote{This is the similar to the eviction scheme described in~\\cite{ren2013design,logN3} with the crucial difference that our fake accesses are completely indistinguishable from real accesses.}. These accesses are made by the user to the server and are indistinguishable from real accesses. Fake accesses are drawn from a Poisson process with a parameter $\\lambda$. It is important to note that the real access made by the client and the fake accesses by the client machine are exactly the same and hence are indistinguishable from the server\u00e2\u0080\u0099s perspective.\n\n\n\n\n\\subsection{Details of the protocol}\n\nAn access is defined as a 3-tuple \n\\begin{displaymath}\n\\begin{tt}\nAccess_i = (data_i, element_i, operation_i)\n\\end{tt}\n\\end{displaymath}\n\nFor a real access, given a particular access 3-tuple, the user finds the mapping of the data block needed using his local position map. He then requests the whole path of that leaf from the server tree. After processing the data and generating new randomized encryptions, the user writes the data back to the tree with the element that was accessed at a new location along the path. But the key idea here is that the element that was accessed has a non-uniform distribution\\footnote{The distribution becomes uniform if $k = L = \\log N$.} of it being mapped to other leaves. It is more likely to be mapped to the same leaf than to others and the probabilities involved are decided by the security parameter $k$.\n\nThe broader picture of the protocol is as follows. The client systems makes real as well as fake accesses to the server. The real access is as described in the previous paragraph. There is a parameter $\\lambda$ which controls the amount of fake accesses. One way of implementing the protocol is in the following way.\\footnote{It should be noted that the code has been structured in the following way for clarity of understanding and hence can be optimized in a number of ways.} \\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{Access(${\\tt op,a,data^*)}$ :}]\n\\item[]\n\\While{ORAM is under use} \n\t\\State $\\alpha \\leftarrow$ Poisson($\\lambda$)\n\t\\For {$i = 1:\\alpha$}\n\t\t\\State normal\\_access(${\\tt a}$)\n\t\\EndFor\n\t\\State fake\\_access()\n\\EndWhile \n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\\textbf{normal\\_access(a) : }A normal access consists of the following functions in order: read(${\\tt a}$), push\\_down(${\\tt position[a]}$), update\\_mapping(${\\tt a}$) and finally a write(${\\tt a}$). \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\textbf{read(${\\tt a}$) : }The reading phase is the same as that in Path ORAM; Using the local client side mapping, the client finds out the leaf to which the data element ${\\tt a}$ is currently mapped i.e find $x$ such that $x:= {\\tt position[a]}$. We then request all the data blocks in the buckets along path $P(x)$. The invariant ensures that the client can retrieve ${\\tt a}$, its data element, from these. This completes the reading phase of the protocol. \\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{read(${\\tt a}$) :}]\n\\item[]\n\\State $x \\leftarrow {\\tt position[a]}$\n\\item[]\n\\For {$i \\in \\{0,1,...,k\\}$}\n\t\\State $S \\leftarrow S \\ \\cup \\ $ReadBucket$(P(x,i))$\n\\EndFor\n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\textbf{update\\_mapping(${\\tt a}$) : }After reading a data block, we modify its mapping using the distribution mentioned in Eq.\\ref{eqn:distributionD} i.e update\\_mapping keeps the mapping same with probability $(1-p)$ and with the remaining probability changes it to a uniformly random leaf among the remaining leaves.\\[2pt]\n\n\\noindent\\framebox[.486\\textwidth]{\n\\begin{minipage}{\\dimexpr\\linewidth-2\\fboxsep-2\\fboxrule\\relax}\n\\begin{algorithmic}[1]\n\\item[  \\underline{update\\_mapping(${\\tt a}$) :}]\n\\item[]\n\\State $x \\leftarrow {\\tt position[a]}$\n\\If {Bernoulli(p) = 0}\n\t\\State \\Return $x$\n\\Else\n\t\\State \\Return UniformRandom$\\left( \\{0,1,2,. . 2^L {\\scalebox{0.75}[1.0]{$-$}} 1\\} \\setminus \\{{x}\\} \\right)$\n\\EndIf\n\\end{algorithmic}\n\\end{minipage}\n}\\[5pt]\n\n\n\n\\textbf{push\\_down(${\\tt position[a]}$) : }When any path is accessed, this function tries to place any data blocks along the path $P({\\tt position[a]}$) or in the Stash to lower positions on the same path if possible.\n\n\n\\textbf{write(a) : }Once the mapping is updated, say initially $x := {\\tt position[a]}$ and after updating the mapping $z := {\\tt position[a]}$, we try to write the data block back into the bucket which is the lowest intersection of the two paths in consideration i.e. lowest bucket in $P(x) \\bigcap P(z)$ (with the convention that bucket with the highest level number is the root at level $0$) which has an empty/dummy block.\n\n\n\\textbf{fake\\_access() : }A fake access is issued to push back elements from the stash to the tree.  More precisely, a fake access is issued on a non-empty stash. One data block, say ${\\tt a'}$, is chosen at random from those in the Stash and a normal access is performed on ${\\tt a'}$, i.e., : read(${\\tt a'}$) followed by push\\_down(${\\tt position[a']}$) followed by an update\\_mapping(${\\tt a'}$) followed by a write(${\\tt a'}$).\\\\\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Theoretical evaluation}\\label{security}\n\nIn this section, we shall state our main theorems, their proofs and a few interesting special cases.\n\n\\vspace{2mm}\n\\begin{theorem}[\\textbf{Main theorem}]\\label{thm:main}\n\\textbf{Given a stash size $C$, the Root ORAM with parameters $k,Z$ and $\\lambda$ is $(\\epsilon, \\delta)$-differentially private for $\\epsilon = 2 \\log \\left( \\frac{N-1}{2^k - 1} \\right)$ and $\\delta = 0.5^{M_k}$ where $M_k = (C+Z(k+1)+1)$}\n\\end{theorem}\n\\vspace*{2mm}\n\n\n\\textbf{Proof : }The theorem has two parts, the $\\epsilon$ bound and the $\\delta$ bound. Firstly, we give a brief insight into the two security parameters $\\epsilon$ and $\\delta$. The proof is then structured as follows : \n\n\\textbf{The $\\epsilon$ bound :}\n\\begin{itemize}\n\\itemsep0em\n\\item We set up the differential privacy framework in the ORAM setting.\n\\item Then we set up the probability evaluation model which takes the real and observed access sequences as inputs and finds the probability of that real sequence leading to that output sequence by the ORAM. \n\\item Finally, we compute the maximum change that one access in the input sequence can have on the probability of the output sequence over all possible output sequences. \n\\item These together give the $\\epsilon$ bound.\n\\end{itemize}\n\n\\textbf{The $\\delta$ bound :}\n\\begin{itemize}\n\\itemsep0em\n\\item We begin by showing the need for $\\delta$ in the security framework. \n\\item We then conservatively evaluate a bound on $\\delta$.\n\\end{itemize}\n\\mbox{ }\\\\\n\n$\\epsilon$ and $\\delta$ can be interpret as follows: Given an ORAM scheme with an unbounded amount of local stash, we show that such a scheme is $\\epsilon$-differentially private. But the moment we introduce a finite amount of stash, this is no longer true as is shown in Sec.~\\ref{attack}. And the privacy loss under such a situation is precisely the quantity that is bounded by $\\delta$. \n\nIn the context of Path ORAM, $\\delta$ characterizes the privacy loss if the stash size exceeds its bounds. Another quantity of interest is the probability of the stash overflow. Similarly, in Root ORAM, $\\delta$ quantifies the privacy loss if the stash size is exceeded.\n\n\n\\begin{center}\n\\textbf{The $\\epsilon$ bound}\n\\end{center}\n\n\\subsection{Framework set-up}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.45\\textwidth}{!}\n{\\begin{tabular}{cll|} \\toprule\nSymbol  & Description \\\\\n\\midrule\n$k \\geq 1$        & Model parameter\\\\\n$p = 1-1/2^k$\t\t& Derived model parameter\\\\\n$N = 2^L$        & Number of real data blocks outsourced\\\\\n$M$        & Access pattern size\\\\\n$C$ \t\t& Stash size\\\\\n$p_1$\t& $(1-p)$\\\\\n$p_2$ \t&  $p/(N-1)$\\\\\n$M_k$\t\t& $M_k = Z(k+1) + C$\\\\\n\\bottomrule \\\\\n\\end{tabular}}\n\\caption{Notation for analysis of Root ORAM}\n\\label{table:analysis}\n\\end{table}\n\n\nThe notation used is specified in Table~\\ref{table:analysis}. Recall that a fake access in Root ORAM is indistinguishable from a real access. Hence, for our theoretical analysis, we make a conservative assumption that the sequence of accesses requested by the client machine were all real accesses. In other words, among M access, some are real and some are fake. We conservatively assume that these can be distinguished. In practice, the security offered by our approach is higher since the untrusted server storage cannot differentiate fake accesses from real accesses in practice.\n\nMore formally, let $f_i$ denote the set of fake accesses and $r_i$ denotes the real set of accesses made by the ORAM. We denote by $R_i$, the complete set of accesses made ($r_i$ along with $f_i$). Thus we have that : \n\n", "index": 23, "text": "\\begin{equation}\\label{eqn:relationDP}\n  \\max_{\\substack{r_1,r_2\\\\ |r_1-r_2| = 1}} \\frac{Pr[{\\tt ORAM(r_1)} = o]}{Pr[{\\tt ORAM(r_2)} = o]} \\leq \n  \\max_{\\substack{R_1,R_2\\\\ |R_1-R_2| = 1}} \\frac{Pr[{\\tt \\overline{ORAM}(R_1)} = o]}{Pr[{\\tt \\overline{ORAM}(R_2)} = o]}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\max_{\\begin{subarray}{c}r_{1},r_{2}\\\\&#10;|r_{1}-r_{2}|=1\\end{subarray}}\\frac{Pr[{\\tt ORAM(r_{1})}=o]}{Pr[{\\tt ORAM(r_{2%&#10;})}=o]}\\leq\\max_{\\begin{subarray}{c}R_{1},R_{2}\\\\&#10;|R_{1}-R_{2}|=1\\end{subarray}}\\frac{Pr[{\\tt\\overline{ORAM}(R_{1})}=o]}{Pr[{\\tt%&#10;\\overline{ORAM}(R_{2})}=o]}\" display=\"block\"><mrow><mrow><munder><mi>max</mi><mtable class=\"ltx_align_c\" rowspacing=\"0.0pt\"><mtr><mtd><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>-</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></munder><mo>\u2061</mo><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff8</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac></mrow><mo>\u2264</mo><mrow><munder><mi>max</mi><mtable class=\"ltx_align_c\" rowspacing=\"0.0pt\"><mtr><mtd><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>-</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></munder><mo>\u2061</mo><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff8</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nHence, it is sufficient to bound the latter quantity in Eq.~\\ref{eqn:relationDP} by $e^{\\epsilon}$. \n\n\n\n\n\n\\subsection{Probability model}\nNext, we evaluate the ratio of the probabilities by invoking the secondary invariant. Recall that our secondary invariant is : after each access for an element (real/fake) the position map of that element (and none other) changes randomly according to the distribution $D$ given in Eq.~\\ref{eqn:distributionD}.\n\n\nWith this invariant, we can compute the probability of a particular real sequence $R$ leading to a particular observed sequence $o$. For our computation, we write the real sequence (including fake accesses) below the observed sequence and calculate the probabilities according to the following rules : \n\\begin{itemize}\n\\itemsep0em\n\\item The first time a data block is accessed, its location is random. Hence we write a $1/N$ below this access. \n\\item When an element that was accessed before is accessed, we write a $p_1$ or $p_2$ in the probability calculation depending on whether the observed locations were same or different respectively. \n\\item A background check is maintained, if at any time there are more than $(k+1) \\times Z + C$ data blocks mapped to the same location, the probability becomes 0, where $k$ is the model parameter, $Z$ is the bucket size and $C$ is the maximum stash size. Refer to Subsection~\\ref{attack} for details.\n\\item Finally, we multiply all the written probabilities to get the final probability $Pr[{\\tt ORAM(r_1)} = o]$.\n\\end{itemize}\nThis is demonstrated in the Table~\\ref{table:probabilitymodel}.\n\n\n\\begin{table}\n\\centering\n\\resizebox{.5\\textwidth}{!}{\n\\begin{tabular}{ c | c c c c c c c c}\nObserved seq. & a & b & a & c & a & a & b & d \\\\ \nReal seq. &  x & y & x & z & y & y & z & x \\\\ \\bottomrule \\toprule\nProbabilities &  $\\frac{1}{N}$ & $\\frac{1}{N}$ & $p_1$ & $\\frac{1}{N}$ & $p_2$ & $p_1$ & $p_2$ & $p_2$ \\\\\n\\end{tabular}}\n\\caption{\\textbf{An example of how one can write probabilities directly given the real and observed access patterns $r$ and $o$. Different symbols are used for real and observed access patterns merely for the clarity of the demonstration. $p_1$ and $p_2$ are as defined in Eq.~\\ref{eqn:distributionD} or Table~\\ref{table:analysis}.}}\n\\label{table:probabilitymodel}\n\\end{table}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.5\\textwidth}{!}{\n\\begin{tabular}{ c | c c c c c c c c}\nObserved seq. & {\\color{blue} a} & b & {\\color{blue} a} & c & a & a & b & d \\\\ \nReal seq. &  {\\color{red} x} & y & \\boxed{x} & z & y & y & z & {\\color{red} x} \\\\ \\bottomrule \\toprule\nProbabilities &  $\\frac{1}{N}$ & $\\frac{1}{N}$ & $p_1$ & $\\frac{1}{N}$ & $p_2$ & $p_1$ & $p_2$ & $p_2$ \\\\\n\\end{tabular}}\n\\caption{\\textbf{The symbols in blue are the only ones that affect the probability that will be written under the data element shown by an enclosing box. The data elements in red show the previous and next access of the boxed data element.}}\n\\end{table}\n\n\n\n\n\n\n\\subsection{Maximum change}\nNext, we find the maximum change in the probabilities that can occur as a result of changing one real access. \n\n\nFirst we note that in the probability model, different accessed data elements  have independent chains of probabilities, i.e. each data element has a probability written independent of the other symbols. Also, the probability written under each data element depends only on its previous location and nothing else (and is governed by the distribution $D$ given by Eq.~\\ref{eqn:distributionD}). Hence, if one data access is changed, the maximum change that can occur in the probability is at most in two places v.i.z the location which was modified and the next accessed location of that data element. With this, we can enumerate all the possible cases that can occur and find the maximum change in probabilities. To do this efficiently, we develop some more notation.\n\nLet the accessed data element be changed from ${\\tt a}$ to ${\\tt b}$. Let the previous location of access of a data element ${\\tt a}$ be $l_{pa}$ (leaf $pa$) and the next location be  $l_{na}$. Similarly, the previous location of access of ${\\tt b}$ is $l_{pb}$ and the next location as $l_{nb}$. If any of these 4 do not exist i.e the symbol was never accessed before or was never accessed afterwards, we define that leaf to be $0$ for simplification of the equations. In other words, if data element ${\\tt a}$ was never accessed after the location of access change, then $l_{na} = 0$. Let $l$ be the location of the access in consideration i.e the location of data access which was changed in $r_1$ and $r_2$. Note that in our calculations, we have the same observed sequence for both the sequences $r_1$ and $r_2$, the location of access $l$ is the same in both the sequences. This is shown in the Fig.~\\ref{fig:probabilities}.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{probabilities}\n\\caption{\\textbf{The sequences $r_1$ and $r_2$ differ by one element shown in the box. The previous accessed location and the next accessed location are as shown. Note that the observed sequence $o$ for both is the same (condition for Differential Privacy). The dots denote irrelevant accesses (accesses for elements different from $a$ and $b$).}}\n\\label{fig:probabilities}\n\\end{figure}\n\n\nNow, the probabilities can differ in at most 3 places v.i.z $l$, $l_{na}$ and $l_{nb}$. Let $r_1$ be the sequence with symbol $a$ and $r_2$ be the sequence with symbol $b$. To make the equations crisp, we define the following extension to the Kronecker delta function, \n\n", "itemtype": "equation", "pos": 45374, "prevtext": "\nwhere ${\\tt \\overline{ORAM}(R_i)}$ denotes the ORAM protocol output on sequence $R_i$ without any additional fake accesses. But to prove the bounds of differential privacy in the theorem, we need to bound the following term :\n", "index": 25, "text": "\n\\[\n  \\max_{\\substack{r_1,r_2\\\\ |r_1-r_2| = 1}} \\frac{Pr[{\\tt ORAM(r_1)} = o]}{Pr[{\\tt ORAM(r_2)} = o]} \\leq e^{\\epsilon} \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\max_{\\begin{subarray}{c}r_{1},r_{2}\\\\&#10;|r_{1}-r_{2}|=1\\end{subarray}}\\frac{Pr[{\\tt ORAM(r_{1})}=o]}{Pr[{\\tt ORAM(r_{2%&#10;})}=o]}\\leq e^{\\epsilon}\" display=\"block\"><mrow><mrow><munder><mi>max</mi><mtable class=\"ltx_align_c\" rowspacing=\"0.0pt\"><mtr><mtd><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>-</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></munder><mo>\u2061</mo><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff8</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac></mrow><mo>\u2264</mo><msup><mi>e</mi><mi>\u03f5</mi></msup></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nThis modification of the Kronecker delta is for the simplicity of the equations. Specifically, the modification ensures that if a symbol is accessed for the first time, then its probability given by $P_{z,x} = p_{2} + (p_{1} - p_{2}) \\delta_{zx}$ evaluates to $1/N$ as it should. Now if $Pr[{\\tt \\overline{ORAM}(R_1)} = o] > 0$ and $Pr[{\\tt \\overline{ORAM}(R_2)} = o] > 0$, so that their ratios are well-defined, we can calculate the ratio of the probabilities as :\n", "itemtype": "equation", "pos": 51031, "prevtext": "\nHence, it is sufficient to bound the latter quantity in Eq.~\\ref{eqn:relationDP} by $e^{\\epsilon}$. \n\n\n\n\n\n\\subsection{Probability model}\nNext, we evaluate the ratio of the probabilities by invoking the secondary invariant. Recall that our secondary invariant is : after each access for an element (real/fake) the position map of that element (and none other) changes randomly according to the distribution $D$ given in Eq.~\\ref{eqn:distributionD}.\n\n\nWith this invariant, we can compute the probability of a particular real sequence $R$ leading to a particular observed sequence $o$. For our computation, we write the real sequence (including fake accesses) below the observed sequence and calculate the probabilities according to the following rules : \n\\begin{itemize}\n\\itemsep0em\n\\item The first time a data block is accessed, its location is random. Hence we write a $1/N$ below this access. \n\\item When an element that was accessed before is accessed, we write a $p_1$ or $p_2$ in the probability calculation depending on whether the observed locations were same or different respectively. \n\\item A background check is maintained, if at any time there are more than $(k+1) \\times Z + C$ data blocks mapped to the same location, the probability becomes 0, where $k$ is the model parameter, $Z$ is the bucket size and $C$ is the maximum stash size. Refer to Subsection~\\ref{attack} for details.\n\\item Finally, we multiply all the written probabilities to get the final probability $Pr[{\\tt ORAM(r_1)} = o]$.\n\\end{itemize}\nThis is demonstrated in the Table~\\ref{table:probabilitymodel}.\n\n\n\\begin{table}\n\\centering\n\\resizebox{.5\\textwidth}{!}{\n\\begin{tabular}{ c | c c c c c c c c}\nObserved seq. & a & b & a & c & a & a & b & d \\\\ \nReal seq. &  x & y & x & z & y & y & z & x \\\\ \\bottomrule \\toprule\nProbabilities &  $\\frac{1}{N}$ & $\\frac{1}{N}$ & $p_1$ & $\\frac{1}{N}$ & $p_2$ & $p_1$ & $p_2$ & $p_2$ \\\\\n\\end{tabular}}\n\\caption{\\textbf{An example of how one can write probabilities directly given the real and observed access patterns $r$ and $o$. Different symbols are used for real and observed access patterns merely for the clarity of the demonstration. $p_1$ and $p_2$ are as defined in Eq.~\\ref{eqn:distributionD} or Table~\\ref{table:analysis}.}}\n\\label{table:probabilitymodel}\n\\end{table}\n\n\n\\begin{table}\n\\centering\n\\resizebox{0.5\\textwidth}{!}{\n\\begin{tabular}{ c | c c c c c c c c}\nObserved seq. & {\\color{blue} a} & b & {\\color{blue} a} & c & a & a & b & d \\\\ \nReal seq. &  {\\color{red} x} & y & \\boxed{x} & z & y & y & z & {\\color{red} x} \\\\ \\bottomrule \\toprule\nProbabilities &  $\\frac{1}{N}$ & $\\frac{1}{N}$ & $p_1$ & $\\frac{1}{N}$ & $p_2$ & $p_1$ & $p_2$ & $p_2$ \\\\\n\\end{tabular}}\n\\caption{\\textbf{The symbols in blue are the only ones that affect the probability that will be written under the data element shown by an enclosing box. The data elements in red show the previous and next access of the boxed data element.}}\n\\end{table}\n\n\n\n\n\n\n\\subsection{Maximum change}\nNext, we find the maximum change in the probabilities that can occur as a result of changing one real access. \n\n\nFirst we note that in the probability model, different accessed data elements  have independent chains of probabilities, i.e. each data element has a probability written independent of the other symbols. Also, the probability written under each data element depends only on its previous location and nothing else (and is governed by the distribution $D$ given by Eq.~\\ref{eqn:distributionD}). Hence, if one data access is changed, the maximum change that can occur in the probability is at most in two places v.i.z the location which was modified and the next accessed location of that data element. With this, we can enumerate all the possible cases that can occur and find the maximum change in probabilities. To do this efficiently, we develop some more notation.\n\nLet the accessed data element be changed from ${\\tt a}$ to ${\\tt b}$. Let the previous location of access of a data element ${\\tt a}$ be $l_{pa}$ (leaf $pa$) and the next location be  $l_{na}$. Similarly, the previous location of access of ${\\tt b}$ is $l_{pb}$ and the next location as $l_{nb}$. If any of these 4 do not exist i.e the symbol was never accessed before or was never accessed afterwards, we define that leaf to be $0$ for simplification of the equations. In other words, if data element ${\\tt a}$ was never accessed after the location of access change, then $l_{na} = 0$. Let $l$ be the location of the access in consideration i.e the location of data access which was changed in $r_1$ and $r_2$. Note that in our calculations, we have the same observed sequence for both the sequences $r_1$ and $r_2$, the location of access $l$ is the same in both the sequences. This is shown in the Fig.~\\ref{fig:probabilities}.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{probabilities}\n\\caption{\\textbf{The sequences $r_1$ and $r_2$ differ by one element shown in the box. The previous accessed location and the next accessed location are as shown. Note that the observed sequence $o$ for both is the same (condition for Differential Privacy). The dots denote irrelevant accesses (accesses for elements different from $a$ and $b$).}}\n\\label{fig:probabilities}\n\\end{figure}\n\n\nNow, the probabilities can differ in at most 3 places v.i.z $l$, $l_{na}$ and $l_{nb}$. Let $r_1$ be the sequence with symbol $a$ and $r_2$ be the sequence with symbol $b$. To make the equations crisp, we define the following extension to the Kronecker delta function, \n\n", "index": 27, "text": "\\begin{equation*}\n\\delta_{ij} = \n\\begin{cases}\n0 \t& \\text{if $i \\neq j$}\\\\\n1\t& \\text{if $i=j$} \\\\\n\\frac{1/N - p_2}{p_1-p_2}  & \\text{if $j=0$}\n\\end{cases}\n\\end{equation*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\delta_{ij}=\\begin{cases}0&amp;\\text{if $i\\neq j$}\\\\&#10;1&amp;\\text{if $i=j$}\\\\&#10;\\frac{1/N-p_{2}}{p_{1}-p_{2}}&amp;\\text{if $j=0$}\\end{cases}\" display=\"block\"><mrow><msub><mi>\u03b4</mi><mrow><mi>i</mi><mo>\u2062</mo><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>i</mi><mo>\u2260</mo><mi>j</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mstyle displaystyle=\"false\"><mfrac><mrow><mrow><mn>1</mn><mo>/</mo><mi>N</mi></mrow><mo>-</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>-</mo><msub><mi>p</mi><mn>2</mn></msub></mrow></mfrac></mstyle></mtd><mtd columnalign=\"left\"><mrow><mtext>if\u00a0</mtext><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow></mrow></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\n\nAfter observing that\n", "itemtype": "equation", "pos": 51667, "prevtext": "\nThis modification of the Kronecker delta is for the simplicity of the equations. Specifically, the modification ensures that if a symbol is accessed for the first time, then its probability given by $P_{z,x} = p_{2} + (p_{1} - p_{2}) \\delta_{zx}$ evaluates to $1/N$ as it should. Now if $Pr[{\\tt \\overline{ORAM}(R_1)} = o] > 0$ and $Pr[{\\tt \\overline{ORAM}(R_2)} = o] > 0$, so that their ratios are well-defined, we can calculate the ratio of the probabilities as :\n", "index": 29, "text": "\n\\[\n\\frac{Pr[{\\tt \\overline{ORAM}(R_1)} = o]}{Pr[{\\tt \\overline{ORAM}(R_2)} = o]} = \\frac{P_{l,l_{pa}} \\cdot P_{l_{na},l} \\cdot P_{l_{nb},l_{pb}}}{P_{l_{na},l_{pa}} \\cdot P_{l,l_{pb}} \\cdot P_{l_{nb},l}}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\frac{Pr[{\\tt\\overline{ORAM}(R_{1})}=o]}{Pr[{\\tt\\overline{ORAM}(R_{2})}=o]}=%&#10;\\frac{P_{l,l_{pa}}\\cdot P_{l_{na},l}\\cdot P_{l_{nb},l_{pb}}}{P_{l_{na},l_{pa}}%&#10;\\cdot P_{l,l_{pb}}\\cdot P_{l_{nb},l}}\" display=\"block\"><mrow><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff8</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>P</mi><mrow><mi>l</mi><mo>,</mo><msub><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>a</mi></mrow></msub></mrow></msub><mo>\u22c5</mo><msub><mi>P</mi><mrow><msub><mi>l</mi><mrow><mi>n</mi><mo>\u2062</mo><mi>a</mi></mrow></msub><mo>,</mo><mi>l</mi></mrow></msub><mo>\u22c5</mo><msub><mi>P</mi><mrow><msub><mi>l</mi><mrow><mi>n</mi><mo>\u2062</mo><mi>b</mi></mrow></msub><mo>,</mo><msub><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>b</mi></mrow></msub></mrow></msub></mrow><mrow><msub><mi>P</mi><mrow><msub><mi>l</mi><mrow><mi>n</mi><mo>\u2062</mo><mi>a</mi></mrow></msub><mo>,</mo><msub><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>a</mi></mrow></msub></mrow></msub><mo>\u22c5</mo><msub><mi>P</mi><mrow><mi>l</mi><mo>,</mo><msub><mi>l</mi><mrow><mi>p</mi><mo>\u2062</mo><mi>b</mi></mrow></msub></mrow></msub><mo>\u22c5</mo><msub><mi>P</mi><mrow><msub><mi>l</mi><mrow><mi>n</mi><mo>\u2062</mo><mi>b</mi></mrow></msub><mo>,</mo><mi>l</mi></mrow></msub></mrow></mfrac></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nwe can see that this maximum value of the ratio of probabilities occurs when $l_{na} = l = l_{pa}$ and $l_{pb} = l_{nb} \\neq l$. In this case, the ratio is given by,\n", "itemtype": "equation", "pos": 51895, "prevtext": "\n\nAfter observing that\n", "index": 31, "text": "\n\\[ \\frac{1/N}{p_1} \\geq \\frac{p_2}{p_1} \\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\frac{1/N}{p_{1}}\\geq\\frac{p_{2}}{p_{1}}\" display=\"block\"><mrow><mfrac><mrow><mn>1</mn><mo>/</mo><mi>N</mi></mrow><msub><mi>p</mi><mn>1</mn></msub></mfrac><mo>\u2265</mo><mfrac><msub><mi>p</mi><mn>2</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mfrac></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nEvaluating this in terms of our parameters, $p_1 = (1-p) = 2^{-k}$ and $p_2 = \\frac{p}{N-1} = \\frac{1-2^{-k}}{N-1}$ and plugging this into the differential privacy equation, we get \n\n", "itemtype": "equation", "pos": 52104, "prevtext": "\nwe can see that this maximum value of the ratio of probabilities occurs when $l_{na} = l = l_{pa}$ and $l_{pb} = l_{nb} \\neq l$. In this case, the ratio is given by,\n", "index": 33, "text": "\n\\[\n\\frac{p_1 \\cdot p_1 \\cdot p_1}{p_1 \\cdot p_2 \\cdot p_2} = \\left( \\frac{p_1}{p_2} \\right)^2\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\frac{p_{1}\\cdot p_{1}\\cdot p_{1}}{p_{1}\\cdot p_{2}\\cdot p_{2}}=\\left(\\frac{p_%&#10;{1}}{p_{2}}\\right)^{2}\" display=\"block\"><mrow><mfrac><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>\u22c5</mo><msub><mi>p</mi><mn>1</mn></msub><mo>\u22c5</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>\u22c5</mo><msub><mi>p</mi><mn>2</mn></msub><mo>\u22c5</mo><msub><mi>p</mi><mn>2</mn></msub></mrow></mfrac><mo>=</mo><msup><mrow><mo>(</mo><mfrac><msub><mi>p</mi><mn>1</mn></msub><msub><mi>p</mi><mn>2</mn></msub></mfrac><mo>)</mo></mrow><mn>2</mn></msup></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "  \nIt is important to note that the above equation holds for all observed access sequences $o$. And hence, we can see that Root ORAM guarantees $\\epsilon = 2 \\log \\left( \\frac{N-1}{2^k - 1} \\right)$. This completes the $\\epsilon$ bound\\footnote{It is interesting to note that as $k$ becomes reasonably large (compared to 1), we can approximate the last expression by $N/2^k$ and get an estimate on $\\epsilon$ as $2(L-k)$, where $N = 2^L$ as before.}.\n\n\n\n\\begin{center}\n\\textbf{The $\\delta$ bound}\n\\end{center}\n\n\n\\subsection{The need for $\\delta$}\\label{attack}\n\nIn this subsection, we compute the $\\delta$ bound in the theorem. We use the notation from the Path ORAM paper to demonstrate this short-coming. We assume that the Stash size is bounded by $C$ and let $M_{L}$ denote $\\mathit{Z \\log N+C+1}$. \n\nWe assume that the ORAM has been used to access each element at least once. For demonstration purpose, we construct a minimal working example : \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nEvaluating this in terms of our parameters, $p_1 = (1-p) = 2^{-k}$ and $p_2 = \\frac{p}{N-1} = \\frac{1-2^{-k}}{N-1}$ and plugging this into the differential privacy equation, we get \n\n", "index": 35, "text": "\\begin{align*}\n  \\max_{\\substack{r_1,r_2\\\\ |r_1-r_2| = 1}} \\frac{Pr[{\\tt ORAM(r_1)} = o]}{Pr[{\\tt ORAM(r_2)} = o]}  & \\leq \n  \\max_{\\substack{R_1,R_2\\\\ |R_1-R_2| = 1}} \\frac{Pr[{\\tt \\overline{ORAM}(R_1)} = o]}{Pr[{\\tt \\overline{ORAM}(R_1)} = o]} \\\\\n  & \\leq \\left( \\frac{p_1}{p_2} \\right)^2 \\\\\n  & = \\left( \\frac{N-1}{2^k - 1} \\right)^2\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\max_{\\begin{subarray}{c}r_{1},r_{2}\\\\&#10;|r_{1}-r_{2}|=1\\end{subarray}}\\frac{Pr[{\\tt ORAM(r_{1})}=o]}{Pr[{\\tt ORAM(r_{2%&#10;})}=o]}\" display=\"inline\"><mrow><munder><mi>max</mi><mtable class=\"ltx_align_c\" rowspacing=\"0.0pt\"><mtr><mtd><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>-</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></munder><mo>\u2061</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude9b</mi><mn>\ud835\udff8</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac></mstyle></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\max_{\\begin{subarray}{c}R_{1},R_{2}\\\\&#10;|R_{1}-R_{2}|=1\\end{subarray}}\\frac{Pr[{\\tt\\overline{ORAM}(R_{1})}=o]}{Pr[{\\tt%&#10;\\overline{ORAM}(R_{1})}=o]}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><mrow><munder><mi>max</mi><mtable class=\"ltx_align_c\" rowspacing=\"0.0pt\"><mtr><mtd><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>-</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr></mtable></munder><mo>\u2061</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow><mrow><mi>P</mi><mi>r</mi><mrow><mo stretchy=\"false\">[</mo><mover accent=\"true\"><mi>\ud835\ude7e\ud835\ude81\ud835\ude70\ud835\ude7c</mi><mo>\u00af</mo></mover><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\ude81</mi><mn>\ud835\udff7</mn></msub><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>o</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mfrac></mstyle></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\leq\\left(\\frac{p_{1}}{p_{2}}\\right)^{2}\" display=\"inline\"><mrow><mi/><mo>\u2264</mo><msup><mrow><mo>(</mo><mstyle displaystyle=\"true\"><mfrac><msub><mi>p</mi><mn>1</mn></msub><msub><mi>p</mi><mn>2</mn></msub></mfrac></mstyle><mo>)</mo></mrow><mn>2</mn></msup></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\left(\\frac{N-1}{2^{k}-1}\\right)^{2}\" display=\"inline\"><mrow><mi/><mo>=</mo><msup><mrow><mo>(</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>-</mo><mn>1</mn></mrow></mfrac></mstyle><mo>)</mo></mrow><mn>2</mn></msup></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nwhere $r$ denotes the read operation and $x$ denotes data which is not important for the demonstration. In words, one access sequence consists of $M_L$ accesses to the same element and the second access sequence consists of $M_L$ different accesses to elements $1,2, . . . ,M_L$.\n\nNow, of all the possible sequences ${\\tt ORAM}(\\overrightarrow{y})$ can produce, we can see that the sequence $1,1,. .  .,1$ can be one of them.\\footnote{For that matter so can any sequence $a,a,. . .,a$ for any $a \\in \\{1,2,3, . . . N\\}$} But, its not hard to see that the same sequence $1,1,. . .,1$ can never occur as ${\\tt ORAM}(\\overrightarrow{y}')$. The reason for this is simply because we cannot ever map more than $M_{L}$ elements to the same path (or else the Path ORAM invariant is broken i.e stash overflows) and hence the $M_L$ accesses to that one location cannot all be for different symbols. \n\nTo demonstrate this, we project this as an attack on the Path ORAM protocol. We imagine a hypothetical situation where a program is using the Path ORAM protocol to hide its access pattern. We know that the program has the following traits,\n", "itemtype": "equation", "pos": 53683, "prevtext": "  \nIt is important to note that the above equation holds for all observed access sequences $o$. And hence, we can see that Root ORAM guarantees $\\epsilon = 2 \\log \\left( \\frac{N-1}{2^k - 1} \\right)$. This completes the $\\epsilon$ bound\\footnote{It is interesting to note that as $k$ becomes reasonably large (compared to 1), we can approximate the last expression by $N/2^k$ and get an estimate on $\\epsilon$ as $2(L-k)$, where $N = 2^L$ as before.}.\n\n\n\n\\begin{center}\n\\textbf{The $\\delta$ bound}\n\\end{center}\n\n\n\\subsection{The need for $\\delta$}\\label{attack}\n\nIn this subsection, we compute the $\\delta$ bound in the theorem. We use the notation from the Path ORAM paper to demonstrate this short-coming. We assume that the Stash size is bounded by $C$ and let $M_{L}$ denote $\\mathit{Z \\log N+C+1}$. \n\nWe assume that the ORAM has been used to access each element at least once. For demonstration purpose, we construct a minimal working example : \n\n", "index": 37, "text": "\\begin{align}\n\\overrightarrow{y} &= \\mathit{((r,1,x),(r,1,x),. . . , (r, 1, x))}  \\mbox{ and }\\\\\n\\overrightarrow{y}' &= \\mathit{((r,1,x),(r,2,x),. . . , (r, M_L, x))}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overrightarrow{y}\" display=\"inline\"><mover accent=\"true\"><mi>y</mi><mo>\u2192</mo></mover></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\mathit{((r,1,x),(r,1,x),...,(r,1,x))}\\mbox{ and }\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mn mathvariant=\"italic\">1</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mn mathvariant=\"italic\">1</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mn mathvariant=\"italic\">1</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mtext>\u00a0and</mtext></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overrightarrow{y}^{\\prime}\" display=\"inline\"><msup><mover accent=\"true\"><mi>y</mi><mo>\u2192</mo></mover><mo>\u2032</mo></msup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\mathit{((r,1,x),(r,2,x),...,(r,M_{L},x))}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mn mathvariant=\"italic\">1</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><mn mathvariant=\"italic\">2</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo>,</mo><msub><mi>M</mi><mi>L</mi></msub><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nWe assume that the program makes sufficiently large number of accesses. Now, if $y$ is the access real pattern, we know that if ever we see a sequence of $M_{L}$ or more access made to the same location in ${\\tt ORAM}(\\overrightarrow{y})$, we can immediately infer that Secret = 1!!\\footnote{The reason for this is that there is another constraint in the system which is that no leaf can have more than $M_{L}$ data blocks mapped to it. This is because each path $P(x)$ has $Z \\log N$ buckets and along with the main invariant that each block is stored somewhere along the path from the mapped leaf to the root or in the Stash. We assume that this is covered in the failure probability of the ORAM because the probability of this occurring is very very low.}\n\n\n\n\\subsection{$\\delta$ bound}\nBack to the Root ORAM protocol, we can see that the probability of an observed sequence can suddenly jump from $0$ to a non-zero value after one data access has been changed. And this is what is captured by the $\\delta$ in the $(\\epsilon,\\delta)$-differential privacy framework for ORAMs. \n\nLet $M_k$ denote the number $(C + Z(k+1) + 1)$. It is easy to see that there is a sudden jump in the probability from $0$ to a non-zero value when the real access is changed at one location when we look at any such sequence. In particular we choose the two sequences to be the following :\n\n", "itemtype": "equation", "pos": 54992, "prevtext": "\nwhere $r$ denotes the read operation and $x$ denotes data which is not important for the demonstration. In words, one access sequence consists of $M_L$ accesses to the same element and the second access sequence consists of $M_L$ different accesses to elements $1,2, . . . ,M_L$.\n\nNow, of all the possible sequences ${\\tt ORAM}(\\overrightarrow{y})$ can produce, we can see that the sequence $1,1,. .  .,1$ can be one of them.\\footnote{For that matter so can any sequence $a,a,. . .,a$ for any $a \\in \\{1,2,3, . . . N\\}$} But, its not hard to see that the same sequence $1,1,. . .,1$ can never occur as ${\\tt ORAM}(\\overrightarrow{y}')$. The reason for this is simply because we cannot ever map more than $M_{L}$ elements to the same path (or else the Path ORAM invariant is broken i.e stash overflows) and hence the $M_L$ accesses to that one location cannot all be for different symbols. \n\nTo demonstrate this, we project this as an attack on the Path ORAM protocol. We imagine a hypothetical situation where a program is using the Path ORAM protocol to hide its access pattern. We know that the program has the following traits,\n", "index": 39, "text": "\n\\[\n\\mbox{Access Pattern} = \\begin{cases} 1,1,1,. . .,1 & \\mbox{if } \\mbox{ Secret = 1} \\\\ \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 1,2,3, . . ,M & \\mbox{if } \\mbox{ Secret = 0} \\end{cases}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\mbox{Access Pattern}=\\begin{cases}1,1,1,...,1&amp;\\mbox{if }\\mbox{ Secret = 1}\\\\&#10;1,2,3,..,M&amp;\\mbox{if }\\mbox{ Secret = 0}\\end{cases}\" display=\"block\"><mrow><mtext>Access Pattern</mtext><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"left\"><mtext>if  Secret = 1</mtext></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>M</mi></mrow></mtd><mtd columnalign=\"left\"><mtext>if  Secret = 0</mtext></mtd></mtr></mtable></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nIf $Pr[{\\tt ORAM(r_i)} = o] > 0$ for $i = 1,2$, then we have already shown the $\\epsilon$ bound and hence $\\delta = 0$. So it remains to find the maximum $\\delta$ when one of these terms is $0$. WLOG, $Pr[{\\tt ORAM(r_1)} = o] = 0$. Hence $\\delta$ is the maximum value of $Pr[{\\tt ORAM(r_2)} = o]$ i.e the maximum probability over a neighboring sequence compared to a zero probability over the original sequence. Now, one simple upper bound on $\\delta$ can be found by noting the following: Since the probabilities used to compute for each access are at most $p_1$ (they are either $p_1$ or $p_2$ or $1/N$), we can get a quick upper bound on $\\delta$ as\n\n", "itemtype": "equation", "pos": 56532, "prevtext": "\nWe assume that the program makes sufficiently large number of accesses. Now, if $y$ is the access real pattern, we know that if ever we see a sequence of $M_{L}$ or more access made to the same location in ${\\tt ORAM}(\\overrightarrow{y})$, we can immediately infer that Secret = 1!!\\footnote{The reason for this is that there is another constraint in the system which is that no leaf can have more than $M_{L}$ data blocks mapped to it. This is because each path $P(x)$ has $Z \\log N$ buckets and along with the main invariant that each block is stored somewhere along the path from the mapped leaf to the root or in the Stash. We assume that this is covered in the failure probability of the ORAM because the probability of this occurring is very very low.}\n\n\n\n\\subsection{$\\delta$ bound}\nBack to the Root ORAM protocol, we can see that the probability of an observed sequence can suddenly jump from $0$ to a non-zero value after one data access has been changed. And this is what is captured by the $\\delta$ in the $(\\epsilon,\\delta)$-differential privacy framework for ORAMs. \n\nLet $M_k$ denote the number $(C + Z(k+1) + 1)$. It is easy to see that there is a sudden jump in the probability from $0$ to a non-zero value when the real access is changed at one location when we look at any such sequence. In particular we choose the two sequences to be the following :\n\n", "index": 41, "text": "\\begin{align*}\nr_1 &= (1,2,3, . . . ,M_k) \\\\\nr_2 &= (1,2,3, . . . ,M_k -1, 1)\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{1}\" display=\"inline\"><msub><mi>r</mi><mn>1</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(1,2,3,...,M_{k})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>M</mi><mi>k</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle r_{2}\" display=\"inline\"><msub><mi>r</mi><mn>2</mn></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(1,2,3,...,M_{k}-1,1)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><msub><mi>M</mi><mi>k</mi></msub><mo>-</mo><mn>1</mn></mrow><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow></math>", "type": "latex"}, {"file": "1601.03378.tex", "nexttext": "\nWhere $M_k = (C + Z(k+1) + 1)$ and the last inequality follows by inserting the worst case value of $p_1$ which is  $p_1 = 1/2$ when $k=1$. This completes the $\\delta$ bound.\\footnote{A strictly better bound can be evaluated by actually evaluating $Pr[{\\tt ORAM(r_1)} = o]$.}  $\\blacksquare$\n\n\n\n\n\\subsection{Bandwidth}\n\n\\begin{theorem}\\label{thm:bandwidth}\n\\textbf{The bandwidth of the Root ORAM protocol with parameters $k,Z$ and $\\lambda$ is $2 \\times Z(k+1) \\times (1+1/\\lambda)$ per real access.}\n\\end{theorem}\n\\vspace*{2mm}\n\n\n\n\\textbf{Proof : }The number of blocks in any path of the tree is equal to $Z(k+1)$ and hence twice the number of blocks are transferred per read and write. Also, they way the parameter $\\lambda$ is set (i.e the way the fake accesses are programmed), we perform on an average $\\lambda$ real accesses per fake access. (the average of a Poisson process with parameter $\\lambda$ is $\\lambda$). Hence, the bandwidth gets an addition factor of $(1+1/\\lambda)$ per real access.  $\\blacksquare $\n\n\n\n\\subsection{Special Cases of Root ORAM}\n\n\n\\emph{\\textbf{Case 1 : k = 1 }}This is a particularly interesting case. The bandwidth used is an extremely low constant. With realistic estimates of parameters, the security guaranteed by this scheme is about $\\epsilon = 2 \\log N$, which is roughly 60 where as the bandwidth used is a mere 10 blocks per real access and is independent of $N$ (using $Z=2$ and $\\lambda=4$).\n\n\n\\vspace{2mm}\n\\emph{\\textbf{Case 2 : Path ORAM }}\n\\vspace{2mm}\n\\begin{theorem}\\label{them:pathoram}\n\\textbf{Path ORAM protocol is an instantiation of Root ORAM with the following values of parameters : $k=L=\\log N, Z=5$ and $\\lambda = \\infty$.}\n\\end{theorem}\n\n\n\\textbf{Proof : }This follows directly by noting that the distribution $D$ which is the distribution of the new location of any data block reduces to a uniform distribution when $k=L$ and that $\\lambda = \\infty$ corresponds to no fake access. This is precisely the Path ORAM protocol. $\\blacksquare $ \n\n\n\\vspace{2mm}\n\\emph{\\textbf{Case 3 : k = L }}We can see that $k = L$ corresponds to complete binary tree. We get $\\epsilon = 0$, the equivalent of perfect security in the differential privacy formulation. Given $\\lambda = 1$ and $Z=2$, the protocol has very low stash size (refer to Sec.~\\ref{systems} for technical details). The average bandwidth used is $\\sim 8 \\log N$ (compared to $\\sim 10 \\log N)$ for Path ORAM). This is because Root ORAM uses a combination of fake accesses ($\\lambda$) and smaller bucket size ($Z$).\n\n\n\\subsection{Security-Bandwidth trade-off}\n\nFig.~\\ref{fig:tradeoff} show the security-bandwidth trade-off, the central result of this paper. It shows possibility of having lower bandwidth at the cost of a rigorously quantified privacy loss, for various values of $Z$ and $\\lambda$. We plot the figure in a $\\log$ scale to show the order of magnitude improvement in bandwidth over existing protocols. The lowest bandwidth protocol uses a mere 10 Blocks per access of bandwidth (for $\\lambda = 4$) and give a security of $\\epsilon = 60$. We would also like to highlight that the bandwidth in the low bandwidth regime independent of $N$. With realistic values of parameters, $\\delta$ is negligibly small and hence we do not show plots of $\\delta$.\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{tradeoff4_1}\n\\caption{\\textbf{This figure shows the security-bandwidth trade-off for $N=2^{30}$. We would like to highlight the low bandwidth design space that has opened up with the introduction of Root ORAM. The low bandwidth regime shows an order of magnitude improvement over state-of-the-art. A red cross is marked to reference the Path ORAM protocol in this space and a blue circle is used to reference the Ring ORAM protocol.}}\n\\label{fig:tradeoff}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Systems evaluation}\\label{systems}\n\nWe have already established the security-bandwidth trade-off using theoretical analysis. Next, we would like to investigate the hidden component of the system viz. the stash size used.  To recapitulate, $\\epsilon$ gives a bound on a the protocol with an unbounded stash. If we introduce a stash size constraint, then $\\delta$ characterizes the privacy loss if the stash is overflown. But we need to show the relation between stash size and the overflow probability viz. small stash size is much more likely to overflow whereas large stash sizes are less likely to overflow. We resort to simulations to demonstrate how large should the stash size be to have low probabilities of overflow. \n\nWe simulate Root ORAM for various values of the parameter to understand the impact of design parameters on the stash size. Specifically, we varied $L$ from $10$ to $21$, $k$ from $1$ to $L$, $Z$ from $2$ to $5$ and for six different values of $\\lambda$. This has been tabulated in Table~\\ref{table:simulation}. We define \\textit{outsourced ratio} as the fraction of client storage to the total data outsourced. \n\nWe begin by giving the details of our implementations. \n\n\n\n\n\n\n\n\\subsection{Details of the implementation}\nWe implemented the complete functionality of Root ORAM in C++. We plan to make our implementation publicly available as an open source software. We performed all experiments on a 1.4 GHz Intel processor. The Amazon EC2 experiments were performed using a TCP connection for reliable data downloads. \n\nWe use random access patterns for the simulations and the maximum stash size is calculated excluding the transient storage for one path. Unlike current work, we independently study the effect of increasing the number of accesses ($M$) on the max stash size. The rationale behind this is that in current ORAM evaluations, a fixed number of accesses allows us to absolutely bound the stash size. But in any probabilistic ORAM, this stash size will be probabilistic and given a sufficiently large number of access, is going to exceed the bounds given. Hence, we independently present results about the dependence of the maximum stash size on $M$, the number of accesses made to the ORAM. Next we briefly describe the aims of our evaluations before showing its results.\\\\\n\n\\begin{table}[t]\n\\centering\n\\resizebox{0.37\\textwidth}{!}{\n\\begin{tabular}{cll|} \\toprule\nSymbol  & Description \\\\\n\\midrule\n$L$ \t\t& From 10 to 21\\\\\n$k$        & Runs from 1 to $L$\\\\\n$Z$\t\t& $Z \\in \\{2,3,4,5\\}$\\\\\n$\\lambda$ \t\t& $\\lambda \\in \\{0.25,0.5, 0.75,1,2,\\infty\\}$\\\\\n\\bottomrule\\\\\n\\end{tabular}}\n\\caption{Simulations limits}\n\\label{table:simulation}\n\\end{table}\n\n\\textbf{Security and Bandwidth trade-off curve : }First we would like to explicitly show the trade-off curve of security vs bandwidth. We would like to highlight the two dimensional nature of the graph which demonstrates an explicit design space based on the system requirements. Similarly, we remark about the low bandwidth regime which has a constant bandwidth independent of $N$.\n\n\\textbf{Stash usage : }Next we explore the effect of $N$ on the maximum stash used at the client side.  \nWe aim to investigate the outsourcing ratio for large values of $N$ and demonstrate low-stash usage of our protocol.\n\n\\textbf{Number of accesses : }It is also important to show the dependence of the maximum stash usage on $M$, the number of accesses made by the ORAM. We expect the growth of the maximum stash used to be extremely slow with $M$, which will make this a feasible architecture. Since this is not a critical aspect of the paper, the content has been deferred to the Appendix~\\ref{App:AppendixA}.\n\n\\textbf{$k$-dependence of stash size : }We would then like to show the maximum usage of stash size as a function of the parameters of the model viz. $k,\\lambda$ and $Z$, which gives a holistic view of the effect of various design parameters. We aim to investigate the different regimes of these graphs such as the low bandwidth regime and the high bandwidth regime.\n\n\\textbf{Latency study via Amazon EC2 : }Finally, we study the latency incurred for Root ORAM memory accesses using an Amazon EC2 server. Details of the client machine are not disclosed to maintain the anonymity of the authors. We study the effect of latency as a function of $k$ for three different block sizes viz. $1$ KB, $4$ KB and $16$ KB. \n\n\n\n\n\n\n\\begin{figure}\n\\centering\n\\includegraphics[width=\\linewidth]{max_plot}\n\\caption{\\textbf{This figure illustrates the maximum stash usage as a function of $N$. Different lines correspond to different values of $\\lambda$. To put this in perspective, the maximum stash usage for $10$ GB of outsourced data is roughly $40$ MB (using a $4$ KB block size).}}\n\\label{fig:maxplot}\n\\end{figure}\n\n\n\\begin{figure*}\n\\centering\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_lambda_2}\n\\caption{$Z=2$}\\label{topa}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_lambda_3}\n\\caption{$Z=3$}\\label{topb}\n\\end{subfigure}\n\\vspace*{0.5cm} \n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_lambda_4}\n\\caption{$Z=4$}\\label{topc}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_lambda_5}\n\\caption{$Z=5$}\\label{topd}\n\\end{subfigure}\n\\caption{\\textbf{These figures show the dependence of the maximum stash used on the fake access parameter ($\\lambda$). $N=2^{20}$ and corresponding $Z$ sizes are mentioned below the figures. Towards the low bandwidth regime, outsourcing ratios of $1/1000$ can be achieved (for $Z=5$). Another interesting feature of these graphs is in their blue regions, where $k$ is close to $L=\\log N$. In these regimes, the stash size is extremely low.}}\\label{fig:mesh_plots_lambda}\n\\end{figure*}\n\n\n\n\\begin{figure*}\n\\centering\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_Z_fourth}\n\\caption{$\\lambda = 0.25$}\\label{bota}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{mesh_plot_Z_one}\n\\caption{$\\lambda = 1$}\\label{botb}\n\\end{subfigure}\n\\caption{\\textbf{These figures show the dependence of maximum stash used on the bucket size $Z$ $N = 2^{20}$. The small difference between Fig.~\\ref{bota} and Fig.~\\ref{botb} is because at high values of $N$, there is little difference between $\\lambda=1$ and $\\lambda=0.25$ in terms of stash size usage. It is only noticeable at the lower end, i.e., around $Z=2$.}}\\label{fig:mesh_plots_Z}\n\\end{figure*}\n\n\n\n\\begin{figure*}\n\\centering\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{EC2_highband}\n\\caption{}\\label{banda}\n\\end{subfigure}\\qquad\n\\begin{subfigure}[b]{.47\\textwidth}\n\\centering\n\\includegraphics[width=\\linewidth]{EC2_constraint}\n\\caption{}\\label{bandb}\n\\end{subfigure}\n\\caption{\\textbf{Real-world implementations over Amazon EC2. These figures show the latency as a function of $k$ and the application bandwidth for $N = 2^{20}$ and three block sizes viz. $1$ KB, $4$ KB and $16$ KB. Fig.~\\ref{banda} shows the latency vs $k$ whereas Fig.~\\ref{bandb} shows the latency as a function of the constrained application bandwidth. It is worth noting the significant difference between the latencies for different values of $k$ when application bandwidth is constrained.}}\\label{fig:EC2}\n\\end{figure*}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Max stash size vs $N$}\nIn light of the recent paper by Bindschaedler \\textit{et al.}~\\cite{naveedpractical}, we base our experimental evaluation by giving due importance to the constants involved in relevant equations. Fig.~\\ref{fig:maxplot} shows the dependence of the maximum stash used on $N$, the number of outsourced blocks. Different lines correspond to different values of $\\lambda$. As can be seen, the effect of $\\lambda$ goes down for relatively large values of $N$. We believe the reason for this is that during a probabilistic run of the protocol, certain paths of the tree have more real data elements causing crowding and it becomes less likely for fake accesses to alleviate that for large values of $N$.\n\n As can be seen in Fig.~\\ref{fig:maxplot}, the worst case stash size for standard 4 KB blocks for 10 GB of data outsourced is 40 MB. The growth in Fig.~\\ref{fig:maxplot} suggests that this outsourced ratio will be smaller for larger values of $N$. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{$k$-dependence of stash size}\n\nFig.~\\ref{fig:mesh_plots_lambda} and Fig.~\\ref{fig:mesh_plots_Z} show the dependence of the maximum stash used as a function of $k$, $Z$ and $\\lambda$ respectively. All these plots are for $N=2^{20}$.\n\nWhen low bandwidth is used, the stash size usage is relatively high, though with modest values of the parameters, the outsourcing ratio can be reduced to acceptable values. For small values of $Z$, we have an outsourcing ratio of about $1/30$, whereas for larger values, the ratio is almost $1/1000$. It enables a smartphone client with only 1 GB of local storage to outsource 1 TB of data to the untrusted cloud server. Similarly, as can be seen from the Fig.~\\ref{fig:maxplot}, the growth of the maximum stash size is considerably flat implying that the outsourced ratio gets much better with higher amounts of outsourced data. \n\nAnother interesting feature of Root ORAM is the extremely low stash size used by the models with near perfect security i.e models with $k$ between roughly 13 and 20. Though Root ORAM does not have theoretical bounds on the stash usage like in Path ORAM, it can be seen clearly how these aspects tie together from these figures.~\\ref{fig:mesh_plots_Z} as Path ORAM is one particular instantiation of Root ORAM in the $\\epsilon=0$ security regime and as can be seen, the stash size is extremely low.\n\n\n\\subsection{Real-world implementation}\nNext, we evaluate our real-world implementation of Root ORAM using an Amazon EC2 server. We aim to compute the latency overhead of a memory accesses as a function of Root ORAM parameters. We anonymize the geographic locations of the servers to protect author identities. Fig.~\\ref{banda} depicts latency as a function of $k$ for $Z = 2, \\lambda = 4$ while Fig.~\\ref{bandb} depicts the latency as a function of the client bandwidth for $k = 1, Z = 2, \\lambda = 4$. We used the \\emph{trickle} application to constraint the bandwidth at our client machine to desired values. We can see that Root ORAM enables an application designer to achieve desired trade-offs between system performance and security. It is important to note that the difference between latencies for low and high values of $k$ is significant at the regime of low client bandwidth. We provide the full data set in Appendix B.\n\n\n\\subsection{Summary}\nTo summarize, we have shown the practicality of Root ORAM through theoretical analysis, simulations and real-world experiments. . Theoretically, we have shown the bandwidth and security for different values of the protocol parameters. Experimentally, we have shown the dependence of the stash size and memory access latency on Root ORAM parameters, demonstrating the possibility of multi-dimensional trade-offs and orders of magnitude performance improvements.\n\n\n\n\\section{Related work}\\label{relatedwork}\n\nSince the formalization of the concept of an Oblivious RAM, in a seminal paper by Goldreich and Ostrovsky\\cite{goldreichoram}, the research community has made substantial progress in making ORAM practical by improving their performance~\\cite{pathoram,ringoram,gentryoramSC,burstoram,SSSoram,ren15constants,oblivistore}. Recent work has also shown the promise of using ORAMs as a critical component in developing protocols for Secure Multi-Party Computation~\\cite{gentryoramSC}.\n\nA recent benchmark for ORAMs has been the Path ORAM protocol~\\cite{pathoram}. It builds upon previous hierarchical constructions such as~\\cite{SSSoram} and gives rigorous bounds on stash usage. generalizes the construction of Path ORAM to provide a tunable framework offering differentially private guarantees. Root ORAM also reintroduces the eviction scheme of dummy/fake accesses. This was first looked into by Shi \\textit{et al.}~\\cite{logN3} and formalized in Ren \\textit{et al.}~\\cite{ren2013design}. The latter also highlights the potential pitfalls in proposing eviction schemes that are not provably secure while demonstrating the security consequences of one such scheme. Root ORAM uses  dummy accesses which are indistinguishable from real ORAM accesses and gives rigorous bounds on the security. \n\nAnother novel concept that was recently introduced in the ORAM domain was that of the XOR technique to reduce online bandwidth. Online bandwidth, first formalized by Boneh \\textit{et al.} in~\\cite{boneh2011remote} was reduced to $O(1)$ using the XOR technique by Dautrich \\textit{et al.}~\\cite{burstoram}. The XOR technique can be extended to Root ORAM as well, which will further introduce and influence the trade-offs in the design space.\n\nTwo optimizations for~\\cite{logN3} were provided by Gentry \\textit{et al.}~\\cite{gentryoramSC}. Concretely, they show the benefits of using a tree structure with multiple leaves instead of 2 as in the case of a binary tree. This idea is in similar spirit as that of Root ORAM though these differ considerably in terms of their working as well as the eviction scheme used. The higher-degree tree in the paper is a complete higher-degree tree (i.e degree of each node is the same) where as in the Root ORAM paper, the tree is binary till the last level and only the last level nodes have a higher degree. This leads to very different dynamics of the two schemes. Similarly, Root ORAM uses fake accesses as its eviction process which is different from that in~\\cite{gentryoramSC}. \n\nORAM has been implemented and shown to be feasible at a chip level in prototypes such as the Ascend architecture~\\cite{fletcher2012secure} and the Phantom architecture~\\cite{maas2013phantom}. But unlike the case of chip-level implementations where trusted local cache is expensive, most other applications have more client space. In fact, in today's settings, it is feasible to have client storage of the order of 1 GB for outsourced data of about 1 TB~\\cite{naveedpractical}. \n\nIn short, Root ORAM is the only protocol with tunable security-bandwidth construction. Similarly, none of the previous work deals with statistical privacy in the context of ORAMs. The notion and formalism of a differentially private ORAM is a novel and important contribution of our work.\n\n\n\\section{Limitations and future work}\\label{futurework}\n\nTo enable the design of stringent bandwidth constrained applications, a security-bandwidth trade-off is desirable and Root ORAM takes the first step in this direction by introducing a tunable framework that provides rigorous differential privacy guarantees. This opens up a number of research ideas which remain unexplored in the current work. \n\nFirst, we would like to explore the integration of techniques that leverage server-side computation in the Root ORAM architecture, such as the XOR technique~\\cite{boneh2011remote,burstoram}. Such an approach can trade-off bandwidth at the cost of server-side computation and can influence the design space of differentially private ORAMs. Second, we would like to explore the effect of varying the ratio of number of blocks outsourced to the size of the server-side storage. Gentry \\textit{et al.}~\\cite{gentryoramSC} have explored similar techniques in the case of Path ORAM, and it would be interesting to combine these techniques with Root ORAM.\n\nOur experimental results have demonstrated the required stash size for various parameters of Root ORAM. However, we acknowledge that Root ORAM lacks rigorous theoretical guarantees on the stash usage. In future work, it would be interesting to rigorously bound the stash size required by Root ORAM. \n\n\n\\section{Conclusions}\\label{conclusion}\nTo summarize, we present Root ORAM, a tunable family of ORAM protocols which trade-off bandwidth (performance) with security. We introduce and formalize the notion of a differentially private ORAM, which to our knowledge is the first of its kind. \n\nWe evaluate the protocol using theoretical analysis, simulations, and real world implementation on Amazon EC2. We theoretically prove that Root ORAM provides the rigorous privacy guarantee of differential privacy. We experimentally demonstrate that the stash size used by Root ORAM is bounded for realistic parameters of the scheme. Overall, Root ORAM can serve as an enabler for real-world deployment of oblivious RAM by providing novel design points that provide an order of magnitude performance improvement over current state-of-the-art. \n\n\n\n\n\\newpage\n\\bibliographystyle{plain}\n\\bibliography{./bib}\n\n\n\n\n\\newpage\n\\appendix\n\\textbf{Previous venues submitted : }This paper has not been submitted previously to any venue and is being sent for publication for the first time.\n\n\n\\section*{Appendix A} \\label{App:AppendixA}\n\n\\subsection{Max stash size vs $M$}\nWe examine the dependence of $M$ on the max stash size. This max stash size is computed as the maximum over all values of $k$ for a given value of $N$. Fig.~\\ref{fig:M_dependence} shows the results of the simulations as $M$ varies from $N$ to $10^5 \\times N$. The results show that the stash size does grow with $M$, which can be expected since the model is probabilistic\\footnote{Hence given sufficient number of accesses any amount of stash size will be overflown}. But the key conclusion here is that this growth of the maximum stash used is extremely slow as a function of $M$. From the simulations in Fig.~\\ref{fig:M_dependence}, the growth seems to be logarithmic or sub-logarithmic.\n\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=\\linewidth]{M_dependence}\n\\caption{\\textbf{This figure illustrates dependence of the maximum stash usage with the number of accesses made by the ORAM. $N=2^{10}, \\lambda=1$ were used in these simulations and the x-axis plots the number of real access ($M$). To put this in context, we start with number of access $M \\sim N$ and go all the way to $M \\sim 10^5 N$. It is important to note that though the stash size does show an increasing trend with $M$, which it should since it is a probabilistic system, its growth is extremely slow with $M$ (logarithmic or sub-logarithmic).\\protect\\footnotemark}}\n\\label{fig:M_dependence}\n\\end{figure}\n\\footnotetext{Path ORAM guarantees a Stash size of $O(\\log N)$ because their main theorem gives that $O(\\log N)$ bound for the number of accesses $M=N$. If we use Path ORAM for $xN$ accesses, then the probability of success roughly goes down exponentially in $x \\sim (1-p_f)^x$ where $p_f$ is the failure probability of ORAM. This can be worked around by not having independent simulations but it is still worth mentioning it.}\n\n\n\n\n\\section*{Appendix B} \\label{App:AppendixB}\n\nDue to high fluctuations in the bandwidth, the data points generated by real-world implementations over Amazon EC2 servers have high variation. This is pronounced in the case of the $16$ KB block size around $k=20$ and hence we provide a full box plot of all the data points here in Fig~\\ref{fig:boxplot}.\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=\\linewidth]{EC2_highband_boxplot}\n\\caption{\\textbf{Real-world implementation over EC2. This figure shows the complete box plot of the latency data for $16$ KB block size.}}\n\\label{fig:boxplot}\n\\end{figure}\n\n\n\n\n\n\n\n\n\n\n\n", "itemtype": "equation", "pos": 57276, "prevtext": "\nIf $Pr[{\\tt ORAM(r_i)} = o] > 0$ for $i = 1,2$, then we have already shown the $\\epsilon$ bound and hence $\\delta = 0$. So it remains to find the maximum $\\delta$ when one of these terms is $0$. WLOG, $Pr[{\\tt ORAM(r_1)} = o] = 0$. Hence $\\delta$ is the maximum value of $Pr[{\\tt ORAM(r_2)} = o]$ i.e the maximum probability over a neighboring sequence compared to a zero probability over the original sequence. Now, one simple upper bound on $\\delta$ can be found by noting the following: Since the probabilities used to compute for each access are at most $p_1$ (they are either $p_1$ or $p_2$ or $1/N$), we can get a quick upper bound on $\\delta$ as\n\n", "index": 43, "text": "\\begin{equation}\n\\delta \\leq p_1^{M_k} \\leq 0.5^{M_k}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\delta\\leq p_{1}^{M_{k}}\\leq 0.5^{M_{k}}\" display=\"block\"><mrow><mi>\u03b4</mi><mo>\u2264</mo><msubsup><mi>p</mi><mn>1</mn><msub><mi>M</mi><mi>k</mi></msub></msubsup><mo>\u2264</mo><msup><mn>0.5</mn><msub><mi>M</mi><mi>k</mi></msub></msup></mrow></math>", "type": "latex"}]