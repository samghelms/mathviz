[{"file": "1601.06454.tex", "nexttext": "\nwhere $c_i = a_ib_i +  \\bar{a}_i \\bar{b}_i$. The \\emph{bitwise greater than or equal to} operation, denoted $a \\unrhd b$, is defined as\n\n", "itemtype": "equation", "pos": 22404, "prevtext": "\n\n\\title{Private Processing of Outsourced Network Functions: Feasibility and Constructions\\titlenote{A preliminary version of this paper appears in the 1st ACM International Workshop on\nSecurity in Software Defined Networks \\& Network Function Virtualization. This is the full version.}}\n\n\\numberofauthors{2}\n\n\n\n\n\n\\author{\n\\alignauthor\nLuca Melis\\\\\n       \\affaddr{University College London, UK}\\\\\n       \\email{luca.melis.14@ucl.ac.uk}\n\n\\alignauthor\nHassan Jameel Asghar\\\\\n       \\affaddr{Data61, CSIRO, Australia}\\\\\n       \\email{hassan.asghar@data61.csiro.au}\n\n\\and\n\\alignauthor \nEmiliano De Cristofaro\\\\\n       \\affaddr{University College London, UK}\\\\\n       \\email{e.decristofaro@ucl.ac.uk}\n         \n\n\\alignauthor \nMohamed Ali Kaafar\\\\\n       \\affaddr{Data61, CSIRO, Australia}\\\\\n       \\email{dali.kaafar@data61.csiro.au}\n}\n\n\\maketitle\n\n\\begin{abstract}\nAiming to reduce the cost and complexity of maintaining networking infrastructures, organizations are increasingly outsourcing their network functions (e.g., firewalls, traffic shapers and intrusion detection systems) to the cloud, and a number of industrial players have started to offer network function virtualization (NFV)-based solutions. Alas, outsourcing network functions in its current setting implies that sensitive network policies, such as firewall rules, are revealed to the cloud provider. In this paper, we investigate the use of cryptographic primitives for processing outsourced network functions, so that the provider does not learn any sensitive information. More specifically, we present a cryptographic treatment of privacy-preserving outsourcing of network functions, introducing security definitions as well as an abstract model of generic network functions, and then propose a few instantiations using partial homomorphic encryption and public-key encryption with keyword search. We include a proof-of-concept implementation of our constructions and show that network functions can be privately processed by an untrusted cloud provider in a few milliseconds.\n\\end{abstract}\n\n\n\\section{Introduction}\n\\label{sec:intro}\n\nNetwork functions, such as firewalls and load balancers, are increasingly moving to ``the cloud'' by means of software processes outsourced on commodity servers. \n\nUsing virtualization, network functions can be emulated in software in a cost-effective manner, and outsourced to the cloud reaping the benefits of reduced management and infrastructure costs, pay-per-use, etc.~\\cite{aplomb}.\nSpecifically, network function virtualization (NFV) is currently being proposed by several major industrial operators like Cisco, Alcatel-Lucent, and Arista, as a service to multiple clients~\\cite{top26}. \n\n\nIn such a multi-tenancy setting, network functions are run on virtual machines (VMs) belonging to different clients hosted on the same hardware (server). Naturally, this raises a number of security concerns for clients, including confidentiality and integrity. While such issues are common to IT infrastructure outsourcing in general~\\cite{cloud-visor}, more specific to NFV is the sensitivity of an organization's proprietary network policies, which instruct how network functions are to be performed. These are potentially vulnerable to compromise from competing organizations as well as the cloud service provider itself. \nFor instance, firewall rules do not only reveal IP addresses of hosts, network topology, etc., but also\ndefense strategies and sensitivity of different services and resources, which, in the traditional setting,\nare only known to a few network administrators~\\cite{bf-firewall, mlm-firewall}. \n\nWhile virtual machine isolation~\\cite{cloud-visor} could potentially address some of these issues, they are inadequate to provide privacy against the operator, i.e., the cloud service provider. \n\n{\\medskip\\noindent\\textbf{{Problem Statement}.}} These challenges motivate the need to protect the privacy of network policies \nagainst an untrusted cloud provider, as well as other tenants and third parties. In the rest of the paper, we call this the \\emph{private NFV problem}, which, as we discuss in Section~\\ref{sec:related}, has been largely overlooked by prior work on NFV security. \n\n\nWe define a generic model to define privacy in NFV and propose several solutions based on different cryptographic primitives such as fully homomorphic encryption, partial homomorphic encryption and public-key encryption with keyword search. The solutions result from tradeoffs between privacy and performance, and can be instantiated depending on the adversarial model, \nshowing that private processing of outsource network functions is already feasible today by adapting a few existing cryptographic primitives.\n\n\n{\\medskip\\noindent\\textbf{{Contributions}.}} We construct an abstract model of network functions which seeks to generalize most of the network functions used in practice as well as relevant adversarial models (Sections~\\ref{sec:problem} and~\\ref{sec:theory}). Then, based on this abstraction, we propose three different solutions: an ideal, yet not very efficient, one based on fully homomorphic encryption, and two more practical solutions based on partial homomorphic encryption and public-key encryption with keyword search (PEKS), secure \nin two different adversarial models, which we define as {\\em strong} and {\\em weak} (Section ~\\ref{sec:solutions}). \n\nOur solution against the weak adversary is also the first to include stateful network functions, e.g., a stateful firewall that keeps track of open TCP/IP connections.\n\nFinally, we present a proof-of-concept implementation of our schemes \nand evaluate their performance overhead using an outsourced firewall as a use-case (Section~\\ref{sec:implement}). Using a typical 5-tuple based firewall rule, we show that a packet can be processed within 109 ms and 180 ms, respectively, using our solutions secure against the weak and the strong adversary, and demonstrate that our schemes scale quite well, as processing times reach 250 ms and 1,208 ms, respectively, using 10 rules. Bearing in mind that our proof-of-concept implementation is not optimised for efficiency (e.g., lack of multi-threading), our results indicate that private NFV is feasible using existing cryptographic primitives.\n\n\n\n\n\n\\section{Related Work}\n\\label{sec:related}\n\n\nKhakpour and Liu~\\cite{bf-firewall} introduce a data structure called Bloom Filter Firewall Decision Diagram (BFFDD) in order to anonymize firewall policies built from Firewall Decision Diagrams (FDD)~\\cite{fdd}. However, as acknowledged by the authors, Bloom filters~\\cite{bloom1970space} naturally introduce false positives. Thus, occasionally, packets that do not match any policy are (mistakenly) dropped by the firewall. Furthermore, security/privacy of their solution is argued against a black-box assumption of Bloom filters, which does not analyze the security properties of Bloom filters themselves (such as one-wayness).\n\n\nShi, Zhang, and Zhong~\\cite{mlm-firewall} use \nmultilinear maps from Coron, Lepoint and Tibouchi (CLT), which are\nbased on \\emph{graded encoding systems}~\\cite{mlm-integers}, to encode each bit of a firewall rule as a pair of level-1 encodings and a level-$(n + 1)$ encoding for the whole rule, where $n$ is the length of a possible packet. Following the security properties of the multilinear map, it is not possible to obtain level-$i$ or lower encodings given a level-$(i+1)$ encoding for each $i$. Upon receiving a packet, the encodings corresponding to the bits of the packet are multiplied and the result is then matched with the level-$(n+1)$ encoding for the whole policy through a procedure called \\texttt{isZero}. Unfortunately, the CLT construction has been recently shown to be insecure, due to an attack on the \\texttt{isZero} routine~\\cite{mlm-cryptanalysis}; a key ingredient to check if a packet matches a policy.\n\nAlthough both these constructions focus specifically on outsourcing firewalls, they exclude details of how state tables can be maintained in their framework by a stateful firewall. Furthermore, due to being specific to firewalls, their solutions are only relevant to policies that result in a binary decision (allow or deny), excluding network functions that modify packet contents or perform more complex actions. Compared to these two solutions, our solutions for private NFV cover a much broader range of network functions, including firewalls, and also consider state tables. \n\nPrivate NFV also resembles real-time processing over encrypted packets. The work in \\cite{blindbox} discusses deep packet inspection over encrypted data, however, it requires the sender (third party) to be a participant in the protocol, which makes it impossible to use this solution on existing infrastructures (a requirement that we describe as compatibility in Section~\\ref{sec:desired}). \n\n\n\nSomewhat related is work on outsourcing frameworks in Software Defined Networks. Specifically,  \nSherry et al.~\\cite{aplomb} provide a prototype of the APLOMB architecture, where the middlebox functionalities (e.g. firewall) are outsourced to the cloud by the enterprises without greatly damaging throughput.\n\nGibb et al.\\cite{waypoints} then present an architecture in which enterprise networks only forward data and additional processing is performed by external feature providers without any limitation on location. However, \\cite{aplomb,waypoints} do not consider private processing.\n\nSecurity issues in outsourcing network functions are also studied in, e.g.,, which provide a roadmap on the construction of a verifiable network function architecture that can verify the correctness of the outsourced service w.r.t. functionality, performance, and actual workload in the cloud.\nIn general, concerns raised from the the lack of control with cloud outsourcing have been investigated in~\\cite{chow2009controlling}, while, addresses the problem of auditing outsourced computation by providing a monitor system that efficiently and verifiably tracks memory use and CPU-cycle consumption in the cloud.\nRemote attestation and verification are also studied  by Haeberlen et al.~\\cite{vu2013hybrid}, who propose an efficient method for verifying specific types of computation, while~\\cite{haeberlen2010accountable} introduces accountable virtual machines without trusted hardware.\n\nFinally, Zhang et al.~\\cite{zhang2008packet} and Argyraki et al.~\\cite{argyraki2010verifiable} provide mechanisms to ensure accountable networking by discovering entities that drop packets in a malicious way.\n\n\n\n\\begin{figure*}[!htb]\n\\centering\\includegraphics[scale=0.38]{figures/nfv-diagram.pdf}\n\\caption{Network Function Virtualization.}\n\\label{fig:nfv-diagram}\n\\end{figure*}\n\n\n\n\n\n\n\\section{Preliminaries}\n\\label{sec:problem}\nThis section introduces the problem of private processing of outsourced network functions.\n\n\n\n\n\\subsection{Examples of Network Functions}\nIn the rest of the paper, we consider outsourcing of simple network functions, \nsuch as those presented below, along with the related (simplified) policies.\n\n\t{\\medskip\\noindent\\textbf{{Firewall}.}} The simplest example of a firewall policy is to drop a packet if the source IP address belongs to a given IP range.\n\t \n\t{\\medskip\\noindent\\textbf{{Load Balancer}.}} A load balancer distributes incoming packets across different servers to minimize load on one or more servers. A typical load distributing algorithm is round-robin. For instance, if the IP address of the server currently at the top of the list is \\texttt{192.168.0.1}, then the destination IP address of the packet should be changed to this IP address. \n\n\t{\\medskip\\noindent\\textbf{{Carrier-grade NAT}.}} A carrier-grade network address translator maps private IP addresses (and ports) within a private network to one or more public IP addresses (and ports), to reduce the number of public IP addresses required. An example of a NAT policy is that if the destination IP of an incoming packet is \\texttt{213.145.163.231} and the destination port is \\texttt{5000}, the destination IP and port should be changed to \\texttt{196.168.0.1} and \\texttt{22}, respectively.\n\t\n\t\n\n\t{\\medskip\\noindent\\textbf{{IDS}.}} An intrusion detection system scans packets to detect any malicious traffic. An example policy could be that if the destination IP address of an incoming packet is \\texttt{192.168.0.1} and the payload contains a \\texttt{POST} request then an \\texttt{alert} message should be sent.\n\n\t{\\medskip\\noindent\\textbf{{DPI}.}} Deep packet inspection filters packets by inspecting it for viruses or other content such as pornography. An example policy could be that if an incoming packet contains the word \\texttt{adult} in its contents, then the packet should be dropped.\n\n\n\\subsection{System Model} \n\nIn the rest of the paper, we consider a scenario where an organization, the \\textit{client}, outsources one or more of its network functions to the \\textit{cloud}, as illustrated in Figure~\\ref{fig:nfv-diagram}. The outsourced network functions run within virtual machines (VMs) on commodity servers provided by the cloud. We call this the {\\em NFV setting} -- as opposed to the {\\em traditional} setting in which dedicated network middleboxes perform network functions within the client's private network.  Analogous to other cloud platforms, such VMs are managed through hypervisors~\\cite{click-os}. \n\n{\\medskip\\noindent\\textbf{{Cloud and Client Middleboxes}.}} To ease presentation, we denote the set of all VMs executing virtual network functions as the {\\em cloud middlebox}, or {\\em cloud MB} for short. Not all network functionalities need to be outsourced to the cloud, and as such the client still requires its own middlebox to carry out the remaining network functions or to communicate with the cloud MB. We call this the {\\em client middlebox}, or {\\em client MB} for short. The cloud MB receives inbound traffic destined for the client, processes the network functions assigned to it, and forwards the result to the client MB. Outbound traffic is the one originating from within the client's private network which is forwarded by the client MB to the cloud MB to process the outsourced network functions and subsequently relay it to its intended destination. The network policies which describe how the network functions are to be processed are installed in the cloud MB by the client. \n\n{\\medskip\\noindent\\textbf{{Trust Assumptions}.}} We assume the cloud MB to be honest-but-curious, i.e., it performs network functions dutifully yet wishes to infer the policies. Later on in this paper, for some of the proposed solutions, we will assume that the cloud MB has a \\emph{semi-trusted} component, which we call the \\emph{entry MB}. The entry MB receives the packet and performs some preliminary processing before handing the results over to the cloud MB. Ideally there should be no entry MB, i.e., no part of the cloud MB should be assumed to be part of black-box processing. However, inclusion of an entry MB remarkably improves performance, and its presence is reasonable assuming that the cloud is honest-but-curious. Also, remark that the entry MB does not share any private keys with the client MB, and all the processing is done using public-key operations. \n\n\n\n\n\n\n\n\n\\subsection{Desired Properties}\\label{sec:desired}\nIn the traditional setting, most network functions are run on dedicated middleboxes located at the edge of the client's private network. As a result, the network policies are hidden from outsiders as long as the hardware is secure. Once a network function is outsourced to the cloud, obviously, it is no longer the case. Ideally, the client would want its network policies to remain private while maintaining the standards of service set by the traditional setting. \n\n{\\medskip\\noindent\\textbf{{Privacy}.}} The client expects its network policies to remain hidden not only from \nthird parties, but also from other tenants and the cloud. \n\n\n\n\n\nWe argue that the cloud should not be trusted to keep the policies secret, even though it processes the network functions for the client. At best, the client can only assume that the cloud is {\\em honest-but-curious}, i.e., it performs all the network functions as required due to service obligations and does not deviate from protocol specification, but it might still be interested in inferring network policies, possibly by colluding with another party. \n\nAlso, due to virtualization, it is likely that two VMs computing network functions of two (possibly competing) tenants might be residing in the same physical server, thus, a client's network policies should be kept secret from another client.\n\n\n\n\n{\\medskip\\noindent\\textbf{{Performance}.}} The client expects the outsourced network functions to maintain the quality of service of the traditional setting. This introduces the following constraints.\n\\begin{itemize}\n\t\\item \\textit{Real-time Processing}: The cloud MB should be able to process network functions in real-time.\n\t\\item \\textit{Minimal Client-side Processing}: The client MB should be processing as little of the policies as possible in order to maintain the benefits of network function outsourcing. \n\\end{itemize}\n\n{\\medskip\\noindent\\textbf{{Compatibility}.}} Third parties should be able to send/receive traffic to/from the client as if the network functions are implemented in the traditional setting, i.e., third parties should not be required to undergo additional setup (e.g., implementation of customized network and cryptographic protocols) \nto communicate with the client.\n\\smallskip\n\n\nNaturally, any solution for a private NFV will likely introduce a tradeoff between  privacy and compatibility/performance: our goal is to explore the balance between security and performance, while satisfying the compatibility constraint.\n \n\n\n\n\\subsection{Limitations and Scope}\nBefore introducing our solutions, we discuss a few limitations of our model and make some important remarks.\n\n\n{\\medskip\\noindent\\textbf{{Traffic Analysis}.}} An adversary may intercept and analyze traffic between the cloud MB and a third party and try to infer network policies based on the pattern of inbound and outbound packets. Likewise, the adversary may generate its own traffic destined for the client (through the cloud MB) and analyze the packets it receives in response. For instance, if a request has been sent from a certain IP address for a TCP/IP connection, and a response has not been received, then the adversary may infer that it is a policy to drop packets from this particular IP address. However, note this can also be done in the traditional setting, and we require that solutions for private NFV do not need to provide privacy beyond what can be achieved in the traditional setting. \n\n{\\medskip\\noindent\\textbf{{Virtual Machine Isolation}.}} One way to achieve private NFV is through VM isolation, e.g., isolation of memory and disk storage, together with the assumption that the hypervisor belongs to a trusted base~\\cite{nohype, sel4, cloud-visor}. A crucial aspect for secure isolation is to ensure that the hypervisor, i.e., trusted computing base, is small in terms of lines of codes (LoC)~\\cite{hypersafe,cloud-visor}, which ensures that security vulnerabilities are minimized or, if identified, can be easily patched~\\cite{sel4}. There are, however, several issues with this approach. \n(1)~Small hypervisors are needed to formally verify correctness and security properties, and some simplifying assumptions are required, e.g., w.r.t. the correctness of the compiler and the hardware, the presence of a uniprocessor instead of multiprocessors, etc., as in the case of the formal verification of the operating system kernel ``sel4''~\\cite{sel4}. Also, it may be possible to iteratively verify a hypervisor by shedding each layer of simplifying assumptions. (2)~Unfortunately, commodity hypervisors are not optimized in terms of lines of codes~\\cite{cloud-visor}, thus it is a strong assumption to assume they are trusted. (3)~Cross-VM side-channel attacks can also enable a malicious VM to be co-located at the physical host of the target VM and exploit various side channels (e.g., cache), to obtain information such as cryptographic keys~\\cite{hey-you, zhang-juels}. \n\n\n{\\medskip\\noindent\\textbf{{Coverage of Network Functions}.}} Our goal is to provide solutions to private NFV that are applicable to most network functions, ideally, encompassing all possible network functions. However, one cannot make such claim\nwithout checking the implementation details of each and every network function in practice. Rather, we give a broad definition of network functions and provide solutions to private NFV that cover network functions satisfying this definition, which can be incrementally modified to cover more functions. For instance, we do not consider traffic shaping, where delivery of certain packets is delayed (at the cloud's side) to satisfy performance guarantees. \n\n\n{\\medskip\\noindent\\textbf{{Inbound vs Outbound Traffic}.}} In this work, we focus on {\\em inbound} traffic, i.e., traffic coming from third parties toward the client. Although our private NFV solutions (presented next) are applicable to outbound traffic as well, this would require redirecting traffic from the cloud MB (after private processing of network functions) to the client MB, which in turn forwards it to the third party receiver. \n\n\n\n\n\n\n\\section{Mathematical Formulation}\n\\label{sec:theory}\n\n\n\n\nLet $n$ be a positive integer and $\\mathbf{x}$ and $\\mathbf{y}$ be $n$-element vectors: then\n\n$\\langle \\mathbf{x}, \\mathbf{y} \\rangle$ denotes their dot product. The dot product of a vector $\\mathbf{x}$ with itself, i.e., $\\langle \\mathbf{x}, \\mathbf{x} \\rangle$ is denoted by $\\mathbf{x}^2$. The Hadamard product or the entry-wise product of the vectors $\\mathbf{x}$ and $\\mathbf{y}$ is $\\mathbf{x} \\circ \\mathbf{y}$,\ni.e., the $n$-element vector whose $i$-th element is $x_iy_i$. The vector $\\mathbf{e}_i$ denotes the $n$-element vector with all $0$s except a $1$ in the $i$-th position.\n\nGiven two positive integers $a$ and $b$, the \\emph{bitwise AND} operation, denoted $a \\odot b$, outputs $1$ if the binary representation of $a$ and $b$ agrees in all bit positions. More specifically, if we assume $a$ and $b$ to be $n$-bit binary numbers and let $a_i$ and $b_i$ denote their $i$-th bits with the most significant bit at position $n$, then\n", "index": 1, "text": "\n\\[\na \\odot b = c_n c_{n-1} \\cdots c_1, \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"a\\odot b=c_{n}c_{n-1}\\cdots c_{1},\" display=\"block\"><mrow><mrow><mrow><mi>a</mi><mo>\u2299</mo><mi>b</mi></mrow><mo>=</mo><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>c</mi><mn>1</mn></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhich is $1$ if $a \\ge b$ and $0$ otherwise. The \\emph{bitwise less than or equal to} operation, denoted $a \\unlhd b$, is defined similarly with the roles of $a$ and $b$ interchanged. \n\n\n\n\n\nThe encryption function $E$ on a vector $\\mathbf{x}$ is defined as the vector\n", "itemtype": "equation", "pos": 22584, "prevtext": "\nwhere $c_i = a_ib_i +  \\bar{a}_i \\bar{b}_i$. The \\emph{bitwise greater than or equal to} operation, denoted $a \\unrhd b$, is defined as\n\n", "index": 3, "text": "\\begin{align*}\na \\unrhd b &= a_n\\bar{b}_n + c_n a_{n-1}\\bar{b}_{n-1} + c_n c_{n-1} a_{n-2}\\bar{b}_{n-2} + \\cdots \\\\\n\t\t\t\t  &+ c_n \\cdots c_2 a_{1}\\bar{b}_{1} + c_n c_{n-1} \\cdots c_1,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle a\\unrhd b\" display=\"inline\"><mrow><mi>a</mi><mo>\u22b5</mo><mi>b</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=a_{n}\\bar{b}_{n}+c_{n}a_{n-1}\\bar{b}_{n-1}+c_{n}c_{n-1}a_{n-2}%&#10;\\bar{b}_{n-2}+\\cdots\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mover accent=\"true\"><mi>b</mi><mo stretchy=\"false\">\u00af</mo></mover><mi>n</mi></msub></mrow><mo>+</mo><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><msub><mover accent=\"true\"><mi>b</mi><mo stretchy=\"false\">\u00af</mo></mover><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>\u2062</mo><msub><mover accent=\"true\"><mi>b</mi><mo stretchy=\"false\">\u00af</mo></mover><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow><mo>+</mo><mi mathvariant=\"normal\">\u22ef</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+c_{n}\\cdots c_{2}a_{1}\\bar{b}_{1}+c_{n}c_{n-1}\\cdots c_{1},\" display=\"inline\"><mrow><mrow><mrow><mo>+</mo><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>c</mi><mn>2</mn></msub><mo>\u2062</mo><msub><mi>a</mi><mn>1</mn></msub><mo>\u2062</mo><msub><mover accent=\"true\"><mi>b</mi><mo stretchy=\"false\">\u00af</mo></mover><mn>1</mn></msub></mrow></mrow><mo>+</mo><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>\u2062</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>c</mi><mn>1</mn></msub></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\n\n\nFor positive integers $a < b$, the notation $[a, b]$ denotes all integers between $a$ and $b$ inclusive. The notation $[n]$, for a positive integer $n$, defines the set $\\{1, 2, \\ldots, n\\}$.\n\n\n\n\n\n\n\n\\subsection{Network Functions}\nLet $n \\ge 1$ and $q \\ge 2$ be positive integers. We define a packet $\\mathbf{x}$ as a vector in $\\mathbb{Z}^{n}_q$, where $n$ represents the different fields of the packet (source IP address, protocol type, etc.) and $q$ is an upper bound on the length of packet fields. Although it is much natural to define a packet as a bit string of bounded length ($2^{16}$ in case of IPv4 packets), we prefer our definition as it facilitates the description of private NFV solutions later on. A network function $\\psi$ from $\\mathbb{Z}^{n}_q$ onto $\\mathbb{Z}^{n}_q$ is the pair $(m, a)$ defined as\n\n", "itemtype": "equation", "pos": 23047, "prevtext": "\nwhich is $1$ if $a \\ge b$ and $0$ otherwise. The \\emph{bitwise less than or equal to} operation, denoted $a \\unlhd b$, is defined similarly with the roles of $a$ and $b$ interchanged. \n\n\n\n\n\nThe encryption function $E$ on a vector $\\mathbf{x}$ is defined as the vector\n", "index": 5, "text": "\n\\[\nE(\\mathbf{x}) = \n\\begin{pmatrix}\nE(x_1) & E(x_2) & \\cdots & E(x_n)\n\\end{pmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"E(\\mathbf{x})=\\begin{pmatrix}E(x_{1})&amp;E(x_{2})&amp;\\cdots&amp;E(x_{n})\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhere $m : \\mathbb{Z}^{n}_q \\rightarrow \\{0, 1\\}$ is called the matching function, and $a: \\mathbb{Z}^{n}_q \\rightarrow \\mathbb{Z}^{n}_q$ is the action function, or simply the {\\em action}. The intuitive meaning of the above is that when a network function receives a packet $\\mathbf{x}$ the matching function decides whether the current network function applies to this packet. If yes, the relevant action is performed by the action function altering the packet to $\\mathbf{x}'$. If the result of the match is negative, the packet is left unchanged. \n\nIn some cases, a network policy will be composed of several network functions as defined above -- in this case, we iteratively define the resulting network function as:\n\n", "itemtype": "equation", "pos": 23957, "prevtext": "\n\n\nFor positive integers $a < b$, the notation $[a, b]$ denotes all integers between $a$ and $b$ inclusive. The notation $[n]$, for a positive integer $n$, defines the set $\\{1, 2, \\ldots, n\\}$.\n\n\n\n\n\n\n\n\\subsection{Network Functions}\nLet $n \\ge 1$ and $q \\ge 2$ be positive integers. We define a packet $\\mathbf{x}$ as a vector in $\\mathbb{Z}^{n}_q$, where $n$ represents the different fields of the packet (source IP address, protocol type, etc.) and $q$ is an upper bound on the length of packet fields. Although it is much natural to define a packet as a bit string of bounded length ($2^{16}$ in case of IPv4 packets), we prefer our definition as it facilitates the description of private NFV solutions later on. A network function $\\psi$ from $\\mathbb{Z}^{n}_q$ onto $\\mathbb{Z}^{n}_q$ is the pair $(m, a)$ defined as\n\n", "index": 7, "text": "\\begin{equation}\n\\label{eq:nf}\n\\psi(\\mathbf{x}) = m(\\mathbf{x})a(\\mathbf{x}) + (1 - m(\\mathbf{x}))\\mathbf{x}, \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\psi(\\mathbf{x})=m(\\mathbf{x})a(\\mathbf{x})+(1-m(\\mathbf{x}))\\mathbf{x},\" display=\"block\"><mrow><mrow><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc31</mi></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nfor $i \\ge 1$. \n\n\n\n\n\nThe definition of $\\psi$ as a match-action pair is motivated by the OpenFlow communications protocol between the control and forwarding planes in Software Defined Networks (SDN)~\\cite{openflow}, which use flow tables containing match fields and the corresponding actions to be carried out. \n\nNote that different fields of a packet are not necessarily of the same length, e.g., if we consider IP packets then the version field (i.e., IPv4 or IPv6) is 4 bits long while the source IP field is 32 or 128 bits long (IPv4 or IPv6 packets). Therefore, we consider a value $q$ that is large enough to incorporate the largest header field.\n\nThis is for theoretical convenience, and any superfluous bits for smaller fields can be duly discarded. The packet payload, which can be much larger, is divided into chunks of length $\\log_2 q$ bits. \n\n{\\medskip\\noindent\\textbf{{Virtual Fields}.}} Besides the standard fields, we assume the presence of additional ones, which we call \\emph{virtual} fields. These  originate from the implementation of our private NFV instantiations and are inserted in the payload of the packet. For instance, a \\emph{tag} field will be used to model a common functionality of network functions such as the firewall and rate limiter, to drop packets matching certain criteria. To indicate that a packet is to be dropped, the cloud MB can assign the value \\texttt{drop} to this tag (contained in the IP packet's payload) and send it to the client MB. How this value is added in a private way is described in Section~\\ref{sec:solutions} and how these virtual fields can be added to the packet is described in Section~\\ref{sec:implement}.\n\n\n\n\n{\\medskip\\noindent\\textbf{{Example}.}}\nWe assume a simple network address translation (NAT) policy as a running example. For instance, upon receiving a packet $\\mathbf{x}$ with destination IP in the range \\texttt{128.*.*.*}, the NAT changes the destination IP and port to \\texttt{196.*.*.*} and \\texttt{22}, respectively. Without loss of generality, we assume that the destination IP and destination port belong to the first two elements of $\\mathbf{x}$, i.e., $x_1$ and $x_2$. Thus, the matching function is: \n", "itemtype": "equation", "pos": 24805, "prevtext": "\nwhere $m : \\mathbb{Z}^{n}_q \\rightarrow \\{0, 1\\}$ is called the matching function, and $a: \\mathbb{Z}^{n}_q \\rightarrow \\mathbb{Z}^{n}_q$ is the action function, or simply the {\\em action}. The intuitive meaning of the above is that when a network function receives a packet $\\mathbf{x}$ the matching function decides whether the current network function applies to this packet. If yes, the relevant action is performed by the action function altering the packet to $\\mathbf{x}'$. If the result of the match is negative, the packet is left unchanged. \n\nIn some cases, a network policy will be composed of several network functions as defined above -- in this case, we iteratively define the resulting network function as:\n\n", "index": 9, "text": "\\begin{equation}\n\\label{eq:nf-comp}\n\\psi^{i}(\\mathbf{x}) = \\psi_i(\\cdots\\psi_2(\\psi_1(\\mathbf{x}))\\cdots)\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\psi^{i}(\\mathbf{x})=\\psi_{i}(\\cdots\\psi_{2}(\\psi_{1}(\\mathbf{x}))\\cdots)\" display=\"block\"><mrow><mrow><msup><mi>\u03c8</mi><mi>i</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>\u03c8</mi><mi>i</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\u03c8</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c8</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nand the action is:\n", "itemtype": "equation", "pos": 27113, "prevtext": "\nfor $i \\ge 1$. \n\n\n\n\n\nThe definition of $\\psi$ as a match-action pair is motivated by the OpenFlow communications protocol between the control and forwarding planes in Software Defined Networks (SDN)~\\cite{openflow}, which use flow tables containing match fields and the corresponding actions to be carried out. \n\nNote that different fields of a packet are not necessarily of the same length, e.g., if we consider IP packets then the version field (i.e., IPv4 or IPv6) is 4 bits long while the source IP field is 32 or 128 bits long (IPv4 or IPv6 packets). Therefore, we consider a value $q$ that is large enough to incorporate the largest header field.\n\nThis is for theoretical convenience, and any superfluous bits for smaller fields can be duly discarded. The packet payload, which can be much larger, is divided into chunks of length $\\log_2 q$ bits. \n\n{\\medskip\\noindent\\textbf{{Virtual Fields}.}} Besides the standard fields, we assume the presence of additional ones, which we call \\emph{virtual} fields. These  originate from the implementation of our private NFV instantiations and are inserted in the payload of the packet. For instance, a \\emph{tag} field will be used to model a common functionality of network functions such as the firewall and rate limiter, to drop packets matching certain criteria. To indicate that a packet is to be dropped, the cloud MB can assign the value \\texttt{drop} to this tag (contained in the IP packet's payload) and send it to the client MB. How this value is added in a private way is described in Section~\\ref{sec:solutions} and how these virtual fields can be added to the packet is described in Section~\\ref{sec:implement}.\n\n\n\n\n{\\medskip\\noindent\\textbf{{Example}.}}\nWe assume a simple network address translation (NAT) policy as a running example. For instance, upon receiving a packet $\\mathbf{x}$ with destination IP in the range \\texttt{128.*.*.*}, the NAT changes the destination IP and port to \\texttt{196.*.*.*} and \\texttt{22}, respectively. Without loss of generality, we assume that the destination IP and destination port belong to the first two elements of $\\mathbf{x}$, i.e., $x_1$ and $x_2$. Thus, the matching function is: \n", "index": 11, "text": "\n\\[\nm(\\mathbf{x}) = \\begin{cases}\n\t\t\t\t1 & \\text{if } x_1 \\in [\\texttt{128.0.0.0}, \\texttt{128.255.255.255}]\\\\\n\t\t\t\t0 & \\text{otherwise}\n\t\t\t\t\\end{cases},\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"m(\\mathbf{x})=\\begin{cases}1&amp;\\text{if }x_{1}\\in[\\texttt{128.0.0.0},\\texttt{128%&#10;.255.255.255}]\\\\&#10;0&amp;\\text{otherwise}\\end{cases},\" display=\"block\"><mrow><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mn>1</mn></mtd><mtd columnalign=\"left\"><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mtext mathvariant=\"monospace\">128.0.0.0</mtext><mo>,</mo><mtext mathvariant=\"monospace\">128.255.255.255</mtext><mo stretchy=\"false\">]</mo></mrow></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mn>0</mn></mtd><mtd columnalign=\"left\"><mtext>otherwise</mtext></mtd></mtr></mtable></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\n(Note that the IP addresses are mapped in $\\mathbb{Z}_q$.)\n\n\n\n\n\n\n\\subsection{Stateful Network Functions}\nSome network functions such as (stateful) firewalls maintain dynamically generated states. When a packet arrives, it is first checked against the state table to see if any entry in the state table matches the fields of the packet. If a matching entry is found, the prescribed action is performed on the packet and it does not need to be further processed by other (static) policies. An example is the state of TCP connection maintained by a firewall, as depicted in Table~\\ref{table:state}. The firewall notes a \\textit{new} connection when the SYN flag in a packet is set, and creates an entry in the state table containing, for instance, the source/destination IPs and ports and protocol type (6 for TCP) along with the current state. Upon receiving a SYN-ACK from the destination and a subsequent ACK flag from the source, the firewall changes the state of this connection to \\textit{established} (shown as \\texttt{est} in the table). Any subsequent packets that satisfy the headers contained in the state table entry are then allowed to go through without further processing of the network policies. The state table entry is deleted once the FIN-ACK part of the TCP protocol is carried out, or when the connection times out. \n\n\\begin{table}[!h]\n\\centering\n\n\\resizebox{1.025\\linewidth}{!}{\n\\setlength\\tabcolsep{2pt} \n\\begin{tabular}{l|l|r|l|r|r|r|r} \nID   & src IP & src port  & dst IP & dst port  & prot  & state & timeout  \\\\\n\\hline\n1 & \\texttt{192.168.1.1} & \\texttt{120} & \\texttt{192.168.1.2} & \\texttt{121} & \\texttt{6} & \\texttt{new} & \\texttt{59}\\\\\n2 & \\texttt{192.168.1.129}  & \\texttt{45} & \\texttt{192.168.1.140}   & \\texttt{8080} & \\texttt{6} & \\texttt{est} & \\texttt{3600}\n\\end{tabular}\n}\n\\vspace{-0.1cm}\n\\caption{An example of a firewall state table.}\n\\label{table:state}\n\\vspace{-0.1cm}\n\\end{table}\n\nWe note that in our model, state tables can be abstracted as dynamic match-action pairs, where the state and time-out columns in the state table can be thought of as \\textit{virtual} fields of the IP packet and the action as the addition of the \\texttt{tag} field with value ``allow''. However, one key difference is that once a match has been found, further processing is discontinued.\\footnote{There are network functions for which this is not true, e.g., traffic monitoring in which aggregate statistics of packets, such as number of packets received, are maintained.} Therefore, any private solution to a stateful middlebox should have the property that execution is allowed to stop once a match in the state table is found---otherwise there would be no performance gain from maintaining state. \n\n\n\n\n\n\n\n\\subsection{Private Processing of Outsourced Network Functions}\nOur goal is to provide privacy of an outsourced network function $\\psi$ given a set of packets $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_t$. From an adversarial perspective, the network function $\\psi$ can be learned either directly through the description of $(m, a)$ or indirectly by deducing from the outputs $\\psi(\\mathbf{x}_1), \\psi(\\mathbf{x}_2), \\ldots, \\psi(\\mathbf{x}_t)$. In order to achieve privacy, we therefore need a scheme that protects both the network function $\\psi$ and its output. We call this PNFV (Private NFV). Let $\\mathbf{x}$ be a packet as defined before and $\\psi$ be a network function such that $\\psi(\\mathbf{x}) = \\mathbf{x}'$.\n\n\\subsubsection{PNFV}\n\\vspace{-0.25cm}\n\\begin{definition}[PNFV]\nA public-key PNFV scheme is a tuple \n$(\\mathsf{kg}, \\mathsf{enc}, \\mathsf{dec}, \\mathsf{tr}, \\mathsf{proc})$\nof probabilistic polynomial time algorithms defined as follows:\n\\begin{compactitem}\n\\item {\\em Key generation:} The algorithm $s, p \\leftarrow \\mathsf{kg}(1^k)$ returns the secret key $s$ and public key $p$, where $k$ is the security parameter.\n\\item {\\em Packet encryption:} The algorithm $E(\\mathbf{x}) \\leftarrow \\mathsf{enc}(p, \\mathbf{x})$ takes as input the public key $p$ and the packet $\\mathbf{x}$ and outputs the encrypted version $E(\\mathbf{x})$. Note that this is element-wise encryption, which results in $n$ ciphertexts.\n\\item {\\em Network function transformation:} The algorithm $\\phi \\leftarrow \\mathsf{tr}(\\psi)$ takes as input the network function $\\psi$ and outputs a \\emph{transformed} network function $\\phi$. \n\\item {\\em Packet processing:} The algorithm $E(\\mathbf{x}') \\leftarrow \\mathsf{proc}(\\phi, E(\\mathbf{x}))$ takes as input the transformed network function $\\phi$ and the encrypted packet $E(\\mathbf{x})$ and outputs the encryption of $\\mathbf{x}'$. \n\\item {\\em Packet decryption:} The algorithm $\\mathbf{x}' \\leftarrow \\mathsf{dec}(s, E(\\mathbf{x}'))$ takes as input the secret key $s$ and the encryption of $\\mathbf{x}'$ and outputs $\\mathbf{x}'$. We may write $D(E(\\mathbf{x}))$ to represent $\\mathsf{dec}(s, E(\\mathbf{x}))$.\n\\end{compactitem}\n\\end{definition}\n\nConcisely, we can define the output of PNFV given $\\mathbf{x}$ and $\\psi$ as $\\text{PNFV}(\\mathbf{x}, \\psi)$. Thus,\n", "itemtype": "equation", "pos": 27286, "prevtext": "\nand the action is:\n", "index": 13, "text": "\n\\[\na(\\mathbf{x}) = \n\\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\nx_3 \\\\\n\\vdots \\\\\nx_n\t\t\t\n\\end{pmatrix} +\n\\begin{pmatrix}\nx_1 + \\texttt{68.0.0.0} \\\\\n-x_2 + 22 \\\\\n0 \\\\\n\\vdots \\\\\n0\t\t\t\n\\end{pmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"a(\\mathbf{x})=\\begin{pmatrix}x_{1}\\\\&#10;x_{2}\\\\&#10;x_{3}\\\\&#10;\\vdots\\\\&#10;x_{n}\\end{pmatrix}+\\begin{pmatrix}x_{1}+\\texttt{68.0.0.0}\\\\&#10;-x_{2}+22\\\\&#10;0\\\\&#10;\\vdots\\\\&#10;0\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr><mtr><mtd columnalign=\"center\"><msub><mi>x</mi><mi>n</mi></msub></mtd></mtr></mtable><mo>)</mo></mrow><mo>+</mo><mrow><mo>(</mo><mtable displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"center\"><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mtext mathvariant=\"monospace\">68.0.0.0</mtext></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mrow><mrow><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><mo>+</mo><mn>22</mn></mrow></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr><mtr><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ee</mi></mtd></mtr><mtr><mtd columnalign=\"center\"><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nKey generation, network function transformation, and packet decryption algorithms are computed by the client MB, while the remaining two algorithms are processed by the cloud MB. We have the following definition for correctness.\n\n\\begin{definition}[Correctness]\nA \\emph{public-key} {\\em PNFV} scheme is correct if for all $\\mathbf{x} \\in \\mathbb{Z}_q^n$ it holds that  \n", "itemtype": "equation", "pos": 32513, "prevtext": "\n(Note that the IP addresses are mapped in $\\mathbb{Z}_q$.)\n\n\n\n\n\n\n\\subsection{Stateful Network Functions}\nSome network functions such as (stateful) firewalls maintain dynamically generated states. When a packet arrives, it is first checked against the state table to see if any entry in the state table matches the fields of the packet. If a matching entry is found, the prescribed action is performed on the packet and it does not need to be further processed by other (static) policies. An example is the state of TCP connection maintained by a firewall, as depicted in Table~\\ref{table:state}. The firewall notes a \\textit{new} connection when the SYN flag in a packet is set, and creates an entry in the state table containing, for instance, the source/destination IPs and ports and protocol type (6 for TCP) along with the current state. Upon receiving a SYN-ACK from the destination and a subsequent ACK flag from the source, the firewall changes the state of this connection to \\textit{established} (shown as \\texttt{est} in the table). Any subsequent packets that satisfy the headers contained in the state table entry are then allowed to go through without further processing of the network policies. The state table entry is deleted once the FIN-ACK part of the TCP protocol is carried out, or when the connection times out. \n\n\\begin{table}[!h]\n\\centering\n\n\\resizebox{1.025\\linewidth}{!}{\n\\setlength\\tabcolsep{2pt} \n\\begin{tabular}{l|l|r|l|r|r|r|r} \nID   & src IP & src port  & dst IP & dst port  & prot  & state & timeout  \\\\\n\\hline\n1 & \\texttt{192.168.1.1} & \\texttt{120} & \\texttt{192.168.1.2} & \\texttt{121} & \\texttt{6} & \\texttt{new} & \\texttt{59}\\\\\n2 & \\texttt{192.168.1.129}  & \\texttt{45} & \\texttt{192.168.1.140}   & \\texttt{8080} & \\texttt{6} & \\texttt{est} & \\texttt{3600}\n\\end{tabular}\n}\n\\vspace{-0.1cm}\n\\caption{An example of a firewall state table.}\n\\label{table:state}\n\\vspace{-0.1cm}\n\\end{table}\n\nWe note that in our model, state tables can be abstracted as dynamic match-action pairs, where the state and time-out columns in the state table can be thought of as \\textit{virtual} fields of the IP packet and the action as the addition of the \\texttt{tag} field with value ``allow''. However, one key difference is that once a match has been found, further processing is discontinued.\\footnote{There are network functions for which this is not true, e.g., traffic monitoring in which aggregate statistics of packets, such as number of packets received, are maintained.} Therefore, any private solution to a stateful middlebox should have the property that execution is allowed to stop once a match in the state table is found---otherwise there would be no performance gain from maintaining state. \n\n\n\n\n\n\n\n\\subsection{Private Processing of Outsourced Network Functions}\nOur goal is to provide privacy of an outsourced network function $\\psi$ given a set of packets $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_t$. From an adversarial perspective, the network function $\\psi$ can be learned either directly through the description of $(m, a)$ or indirectly by deducing from the outputs $\\psi(\\mathbf{x}_1), \\psi(\\mathbf{x}_2), \\ldots, \\psi(\\mathbf{x}_t)$. In order to achieve privacy, we therefore need a scheme that protects both the network function $\\psi$ and its output. We call this PNFV (Private NFV). Let $\\mathbf{x}$ be a packet as defined before and $\\psi$ be a network function such that $\\psi(\\mathbf{x}) = \\mathbf{x}'$.\n\n\\subsubsection{PNFV}\n\\vspace{-0.25cm}\n\\begin{definition}[PNFV]\nA public-key PNFV scheme is a tuple \n$(\\mathsf{kg}, \\mathsf{enc}, \\mathsf{dec}, \\mathsf{tr}, \\mathsf{proc})$\nof probabilistic polynomial time algorithms defined as follows:\n\\begin{compactitem}\n\\item {\\em Key generation:} The algorithm $s, p \\leftarrow \\mathsf{kg}(1^k)$ returns the secret key $s$ and public key $p$, where $k$ is the security parameter.\n\\item {\\em Packet encryption:} The algorithm $E(\\mathbf{x}) \\leftarrow \\mathsf{enc}(p, \\mathbf{x})$ takes as input the public key $p$ and the packet $\\mathbf{x}$ and outputs the encrypted version $E(\\mathbf{x})$. Note that this is element-wise encryption, which results in $n$ ciphertexts.\n\\item {\\em Network function transformation:} The algorithm $\\phi \\leftarrow \\mathsf{tr}(\\psi)$ takes as input the network function $\\psi$ and outputs a \\emph{transformed} network function $\\phi$. \n\\item {\\em Packet processing:} The algorithm $E(\\mathbf{x}') \\leftarrow \\mathsf{proc}(\\phi, E(\\mathbf{x}))$ takes as input the transformed network function $\\phi$ and the encrypted packet $E(\\mathbf{x})$ and outputs the encryption of $\\mathbf{x}'$. \n\\item {\\em Packet decryption:} The algorithm $\\mathbf{x}' \\leftarrow \\mathsf{dec}(s, E(\\mathbf{x}'))$ takes as input the secret key $s$ and the encryption of $\\mathbf{x}'$ and outputs $\\mathbf{x}'$. We may write $D(E(\\mathbf{x}))$ to represent $\\mathsf{dec}(s, E(\\mathbf{x}))$.\n\\end{compactitem}\n\\end{definition}\n\nConcisely, we can define the output of PNFV given $\\mathbf{x}$ and $\\psi$ as $\\text{PNFV}(\\mathbf{x}, \\psi)$. Thus,\n", "index": 15, "text": "\n\\[\n\\text{PNFV}(\\mathbf{x}, \\psi) = \\mathsf{dec}(s, \\mathsf{proc}(\\mathsf{tr}(\\psi), \\mathsf{enc}(p, \\mathbf{x}))).\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\text{PNFV}(\\mathbf{x},\\psi)=\\mathsf{dec}(s,\\mathsf{proc}(\\mathsf{tr}(\\psi),%&#10;\\mathsf{enc}(p,\\mathbf{x}))).\" display=\"block\"><mrow><mrow><mrow><mtext>PNFV</mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c8</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mi>\ud835\uddbd\ud835\uddbe\ud835\uddbc</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>s</mi><mo>,</mo><mrow><mi>\ud835\uddc9\ud835\uddcb\ud835\uddc8\ud835\uddbc</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\uddcd\ud835\uddcb</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\u03c8</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>\ud835\uddbe\ud835\uddc7\ud835\uddbc</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo>,</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhere $s, p \\leftarrow \\mathsf{kg}(1^k)$, $\\mathsf{negl}$ is a negligible function and $k$ is the security parameter.\n\\end{definition}\n\n\n\n\\subsubsection{PNFV Security}\nAs mentioned before, we consider an honest-but-curious adversary, i.e., a passive adversary that correctly computes PNFV but would like to infer $\\psi$. More precisely, we conduct the following experiment involving an adversary $\\cal{A}$ to model PNFV security.\n\n\n\n\n\n\n\nFirst, $\\cal{A}$ is given the public key $p$, the description of algorithms $(\\mathsf{kg}, \\mathsf{enc}, \\mathsf{dec}, \\mathsf{tr}, \\mathsf{proc})$ and the transformed network function $\\phi$. \nWhile $\\cal{A}$ is in the \\emph{test} state, it can sample any packet $\\mathbf{x}$ and obtain its output $E(\\mathbf{x}')$ such that $\\psi(\\mathbf{x}) = \\mathbf{x}'$ through the packet processing algorithm. \nFinally, in the \\emph{guess} state $\\cal{A}$ outputs its guess of the network function $\\psi$ as $\\psi'$. If $\\psi' = \\psi$, $\\cal A$ wins.\n\n\n\nThe above experiment abstracts what we call the strong adversary, denoted $\\cal{A}_\\text{strong}$, to distinguish it from a weaker adversary, denoted $\\cal{A}_\\text{weak}$. \n\n\nThe weak adversary differs from the strong one in that it is only given \\emph{oracle (black box) access to part} of the packet processing algorithm $\\mathsf{proc}$, and is not shown the incoming packet $\\mathbf{x}$. Instead a packet is chosen randomly from a publicly known distribution $\\cal D$, whenever $\\cal{A}_\\text{weak}$ requests for outputs of the above functions on a fresh input $\\mathbf{x}$. Naturally, this yields a weaker security definition.\n\nIn practice, this model is realized by introducing an entry MB, which is assumed to be running within a black box. The entry MB receives the packet and performs part of the packet processing algorithm $\\mathsf{proc}$, which is hidden from $\\cal{A}_\\text{weak}$. \n\nWe model PNFV security using the following experiment involving,\nas discussed in Section~\\ref{sec:desired}, an {\\em honest-but-curious} adversary.\n\n\n\n\n\\begin{definition}\nA \\emph{public-key PNFV} scheme is $(\\tau, \\epsilon)$-private if for any adversary $\\mathcal{A}$ that runs in time $\\tau = \\mathsf{poly}(k)$, it holds that\n", "itemtype": "equation", "pos": 33001, "prevtext": "\nKey generation, network function transformation, and packet decryption algorithms are computed by the client MB, while the remaining two algorithms are processed by the cloud MB. We have the following definition for correctness.\n\n\\begin{definition}[Correctness]\nA \\emph{public-key} {\\em PNFV} scheme is correct if for all $\\mathbf{x} \\in \\mathbb{Z}_q^n$ it holds that  \n", "index": 17, "text": "\n\\[\n\\Pr [ \\text{\\emph{PNFV}}(\\mathbf{x}, \\psi) \\ne \\psi(\\mathbf{x}) ] \\le \\mathsf{negl}(k),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\Pr[\\text{\\emph{PNFV}}(\\mathbf{x},\\psi)\\neq\\psi(\\mathbf{x})]\\leq\\mathsf{negl}(%&#10;k),\" display=\"block\"><mrow><mrow><mrow><mi>Pr</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">[</mo><mrow><mrow><mtext><em xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_emph\">PNFV</em></mtext><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo>,</mo><mi>\u03c8</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2260</mo><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2264</mo><mrow><mi>\ud835\uddc7\ud835\uddbe\ud835\uddc0\ud835\uddc5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhere $\\mathbf{x}' = \\psi(\\mathbf{x})$, $\\cal{A}$ can be either $\\cal{A}_\\text{\\emph{strong}}$ or $\\cal{A}_\\text{\\emph{weak}}$ and $k$ is the security parameter.\n\\end{definition}\n\n\n\n\n\\subsection{Notation}\n\nIn Table~\\ref{tab:notation}, we summarize the notation used throughout the rest of the paper.\n\n\n\\begin{table}[t]\n\\centering\n\\small\n\\begin{tabular}{|l|l|}\n\\hline \n{\\bf Symbol} & {\\bf Description} \\\\ \\hline \\hline\n$n$\t\t& Number of packet fields\t\t\\\\ \\hline\n$N$\t\t& Number of policies\t\t         \\\\ \\hline\n$x_i$ \t\t& $i$-th packet field \\\\ \\hline\n$\\psi()$\t& Network function\t\t\t\t \\\\ \\hline\n$m()$\t& Matching function\t\t\t\t \\\\ \\hline\n$a()$\t& Action function\t\t\t\t \\\\ \\hline\n$\\langle \\mathbf{x} , \\mathbf{y}\\rangle$ & Dot product of vectors $x$ and $y$ \\\\ \\hline\n$\\mathbf{x} \\circ \\mathbf{y}$ & Entry-wise product of vectors $x$ and $y$ \\\\ \\hline\n$x \\odot y$ & \\emph{Bitwise AND} operation \\\\ \\hline\n$\\mathbf{e}_i$ & Vector with all $0$'s and a $1$ at the $i$-th position \\\\ \\hline\n$E()$ & Encryption function \\\\ \\hline\n$D()$ & Decryption function \\\\ \\hline\n$\\sigma()$ & Pseudorandom Permutation \\\\ \\hline\n$I$ & Index vector whose $i$-th element is $i$ itself \\\\ \\hline\n$||$ & Concatenation operator \\\\ \\hline \n$\\mathcal{E}()$ & Searchable encryption function \\\\ \\hline \n$T()$ & Trapdoor generation function \\\\ \\hline \n$\\mathsf{test}()$ & Test equality function \\\\ \\hline\n\\{\\texttt{new},\\texttt{est}\\} & Set of states \\\\ \\hline\n\\{\\texttt{allow},\\texttt{drop}\\} & Set of tags \\\\ \\hline\n\\texttt{id} & Identifier of a table entry \\\\ \\hline \n\\texttt{delete} & Command to delete a table entry \\\\ \\hline \n\\end{tabular}\n\\vspace{-0.2cm}\n\\caption{Notation}\n\\label{tab:notation}\n\\vspace{-0.2cm}\n\\end{table}\n\n\n\n\\section{Three PNFV Instantiations}\n\\label{sec:solutions}\n\nThis section presents three PNFV instantiations. First, we briefly review a few different cryptographic primitives used in our schemes. Then, we describe solutions for a generic network function $\\psi$, which, given a packet $\\mathbf{x}$ implements the policy:\n\n", "itemtype": "equation", "pos": 35299, "prevtext": "\nwhere $s, p \\leftarrow \\mathsf{kg}(1^k)$, $\\mathsf{negl}$ is a negligible function and $k$ is the security parameter.\n\\end{definition}\n\n\n\n\\subsubsection{PNFV Security}\nAs mentioned before, we consider an honest-but-curious adversary, i.e., a passive adversary that correctly computes PNFV but would like to infer $\\psi$. More precisely, we conduct the following experiment involving an adversary $\\cal{A}$ to model PNFV security.\n\n\n\n\n\n\n\nFirst, $\\cal{A}$ is given the public key $p$, the description of algorithms $(\\mathsf{kg}, \\mathsf{enc}, \\mathsf{dec}, \\mathsf{tr}, \\mathsf{proc})$ and the transformed network function $\\phi$. \nWhile $\\cal{A}$ is in the \\emph{test} state, it can sample any packet $\\mathbf{x}$ and obtain its output $E(\\mathbf{x}')$ such that $\\psi(\\mathbf{x}) = \\mathbf{x}'$ through the packet processing algorithm. \nFinally, in the \\emph{guess} state $\\cal{A}$ outputs its guess of the network function $\\psi$ as $\\psi'$. If $\\psi' = \\psi$, $\\cal A$ wins.\n\n\n\nThe above experiment abstracts what we call the strong adversary, denoted $\\cal{A}_\\text{strong}$, to distinguish it from a weaker adversary, denoted $\\cal{A}_\\text{weak}$. \n\n\nThe weak adversary differs from the strong one in that it is only given \\emph{oracle (black box) access to part} of the packet processing algorithm $\\mathsf{proc}$, and is not shown the incoming packet $\\mathbf{x}$. Instead a packet is chosen randomly from a publicly known distribution $\\cal D$, whenever $\\cal{A}_\\text{weak}$ requests for outputs of the above functions on a fresh input $\\mathbf{x}$. Naturally, this yields a weaker security definition.\n\nIn practice, this model is realized by introducing an entry MB, which is assumed to be running within a black box. The entry MB receives the packet and performs part of the packet processing algorithm $\\mathsf{proc}$, which is hidden from $\\cal{A}_\\text{weak}$. \n\nWe model PNFV security using the following experiment involving,\nas discussed in Section~\\ref{sec:desired}, an {\\em honest-but-curious} adversary.\n\n\n\n\n\\begin{definition}\nA \\emph{public-key PNFV} scheme is $(\\tau, \\epsilon)$-private if for any adversary $\\mathcal{A}$ that runs in time $\\tau = \\mathsf{poly}(k)$, it holds that\n", "index": 19, "text": "\n\\[\n\\Pr [ \\mathcal{A}^{\\text{\\emph{PNFV}}} =\\psi ] \\le \\epsilon = \\epsilon(k), \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m1\" class=\"ltx_Math\" alttext=\"\\Pr[\\mathcal{A}^{\\text{\\emph{PNFV}}}=\\psi]\\leq\\epsilon=\\epsilon(k),\" display=\"block\"><mrow><mrow><mrow><mi>Pr</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">[</mo><mrow><msup><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9c</mi><mtext><em xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_emph\" style=\"font-size:70%;\">PNFV</em></mtext></msup><mo>=</mo><mi>\u03c8</mi></mrow><mo stretchy=\"false\">]</mo></mrow></mrow><mo>\u2264</mo><mi>\u03f5</mi><mo>=</mo><mrow><mi>\u03f5</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhere $i, j \\in [n]$. We call this the \\emph{equality matching} policy, a special case of the more general \\emph{range matching} policy defined as:\n\n", "itemtype": "equation", "pos": 37393, "prevtext": "\nwhere $\\mathbf{x}' = \\psi(\\mathbf{x})$, $\\cal{A}$ can be either $\\cal{A}_\\text{\\emph{strong}}$ or $\\cal{A}_\\text{\\emph{weak}}$ and $k$ is the security parameter.\n\\end{definition}\n\n\n\n\n\\subsection{Notation}\n\nIn Table~\\ref{tab:notation}, we summarize the notation used throughout the rest of the paper.\n\n\n\\begin{table}[t]\n\\centering\n\\small\n\\begin{tabular}{|l|l|}\n\\hline \n{\\bf Symbol} & {\\bf Description} \\\\ \\hline \\hline\n$n$\t\t& Number of packet fields\t\t\\\\ \\hline\n$N$\t\t& Number of policies\t\t         \\\\ \\hline\n$x_i$ \t\t& $i$-th packet field \\\\ \\hline\n$\\psi()$\t& Network function\t\t\t\t \\\\ \\hline\n$m()$\t& Matching function\t\t\t\t \\\\ \\hline\n$a()$\t& Action function\t\t\t\t \\\\ \\hline\n$\\langle \\mathbf{x} , \\mathbf{y}\\rangle$ & Dot product of vectors $x$ and $y$ \\\\ \\hline\n$\\mathbf{x} \\circ \\mathbf{y}$ & Entry-wise product of vectors $x$ and $y$ \\\\ \\hline\n$x \\odot y$ & \\emph{Bitwise AND} operation \\\\ \\hline\n$\\mathbf{e}_i$ & Vector with all $0$'s and a $1$ at the $i$-th position \\\\ \\hline\n$E()$ & Encryption function \\\\ \\hline\n$D()$ & Decryption function \\\\ \\hline\n$\\sigma()$ & Pseudorandom Permutation \\\\ \\hline\n$I$ & Index vector whose $i$-th element is $i$ itself \\\\ \\hline\n$||$ & Concatenation operator \\\\ \\hline \n$\\mathcal{E}()$ & Searchable encryption function \\\\ \\hline \n$T()$ & Trapdoor generation function \\\\ \\hline \n$\\mathsf{test}()$ & Test equality function \\\\ \\hline\n\\{\\texttt{new},\\texttt{est}\\} & Set of states \\\\ \\hline\n\\{\\texttt{allow},\\texttt{drop}\\} & Set of tags \\\\ \\hline\n\\texttt{id} & Identifier of a table entry \\\\ \\hline \n\\texttt{delete} & Command to delete a table entry \\\\ \\hline \n\\end{tabular}\n\\vspace{-0.2cm}\n\\caption{Notation}\n\\label{tab:notation}\n\\vspace{-0.2cm}\n\\end{table}\n\n\n\n\\section{Three PNFV Instantiations}\n\\label{sec:solutions}\n\nThis section presents three PNFV instantiations. First, we briefly review a few different cryptographic primitives used in our schemes. Then, we describe solutions for a generic network function $\\psi$, which, given a packet $\\mathbf{x}$ implements the policy:\n\n", "index": 21, "text": "\\begin{align}\n\\tag{\\texttt{P1}}\n\\label{eq:equal-pol}\n\\texttt{if } x_i == y \\texttt{ then } x_j \\leftarrow z,\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{}\\texttt{if }x_{i}==y\\texttt{ then }x_{j}\\leftarrow z,\" display=\"inline\"><mrow><mtext mathvariant=\"monospace\">if\u00a0</mtext><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>y</mi><mtext mathvariant=\"monospace\">\u00a0then\u00a0</mtext><msub><mi>x</mi><mi>j</mi></msub><mo>\u2190</mo><mi>z</mi><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nNote that policy~\\ref{eq:range-pol} equals policy~\\ref{eq:equal-pol} if $a = b = y$. \n\n\n\n\n\n\n\n\\subsection{Cryptographic Primitives}\n\n{\\medskip\\noindent\\textbf{{Fully Homomorphic Encryption (FHE)}.}}\nA FHE scheme involves the following algorithms:\n\\begin{itemize}\n\\itemsep0em \n\\item {\\em Key generation:} Given the security parameter $k$, generates public and private key pair $(pk,sk)$.\n\\item {\\em Encryption:} Given plaintext $m \\in \\{ 0 , 1 \\}^*$, outputs ciphertext $c = E(m)$ encrypted under public key $pk$.\n\\item {\\em Decryption:} Given a ciphertext $c$, outputs the plaintext $m=D(c)$ using the secret key $sk$.\n\\item {\\em Homomorphic Addition (Add):} Given two ciphertexts $c_1 = E(m_1)$, $c_2 = E(m_2)$, and the public key $pk$,  produces a ciphertext $c = \\textrm{Add}(c_1,c_2)=c_1 + c_2$ such that $D(c) = m_1 + m_2$.\n\\item {\\em Homomorphic Multiplication (Mult):} Given two ciphertexts $c_1 = E(m_1)$, $c_2 = E(m_2)$, and the public key $pk$, produces a ciphertext $c$ as $c = \\textrm{Mult}(c_1,c_2)=c_1 \\cdot c_2$ such that $D(c) = m_1 \\cdot m_2$.\n\\end{itemize}\n\n{\\medskip\\noindent\\textbf{{The BGN Cryptosystem~\\cite{bgn}}.}}\nBoneh, Goh, and Nissim (BGN) cryptosystem~\\cite{bgn}, besides provide additive homomorphism, also allows for \\emph{one} multiplication of ciphertexts. The scheme is based on a bilinear map and involves the following algorithms: \n\\begin{itemize}\n\\itemsep0em\n\t\\item {\\em Key Generation:} Generate the tuple $(q_1, q_2, {G}_1, {G}_2, e)$, where ${G}_1$ and ${G}_2$ are two multiplicative cyclic groups of order $n = q_1q_2$ and $e$ is the bilinear map $e: {G}_1 \\times {G}_1 \\rightarrow {G}_2$. Further pick two random generators $g$ and $u$ of ${G}_1$ and set $h = u^{q_2}$. It follows that $h$ is a random generator of the subgroup of ${G}_1$ of order $q_1$. The public key is $p = (n, G_1, {G}_2, e, g, h)$ and the private key is $s = q_1$. \n\t\\item {\\em Encryption:} Assume the message space to be $\\{0, 1, 2, \\ldots, M\\}$ where $M < q_2$. Encryption of a message $m$ using public key $p$ is $c = g^m h^r$, where $r$ is randomly chosen from the set $\\{0, 1, \\ldots, n-1\\}$. $c$ is the resulting ciphertext and is an element of ${G}_1$.\n\t\\item {\\em Decryption:} Given the secret key $s = q_1$, compute $c^{q_1}$ and then find its discrete log base $g^{q_1}$ using, for instance, Pollard's lambda method which takes expected time $O(\\sqrt{M})$~\\cite[\\S 3, p. 128]{handbook-ac}\\cite{bgn}.\n\\end{itemize}\n\nThe BGN cryptosystem is semantically secure under the \\emph{subgroup decision} assumption,\ni.e., given an element $x \\in G_1$, it is hard to decide if $x$ is in a subgroup of $G_1$ without knowing the factorization of the group order $n$ (which is $q_1q_2$).\nSince decryption involves computing discrete logarithms, BGN is only suitable for a small message space.\n\n{\\medskip\\noindent\\textbf{{PEKS~\\cite{peks}}.}}\nPublic-key Encryption with Keyword Search (PEKS)~\\cite{peks} involves the following algorithms:\n\\begin{itemize}\n\\itemsep0em\n\t\\item {\\em Key generation:} Given a security parameter, generates the public key $p$ and private key $s$.\n\t\\item {\\em PEKS generation:} Given a keyword $w$ and the public key $p$, produces the searchable encryption $\\mathcal{E}$ of $w$ as $\\mathcal{E}(w)$.\n\t\\item {\\em Trapdoor generation:} Given the private key $s$ and a keyword $w$, generates the trapdoor for $w$ as $T(w)$.\n\t\\item {\\em Test:} Given public key $p$, searchable encryption $\\mathcal{E}(w)$ and trapdoor $T(w')$, $\\mathsf{test}(\\mathcal{E}(w), T(w'))$ outputs $1$ if $w' = w$ and $0$ otherwise.\n\\end{itemize}\n\nWe consider the instantiation by Boneh et al.~\\cite{peks}, based on Identity Based Encryption (IBE)~\\cite{ibe}, which itself is based on a bilinear map $e: {G}_1 \\times {G}_1 \\rightarrow {G}_2$, where both $G_1$ and $G_2$ are of prime order $p$. The resulting scheme is semantically secure against a chosen-keyword attack in the random oracle model under the Bilinear Diffie-Hellman (BDH) assumption~\\cite{peks, ibe}, i.e., that given $g$, $g^a$, $g^b$,  $g^c$ $\\in G_1$, where $g$ is a generator of $G_1$, it is hard to compute $e(g, g)^{abc} \\in G_2$. Apart from this assumption, we also use the assumption that the trapdoor $T(w)$ is not invertible, i.e., is one-way. In the specific construction discussed, the trapdoor $T$ is computed as $T(w) = H(w)^s$, where $H$ is a hash function. The one-wayness of the trapdoor follows from the one-wayness of $H$. \n\n{\\medskip\\noindent\\textbf{{Pseudorandom Permutation}.}}\nWe also assume the existence of a secure pseudorandom permutation $\\sigma$, mapping from $[n]$ to itself. In practice, this can be implemented using a block cipher~\\cite{luby-rackoff}, such as AES. In our constructions, the inverse permutation $\\sigma^{-1}$ is not required and as such the private key does not need to be shared. \n\n\n\n\n\n\\subsection{Privacy against the Strong Adversary}\n\\label{sec:strongAdv}\n\n\n\n\n\\begin{figure*}[!htb]\n\\begin{framed}\n\\small\n\\textbf{\\em Key generation.} The client MB creates a public-private key pair $(pk, sk)$ of the FHE scheme. It keeps $sk$, and sends the public key $pk$ to the cloud MB.\n\n\\medskip\n\\textbf{\\em Network function transformation.} The client MB computes the encrypted tuple $(E(\\mathbf{e}_i), E(\\mathbf{e}_j), E(y), E(z))$ using the public key $pk$ and sends them to the cloud MB.  \n\n\\medskip\n\\textbf{\\em Packet encryption.} Upon receiving a packet $\\mathbf{x}$, the cloud MB computes $E(\\mathbf{x})$, using the public key $pk$.\n\n\\medskip\n\\textbf{\\em Packet processing.} Using $E(\\mathbf{x})$ and the encrypted tuple, the cloud MB computes $E(\\mathbf{x}') = E(\\psi(\\mathbf{x}))$ as defined in Eq.~\\ref{eq:fully-nf}. \n\n\\medskip\n\\textbf{\\em Packet decryption.} Upon receiving the encrypted packet $E(\\mathbf{x}')$, the client MB decrypts it using its private key $sk$ to obtain the transformed packet $\\mathbf{x}'$.\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{PNFV scheme based on Fully Homomorphic Encryption (FHE). $E()$ denotes the encryption function of an FHE cryptosystem.}\n\\label{fig:fhesol}\n\n\\end{figure*}\n\n\n\\subsubsection{Scheme based on Fully Homomorphic Encryption}\n\nWe now introduce our fist solution based on FHE that is secure against the strong adversary.\nConsider a  network function $\\psi$ implementing policy~\\ref{eq:equal-pol}. Its matching function can be written as:\n", "itemtype": "equation", "pos": 37662, "prevtext": "\nwhere $i, j \\in [n]$. We call this the \\emph{equality matching} policy, a special case of the more general \\emph{range matching} policy defined as:\n\n", "index": 23, "text": "\\begin{align}\n\\tag{\\texttt{P2}}\n\\label{eq:range-pol}\n\\texttt{if } x_i \\in [a, b] \\texttt{ then } x_j \\leftarrow z.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{}\\texttt{if }x_{i}\\in[a,b]\\texttt{ then }x_{j}\\leftarrow z.\" display=\"inline\"><mrow><mrow><mrow><mtext mathvariant=\"monospace\">if\u00a0</mtext><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo>\u2208</mo><mrow><mrow><mo stretchy=\"false\">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow><mo>\u2062</mo><mtext mathvariant=\"monospace\">\u00a0then\u00a0</mtext><mo>\u2062</mo><msub><mi>x</mi><mi>j</mi></msub></mrow><mo>\u2190</mo><mi>z</mi></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhich returns $1$ if $y = x_i$ and $0$ otherwise. The action function can be written as:\n", "itemtype": "equation", "pos": 44089, "prevtext": "\nNote that policy~\\ref{eq:range-pol} equals policy~\\ref{eq:equal-pol} if $a = b = y$. \n\n\n\n\n\n\n\n\\subsection{Cryptographic Primitives}\n\n{\\medskip\\noindent\\textbf{{Fully Homomorphic Encryption (FHE)}.}}\nA FHE scheme involves the following algorithms:\n\\begin{itemize}\n\\itemsep0em \n\\item {\\em Key generation:} Given the security parameter $k$, generates public and private key pair $(pk,sk)$.\n\\item {\\em Encryption:} Given plaintext $m \\in \\{ 0 , 1 \\}^*$, outputs ciphertext $c = E(m)$ encrypted under public key $pk$.\n\\item {\\em Decryption:} Given a ciphertext $c$, outputs the plaintext $m=D(c)$ using the secret key $sk$.\n\\item {\\em Homomorphic Addition (Add):} Given two ciphertexts $c_1 = E(m_1)$, $c_2 = E(m_2)$, and the public key $pk$,  produces a ciphertext $c = \\textrm{Add}(c_1,c_2)=c_1 + c_2$ such that $D(c) = m_1 + m_2$.\n\\item {\\em Homomorphic Multiplication (Mult):} Given two ciphertexts $c_1 = E(m_1)$, $c_2 = E(m_2)$, and the public key $pk$, produces a ciphertext $c$ as $c = \\textrm{Mult}(c_1,c_2)=c_1 \\cdot c_2$ such that $D(c) = m_1 \\cdot m_2$.\n\\end{itemize}\n\n{\\medskip\\noindent\\textbf{{The BGN Cryptosystem~\\cite{bgn}}.}}\nBoneh, Goh, and Nissim (BGN) cryptosystem~\\cite{bgn}, besides provide additive homomorphism, also allows for \\emph{one} multiplication of ciphertexts. The scheme is based on a bilinear map and involves the following algorithms: \n\\begin{itemize}\n\\itemsep0em\n\t\\item {\\em Key Generation:} Generate the tuple $(q_1, q_2, {G}_1, {G}_2, e)$, where ${G}_1$ and ${G}_2$ are two multiplicative cyclic groups of order $n = q_1q_2$ and $e$ is the bilinear map $e: {G}_1 \\times {G}_1 \\rightarrow {G}_2$. Further pick two random generators $g$ and $u$ of ${G}_1$ and set $h = u^{q_2}$. It follows that $h$ is a random generator of the subgroup of ${G}_1$ of order $q_1$. The public key is $p = (n, G_1, {G}_2, e, g, h)$ and the private key is $s = q_1$. \n\t\\item {\\em Encryption:} Assume the message space to be $\\{0, 1, 2, \\ldots, M\\}$ where $M < q_2$. Encryption of a message $m$ using public key $p$ is $c = g^m h^r$, where $r$ is randomly chosen from the set $\\{0, 1, \\ldots, n-1\\}$. $c$ is the resulting ciphertext and is an element of ${G}_1$.\n\t\\item {\\em Decryption:} Given the secret key $s = q_1$, compute $c^{q_1}$ and then find its discrete log base $g^{q_1}$ using, for instance, Pollard's lambda method which takes expected time $O(\\sqrt{M})$~\\cite[\\S 3, p. 128]{handbook-ac}\\cite{bgn}.\n\\end{itemize}\n\nThe BGN cryptosystem is semantically secure under the \\emph{subgroup decision} assumption,\ni.e., given an element $x \\in G_1$, it is hard to decide if $x$ is in a subgroup of $G_1$ without knowing the factorization of the group order $n$ (which is $q_1q_2$).\nSince decryption involves computing discrete logarithms, BGN is only suitable for a small message space.\n\n{\\medskip\\noindent\\textbf{{PEKS~\\cite{peks}}.}}\nPublic-key Encryption with Keyword Search (PEKS)~\\cite{peks} involves the following algorithms:\n\\begin{itemize}\n\\itemsep0em\n\t\\item {\\em Key generation:} Given a security parameter, generates the public key $p$ and private key $s$.\n\t\\item {\\em PEKS generation:} Given a keyword $w$ and the public key $p$, produces the searchable encryption $\\mathcal{E}$ of $w$ as $\\mathcal{E}(w)$.\n\t\\item {\\em Trapdoor generation:} Given the private key $s$ and a keyword $w$, generates the trapdoor for $w$ as $T(w)$.\n\t\\item {\\em Test:} Given public key $p$, searchable encryption $\\mathcal{E}(w)$ and trapdoor $T(w')$, $\\mathsf{test}(\\mathcal{E}(w), T(w'))$ outputs $1$ if $w' = w$ and $0$ otherwise.\n\\end{itemize}\n\nWe consider the instantiation by Boneh et al.~\\cite{peks}, based on Identity Based Encryption (IBE)~\\cite{ibe}, which itself is based on a bilinear map $e: {G}_1 \\times {G}_1 \\rightarrow {G}_2$, where both $G_1$ and $G_2$ are of prime order $p$. The resulting scheme is semantically secure against a chosen-keyword attack in the random oracle model under the Bilinear Diffie-Hellman (BDH) assumption~\\cite{peks, ibe}, i.e., that given $g$, $g^a$, $g^b$,  $g^c$ $\\in G_1$, where $g$ is a generator of $G_1$, it is hard to compute $e(g, g)^{abc} \\in G_2$. Apart from this assumption, we also use the assumption that the trapdoor $T(w)$ is not invertible, i.e., is one-way. In the specific construction discussed, the trapdoor $T$ is computed as $T(w) = H(w)^s$, where $H$ is a hash function. The one-wayness of the trapdoor follows from the one-wayness of $H$. \n\n{\\medskip\\noindent\\textbf{{Pseudorandom Permutation}.}}\nWe also assume the existence of a secure pseudorandom permutation $\\sigma$, mapping from $[n]$ to itself. In practice, this can be implemented using a block cipher~\\cite{luby-rackoff}, such as AES. In our constructions, the inverse permutation $\\sigma^{-1}$ is not required and as such the private key does not need to be shared. \n\n\n\n\n\n\\subsection{Privacy against the Strong Adversary}\n\\label{sec:strongAdv}\n\n\n\n\n\\begin{figure*}[!htb]\n\\begin{framed}\n\\small\n\\textbf{\\em Key generation.} The client MB creates a public-private key pair $(pk, sk)$ of the FHE scheme. It keeps $sk$, and sends the public key $pk$ to the cloud MB.\n\n\\medskip\n\\textbf{\\em Network function transformation.} The client MB computes the encrypted tuple $(E(\\mathbf{e}_i), E(\\mathbf{e}_j), E(y), E(z))$ using the public key $pk$ and sends them to the cloud MB.  \n\n\\medskip\n\\textbf{\\em Packet encryption.} Upon receiving a packet $\\mathbf{x}$, the cloud MB computes $E(\\mathbf{x})$, using the public key $pk$.\n\n\\medskip\n\\textbf{\\em Packet processing.} Using $E(\\mathbf{x})$ and the encrypted tuple, the cloud MB computes $E(\\mathbf{x}') = E(\\psi(\\mathbf{x}))$ as defined in Eq.~\\ref{eq:fully-nf}. \n\n\\medskip\n\\textbf{\\em Packet decryption.} Upon receiving the encrypted packet $E(\\mathbf{x}')$, the client MB decrypts it using its private key $sk$ to obtain the transformed packet $\\mathbf{x}'$.\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{PNFV scheme based on Fully Homomorphic Encryption (FHE). $E()$ denotes the encryption function of an FHE cryptosystem.}\n\\label{fig:fhesol}\n\n\\end{figure*}\n\n\n\\subsubsection{Scheme based on Fully Homomorphic Encryption}\n\nWe now introduce our fist solution based on FHE that is secure against the strong adversary.\nConsider a  network function $\\psi$ implementing policy~\\ref{eq:equal-pol}. Its matching function can be written as:\n", "index": 25, "text": "\n\\[\nm(\\mathbf{x}) = \\langle \\mathbf{x} , \\mathbf{e}_i \\rangle \\odot y\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"m(\\mathbf{x})=\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle\\odot y\" display=\"block\"><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2299</mo><mi>y</mi></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nreplacing $x_j$ with $z$. \nThus, $\\psi$ becomes:\n\n", "itemtype": "equation", "pos": 44250, "prevtext": "\nwhich returns $1$ if $y = x_i$ and $0$ otherwise. The action function can be written as:\n", "index": 27, "text": "\n\\[\na(\\mathbf{x}) = \\mathbf{x} - \\mathbf{x} \\circ \\mathbf{e}_j + z \\mathbf{e}_ j,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m1\" class=\"ltx_Math\" alttext=\"a(\\mathbf{x})=\\mathbf{x}-\\mathbf{x}\\circ\\mathbf{e}_{j}+z\\mathbf{e}_{j},\" display=\"block\"><mrow><mrow><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>\ud835\udc31</mi><mo>-</mo><mrow><mi>\ud835\udc31</mi><mo>\u2218</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow><mo>+</mo><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\n\nWe can construct a public-key PNFV scheme from any Fully Homomorphic Encryption (FHE) scheme, as described in Figure~\\ref{fig:fhesol}. \n\n\nFor policy~\\ref{eq:range-pol}, the action function is the same, but the matching function is now given as:\n", "itemtype": "equation", "pos": 44384, "prevtext": "\nreplacing $x_j$ with $z$. \nThus, $\\psi$ becomes:\n\n", "index": 29, "text": "\\begin{align}\n\\label{eq:fully-nf}\n\\psi(\\mathbf{x}) &= m(\\mathbf{x})a(\\mathbf{x}) + (1 - m(\\mathbf{x}))\\mathbf{x} \\nonumber\\\\\n\t\t\t\t\t &= m(\\mathbf{x})(a(\\mathbf{x}) - \\mathbf{x}) + \\mathbf{x} \\nonumber\\\\\n\t\t\t\t\t &= (\\langle \\mathbf{x} , \\mathbf{e}_i \\rangle \\odot y)(z \\mathbf{e}_ j - \\mathbf{x} \\circ \\mathbf{e}_j) + \\mathbf{x}.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\psi(\\mathbf{x})\" display=\"inline\"><mrow><mi>\u03c8</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=m(\\mathbf{x})a(\\mathbf{x})+(1-m(\\mathbf{x}))\\mathbf{x}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi>\ud835\udc31</mi></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=m(\\mathbf{x})(a(\\mathbf{x})-\\mathbf{x})+\\mathbf{x}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mi>\ud835\udc31</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mi>\ud835\udc31</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=(\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle\\odot y)(z\\mathbf{e}_{j}%&#10;-\\mathbf{x}\\circ\\mathbf{e}_{j})+\\mathbf{x}.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u2299</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow><mo>-</mo><mrow><mi>\ud835\udc31</mi><mo>\u2218</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>+</mo><mi>\ud835\udc31</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhich is $1$ if $x_i \\in [a, b]$ and $0$ otherwise. This can be substituted for $m(\\mathbf{x})$ in Eq.~\\ref{eq:fully-nf} to get an expression for $\\psi$. The client MB needs to send the encryptions $E(a)$ and $E(b)$ (instead of $E(y)$) to the cloud MB, while the rest is the same. Since policy~\\ref{eq:equal-pol} equals policy~\\ref{eq:range-pol} with $a = b = y$, we can replace the matching function of the former with the latter for a more general description, even though incurring more homomorphic computations. Also note that one can sequentially process $N$ network functions $\\psi_1 , \\ldots, \\psi_N$ using this scheme, with the client MB sending encryptions for each network function at setup, and the cloud MB sending the encryption of\n", "itemtype": "equation", "pos": 44966, "prevtext": "\n\nWe can construct a public-key PNFV scheme from any Fully Homomorphic Encryption (FHE) scheme, as described in Figure~\\ref{fig:fhesol}. \n\n\nFor policy~\\ref{eq:range-pol}, the action function is the same, but the matching function is now given as:\n", "index": 31, "text": "\n\\[\nm(\\mathbf{x}) = (\\langle \\mathbf{x} , \\mathbf{e}_i \\rangle \\unrhd a )(  \\langle \\mathbf{x} , \\mathbf{e}_i \\rangle \\unlhd b), \n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"m(\\mathbf{x})=(\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle\\unrhd a)(\\langle\\mathbf%&#10;{x},\\mathbf{e}_{i}\\rangle\\unlhd b),\" display=\"block\"><mrow><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u22b5</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo>\u22b4</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nto the client MB upon receiving the packet $\\mathbf{x}$. \n\n{\\medskip\\noindent\\textbf{{Correctness}.}} It is straightforward to see that, if the underlying FHE scheme is correct, the construction in Figure~\\ref{fig:fhesol} correctly performs the network function defined by policies~\\ref{eq:equal-pol} and \\ref{eq:range-pol}. \n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, privacy of the scheme stems from the fact that, as matching and action functions, together with their results, are encrypted, the adversary cannot infer the network function. More formally, in\nAppendix~\\ref{app:sec-red},\nwe prove that this scheme is private against $\\cal{A}_\\text{strong}$ if the FHE scheme is semantically secure.\n\n\n{\\medskip\\noindent\\textbf{{FHE Practicality}.}} Although research in FHE has made tremendous progress in improving efficiency~\\cite{DBLP:conf/ccs/NaehrigLV11}, we do not have a truly efficient FHE instantiation providing acceptable performance in the context of network function virtualization. However, efficient partial homomorphic encryption schemes, like BGN~\\cite{bgn}, could be used, as discussed next, if we modify the matching function.\n\n\n\n\n\n\n\\subsubsection{Scheme based on BGN Cryptosystem}\n\\label{sub:bgn-scheme}\nAs for the FHE based scheme, we start with the function $\\psi$ described by policy~\\ref{eq:equal-pol},\nbut describe the matching function as:\n", "itemtype": "equation", "pos": 45843, "prevtext": "\nwhich is $1$ if $x_i \\in [a, b]$ and $0$ otherwise. This can be substituted for $m(\\mathbf{x})$ in Eq.~\\ref{eq:fully-nf} to get an expression for $\\psi$. The client MB needs to send the encryptions $E(a)$ and $E(b)$ (instead of $E(y)$) to the cloud MB, while the rest is the same. Since policy~\\ref{eq:equal-pol} equals policy~\\ref{eq:range-pol} with $a = b = y$, we can replace the matching function of the former with the latter for a more general description, even though incurring more homomorphic computations. Also note that one can sequentially process $N$ network functions $\\psi_1 , \\ldots, \\psi_N$ using this scheme, with the client MB sending encryptions for each network function at setup, and the cloud MB sending the encryption of\n", "index": 33, "text": "\n\\[\n\\psi^{N}(\\mathbf{x}) =  \\psi_N(\\cdots \\psi_2(\\psi_1(\\mathbf{x}))\\cdots),\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m1\" class=\"ltx_Math\" alttext=\"\\psi^{N}(\\mathbf{x})=\\psi_{N}(\\cdots\\psi_{2}(\\psi_{1}(\\mathbf{x}))\\cdots),\" display=\"block\"><mrow><mrow><mrow><msup><mi>\u03c8</mi><mi>N</mi></msup><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>\u03c8</mi><mi>N</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">\u22ef</mi><mo>\u2062</mo><msub><mi>\u03c8</mi><mn>2</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>\u03c8</mi><mn>1</mn></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u22ef</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nIf we denote $m(\\mathbf{x}) = c$, note that $c = 1$ if $y = x_i$, whereas, if $x_i \\ne y$, then $c \\ne 1$. \n\nSince we only get $c$ as a function of $\\mathbf{x}$, \nthe matching function will output $1$ only if the packet matches the policy and give \nany value other than $1$ otherwise. \n\nThe action function $a$ is the same as before:\n", "itemtype": "equation", "pos": 47300, "prevtext": "\nto the client MB upon receiving the packet $\\mathbf{x}$. \n\n{\\medskip\\noindent\\textbf{{Correctness}.}} It is straightforward to see that, if the underlying FHE scheme is correct, the construction in Figure~\\ref{fig:fhesol} correctly performs the network function defined by policies~\\ref{eq:equal-pol} and \\ref{eq:range-pol}. \n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, privacy of the scheme stems from the fact that, as matching and action functions, together with their results, are encrypted, the adversary cannot infer the network function. More formally, in\nAppendix~\\ref{app:sec-red},\nwe prove that this scheme is private against $\\cal{A}_\\text{strong}$ if the FHE scheme is semantically secure.\n\n\n{\\medskip\\noindent\\textbf{{FHE Practicality}.}} Although research in FHE has made tremendous progress in improving efficiency~\\cite{DBLP:conf/ccs/NaehrigLV11}, we do not have a truly efficient FHE instantiation providing acceptable performance in the context of network function virtualization. However, efficient partial homomorphic encryption schemes, like BGN~\\cite{bgn}, could be used, as discussed next, if we modify the matching function.\n\n\n\n\n\n\n\\subsubsection{Scheme based on BGN Cryptosystem}\n\\label{sub:bgn-scheme}\nAs for the FHE based scheme, we start with the function $\\psi$ described by policy~\\ref{eq:equal-pol},\nbut describe the matching function as:\n", "index": 35, "text": "\n\\[\nm(\\mathbf{x}) = 1 - \\langle \\mathbf{x},\\mathbf{e}_i\\rangle + y.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m1\" class=\"ltx_Math\" alttext=\"m(\\mathbf{x})=1-\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle+y.\" display=\"block\"><mrow><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mn>1</mn><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mi>y</mi></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\n\n{\\medskip\\noindent\\textbf{{Matching and Action}.}} We need an encryption algorithm $E$ that can homomorphically compute both $m$ and $a$. More specifically, $E$ should give the encryption of $m()$ as:\n\n", "itemtype": "equation", "pos": 47704, "prevtext": "\nIf we denote $m(\\mathbf{x}) = c$, note that $c = 1$ if $y = x_i$, whereas, if $x_i \\ne y$, then $c \\ne 1$. \n\nSince we only get $c$ as a function of $\\mathbf{x}$, \nthe matching function will output $1$ only if the packet matches the policy and give \nany value other than $1$ otherwise. \n\nThe action function $a$ is the same as before:\n", "index": 37, "text": "\n\\[\na(\\mathbf{x}) = \\mathbf{x} - \\mathbf{x} \\circ \\mathbf{e}_j + z\\mathbf{e}_j.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex19.m1\" class=\"ltx_Math\" alttext=\"a(\\mathbf{x})=\\mathbf{x}-\\mathbf{x}\\circ\\mathbf{e}_{j}+z\\mathbf{e}_{j}.\" display=\"block\"><mrow><mrow><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>\ud835\udc31</mi><mo>-</mo><mrow><mi>\ud835\udc31</mi><mo>\u2218</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow><mo>+</mo><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nand, for the action function: \n\n", "itemtype": "equation", "pos": 47989, "prevtext": "\n\n{\\medskip\\noindent\\textbf{{Matching and Action}.}} We need an encryption algorithm $E$ that can homomorphically compute both $m$ and $a$. More specifically, $E$ should give the encryption of $m()$ as:\n\n", "index": 39, "text": "\\begin{align}\n\\label{eq:bgn-match}\nE(m(\\mathbf{x})) &= E(1 - \\langle\\mathbf{x},\\mathbf{e}_i\\rangle + y) \\nonumber\\\\\n\t\t\t\t\t\t& = E(1) - E(\\langle \\mathbf{x}, \\mathbf{e}_i \\rangle) + E(y) \\nonumber \\\\\n\t\t\t\t\t\t& = E(1) - \\langle E(\\mathbf{x}), E(\\mathbf{e}_i) \\rangle + E(y) \n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle E(m(\\mathbf{x}))\" display=\"inline\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex20.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(1-\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle+y)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>1</mn><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mi>y</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex21.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(1)-E(\\langle\\mathbf{x},\\mathbf{e}_{i}\\rangle)+E(y)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(1)-\\langle E(\\mathbf{x}),E(\\mathbf{e}_{i})\\rangle+E(y)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\n\nThe BGN cryptosystem allows to homomorphically compute one multiplication and any number of additions. Therefore, we can use it to construct a PNFV scheme secure against the strong adversary: the scheme is presented in Figure~\\ref{fig:bgnsol}. \nWe omit the description of the key generation algorithm (which should be obvious from the underlying cryptosystem), and further include the packet encryption routine within the packet processing algorithm. \n\n\\begin{figure*}[!htb]\n\\begin{framed}\n\\small\n\\textbf{\\em Network function transformation.} The client MB computes the tuple $(E(1), E(\\mathbf{e}_i), E(y), E(\\mathbf{e}_j), E(z\\mathbf{e}_j))$ and sends it to the cloud MB. \n\n\\medskip\n\\textbf{\\em Packet processing.} Upon receiving a packet $\\mathbf{x}$ the cloud MB:\n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Encrypts the packet as $E(\\mathbf{x})$. \n\t\t\\item Computes $E(a(\\mathbf{x}))$ according to Eq.~\\ref{eq:bgn-action} as $E(a(\\mathbf{x})) = E(\\mathbf{x}) - E(\\mathbf{x}) \\circ E(\\mathbf{e}_j) + E(z\\mathbf{e}_j)$ \\\\ \n\t\tand $E(m(\\mathbf{x})) = E(c)$ according to Eq.~\\ref{eq:bgn-match} as $E(c) = E(1) - \\langle E(\\mathbf{x}), E(\\mathbf{e}_i) \\rangle + E(y)$\n\t\t\\item Sends $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(c)$ to the client MB.\n\n\t\t\\end{enumerate}\n\\medskip\n\n\n\n\n\n\n\n\n\n\\textbf{\\em Packet decryption.} Upon receiving $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(c)$ the client MB:\n\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Decrypts $E(c)$ to obtain $c$. \n\t\t\\item If $c = 1$, decrypts $E(a(\\mathbf{x}))$ to obtain the transformed packet.\n\t\t\\item Else if $c \\ne 1$, decrypts $E(\\mathbf{x})$ to obtain the unchanged packet. \n\t\\end{enumerate}\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{PNFV scheme based on the BGN cryptosystem~\\cite{bgn}.}\n\\label{fig:bgnsol}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Range matching}.}} Next, we consider range matching, i.e., the network function $\\psi$ defined by policy~\\ref{eq:range-pol}. Observe that: \n\n", "itemtype": "equation", "pos": 48301, "prevtext": "\nand, for the action function: \n\n", "index": 41, "text": "\\begin{align}\n\\label{eq:bgn-action}\nE(a(\\mathbf{x})) &= E(\\mathbf{x} - \\mathbf{x} \\circ \\mathbf{e}_j + z\\mathbf{e}_j) \\nonumber\\\\\n\t\t\t\t\t\t&= E(\\mathbf{x}) - E(\\mathbf{x} \\circ \\mathbf{e}_j) + E(z\\mathbf{e}_j) \\nonumber\\\\\n\t\t\t\t\t\t& = E(\\mathbf{x}) - E(\\mathbf{x}) \\circ E(\\mathbf{e}_j) + E(z\\mathbf{e}_j).\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle E(a(\\mathbf{x}))\" display=\"inline\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex22.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(\\mathbf{x}-\\mathbf{x}\\circ\\mathbf{e}_{j}+z\\mathbf{e}_{j})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mi>\ud835\udc31</mi><mo>-</mo><mrow><mi>\ud835\udc31</mi><mo>\u2218</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow><mo>+</mo><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex23.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(\\mathbf{x})-E(\\mathbf{x}\\circ\\mathbf{e}_{j})+E(z\\mathbf{e}_{j})\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>\ud835\udc31</mi><mo>\u2218</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(\\mathbf{x})-E(\\mathbf{x})\\circ E(\\mathbf{e}_{j})+E(z\\mathbf{e}%&#10;_{j}).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>-</mo><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2218</mo><mi>E</mi></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>z</mi><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nThe product above can be written as\n\n", "itemtype": "equation", "pos": 50578, "prevtext": "\n\nThe BGN cryptosystem allows to homomorphically compute one multiplication and any number of additions. Therefore, we can use it to construct a PNFV scheme secure against the strong adversary: the scheme is presented in Figure~\\ref{fig:bgnsol}. \nWe omit the description of the key generation algorithm (which should be obvious from the underlying cryptosystem), and further include the packet encryption routine within the packet processing algorithm. \n\n\\begin{figure*}[!htb]\n\\begin{framed}\n\\small\n\\textbf{\\em Network function transformation.} The client MB computes the tuple $(E(1), E(\\mathbf{e}_i), E(y), E(\\mathbf{e}_j), E(z\\mathbf{e}_j))$ and sends it to the cloud MB. \n\n\\medskip\n\\textbf{\\em Packet processing.} Upon receiving a packet $\\mathbf{x}$ the cloud MB:\n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Encrypts the packet as $E(\\mathbf{x})$. \n\t\t\\item Computes $E(a(\\mathbf{x}))$ according to Eq.~\\ref{eq:bgn-action} as $E(a(\\mathbf{x})) = E(\\mathbf{x}) - E(\\mathbf{x}) \\circ E(\\mathbf{e}_j) + E(z\\mathbf{e}_j)$ \\\\ \n\t\tand $E(m(\\mathbf{x})) = E(c)$ according to Eq.~\\ref{eq:bgn-match} as $E(c) = E(1) - \\langle E(\\mathbf{x}), E(\\mathbf{e}_i) \\rangle + E(y)$\n\t\t\\item Sends $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(c)$ to the client MB.\n\n\t\t\\end{enumerate}\n\\medskip\n\n\n\n\n\n\n\n\n\n\\textbf{\\em Packet decryption.} Upon receiving $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(c)$ the client MB:\n\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Decrypts $E(c)$ to obtain $c$. \n\t\t\\item If $c = 1$, decrypts $E(a(\\mathbf{x}))$ to obtain the transformed packet.\n\t\t\\item Else if $c \\ne 1$, decrypts $E(\\mathbf{x})$ to obtain the unchanged packet. \n\t\\end{enumerate}\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{PNFV scheme based on the BGN cryptosystem~\\cite{bgn}.}\n\\label{fig:bgnsol}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Range matching}.}} Next, we consider range matching, i.e., the network function $\\psi$ defined by policy~\\ref{eq:range-pol}. Observe that: \n\n", "index": 43, "text": "\\begin{align*}\n(b - x_i)(x_i - a) \\ge 0 & \\text{ ~~if } x_i \\in [a, b] \\\\\n(b - x_i) (x_i - a)< 0  & \\text{ ~~otherwise}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(b-x_{i})(x_{i}-a)\\geq 0\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>-</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2265</mo><mn>0</mn></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex24.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\text{ ~{}~{}if }x_{i}\\in[a,b]\" display=\"inline\"><mrow><mrow><mtext>\u00a0if\u00a0</mtext><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">]</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(b-x_{i})(x_{i}-a)&lt;0\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>-</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>&lt;</mo><mn>0</mn></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex25.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\text{ ~{}~{}otherwise}.\" display=\"inline\"><mrow><mtext>\u00a0otherwise</mtext><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nLet $\\mathbf{x}^2 = \\langle \\mathbf{x}, \\mathbf{x} \\rangle$. If we define the matching function as:\n", "itemtype": "equation", "pos": 50748, "prevtext": "\nThe product above can be written as\n\n", "index": 45, "text": "\\begin{align*}\n(b - x_i)(x_i - a) &= bx_i - ab -x^2_i + ax_i \\\\\n\t\t\t\t\t   &= -x^2_i + (a + b)x_i -ab.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(b-x_{i})(x_{i}-a)\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>b</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>-</mo><mi>a</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex26.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=bx_{i}-ab-x^{2}_{i}+ax_{i}\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mi>b</mi><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo>-</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow><mo>-</mo><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mi>a</mi><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex27.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-x^{2}_{i}+(a+b)x_{i}-ab.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo>-</mo><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mrow><mo>-</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nthen $m(\\mathbf{x}) \\ge 0$ if there is a match, and negative otherwise. Homomorphically, we obtain:\n\n", "itemtype": "equation", "pos": 50960, "prevtext": "\nLet $\\mathbf{x}^2 = \\langle \\mathbf{x}, \\mathbf{x} \\rangle$. If we define the matching function as:\n", "index": 47, "text": "\n\\[\n m(\\mathbf{x}) = -\\langle \\mathbf{x}^2, \\mathbf{e}_i \\rangle + \\langle \\mathbf{x}, (a + b)\\mathbf{e}_i \\rangle - ab\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex28.m1\" class=\"ltx_Math\" alttext=\"m(\\mathbf{x})=-\\langle\\mathbf{x}^{2},\\mathbf{e}_{i}\\rangle+\\langle\\mathbf{x},(%&#10;a+b)\\mathbf{e}_{i}\\rangle-ab\" display=\"block\"><mrow><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msup><mi>\ud835\udc31</mi><mn>2</mn></msup><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>-</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nHere, $E(ab)$, $E((a + b)\\mathbf{e}_i)$ and $E(\\mathbf{e}_i)$ are computed by the client MB during the setup phase as part of the network function transformation routine. Since the cloud MB already knows $\\mathbf{x}$, it can compute $\\mathbf{x}^2 = \\langle \\mathbf{x}, \\mathbf{x} \\rangle$ in the clear, and then compute $E(\\mathbf{x}^2)$.  \nThe action function is the same as before. The client MB  receives $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(m(\\mathbf{x})) = E(c)$, and decrypts $E(c)$ to obtain $c$. If $c$ is a non-negative integer then it decrypts the result of the action function as the transformed packet, otherwise, it decrypts the original packet as the packet to be retained.\n\n{\\medskip\\noindent\\textbf{{Correctness}.}} As mentioned, BGN can successfully decrypt homomorphic encryptions of unlimited additions and one multiplication (per ciphertext). The above construction of match and action functions satisfy this constraint,\nthus implying correctness of the PNFV scheme in Figure~\\ref{fig:bgnsol}.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, the scheme can be shown to be private as the adversary only sees randomized encryptions of matching and action functions and, as such, cannot infer whether the matching function resulted in $1$ or some other value. More formally, we prove, in\nAppendix~\\ref{app:sec-red},\nthat, if BGN is semantically secure, our PNFV scheme is private against $\\cal{A}_\\text{strong}$.\n\n{\\medskip\\noindent\\textbf{{Discussion}.}} Ideally, the client MB would receive the encryption of the whole network function, i.e., $E(\\psi(\\mathbf{x}))$ and simply decrypt it to get the final packet. In our protocol, it actually has to perform two decryption operations instead of one (one to check the output of the matching function and another to decrypt the result), and, for each packet, three encryptions need to be sent. \nThis is due to the fact that the output of the matching function is a variable (i.e., not a constant value) when there is no match, thus, we cannot perform iterations of $N$ network functions. \n\n\n\n{\\medskip\\noindent\\textbf{{Asymptotic Complexity}.}} The network function transformation phase (which is done only once, during the \nsetup) requires the client MB to compute, and send to the cloud MB, $O(N\\cdot n)$ encryptions.\nThe packet processing at the cloud MB requires the computation of $O(N\\cdot n)$ encryptions, which are then sent to the client MB.\nFinally, the packet decryption at the client MB requires $O(N\\cdot n)$ decryptions.\n\n\n\n\n\n\\subsection{Privacy against the Weak Adversary}\n\\label{sub:weak-peks}\n\nWe now present a more efficient solution that is secure against the weak adversary,\nbased on {\\bf Public-key Encryption with Keyword Search (PEKS)}~\\cite{peks}, a probabilistic encryption scheme $(E, D)$ and a pseudorandom permutation $\\sigma$. \n\nFigure~\\ref{fig:weakadvsol} presents our solution, in the context of policy~\\ref{eq:equal-pol}.\n\nObserve that $I$ denotes the $n$-element index vector whose $i$-th element is $i$ itself, and $\\mathbf{x} || I$ the $n$-element vector whose $i$-th element is $x_i || i$. \nIn this model, the weak adversary $\\cal{A}_\\text{weak}$ does not have access to the entry MB packet processing.\n\nThus, we have a somewhat stronger assumption of security in this scheme with respect to the strong adversary schemes presented in Section~\\ref{sec:strongAdv}. The advantage, compared to the BGN based scheme presented in Section~\\ref{sub:bgn-scheme}, is that we only send one encrypted packet, and the client MB only needs \nto decrypt the packet.\n\n\n\nAlso note that the entry MB runs $\\sigma$ only once per packet arrival to obtain a shuffled set of indexes, and permutes the encryptions according to this set. That is, steps 1, 2 and 3 in Figure~\\ref{fig:weakadvsol} performed by the entry MB use the same permutation.  \n\n\\begin{figure*}[!htb]\n\\small\n\\begin{framed}\n\\textbf{\\em Network function transformation.} Using PEKS, the client MB computes the trapdoors $T(y || i)$ and $T(j)$. Using $E$, the client MB creates the encryption $E(z || j)$. The client MB sends $T(y || i)$, $T(j)$ and $E(z || j)$ to the cloud MB.\n\n\\medskip\n\\textbf{\\em Packet processing.} This is divided into entry MB and cloud MB.\n\n\\medskip\n\\textit{\\em Entry MB}: Upon receiving a packet $\\mathbf{x}$:\n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Encrypts $\\mathbf{x} || I$ using $E$ and shuffles the result as $\\sigma(E(\\mathbf{x}|| I))$.\n\t\t\\item Encrypts $\\mathbf{x} || I$ using PEKS and shuffles the result as $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$.\n\t\t\\item Encrypts $I$ using PEKS and shuffles it as $\\sigma(\\mathcal{E}(I))$.\n\t\t\\item Deletes the original packet $\\mathbf{x}$.\n\t\t\\end{enumerate}\n\n\\medskip\n\\textit{\\em Cloud MB}: Upon receiving $\\sigma(E(\\mathbf{x}|| I))$, $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$ and $\\sigma(\\mathcal{E}(I))$:\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Checks if there exists an $l \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( x_l || l ), T(y || i )) = 1$. \n\t\t\t\\begin{enumerate}[label={\\arabic{enumi}.\\arabic*.}]\n\t\t\t\\itemsep0em \n\t\t\t\\item If yes, finds an $l' \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( l' ) , T(j) ) = 1$ (which should exist). \n\t\t\t\\item Replaces $E(x_{l'} || l')$ with $E(z || j)$ in $\\sigma(E(\\mathbf{x}|| I))$ and sends it to the client MB.\t\t\t\n\t\t\t\\end{enumerate}\t\t\t\t\n\t\t\\item Else, sends $\\sigma(E(\\mathbf{x}|| I))$ to the client MB.\n\t\t\\end{enumerate}\n\t\t\n\\medskip\n\\textbf{\\em Packet decryption.} The client MB upon receiving $\\sigma(E(\\mathbf{x}|| I))$, decrypts to obtain $\\sigma(\\mathbf{x} || I)$ and then reconstructs $\\mathbf{x}$ according to $I$.\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{Scheme based on PEKS, private against the weak adversary.}\n\\label{fig:weakadvsol}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Correctness}.}} The client MB decrypts $E(\\mathbf{x}'|| I)$, permuted by $\\sigma$, to obtain $\\mathbf{x}' || I$ and  reconstructs $\\mathbf{x}'$ according to $I$. Note that, if the original packet matches policy~\\ref{eq:equal-pol}, then $x'_j = z$. Likewise, it the packet does not match the policy, decrypted packet $\\mathbf{x}'$ is the original packet $\\mathbf{x}$. Therefore, our PNFV scheme is correct.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, since $\\cal{A}_\\text{weak}$ does not know which packet index yields a match and which index the action applies to (due to random shuffle by $\\sigma$), and since the matching value $y$ and the action value $z$ are encrypted, it cannot infer the policy. In \nAppendix~\\ref{app:sec-red},\nwe show that if the probabilistic encryption scheme $E$ is semantically secure and the PEKS scheme is semantically secure against a chosen keyword attack, its trapdoor function $T$ is not invertible, and the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation, then the PNFV scheme described in Figure~\\ref{fig:weakadvsol} is private against $\\cal{A}_\\text{weak}$.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{Discussion}.}} The obvious limitation of this scheme is that it is only private against a weaker notion of adversary. In particular, we consider a cloud MB that does not try to analyze incoming packet $\\mathbf{x}$ with the output of the scheme. More precisely, the cloud MB does not retain the packet $\\mathbf{x}$ to match its randomly permuted encryptions, neither does it attempt to find $j$ in $T(j)$ by checking all possible encryptions under $\\mathcal{E}$ of all possible elements in $[n]$. If the cloud MB tries to do either of these (unwarranted) actions, it will at best learn the index $j$ (and not index $i$, $y$ or $z$). To find $(i, y)$, the cloud MB needs to do a brute force search whose complexity is $O(2^{qn})$. \n\nOn the other hand, we only need to send a number of encryptions per packet independent\tof the number of network functions $N$, however, it is only applicable to policy~\\ref{eq:equal-pol}.\n\n{\\medskip\\noindent\\textbf{{Asymptotic Complexity}.}}\nThe network function transformation, similarly to the BGN based scheme, is done only\nonce, during the setup, by the client MB, computing $O(N)$ PEKS trapdoors and encryptions to be sent to the cloud MB.\nThe packet processing requires the entry MB to perform and send to the cloud MB $O(N)$ encryptions,\nwhile the cloud MB performs $O(N\\cdot n)$ equality tests (using the PEKS scheme), for each packet, and sends $O(n)$ ciphertexts to the client MB. Finally, the client MB needs to decrypt $O(n)$ ciphertexts.\n\n\n\n\n\n\n\\subsection{Handling State Tables}\nWe now discuss PNFV solutions in the context of stateful network functions. Recall that a stateful network function maintains a state table, which among others contains a field (column) labelled \\emph{state}. We model a state table as comprising of one or more packet field headers followed by a \\emph{state} field and an \\emph{action tag}. \n\n\nThe private state table solution is built from the PEKS based PNFV scheme discussed above.\nNote that FHE based solutions are not applicable to state tables, as the cloud MB should discontinue processing once a match is found in the state table. If processing needs to be continued for the packet, and the current state table only maintains statistics (such as counters), then this can be implemented in the same way as a normal network function. We denote the state and tag fields by $s$ and $t$ respectively. \n\nOur proposed solution is shown in Figure~\\ref{fig:statetablesol}. In case no entry in the state table is found, the cloud MB processes the static network policies via the underlying PNFV scheme. In Figure~\\ref{fig:statetablesol}, we assume that this is the BGN based PNFV scheme from Section~\\ref{sub:bgn-scheme}. If relying on the PEKS-based scheme, the entry MB needs to send $\\sigma(E(\\mathbf{x}|| I))$ and $\\sigma(\\mathcal{E}(I))$ to the cloud MB instead of $\\mathbf{x}$.\n\n\\begin{figure*}[!htb]\n\\small\n\\begin{framed}\n{Client MB}: Upon receiving a packet $\\mathbf{x}$ from the cloud MB decides that a state table entry is to be created. \n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Identifies a subset $I'$ of $I$ corresponding to packet fields to be placed in the state table.\n\t\t\\item Produces trapdoors $T(\\mathbf{x}_{I'} || I')$ and shuffles them using $\\sigma$ as $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$. \n\t\t\\item Creates encryptions of the state and the tag as $E(s)$ and $E(t)$, respectively.\n\t\t\\item Sends $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$, $E(s)$ and $E(t)$ to the cloud MB. \n\t\t\\end{enumerate}\t\t\n\n\\medskip\n{Cloud MB}: Creates a state table entry with $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$, $E(s)$ and $E(t)$, and sends the $\\texttt{id}$ of this entry to the client MB.\n\n\\medskip\n{Entry MB}: Upon receiving a packet $\\mathbf{x}$, encrypts $\\mathbf{x} || I$ using PEKS and shuffles the result as $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$.\n\n\\medskip\n{Cloud MB}: Upon receiving $\\mathbf{x}$ and $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$, for $l' \\in |\\mathcal{T}|$ checks whether there exists an $l \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( x_l || l ), T( x_{l'} || l' )) = 1$. \n\t\t\\begin{enumerate}\n\t\t\t\\itemsep0em \n\t\t\t\\item If there is a match for all $l'$, computes $E(\\mathbf{x})$, appends $E(\\texttt{id})$, $E(s)$ and $E(t)$ to it and sends it to the client MB.\n\t\t\t\\item Otherwise, continues processing the \\emph{static} network functions (using the PNFV scheme).\n\t\t\\end{enumerate}\t\t\t\t\n\n\\medskip\n{Client MB}: Upon receiving an encrypted packet $E(\\mathbf{x})$\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Decrypts it to obtain $\\mathbf{x}$.\n\t\t\\item Strips the $\\texttt{id}$, state $s$ and tag $t$, and carries out the action according to $t$.\n\t\t\\item \\textit{Update:} Sends the tuple $(\\texttt{id}, E(s'))$ to the cloud MB, where $s'$ is the new state.\n\t\t\\item \\textit{Deletion:} Sends the tuple $(\\texttt{id}, \\texttt{delete})$ to the cloud MB.\n\t\t\\end{enumerate}\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{State table solution private against the weak adversary. The PNFV scheme used in case of a state table miss is based on BGN.}\n\\label{fig:statetablesol}\n\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Example}.}} \nWe illustrate the state table solution using a firewall state table as an example. The client MB identifies the index set \n\n", "itemtype": "equation", "pos": 51183, "prevtext": "\nthen $m(\\mathbf{x}) \\ge 0$ if there is a match, and negative otherwise. Homomorphically, we obtain:\n\n", "index": 49, "text": "\\begin{align*}\nE(m(\\mathbf{x})) &= E(-\\langle \\mathbf{x}^2, \\mathbf{e}_i \\rangle + \\langle \\mathbf{x}, (a + b)\\mathbf{e}_i \\rangle - ab) \\\\\n\t\t\t\t\t\t& = -E(\\langle \\mathbf{x}^2, \\mathbf{e}_i \\rangle) + E(\\langle \\mathbf{x}, (a + b)\\mathbf{e}_i \\rangle) - E(ab)\\\\\n\t\t\t\t\t\t& = -\\langle E(\\mathbf{x}^2) , E(\\mathbf{e}_i) \\rangle + \\langle E(\\mathbf{x}), E((a + b)\\mathbf{e}_i) \\rangle - E(ab).\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle E(m(\\mathbf{x}))\" display=\"inline\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>m</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex29.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=E(-\\langle\\mathbf{x}^{2},\\mathbf{e}_{i}\\rangle+\\langle\\mathbf{x}%&#10;,(a+b)\\mathbf{e}_{i}\\rangle-ab)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msup><mi>\ud835\udc31</mi><mn>2</mn></msup><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>-</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex30.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-E(\\langle\\mathbf{x}^{2},\\mathbf{e}_{i}\\rangle)+E(\\langle\\mathbf%&#10;{x},(a+b)\\mathbf{e}_{i}\\rangle)-E(ab)\" display=\"inline\"><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo>-</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">\u27e8</mo><msup><mi>\ud835\udc31</mi><mn>2</mn></msup><mo>,</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">\u27e9</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>+</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mi>\ud835\udc31</mi><mo>,</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">\u27e9</mo></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>-</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex31.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=-\\langle E(\\mathbf{x}^{2}),E(\\mathbf{e}_{i})\\rangle+\\langle E(%&#10;\\mathbf{x}),E((a+b)\\mathbf{e}_{i})\\rangle-E(ab).\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mrow><mrow><mo>-</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc31</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>+</mo><mrow><mo stretchy=\"false\">\u27e8</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">\u27e9</mo></mrow></mrow><mo>-</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2062</mo><mi>b</mi></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhich correspond to the source IP address, destination IP address, source port, destination port and protocol fields, respectively, of an IPv4 packet. The client MB creates trapdoors for the values of these fields and randomly shuffles \nthe trapdoors creating the set $\\cal {T}$. Let $s \\in \\{\\texttt{new}, \\texttt{est}\\}$ be the possible states, where the second state is the abbreviation of ``established.'' Let $t \\in \\{\\texttt{allow}, \\texttt{drop} \\}$ be the possible tags. Suppose the client MB first receives a packet $\\mathbf{x}$ whose SYN flag is set. The client MB then sends the set $\\cal T$ and $E(s) = E(\\texttt{new})$ and $E(t) = E(\\texttt{allow})$ to the cloud MB. The cloud MB creates an entry for this state table. Suppose the identifier of this state table entry is $\\texttt{id}$, which is sent to the client MB. The cloud MB subsequently checks each incoming encrypted and shuffled packet $\\mathbf{x}$ (done by the entry MB) to see if it matches this state table entry. If it does, it simply appends $E(\\texttt{id})$, $E(\\texttt{new})$ and $E(\\texttt{allow})$ as the state and tag respectively, to the encrypted packet $E(\\mathbf{x})$ and sends it to the client MB. The client MB, after decrypting the packet, checks the state and the ACK flag in $\\mathbf{x}$. If the ACK flag is set, the client MB sets $s \\leftarrow \\texttt{est}$ and sends $(\\texttt{id}, E(\\texttt{est}))$ to the cloud MB. Since the tag is set to $\\texttt{allow}$, it forwards the packet to \nits intended destination within the internal network. After the current TCP connection is over (through FIN-ACK exchange), the client MB sends the pair $(\\texttt{id}, \\texttt{delete})$ to the cloud MB, which in turn deletes the corresponding entry.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} The privacy argument of the proposed state table solution is similar to the one for the PEKS based PNFV scheme, and hence we omit it here. However, two important differences are that (i) the adversary $\\mathcal{A}_\\text{weak}$ knows the number of fields being checked (due to $|I'|$), and (ii) learns whether or not the current packet matches a state table entry. \n\n\n\n\n\n\n\\section{Implementation and Performance Evaluation}\n\\label{sec:implement}\nIn the following, we provide a proof-of-concept of the feasibility of our PNFV schemes. \n\n\n\\subsection{Implementing PNFV}\nWe assume that private network function processing operates at the network layer in the OSI model, i.e., it processes IP packets, although it can be extended to the processing of Ethernet frames as well (MAC headers). \n\nNote that not all packet fields are needed for private processing of a given network function, e.g., the ``header checksum'' field of an IPv4 packet is used for integrity check and does not have to be encrypted. Thus, we only use a subset $I'$ of the set of indexes $I$ corresponding to different fields of a packet. For instance, if the network function performs firewall actions, we assume that $I'$ is the 5-tuple defined in Eq.~\\ref{eq:5tuple}. \nThe packet encryption algorithm of the cloud MB, upon receiving the packet $\\mathbf{x}$, computes encryptions of the above fields only. Recall that, in the PEKS based scheme, the entry MB deletes the original packet $\\mathbf{x}$: for this tuple, this implemented by the entry MB resetting the corresponding field values to $0$ before sending $\\mathbf{x}$ to the cloud MB.\n\nWhenever a packet $\\mathbf{x}$ arrives at the cloud MB, after private processing, this is transformed into a new packet $\\mathbf{x}'$ (as shown in Figure~\\ref{fig:encapsulation-x}) which is then sent to the client MB. For instance, assume a network function implementing the policy: if $x_{\\texttt{s\\_ip}} = \\texttt{127.0.0.1}$ then block the packet, otherwise allow it, and \nassume we are using the PNFV scheme based on BGN (Section~\\ref{sub:bgn-scheme}). \n\nThe client MB constructs the transformed packet $\\mathbf{x}'$ as follows. It first constructs a new IP header containing its IP address as the source IP and the IP address of the client MB as the destination IP (similarly for the ports). The payload of $\\mathbf{x}'$ contains the original IP packet $\\mathbf{x}$, as shown in the figure, followed by PNFV related payload. The PNFV payload specific to the BGN based scheme and the above mentioned policy is:\n\n\n\\begin{figure}[!tb]\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx\\svgwidth\\undefined\n    \\setlength{\\unitlength}{228.60229492bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{\\svgwidth}\n  \\fi\n  \\global\\let\\svgwidth\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,0.44079526)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{encapsulation-x-wo-names.pdf}}\n    \\put(0.270219743,0.42047569){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{\\small Ethernet frame of packet $\\mathbf{x}$}}}\n    \\put(0.27606589,0.00556308){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{\\small Ethernet frame of packet $\\mathbf{x}'$}}}\n  \\end{picture}\n\\endgroup\n\\caption{Encapsulation of packet $\\mathbf{x}$ within packet $\\mathbf{x}'$ by the cloud MB. Fields shaded \\textcolor{nfvyellow}{\\protect\\rule[0pt]{2mm}{2mm}}~have identical content.}\n\\label{fig:encapsulation-x}\n\\vspace{-0.3cm}\n\\end{figure}\n\n\n\\medskip\\noindent\n\\resizebox{\\columnwidth}{!}{\n\\begin{tabular}{ccccc} \n\\text{PNFV ID} & \\text{state/policy ID} & $x_j || j$ & $z || j$ & $c$ \\\\\n\\hline\n\\texttt{BGN} & \\texttt{id} & $E(\\texttt{allow} || \\texttt{tag})$ & $E(\\texttt{deny}  || \\texttt{tag})$ & $E(c)$ \n\\end{tabular}\n}\n\\medskip\n\n\n\nThe first field contains the ID of the PNFV scheme being used (in this case, the BGN based scheme). The second field reports the policy ID of the particular policy being processed (in case of state tables this is the state table entry ID). The next two items are the two possible actions that are to be applied on packet field $j$ depending on whether there was a policy match. In our example, this is $E(\\texttt{allow} || \\texttt{tag})$ which is the action when there is no match and $E(\\texttt{deny} || \\texttt{tag})$ is the action when there is a match. Here $\\texttt{tag}$ is an index for the \\emph{virtual} field tag, since IP packets do not have a $\\texttt{tag}$ field. In case of other policies, this could be a real packet field, for instance the $\\texttt{prot}$ (protocol) field. The last item is the encryption of the result of the matching function, i.e., $E(c)$.\n\nWhen the client MB receives the packet $\\mathbf{x}'$, it first extracts $\\mathbf{x}$ in a straightforward manner. The client MB then checks the PNFV ID to learn which scheme is to be applied (in this case, the BGN based scheme) and decrypts the last item $E(c)$. If $c = 1$, it decrypts $E(\\texttt{deny} || \\texttt{tag})$ and then drops the packets $\\mathbf{x}$,\nwhereas, if $c \\ne 1$, it decrypts $E(\\texttt{allow} || \\texttt{tag})$, and forwards the packet $\\mathbf{x}$ to its intended destination. The policy ID can be used for bookkeeping.  \n\nIf the original packet $\\mathbf{x}$ has size $| \\mathbf{x} |$, then the size of $\\mathbf{x}'$ is given by:\n", "itemtype": "equation", "pos": 63839, "prevtext": "\nHere, $E(ab)$, $E((a + b)\\mathbf{e}_i)$ and $E(\\mathbf{e}_i)$ are computed by the client MB during the setup phase as part of the network function transformation routine. Since the cloud MB already knows $\\mathbf{x}$, it can compute $\\mathbf{x}^2 = \\langle \\mathbf{x}, \\mathbf{x} \\rangle$ in the clear, and then compute $E(\\mathbf{x}^2)$.  \nThe action function is the same as before. The client MB  receives $E(\\mathbf{x})$, $E(a(\\mathbf{x}))$ and $E(m(\\mathbf{x})) = E(c)$, and decrypts $E(c)$ to obtain $c$. If $c$ is a non-negative integer then it decrypts the result of the action function as the transformed packet, otherwise, it decrypts the original packet as the packet to be retained.\n\n{\\medskip\\noindent\\textbf{{Correctness}.}} As mentioned, BGN can successfully decrypt homomorphic encryptions of unlimited additions and one multiplication (per ciphertext). The above construction of match and action functions satisfy this constraint,\nthus implying correctness of the PNFV scheme in Figure~\\ref{fig:bgnsol}.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, the scheme can be shown to be private as the adversary only sees randomized encryptions of matching and action functions and, as such, cannot infer whether the matching function resulted in $1$ or some other value. More formally, we prove, in\nAppendix~\\ref{app:sec-red},\nthat, if BGN is semantically secure, our PNFV scheme is private against $\\cal{A}_\\text{strong}$.\n\n{\\medskip\\noindent\\textbf{{Discussion}.}} Ideally, the client MB would receive the encryption of the whole network function, i.e., $E(\\psi(\\mathbf{x}))$ and simply decrypt it to get the final packet. In our protocol, it actually has to perform two decryption operations instead of one (one to check the output of the matching function and another to decrypt the result), and, for each packet, three encryptions need to be sent. \nThis is due to the fact that the output of the matching function is a variable (i.e., not a constant value) when there is no match, thus, we cannot perform iterations of $N$ network functions. \n\n\n\n{\\medskip\\noindent\\textbf{{Asymptotic Complexity}.}} The network function transformation phase (which is done only once, during the \nsetup) requires the client MB to compute, and send to the cloud MB, $O(N\\cdot n)$ encryptions.\nThe packet processing at the cloud MB requires the computation of $O(N\\cdot n)$ encryptions, which are then sent to the client MB.\nFinally, the packet decryption at the client MB requires $O(N\\cdot n)$ decryptions.\n\n\n\n\n\n\\subsection{Privacy against the Weak Adversary}\n\\label{sub:weak-peks}\n\nWe now present a more efficient solution that is secure against the weak adversary,\nbased on {\\bf Public-key Encryption with Keyword Search (PEKS)}~\\cite{peks}, a probabilistic encryption scheme $(E, D)$ and a pseudorandom permutation $\\sigma$. \n\nFigure~\\ref{fig:weakadvsol} presents our solution, in the context of policy~\\ref{eq:equal-pol}.\n\nObserve that $I$ denotes the $n$-element index vector whose $i$-th element is $i$ itself, and $\\mathbf{x} || I$ the $n$-element vector whose $i$-th element is $x_i || i$. \nIn this model, the weak adversary $\\cal{A}_\\text{weak}$ does not have access to the entry MB packet processing.\n\nThus, we have a somewhat stronger assumption of security in this scheme with respect to the strong adversary schemes presented in Section~\\ref{sec:strongAdv}. The advantage, compared to the BGN based scheme presented in Section~\\ref{sub:bgn-scheme}, is that we only send one encrypted packet, and the client MB only needs \nto decrypt the packet.\n\n\n\nAlso note that the entry MB runs $\\sigma$ only once per packet arrival to obtain a shuffled set of indexes, and permutes the encryptions according to this set. That is, steps 1, 2 and 3 in Figure~\\ref{fig:weakadvsol} performed by the entry MB use the same permutation.  \n\n\\begin{figure*}[!htb]\n\\small\n\\begin{framed}\n\\textbf{\\em Network function transformation.} Using PEKS, the client MB computes the trapdoors $T(y || i)$ and $T(j)$. Using $E$, the client MB creates the encryption $E(z || j)$. The client MB sends $T(y || i)$, $T(j)$ and $E(z || j)$ to the cloud MB.\n\n\\medskip\n\\textbf{\\em Packet processing.} This is divided into entry MB and cloud MB.\n\n\\medskip\n\\textit{\\em Entry MB}: Upon receiving a packet $\\mathbf{x}$:\n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Encrypts $\\mathbf{x} || I$ using $E$ and shuffles the result as $\\sigma(E(\\mathbf{x}|| I))$.\n\t\t\\item Encrypts $\\mathbf{x} || I$ using PEKS and shuffles the result as $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$.\n\t\t\\item Encrypts $I$ using PEKS and shuffles it as $\\sigma(\\mathcal{E}(I))$.\n\t\t\\item Deletes the original packet $\\mathbf{x}$.\n\t\t\\end{enumerate}\n\n\\medskip\n\\textit{\\em Cloud MB}: Upon receiving $\\sigma(E(\\mathbf{x}|| I))$, $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$ and $\\sigma(\\mathcal{E}(I))$:\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Checks if there exists an $l \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( x_l || l ), T(y || i )) = 1$. \n\t\t\t\\begin{enumerate}[label={\\arabic{enumi}.\\arabic*.}]\n\t\t\t\\itemsep0em \n\t\t\t\\item If yes, finds an $l' \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( l' ) , T(j) ) = 1$ (which should exist). \n\t\t\t\\item Replaces $E(x_{l'} || l')$ with $E(z || j)$ in $\\sigma(E(\\mathbf{x}|| I))$ and sends it to the client MB.\t\t\t\n\t\t\t\\end{enumerate}\t\t\t\t\n\t\t\\item Else, sends $\\sigma(E(\\mathbf{x}|| I))$ to the client MB.\n\t\t\\end{enumerate}\n\t\t\n\\medskip\n\\textbf{\\em Packet decryption.} The client MB upon receiving $\\sigma(E(\\mathbf{x}|| I))$, decrypts to obtain $\\sigma(\\mathbf{x} || I)$ and then reconstructs $\\mathbf{x}$ according to $I$.\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{Scheme based on PEKS, private against the weak adversary.}\n\\label{fig:weakadvsol}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Correctness}.}} The client MB decrypts $E(\\mathbf{x}'|| I)$, permuted by $\\sigma$, to obtain $\\mathbf{x}' || I$ and  reconstructs $\\mathbf{x}'$ according to $I$. Note that, if the original packet matches policy~\\ref{eq:equal-pol}, then $x'_j = z$. Likewise, it the packet does not match the policy, decrypted packet $\\mathbf{x}'$ is the original packet $\\mathbf{x}$. Therefore, our PNFV scheme is correct.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} Intuitively, since $\\cal{A}_\\text{weak}$ does not know which packet index yields a match and which index the action applies to (due to random shuffle by $\\sigma$), and since the matching value $y$ and the action value $z$ are encrypted, it cannot infer the policy. In \nAppendix~\\ref{app:sec-red},\nwe show that if the probabilistic encryption scheme $E$ is semantically secure and the PEKS scheme is semantically secure against a chosen keyword attack, its trapdoor function $T$ is not invertible, and the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation, then the PNFV scheme described in Figure~\\ref{fig:weakadvsol} is private against $\\cal{A}_\\text{weak}$.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{Discussion}.}} The obvious limitation of this scheme is that it is only private against a weaker notion of adversary. In particular, we consider a cloud MB that does not try to analyze incoming packet $\\mathbf{x}$ with the output of the scheme. More precisely, the cloud MB does not retain the packet $\\mathbf{x}$ to match its randomly permuted encryptions, neither does it attempt to find $j$ in $T(j)$ by checking all possible encryptions under $\\mathcal{E}$ of all possible elements in $[n]$. If the cloud MB tries to do either of these (unwarranted) actions, it will at best learn the index $j$ (and not index $i$, $y$ or $z$). To find $(i, y)$, the cloud MB needs to do a brute force search whose complexity is $O(2^{qn})$. \n\nOn the other hand, we only need to send a number of encryptions per packet independent\tof the number of network functions $N$, however, it is only applicable to policy~\\ref{eq:equal-pol}.\n\n{\\medskip\\noindent\\textbf{{Asymptotic Complexity}.}}\nThe network function transformation, similarly to the BGN based scheme, is done only\nonce, during the setup, by the client MB, computing $O(N)$ PEKS trapdoors and encryptions to be sent to the cloud MB.\nThe packet processing requires the entry MB to perform and send to the cloud MB $O(N)$ encryptions,\nwhile the cloud MB performs $O(N\\cdot n)$ equality tests (using the PEKS scheme), for each packet, and sends $O(n)$ ciphertexts to the client MB. Finally, the client MB needs to decrypt $O(n)$ ciphertexts.\n\n\n\n\n\n\n\\subsection{Handling State Tables}\nWe now discuss PNFV solutions in the context of stateful network functions. Recall that a stateful network function maintains a state table, which among others contains a field (column) labelled \\emph{state}. We model a state table as comprising of one or more packet field headers followed by a \\emph{state} field and an \\emph{action tag}. \n\n\nThe private state table solution is built from the PEKS based PNFV scheme discussed above.\nNote that FHE based solutions are not applicable to state tables, as the cloud MB should discontinue processing once a match is found in the state table. If processing needs to be continued for the packet, and the current state table only maintains statistics (such as counters), then this can be implemented in the same way as a normal network function. We denote the state and tag fields by $s$ and $t$ respectively. \n\nOur proposed solution is shown in Figure~\\ref{fig:statetablesol}. In case no entry in the state table is found, the cloud MB processes the static network policies via the underlying PNFV scheme. In Figure~\\ref{fig:statetablesol}, we assume that this is the BGN based PNFV scheme from Section~\\ref{sub:bgn-scheme}. If relying on the PEKS-based scheme, the entry MB needs to send $\\sigma(E(\\mathbf{x}|| I))$ and $\\sigma(\\mathcal{E}(I))$ to the cloud MB instead of $\\mathbf{x}$.\n\n\\begin{figure*}[!htb]\n\\small\n\\begin{framed}\n{Client MB}: Upon receiving a packet $\\mathbf{x}$ from the cloud MB decides that a state table entry is to be created. \n\t\t\\setlist{nolistsep}\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Identifies a subset $I'$ of $I$ corresponding to packet fields to be placed in the state table.\n\t\t\\item Produces trapdoors $T(\\mathbf{x}_{I'} || I')$ and shuffles them using $\\sigma$ as $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$. \n\t\t\\item Creates encryptions of the state and the tag as $E(s)$ and $E(t)$, respectively.\n\t\t\\item Sends $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$, $E(s)$ and $E(t)$ to the cloud MB. \n\t\t\\end{enumerate}\t\t\n\n\\medskip\n{Cloud MB}: Creates a state table entry with $\\mathcal{T} = \\sigma(T(\\mathbf{x}_{I'} || I'))$, $E(s)$ and $E(t)$, and sends the $\\texttt{id}$ of this entry to the client MB.\n\n\\medskip\n{Entry MB}: Upon receiving a packet $\\mathbf{x}$, encrypts $\\mathbf{x} || I$ using PEKS and shuffles the result as $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$.\n\n\\medskip\n{Cloud MB}: Upon receiving $\\mathbf{x}$ and $\\sigma(\\mathcal{E}(\\mathbf{x}|| I))$, for $l' \\in |\\mathcal{T}|$ checks whether there exists an $l \\in [n]$ such that $\\mathsf{test}( \\mathcal{E}( x_l || l ), T( x_{l'} || l' )) = 1$. \n\t\t\\begin{enumerate}\n\t\t\t\\itemsep0em \n\t\t\t\\item If there is a match for all $l'$, computes $E(\\mathbf{x})$, appends $E(\\texttt{id})$, $E(s)$ and $E(t)$ to it and sends it to the client MB.\n\t\t\t\\item Otherwise, continues processing the \\emph{static} network functions (using the PNFV scheme).\n\t\t\\end{enumerate}\t\t\t\t\n\n\\medskip\n{Client MB}: Upon receiving an encrypted packet $E(\\mathbf{x})$\n\t\t\\begin{enumerate}\n\t\t\\itemsep0em \n\t\t\\item Decrypts it to obtain $\\mathbf{x}$.\n\t\t\\item Strips the $\\texttt{id}$, state $s$ and tag $t$, and carries out the action according to $t$.\n\t\t\\item \\textit{Update:} Sends the tuple $(\\texttt{id}, E(s'))$ to the cloud MB, where $s'$ is the new state.\n\t\t\\item \\textit{Deletion:} Sends the tuple $(\\texttt{id}, \\texttt{delete})$ to the cloud MB.\n\t\t\\end{enumerate}\n\\end{framed}\n\\vspace{-0.4cm}\n\\caption{State table solution private against the weak adversary. The PNFV scheme used in case of a state table miss is based on BGN.}\n\\label{fig:statetablesol}\n\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{Example}.}} \nWe illustrate the state table solution using a firewall state table as an example. The client MB identifies the index set \n\n", "index": 51, "text": "\\begin{equation}\n\\label{eq:5tuple}\nI' = \\{ \\texttt{s\\_ip}, \\texttt{d\\_ip}, \\texttt{s\\_port}, \\texttt{d\\_port}, \\texttt{prot}\\}, \n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"I^{\\prime}=\\{\\texttt{s\\_ip},\\texttt{d\\_ip},\\texttt{s\\_port},\\texttt{d\\_port},%&#10;\\texttt{prot}\\},\" display=\"block\"><mrow><mrow><msup><mi>I</mi><mo>\u2032</mo></msup><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mtext mathvariant=\"monospace\">s_ip</mtext><mo>,</mo><mtext mathvariant=\"monospace\">d_ip</mtext><mo>,</mo><mtext mathvariant=\"monospace\">s_port</mtext><mo>,</mo><mtext mathvariant=\"monospace\">d_port</mtext><mo>,</mo><mtext>\ud835\ude99\ud835\ude9b\ud835\ude98\ud835\ude9d</mtext><mo stretchy=\"false\">}</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nAs an example, consider the smallest sized packet $\\mathbf{x}$ of 34 bytes (14 bytes for the MAC header, 20 bytes for the IP header and 0 bytes for the payload). \nIf PNFV ID requires 4 bits and the state/policy ID requires another 20 bits, and the BGN ciphertexts have a blocksize of $256$ bits, then the PNFV payload has 99 bytes, thus yielding $34 + 20 + 99 = 153$ bytes for $\\mathbf{x}'$. In the case of the PEKS based scheme, the overhead is actually higher since encryptions corresponding to the 5-tuples and the virtual $\\texttt{tag}$ field needs to be added, thus yielding a tradeoff between packet processing efficiency and bandwidth/storage overhead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Empirical Evaluation}\n\nWe implemented the PEKS based and BGN based schemes in C, using the \\texttt{RELIC} cryptographic library~\\cite{relic-toolkit}. As discussed earlier, the PEKS based scheme relies on the Boneh and Franklin cryptosystem~\\cite{ibe}, whereas, for the BGN based scheme, we modified the Freeman's prime-order version~\\cite{freeman2010converting} provided by \\texttt{RELIC} in order to fix some bugs in the decryption phase and to implement lookup tables of pre-computed discrete logarithms in order to achieve constant-time decryption. For the two schemes, we chose a Barreto-Naehrig pairing-friendly elliptic curve defined on a 256-bit prime order group, achieving a 128-bit security level. For pairing computations, we used the optimal ate pairing implementation provided by \\texttt{RELIC}.\n\nIn the following, we present empirical results on PNFV simulations using the generic policy~\\ref{eq:equal-pol}, setting the size of each packet attribute $x_i$ to 4 bytes, which is the largest size of an IP header field in IPv4 packets (corresponding to IP addresses).  Simulations were performed on a machine running Ubuntu Trusty Tahr (Ubuntu 14.04.2 LTS), equipped with a 2.4 GHz CPU i5-520M and 4GB RAM.\n\n\n\n\n\n\n\n\n\n \n\n\n\\begin{figure*}[!htb]\n\\centering\n    \\begin{subfigure}[t]{0.3\\textwidth}\t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/bgn-fields.pdf}\n        \\caption{BGN based scheme with 10 policies\\label{fig:time_strong_attr}}\n    \\end{subfigure}\n~\n\\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/peks-fields.pdf}\n        \\caption{PEKS based scheme with 10 policies\\label{fig:time_weak_attr}}\n    \\end{subfigure} \n~\n\t\\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/nft-fields.pdf}\n        \\caption{Network function transformation with 10 policies (setup) \\label{fig:clientMB_attributes}}\n\\vspace*{-0.1cm} \n    \\end{subfigure} \n~\n    \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/bgn-pols.pdf}\n        \\caption{BGN based scheme with 5 packet fields\\label{fig:time_strong_policies} }\n    \\end{subfigure} \n~\n     \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/peks-pols.pdf}\n        \\caption{PEKS based scheme with 5 packet fields\\label{fig:time_weak_policies} }\n    \\end{subfigure} \n~\n\t \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/nft-pols.pdf}\n        \\caption{Network function transformation with 5 packet fields (setup)\\label{fig:clientMB_policies} }\n    \\end{subfigure}     \n  \\vspace{-0.2cm}\n\\caption{\\label{fig:time_strong} Execution times of different algorithms of the BGN and PEKS based schemes as functions of packet fields and number of policies.}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{BGN based Scheme}.}} Figures~\\ref{fig:time_strong_attr} and~\\ref{fig:time_strong_policies} report execution times of packet encryption, processing and decryption of the BGN based scheme w.r.t., respectively, the number of packet fields (and $10$ policies) and the number of policies (and $5$ packet fields). Experiments in Figure~\\ref{fig:time_strong_policies} are intended to simulate a typical firewall rule that uses the $5$-tuple given by Eq.~\\ref{eq:5tuple}. \n\nNote that the execution time of all three algorithms is linear in the number of packet fields (Figure~\\ref{fig:time_strong_attr}). Whereas, as shown in Figure~\\ref{fig:time_strong_policies}, execution times of packet processing and decryption are linear in the number of policies, but constant for packet encryption. For a network function with $10$ policies, private processing of $5$ packet fields takes 62 ms for encryption, 1,027 ms for processing, and 118 ms for decryption. \n\nThen, Figures~\\ref{fig:clientMB_attributes} and \\ref{fig:clientMB_policies} plot the execution time for the network function transformation algorithm: for the BGN based scheme, this is linear both as a function of the number of packet fields and policies, reaching a maximum of 7,669 ms (30 fields and 10 policies) and 3,831 ms (5 fields and 30 policies). However, note that these times are acceptable since this  does not have to be executed in real-time but only once, during the setup.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{PEKS based Scheme}.}} In Figures~\\ref{fig:time_weak_attr} and~\\ref{fig:time_weak_policies}, we report the execution times of the packet processing and decryption algorithms for the PEKS based scheme as a function of packet fields and number of policies. As the entry MB performs packet encryption and some preliminary packet processing, we divide the corresponding times between entry MB and cloud MB. \n\nNote from Figure~\\ref{fig:time_weak_attr} that packet processing (both at entry MB and cloud MB) as well as decryption \nare linear w.r.t. increasing number of packet fields, while packet processing at entry MB and decryption are constant w.r.t. increasing number of policies (Figure~\\ref{fig:time_weak_policies}). For a network function with 10 policies, private processing of $5$ packet fields takes 77 ms at the entry MB, 157 ms at the cloud MB and 16 ms for decryption. \n\nFinally, Figures~\\ref{fig:clientMB_attributes} and \\ref{fig:clientMB_policies} show that the network function transformation algorithm for this scheme is linear both in the number of packet fields and policies, reaching a maximum of 341 ms and 184 ms, respectively. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{Comparison of the two schemes}.}} Figures~\\ref{fig:clientMB_attributes} and~\\ref{fig:clientMB_policies} show the aggregate times of the two schemes (by adding up the times of packet encryption, processing and decryption) against increasing number of fields (with $10$ policies) and increasing number of policies (with $5$ packet fields used for private processing). The PEKS based scheme clearly outperforms the BGN based scheme. For instance, for a network function with $10$ policies, private processing of $5$ packet fields takes 250 ms in the PEKS based scheme and 1,208 ms in the BGN based scheme. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!htb]\n\\centering\n    \\begin{subfigure}[t]{0.26\\textwidth}\n\\hspace{-1cm}\n\t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/agg-fields.pdf}\n        \\caption{With 10 policies\\label{fig:comparison_attributes} }\n    \\end{subfigure}\n    \\hspace*{-1cm}\n~\n    \\begin{subfigure}[t]{0.26\\textwidth}\n    \t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/agg-pols.pdf}\n        \\caption{With 5 packet fields\\label{fig:comparison_policies} }\n    \\end{subfigure} \n    \\vspace{-0.2cm}\n\\caption{\\label{fig:client_comparison} Aggregate execution times (packet encryption, processing and decryption) for the two schemes.}\n    \\vspace{-0.2cm}\n\\end{figure}\n\nTranslated into packets per second (pps), the above two numbers translate to a modest 4 pps and 0.82 pps, respectively. However, we remark that our implementation merely stands as a proof-of-concept, and as such we did not go for further implementation efficiency by using a more powerful machine or multi-threading in C. For instance, the time taken by the entry MB, the cloud MB and the client MB for a packet with a single encrypted field and a network function with a single policy was 13.32 ms, 5.41 ms and 2.69 ms, respectively, giving a total of 21.42 ms. Using multi-threading we can process a larger number of packet fields (in the case of the entry and client MB) and the policies (in the case of the cloud MB) in parallel, thus increasing the number of packets processed per second. With a modestly more powerful machine that can process say 50 threads concurrently, we can achieve a rate of more than 2,300 pps (using 21.42 ms as the baseline). \n\nEven without optimizations, e.g., multi-threading, our performance is comparable to that of the schemes proposed by Shi, Zhang and Zhong~\\cite{mlm-firewall}. The three different \\emph{modes} in~\\cite{mlm-firewall} yield 60 ms, 1,000 ms and 3,000 ms for private processing of a $5$-tuple with $10$ firewall rules. The Bloom filter based scheme from Khakpour and Liu~\\cite{bf-firewall} does much better, achieving 0.1 ms for a 10 rule firewall.\\footnote{These approximate numbers are deduced from ACL index 16 from Figure~8 in~\\cite{bf-firewall}.} However, as described in Section~\\ref{sec:related}, both these works are narrower in scope and their security, at best, is questionable. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Conclusion}  \n\\label{sec:conclude}\nThis paper addressed the problem of private processing of outsourced network functions, where network function policies need to be kept private from the cloud, other tenants and third parties. \nWe presented a cryptographic treatment of the problem, introducing security definitions as well as an abstract model of generic network functions, and proposed a few instantiations using homomorphic encryption and public-key encryption with keyword search. \nThe performance of our proposed solutions is reasonable considering that we rely on public key operations and provide provable security in the presence of an honest-but-curious cloud, while guaranteeing that third party users, who are sending/receiving traffic, are oblivious to network function outsourcing. \nIn future work, we plan to investigate mechanisms to further speed up computation, e.g., assuming that part of the cloud runs on a trusted computing base. \nWe are also working on integrating our solutions for private NFV to existing NFV frameworks such as OPNFV\\footnote{\\url{https://www.opnfv.org/}.} and ClickOS~\\cite{click-os}.\n\n\n\n\n\\appendix\n\n\n\n\\section{Proofs} \n\\label{app:sec-red}\nThe following reductionist arguments will use policy~\\ref{eq:equal-pol} as the base. It is straightforward to extend the arguments to policy~\\ref{eq:range-pol}.\n\\begin{claim}\nIf the FHE scheme $(E, D)$ is semantically secure (indistinguishable under chosen plaintext attack), then the PNFV scheme based on it is private against $\\cal{A}_\\text{strong}$.\n\\end{claim}\n\n\\begin{argument}\nWe assume an FHE oracle which when given a plaintext $x$ returns the encryption $E(x)$, and when given two ciphertexts $E(x)$ and $E(y)$ returns $E(x + y)$. We use $\\cal{A}_\\text{strong}$ as a subroutine to an adversary $\\cal{B}$ that tries to subvert the FHE scheme. $\\cal{B}$ announces $m_0 = z_0$ and $m_1 = z_1$ as its chosen plaintexts. $\\cal{B}$ is given $E(m_b)$ such that $b = 0$ with probability $\\frac{1}{2}$, and is asked to guess $b$. \n\n$\\cal{B}$ begins by choosing a $y \\ne m_0, m_1$ and requesting the encryptions of $E(\\mathbf{e}_1)$, $E(\\mathbf{e}_2)$ and $E(y)$ from the FHE oracle.\\footnote{To be precise, asking the oracle for the encryption of an $n$-element vector actually means asking the oracle for $n$ encryptions, once per element. For succinctness, we omit this detail.} $\\cal{B}$ gives $E(\\mathbf{e}_1)$, $E(\\mathbf{e}_2)$, $E(y)$ and $E(m_b)$ to $\\cal{A}_\\text{strong}$ as the description of the transformed network function $\\phi$. Note that this is essentially the policy\n", "itemtype": "equation", "pos": 71518, "prevtext": "\nwhich correspond to the source IP address, destination IP address, source port, destination port and protocol fields, respectively, of an IPv4 packet. The client MB creates trapdoors for the values of these fields and randomly shuffles \nthe trapdoors creating the set $\\cal {T}$. Let $s \\in \\{\\texttt{new}, \\texttt{est}\\}$ be the possible states, where the second state is the abbreviation of ``established.'' Let $t \\in \\{\\texttt{allow}, \\texttt{drop} \\}$ be the possible tags. Suppose the client MB first receives a packet $\\mathbf{x}$ whose SYN flag is set. The client MB then sends the set $\\cal T$ and $E(s) = E(\\texttt{new})$ and $E(t) = E(\\texttt{allow})$ to the cloud MB. The cloud MB creates an entry for this state table. Suppose the identifier of this state table entry is $\\texttt{id}$, which is sent to the client MB. The cloud MB subsequently checks each incoming encrypted and shuffled packet $\\mathbf{x}$ (done by the entry MB) to see if it matches this state table entry. If it does, it simply appends $E(\\texttt{id})$, $E(\\texttt{new})$ and $E(\\texttt{allow})$ as the state and tag respectively, to the encrypted packet $E(\\mathbf{x})$ and sends it to the client MB. The client MB, after decrypting the packet, checks the state and the ACK flag in $\\mathbf{x}$. If the ACK flag is set, the client MB sets $s \\leftarrow \\texttt{est}$ and sends $(\\texttt{id}, E(\\texttt{est}))$ to the cloud MB. Since the tag is set to $\\texttt{allow}$, it forwards the packet to \nits intended destination within the internal network. After the current TCP connection is over (through FIN-ACK exchange), the client MB sends the pair $(\\texttt{id}, \\texttt{delete})$ to the cloud MB, which in turn deletes the corresponding entry.\n\n{\\medskip\\noindent\\textbf{{Privacy}.}} The privacy argument of the proposed state table solution is similar to the one for the PEKS based PNFV scheme, and hence we omit it here. However, two important differences are that (i) the adversary $\\mathcal{A}_\\text{weak}$ knows the number of fields being checked (due to $|I'|$), and (ii) learns whether or not the current packet matches a state table entry. \n\n\n\n\n\n\n\\section{Implementation and Performance Evaluation}\n\\label{sec:implement}\nIn the following, we provide a proof-of-concept of the feasibility of our PNFV schemes. \n\n\n\\subsection{Implementing PNFV}\nWe assume that private network function processing operates at the network layer in the OSI model, i.e., it processes IP packets, although it can be extended to the processing of Ethernet frames as well (MAC headers). \n\nNote that not all packet fields are needed for private processing of a given network function, e.g., the ``header checksum'' field of an IPv4 packet is used for integrity check and does not have to be encrypted. Thus, we only use a subset $I'$ of the set of indexes $I$ corresponding to different fields of a packet. For instance, if the network function performs firewall actions, we assume that $I'$ is the 5-tuple defined in Eq.~\\ref{eq:5tuple}. \nThe packet encryption algorithm of the cloud MB, upon receiving the packet $\\mathbf{x}$, computes encryptions of the above fields only. Recall that, in the PEKS based scheme, the entry MB deletes the original packet $\\mathbf{x}$: for this tuple, this implemented by the entry MB resetting the corresponding field values to $0$ before sending $\\mathbf{x}$ to the cloud MB.\n\nWhenever a packet $\\mathbf{x}$ arrives at the cloud MB, after private processing, this is transformed into a new packet $\\mathbf{x}'$ (as shown in Figure~\\ref{fig:encapsulation-x}) which is then sent to the client MB. For instance, assume a network function implementing the policy: if $x_{\\texttt{s\\_ip}} = \\texttt{127.0.0.1}$ then block the packet, otherwise allow it, and \nassume we are using the PNFV scheme based on BGN (Section~\\ref{sub:bgn-scheme}). \n\nThe client MB constructs the transformed packet $\\mathbf{x}'$ as follows. It first constructs a new IP header containing its IP address as the source IP and the IP address of the client MB as the destination IP (similarly for the ports). The payload of $\\mathbf{x}'$ contains the original IP packet $\\mathbf{x}$, as shown in the figure, followed by PNFV related payload. The PNFV payload specific to the BGN based scheme and the above mentioned policy is:\n\n\n\\begin{figure}[!tb]\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx\\svgwidth\\undefined\n    \\setlength{\\unitlength}{228.60229492bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{\\svgwidth}\n  \\fi\n  \\global\\let\\svgwidth\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,0.44079526)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{encapsulation-x-wo-names.pdf}}\n    \\put(0.270219743,0.42047569){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{\\small Ethernet frame of packet $\\mathbf{x}$}}}\n    \\put(0.27606589,0.00556308){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{\\small Ethernet frame of packet $\\mathbf{x}'$}}}\n  \\end{picture}\n\\endgroup\n\\caption{Encapsulation of packet $\\mathbf{x}$ within packet $\\mathbf{x}'$ by the cloud MB. Fields shaded \\textcolor{nfvyellow}{\\protect\\rule[0pt]{2mm}{2mm}}~have identical content.}\n\\label{fig:encapsulation-x}\n\\vspace{-0.3cm}\n\\end{figure}\n\n\n\\medskip\\noindent\n\\resizebox{\\columnwidth}{!}{\n\\begin{tabular}{ccccc} \n\\text{PNFV ID} & \\text{state/policy ID} & $x_j || j$ & $z || j$ & $c$ \\\\\n\\hline\n\\texttt{BGN} & \\texttt{id} & $E(\\texttt{allow} || \\texttt{tag})$ & $E(\\texttt{deny}  || \\texttt{tag})$ & $E(c)$ \n\\end{tabular}\n}\n\\medskip\n\n\n\nThe first field contains the ID of the PNFV scheme being used (in this case, the BGN based scheme). The second field reports the policy ID of the particular policy being processed (in case of state tables this is the state table entry ID). The next two items are the two possible actions that are to be applied on packet field $j$ depending on whether there was a policy match. In our example, this is $E(\\texttt{allow} || \\texttt{tag})$ which is the action when there is no match and $E(\\texttt{deny} || \\texttt{tag})$ is the action when there is a match. Here $\\texttt{tag}$ is an index for the \\emph{virtual} field tag, since IP packets do not have a $\\texttt{tag}$ field. In case of other policies, this could be a real packet field, for instance the $\\texttt{prot}$ (protocol) field. The last item is the encryption of the result of the matching function, i.e., $E(c)$.\n\nWhen the client MB receives the packet $\\mathbf{x}'$, it first extracts $\\mathbf{x}$ in a straightforward manner. The client MB then checks the PNFV ID to learn which scheme is to be applied (in this case, the BGN based scheme) and decrypts the last item $E(c)$. If $c = 1$, it decrypts $E(\\texttt{deny} || \\texttt{tag})$ and then drops the packets $\\mathbf{x}$,\nwhereas, if $c \\ne 1$, it decrypts $E(\\texttt{allow} || \\texttt{tag})$, and forwards the packet $\\mathbf{x}$ to its intended destination. The policy ID can be used for bookkeeping.  \n\nIf the original packet $\\mathbf{x}$ has size $| \\mathbf{x} |$, then the size of $\\mathbf{x}'$ is given by:\n", "index": 53, "text": "\n\\[\n|\\mathbf{x}' | = | \\mathbf{x} | + \\text{New IP header} + \\text{PNFV payload}\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex32.m1\" class=\"ltx_Math\" alttext=\"|\\mathbf{x}^{\\prime}|=|\\mathbf{x}|+\\text{New IP header}+\\text{PNFV payload}\" display=\"block\"><mrow><mrow><mo stretchy=\"false\">|</mo><msup><mi>\ud835\udc31</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo></mrow><mo>=</mo><mrow><mrow><mo stretchy=\"false\">|</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">|</mo></mrow><mo>+</mo><mtext>New IP header</mtext><mo>+</mo><mtext>PNFV payload</mtext></mrow></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nDuring the test state, whenever $\\cal{A}_\\text{strong}$ asks for the result (encryptions from packet processing) of a packet $\\mathbf{x}$ under PNFV, $\\cal{B}$ does as follows. If $x_1 = y$, $\\cal{B}$ asks the FHE oracle for the encryptions of $x_1, x_3, \\ldots, x_n$. It further requests the oracle for the encryption of $0$, and upon receiving $E(0)$, asks for the encryption of $E(m_b) + E(0) = E(m_b)'$. $\\cal{B}$ constructs the vector\n", "itemtype": "equation", "pos": 83717, "prevtext": "\nAs an example, consider the smallest sized packet $\\mathbf{x}$ of 34 bytes (14 bytes for the MAC header, 20 bytes for the IP header and 0 bytes for the payload). \nIf PNFV ID requires 4 bits and the state/policy ID requires another 20 bits, and the BGN ciphertexts have a blocksize of $256$ bits, then the PNFV payload has 99 bytes, thus yielding $34 + 20 + 99 = 153$ bytes for $\\mathbf{x}'$. In the case of the PEKS based scheme, the overhead is actually higher since encryptions corresponding to the 5-tuples and the virtual $\\texttt{tag}$ field needs to be added, thus yielding a tradeoff between packet processing efficiency and bandwidth/storage overhead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection{Empirical Evaluation}\n\nWe implemented the PEKS based and BGN based schemes in C, using the \\texttt{RELIC} cryptographic library~\\cite{relic-toolkit}. As discussed earlier, the PEKS based scheme relies on the Boneh and Franklin cryptosystem~\\cite{ibe}, whereas, for the BGN based scheme, we modified the Freeman's prime-order version~\\cite{freeman2010converting} provided by \\texttt{RELIC} in order to fix some bugs in the decryption phase and to implement lookup tables of pre-computed discrete logarithms in order to achieve constant-time decryption. For the two schemes, we chose a Barreto-Naehrig pairing-friendly elliptic curve defined on a 256-bit prime order group, achieving a 128-bit security level. For pairing computations, we used the optimal ate pairing implementation provided by \\texttt{RELIC}.\n\nIn the following, we present empirical results on PNFV simulations using the generic policy~\\ref{eq:equal-pol}, setting the size of each packet attribute $x_i$ to 4 bytes, which is the largest size of an IP header field in IPv4 packets (corresponding to IP addresses).  Simulations were performed on a machine running Ubuntu Trusty Tahr (Ubuntu 14.04.2 LTS), equipped with a 2.4 GHz CPU i5-520M and 4GB RAM.\n\n\n\n\n\n\n\n\n\n \n\n\n\\begin{figure*}[!htb]\n\\centering\n    \\begin{subfigure}[t]{0.3\\textwidth}\t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/bgn-fields.pdf}\n        \\caption{BGN based scheme with 10 policies\\label{fig:time_strong_attr}}\n    \\end{subfigure}\n~\n\\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/peks-fields.pdf}\n        \\caption{PEKS based scheme with 10 policies\\label{fig:time_weak_attr}}\n    \\end{subfigure} \n~\n\t\\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/nft-fields.pdf}\n        \\caption{Network function transformation with 10 policies (setup) \\label{fig:clientMB_attributes}}\n\\vspace*{-0.1cm} \n    \\end{subfigure} \n~\n    \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/bgn-pols.pdf}\n        \\caption{BGN based scheme with 5 packet fields\\label{fig:time_strong_policies} }\n    \\end{subfigure} \n~\n     \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/peks-pols.pdf}\n        \\caption{PEKS based scheme with 5 packet fields\\label{fig:time_weak_policies} }\n    \\end{subfigure} \n~\n\t \\begin{subfigure}[t]{0.3\\textwidth} \\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/nft-pols.pdf}\n        \\caption{Network function transformation with 5 packet fields (setup)\\label{fig:clientMB_policies} }\n    \\end{subfigure}     \n  \\vspace{-0.2cm}\n\\caption{\\label{fig:time_strong} Execution times of different algorithms of the BGN and PEKS based schemes as functions of packet fields and number of policies.}\n\\end{figure*}\n\n{\\medskip\\noindent\\textbf{{BGN based Scheme}.}} Figures~\\ref{fig:time_strong_attr} and~\\ref{fig:time_strong_policies} report execution times of packet encryption, processing and decryption of the BGN based scheme w.r.t., respectively, the number of packet fields (and $10$ policies) and the number of policies (and $5$ packet fields). Experiments in Figure~\\ref{fig:time_strong_policies} are intended to simulate a typical firewall rule that uses the $5$-tuple given by Eq.~\\ref{eq:5tuple}. \n\nNote that the execution time of all three algorithms is linear in the number of packet fields (Figure~\\ref{fig:time_strong_attr}). Whereas, as shown in Figure~\\ref{fig:time_strong_policies}, execution times of packet processing and decryption are linear in the number of policies, but constant for packet encryption. For a network function with $10$ policies, private processing of $5$ packet fields takes 62 ms for encryption, 1,027 ms for processing, and 118 ms for decryption. \n\nThen, Figures~\\ref{fig:clientMB_attributes} and \\ref{fig:clientMB_policies} plot the execution time for the network function transformation algorithm: for the BGN based scheme, this is linear both as a function of the number of packet fields and policies, reaching a maximum of 7,669 ms (30 fields and 10 policies) and 3,831 ms (5 fields and 30 policies). However, note that these times are acceptable since this  does not have to be executed in real-time but only once, during the setup.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{PEKS based Scheme}.}} In Figures~\\ref{fig:time_weak_attr} and~\\ref{fig:time_weak_policies}, we report the execution times of the packet processing and decryption algorithms for the PEKS based scheme as a function of packet fields and number of policies. As the entry MB performs packet encryption and some preliminary packet processing, we divide the corresponding times between entry MB and cloud MB. \n\nNote from Figure~\\ref{fig:time_weak_attr} that packet processing (both at entry MB and cloud MB) as well as decryption \nare linear w.r.t. increasing number of packet fields, while packet processing at entry MB and decryption are constant w.r.t. increasing number of policies (Figure~\\ref{fig:time_weak_policies}). For a network function with 10 policies, private processing of $5$ packet fields takes 77 ms at the entry MB, 157 ms at the cloud MB and 16 ms for decryption. \n\nFinally, Figures~\\ref{fig:clientMB_attributes} and \\ref{fig:clientMB_policies} show that the network function transformation algorithm for this scheme is linear both in the number of packet fields and policies, reaching a maximum of 341 ms and 184 ms, respectively. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\\medskip\\noindent\\textbf{{Comparison of the two schemes}.}} Figures~\\ref{fig:clientMB_attributes} and~\\ref{fig:clientMB_policies} show the aggregate times of the two schemes (by adding up the times of packet encryption, processing and decryption) against increasing number of fields (with $10$ policies) and increasing number of policies (with $5$ packet fields used for private processing). The PEKS based scheme clearly outperforms the BGN based scheme. For instance, for a network function with $10$ policies, private processing of $5$ packet fields takes 250 ms in the PEKS based scheme and 1,208 ms in the BGN based scheme. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{figure}[!htb]\n\\centering\n    \\begin{subfigure}[t]{0.26\\textwidth}\n\\hspace{-1cm}\n\t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/agg-fields.pdf}\n        \\caption{With 10 policies\\label{fig:comparison_attributes} }\n    \\end{subfigure}\n    \\hspace*{-1cm}\n~\n    \\begin{subfigure}[t]{0.26\\textwidth}\n    \t\\captionsetup{skip=0pt}\n        \\centering\n\t\t\n\t\t\\includegraphics[width=\\columnwidth]{figures/agg-pols.pdf}\n        \\caption{With 5 packet fields\\label{fig:comparison_policies} }\n    \\end{subfigure} \n    \\vspace{-0.2cm}\n\\caption{\\label{fig:client_comparison} Aggregate execution times (packet encryption, processing and decryption) for the two schemes.}\n    \\vspace{-0.2cm}\n\\end{figure}\n\nTranslated into packets per second (pps), the above two numbers translate to a modest 4 pps and 0.82 pps, respectively. However, we remark that our implementation merely stands as a proof-of-concept, and as such we did not go for further implementation efficiency by using a more powerful machine or multi-threading in C. For instance, the time taken by the entry MB, the cloud MB and the client MB for a packet with a single encrypted field and a network function with a single policy was 13.32 ms, 5.41 ms and 2.69 ms, respectively, giving a total of 21.42 ms. Using multi-threading we can process a larger number of packet fields (in the case of the entry and client MB) and the policies (in the case of the cloud MB) in parallel, thus increasing the number of packets processed per second. With a modestly more powerful machine that can process say 50 threads concurrently, we can achieve a rate of more than 2,300 pps (using 21.42 ms as the baseline). \n\nEven without optimizations, e.g., multi-threading, our performance is comparable to that of the schemes proposed by Shi, Zhang and Zhong~\\cite{mlm-firewall}. The three different \\emph{modes} in~\\cite{mlm-firewall} yield 60 ms, 1,000 ms and 3,000 ms for private processing of a $5$-tuple with $10$ firewall rules. The Bloom filter based scheme from Khakpour and Liu~\\cite{bf-firewall} does much better, achieving 0.1 ms for a 10 rule firewall.\\footnote{These approximate numbers are deduced from ACL index 16 from Figure~8 in~\\cite{bf-firewall}.} However, as described in Section~\\ref{sec:related}, both these works are narrower in scope and their security, at best, is questionable. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Conclusion}  \n\\label{sec:conclude}\nThis paper addressed the problem of private processing of outsourced network functions, where network function policies need to be kept private from the cloud, other tenants and third parties. \nWe presented a cryptographic treatment of the problem, introducing security definitions as well as an abstract model of generic network functions, and proposed a few instantiations using homomorphic encryption and public-key encryption with keyword search. \nThe performance of our proposed solutions is reasonable considering that we rely on public key operations and provide provable security in the presence of an honest-but-curious cloud, while guaranteeing that third party users, who are sending/receiving traffic, are oblivious to network function outsourcing. \nIn future work, we plan to investigate mechanisms to further speed up computation, e.g., assuming that part of the cloud runs on a trusted computing base. \nWe are also working on integrating our solutions for private NFV to existing NFV frameworks such as OPNFV\\footnote{\\url{https://www.opnfv.org/}.} and ClickOS~\\cite{click-os}.\n\n\n\n\n\\appendix\n\n\n\n\\section{Proofs} \n\\label{app:sec-red}\nThe following reductionist arguments will use policy~\\ref{eq:equal-pol} as the base. It is straightforward to extend the arguments to policy~\\ref{eq:range-pol}.\n\\begin{claim}\nIf the FHE scheme $(E, D)$ is semantically secure (indistinguishable under chosen plaintext attack), then the PNFV scheme based on it is private against $\\cal{A}_\\text{strong}$.\n\\end{claim}\n\n\\begin{argument}\nWe assume an FHE oracle which when given a plaintext $x$ returns the encryption $E(x)$, and when given two ciphertexts $E(x)$ and $E(y)$ returns $E(x + y)$. We use $\\cal{A}_\\text{strong}$ as a subroutine to an adversary $\\cal{B}$ that tries to subvert the FHE scheme. $\\cal{B}$ announces $m_0 = z_0$ and $m_1 = z_1$ as its chosen plaintexts. $\\cal{B}$ is given $E(m_b)$ such that $b = 0$ with probability $\\frac{1}{2}$, and is asked to guess $b$. \n\n$\\cal{B}$ begins by choosing a $y \\ne m_0, m_1$ and requesting the encryptions of $E(\\mathbf{e}_1)$, $E(\\mathbf{e}_2)$ and $E(y)$ from the FHE oracle.\\footnote{To be precise, asking the oracle for the encryption of an $n$-element vector actually means asking the oracle for $n$ encryptions, once per element. For succinctness, we omit this detail.} $\\cal{B}$ gives $E(\\mathbf{e}_1)$, $E(\\mathbf{e}_2)$, $E(y)$ and $E(m_b)$ to $\\cal{A}_\\text{strong}$ as the description of the transformed network function $\\phi$. Note that this is essentially the policy\n", "index": 55, "text": "\n\\[\n\\texttt{if } x_1 == y \\texttt{ then } x_2 \\leftarrow m_b.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex33.m1\" class=\"ltx_Math\" alttext=\"\\texttt{if }x_{1}==y\\texttt{ then }x_{2}\\leftarrow m_{b}.\" display=\"block\"><mrow><mtext mathvariant=\"monospace\">if\u00a0</mtext><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><mi>y</mi><mtext mathvariant=\"monospace\">\u00a0then\u00a0</mtext><msub><mi>x</mi><mn>2</mn></msub><mo>\u2190</mo><msub><mi>m</mi><mi>b</mi></msub><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nOtherwise if $x_1 \\ne y$, $\\cal{B}$ asks for the encryption of $x_2$ from the FHE oracle and $E(m_b)'$ is replaced with $E(x_2)$ in the above vector. This vector is then given to $\\cal{A}_\\text{strong}$. When $\\cal{A}_\\text{strong}$ submits its guess for $\\psi$ as the tuple $(y',z')$ (as a match-action pair), $\\cal{B}$ does as follows. If $y' = y$ and $z' = z_0$, then $\\cal{B}$ outputs $b = 0$ as its guess, i.e., $\\cal{B}$ guesses that $E(m_b)$ is the encryption of $m_0 = z_0$. Otherwise, if $y' = y$ and $z' = z_1$, then $\\cal{B}$ outputs $b = 1$, i.e., $\\cal{B}$ guesses that $E(m_b)$ is the encryption of $m_1 = z_1$. To see that this strategy works, notice that if $m_b = m_0 = z_0$, the above policy is\n", "itemtype": "equation", "pos": 84221, "prevtext": "\nDuring the test state, whenever $\\cal{A}_\\text{strong}$ asks for the result (encryptions from packet processing) of a packet $\\mathbf{x}$ under PNFV, $\\cal{B}$ does as follows. If $x_1 = y$, $\\cal{B}$ asks the FHE oracle for the encryptions of $x_1, x_3, \\ldots, x_n$. It further requests the oracle for the encryption of $0$, and upon receiving $E(0)$, asks for the encryption of $E(m_b) + E(0) = E(m_b)'$. $\\cal{B}$ constructs the vector\n", "index": 57, "text": "\n\\[\nE(\\mathbf{x}') = \n\\begin{pmatrix}\nE(x_1) & E(m_b)' & E(x_3) & \\cdots & E(x_n)\n\\end{pmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex34.m1\" class=\"ltx_Math\" alttext=\"E(\\mathbf{x}^{\\prime})=\\begin{pmatrix}E(x_{1})&amp;E(m_{b})^{\\prime}&amp;E(x_{3})&amp;%&#10;\\cdots&amp;E(x_{n})\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msup><mi>\ud835\udc31</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><msub><mi>m</mi><mi>b</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2032</mo></msup></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nand if $m_b = m_1 = z_1$, the above policy is\n", "itemtype": "equation", "pos": 85033, "prevtext": "\nOtherwise if $x_1 \\ne y$, $\\cal{B}$ asks for the encryption of $x_2$ from the FHE oracle and $E(m_b)'$ is replaced with $E(x_2)$ in the above vector. This vector is then given to $\\cal{A}_\\text{strong}$. When $\\cal{A}_\\text{strong}$ submits its guess for $\\psi$ as the tuple $(y',z')$ (as a match-action pair), $\\cal{B}$ does as follows. If $y' = y$ and $z' = z_0$, then $\\cal{B}$ outputs $b = 0$ as its guess, i.e., $\\cal{B}$ guesses that $E(m_b)$ is the encryption of $m_0 = z_0$. Otherwise, if $y' = y$ and $z' = z_1$, then $\\cal{B}$ outputs $b = 1$, i.e., $\\cal{B}$ guesses that $E(m_b)$ is the encryption of $m_1 = z_1$. To see that this strategy works, notice that if $m_b = m_0 = z_0$, the above policy is\n", "index": 59, "text": "\n\\[\n\\texttt{if } x_1 == y \\texttt{ then } x_2 \\leftarrow z_0,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex35.m1\" class=\"ltx_Math\" alttext=\"\\texttt{if }x_{1}==y\\texttt{ then }x_{2}\\leftarrow z_{0},\" display=\"block\"><mrow><mtext mathvariant=\"monospace\">if\u00a0</mtext><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><mi>y</mi><mtext mathvariant=\"monospace\">\u00a0then\u00a0</mtext><msub><mi>x</mi><mn>2</mn></msub><mo>\u2190</mo><msub><mi>z</mi><mn>0</mn></msub><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nas required.\n\\end{argument}\n\n\\begin{claim}\nIf the BGN cryptosystem $(E, D)$ is semantically secure (indistinguishable under chosen plaintext attack), then the PNFV scheme based on the BGN scheme is private against $\\cal{A}_\\text{strong}$.\n\\end{claim}\n\n\\begin{argument}\nThe proof is similar to above with minor differences, which we highlight here. For network function transformation, $\\cal{B}$ asks the BGN oracle the encryption of $n-1$ zeros and constructs the vector \n", "itemtype": "equation", "pos": 85143, "prevtext": "\nand if $m_b = m_1 = z_1$, the above policy is\n", "index": 61, "text": "\n\\[\n\\texttt{if } x_1 == y \\texttt{ then } x_2 \\leftarrow z_1,\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex36.m1\" class=\"ltx_Math\" alttext=\"\\texttt{if }x_{1}==y\\texttt{ then }x_{2}\\leftarrow z_{1},\" display=\"block\"><mrow><mtext mathvariant=\"monospace\">if\u00a0</mtext><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><mi>y</mi><mtext mathvariant=\"monospace\">\u00a0then\u00a0</mtext><msub><mi>x</mi><mn>2</mn></msub><mo>\u2190</mo><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nIt then asks the oracle for encryptions of $E(1)$, $E(\\mathbf{e}_1)$, $E(y)$ and $E(\\mathbf{e}_2)$, and sends the tuple\n", "itemtype": "equation", "pos": 85679, "prevtext": "\nas required.\n\\end{argument}\n\n\\begin{claim}\nIf the BGN cryptosystem $(E, D)$ is semantically secure (indistinguishable under chosen plaintext attack), then the PNFV scheme based on the BGN scheme is private against $\\cal{A}_\\text{strong}$.\n\\end{claim}\n\n\\begin{argument}\nThe proof is similar to above with minor differences, which we highlight here. For network function transformation, $\\cal{B}$ asks the BGN oracle the encryption of $n-1$ zeros and constructs the vector \n", "index": 63, "text": "\n\\[\nE(m_b\\mathbf{e}_2) = \n\\begin{pmatrix}\nE(0)' & E(m_b) & E(0)'' & \\cdots & E(0)^{(n-1)}\n\\end{pmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex37.m1\" class=\"ltx_Math\" alttext=\"E(m_{b}\\mathbf{e}_{2})=\\begin{pmatrix}E(0)^{\\prime}&amp;E(m_{b})&amp;E(0)^{\\prime%&#10;\\prime}&amp;\\cdots&amp;E(0)^{(n-1)}\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>m</mi><mi>b</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>\u2032</mo></msup></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>m</mi><mi>b</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mi>\u2032\u2032</mi></msup></mrow></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></msup></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": " \nto $\\cal{A}_\\text{strong}$ as the description of the transformed network function. During the guess state of $\\cal{A}_\\text{strong}$, whenever a packet $\\mathbf{x}$ is presented to $\\cal{B}$, it asks the BGN oracle for the encryption of $1 - x_1 + y$ and labels the resulting encryption as $E(m(\\mathbf{x}))$ (note that if $x_1 = y$ then the matching function is simply the encryption of $1$). For the action function, $\\cal{B}$ asks the FHE oracle for the encryptions of $x_1, x_3, \\ldots, x_n$. It further requests the oracle for the encryption of $0$, and upon receiving $E(0)$, asks for the encryption of $E(m_b) + E(0) = E(m_b)'$. $\\cal{B}$ constructs the vector\n", "itemtype": "equation", "pos": -1, "prevtext": "\nIt then asks the oracle for encryptions of $E(1)$, $E(\\mathbf{e}_1)$, $E(y)$ and $E(\\mathbf{e}_2)$, and sends the tuple\n", "index": 65, "text": "\n\\[\n(E(1), E(\\mathbf{e}_1), E(y), E(\\mathbf{e}_2), E(m_b\\mathbf{e}_2))\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex38.m1\" class=\"ltx_Math\" alttext=\"(E(1),E(\\mathbf{e}_{1}),E(y),E(\\mathbf{e}_{2}),E(m_{b}\\mathbf{e}_{2}))\" display=\"block\"><mrow><mo stretchy=\"false\">(</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>\ud835\udc1e</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>m</mi><mi>b</mi></msub><mo>\u2062</mo><msub><mi>\ud835\udc1e</mi><mn>2</mn></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nFinally $\\cal{B}$ asks the BGN oracle for the encryption of $E(\\mathbf{x})$. It sends $E(\\mathbf{x})$, $E(m(\\mathbf{x}))$ and $E(a(\\mathbf{x}))$ to $\\cal{A}_\\text{strong}$.\n\\end{argument}\n\n\\begin{claim}\nIf the probabilistic encryption scheme $E$ is semantically secure, the PEKS scheme is semantically secure against the chosen keyword (plaintext) attack, its trapdoor function $T$ is not invertible, and the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation, then the PNFV scheme described in Section~\\ref{sub:weak-peks} is private against $\\cal{A}_\\text{weak}$.\n\\end{claim}\n\n\\begin{argument}\nWe define the following statements:\n\\begin{itemize}\n\t\\item $D$: the PNFV scheme described in Section~\\ref{sub:weak-peks} is private against $\\cal{A}_\\text{weak}$.\n\t\\item $A_1$: the probabilistic encryption scheme $E$ is semantically secure.\n\t\\item $A_2$: the PEKS scheme is semantically secure against the chosen keyword (plaintext) attack and the trapdoor function $T$ is not invertible.\n\t\\item $A_3$: the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation.\n\\end{itemize}\nWe further refine $D$ as follows:\n\\begin{itemize}\n\t\\item $D_1$: $\\cal{A}_\\text{weak}$ does not know the tuple $(j, z)$.\n\t\\item $D_2$: $\\cal{A}_\\text{weak}$ does not know the tuple $(i, j, y)$.\n\t\\item $D_3$: $\\cal{A}_\\text{weak}$ does not know the tuple $(i, j)$.\n\\end{itemize}\nThen it follows that:\n", "itemtype": "equation", "pos": 86648, "prevtext": " \nto $\\cal{A}_\\text{strong}$ as the description of the transformed network function. During the guess state of $\\cal{A}_\\text{strong}$, whenever a packet $\\mathbf{x}$ is presented to $\\cal{B}$, it asks the BGN oracle for the encryption of $1 - x_1 + y$ and labels the resulting encryption as $E(m(\\mathbf{x}))$ (note that if $x_1 = y$ then the matching function is simply the encryption of $1$). For the action function, $\\cal{B}$ asks the FHE oracle for the encryptions of $x_1, x_3, \\ldots, x_n$. It further requests the oracle for the encryption of $0$, and upon receiving $E(0)$, asks for the encryption of $E(m_b) + E(0) = E(m_b)'$. $\\cal{B}$ constructs the vector\n", "index": 67, "text": "\n\\[\nE(a(\\mathbf{x})) = \n\\begin{pmatrix}\nE(x_1) & E(m_b)' & E(x_3) & \\cdots & E(x_n)\n\\end{pmatrix}.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex39.m1\" class=\"ltx_Math\" alttext=\"E(a(\\mathbf{x}))=\\begin{pmatrix}E(x_{1})&amp;E(m_{b})^{\\prime}&amp;E(x_{3})&amp;\\cdots&amp;E(x%&#10;_{n})\\end{pmatrix}.\" display=\"block\"><mrow><mrow><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>a</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc31</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo>(</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><msup><mrow><mo stretchy=\"false\">(</mo><msub><mi>m</mi><mi>b</mi></msub><mo stretchy=\"false\">)</mo></mrow><mo>\u2032</mo></msup></mrow></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd><mtd columnalign=\"center\"><mi mathvariant=\"normal\">\u22ef</mi></mtd><mtd columnalign=\"center\"><mrow><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mtd></mtr></mtable><mo>)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nThat is, the PNFV scheme is not private if $\\cal{A}_\\text{weak}$ knows any of the aforementioned tuples. The claim states that\n", "itemtype": "equation", "pos": 88176, "prevtext": "\nFinally $\\cal{B}$ asks the BGN oracle for the encryption of $E(\\mathbf{x})$. It sends $E(\\mathbf{x})$, $E(m(\\mathbf{x}))$ and $E(a(\\mathbf{x}))$ to $\\cal{A}_\\text{strong}$.\n\\end{argument}\n\n\\begin{claim}\nIf the probabilistic encryption scheme $E$ is semantically secure, the PEKS scheme is semantically secure against the chosen keyword (plaintext) attack, its trapdoor function $T$ is not invertible, and the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation, then the PNFV scheme described in Section~\\ref{sub:weak-peks} is private against $\\cal{A}_\\text{weak}$.\n\\end{claim}\n\n\\begin{argument}\nWe define the following statements:\n\\begin{itemize}\n\t\\item $D$: the PNFV scheme described in Section~\\ref{sub:weak-peks} is private against $\\cal{A}_\\text{weak}$.\n\t\\item $A_1$: the probabilistic encryption scheme $E$ is semantically secure.\n\t\\item $A_2$: the PEKS scheme is semantically secure against the chosen keyword (plaintext) attack and the trapdoor function $T$ is not invertible.\n\t\\item $A_3$: the pseudorandom permutation $\\sigma$ is indistinguishable from a random permutation.\n\\end{itemize}\nWe further refine $D$ as follows:\n\\begin{itemize}\n\t\\item $D_1$: $\\cal{A}_\\text{weak}$ does not know the tuple $(j, z)$.\n\t\\item $D_2$: $\\cal{A}_\\text{weak}$ does not know the tuple $(i, j, y)$.\n\t\\item $D_3$: $\\cal{A}_\\text{weak}$ does not know the tuple $(i, j)$.\n\\end{itemize}\nThen it follows that:\n", "index": 69, "text": "\n\\[\nD \\Leftrightarrow D_1 \\wedge D_2 \\wedge D_3.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex40.m1\" class=\"ltx_Math\" alttext=\"D\\Leftrightarrow D_{1}\\wedge D_{2}\\wedge D_{3}.\" display=\"block\"><mrow><mrow><mi>D</mi><mo>\u21d4</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>D</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>D</mi><mn>3</mn></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nor equivalently \n\n", "itemtype": "equation", "pos": 88354, "prevtext": "\nThat is, the PNFV scheme is not private if $\\cal{A}_\\text{weak}$ knows any of the aforementioned tuples. The claim states that\n", "index": 71, "text": "\n\\[\n A_1 \\wedge A_2 \\wedge A_3 \\Rightarrow D\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex41.m1\" class=\"ltx_Math\" alttext=\"A_{1}\\wedge A_{2}\\wedge A_{3}\\Rightarrow D\" display=\"block\"><mrow><mrow><msub><mi>A</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>A</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>A</mi><mn>3</mn></msub></mrow><mo>\u21d2</mo><mi>D</mi></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nIn the following, in a series of ``games'' we show that for $i, j, k \\in \\{1, 2, 3\\}$ and $i \\ne j \\ne k$,\n", "itemtype": "equation", "pos": 88419, "prevtext": "\nor equivalently \n\n", "index": 73, "text": "\\begin{equation}\n\\label{eq:log-neg}\n\\neg D \\Rightarrow \\neg A_1 \\vee \\neg A_2 \\vee \\neg  A_3 .\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\neg D\\Rightarrow\\neg A_{1}\\vee\\neg A_{2}\\vee\\neg A_{3}.\" display=\"block\"><mrow><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><mi>D</mi></mrow><mo>\u21d2</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>3</mn></msub></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nThe conjunction of the above propositions is equivalent to proposition~\\ref{eq:log-neg}, since\n\n", "itemtype": "equation", "pos": 88635, "prevtext": "\nIn the following, in a series of ``games'' we show that for $i, j, k \\in \\{1, 2, 3\\}$ and $i \\ne j \\ne k$,\n", "index": 75, "text": "\n\\[\n\\neg D_i \\wedge A_j \\wedge A_k \\Rightarrow \\neg A_i.\n\\]\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex42.m1\" class=\"ltx_Math\" alttext=\"\\neg D_{i}\\wedge A_{j}\\wedge A_{k}\\Rightarrow\\neg A_{i}.\" display=\"block\"><mrow><mrow><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><mo>\u2227</mo><msub><mi>A</mi><mi>j</mi></msub><mo>\u2227</mo><msub><mi>A</mi><mi>k</mi></msub></mrow><mo>\u21d2</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mi>i</mi></msub></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06454.tex", "nexttext": "\nwhere we have implicitly used the tautology $P \\Rightarrow Q \\Leftrightarrow \\neg P \\vee Q$. For notational convenience, we shall use $\\sigma(\\mathbf{x})$ to denote the permuted vector after the application of the permutation $\\sigma$. On the other hand, $\\sigma(x)$ shall denote the permutation of single element $x \\in \\mathbf{x}$ under $\\sigma$. We shall denote by $I$ the vector of indexes $\\{1, 2, \\ldots, n\\}$. The notation $\\mathbf{x} || I $ denotes the vector whose $l$th element is $x_l || l $. \n\n\\medskip\n\\noindent\\textit{Game 1.} Suppose $A_2$ and $A_3$ hold. Then if $\\cal{A}_\\text{weak}$ learns the tuple $(j, z)$ in the PNFV scheme, then the probabilistic encryption scheme $E$ is not semantically secure, i.e., $\\neg D_1 \\Rightarrow \\neg A_1$. \n\nWe construct an adversary $\\cal B$ that uses $\\cal{A}_\\text{weak}$ as a subroutine. $\\cal B$ issues the challenger with $z_0 || 2$ and $z_1 || 2$ as the two plaintexts it wants to be challenged on. Let $m_0 = z_0 || 2$ and $m_1 = z_1 || 2$. The challenger returns $E(m_b)$ to $\\cal{B}$ such that $b = 0$ with probability $\\frac{1}{2}$. $\\cal B$ samples two uniform random bit strings with length equal to the range of the trapdoor function $T$, and labels these values $T(y || 1)$ and $T(2)$. Note that these are not actual trapdoors, but random values (dummy trapdoors) simulating the behaviour of a non-invertible trapdoor. $\\cal {B}$ gives $E(m_b)$, $T(y || 1)$ and $T(2)$ to $\\cal{A}_\\text{weak}$. Whenever $\\cal{A}_\\text{weak}$ asks for new packet encryptions, $\\cal B$ samples a packet $\\mathbf{x}$ from the public distribution $\\cal{D}$. If $x_1 = y$ for a predetermined and fixed value of $y$, $\\cal B$ asks the $E$ oracle for $n-1$ encryptions of $x_l || l$ such that $l \\ne 1$, and an encryption of $0$ followed by the encryption of $E(m_b)' = E(0) + E(m_b)$, and constructs $E(\\mathbf{x} || I)$, such that $E(x_1 || 1) = E(m_b)'$. $\\cal{B}$ then randomly generates a permutation $\\sigma$ and permutes $E(\\mathbf{x} || I)$ obtaining $\\sigma(E(x || I))$. Note that this permutation $\\sigma$ is generated by $\\cal{B}$ itself. $\\cal{B}$ also generates $2n$ random bit strings of size equal to the range of $\\mathcal{E}$. $n$ of these values are used to simulate $\\sigma(\\mathcal{E}(\\mathbf{x} || I))$, and the other $n$ to simulate $\\sigma(\\mathcal{E}(I))$. $\\cal{B}$ gives these permuted encryptions to $\\cal{A}_\\text{weak}$. To simulate the $\\mathsf{test}$ routine, if $x_1 = y$, $\\cal B$ gives $\\sigma(1)$ and $\\sigma(2)$ to $\\cal{A}_\\text{weak}$, i.e., the permuted indexes corresponding to the match and action. $\\cal B$ further replaces $\\sigma(E(x_2 || 2))$ with $\\sigma(E(m_b))$ in $\\sigma(E(\\mathbf{x} || I))$, and gives the resultant $\\sigma(E(\\mathbf{x} || I))$ to $\\cal{A}_\\text{weak}$. Otherwise it simply gives $\\sigma(E(\\mathbf{x} || I))$ to $\\cal{A}_\\text{weak}$ (without replacing $\\sigma(E(x_2 || 2))$). When $\\cal{A}_\\text{weak}$ outputs $(j', z')$ as its guess for the policy, $\\cal{B}$ outputs $0$ if $z' = z_0$; otherwise if $z'=z_1$, $\\cal{B}$ outputs $1$. \n\n\\medskip\n\\noindent\\textit{Game 2.} Suppose $A_1$ and $A_3$ hold. Then if $\\cal{A}_\\text{weak}$ learns the tuple $(i, j, y)$ in the PNFV scheme, then the PEKS scheme is not semantically secure against the chosen keyword (plaintext) attack or the trapdoor function $T$ is invertible, i.e., $\\neg D_2 \\Rightarrow \\neg A_2$. \n\nWe show this in two sub-games. \n\n\\medskip\n\\noindent\\textit{Game 2.1.} Suppose $T$ is not invertible, then if $\\cal{A}_\\text{weak}$ learns the tuple $(y, i, j)$ in the PNFV scheme, the PEKS scheme is not semantically secure against the chosen keyword (plaintext) attack.\n\nWe consider an adversary $\\cal B$ who chooses $m_0$ and $m_1$ as two chosen keywords (plaintexts) and is given $\\mathcal{E}(m_b)$ such that $b = 0$ with probability $\\frac{1}{2}$. $\\cal B$ has to guess $b$. It can ask the challenger for further encryptions of any plaintext. $\\cal B$ is also given access to two instances of $\\mathsf{test}$ oracle; one, labelled $\\mathsf{test}_0$, instantiated with the trapdoor $T(m_b)$ and the other, labelled $\\mathsf{test}_1$, with the trapdoor $T(j)$, where $j$ is chosen by $\\cal B$. Note that $\\cal B$ is not given the trapdoor values themselves. We assume an oracle $\\cal P$ which when invoked, generates a random $\\mathbf{x}$ according to the distribution $\\cal{D}$, and outputs $\\sigma({E}(\\mathbf{x} || I))$, $\\sigma(\\mathcal{E}(\\mathbf{x} || I))$ and $\\sigma(\\mathcal{E}({I}))$, where $\\sigma({E}(\\mathbf{x} || I))$ is a vector of $n$ random bit strings each of length equal to the range of $E$ and $\\sigma$ is a (truly) random permutation. More specifically, $\\cal P$ is also given oracle access to $\\mathcal{E}$. Our adversary $\\cal B$ again uses $\\cal{A}_\\text{weak}$ for the rescue. It chooses $m_0 = y_0 ||1$ and $m_1 = y_1 || 1$ as its two chosen plaintexts. Upon receiving $\\mathcal{E}(m_b)$, it generates two random bit strings of length equal to the range of $T$. One of these simulates $T(m_b)$ and the other $T(j) = T(2)$. $\\cal B$ initializes the $\\mathsf{test}_1$ oracle with $j = 2$. $\\cal B$ also samples a bit string uniformly at random to simulate $E(z||j)$ (with length equal to the range of $E$). It gives these simulations of ${T}(m_b)$, $T(3)$ and $E(z||j)$ to $\\cal{A}_\\text{weak}$. In the testing phase, $\\cal B$ queries the $\\cal P$ oracle and obtains $\\sigma({E}(\\mathbf{x}) || I)$, $\\sigma(\\mathcal{E}(\\mathbf{x} || I))$ and $\\sigma(\\mathcal{E}({I}))$ as a result, and duly sends them to $\\cal{A}_\\text{weak}$. It also runs the $\\mathsf{test}_0$ oracle to determine if there is a match, and if yes replaces the value in $\\sigma({E}(\\mathbf{x} || I))$ corresponding to the output of the oracle $\\mathsf{test}_1$ with $E(z||j)$. When $\\cal{A}_\\text{weak}$ outputs $(i', j', y')$, $\\cal B$ outputs $b = 0$ if $y' = y_0$. Else if $y' = y_1$, $\\cal B$ outputs $b = 1$.  \n\n\\medskip\n\\noindent\\textit{Game 2.2.} Suppose the PEKS scheme is semantically secure against the chosen keyword (plaintext) attack, then  if $\\cal{A}_\\text{weak}$ learns the tuple $(i, j, y)$ in the PNFV scheme, the trapdoor function $T$ is invertible.\n\nThis is similar to above. This time, instead of $\\mathcal{E}(m_b)$, $\\cal B$ is given $T(m_b)$. Note that if $T$ is invertible, then finding $b$ is straightforward. $\\cal B$ chooses  $m_0 = y_0 ||1$ and $m_1 = y_1 || 1$ as before, and further asks for the trapdoor of $2$ and gets $T(2)$ as a result (where $j = 2$ is the instantiation of $j$). $\\cal B$ can ask for any further trapdoors pertaining to the condition that the keyword should not equal $m_0$ or $m_1$. We now also have an oracle $\\mathcal{E}$ which upon asked for the encryption of some plaintext $x$ returns a uniform random value in the range of $\\mathcal{E}$. The oracle keeps the record of the value of $\\mathcal{E}(x)$ against $x$ in a table. This oracle can also be accessed by the $\\cal P$ oracle and the $\\mathsf{test}$ oracle (we have only one $\\mathsf{test}$ oracle this time). At the end, $\\cal B$ checks the output of $\\cal{A}_\\text{weak}$ obtained as $(i', j', y')$, and returns the bit $b$ as before.\n\n\\medskip\n\\noindent\\textit{Game 3.} Suppose $A_1$ and $A_2$ hold. Then if $\\cal{A}_\\text{weak}$ learns the tuple $(i, j)$ in the PNFV scheme, then the pseudorandom permutation $\\sigma$ is distinguishable from a random permutation, i.e., $\\neg D_3 \\Rightarrow \\neg A_3$. \n\nWe assume the following challenge game between $\\cal B$ and $\\sigma$. $\\cal B$ can invoke $\\sigma$ as many times as it wants by making a call with the query `\\texttt{next}'. Each such call will be called an iteration of $\\sigma$. Note that before the first call, it is presumed that $\\sigma$ is in the identity configuration, i.e., $(1, 2, \\ldots, n)$. $\\cal B$ can choose an integer $u \\in \\{1, 2, \\ldots, n\\}$ and give it to the challenger. The challenger chooses another integer $m \\in \\{1, 2, \\ldots, n\\}$ such that $m \\ne u$, which $\\cal B$ has to guess. For each oracle call to $\\sigma$, $\\cal B$ can ask for the permutation of the fixed integer $u$ as well as $\\sigma(m)$ (i.e., the permuted value of the unknown integer $m$). $\\cal B$ has to determine $m$. Note that if $\\sigma$ is indistinguishable from a random permutation then the guess of $\\cal B$ should be no better than $\\frac{1}{n - 1}$. Suppose $\\cal B$ chooses $u = 1$. $\\cal B$ gives random values to the adversary $\\cal{A}_\\text{weak}$ to substitute ${T}(y || i)$, $T(j)$, $E(z||j)$, $\\sigma({E}(\\mathbf{x} || I))$, $\\sigma(\\mathcal{E}(\\mathbf{x} || I))$ and $\\sigma(\\mathcal{E}({I}))$, where the packet $\\mathbf{x}$ is generated by $\\cal B$ according to the public distribution $\\cal D$. Whenever $x_1 = y$, $\\cal B$ invokes $\\sigma$, and asks for $\\sigma(1)$ and $\\sigma(m)$. $\\cal B$ then replaces $\\sigma(E({x}_m || m))$ with $E(z||j)$. Whenever $\\cal{A}_\\text{weak}$ outputs $(i', j')$, $\\cal B$ outputs $m = j'$.\n\\end{argument}\n\n\n\n", "itemtype": "equation", "pos": 88790, "prevtext": "\nThe conjunction of the above propositions is equivalent to proposition~\\ref{eq:log-neg}, since\n\n", "index": 77, "text": "\\begin{align*}\n&\\bigwedge_i \\left( \\neg D_i \\wedge A_j \\wedge A_k \\Rightarrow \\neg A_i \\right) \\\\\n&\\Leftrightarrow \\bigwedge_i \\left( D_i \\vee \\neg A_j \\vee \\neg A_k \\vee \\neg A_i \\right) \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&\\Leftrightarrow \\bigwedge_i \\left( D_i \\vee \\neg A_1 \\vee \\neg A_2 \\vee \\neg A_3 \\right) \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &\\Leftrightarrow \\left(D_1 \\wedge D_2 \\wedge D_3 \\right) \\vee \\left(\\neg A_1 \\vee \\neg A_2 \\vee \\neg A_3 \\right) \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &\\Leftrightarrow D \\vee \\left(\\neg A_1 \\vee \\neg A_2 \\vee \\neg A_3 \\right) \\\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   & \\Leftrightarrow \\neg D \\Rightarrow \\neg A_1 \\vee \\neg A_2 \\vee \\neg  A_3,\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex43.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\bigwedge_{i}\\left(\\neg D_{i}\\wedge A_{j}\\wedge A_{k}\\Rightarrow%&#10;\\neg A_{i}\\right)\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mi>i</mi></munder></mstyle><mrow><mo>(</mo><mi mathvariant=\"normal\">\u00ac</mi><msub><mi>D</mi><mi>i</mi></msub><mo>\u2227</mo><msub><mi>A</mi><mi>j</mi></msub><mo>\u2227</mo><msub><mi>A</mi><mi>k</mi></msub><mo>\u21d2</mo><mi mathvariant=\"normal\">\u00ac</mi><msub><mi>A</mi><mi>i</mi></msub><mo>)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex44.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\\bigwedge_{i}\\left(D_{i}\\vee\\neg A_{j}\\vee\\neg A_{%&#10;k}\\vee\\neg A_{i}\\right)\" display=\"inline\"><mrow><mi/><mo>\u21d4</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mi>i</mi></munder></mstyle><mrow><mo>(</mo><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mi>j</mi></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mi>k</mi></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mi>i</mi></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex45.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\\bigwedge_{i}\\left(D_{i}\\vee\\neg A_{1}\\vee\\neg A_{%&#10;2}\\vee\\neg A_{3}\\right)\" display=\"inline\"><mrow><mi/><mo>\u21d4</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo><mi>i</mi></munder></mstyle><mrow><mo>(</mo><mrow><msub><mi>D</mi><mi>i</mi></msub><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>3</mn></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex46.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\\left(D_{1}\\wedge D_{2}\\wedge D_{3}\\right)\\vee%&#10;\\left(\\neg A_{1}\\vee\\neg A_{2}\\vee\\neg A_{3}\\right)\" display=\"inline\"><mrow><mi/><mo>\u21d4</mo><mrow><mrow><mo>(</mo><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>\u2227</mo><msub><mi>D</mi><mn>2</mn></msub><mo>\u2227</mo><msub><mi>D</mi><mn>3</mn></msub></mrow><mo>)</mo></mrow><mo>\u2228</mo><mrow><mo>(</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>3</mn></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex47.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow D\\vee\\left(\\neg A_{1}\\vee\\neg A_{2}\\vee\\neg A_{3}\\right)\" display=\"inline\"><mrow><mi/><mo>\u21d4</mo><mrow><mi>D</mi><mo>\u2228</mo><mrow><mo>(</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>3</mn></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex48.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\\neg D\\Rightarrow\\neg A_{1}\\vee\\neg A_{2}\\vee\\neg A%&#10;_{3},\" display=\"inline\"><mrow><mrow><mi/><mo>\u21d4</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><mi>D</mi></mrow><mo>\u21d2</mo><mrow><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>1</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>2</mn></msub></mrow><mo>\u2228</mo><mrow><mi mathvariant=\"normal\">\u00ac</mi><mo>\u2062</mo><msub><mi>A</mi><mn>3</mn></msub></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]