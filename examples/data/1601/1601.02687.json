[{"file": "1601.02687.tex", "nexttext": "\n\nA high compression rate can be achieved by covering large durations (maximize $\\Delta t_{i,j}$) with functions that require few bits to encode.\n\nIn contrast to \\textsc{Tng}, \\textsc{Xtc} and other classical algorithms \n  we introduce multiple points of information loss during compression.\nThat is, we split the total error budget $\\epsilon$ into two parts:\n  the inevitable quantization error $\\epsilon_q$, and\n  the approximation error $\\epsilon_f$.\nFor this work we use by default $\\epsilon_q = \\epsilon_f = \\frac{1}{2} \\epsilon$.\n\nExploiting the approximation error $ \\epsilon_f$ is our primary vehicle for high compression rates:\nWith $\\epsilon_f = 0$ a polynomial representing $n$ points requires $n$ support vectors.\nStoring them would be no more efficient than storing the points themselves. \nBy introducing an error $\\epsilon_f > 0$, multiple functions are valid representations of the point sequence.\nFrom this set of functions, we can select those with the fewest support vectors.\n\nIn {\\textsc{Hrtc}\\xspace}, we implicitly maintain a set of functions that are valid approximations for each dimension.\nEvery time a new point is added to the sequence,\nwe remove those functions from the set that are not valid approximations of the extended sequence.\nWe continue this process until just before adding the next point would render the candidate set empty.\nThis implements an abstract \ngreedy search for valid approximations covering the maximal timespan $\\Delta t_{i,j}$ (see Algorithm~\\ref{alg:prelim}).\n\n\\begin{algorithm}\n\\caption{Abstract algorithm using arbitrary functions for approximation}\n\\begin{algorithmic}[1]\n\\State $F \\leftarrow$ set of all approximation functions\n\\State $\\Delta t \\leftarrow 0$  \n\n\\For{$t \\in \\{0,\\dotsc,T\\}$}\n  \\State $p' \\leftarrow  p~\\text{appended by} \\lfloor  x_t / (2 \\epsilon_q) +0.5 \\rfloor$ \n      \\Comment Quantize input \n  \\State $F' \\leftarrow$ valid approximation functions for $p'$\n\n  \\If{$F' = \\emptyset$ \\text{or} $t = T$}\n    \\State output $(F, \\Delta t)$\n    \\State $p \\leftarrow (x_t)$\n    \\State $F \\leftarrow$ set of all functions\n    \\State $\\Delta t \\leftarrow 0$\n  \\Else\n    \\State $p \\leftarrow p'$\n    \\State $F \\leftarrow F'$\n    \\State $\\Delta t \\leftarrow \\Delta t + 1$\n  \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\label{alg:prelim}\n\\end{algorithm}\n\nFor general functions this algorithm is expensive in time and space:\nEven if restricted to polynomials with integer coefficients, explicitly storing all functions has exponential space complexity.\nGenerating the new function candidate set $F'$ in line 5 requires at least\n  looking at all $\\Delta t$ values, lifting the lower time bound to $\\Omega(n\\cdot \\Delta t)$.\n\nTo remain in our time budget we restrict the function space to linear functions.\nThe first support vector is the final point of the previous interval,\n  the second one at the rightmost point of the current interval. \nLinear functions allow us to store the entire candidate set $F$ using two integers,\n  and merging as well as computing the candidate set in constant time.\n\n\\begin{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx{0.3\\linewidth}\\undefined\n    \\setlength{\\unitlength}{188bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{{0.3\\linewidth}}\n  \\fi\n  \\global\\let{0.3\\linewidth}\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,1.14893617)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{illustrated_segment.eps}}\n    \\put(-0.00106383,0.63617207){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.28105956,0.79049253){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x'$}}}\n    \\put(0.52254895,0.47666274){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x''$}}}\n    \\put(0.90127231,0.30751381){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x'''$}}}\n    \\put(0.48083314,0.91523644){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$\\epsilon_f$}}}\n    \\put(0.64955347,0.63747661){\\color[rgb]{1,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot\\Delta t''$}}}\n    \\put(0.10319149,0.19574467){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.21382979,0.07659573){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$t$}}}\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:illustrated_segment}\n  Illustration of a segment used to capture a part of the trajectory:\n  The leftmost node $x$ is the left support vector of the current one.\n  Together with the error bars around each node $x' \\ldots x'''$, it induces the extremal slopes $v_{\\bot,i}, v_{\\top,i}$ (dotted lines).\n  The shaded cones cover all possible slopes for each point.\n  While successively including more points into the segment, the range of valid slopes $[v_\\bot, v_\\top]$ (red line) decreases.\n  The error cone induced by $x'''$ (shaded red) does not intersect with  $[v_\\bot, v_\\top]$ covering $x$, $x'$ and $x''$ (shaded dark-grey).\n  Thus $v_\\bot \\Delta t''$ becomes the terminal node of this segment: it is the valid point closest to $x''$.\n}\n\\end{figure}\n\nThe set of linear functions through a point $x$ that are valid approximations\n  for a second point $x'$ separated by $\\Delta t$ timesteps\n  form a $2 \\epsilon_f$~wide error cone around $x'$ (see Figure~\\ref{fig:illustrated_segment}).\nThe set is denoted by $\\mathrm{AF}$:\n\n", "itemtype": "equation", "pos": 9963, "prevtext": "\n\n\\maketitle\n\n\\begin{abstract}\nMolecular dynamics simulations yield large amounts of trajectory data.\nFor their durable storage and accessibility an efficient compression algorithm is paramount.\nState of the art domain-specific algorithms combine quantization, \\textsc{Huffman} encoding and occasionally domain knowledge.\n\nWe propose the high resolution trajectory compression scheme ({\\textsc{Hrtc}\\xspace})\n  that relies on piecewise linear functions to approximate quantized trajectories.\nBy splitting the error budget between quantization and approximation,\n  our approach beats the current state of the art by several orders of magnitude given the same error tolerance.\nIt allows storing samples at far less than one bit per sample.\nIt is simple and fast enough to be integrated into the inner simulation loop,\n  store every time step,\n  and become the primary representation of trajectory data.\n\\end{abstract}\n\n\\bibliographystyle{acm}\n\n\\section*{Introduction}\n\n\nMolecular dynamic (MD) simulations are among the largest supercomputer uses.\nComputing power increases exponentially faster than communication bandwidth.\\cite{Esmaeilzadeh2011}\nTo retain the ability to durably store, share and even analyze the generated particle trajectories,\n  they have to be represented efficiently.\n\n\nFor example, a recent atomistic model of the SGLT membrane protein,\n  consisting of 90.000 particles simulated for $2.4 \\times 10^8$ steps ($\\SI{480}{ns}$)\n  generates $\\SI{259}{TiB}$ of raw trajectory data.\\cite{Adelman2014}\nThe \\textit{de-facto} standard approach to handle such large datasets at all,\n  is to down-sample the time-domain of the trajectory to a tiny fraction---in\n  said example by saving only \\nicefrac{1}{50000} of the steps,\n  except for a few spotlight situations where \\nicefrac{1}{500} of all timesteps are saved.\n\n\nTypically, the down-sampled trajectories are then further compressed.\nIn principle, this is possible using a general purpose lossless compression algorithm, e.g. \\textsc{BZip2}.\nUnfortunately, general purpose compression suffers from incompressible noise in the less significant bits of the particle positions.\nThey can at most be considered as base line to compare better algorithms against.\n\n\nMD trajectories are highly amendable to special-purpose compression:\nThe interframe variation of the particle positions is orders of magnitudes smaller than the positions themself ($\\Delta x \\ll x$).\nThe demanded precision is typically much smaller than the precision offered by uncompressed representation ($\\SI{32}{b}$ or $\\SI{64}{b}$ in IEEE 754).\nPositions as well as velocities are strongly correlated with values from the past and neighboring particles.\n\nFurthermore, MD trajectory compression has special requirements not fulfilled by general-purpose algorithms.\nFor details, see \\textsc{Marais} et al.\\cite{Marais2012} and especially \\textsc{Sp\u00c3\u00a5ngberg} et al.\\cite{Spangberg2011}\nWe concentrate on three aspects:\n\\begin{itemize}\n\\item \\emph{Speed}: \n  (de-)compression overhead has to be insignificant compared to the simulation itself to be of any use.\n  The simulator itself is a space-optimal compressor, requiring only the initial state and the elapsed time to be stored.\n  Corollary it has to be\n    \\emph{parallelizable},\n    computable in a \\emph{streaming} fashion,\n    have a \\emph{small memory footprint}, and\n    elide random writes to the underlying storage.\n\\item \\emph{Tunability}:\n  The tolerable error of lossy compression is highly dependent on the simulated scenario and intended analysis.\n  A tunable precision and good performance across all values is thus required.\n\\item \\emph{Simplicity}:\n  Complex code fits neither into processor caches nor into programmer minds.\n  It is thus prone to be slow, faulty and not widely implemented.\n\\end{itemize}\n\n\nWith the advent of large datasets, a number of compression schemes have been proposed.\nMost of them are a combination of the following building blocks:\n\\begin{itemize}\n\\item Quantization:\n  the lossy reduction to represent floating point numbers as small integers ($x \\mapsto \\lfloor 2 x / \\epsilon_q +0.5 \\rfloor$).\n  The quantization error $\\epsilon_q$ is a paramount tunable of these algorithms.\n\\item Delta-coding:\n  storing the difference of consecutive values instead of the values itself\n    ($x_0, x_1, x_2, \\dots \\mapsto x_0, x_1 - x_0, x_2 - x_1, \\dotsc$).\n\\item Reordering\n  particle coordinates, so that their consecutive differences are likely to be small.\n  This comes often at a loss of the particle identities:\n    particles of the same element become indistinguishable.\n\\item Variable-length integer encoding\n  to store the frequent small integers with few bits without sacrificing the possibility to store rare large values.\n  This is typically achieved using\n    \\nth{0} order encoders, which are faster but rely on a fixed distribution of values (e.g., rice coding), or\n    \\nth{1} order encoders, which adapt to the observed distribution to increase the compression rate\n      at the price of higher space and time complexity (e.g., \\textsc{Huffman} coding).\n\\end{itemize}\nAll of these techniques have in common that they try to spend less bits per data-point,\n  but keep the number of data-points constant.\nThey thus fail to achieve less than one bit per sample.\n\n\n\\textsc{Sp\u00c3\u00a5ngberg} et al.~proposes \\textsc{Tng-Mf1}\\cite{Spangberg2011}, a class of algorithms that use\n  quantization,\n  delta-coding within and between frames,\n  a custom \\nth{0} order variable length integer compression, and\n  optionally a combination of \\textsc{Burrow-Wheeler} transformation\\cite{Burrows1994},\n    \\textsc{Lempel-Ziv} coding\\cite{Lempel1977}, and \\textsc{Huffman} coding.\\cite{Huffman1952}\n\\textsc{Marais} et al.\\cite{Marais2012}~use\n  quantization,\n  an arithmetic encoder, and\n  interframe prediction with polynomials of order zero or one.\nAdditionally they use \\textit{a~priori} knowledge about the spatial structure of water\n  to exploit redundancy in adjacent water molecules position and orientation.\nThe venerable \\textsc{Xtc} file format uses\n  quantization,\n  delta-coding between frames,\n  reordering of coordinates to improve compression of water molecules, and\n  a custom variable-length integer encoding.\\cite{Abraham2015}\n\n\nA completely different approach is realized with the Essential Dynamics tool,\nwhich stores particle motions relative to a reference structure in a matrix.\nThe matrix' eigenvectors with the largest eigenvalues are used as a compressed base:\na weighted sum of them represents each frame.\\cite{Meyer2006}\n\\textsc{Ohtani} et al.~represent trajectories by polynomial functions.\\cite{Ohtani2013}\nA time window for consecutive frames is decreased until a polynomial function fits the data within the given error.\nBoth methods do not support streaming operation and have large time and space overhead.\n\nFor more examples, see \\textsc{Marais et al.}\\cite{Marais2012} \n\n\nA related field to MD trajectory compression is the efficient storage of space curves used for geoinformation systems.\nThese algorithms do not store time information, work offline on the entire dataset, and are allowed superlinear runtimes.\nThe prime example is the \\textsc{Douglas-Peucker} algorithm that iteratively removes points from a curve,\n  as long as they lie within an error corridor between their neighbors.\\cite{douglas1973algorithms}\n\\textsc{Bellman}'s algorithm even finds the optimal (minimal error) cover of $n$~points with $k$~lines,\n  but requires $O(n^2)$ time to do so.\\cite{bellman1961approximation}\n\n\nThe high resolution trajectory compression algorithm ({\\textsc{Hrtc}\\xspace}) presented here follows a similar, yet faster and simpler approach:\nAkin to delta-coding, piecewise linear functions are employed to represent trajectories.\nThe resulting support vectors are\n  quantized with a tunable precision and\n  stored using state-of-the-art variable length integer representation.\nBesides having the highest compression rates and performance,\nour main novelty is the distribution of the error budget between the quantization and the approximation by functions.\nEstablished approaches allow either quantization error\\cite{Marais2012,Spangberg2011,Abraham2015},\n  or approximation error\\cite{Ohtani2013}, but not both at the same time.\n\nComparing our algorithm to the state of the art is difficult:\nCrucial simulation parameters are not well documented and\n  a common standard for storing trajectory data needs to be established.\\cite{Hinsen2014}\nFor this purpose we heavily rely on the container-based file format\n  proposed by \\textsc{Lundborg} et al.:\\cite{Lundborg2014}\nIt allows trajectory storage alongside with parameter values and arbitrary metadata in a single file.\nIt enables usage of different compression algorithms,\ninitially equipped with the option to use \\textsc{Xtc}, \\textsc{Tng} and \\textsc{BZip2}.\nBoth the file format and the code are open source and open to extension.\nWe followed this invitation and modified the \\textsc{Tng} library to support our {\\textsc{Hrtc}\\xspace} compression scheme.\n\n\\section*{Methodology}\n\n\nThe {\\textsc{Hrtc}\\xspace} algorithm we present here uses piecewise linear functions to represent trajectories.\nWe consider only particle positions---noting that for most applications the slope of the approximating function can be used as velocity.\nGiven $n$ particles in a $d$-dimensional space, we consider each dimension $k \\in \\{1, \\dotsc, n d\\}$ of a state independently.\nFor each dimension $k$, our algorithm approximates the\n  $T$ points $(x_{k,t})$ of a trajectory by\n  $J(k)$ functions $f_{k,j} : \\{1, \\dotsc, \\Delta t_{k,j}\\} \\rightarrow \\{\\frac{1}{2} z \\epsilon_q : z \\in \\mathbb{Z}\\}$ where\n  $\\epsilon_q$ is the quantization error, and\n  $\\Delta t_{k,j}$ is the number of timesteps the function $f_{k,j}$ is covering, with\n  $j \\in \\{ 1, \\dotsc, J\\}$,\n  $t \\in \\{ 1, \\dotsc, T \\}$.\nWith a given (maximal) approximation error $\\epsilon_f$, our approximation scheme\nbecomes:\n\n", "index": 1, "text": "\\begin{align}\nx_{k,1}, \\dotsc, x_{k,T} \\rightsquigarrow f_{k,1}, \\dotsc, f_{k,J(k)} ~,\\\\\n|x_{k,t} - f_{k,j}(t - \\sum_{l<j} \\Delta t_{k,l})| \\le \\epsilon_f ~,\\\\\n\\sum_{l<j} \\Delta t_{k,l} < t  \\le \\sum_{l<j+1} \\Delta t_{k,l} ~.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{k,1},\\ldots,x_{k,T}\\rightsquigarrow f_{k,1},\\ldots,f_{k,J(k)}%&#10;~{},\" display=\"inline\"><mrow><mrow><mrow><mrow><msub><mi>x</mi><mrow><mi>k</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>,</mo><mi>T</mi></mrow></msub></mrow><mo>\u219d</mo><msub><mi>f</mi><mrow><mi>k</mi><mo>,</mo><mn>1</mn></mrow></msub></mrow><mo>,</mo><mrow><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mpadded width=\"+3.3pt\"><msub><mi>f</mi><mrow><mi>k</mi><mo>,</mo><mrow><mi>J</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msub></mpadded></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle|x_{k,t}-f_{k,j}(t-\\sum_{l&lt;j}\\Delta t_{k,l})|\\leq\\epsilon_{f}~{},\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>x</mi><mrow><mi>k</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>-</mo><mrow><msub><mi>f</mi><mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>t</mi><mo>-</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>l</mi><mo>&lt;</mo><mi>j</mi></mrow></munder></mstyle><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo stretchy=\"false\">|</mo></mrow><mo>\u2264</mo><mpadded width=\"+3.3pt\"><msub><mi>\u03f5</mi><mi>f</mi></msub></mpadded></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{l&lt;j}\\Delta t_{k,l}&lt;t\\leq\\sum_{l&lt;j+1}\\Delta t_{k,l}~{}.\" display=\"inline\"><mrow><mrow><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>l</mi><mo>&lt;</mo><mi>j</mi></mrow></munder></mstyle><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>t</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow></mrow><mo>&lt;</mo><mi>t</mi><mo>\u2264</mo><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>l</mi><mo>&lt;</mo><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></mrow></munder></mstyle><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><msub><mi>t</mi><mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub></mpadded></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\nThe set of functions is completely represented by $x$, $v_\\bot$, and $v_\\top$.\nThe intersection of multiple such sets\n  that share a common support vector $x$ but differ in extremal slopes $v_{\\bot,i}$ and $v_{\\top,i}$\n  can be merged efficiently:\n\n", "itemtype": "equation", "pos": 15939, "prevtext": "\n\nA high compression rate can be achieved by covering large durations (maximize $\\Delta t_{i,j}$) with functions that require few bits to encode.\n\nIn contrast to \\textsc{Tng}, \\textsc{Xtc} and other classical algorithms \n  we introduce multiple points of information loss during compression.\nThat is, we split the total error budget $\\epsilon$ into two parts:\n  the inevitable quantization error $\\epsilon_q$, and\n  the approximation error $\\epsilon_f$.\nFor this work we use by default $\\epsilon_q = \\epsilon_f = \\frac{1}{2} \\epsilon$.\n\nExploiting the approximation error $ \\epsilon_f$ is our primary vehicle for high compression rates:\nWith $\\epsilon_f = 0$ a polynomial representing $n$ points requires $n$ support vectors.\nStoring them would be no more efficient than storing the points themselves. \nBy introducing an error $\\epsilon_f > 0$, multiple functions are valid representations of the point sequence.\nFrom this set of functions, we can select those with the fewest support vectors.\n\nIn {\\textsc{Hrtc}\\xspace}, we implicitly maintain a set of functions that are valid approximations for each dimension.\nEvery time a new point is added to the sequence,\nwe remove those functions from the set that are not valid approximations of the extended sequence.\nWe continue this process until just before adding the next point would render the candidate set empty.\nThis implements an abstract \ngreedy search for valid approximations covering the maximal timespan $\\Delta t_{i,j}$ (see Algorithm~\\ref{alg:prelim}).\n\n\\begin{algorithm}\n\\caption{Abstract algorithm using arbitrary functions for approximation}\n\\begin{algorithmic}[1]\n\\State $F \\leftarrow$ set of all approximation functions\n\\State $\\Delta t \\leftarrow 0$  \n\n\\For{$t \\in \\{0,\\dotsc,T\\}$}\n  \\State $p' \\leftarrow  p~\\text{appended by} \\lfloor  x_t / (2 \\epsilon_q) +0.5 \\rfloor$ \n      \\Comment Quantize input \n  \\State $F' \\leftarrow$ valid approximation functions for $p'$\n\n  \\If{$F' = \\emptyset$ \\text{or} $t = T$}\n    \\State output $(F, \\Delta t)$\n    \\State $p \\leftarrow (x_t)$\n    \\State $F \\leftarrow$ set of all functions\n    \\State $\\Delta t \\leftarrow 0$\n  \\Else\n    \\State $p \\leftarrow p'$\n    \\State $F \\leftarrow F'$\n    \\State $\\Delta t \\leftarrow \\Delta t + 1$\n  \\EndIf\n\\EndFor\n\\end{algorithmic}\n\\label{alg:prelim}\n\\end{algorithm}\n\nFor general functions this algorithm is expensive in time and space:\nEven if restricted to polynomials with integer coefficients, explicitly storing all functions has exponential space complexity.\nGenerating the new function candidate set $F'$ in line 5 requires at least\n  looking at all $\\Delta t$ values, lifting the lower time bound to $\\Omega(n\\cdot \\Delta t)$.\n\nTo remain in our time budget we restrict the function space to linear functions.\nThe first support vector is the final point of the previous interval,\n  the second one at the rightmost point of the current interval. \nLinear functions allow us to store the entire candidate set $F$ using two integers,\n  and merging as well as computing the candidate set in constant time.\n\n\\begin{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx{0.3\\linewidth}\\undefined\n    \\setlength{\\unitlength}{188bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{{0.3\\linewidth}}\n  \\fi\n  \\global\\let{0.3\\linewidth}\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,1.14893617)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{illustrated_segment.eps}}\n    \\put(-0.00106383,0.63617207){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.28105956,0.79049253){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x'$}}}\n    \\put(0.52254895,0.47666274){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x''$}}}\n    \\put(0.90127231,0.30751381){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x'''$}}}\n    \\put(0.48083314,0.91523644){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$\\epsilon_f$}}}\n    \\put(0.64955347,0.63747661){\\color[rgb]{1,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot\\Delta t''$}}}\n    \\put(0.10319149,0.19574467){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.21382979,0.07659573){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$t$}}}\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:illustrated_segment}\n  Illustration of a segment used to capture a part of the trajectory:\n  The leftmost node $x$ is the left support vector of the current one.\n  Together with the error bars around each node $x' \\ldots x'''$, it induces the extremal slopes $v_{\\bot,i}, v_{\\top,i}$ (dotted lines).\n  The shaded cones cover all possible slopes for each point.\n  While successively including more points into the segment, the range of valid slopes $[v_\\bot, v_\\top]$ (red line) decreases.\n  The error cone induced by $x'''$ (shaded red) does not intersect with  $[v_\\bot, v_\\top]$ covering $x$, $x'$ and $x''$ (shaded dark-grey).\n  Thus $v_\\bot \\Delta t''$ becomes the terminal node of this segment: it is the valid point closest to $x''$.\n}\n\\end{figure}\n\nThe set of linear functions through a point $x$ that are valid approximations\n  for a second point $x'$ separated by $\\Delta t$ timesteps\n  form a $2 \\epsilon_f$~wide error cone around $x'$ (see Figure~\\ref{fig:illustrated_segment}).\nThe set is denoted by $\\mathrm{AF}$:\n\n", "index": 3, "text": "\\begin{align}\n  & \\{ f : f(0) = x \\wedge | f(\\Delta t) - x' | \\le \\epsilon_f  \\} \\nonumber \\\\\n  \\supseteq & \\{ t \\mapsto \\frac{t}{\\Delta t} v  + x : v \\in [v_\\bot, v_\\top] \\} \\\\\n  =: & \\mathrm{AF}(v_\\bot, v_\\top) \\quad \\text{with} ~\n    v_\\bot = \\frac{x' - x - \\epsilon_f}{\\Delta t},\\;\n    v_\\top = \\frac{x' - x + \\epsilon_f}{\\Delta t} ~.\n\\nonumber\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{f:f(0)=x\\wedge|f(\\Delta t)-x^{\\prime}|\\leq\\epsilon_{f}\\}\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mi>f</mi><mo>:</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mi>x</mi><mo>\u2227</mo><mo stretchy=\"false\">|</mo><mi>f</mi><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">\u0394</mi><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><mo>-</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo stretchy=\"false\">|</mo><mo>\u2264</mo><msub><mi>\u03f5</mi><mi>f</mi></msub><mo stretchy=\"false\">}</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\supseteq\" display=\"inline\"><mo>\u2287</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{t\\mapsto\\frac{t}{\\Delta t}v+x:v\\in[v_{\\bot},v_{\\top}]\\}\" display=\"inline\"><mrow><mi mathvariant=\"normal\">{</mi><mi>t</mi><mo>\u21a6</mo><mstyle displaystyle=\"true\"><mfrac><mi>t</mi><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mi>v</mi><mo>+</mo><mi>x</mi><mo>:</mo><mi>v</mi><mo>\u2208</mo><mrow><mo stretchy=\"false\">[</mo><msub><mi>v</mi><mo>\u22a5</mo></msub><mo>,</mo><msub><mi>v</mi><mo>\u22a4</mo></msub><mo stretchy=\"false\">]</mo></mrow><mo stretchy=\"false\">}</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle=:\" display=\"inline\"><mrow><mi/><mo>=</mo><mo>:</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\mathrm{AF}(v_{\\bot},v_{\\top})\\quad\\text{with}~{}v_{\\bot}=\\frac{x%&#10;^{\\prime}-x-\\epsilon_{f}}{\\Delta t},\\;v_{\\top}=\\frac{x^{\\prime}-x+\\epsilon_{f}%&#10;}{\\Delta t}~{}.\" display=\"inline\"><mrow><mrow><mrow><mrow><mrow><mi>AF</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mo>\u22a5</mo></msub><mo>,</mo><msub><mi>v</mi><mo>\u22a4</mo></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo mathvariant=\"italic\" separator=\"true\">\u2003</mo><mrow><mpadded width=\"+3.3pt\"><mtext>with</mtext></mpadded><mo>\u2062</mo><msub><mi>v</mi><mo>\u22a5</mo></msub></mrow></mrow><mo>=</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow><mo rspace=\"5.3pt\">,</mo><mrow><msub><mi>v</mi><mo>\u22a4</mo></msub><mo>=</mo><mpadded width=\"+3.3pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\nThis intersection contains all valid approximations for \\emph{all} input points.\nNote that the intersection is empty if the lower bound $v_\\bot$ becomes larger\nthan the upper bound $ v_\\top$, that is,  $AF(x, v_\\bot, v_\\top) = \\emptyset$ iff.~$v_\\bot > v_\\top$.\nThe above formulation allows to incrementally update the function candidate set.\nThe sequence of points of the current interval does not have to be stored anymore.\n\n\\subsection*{Combined storage of multiple trajectories}\n\n\nA single trajectory can be stored \nin memory as a sequence $(v_0, \\Delta t_0), (v_1, \\Delta t_1), \\dotsc$\nWhen storing multiple trajectories, we have to counter the issue that their support vectors are not synchronized in time.\nA naive approach would include a trajectory index $k_l$ for each support vector:\n  $(k_1, v_{k_1}, \\Delta t_{k_1}), (k_2, v_{k_2}, \\Delta t_{k_2}), \\dotsc$.\nHowever, this would require $O(\\log n d)$ additional space per support vector, which we avoid with the following procedure.\n\n\nWe exploit the fact that the start time and duration of a segment imply the time at which the next support vector has to be expected.\nTo use this insight, we maintain an auxiliary priority queue $Q_\\mathrm{expected}$, which\nstores tuples $(t, k)$ sorted by time $t$ and secondarily trajectory index $k$.\nThe minimal element of the queue denotes the support vector to be outputted next.\nThe queue always contains $nd$ elements,\n  thus the space gain is traded against an additional time complexity of $O(\\log nd)$ per inserted interval.\n\nTo reorder the support vectors from the sequence of discovery to the sequence of storage described above,\n  we use a second priority queue $Q_\\mathrm{known}$.\nIt stores all support vectors that can not be stored immediately because a preceding support vector (according to $Q_\\mathrm{expected}$) is not yet known.\nIt contains up to $O(nd \\max_i \\Delta t_i)$ elements.\nThis implies a memory overhead of the same magnitude in the compressor.\nThe time overhead can be reduced to $O(nd)$ assuming time points are dense--if\n  the number of support vectors of all trajectories exceeds the number of time points.\nDue to the blockwise compression and limited $\\Delta t$ observed,\n  this overhead is much less dramatic in practice.\n\n\nA key frame is used to initialize the queue and to provide the initial support vectors for each dimension.\nThe key frame stores the quantized values of $x_{0,0}, x_{1,0}, \\dotsc$ with a fixed bit count, without further compression.\nThe number of bits $\\lceil log \\frac{L}{2 \\epsilon_q} \\rceil$ is determined by\n  the quantization granularity $\\epsilon_q$ and\n  the edge length $L$ of the bounding box of the trajectory. \n\n\\subsection*{Hierarchy of computation and storage}\n\n\\begin{figure}\n\\includegraphics[width=\\linewidth]{storage_hierarchy.eps}\n\\caption{\\label{fig:storage_hierarchy}\n  Hierarchical storage of MD simulation generated data.\n  Top row denotes data, bottom row code. Each block starts with a key frame.\n  A high-performance implementation typically integrates all lower boxes.}\n\\end{figure}\n\n\nThe {\\textsc{Hrtc}\\xspace} algorithm has to conciliate between two opposing forces:\nMemory pressure and data cache locality demand to minimize the window of trajectory data held in memory during compression.\nHigher compression rates require a larger timespan of data to reason about.\nTo minimize cache thrashing, switching between simulation and compression should happen at a low frequency---asking\n  for a large window, too.\nAt last, to generate a searchable compressed data-stream, key frames have to be inserted at regular time intervals.\n\n\nBalancing these demands has led to the following hierarchy of computation and storage (cf.~Figure~\\ref{fig:storage_hierarchy}):\nAn MD simulator calls the compression library for each generated timestep---denoted a \\emph{frame}.\nThe data is approximated with linear functions, their resulting support vectors are buffered.\nOnce a threshold buffer size is reached (e.g., $\\SI{8}{KB}$ storing $1024$ support vectors),\n  all support vectors are fed through the variable length integer encoding,\n  yielding one \\emph{chunk}.\nThe largest unit---a \\emph{block}---contains a user-specified number of frames.\nIt starts with a single key frame and contains all chunks belonging to the encoded frames.\nThe block size is tuned by the user depending on the desired compression and seek time.\n\n\nThe {\\textsc{Hrtc}\\xspace} compression integrated into the \\textsc{Tng} library does not fully exploit this hierarchy.\nDue to design constraints of the \\textsc{Tng} library,\n  all frames of a block are collected and then compressed at once.\nWhen speed matters, {\\textsc{Hrtc}\\xspace} could be used directly.\n\nThe update compression algorithm, together with storage hierarchy and multiple trajectory storage\nare described by Algorithm~\\ref{alg:alg}. The respective decompression is described by Algorithm~\\ref{alg:sffam-large-hier}.\n\n\\begin{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx{\\linewidth}\\undefined\n    \\setlength{\\unitlength}{13.67213593bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{{\\linewidth}}\n  \\fi\n  \\global\\let{\\linewidth}\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,0.48424785)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{PS_combined.eps}}\n    \\put(0.01561113,0.23253111){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$p_k$}}}\n    \\put(0.29647433,0.17986923){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x_{k,t}$}}}\n    \\put(0.29647433,0.15061264){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$q$}}}\n    \\put(0.11702634,0.15213424){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_k$}}}\n    \\put(0.09167825,0.23898743){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top$}}}\n    \\put(0.08582693,0.10557742){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot$}}}\n    \\put(0.20870457,0.09650787){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot'$}}}\n    \\put(0.20870457,0.22377402){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top'$}}}\n    \\put(0.52432464,0.23253111){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$p_k$}}}\n    \\put(0.92221415,0.36711137){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x_{k,t+1}$}}}\n    \\put(0.92221415,0.39636795){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$q$}}}\n    \\put(0.71741806,0.18691072){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_k$}}}\n    \\put(0.7174339,0.2214335){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top$}}}\n    \\put(0.7174339,0.1357117){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot$}}}\n    \\put(0.83446024,0.27444642){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot'$}}}\n    \\put(0.83446024,0.17111217){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top'$}}}\n    \\put(0.88606434,0.05283901){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.9351291,0.00000004){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$t$}}}\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:pseudocode_segement}\n  Illustration of the variables used during compression for each dimension $k$ as used in algorithm~\\ref{alg:alg}.\n  Shown are two cases: A point to be added either extends the segment (a),\n    or causes termination of the segment at the previous point (b).\n  The input $x_{k,t}$ is shown as circle, the quantized values as square.\n  Four variables are stored per dimension:\n    $p_k$ denotes the quantized support vector starting the segment,\n    $v_k$ the slope to the last point added, and\n    $v_\\bot$ and $v_\\top$ the lower and upper slope bounds.\n  In addition, three temporary variables are used:\n    the quantized input value $q$, and\n    the updated slope bounds $v_\\bot'$ and $v_\\top'$.}\n\\end{figure}\n\n\\begin{algorithm}\n\\caption{The {\\textsc{Hrtc}\\xspace} compression algorithm. For an illustration of the variables used, see Figure~\\ref{fig:pseudocode_segement}.}\n\\begin{algorithmic}[1]\n\\State \\textbf{Input:} Trajectory $(x_{t,k})$ for $t \\in \\{0, \\dots, T\\}, k \\in \\{1, \\dots, nd \\}$, quantization error $\\epsilon_q$, approximation error $\\epsilon_f$\n\\State \\textbf{Output:} Compressed trajectory (incl. key frames)\n\\State \\textbf{global} $v_{\\bot,k}$, $v_{\\top,k}$, $v_k$, $p_k$, $\\Delta t_k$ for $k \\in \\{1, \\dots, nd \\}$ \\Comment current approximation\n\\State \\textbf{global} $q$ \\Comment current quantized input $x_{t,k}$  \n\\State \\textbf{global} outputBuf $= ()$\n\\State \\textbf{global} $Q_\\mathrm{known} \\leftarrow \\emptyset$,\n       $Q_\\mathrm{expected} \\leftarrow \\emptyset$\n\\Statex\n\\For{$t \\in \\{0, \\dotsc, T\\}$}                              \\Comment For each input frame\n  \\State \\Call{DrainQueue}{}                                \\Comment Move expected known segments to output buffer\n\n  \\If{$t ~\\mathrm{mod}~ \\mathrm{blockSize} = 0$}\n    \\Comment ENCODE KEY FRAME\n    \\While{$Q_\\mathrm{expected} \\ne \\emptyset$}              \\Comment While there are segments to end\n      \\State $(t', k) \\leftarrow \\min(Q_\\mathrm{expected})$ \\Comment Get time and dimension of next segment\n      \\State \\Call{FlushSegment}{t', k}                    \\Comment End this segment and push it into $Q_\\mathrm{known}$ \n    \\EndWhile\n    \\State \\Call{DrainQueue}{} \\Comment Move $Q_\\mathrm{known}$ (known segments) to output buffer\n    \\State \\Call{FlushChunk}{}                             \\Comment Compress output buffer and output it \n    \\State $Q_\\mathrm{expected} \\leftarrow \\{(t,0), \\dotsc, (t, nd-1)\\}$   \\Comment Initialize  $Q_\\mathrm{expected}$ with current time \n    \\For{$k \\in \\{1, \\dotsc nd\\}$}                                        \\Comment For each dimension $k$:\n      \\State $p_k \\leftarrow \\lfloor  x_{t,k} / (2 \\epsilon_q) + 0.5 \\rfloor$  \\Comment get the next input, quantize and remember it as $p_k$,\n      \\State output $p_k$                                                  \\Comment and output it (for the key frame).\n      \\State $v_{\\bot,k} = -\\infty$, $v_{\\top,k} = \\infty$    \\Comment initialize empty segment\n      \\State $\\Delta t_k \\leftarrow 0$                           \n    \\EndFor\n  \\Else \\Comment ENCODE SEGMENTS \n    \\For{$k \\in \\{1, \\dotsc nd\\}$} \\Comment for each dimension $k$\n      \\State $q \\leftarrow \\lfloor  x_{t,k} / (2 \\epsilon_q) + 0.5 \\rfloor$ \\Comment quantize next input \n      \\State $v_\\top' \\leftarrow \\min(v_{\\top,k}, (q -  p_k + \\epsilon_f)/\\Delta t_k)$ \\Comment Computer lower and upper bound \n      \\State $v_\\bot' \\leftarrow \\max(v_{\\bot,k}, (q -  p_k - \\epsilon_f)/\\Delta t_k)$ \\Comment of the approximating functions.\n      \\If{$v_\\top' < v_\\bot'$}   \\Comment If no valid approximating function remains\n       \\State \\Call{FlushSegment}{t, k}  \\Comment terminate current segment with previous point.\n      \\Else\n        \\State $v_{\\bot,k} \\leftarrow v_\\bot'$, $v_{\\top,k} \\leftarrow v_\\top'$ \\Comment Update current approximation\n        \\State $v_k \\leftarrow (q -  p_k) / \\Delta t_k$ \n        \\State $\\Delta t_k \\leftarrow \\Delta t_k + 1$\n      \\EndIf\n    \\EndFor\n  \\EndIf\n\\EndFor\n\\algstore{algcomp}\n\\end{algorithmic}\n\\label{alg:alg}\n\\end{algorithm}\n\n\n\n\n\n\\begin{algorithm}\n\\begin{algorithmic}[1]\n\\algrestore{algcomp}\n\\Function{FlushSegment}{t, k}\n  \\State \\(\\Delta q \\leftarrow \\left\\{ \\begin{array}{ll}\n    \\Delta t_k v_{\\bot,k} & \\mathrm{if}\\: v_k < v_{\\bot,k} \\\\\n    \\Delta t_k v_k & \\mathrm{if}\\: v_k \\in [v_{\\bot,k}, v_{\\top,k}] \\\\\n    \\Delta t_k v_{\\top,k} & \\mathrm{if}\\: v_k > v_{\\top,k} \\end{array}\\right.\\)  \\Comment Choose support vector closest to prev. point.\n  \\State insert $(t - \\Delta t_k, k, \\Delta t_k, \\Delta q)$ into $Q_\\mathrm{known}$ \\Comment Insert support vector to $Q_\\mathrm{known}$, \n  \\Statex \\Comment which is sorted by $(t - \\Delta t_k, k)$.\n  \\State $\\Delta t_k \\leftarrow 1$  \\Comment Initialize next segment duration with 1\n  \\State $v_{\\bot,k} \\leftarrow q - p_k - \\epsilon_f$ \\Comment Reset upper and lower bounds\n  \\State $v_{\\top,k} \\leftarrow q - p_k + \\epsilon_f$\n  \\State $p_k \\leftarrow p_k + \\Delta q$  \\Comment Set starting point of next segment \n  \\Statex \\Comment to terminal point of current segment.\n\\EndFunction\n\\Statex\n\\Function{FlushChunk}{}\n  \\State compress outputBuf using \\textsc{VSE-R}, output result\n  \\State outputBuf $\\leftarrow ()$\n\\EndFunction\n\\Statex\n\\Function{DrainQueue}{$Q_\\mathrm{known}, Q_\\mathrm{expected}, \\mathrm{outputBuf}$}\n  \\While {$\\min(Q_\\mathrm{expected}) \\overset{t,k}{=} \\min(Q_\\mathrm{known})$}\n    \\Comment While next segment is known\n    \\State $(t, k, \\Delta t, \\Delta q) \\leftarrow \\mathrm{extractMin}(Q_\\mathrm{known})$ \\Comment Get next known segment\n    \\State $\\mathrm{extractMin}(Q_\\mathrm{expected})$ \\Comment Update the expected start time \n    \\State insert $(t+\\Delta t, k)$ into $Q_\\mathrm{expected}$ \n    \\State $\\mathrm{outputBuf} \\leftarrow (\\Delta q, \\mathrm{outputBuf}, \\Delta t)$ \\Comment Append segment to output buffer \n \\Statex \\Comment (see section ``chunk encoding'')\n    \\If{length of outputBuf $\\ge 2 \\cdot \\mathrm{chunkLength}$}  \\Comment If chunk is full.\n      \\State \\Call{FlushChunk}{} \\Comment compress and output chunk.\n    \\EndIf\n  \\EndWhile\n\\EndFunction\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{algorithm}\n\\caption{The {\\textsc{Hrtc}\\xspace} \\textbf{de}compression algorithm.\n  The handling of chunks for integer compression has been omitted for brevity---it is implied in line 11.}\n\\label{alg:sffam-large-hier}\n\\begin{algorithmic}[1]\n\\State \\textbf{Input:} Compressed trajectory (incl. key frames)\n\\State \\textbf{Output:} Uncompressed trajectory $(x_{t,k})$\n\\For{$t \\in \\{0, \\ldots, T\\}$}\n  \\If{$t ~\\mathrm{mod}~ \\mathrm{blockSize} = 0$} \\Comment decode key frame\n    \\For{$k \\in \\{1, \\dotsc nd\\}$}\n      \\State read $q$\n      \\State $p_k \\leftarrow q \\epsilon_q$, $t_k \\leftarrow t, v_k \\leftarrow 0 ,\\Delta t_k \\leftarrow 0$ \n                                                    \\Comment Set starting point of segment\n    \\EndFor\n    \\State $Q_\\mathrm{expected} \\leftarrow \\{(t,1), \\dotsc, (t, nd)\\}$ \\Comment Initialize $Q_\\mathrm{expected}$ with current time\n  \\EndIf\n  \\While{$t \\overset{t}{=} \\min(Q_\\mathrm{expected})$} \\Comment For all segments starting at $t$\n    \\State $(t, k) \\leftarrow \\mathrm{extractMin}(Q_\\mathrm{expected})$ \\Comment Get dimension of next segment\n    \\State read $(d, q)$ using \\textsc{VSE-R} decompression \\Comment Get its duration and support vector\n    \\State $p_k \\leftarrow p_k + \\Delta t_k v_k$ \\Comment Compute starting point\n    \\State $v_k \\leftarrow q \\epsilon_q/d$ \\Comment Compute slope of segment\n    \\State $t_k \\leftarrow t$ \\Comment Update time of segment\n    \\State $\\Delta t_k \\leftarrow d$ \\Comment Duration of segment \n    \\State insert $(t + d, k)$ into $Q_\\mathrm{expected}$ \\Comment Update expected time for next segment\n  \\EndWhile\n  \\For{$k \\in \\{1, \\dotsc nd\\}$} \\Comment Interpolate current frame\n    \\State output $x_{t,k} \\leftarrow p_k + (t - t_k) v_k$ \\Comment and output it. \n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\\subsection*{Integer compression and chunk encoding}\n\nFor variable-length integer encoding, we use the \\textsc{Integer Encoding Library}.\\cite{integer-encoding}\nIt offers several codecs.\nAfter selecting for time and speed, we chose the codec \\textsc{VSE-R}.\\cite{silvestri2010vsencoding}\nThe library only encodes unsigned integers.\nWhere signed integers occur in our algorithm they are mapped to unsigneds:\n\n", "itemtype": "equation", "pos": 16548, "prevtext": "\nThe set of functions is completely represented by $x$, $v_\\bot$, and $v_\\top$.\nThe intersection of multiple such sets\n  that share a common support vector $x$ but differ in extremal slopes $v_{\\bot,i}$ and $v_{\\top,i}$\n  can be merged efficiently:\n\n", "index": 5, "text": "\\begin{align}\n\\bigcap_{i} AF(x, v_{\\bot,i}, v_{\\top,i}) = AF(x, \\max_{i} \\, v_{\\bot,i} , \\min_{i} \\, v_{\\top,i}) ~.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\bigcap_{i}AF(x,v_{\\bot,i},v_{\\top,i})=AF(x,\\max_{i}\\,v_{\\bot,i},%&#10;\\min_{i}\\,v_{\\top,i})~{}.\" display=\"inline\"><mrow><mrow><mrow><mstyle displaystyle=\"true\"><munder><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c2</mo><mi>i</mi></munder></mstyle><mrow><mi>A</mi><mo>\u2062</mo><mi>F</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><msub><mi>v</mi><mrow><mo>\u22a5</mo><mo>,</mo><mi>i</mi></mrow></msub><mo>,</mo><msub><mi>v</mi><mrow><mo>\u22a4</mo><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>A</mi><mo>\u2062</mo><mi>F</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mrow><mpadded width=\"+1.7pt\"><munder><mi>max</mi><mi>i</mi></munder></mpadded><mo>\u2061</mo><msub><mi>v</mi><mrow><mo>\u22a5</mo><mo>,</mo><mi>i</mi></mrow></msub></mrow><mo>,</mo><mrow><mpadded width=\"+1.7pt\"><munder><mi>min</mi><mi>i</mi></munder></mpadded><mo>\u2061</mo><msub><mi>v</mi><mrow><mo>\u22a4</mo><mo>,</mo><mi>i</mi></mrow></msub></mrow><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\n\n\\textsc{VSE-R} encodes groups of consecutive integers with the number of bits required by the largest element of the group.\nThe optimal length of the group is computed using dynamic programming.\n\nThis allows storing the number of bits only once for several integers to be stored.\nIt is the basis for high performance of \\textsc{VSE-R} (regarding throughput and compression).\nIt also means that the performance is suboptimal when encoding integers of alternating magnitude.\nIn our case the magnitude of space and time deltas can be different by several orders of magnitude. \nSo we rearrange the support vectors such that time and space deltas are grouped together, respectively.\nInstead of the queue $(\\Delta x_1, \\Delta t_1), \\ldots, (\\Delta x_n, \\Delta t_n)$\n   we store the doubled ended queue $\\Delta x_n, \\ldots \\Delta x_1, \\Delta t_1, \\ldots, \\Delta t_n$ \n  (see function $\\textsc{DrainQueue}$ in Algorithm~\\ref{alg:alg}).\n\n\n\n\\subsection*{Optional adaptation for deep simulator integration}\n\nBecause the computational demands for our compression method are small, \nwe envisage future integration of it into the inner loop of MD simulation programs:\nEvery update of a particle's state is immediately followed by the compression of the new position.\n{\\textsc{Hrtc}\\xspace} can then serve as the primary mechanism to retrieve simulation data. In the following, we\ndescribe optional adaptations of our algorithm for this purpose, which are, however, not\napplied for our performance evaluation in the result section.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor a state-of-the-art MD application the integration of {\\textsc{Hrtc}\\xspace} in its inner loop poses additional challenges.\nHigh performance MD simulators rely on specialized hardware---from GPUs to custom ASICs.\\cite{Shaw2007}\nThe performance characteristic of these platforms differs from a typical desktop CPU.\nNon-uniform memory access, diverging control flow and branches are much more expensive compared to arithmetic operations.\nAddition and multiplication are especially fast compared to division and other mathematical operations.\\cite{cuda}\nTo accommodate {\\textsc{Hrtc}\\xspace} compression on these machines, we can adapt the algorithm.\nThe critical section of our algorithm is the check\n  whether the current candidate set of curves is empty after adding the next point.\nWe reformulate it to\n  avoid division operations, and\n  rely on conditional writes instead of branches.\nThen the special purpose hardware only needs to transfer id and position of those dimensions where the check failed.\nThe host computer executes all further compression steps (sorting, queue management, variable-length integer encoding)\n  in parallel to the kernel running on special purpose hardware.\n\nThe original condition whether a point does not lie in the current set of linear functions is:\n\n", "itemtype": "equation", "pos": 32409, "prevtext": "\nThis intersection contains all valid approximations for \\emph{all} input points.\nNote that the intersection is empty if the lower bound $v_\\bot$ becomes larger\nthan the upper bound $ v_\\top$, that is,  $AF(x, v_\\bot, v_\\top) = \\emptyset$ iff.~$v_\\bot > v_\\top$.\nThe above formulation allows to incrementally update the function candidate set.\nThe sequence of points of the current interval does not have to be stored anymore.\n\n\\subsection*{Combined storage of multiple trajectories}\n\n\nA single trajectory can be stored \nin memory as a sequence $(v_0, \\Delta t_0), (v_1, \\Delta t_1), \\dotsc$\nWhen storing multiple trajectories, we have to counter the issue that their support vectors are not synchronized in time.\nA naive approach would include a trajectory index $k_l$ for each support vector:\n  $(k_1, v_{k_1}, \\Delta t_{k_1}), (k_2, v_{k_2}, \\Delta t_{k_2}), \\dotsc$.\nHowever, this would require $O(\\log n d)$ additional space per support vector, which we avoid with the following procedure.\n\n\nWe exploit the fact that the start time and duration of a segment imply the time at which the next support vector has to be expected.\nTo use this insight, we maintain an auxiliary priority queue $Q_\\mathrm{expected}$, which\nstores tuples $(t, k)$ sorted by time $t$ and secondarily trajectory index $k$.\nThe minimal element of the queue denotes the support vector to be outputted next.\nThe queue always contains $nd$ elements,\n  thus the space gain is traded against an additional time complexity of $O(\\log nd)$ per inserted interval.\n\nTo reorder the support vectors from the sequence of discovery to the sequence of storage described above,\n  we use a second priority queue $Q_\\mathrm{known}$.\nIt stores all support vectors that can not be stored immediately because a preceding support vector (according to $Q_\\mathrm{expected}$) is not yet known.\nIt contains up to $O(nd \\max_i \\Delta t_i)$ elements.\nThis implies a memory overhead of the same magnitude in the compressor.\nThe time overhead can be reduced to $O(nd)$ assuming time points are dense--if\n  the number of support vectors of all trajectories exceeds the number of time points.\nDue to the blockwise compression and limited $\\Delta t$ observed,\n  this overhead is much less dramatic in practice.\n\n\nA key frame is used to initialize the queue and to provide the initial support vectors for each dimension.\nThe key frame stores the quantized values of $x_{0,0}, x_{1,0}, \\dotsc$ with a fixed bit count, without further compression.\nThe number of bits $\\lceil log \\frac{L}{2 \\epsilon_q} \\rceil$ is determined by\n  the quantization granularity $\\epsilon_q$ and\n  the edge length $L$ of the bounding box of the trajectory. \n\n\\subsection*{Hierarchy of computation and storage}\n\n\\begin{figure}\n\\includegraphics[width=\\linewidth]{storage_hierarchy.eps}\n\\caption{\\label{fig:storage_hierarchy}\n  Hierarchical storage of MD simulation generated data.\n  Top row denotes data, bottom row code. Each block starts with a key frame.\n  A high-performance implementation typically integrates all lower boxes.}\n\\end{figure}\n\n\nThe {\\textsc{Hrtc}\\xspace} algorithm has to conciliate between two opposing forces:\nMemory pressure and data cache locality demand to minimize the window of trajectory data held in memory during compression.\nHigher compression rates require a larger timespan of data to reason about.\nTo minimize cache thrashing, switching between simulation and compression should happen at a low frequency---asking\n  for a large window, too.\nAt last, to generate a searchable compressed data-stream, key frames have to be inserted at regular time intervals.\n\n\nBalancing these demands has led to the following hierarchy of computation and storage (cf.~Figure~\\ref{fig:storage_hierarchy}):\nAn MD simulator calls the compression library for each generated timestep---denoted a \\emph{frame}.\nThe data is approximated with linear functions, their resulting support vectors are buffered.\nOnce a threshold buffer size is reached (e.g., $\\SI{8}{KB}$ storing $1024$ support vectors),\n  all support vectors are fed through the variable length integer encoding,\n  yielding one \\emph{chunk}.\nThe largest unit---a \\emph{block}---contains a user-specified number of frames.\nIt starts with a single key frame and contains all chunks belonging to the encoded frames.\nThe block size is tuned by the user depending on the desired compression and seek time.\n\n\nThe {\\textsc{Hrtc}\\xspace} compression integrated into the \\textsc{Tng} library does not fully exploit this hierarchy.\nDue to design constraints of the \\textsc{Tng} library,\n  all frames of a block are collected and then compressed at once.\nWhen speed matters, {\\textsc{Hrtc}\\xspace} could be used directly.\n\nThe update compression algorithm, together with storage hierarchy and multiple trajectory storage\nare described by Algorithm~\\ref{alg:alg}. The respective decompression is described by Algorithm~\\ref{alg:sffam-large-hier}.\n\n\\begin{figure}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\errmessage{(Inkscape) Color is used for the text in Inkscape, but the package 'color.sty' is not loaded}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\transparent[1]{\n    \\errmessage{(Inkscape) Transparency is used (non-zero) for the text in Inkscape, but the package 'transparent.sty' is not loaded}\n    \\renewcommand\\transparent[1]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\ifx{\\linewidth}\\undefined\n    \\setlength{\\unitlength}{13.67213593bp}\n    \\ifx\\svgscale\\undefined\n      \\relax\n    \\else\n      \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}\n    \\fi\n  \\else\n    \\setlength{\\unitlength}{{\\linewidth}}\n  \\fi\n  \\global\\let{\\linewidth}\\undefined\n  \\global\\let\\svgscale\\undefined\n  \\makeatother\n  \\begin{picture}(1,0.48424785)\n    \\put(0,0){\\includegraphics[width=\\unitlength]{PS_combined.eps}}\n    \\put(0.01561113,0.23253111){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$p_k$}}}\n    \\put(0.29647433,0.17986923){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x_{k,t}$}}}\n    \\put(0.29647433,0.15061264){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$q$}}}\n    \\put(0.11702634,0.15213424){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_k$}}}\n    \\put(0.09167825,0.23898743){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top$}}}\n    \\put(0.08582693,0.10557742){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot$}}}\n    \\put(0.20870457,0.09650787){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot'$}}}\n    \\put(0.20870457,0.22377402){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top'$}}}\n    \\put(0.52432464,0.23253111){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$p_k$}}}\n    \\put(0.92221415,0.36711137){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x_{k,t+1}$}}}\n    \\put(0.92221415,0.39636795){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$q$}}}\n    \\put(0.71741806,0.18691072){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_k$}}}\n    \\put(0.7174339,0.2214335){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top$}}}\n    \\put(0.7174339,0.1357117){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot$}}}\n    \\put(0.83446024,0.27444642){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\bot'$}}}\n    \\put(0.83446024,0.17111217){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$v_\\top'$}}}\n    \\put(0.88606434,0.05283901){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$x$}}}\n    \\put(0.9351291,0.00000004){\\color[rgb]{0,0,0}\\makebox(0,0)[lb]{\\smash{$t$}}}\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:pseudocode_segement}\n  Illustration of the variables used during compression for each dimension $k$ as used in algorithm~\\ref{alg:alg}.\n  Shown are two cases: A point to be added either extends the segment (a),\n    or causes termination of the segment at the previous point (b).\n  The input $x_{k,t}$ is shown as circle, the quantized values as square.\n  Four variables are stored per dimension:\n    $p_k$ denotes the quantized support vector starting the segment,\n    $v_k$ the slope to the last point added, and\n    $v_\\bot$ and $v_\\top$ the lower and upper slope bounds.\n  In addition, three temporary variables are used:\n    the quantized input value $q$, and\n    the updated slope bounds $v_\\bot'$ and $v_\\top'$.}\n\\end{figure}\n\n\\begin{algorithm}\n\\caption{The {\\textsc{Hrtc}\\xspace} compression algorithm. For an illustration of the variables used, see Figure~\\ref{fig:pseudocode_segement}.}\n\\begin{algorithmic}[1]\n\\State \\textbf{Input:} Trajectory $(x_{t,k})$ for $t \\in \\{0, \\dots, T\\}, k \\in \\{1, \\dots, nd \\}$, quantization error $\\epsilon_q$, approximation error $\\epsilon_f$\n\\State \\textbf{Output:} Compressed trajectory (incl. key frames)\n\\State \\textbf{global} $v_{\\bot,k}$, $v_{\\top,k}$, $v_k$, $p_k$, $\\Delta t_k$ for $k \\in \\{1, \\dots, nd \\}$ \\Comment current approximation\n\\State \\textbf{global} $q$ \\Comment current quantized input $x_{t,k}$  \n\\State \\textbf{global} outputBuf $= ()$\n\\State \\textbf{global} $Q_\\mathrm{known} \\leftarrow \\emptyset$,\n       $Q_\\mathrm{expected} \\leftarrow \\emptyset$\n\\Statex\n\\For{$t \\in \\{0, \\dotsc, T\\}$}                              \\Comment For each input frame\n  \\State \\Call{DrainQueue}{}                                \\Comment Move expected known segments to output buffer\n\n  \\If{$t ~\\mathrm{mod}~ \\mathrm{blockSize} = 0$}\n    \\Comment ENCODE KEY FRAME\n    \\While{$Q_\\mathrm{expected} \\ne \\emptyset$}              \\Comment While there are segments to end\n      \\State $(t', k) \\leftarrow \\min(Q_\\mathrm{expected})$ \\Comment Get time and dimension of next segment\n      \\State \\Call{FlushSegment}{t', k}                    \\Comment End this segment and push it into $Q_\\mathrm{known}$ \n    \\EndWhile\n    \\State \\Call{DrainQueue}{} \\Comment Move $Q_\\mathrm{known}$ (known segments) to output buffer\n    \\State \\Call{FlushChunk}{}                             \\Comment Compress output buffer and output it \n    \\State $Q_\\mathrm{expected} \\leftarrow \\{(t,0), \\dotsc, (t, nd-1)\\}$   \\Comment Initialize  $Q_\\mathrm{expected}$ with current time \n    \\For{$k \\in \\{1, \\dotsc nd\\}$}                                        \\Comment For each dimension $k$:\n      \\State $p_k \\leftarrow \\lfloor  x_{t,k} / (2 \\epsilon_q) + 0.5 \\rfloor$  \\Comment get the next input, quantize and remember it as $p_k$,\n      \\State output $p_k$                                                  \\Comment and output it (for the key frame).\n      \\State $v_{\\bot,k} = -\\infty$, $v_{\\top,k} = \\infty$    \\Comment initialize empty segment\n      \\State $\\Delta t_k \\leftarrow 0$                           \n    \\EndFor\n  \\Else \\Comment ENCODE SEGMENTS \n    \\For{$k \\in \\{1, \\dotsc nd\\}$} \\Comment for each dimension $k$\n      \\State $q \\leftarrow \\lfloor  x_{t,k} / (2 \\epsilon_q) + 0.5 \\rfloor$ \\Comment quantize next input \n      \\State $v_\\top' \\leftarrow \\min(v_{\\top,k}, (q -  p_k + \\epsilon_f)/\\Delta t_k)$ \\Comment Computer lower and upper bound \n      \\State $v_\\bot' \\leftarrow \\max(v_{\\bot,k}, (q -  p_k - \\epsilon_f)/\\Delta t_k)$ \\Comment of the approximating functions.\n      \\If{$v_\\top' < v_\\bot'$}   \\Comment If no valid approximating function remains\n       \\State \\Call{FlushSegment}{t, k}  \\Comment terminate current segment with previous point.\n      \\Else\n        \\State $v_{\\bot,k} \\leftarrow v_\\bot'$, $v_{\\top,k} \\leftarrow v_\\top'$ \\Comment Update current approximation\n        \\State $v_k \\leftarrow (q -  p_k) / \\Delta t_k$ \n        \\State $\\Delta t_k \\leftarrow \\Delta t_k + 1$\n      \\EndIf\n    \\EndFor\n  \\EndIf\n\\EndFor\n\\algstore{algcomp}\n\\end{algorithmic}\n\\label{alg:alg}\n\\end{algorithm}\n\n\n\n\n\n\\begin{algorithm}\n\\begin{algorithmic}[1]\n\\algrestore{algcomp}\n\\Function{FlushSegment}{t, k}\n  \\State \\(\\Delta q \\leftarrow \\left\\{ \\begin{array}{ll}\n    \\Delta t_k v_{\\bot,k} & \\mathrm{if}\\: v_k < v_{\\bot,k} \\\\\n    \\Delta t_k v_k & \\mathrm{if}\\: v_k \\in [v_{\\bot,k}, v_{\\top,k}] \\\\\n    \\Delta t_k v_{\\top,k} & \\mathrm{if}\\: v_k > v_{\\top,k} \\end{array}\\right.\\)  \\Comment Choose support vector closest to prev. point.\n  \\State insert $(t - \\Delta t_k, k, \\Delta t_k, \\Delta q)$ into $Q_\\mathrm{known}$ \\Comment Insert support vector to $Q_\\mathrm{known}$, \n  \\Statex \\Comment which is sorted by $(t - \\Delta t_k, k)$.\n  \\State $\\Delta t_k \\leftarrow 1$  \\Comment Initialize next segment duration with 1\n  \\State $v_{\\bot,k} \\leftarrow q - p_k - \\epsilon_f$ \\Comment Reset upper and lower bounds\n  \\State $v_{\\top,k} \\leftarrow q - p_k + \\epsilon_f$\n  \\State $p_k \\leftarrow p_k + \\Delta q$  \\Comment Set starting point of next segment \n  \\Statex \\Comment to terminal point of current segment.\n\\EndFunction\n\\Statex\n\\Function{FlushChunk}{}\n  \\State compress outputBuf using \\textsc{VSE-R}, output result\n  \\State outputBuf $\\leftarrow ()$\n\\EndFunction\n\\Statex\n\\Function{DrainQueue}{$Q_\\mathrm{known}, Q_\\mathrm{expected}, \\mathrm{outputBuf}$}\n  \\While {$\\min(Q_\\mathrm{expected}) \\overset{t,k}{=} \\min(Q_\\mathrm{known})$}\n    \\Comment While next segment is known\n    \\State $(t, k, \\Delta t, \\Delta q) \\leftarrow \\mathrm{extractMin}(Q_\\mathrm{known})$ \\Comment Get next known segment\n    \\State $\\mathrm{extractMin}(Q_\\mathrm{expected})$ \\Comment Update the expected start time \n    \\State insert $(t+\\Delta t, k)$ into $Q_\\mathrm{expected}$ \n    \\State $\\mathrm{outputBuf} \\leftarrow (\\Delta q, \\mathrm{outputBuf}, \\Delta t)$ \\Comment Append segment to output buffer \n \\Statex \\Comment (see section ``chunk encoding'')\n    \\If{length of outputBuf $\\ge 2 \\cdot \\mathrm{chunkLength}$}  \\Comment If chunk is full.\n      \\State \\Call{FlushChunk}{} \\Comment compress and output chunk.\n    \\EndIf\n  \\EndWhile\n\\EndFunction\n\\end{algorithmic}\n\\end{algorithm}\n\n\\begin{algorithm}\n\\caption{The {\\textsc{Hrtc}\\xspace} \\textbf{de}compression algorithm.\n  The handling of chunks for integer compression has been omitted for brevity---it is implied in line 11.}\n\\label{alg:sffam-large-hier}\n\\begin{algorithmic}[1]\n\\State \\textbf{Input:} Compressed trajectory (incl. key frames)\n\\State \\textbf{Output:} Uncompressed trajectory $(x_{t,k})$\n\\For{$t \\in \\{0, \\ldots, T\\}$}\n  \\If{$t ~\\mathrm{mod}~ \\mathrm{blockSize} = 0$} \\Comment decode key frame\n    \\For{$k \\in \\{1, \\dotsc nd\\}$}\n      \\State read $q$\n      \\State $p_k \\leftarrow q \\epsilon_q$, $t_k \\leftarrow t, v_k \\leftarrow 0 ,\\Delta t_k \\leftarrow 0$ \n                                                    \\Comment Set starting point of segment\n    \\EndFor\n    \\State $Q_\\mathrm{expected} \\leftarrow \\{(t,1), \\dotsc, (t, nd)\\}$ \\Comment Initialize $Q_\\mathrm{expected}$ with current time\n  \\EndIf\n  \\While{$t \\overset{t}{=} \\min(Q_\\mathrm{expected})$} \\Comment For all segments starting at $t$\n    \\State $(t, k) \\leftarrow \\mathrm{extractMin}(Q_\\mathrm{expected})$ \\Comment Get dimension of next segment\n    \\State read $(d, q)$ using \\textsc{VSE-R} decompression \\Comment Get its duration and support vector\n    \\State $p_k \\leftarrow p_k + \\Delta t_k v_k$ \\Comment Compute starting point\n    \\State $v_k \\leftarrow q \\epsilon_q/d$ \\Comment Compute slope of segment\n    \\State $t_k \\leftarrow t$ \\Comment Update time of segment\n    \\State $\\Delta t_k \\leftarrow d$ \\Comment Duration of segment \n    \\State insert $(t + d, k)$ into $Q_\\mathrm{expected}$ \\Comment Update expected time for next segment\n  \\EndWhile\n  \\For{$k \\in \\{1, \\dotsc nd\\}$} \\Comment Interpolate current frame\n    \\State output $x_{t,k} \\leftarrow p_k + (t - t_k) v_k$ \\Comment and output it. \n  \\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}\n\n\n\\subsection*{Integer compression and chunk encoding}\n\nFor variable-length integer encoding, we use the \\textsc{Integer Encoding Library}.\\cite{integer-encoding}\nIt offers several codecs.\nAfter selecting for time and speed, we chose the codec \\textsc{VSE-R}.\\cite{silvestri2010vsencoding}\nThe library only encodes unsigned integers.\nWhere signed integers occur in our algorithm they are mapped to unsigneds:\n\n", "index": 7, "text": "\\begin{equation}\ni \\mapsto \\left\\{ \\begin{array}{lr}\n  \\hphantom{-} 2i   & \\textrm{if } i \\ge 0 ~,\\\\\n              -2i+1 & \\textrm{if } i <   0 ~.\n\\end{array} \\right.\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E6.m1\" class=\"ltx_Math\" alttext=\"i\\mapsto\\left\\{\\begin{array}[]{lr}\\hphantom{-}2i&amp;\\textrm{if }i\\geq 0~{},\\\\&#10;-2i+1&amp;\\textrm{if }i&lt;0~{}.\\end{array}\\right.\" display=\"block\"><mrow><mi>i</mi><mo>\u21a6</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" displaystyle=\"true\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow></mtd><mtd columnalign=\"right\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>i</mi></mrow><mo>\u2265</mo><mpadded width=\"+3.3pt\"><mn>0</mn></mpadded></mrow><mo>,</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mrow><mrow><mo>-</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow></mrow><mo>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=\"right\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><mi>i</mi></mrow><mo>&lt;</mo><mpadded width=\"+3.3pt\"><mn>0</mn></mpadded></mrow><mo>.</mo></mrow></mtd></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\n\nThis code requires $4$ additions, $2$ divisions, $3$ comparisons and $3$ branches.\nEquation \\ref{eqn:test_orig}-\\ref{eqn:test_max} can be merged and simplified by case analysis:\n\n", "itemtype": "equation", "pos": 35420, "prevtext": "\n\n\\textsc{VSE-R} encodes groups of consecutive integers with the number of bits required by the largest element of the group.\nThe optimal length of the group is computed using dynamic programming.\n\nThis allows storing the number of bits only once for several integers to be stored.\nIt is the basis for high performance of \\textsc{VSE-R} (regarding throughput and compression).\nIt also means that the performance is suboptimal when encoding integers of alternating magnitude.\nIn our case the magnitude of space and time deltas can be different by several orders of magnitude. \nSo we rearrange the support vectors such that time and space deltas are grouped together, respectively.\nInstead of the queue $(\\Delta x_1, \\Delta t_1), \\ldots, (\\Delta x_n, \\Delta t_n)$\n   we store the doubled ended queue $\\Delta x_n, \\ldots \\Delta x_1, \\Delta t_1, \\ldots, \\Delta t_n$ \n  (see function $\\textsc{DrainQueue}$ in Algorithm~\\ref{alg:alg}).\n\n\n\n\\subsection*{Optional adaptation for deep simulator integration}\n\nBecause the computational demands for our compression method are small, \nwe envisage future integration of it into the inner loop of MD simulation programs:\nEvery update of a particle's state is immediately followed by the compression of the new position.\n{\\textsc{Hrtc}\\xspace} can then serve as the primary mechanism to retrieve simulation data. In the following, we\ndescribe optional adaptations of our algorithm for this purpose, which are, however, not\napplied for our performance evaluation in the result section.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor a state-of-the-art MD application the integration of {\\textsc{Hrtc}\\xspace} in its inner loop poses additional challenges.\nHigh performance MD simulators rely on specialized hardware---from GPUs to custom ASICs.\\cite{Shaw2007}\nThe performance characteristic of these platforms differs from a typical desktop CPU.\nNon-uniform memory access, diverging control flow and branches are much more expensive compared to arithmetic operations.\nAddition and multiplication are especially fast compared to division and other mathematical operations.\\cite{cuda}\nTo accommodate {\\textsc{Hrtc}\\xspace} compression on these machines, we can adapt the algorithm.\nThe critical section of our algorithm is the check\n  whether the current candidate set of curves is empty after adding the next point.\nWe reformulate it to\n  avoid division operations, and\n  rely on conditional writes instead of branches.\nThen the special purpose hardware only needs to transfer id and position of those dimensions where the check failed.\nThe host computer executes all further compression steps (sorting, queue management, variable-length integer encoding)\n  in parallel to the kernel running on special purpose hardware.\n\nThe original condition whether a point does not lie in the current set of linear functions is:\n\n", "index": 9, "text": "\\begin{align}\nv_\\bot' & > v_\\top' \\label{eqn:test_orig} ~,\\\\\nv_\\bot' & = \\max(v_\\bot, \\frac{x' - x - \\epsilon_f}{\\Delta t}) \\label{eqn:test_min} ~,\\\\\nv_\\top' & = \\min(v_\\top, \\frac{x' - x + \\epsilon_f}{\\Delta t}) \\label{eqn:test_max} ~.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle v_{\\bot}^{\\prime}\" display=\"inline\"><msubsup><mi>v</mi><mo>\u22a5</mo><mo>\u2032</mo></msubsup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&gt;v_{\\top}^{\\prime}~{},\" display=\"inline\"><mrow><mrow><mi/><mo>&gt;</mo><mpadded width=\"+3.3pt\"><msubsup><mi>v</mi><mo>\u22a4</mo><mo>\u2032</mo></msubsup></mpadded></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle v_{\\bot}^{\\prime}\" display=\"inline\"><msubsup><mi>v</mi><mo>\u22a5</mo><mo>\u2032</mo></msubsup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\max(v_{\\bot},\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta t})~{},\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mi>max</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mo>\u22a5</mo></msub><mo>,</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle v_{\\top}^{\\prime}\" display=\"inline\"><msubsup><mi>v</mi><mo>\u22a4</mo><mo>\u2032</mo></msubsup></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\min(v_{\\top},\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta t})~{}.\" display=\"inline\"><mrow><mrow><mi/><mo>=</mo><mrow><mi>min</mi><mo>\u2061</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>v</mi><mo>\u22a4</mo></msub><mo>,</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo rspace=\"5.8pt\" stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\n\nCase \\ref{eqn:test_merge}.2 is impossible: it implies that the curve set was already empty after insertion of the previous point.\nThat would already have been remedied by starting a new segment.\nCase \\ref{eqn:test_merge}.3 is impossible as all variables are strictly positive.\nThis allows us to rewrite equation \\ref{eqn:test_merge} without expensive division operations:\nInstead of the extremal slopes $v_\\bot, v_\\top$ we store\n  the time $\\Delta t_\\bot, \\Delta t_\\top$ and\n  value $x_\\bot, x_\\top$ of the previous extrema.\nThen a new segment starts iff.\n\n", "itemtype": "equation", "pos": 35848, "prevtext": "\n\nThis code requires $4$ additions, $2$ divisions, $3$ comparisons and $3$ branches.\nEquation \\ref{eqn:test_orig}-\\ref{eqn:test_max} can be merged and simplified by case analysis:\n\n", "index": 11, "text": "\\begin{align}\nv_\\bot' > v_\\top' \\label{eqn:test_merge}\n\\Leftrightarrow\n  \\left\\{ \\begin{array}{lllr}\n  v_\\bot                  & > \\frac{x'-x+\\epsilon_f}{\\Delta{t}} & \\text{if } v_\\bot \\ge \\frac{x'-x-\\epsilon_f}{\\Delta{t}} \\wedge v_\\top \\ge \\frac{x'-x+\\epsilon_f}{\\Delta{t}} ~,& (\\ref{eqn:test_merge}.1) \\\\\n  v_\\bot                  & > v_\\top                  & \\text{if } v_\\bot \\ge \\frac{x'-x-\\epsilon_f}{\\Delta{t}} \\wedge v_\\top <   \\frac{x'-x+\\epsilon_f}{\\Delta{t}} ~,& (\\ref{eqn:test_merge}.2) \\\\\n  \\frac{x'-x-\\epsilon_f}{\\Delta{t}} & > \\frac{x'-x+\\epsilon_f}{\\Delta{t}} & \\text{if } v_\\bot <   \\frac{x'-x-\\epsilon_f}{\\Delta{t}} \\wedge v_\\top \\ge \\frac{x'-x+\\epsilon_f}{\\Delta{t}}  ~,& (\\ref{eqn:test_merge}.3)\\\\\n  \\frac{x'-x-\\epsilon_f}{\\Delta{t}} & > v_\\top                  & \\text{if } v_\\bot <   \\frac{x'-x-\\epsilon_f}{\\Delta{t}} \\wedge v_\\top <   \\frac{x'-x+\\epsilon_f}{\\Delta{t}} ~, & (\\ref{eqn:test_merge}.4) \\\\\n  \\mathrm{false} & & \\mathrm{otherwise} .\n  \\end{array} \\right.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E10.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle v_{\\bot}^{\\prime}&gt;v_{\\top}^{\\prime}\\Leftrightarrow\\left\\{\\begin{%&#10;array}[]{lllr}v_{\\bot}&amp;&gt;\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta{t}}&amp;\\text{if }%&#10;v_{\\bot}\\geq\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta{t}}\\wedge v_{\\top}\\geq%&#10;\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta{t}}~{},&amp;(\\ref{eqn:test_merge}.1)\\\\&#10;v_{\\bot}&amp;&gt;v_{\\top}&amp;\\text{if }v_{\\bot}\\geq\\frac{x^{\\prime}-x-\\epsilon_{f}}{%&#10;\\Delta{t}}\\wedge v_{\\top}&lt;\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta{t}}~{},&amp;(%&#10;\\ref{eqn:test_merge}.2)\\\\&#10;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta{t}}&amp;&gt;\\frac{x^{\\prime}-x+\\epsilon_{f}}{%&#10;\\Delta{t}}&amp;\\text{if }v_{\\bot}&lt;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta{t}}%&#10;\\wedge v_{\\top}\\geq\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta{t}}~{},&amp;(\\ref{eqn:%&#10;test_merge}.3)\\\\&#10;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta{t}}&amp;&gt;v_{\\top}&amp;\\text{if }v_{\\bot}&lt;\\frac%&#10;{x^{\\prime}-x-\\epsilon_{f}}{\\Delta{t}}\\wedge v_{\\top}&lt;\\frac{x^{\\prime}-x+%&#10;\\epsilon_{f}}{\\Delta{t}}~{},&amp;(\\ref{eqn:test_merge}.4)\\\\&#10;\\mathrm{false}&amp;&amp;\\mathrm{otherwise}.\\end{array}\\right.\" display=\"inline\"><mrow><mrow><msubsup><mi>v</mi><mo>\u22a5</mo><mo>\u2032</mo></msubsup><mo>&gt;</mo><msubsup><mi>v</mi><mo>\u22a4</mo><mo>\u2032</mo></msubsup></mrow><mo>\u21d4</mo><mrow><mo>{</mo><mtable columnspacing=\"5pt\" rowspacing=\"0pt\"><mtr><mtd columnalign=\"left\"><msub><mi>v</mi><mo>\u22a5</mo></msub></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>&gt;</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>v</mi><mo>\u22a5</mo></msub></mrow><mo>\u2265</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo>\u2227</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow><mo>\u2265</mo><mpadded width=\"+3.3pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"right\"><mrow><mo stretchy=\"false\">(</mo><mrow><mtext mathvariant=\"italic\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ref ltx_font_italic ltx_ref_self\"><span class=\"ltx_text ltx_ref_tag\">10</span></span></mtext><mo>\u2062</mo><mn>.1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><msub><mi>v</mi><mo>\u22a5</mo></msub></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>&gt;</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>v</mi><mo>\u22a5</mo></msub></mrow><mo>\u2265</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo>\u2227</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow><mo>&lt;</mo><mpadded width=\"+3.3pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"right\"><mrow><mo stretchy=\"false\">(</mo><mrow><mtext mathvariant=\"italic\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ref ltx_font_italic ltx_ref_self\"><span class=\"ltx_text ltx_ref_tag\">10</span></span></mtext><mo>\u2062</mo><mn>.2</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>&gt;</mo><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>v</mi><mo>\u22a5</mo></msub></mrow><mo>&lt;</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo>\u2227</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow><mo>\u2265</mo><mpadded width=\"+3.3pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"right\"><mrow><mo stretchy=\"false\">(</mo><mrow><mtext mathvariant=\"italic\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ref ltx_font_italic ltx_ref_self\"><span class=\"ltx_text ltx_ref_tag\">10</span></span></mtext><mo>\u2062</mo><mn>.3</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mtd><mtd columnalign=\"left\"><mrow><mi/><mo>&gt;</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow></mtd><mtd columnalign=\"left\"><mrow><mrow><mrow><mtext>if\u00a0</mtext><mo>\u2062</mo><msub><mi>v</mi><mo>\u22a5</mo></msub></mrow><mo>&lt;</mo><mrow><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle><mo>\u2227</mo><msub><mi>v</mi><mo>\u22a4</mo></msub></mrow><mo>&lt;</mo><mpadded width=\"+3.3pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded></mrow><mo>,</mo></mrow></mtd><mtd columnalign=\"right\"><mrow><mo stretchy=\"false\">(</mo><mrow><mtext mathvariant=\"italic\"><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_ref ltx_font_italic ltx_ref_self\"><span class=\"ltx_text ltx_ref_tag\">10</span></span></mtext><mo>\u2062</mo><mn>.4</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mtd></mtr><mtr><mtd columnalign=\"left\"><mi>false</mi></mtd><mtd/><mtd columnalign=\"left\"><mrow><mi>otherwise</mi><mo>.</mo></mrow></mtd><mtd/></mtr></mtable><mi/></mrow></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\n\nThe update of the stored extrema can be modified in the same\nway. Update $x_\\bot \\leftarrow x'$ and $t_\\bot \\leftarrow t_1$ when\n\n", "itemtype": "equation", "pos": 37407, "prevtext": "\n\nCase \\ref{eqn:test_merge}.2 is impossible: it implies that the curve set was already empty after insertion of the previous point.\nThat would already have been remedied by starting a new segment.\nCase \\ref{eqn:test_merge}.3 is impossible as all variables are strictly positive.\nThis allows us to rewrite equation \\ref{eqn:test_merge} without expensive division operations:\nInstead of the extremal slopes $v_\\bot, v_\\top$ we store\n  the time $\\Delta t_\\bot, \\Delta t_\\top$ and\n  value $x_\\bot, x_\\top$ of the previous extrema.\nThen a new segment starts iff.\n\n", "index": 13, "text": "\\begin{align}\n\\frac{x_\\bot - x + \\epsilon_f}{\\Delta t_\\bot} &> \\frac{x' - x + \\epsilon_f}{\\Delta t} \\,\\bigwedge \\nonumber \\\\\n\\frac{x_\\top - x - \\epsilon_f}{\\Delta t_\\top} &< \\frac{x' - x - \\epsilon_f}{\\Delta t} \\label{eqn:opt_check} \\\\\n\\Leftrightarrow (x_\\bot - x + \\epsilon_f) \\Delta t &> (x' - x + \\epsilon_f) \\Delta t_\\bot \\,\\bigwedge \\nonumber \\\\\n                (x_\\top - x - \\epsilon_f) \\Delta t &< (x' - x - \\epsilon_f) \\Delta t_\\top             \\nonumber ~.\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\frac{x_{\\bot}-x+\\epsilon_{f}}{\\Delta t_{\\bot}}\" display=\"inline\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msub><mi>x</mi><mo>\u22a5</mo></msub><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>t</mi><mo>\u22a5</mo></msub></mrow></mfrac></mstyle></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&gt;\\frac{x^{\\prime}-x+\\epsilon_{f}}{\\Delta t}\\,\\bigwedge\" display=\"inline\"><mrow><mi/><mo>&gt;</mo><mrow><mpadded width=\"+1.7pt\"><mstyle displaystyle=\"true\"><mfrac><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mpadded><mo>\u2062</mo><mstyle displaystyle=\"true\"><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo></mstyle></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\frac{x_{\\top}-x-\\epsilon_{f}}{\\Delta t_{\\top}}\" display=\"inline\"><mstyle displaystyle=\"true\"><mfrac><mrow><msub><mi>x</mi><mo>\u22a4</mo></msub><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>t</mi><mo>\u22a4</mo></msub></mrow></mfrac></mstyle></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta t}\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow(x_{\\bot}-x+\\epsilon_{f})\\Delta t\" display=\"inline\"><mrow><mi/><mo>\u21d4</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msub><mi>x</mi><mo>\u22a5</mo></msub><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&gt;(x^{\\prime}-x+\\epsilon_{f})\\Delta t_{\\bot}\\,\\bigwedge\" display=\"inline\"><mrow><mi/><mo>&gt;</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi></mrow><mo>+</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mpadded width=\"+1.7pt\"><msub><mi>t</mi><mo>\u22a5</mo></msub></mpadded><mo>\u2062</mo><mstyle displaystyle=\"true\"><mo largeop=\"true\" mathsize=\"160%\" movablelimits=\"false\" stretchy=\"false\" symmetric=\"true\">\u22c0</mo></mstyle></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle(x_{\\top}-x-\\epsilon_{f})\\Delta t\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mo>\u22a4</mo></msub><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;(x^{\\prime}-x-\\epsilon_{f})\\Delta t_{\\top}~{}.\" display=\"inline\"><mrow><mrow><mi/><mo>&lt;</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><msub><mi>t</mi><mo>\u22a4</mo></msub></mpadded></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\nAnalogous for $x_\\top$.\nImplementing eq.~\\ref{eqn:opt_check} and \\ref{eqn:opt_update} requires\n  13 additions, 6 multiplications, 2 conditional moves and one branch.\nAlthough the operation count is higher, expensive division and branch operations have been omitted.\n\n\\section*{Results and discussion}\n\nA library implementing the {\\textsc{Hrtc}\\xspace} algorithm as described above\n  is available under a GPL-3 open source license at \\url{https://github.com/biosystemanalysis/hrtc}.\nTo compare our compression algorithm with the state of the art,\n  we additionally integrated it into the \\textsc{trajectory-ng} library.\nThe merged library is available at \\url{https://github.com/biosystemanalysis/tng}.\n\n\\subsection*{{\\textsc{Hrtc}\\xspace} outperforms existing compression methods}\n\n\\textsc{Tng} comes with a benchmark application, used to compare compression algorithms, here.\nThe benchmark applies velocity verlet integration to simulate $512$ particles with a harmonic well potential\n  $U(\\Delta x) = \\sin(\\min(\\|\\Delta x\\|, \\frac{\\pi}{2})^2$ and an arbitrary mass $2$, and timestep $2\\cdot10^{-4}$ with arbitrary units (a.u.).\nInitially, the particles are distributed randomly in a $15\\times16\\times17$ (a.u.) cuboid and equilibriated for $10^5$ steps.\nAfter equilibration, this simulation is run for $10^7$ more timesteps to generate the benchmark trajectory.\nThe transient phase is omitted in order to avoid artifacts when applying different sub-sampling rates.\nThe resulting benchmark trajectory is then compressed using either \\textsc{Tng}s native compression algorithm or our {\\textsc{Hrtc}\\xspace} compression.\nWe compare compression rates while varying the sub-sampling rate, the number of frames per block, and the maximal error $\\epsilon$. \nThe results are depicted in Table \\ref{table:compression_rate}.\nThe remaining parameters are held constant during this paper:\n  chunk size is set to 1024 support vectors,\n  and block size to 2048 frames.\n\n{\\textsc{Hrtc}\\xspace} outperforms the \\textsc{Tng} compression in all cases,\n  except when a very coarse sub-sampling rate ($\\lesssim 1:1024$) is combined with high spatial resolution ($\\epsilon \\lesssim 0.001$).\nThese cases are practically irrelevant for two reasons:\n  First, in our example $\\epsilon = 0.0001$ corresponds to \\SI{18}{b} of position information per dimension---almost\n    equal to the \\SI{24}{b} of a single precision float mantissa.\n  And second, the position inaccuracy introduced by low temporal resolution far exceeds the error bound $0.0001$\n    even for minuscule particle velocities.\n\nFurthermore, {\\textsc{Hrtc}\\xspace} appears to outperform  all compression methods investigated by \\textsc{Marais, et al.}\\cite{Marais2012}\nAs neither their implementation nor their test data is public, we have to cautiously compare our benchmarks\n  despite them running on different datasets.\nThe best compression rate \\textsc{Marais'} algorithms achieves is $20.8$\n  with 1:2 sub-sampling, a \\SI{12}{b} quantization and \\SI{0.014}{\\angstrom} positional error.\nThis rate is overachieved by {\\textsc{Hrtc}\\xspace} already at the much coarser 1:32 sub-sampling\n  with much smaller error bound $\\epsilon=0.0001$---yielding a large buffer to compensate for the different datasets being used.\nAt a comparable error rate ($\\epsilon = 0.01$) and sub-sampling (1:2) {\\textsc{Hrtc}\\xspace} achieves a compression ratio of 3419.\n\n\n\n\n\n\n\n\\begin{table}\n\\center\n\\caption{Comparison of compression ratio (uncompressed size / compressed size)\n  for different error bounds $\\epsilon$ and sub-sampling rates.\nThe size of the original, uncompressed \\textsc{Tng} file was \\SI{114}{GiB}.\nThe compressed file sizes vary between \\SI{796}{KiB} and \\SI{7.0}{GiB}.\nNote that the sub-sampling factor is also included in the compression ratio.}\n\\scriptsize\n\\begin{tabular}{lrrrrrrrrrr}\n\\toprule\n\n\\multirow{2}{1.2cm}{Sampling rate} &\n\\multicolumn{2}{c}{$\\epsilon=1$} &\n\\multicolumn{2}{c}{$\\epsilon=0.1$} &\n\\multicolumn{2}{c}{$\\epsilon=0.01$} &\n\\multicolumn{2}{c}{$\\epsilon=0.001$} &\n\\multicolumn{2}{c}{$\\epsilon=0.0001$} \\\\\n\\cmidrule(r){2-3}\n\\cmidrule(r){4-5}\n\\cmidrule(r){6-7}\n\\cmidrule(r){8-9}\n\\cmidrule(r){10-11}\n\n& {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}        & \\textsc{Tng} \\\\\n\\midrule\n\n1:1 & { \\FPeval\\ratio{120117548/{25508}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3132196}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{32960}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3139872}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{47908}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3188944}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{108388}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3610992}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{291956}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7329736}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:2 & { \\FPeval\\ratio{120117548/{13280}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1566364}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18260}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1572516}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{35136}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1619592}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{90604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2005048}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{256512}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5430348}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:4 & { \\FPeval\\ratio{120117548/{7228}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{783120}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{11768}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{788508}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{28632}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{833868}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{79764}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1218152}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{226132}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3173192}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:8 & { \\FPeval\\ratio{120117548/{4228}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{391824}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{8904}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{396808}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{24492}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{439968}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{70188}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{802236}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{198080}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1824716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:16 & { \\FPeval\\ratio{120117548/{2848}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{196172}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7352}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{200932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{21460}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{240560}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{61924}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{587932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{171904}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1032888}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:32 & { \\FPeval\\ratio{120117548/{2212}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{98024}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6520}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{102604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18892}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{140604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{53828}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{389760}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{153696}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{573460}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:64 & { \\FPeval\\ratio{120117548/{1856}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{49276}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5776}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{53656}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{16700}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{90668}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{47184}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{223616}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{142152}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{316816}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:128 & { \\FPeval\\ratio{120117548/{1636}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{24896}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5016}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{28972}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{14644}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{65132}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{42472}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{127112}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{131272}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{173628}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:256 & { \\FPeval\\ratio{120117548/{1452}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12700}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{4420}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{16484}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12916}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{45836}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{39020}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{71496}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{91656}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{99716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:512 & { \\FPeval\\ratio{120117548/{1212}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6248}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{9828}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{10900}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{25252}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{31688}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{37744}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{51088}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{50688}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n1:1024 & { \\FPeval\\ratio{120117548/{932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2960}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2908}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6064}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{8632}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12924}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18764}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18576}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } & { \\FPeval\\ratio{120117548/{25712}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{22848}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n1:2048 & { \\FPeval\\ratio{120117548/{796}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1648}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2468}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{4540}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6736}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7072}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{11328}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{9508}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } & { \\FPeval\\ratio{120117548/{14388}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12180}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n\n\\bottomrule\n\\end{tabular}\n\\label{table:compression_rate}\n\\end{table}\n\n\\subsection*{Compressing below one bit per sample}\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,704){\\makebox(0,0)[r]{\\strut{} 0.01}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,2061){\\makebox(0,0)[r]{\\strut{} 0.1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,3418){\\makebox(0,0)[r]{\\strut{} 1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,4775){\\makebox(0,0)[r]{\\strut{} 10}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1210,484){\\makebox(0,0){\\strut{}$10^{-7}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2009,484){\\makebox(0,0){\\strut{}$10^{-6}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2808,484){\\makebox(0,0){\\strut{}$10^{-5}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3607,484){\\makebox(0,0){\\strut{}$10^{-4}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(4406,484){\\makebox(0,0){\\strut{}$10^{-3}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5205,484){\\makebox(0,0){\\strut{}$10^{-2}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6004,484){\\makebox(0,0){\\strut{}$10^{-1}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{}$10^{0}$}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}bit per sample}}}\n      \\put(4006,154){\\makebox(0,0){\\strut{}error bound $\\epsilon$}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{bps}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fluxkompensator}\n  Average number of bits required to compress one sample---the\n    position of one particle at one timepoint---depending on error bound $\\epsilon$.\n  A trajectory of $512$ particles over $10^7$ timesteps generated by the \\textsc{Tng} benchmark application\n    was compressed with 2048 frames per block.}\n\\end{figure}\n\nTo demonstrate the ability of our algorithm to reduce storage space needed per sample below the \\SI{1}{b} limit,\n  we compress a $2048$ frame $512$ particle simulation with varying error rates $\\epsilon$.\nFor values of $\\epsilon \\tilde{>} 0.0000006$ the average space demanded per sample drops below $\\SI{1}{b}$\n  (see Figure~\\ref{fluxkompensator}).\n\n\\subsection*{Compression is fast}\n\n\\begin{table}\n\\caption{Runtime (s) of an  MD simulation with the trajectory stored either with \\textsc{Tng}, {\\textsc{Hrtc}\\xspace}, or not at all.\n  The storage precision $\\epsilon$ is varied, but has almost no effect on the runtime.}\n\\center\n\\begin{tabular}{rlllll}\n\\toprule\ntrajectory storage & $\\epsilon = 0.0001$ & $\\epsilon = 0.001$ & $\\epsilon = 0.01$ & $\\epsilon = 0.1$ & $\\epsilon = 1$\\\\\n\\midrule\nno storage & 1727.8 & 1730.1 & 1729.3 & 1727.0 & 1728.8\\\\\n{\\textsc{Hrtc}\\xspace} compression & 1726.9 & 1727.2 & 1723.5 & 1728.4 & 1723.7\\\\\n\\textsc{Tng} compression & 1735.5 & 1723.5 & 1732.5 & 1729.9 & 1726.6\\\\ \n\\bottomrule\n\\end{tabular}\n\\label{heartofgold}\n\\end{table}\n\nWe measured the throughput of compression and decompression with\n  the same benchmark simulation used for the compression rate estimation.\nAs this simulation is executed on a general-purpose CPU,\n  it requires relatively large amounts of time to compute the pairwise forces in each step.\nThis made the overhead of compression statistically insignificant compared to the run-time variations of the simulation itself (see Table \\ref{heartofgold}).\nTo compare the throughput of different algorithms,\n  we thus measured the time taken to compress a $\\SI{114}{GiB}$ trajectory that was stored uncompressed on an SSD.\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,704){\\makebox(0,0)[r]{\\strut{} 0}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,1444){\\makebox(0,0)[r]{\\strut{} 20}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2184){\\makebox(0,0)[r]{\\strut{} 40}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2925){\\makebox(0,0)[r]{\\strut{} 60}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,3665){\\makebox(0,0)[r]{\\strut{} 80}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,4405){\\makebox(0,0)[r]{\\strut{} 100}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,484){\\makebox(0,0){\\strut{} 1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2509,484){\\makebox(0,0){\\strut{} 10}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3941,484){\\makebox(0,0){\\strut{} 100}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5372,484){\\makebox(0,0){\\strut{} 1000}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{} 10000}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}compression throughput ($\\SI{}{MiB/s}$)}}}\n      \\put(3940,154){\\makebox(0,0){\\strut{}trajectory speedup (sub-sampling rate)}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n      \\csname LTb\\endcsname\n      \\put(5816,4602){\\makebox(0,0)[r]{\\strut{}\\textsc{Hrtc}}}\n      \\csname LTb\\endcsname\n      \\put(5816,4382){\\makebox(0,0)[r]{\\strut{}\\textsc{Tng}}}\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{speed}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:speed}\n  Compression throughput in \\SI{}{MiB/s} of input data processed depending on trajectory velocity.\n  Trajectories with faster movement were obtained by sub-sampling a common trajectory:\n  A speedup of $n$ is equal to taking every $n$th frame.}\n\\end{figure}\n\nThe throughput of the tested algorithms depends on the magnitude of change of the trajectory to compress.\nTo simulate trajectories with different speed, we sub-sampled our test trajectory.\nA 1:$n$ subsampling results in a $n$-fold speedup of the trajectory to compress.\nThe throughput of \\textsc{Tng} and {\\textsc{Hrtc}\\xspace} compression are depicted in Figure~\\ref{fig:speed}.\nFor slowly varying trajectories (speed-up below 100), {\\textsc{Hrtc}\\xspace} performs around $\\SI{100}{MiB/s}$.\nFor speed-ups below factor $500$ {\\textsc{Hrtc}\\xspace} beats \\textsc{Tng} in terms of throughput.\nFor fast rates of change, {\\textsc{Hrtc}\\xspace}'s throughput converges against $\\SI{20}{MiB/s}$.\nOn the same dataset, the general purpose \\textsc{BZip2} compression achieves no more than $\\SI{7}{MiB/s}$.\n\nOn their own data, \\textsc{Marais} et al.~report compression rates between $13$ and $\\SI{39}{MiB/s}$.\\cite{Marais2012}\n\nA second test with naked {\\textsc{Hrtc}\\xspace} compression---without the overhead of integration into the \\textsc{Tng} library---reveals\n  the extremal throughput:\nA trajectory with constant particle position is compressed with $\\SI{520}{MiB/s}$ and decompressed with $\\SI{1838}{MiB/s}$.\nTrajectories with purely random positions reach $\\SI{65}{MiB/s}$ and $\\SI{40}{MiB/s}$ for compression and decompression respectively.\n\nAll throughput tests have been performed on a single core of\n  an Intel Xeon E5-2690 $\\SI{2.9}{GHz}$ CPU.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection*{Effect of error distribution between $\\bm{\\epsilon_q}$ and $\\bm{\\epsilon_f}$}\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,704){\\makebox(0,0)[r]{\\strut{}$10^{-4}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2061){\\makebox(0,0)[r]{\\strut{}$10^{-3}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,3418){\\makebox(0,0)[r]{\\strut{}$10^{-2}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,4775){\\makebox(0,0)[r]{\\strut{}$10^{-1}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,484){\\makebox(0,0){\\strut{} 0}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1651,484){\\makebox(0,0){\\strut{} 0.1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2223,484){\\makebox(0,0){\\strut{} 0.2}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2796,484){\\makebox(0,0){\\strut{} 0.3}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3368,484){\\makebox(0,0){\\strut{} 0.4}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3941,484){\\makebox(0,0){\\strut{} 0.5}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(4513,484){\\makebox(0,0){\\strut{} 0.6}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5086,484){\\makebox(0,0){\\strut{} 0.7}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5658,484){\\makebox(0,0){\\strut{} 0.8}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6230,484){\\makebox(0,0){\\strut{} 0.9}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{} 1}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}relative compressed size}}}\n      \\put(3940,154){\\makebox(0,0){\\strut{}error distribution coefficient $\\lambda$}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n      \\csname LTb\\endcsname\n      \\put(1937,4367){\\makebox(0,0){\\strut{}$\\xleftarrow[ \\displaystyle \\epsilon_q \\rightarrow 0       ]{\\hspace{3mm}\\displaystyle \\epsilon_f \\rightarrow \\epsilon\\hspace{3mm}}$}}\n      \\put(5658,2061){\\makebox(0,0){\\strut{}$\\xrightarrow[\\hspace{3mm}\\displaystyle \\epsilon_q \\rightarrow \\epsilon\\hspace{3mm}]{\\displaystyle \\epsilon_f \\rightarrow 0}$}}\n      {\\color[rgb]{{0.55,0.10,0.05}}}\n      \\put(1651,1334){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:1}}\n      {\\color[rgb]{{0.48,0.16,0.05}}}\n      \\put(1651,1649){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:2}}\n      {\\color[rgb]{{0.42,0.23,0.05}}}\n      \\put(1651,1994){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:4}}\n      {\\color[rgb]{{0.36,0.29,0.05}}}\n      \\put(1651,2347){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:8}}\n      {\\color[rgb]{{0.29,0.35,0.05}}}\n      \\put(1651,2728){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:16}}\n      {\\color[rgb]{{0.23,0.42,0.05}}}\n      \\put(1651,3132){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:32}}\n      {\\color[rgb]{{0.17,0.48,0.05}}}\n      \\put(1651,3583){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:64}}\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{qp-ratio}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:qp-ratio}\n  Compressed size depending on the error distribution coefficient $\\lambda$ relative to the uncompressed file.\n  Given the quantization error $\\epsilon_q = \\lambda \\epsilon$ and the approximation error $\\epsilon_f = (1 - \\lambda) \\epsilon$,\n    for $\\lambda \\approx 0$ the algorithm degrades to a kind of linear regression, and\n    for $\\lambda \\approx 1$ all error budget is used for quantization.\n  The algorithm then degrades to a linear extrapolation scheme similar to the one used by \\textsc{Marais et al}.\\cite{Marais2012}\n  The uncompressed data contained $10^4$ frames of $512$ particles with $3$ dimensions.\n  It was sub-sampled at eight different rates (1:1 - 1:64).\n  Compression was performed with total error $\\epsilon = 0.01$, block size $10^4$ using plain {\\textsc{Hrtc}\\xspace} (without \\textsc{Tng} metdata).}\n\\end{figure}\n\nIn the preceding sections we assumed the error budget $\\epsilon$ is equally distributed\n  between function approximation and quantization ($\\epsilon_q = \\epsilon_f = \\frac{1}{2}\\epsilon$).\nThe main motivation for that is to keep the number of parameters as small as possible.\nTo test whether this distribution is suitable, we parametrized the error distribution by $\\lambda \\in (0,1]$:\n\n", "itemtype": "equation", "pos": 38015, "prevtext": "\n\nThe update of the stored extrema can be modified in the same\nway. Update $x_\\bot \\leftarrow x'$ and $t_\\bot \\leftarrow t_1$ when\n\n", "index": 15, "text": "\\begin{align}\n                & &                                         v_\\bot &< \\frac{x' - x - \\epsilon_f}{\\Delta t} \\nonumber \\\\\n\\Leftrightarrow & & \\frac{x_\\bot - x' - \\epsilon_f}{\\Delta t_\\bot} &< \\frac{x' - x - \\epsilon_f}{\\Delta t} \\label{eqn:opt_update} \\\\\n\\Leftrightarrow & &     (x_\\bot - x' - \\epsilon_f) \\Delta t      &< (x' - x - \\epsilon_f)       \\Delta t_\\bot ~.\\nonumber\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle v_{\\bot}\" display=\"inline\"><msub><mi>v</mi><mo>\u22a5</mo></msub></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta t}\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\" display=\"inline\"><mo>\u21d4</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\frac{x_{\\bot}-x^{\\prime}-\\epsilon_{f}}{\\Delta t_{\\bot}}\" display=\"inline\"><mstyle displaystyle=\"true\"><mfrac><mrow><msub><mi>x</mi><mo>\u22a5</mo></msub><mo>-</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><msub><mi>t</mi><mo>\u22a5</mo></msub></mrow></mfrac></mstyle></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E12.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;\\frac{x^{\\prime}-x-\\epsilon_{f}}{\\Delta t}\" display=\"inline\"><mrow><mi/><mo>&lt;</mo><mstyle displaystyle=\"true\"><mfrac><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mrow><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></mfrac></mstyle></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\Leftrightarrow\" display=\"inline\"><mo>\u21d4</mo></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(x_{\\bot}-x^{\\prime}-\\epsilon_{f})\\Delta t\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi>x</mi><mo>\u22a5</mo></msub><mo>-</mo><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mi>t</mi></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m3\" class=\"ltx_Math\" alttext=\"\\displaystyle&lt;(x^{\\prime}-x-\\epsilon_{f})\\Delta t_{\\bot}~{}.\" display=\"inline\"><mrow><mrow><mi/><mo>&lt;</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><msup><mi>x</mi><mo>\u2032</mo></msup><mo>-</mo><mi>x</mi><mo>-</mo><msub><mi>\u03f5</mi><mi>f</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><mi mathvariant=\"normal\">\u0394</mi><mo>\u2062</mo><mpadded width=\"+3.3pt\"><msub><mi>t</mi><mo>\u22a5</mo></msub></mpadded></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.02687.tex", "nexttext": "\nWe then compressed the \\textsc{Tng} test data used above at different sub-sampling rates.\nWe compared the compression ratio achieved while varying $\\lambda$.\nThe result is depicted in Figure~\\ref{fig:qp-ratio}.\nBetween $0.01 \\le \\lambda \\le 0.5$ a plateau of the compression ratio can be seen independent of the sub-sampling rate.\nWhen spending more the $50\\%$ of the error budget on quantization the compression rate sharply decreases.\nThis effect is the more pronounced, the more volatile the trajectory is (at sub-sampling rates below $1:16$).\nWe have observed similar behavior for all other datasets we tested (data not shown).\n\n\\section*{Conclusions}\n\nWe have developed a novel compression algorithm specifically for storage of molecular dynamic trajectories.\nThe algorithm is lossy, with a user-specified error bound.\nBy splitting the available error budget between quantisation error and function approximation error,\n  we attain previously unachievable compression rates far below one bit per sample.\n\nEven when saving with high fidelity (small time steps) compression rate and throughput are  outstandingly high.\nThus, we propose to use our format as primary representation of simulation data coming out of MD simulation kernels.\nThis will reduce the bandwidth demands between simulation kernel and analysis tools.\nUsing the computed linear functions as primal data representation\n  will allow more integrated queries than the currently used uncompressed snapshots:\n  for example a check for the minimal distance between two particles\n    can be answered analytically on the level of segments, instead of iterating over all points.\n\nOur approach offers some simple, yet rewarding extension points.\nForemost, parallelization of the compression is trivial:\n  just compress subsets of the particles independently,\n    preferably on the same cores that compute these subsets.\nDue to better use of caches and smaller amounts of buffered support vectors\n  when waiting for the termination of long-lasting function segments,\n  we expect a super-linear speed-up from parallel execution.\n\nSecondly, performance gains can be achieved by tight integration of function approximation and\n  variable length integer representation (we used an external library so far).\nThis will save a whole pass over the data and allows to tune the integer compression parameters to the\n  expected distribution occurring in our use-case.\nAlternatively, an adaptive coder (e.g. entropy coder or arithmetic coder) could be employed.\nWhile this would result in a modest improvement of the compression rate (we estimate at most factor 2),\n  it would also reduce the throughput of our compression significantly.\n\nThirdly, integrating the \\textsc{Tng} library and {\\textsc{Hrtc}\\xspace} more tightly should offer significant performance benefits.\nWe demonstrated that the throughput of our naked {\\textsc{Hrtc}\\xspace} library is much higher than\n  our current integration into the \\textsc{Tng} library.\nThere is an impedance mismatch between both libraries.\nA deeper integration of {\\textsc{Hrtc}\\xspace} into \\textsc{Tng}\n  accompanied with some changes of \\textsc{Tng}'s architecture\n  to allow calling it inside the inner-most simulation loop without performance drawbacks\n  will lift trajectory compression to a new level.\n\n\\subsection*{Author Contributions}\n\nJan Huwald designed the algorithm and implemented it in the {\\textsc{Hrtc}\\xspace} library.\nStephan Richter integrated {\\textsc{Hrtc}\\xspace} into \\textsc{Tng}, generated the test data and executed the benchmarks.\nThe first draft was written jointly by Jan Huwald and Stephan Richter.\nPeter Dittrich was responsible for project supervision and intensive revision of the draft.\n\n\\subsection*{Acknowledgments}\n\nThe authors acknowledge support from the European Union through funding under FP7\u00e2\u0080\u0093ICT\u00e2\u0080\u00932011\u00e2\u0080\u00938 project HIERATIC (316705).\n\n\\bibliography{paper}\n\n\n", "itemtype": "equation", "pos": 72559, "prevtext": "\nAnalogous for $x_\\top$.\nImplementing eq.~\\ref{eqn:opt_check} and \\ref{eqn:opt_update} requires\n  13 additions, 6 multiplications, 2 conditional moves and one branch.\nAlthough the operation count is higher, expensive division and branch operations have been omitted.\n\n\\section*{Results and discussion}\n\nA library implementing the {\\textsc{Hrtc}\\xspace} algorithm as described above\n  is available under a GPL-3 open source license at \\url{https://github.com/biosystemanalysis/hrtc}.\nTo compare our compression algorithm with the state of the art,\n  we additionally integrated it into the \\textsc{trajectory-ng} library.\nThe merged library is available at \\url{https://github.com/biosystemanalysis/tng}.\n\n\\subsection*{{\\textsc{Hrtc}\\xspace} outperforms existing compression methods}\n\n\\textsc{Tng} comes with a benchmark application, used to compare compression algorithms, here.\nThe benchmark applies velocity verlet integration to simulate $512$ particles with a harmonic well potential\n  $U(\\Delta x) = \\sin(\\min(\\|\\Delta x\\|, \\frac{\\pi}{2})^2$ and an arbitrary mass $2$, and timestep $2\\cdot10^{-4}$ with arbitrary units (a.u.).\nInitially, the particles are distributed randomly in a $15\\times16\\times17$ (a.u.) cuboid and equilibriated for $10^5$ steps.\nAfter equilibration, this simulation is run for $10^7$ more timesteps to generate the benchmark trajectory.\nThe transient phase is omitted in order to avoid artifacts when applying different sub-sampling rates.\nThe resulting benchmark trajectory is then compressed using either \\textsc{Tng}s native compression algorithm or our {\\textsc{Hrtc}\\xspace} compression.\nWe compare compression rates while varying the sub-sampling rate, the number of frames per block, and the maximal error $\\epsilon$. \nThe results are depicted in Table \\ref{table:compression_rate}.\nThe remaining parameters are held constant during this paper:\n  chunk size is set to 1024 support vectors,\n  and block size to 2048 frames.\n\n{\\textsc{Hrtc}\\xspace} outperforms the \\textsc{Tng} compression in all cases,\n  except when a very coarse sub-sampling rate ($\\lesssim 1:1024$) is combined with high spatial resolution ($\\epsilon \\lesssim 0.001$).\nThese cases are practically irrelevant for two reasons:\n  First, in our example $\\epsilon = 0.0001$ corresponds to \\SI{18}{b} of position information per dimension---almost\n    equal to the \\SI{24}{b} of a single precision float mantissa.\n  And second, the position inaccuracy introduced by low temporal resolution far exceeds the error bound $0.0001$\n    even for minuscule particle velocities.\n\nFurthermore, {\\textsc{Hrtc}\\xspace} appears to outperform  all compression methods investigated by \\textsc{Marais, et al.}\\cite{Marais2012}\nAs neither their implementation nor their test data is public, we have to cautiously compare our benchmarks\n  despite them running on different datasets.\nThe best compression rate \\textsc{Marais'} algorithms achieves is $20.8$\n  with 1:2 sub-sampling, a \\SI{12}{b} quantization and \\SI{0.014}{\\angstrom} positional error.\nThis rate is overachieved by {\\textsc{Hrtc}\\xspace} already at the much coarser 1:32 sub-sampling\n  with much smaller error bound $\\epsilon=0.0001$---yielding a large buffer to compensate for the different datasets being used.\nAt a comparable error rate ($\\epsilon = 0.01$) and sub-sampling (1:2) {\\textsc{Hrtc}\\xspace} achieves a compression ratio of 3419.\n\n\n\n\n\n\n\n\\begin{table}\n\\center\n\\caption{Comparison of compression ratio (uncompressed size / compressed size)\n  for different error bounds $\\epsilon$ and sub-sampling rates.\nThe size of the original, uncompressed \\textsc{Tng} file was \\SI{114}{GiB}.\nThe compressed file sizes vary between \\SI{796}{KiB} and \\SI{7.0}{GiB}.\nNote that the sub-sampling factor is also included in the compression ratio.}\n\\scriptsize\n\\begin{tabular}{lrrrrrrrrrr}\n\\toprule\n\n\\multirow{2}{1.2cm}{Sampling rate} &\n\\multicolumn{2}{c}{$\\epsilon=1$} &\n\\multicolumn{2}{c}{$\\epsilon=0.1$} &\n\\multicolumn{2}{c}{$\\epsilon=0.01$} &\n\\multicolumn{2}{c}{$\\epsilon=0.001$} &\n\\multicolumn{2}{c}{$\\epsilon=0.0001$} \\\\\n\\cmidrule(r){2-3}\n\\cmidrule(r){4-5}\n\\cmidrule(r){6-7}\n\\cmidrule(r){8-9}\n\\cmidrule(r){10-11}\n\n& {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}       & \\textsc{Tng}          & {\\textsc{Hrtc}\\xspace}        & \\textsc{Tng} \\\\\n\\midrule\n\n1:1 & { \\FPeval\\ratio{120117548/{25508}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3132196}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{32960}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3139872}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{47908}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3188944}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{108388}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3610992}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{291956}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7329736}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:2 & { \\FPeval\\ratio{120117548/{13280}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1566364}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18260}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1572516}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{35136}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1619592}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{90604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2005048}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{256512}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5430348}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:4 & { \\FPeval\\ratio{120117548/{7228}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{783120}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{11768}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{788508}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{28632}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{833868}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{79764}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1218152}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{226132}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3173192}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:8 & { \\FPeval\\ratio{120117548/{4228}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{391824}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{8904}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{396808}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{24492}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{439968}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{70188}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{802236}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{198080}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1824716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:16 & { \\FPeval\\ratio{120117548/{2848}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{196172}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7352}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{200932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{21460}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{240560}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{61924}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{587932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{171904}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1032888}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:32 & { \\FPeval\\ratio{120117548/{2212}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{98024}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6520}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{102604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18892}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{140604}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{53828}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{389760}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{153696}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{573460}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:64 & { \\FPeval\\ratio{120117548/{1856}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{49276}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5776}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{53656}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{16700}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{90668}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{47184}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{223616}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{142152}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{316816}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:128 & { \\FPeval\\ratio{120117548/{1636}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{24896}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{5016}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{28972}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{14644}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{65132}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{42472}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{127112}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{131272}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{173628}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:256 & { \\FPeval\\ratio{120117548/{1452}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12700}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{4420}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{16484}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12916}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{45836}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{39020}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{71496}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{91656}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{99716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } \\\\\n1:512 & { \\FPeval\\ratio{120117548/{1212}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6248}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{3716}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{9828}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{10900}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{25252}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{31688}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{37744}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{51088}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{50688}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n1:1024 & { \\FPeval\\ratio{120117548/{932}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2960}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2908}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6064}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{8632}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12924}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18764}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{18576}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } & { \\FPeval\\ratio{120117548/{25712}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{22848}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n1:2048 & { \\FPeval\\ratio{120117548/{796}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{1648}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{2468}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{4540}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{6736}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{7072}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{11328}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{9508}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } & { \\FPeval\\ratio{120117548/{14388}} \\FPeval\\round{round(\\ratio:0)}  \\SI{\\round}{} } & { \\FPeval\\ratio{120117548/{12180}} \\FPeval\\round{round(\\ratio:0)}  \\textbf{\\SI[detect-weight]{\\round}{}} } \\\\\n\n\\bottomrule\n\\end{tabular}\n\\label{table:compression_rate}\n\\end{table}\n\n\\subsection*{Compressing below one bit per sample}\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,704){\\makebox(0,0)[r]{\\strut{} 0.01}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,2061){\\makebox(0,0)[r]{\\strut{} 0.1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,3418){\\makebox(0,0)[r]{\\strut{} 1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,4775){\\makebox(0,0)[r]{\\strut{} 10}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1210,484){\\makebox(0,0){\\strut{}$10^{-7}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2009,484){\\makebox(0,0){\\strut{}$10^{-6}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2808,484){\\makebox(0,0){\\strut{}$10^{-5}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3607,484){\\makebox(0,0){\\strut{}$10^{-4}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(4406,484){\\makebox(0,0){\\strut{}$10^{-3}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5205,484){\\makebox(0,0){\\strut{}$10^{-2}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6004,484){\\makebox(0,0){\\strut{}$10^{-1}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{}$10^{0}$}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}bit per sample}}}\n      \\put(4006,154){\\makebox(0,0){\\strut{}error bound $\\epsilon$}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{bps}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fluxkompensator}\n  Average number of bits required to compress one sample---the\n    position of one particle at one timepoint---depending on error bound $\\epsilon$.\n  A trajectory of $512$ particles over $10^7$ timesteps generated by the \\textsc{Tng} benchmark application\n    was compressed with 2048 frames per block.}\n\\end{figure}\n\nTo demonstrate the ability of our algorithm to reduce storage space needed per sample below the \\SI{1}{b} limit,\n  we compress a $2048$ frame $512$ particle simulation with varying error rates $\\epsilon$.\nFor values of $\\epsilon \\tilde{>} 0.0000006$ the average space demanded per sample drops below $\\SI{1}{b}$\n  (see Figure~\\ref{fluxkompensator}).\n\n\\subsection*{Compression is fast}\n\n\\begin{table}\n\\caption{Runtime (s) of an  MD simulation with the trajectory stored either with \\textsc{Tng}, {\\textsc{Hrtc}\\xspace}, or not at all.\n  The storage precision $\\epsilon$ is varied, but has almost no effect on the runtime.}\n\\center\n\\begin{tabular}{rlllll}\n\\toprule\ntrajectory storage & $\\epsilon = 0.0001$ & $\\epsilon = 0.001$ & $\\epsilon = 0.01$ & $\\epsilon = 0.1$ & $\\epsilon = 1$\\\\\n\\midrule\nno storage & 1727.8 & 1730.1 & 1729.3 & 1727.0 & 1728.8\\\\\n{\\textsc{Hrtc}\\xspace} compression & 1726.9 & 1727.2 & 1723.5 & 1728.4 & 1723.7\\\\\n\\textsc{Tng} compression & 1735.5 & 1723.5 & 1732.5 & 1729.9 & 1726.6\\\\ \n\\bottomrule\n\\end{tabular}\n\\label{heartofgold}\n\\end{table}\n\nWe measured the throughput of compression and decompression with\n  the same benchmark simulation used for the compression rate estimation.\nAs this simulation is executed on a general-purpose CPU,\n  it requires relatively large amounts of time to compute the pairwise forces in each step.\nThis made the overhead of compression statistically insignificant compared to the run-time variations of the simulation itself (see Table \\ref{heartofgold}).\nTo compare the throughput of different algorithms,\n  we thus measured the time taken to compress a $\\SI{114}{GiB}$ trajectory that was stored uncompressed on an SSD.\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,704){\\makebox(0,0)[r]{\\strut{} 0}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,1444){\\makebox(0,0)[r]{\\strut{} 20}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2184){\\makebox(0,0)[r]{\\strut{} 40}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2925){\\makebox(0,0)[r]{\\strut{} 60}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,3665){\\makebox(0,0)[r]{\\strut{} 80}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,4405){\\makebox(0,0)[r]{\\strut{} 100}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,484){\\makebox(0,0){\\strut{} 1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2509,484){\\makebox(0,0){\\strut{} 10}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3941,484){\\makebox(0,0){\\strut{} 100}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5372,484){\\makebox(0,0){\\strut{} 1000}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{} 10000}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}compression throughput ($\\SI{}{MiB/s}$)}}}\n      \\put(3940,154){\\makebox(0,0){\\strut{}trajectory speedup (sub-sampling rate)}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n      \\csname LTb\\endcsname\n      \\put(5816,4602){\\makebox(0,0)[r]{\\strut{}\\textsc{Hrtc}}}\n      \\csname LTb\\endcsname\n      \\put(5816,4382){\\makebox(0,0)[r]{\\strut{}\\textsc{Tng}}}\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{speed}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:speed}\n  Compression throughput in \\SI{}{MiB/s} of input data processed depending on trajectory velocity.\n  Trajectories with faster movement were obtained by sub-sampling a common trajectory:\n  A speedup of $n$ is equal to taking every $n$th frame.}\n\\end{figure}\n\nThe throughput of the tested algorithms depends on the magnitude of change of the trajectory to compress.\nTo simulate trajectories with different speed, we sub-sampled our test trajectory.\nA 1:$n$ subsampling results in a $n$-fold speedup of the trajectory to compress.\nThe throughput of \\textsc{Tng} and {\\textsc{Hrtc}\\xspace} compression are depicted in Figure~\\ref{fig:speed}.\nFor slowly varying trajectories (speed-up below 100), {\\textsc{Hrtc}\\xspace} performs around $\\SI{100}{MiB/s}$.\nFor speed-ups below factor $500$ {\\textsc{Hrtc}\\xspace} beats \\textsc{Tng} in terms of throughput.\nFor fast rates of change, {\\textsc{Hrtc}\\xspace}'s throughput converges against $\\SI{20}{MiB/s}$.\nOn the same dataset, the general purpose \\textsc{BZip2} compression achieves no more than $\\SI{7}{MiB/s}$.\n\nOn their own data, \\textsc{Marais} et al.~report compression rates between $13$ and $\\SI{39}{MiB/s}$.\\cite{Marais2012}\n\nA second test with naked {\\textsc{Hrtc}\\xspace} compression---without the overhead of integration into the \\textsc{Tng} library---reveals\n  the extremal throughput:\nA trajectory with constant particle position is compressed with $\\SI{520}{MiB/s}$ and decompressed with $\\SI{1838}{MiB/s}$.\nTrajectories with purely random positions reach $\\SI{65}{MiB/s}$ and $\\SI{40}{MiB/s}$ for compression and decompression respectively.\n\nAll throughput tests have been performed on a single core of\n  an Intel Xeon E5-2690 $\\SI{2.9}{GHz}$ CPU.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\subsection*{Effect of error distribution between $\\bm{\\epsilon_q}$ and $\\bm{\\epsilon_f}$}\n\n\\begin{figure}\n\n\\begingroup\n  \\makeatletter\n  \\providecommand\\color[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package color not loaded in conjunction with\n      terminal option `colourtext'\n    }{See the gnuplot documentation for explanation.\n    }{Either use 'blacktext' in gnuplot or load the package\n      color.sty in LaTeX.}\n    \\renewcommand\\color[2][]{}\n  }\n  \\providecommand\\includegraphics[2][]{\n    \\GenericError{(gnuplot) \\space\\space\\space\\@spaces}{\n      Package graphicx or graphics not loaded\n    }{See the gnuplot documentation for explanation.\n    }{The gnuplot epslatex terminal needs graphicx.sty or graphics.sty.}\n    \\renewcommand\\includegraphics[2][]{}\n  }\n  \\providecommand\\rotatebox[2]{#2}\n  \\@ifundefined{ifGPcolor}{\n    \\newif\\ifGPcolor\n    \\GPcolortrue\n  }{}\n  \\@ifundefined{ifGPblacktext}{\n    \\newif\\ifGPblacktext\n    \\GPblacktexttrue\n  }{}\n  \n  \\let\\gplgaddtomacro\\g@addto@macro\n  \n  \\gdef\\gplbacktext{}\n  \\gdef\\gplfronttext{}\n  \\makeatother\n  \\ifGPblacktext\n    \n    \\def\\colorrgb#1{}\n    \\def\\colorgray#1{}\n  \\else\n    \n    \\ifGPcolor\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color[rgb]{1,0,0}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color[rgb]{0,1,0}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color[rgb]{0,0,1}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color[rgb]{1,0,1}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color[rgb]{0,1,1}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color[rgb]{1,1,0}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color[rgb]{0,0,0}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color[rgb]{1,0.3,0}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color[rgb]{0.5,0.5,0.5}}\n    \\else\n      \n      \\def\\colorrgb#1{\\color{black}}\n      \\expandafter\\def\\csname LTw\\endcsname{\\color{white}}\n      \\expandafter\\def\\csname LTb\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LTa\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT0\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT1\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT2\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT3\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT4\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT5\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT6\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT7\\endcsname{\\color{black}}\n      \\expandafter\\def\\csname LT8\\endcsname{\\color{black}}\n    \\fi\n  \\fi\n  \\setlength{\\unitlength}{0.0500bp}\n  \\begin{picture}(7200.00,5040.00)\n    \\gplgaddtomacro\\gplbacktext{\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,704){\\makebox(0,0)[r]{\\strut{}$10^{-4}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,2061){\\makebox(0,0)[r]{\\strut{}$10^{-3}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,3418){\\makebox(0,0)[r]{\\strut{}$10^{-2}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(946,4775){\\makebox(0,0)[r]{\\strut{}$10^{-1}$}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1078,484){\\makebox(0,0){\\strut{} 0}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(1651,484){\\makebox(0,0){\\strut{} 0.1}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2223,484){\\makebox(0,0){\\strut{} 0.2}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(2796,484){\\makebox(0,0){\\strut{} 0.3}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3368,484){\\makebox(0,0){\\strut{} 0.4}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(3941,484){\\makebox(0,0){\\strut{} 0.5}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(4513,484){\\makebox(0,0){\\strut{} 0.6}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5086,484){\\makebox(0,0){\\strut{} 0.7}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(5658,484){\\makebox(0,0){\\strut{} 0.8}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6230,484){\\makebox(0,0){\\strut{} 0.9}}\n      {\\color[rgb]{{0.25,0.25,0.25}}}\n      \\put(6803,484){\\makebox(0,0){\\strut{} 1}}\n      \\csname LTb\\endcsname\n      \\put(176,2739){\\rotatebox{-270}{\\makebox(0,0){\\strut{}relative compressed size}}}\n      \\put(3940,154){\\makebox(0,0){\\strut{}error distribution coefficient $\\lambda$}}\n    }\n    \\gplgaddtomacro\\gplfronttext{\n      \\csname LTb\\endcsname\n      \\put(1937,4367){\\makebox(0,0){\\strut{}$\\xleftarrow[ \\displaystyle \\epsilon_q \\rightarrow 0       ]{\\hspace{3mm}\\displaystyle \\epsilon_f \\rightarrow \\epsilon\\hspace{3mm}}$}}\n      \\put(5658,2061){\\makebox(0,0){\\strut{}$\\xrightarrow[\\hspace{3mm}\\displaystyle \\epsilon_q \\rightarrow \\epsilon\\hspace{3mm}]{\\displaystyle \\epsilon_f \\rightarrow 0}$}}\n      {\\color[rgb]{{0.55,0.10,0.05}}}\n      \\put(1651,1334){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:1}}\n      {\\color[rgb]{{0.48,0.16,0.05}}}\n      \\put(1651,1649){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:2}}\n      {\\color[rgb]{{0.42,0.23,0.05}}}\n      \\put(1651,1994){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:4}}\n      {\\color[rgb]{{0.36,0.29,0.05}}}\n      \\put(1651,2347){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:8}}\n      {\\color[rgb]{{0.29,0.35,0.05}}}\n      \\put(1651,2728){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:16}}\n      {\\color[rgb]{{0.23,0.42,0.05}}}\n      \\put(1651,3132){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:32}}\n      {\\color[rgb]{{0.17,0.48,0.05}}}\n      \\put(1651,3583){\\makebox(0,0)[l]{\\strut{}\\footnotesize 1:64}}\n    }\n    \\gplbacktext\n    \\put(0,0){\\includegraphics{qp-ratio}}\n    \\gplfronttext\n  \\end{picture}\n\\endgroup\n\n\\caption{\\label{fig:qp-ratio}\n  Compressed size depending on the error distribution coefficient $\\lambda$ relative to the uncompressed file.\n  Given the quantization error $\\epsilon_q = \\lambda \\epsilon$ and the approximation error $\\epsilon_f = (1 - \\lambda) \\epsilon$,\n    for $\\lambda \\approx 0$ the algorithm degrades to a kind of linear regression, and\n    for $\\lambda \\approx 1$ all error budget is used for quantization.\n  The algorithm then degrades to a linear extrapolation scheme similar to the one used by \\textsc{Marais et al}.\\cite{Marais2012}\n  The uncompressed data contained $10^4$ frames of $512$ particles with $3$ dimensions.\n  It was sub-sampled at eight different rates (1:1 - 1:64).\n  Compression was performed with total error $\\epsilon = 0.01$, block size $10^4$ using plain {\\textsc{Hrtc}\\xspace} (without \\textsc{Tng} metdata).}\n\\end{figure}\n\nIn the preceding sections we assumed the error budget $\\epsilon$ is equally distributed\n  between function approximation and quantization ($\\epsilon_q = \\epsilon_f = \\frac{1}{2}\\epsilon$).\nThe main motivation for that is to keep the number of parameters as small as possible.\nTo test whether this distribution is suitable, we parametrized the error distribution by $\\lambda \\in (0,1]$:\n\n", "index": 17, "text": "\\begin{align}\n\\epsilon_q = \\lambda \\epsilon, \\quad \\epsilon_f = (1 - \\lambda) \\epsilon_q\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E13.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\epsilon_{q}=\\lambda\\epsilon,\\quad\\epsilon_{f}=(1-\\lambda)%&#10;\\epsilon_{q}\" display=\"inline\"><mrow><mrow><msub><mi>\u03f5</mi><mi>q</mi></msub><mo>=</mo><mrow><mi>\u03bb</mi><mo>\u2062</mo><mi>\u03f5</mi></mrow></mrow><mo rspace=\"12.5pt\">,</mo><mrow><msub><mi>\u03f5</mi><mi>f</mi></msub><mo>=</mo><mrow><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>-</mo><mi>\u03bb</mi></mrow><mo stretchy=\"false\">)</mo></mrow><mo>\u2062</mo><msub><mi>\u03f5</mi><mi>q</mi></msub></mrow></mrow></mrow></math>", "type": "latex"}]