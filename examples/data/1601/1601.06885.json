[{"file": "1601.06885.tex", "nexttext": "\n\\end{example}\n\nThe derivative of ${\\boldsymbol x}$, denoted by $\\partial({\\boldsymbol x})={\\boldsymbol x}'$ is a vector given by ${\\boldsymbol x}' = (x_1,x_2+x_1,x_3+x_2,\\ldots, x_n+x_{n-1})$. Observe that the mapping between ${\\boldsymbol x}$ and ${\\boldsymbol x}'$ is a bijection. Hence the integral $\\partial^{-1}({\\boldsymbol x})\\triangleq  \\overline{{\\boldsymbol x}}$ is well-defined for all ${\\boldsymbol x}\\in \\mathbb{F}_2^n$. With a slight abuse of notation, for a set ${\\cal X} \\subseteq \\mathbb{F}_2^n$, we denote ${\\cal X}'$ to be the result of taking the derivitive of every vector in ${\\cal X}$ and similarly we denote $\\overline{{\\cal X}}$ to be the result of taking the integral of every vector in ${\\cal X}$. For two vectors ${\\boldsymbol x}, {\\boldsymbol y} \\in \\mathbb{F}_2^n$, let $d_H({\\boldsymbol x}, {\\boldsymbol y})$ denote their Hamming distance. Furthermore, we denote by ${\\cal C}_H(n,d)$ a code of length $n$ with minimum Hamming distance $d$ and by ${\\cal C}_{D}(n)$ a single-deletion-correcting code of length $n$.\n\nIn the next section, we make use of these transformations to construct codes capable of correcting a single deletion or a single adjacent transposition, which we define to be \\emph{single transposition or deletion correcting codes}.\n\n\\section{Single Transposition or Deletion Correcting Codes}\\label{sec:basics}\n\nIn this section, we first give a general construction for single transposition or deletion correcting codes. We will then show how to use this construction in order to construct codes with almost optimal redundancy.\n\n\\begin{Construction}\\label{cons:T-D codes}\nLet ${\\cal C}_H(n,3)$ be a single-error-correcting code and ${\\cal C}_D(n)$ be a single-deletion-correcting code. The code $ {\\cal C}_{T \\lor D}(n)$ is defined as follows.\n\n", "itemtype": "equation", "pos": 7055, "prevtext": "\n\n\\title{Codes in the Damerau Distance for DNA Storage}\n\\author{\n  \\IEEEauthorblockN{\n    Ryan~Gabrys\\IEEEauthorrefmark{1}\\IEEEauthorrefmark{2},~ \n    Eitan~Yaakobi~\\IEEEauthorrefmark{3},~and\n    Olgica~Milenkovic\\IEEEauthorrefmark{1}}\n  {\\normalsize\n    \\begin{tabular}{ccc}\n      \\IEEEauthorrefmark{1}ECE Department, University of Illinois, Urbana-Champaign &\n      \\IEEEauthorrefmark{2}Spawar Systems Center, Pacific & \\IEEEauthorrefmark{3}Technion University\\\\\n           \n    \\end{tabular}}\\vspace{-3ex}\n   \n    }\n    \n\\maketitle\n\\begin{abstract} We introduce the new problem of code design in the Damerau metric. The Damerau metric is a generalization of the Levenshtein distance which also allows for adjacent transposition edits. We first provide constructions for codes that may correct either a single deletion or a single adjacent transposition and then proceed to extend these results to codes that can simultaneously correct a single deletion and multiple adjacent transpositions.\n\\end{abstract}\n\n\\vspace{-1.0ex}\\section{Introduction} \\label{sec:intro}\n\nThe edit distance is a measure of similarity between two strings evaluated based on the minimum number of operations required to transform one string into the other. If the operations are confined to symbol deletions, insertions and substitutions, the distance of interest is the Levenshtein distance~\\cite{levenshtein1966binary}. The Levenshtein distance has found numerous applications in bioinformatics, where a weighted version of this metric is used to assess the similarity of DNA strings and construct phylogenetic trees~\\cite{kumar2004mega3}, and natural language processing, where the distance is used to model spelling errors and provide automated word corrections~\\cite{brill2000improved}.\n\nIn parallel to the work on developing efficient algorithms for computing the edit distance and performing alignments of large number of strings, a long line of results were reported on the topic of designing codes in the Levenshtein distance. Classical derivations of upper bounds by Levenshtein~\\cite{levenshtein1966binary} and single-deletion correcting code constructions by Varshamov and Tenengol'ts~\\cite{varshamov1965code,sloane2002single} established the framework for studying many challenging problems in optimal code design for this metric~\\cite{schulman1999asymptotically,helberg2002multiple,brakensiek2015efficient}.\n \nDespite this apparent interest in coding for edit channels, the problem of designing codes in the Damerau distance was not analyzed before. A possible reason for this lack of interest in the Damerau distance may be attributed to the fact that not many models for practical channels involve adjacent transposition errors, and even if they do so, they tend not to allow for user-selected messages. Our motivating application for studying codes in the Damerau distance is the emergent paradigm of DNA-based storage~\\cite{church2012next,goldman2013towards,yazdi2014dna,yazdi2015dna}. In these systems, media degradation arises due to DNA aging caused by metabolic and hydrolitic processes, or more precisely, by exposure to standard or increased level radiation, humidity, and high temperatures. As an example, human cellular DNA undergoes anywhere between 10-50 breakages in a cell cycle~\\cite{vilenchik2003endogenous}. These DNA breakages or symbol/block of symbol deletions result in a changed structures of the string: if a string breaks in two places, which is the most likely scenario, either the sequence reattaches itself without resulting in structural damage, reattaches itself in the opposite direction, resulting in what is call a \\emph{reversal error}, or the broken string degrades, resulting in a bursty deletion; if a string breaks in three positions, which is the second most likely breakage scenario, either the adjacent broken blocks exchange positions or one or both block disintegrate leading to a bursty deletion. It is the latter scenario that motivates the study of channels in which adjacent blocks of symbols may be exchanges or individual blocks deleted. It is straightforward to see that this editing scenario corresponds to a ``block version'' of the Damerau editing process. The block editing process is hard to analyze directly, and we hence propose to first study the symbol-level Damerau editing process. Extensions to the block model will be described in the journal version of the paper.\n\nThe paper is organized as follows. Section~\\ref{sec:notation} contains the problem statement and relevant notation. Section~\\ref{sec:basics} contains an analysis of the code design procedure for single deletion or single adjacent transposition correction. Section~\\ref{sec:main} contains our main contributions: an order optimal code construction for correcting a single deletion and a single adjacent transposition, as well a low-redundancy construction for codes correcting a single deletion and multiple adjacent transpositions. Independently on their use for DNA-based storage systems, our results shed light on the problem of \\emph{mismatched} Varshamov-Tenengoltz (VT) decoding and run length limited VT codes.  \n\n\\vspace{-0.5ex}\\section{Notation}\\label{sec:notation}\n\nWe start by defining the \\emph{Damerau-Levenshtein distance} and its block-version, which arose by the works of Damerau~\\cite{damerau1964technique} and Levenshtein~\\cite{levenshtein1966binary}. \n\\begin{definition}\nThe \\textbf{Damerau--Levenshtein distance} is a string metric, which for two strings $\\textbf{a}$ and $\\textbf{b}$ of length $n_a$ and $n_b$ over some finite alphabet equals the minimum number of insertions, deletions, substitutions and adjacent transposition edits needed to transform one string into the other. The \\textbf{block Damerau--Levenshtein distance} with block length $b$ is a string metric, which for two strings $\\textbf{a}$ and $\\textbf{b}$ of length $n_a$ and $n_b$ over some finite alphabet equals the minimum number of insertions, deletions, substitutions and adjacent transposition edits of blocks of length at most $b$ needed to transform one string into the other.\n\\end{definition}\n\nFor simplicity, we focus on edits involving deletions and adjacent transpositions only and refer to the metric as the Damerau metric, denoted by $D(\\textbf{a},\\textbf{b})$. Furthermore, we restrict our attention to binary alphabets as the generalizations of our results to larger alphabets are straightforward to obtain through Tenegolts up-down encoding, as described in~\\cite{paluncic2011note,le2015new}. Details of the approach will be provided in the full version of the paper.\n\n\n\nFor a vector ${\\boldsymbol x} \\in \\mathbb{F}_2^n$, let ${\\cal B}({\\boldsymbol x})$ denote the set of vectors that may be obtained from ${\\boldsymbol x}$ by either a single deletion or at most a single adjacent transposition. Note that the size of ${\\cal B}({\\boldsymbol x})$ is $2r({\\boldsymbol x})$, where $r({\\boldsymbol x})$ is the number of runs in ${\\boldsymbol x}$.\n\\begin{example} Suppose that ${\\boldsymbol x}=(0,0,1,1,0) \\in \\mathbb{F}_2^n$. Then,\n\n", "index": 1, "text": "\\begin{align}\n{\\cal B}({\\boldsymbol x}) = \\{ &(0,1,1,0), (0,0,1,0), (0,0,1,1), \\notag \\\\\n&(0,0,1,1,0),(0,1,0,1,0), (0,0,1,0,1) \\}. \\notag\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\cal B}({\\boldsymbol{x}})=\\{\" display=\"inline\"><mrow><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc99</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mo stretchy=\"false\">{</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(0,1,1,0),(0,0,1,0),(0,0,1,1),\" display=\"inline\"><mrow><mrow><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle(0,0,1,1,0),(0,1,0,1,0),(0,0,1,0,1)\\}.\" display=\"inline\"><mrow><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": " \n\\end{Construction}\n\n\n\nNote that the code ${\\cal C}_{T \\lor  D}(n)$ is defined to be set of the codewords which belong to a single-deletion-correcting code while their integral belong to a single-error-correcting code. The correctness of this construction is proven next.\n\\begin{lemma}\\label{lem:t1} \nThe code $ {\\cal C}_{T \\lor D}(n)$ from Construction~\\ref{cons:T-D codes} is a single transposition or deletion correcting code.\n\n\n\\end{lemma}\n\\begin{IEEEproof} \nWe prove this claim by showing that for all ${\\boldsymbol x} \\in {\\cal C}_{T \\lor D}(n)$, one can uniquely recover ${\\boldsymbol x}$ from any ${\\boldsymbol z} \\in {\\cal B}({\\boldsymbol x})$. \n\nAssume first that ${\\boldsymbol z} \\in \\mathbb{F}_2^{n-1}$, so that ${\\boldsymbol z}$ is the result of a single deletion occurring in ${\\boldsymbol x}$. Since $ {\\boldsymbol x} \\in {\\cal C}_{D}(n)$, one may apply the decoder of the code ${\\cal C}_D(n)$ to successfully recover ${\\boldsymbol x} \\in {\\cal C}_{T \\lor D}(n)$.\n\nNow assume that ${\\boldsymbol z} \\in \\mathbb{F}_2^{n}$, so that ${\\boldsymbol z}$ is the result of at most one single transposition occurring in ${\\boldsymbol x}$. We show that $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) {\\leqslant} 1$. Then since $\\overline{{\\boldsymbol x}}$ belongs to a code with minimum Hamming distance $3$, the vector $\\overline{{\\boldsymbol x}}$ can be uniquely determined from $\\overline{{\\boldsymbol z}}$. Notice first that since the mapping $\\partial$ is injective, $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) =0$ if and only if $\\overline{{\\boldsymbol x}} = \\overline{{\\boldsymbol z}}$.\n\nAssume then that the transmitted word ${\\boldsymbol x}$ was subjected to one adjacent transposition occurring at the $i$th and $(i+1)$th bits,  so that $x_i \\neq x_{i+1}$ and ${\\boldsymbol z}= (x_1,\\ldots,x_{i-1},x_{i+1},x_i,x_{i+2},\\ldots, x_n)$. First, we compute $\\overline{{\\boldsymbol z}}$, defined as \n\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\end{example}\n\nThe derivative of ${\\boldsymbol x}$, denoted by $\\partial({\\boldsymbol x})={\\boldsymbol x}'$ is a vector given by ${\\boldsymbol x}' = (x_1,x_2+x_1,x_3+x_2,\\ldots, x_n+x_{n-1})$. Observe that the mapping between ${\\boldsymbol x}$ and ${\\boldsymbol x}'$ is a bijection. Hence the integral $\\partial^{-1}({\\boldsymbol x})\\triangleq  \\overline{{\\boldsymbol x}}$ is well-defined for all ${\\boldsymbol x}\\in \\mathbb{F}_2^n$. With a slight abuse of notation, for a set ${\\cal X} \\subseteq \\mathbb{F}_2^n$, we denote ${\\cal X}'$ to be the result of taking the derivitive of every vector in ${\\cal X}$ and similarly we denote $\\overline{{\\cal X}}$ to be the result of taking the integral of every vector in ${\\cal X}$. For two vectors ${\\boldsymbol x}, {\\boldsymbol y} \\in \\mathbb{F}_2^n$, let $d_H({\\boldsymbol x}, {\\boldsymbol y})$ denote their Hamming distance. Furthermore, we denote by ${\\cal C}_H(n,d)$ a code of length $n$ with minimum Hamming distance $d$ and by ${\\cal C}_{D}(n)$ a single-deletion-correcting code of length $n$.\n\nIn the next section, we make use of these transformations to construct codes capable of correcting a single deletion or a single adjacent transposition, which we define to be \\emph{single transposition or deletion correcting codes}.\n\n\\section{Single Transposition or Deletion Correcting Codes}\\label{sec:basics}\n\nIn this section, we first give a general construction for single transposition or deletion correcting codes. We will then show how to use this construction in order to construct codes with almost optimal redundancy.\n\n\\begin{Construction}\\label{cons:T-D codes}\nLet ${\\cal C}_H(n,3)$ be a single-error-correcting code and ${\\cal C}_D(n)$ be a single-deletion-correcting code. The code $ {\\cal C}_{T \\lor D}(n)$ is defined as follows.\n\n", "index": 3, "text": "$$ {\\cal C}_{T \\lor D}(n)= \\{ {\\boldsymbol x} \\in \\mathbb{F}_2^n : {\\boldsymbol x}\\in {\\cal C}_{D}(n), \\overline{{\\boldsymbol x}} \\in {\\cal C}_H(n,3) \\}.$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex3.m1\" class=\"ltx_Math\" alttext=\"{\\cal C}_{T\\lor D}(n)=\\{{\\boldsymbol{x}}\\in\\mathbb{F}_{2}^{n}:{\\boldsymbol{x}}%&#10;\\in{\\cal C}_{D}(n),\\overline{{\\boldsymbol{x}}}\\in{\\cal C}_{H}(n,3)\\}.\" display=\"block\"><mrow><mrow><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mi>T</mi><mo>\u2228</mo><mi>D</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mrow><mi>\ud835\udc99</mi><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup></mrow><mo>:</mo><mrow><mrow><mi>\ud835\udc99</mi><mo>\u2208</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>D</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mover accent=\"true\"><mi>\ud835\udc99</mi><mo>\u00af</mo></mover><mo>\u2208</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>H</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo stretchy=\"false\">}</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\nLet $\\overline{{\\boldsymbol x}} = ( \\overline{x}_1, \\ldots, \\overline{x}_n)$. Then, clearly $(\\overline{x}_1, \\ldots, \\overline{x}_{i-1}) = (\\overline{z}_1, \\ldots, \\overline{z}_{i-1})$. Furthermore, \n\n", "itemtype": "equation", "pos": 11089, "prevtext": " \n\\end{Construction}\n\n\n\nNote that the code ${\\cal C}_{T \\lor  D}(n)$ is defined to be set of the codewords which belong to a single-deletion-correcting code while their integral belong to a single-error-correcting code. The correctness of this construction is proven next.\n\\begin{lemma}\\label{lem:t1} \nThe code $ {\\cal C}_{T \\lor D}(n)$ from Construction~\\ref{cons:T-D codes} is a single transposition or deletion correcting code.\n\n\n\\end{lemma}\n\\begin{IEEEproof} \nWe prove this claim by showing that for all ${\\boldsymbol x} \\in {\\cal C}_{T \\lor D}(n)$, one can uniquely recover ${\\boldsymbol x}$ from any ${\\boldsymbol z} \\in {\\cal B}({\\boldsymbol x})$. \n\nAssume first that ${\\boldsymbol z} \\in \\mathbb{F}_2^{n-1}$, so that ${\\boldsymbol z}$ is the result of a single deletion occurring in ${\\boldsymbol x}$. Since $ {\\boldsymbol x} \\in {\\cal C}_{D}(n)$, one may apply the decoder of the code ${\\cal C}_D(n)$ to successfully recover ${\\boldsymbol x} \\in {\\cal C}_{T \\lor D}(n)$.\n\nNow assume that ${\\boldsymbol z} \\in \\mathbb{F}_2^{n}$, so that ${\\boldsymbol z}$ is the result of at most one single transposition occurring in ${\\boldsymbol x}$. We show that $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) {\\leqslant} 1$. Then since $\\overline{{\\boldsymbol x}}$ belongs to a code with minimum Hamming distance $3$, the vector $\\overline{{\\boldsymbol x}}$ can be uniquely determined from $\\overline{{\\boldsymbol z}}$. Notice first that since the mapping $\\partial$ is injective, $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) =0$ if and only if $\\overline{{\\boldsymbol x}} = \\overline{{\\boldsymbol z}}$.\n\nAssume then that the transmitted word ${\\boldsymbol x}$ was subjected to one adjacent transposition occurring at the $i$th and $(i+1)$th bits,  so that $x_i \\neq x_{i+1}$ and ${\\boldsymbol z}= (x_1,\\ldots,x_{i-1},x_{i+1},x_i,x_{i+2},\\ldots, x_n)$. First, we compute $\\overline{{\\boldsymbol z}}$, defined as \n\n", "index": 5, "text": "$$\\overline{{\\boldsymbol z}}= (z_1,z_2+z_1,z_3+z_2+z_1,\\ldots,\\sum_{j=1}^n z_j)=(\\overline{z}_1, \\ldots, \\overline{z}_n).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex4.m1\" class=\"ltx_Math\" alttext=\"\\overline{{\\boldsymbol{z}}}=(z_{1},z_{2}+z_{1},z_{3}+z_{2}+z_{1},\\ldots,\\sum_{%&#10;j=1}^{n}z_{j})=(\\overline{z}_{1},\\ldots,\\overline{z}_{n}).\" display=\"block\"><mrow><mrow><mover accent=\"true\"><mi>\ud835\udc9b</mi><mo>\u00af</mo></mover><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><mrow><msub><mi>z</mi><mn>2</mn></msub><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>z</mi><mn>3</mn></msub><mo>+</mo><msub><mi>z</mi><mn>2</mn></msub><mo>+</mo><msub><mi>z</mi><mn>1</mn></msub></mrow><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>z</mi><mi>j</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">(</mo><msub><mover accent=\"true\"><mi>z</mi><mo>\u00af</mo></mover><mn>1</mn></msub><mo>,</mo><mi mathvariant=\"normal\">\u2026</mi><mo>,</mo><msub><mover accent=\"true\"><mi>z</mi><mo>\u00af</mo></mover><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": " \nand for any $k {\\geqslant} i+1$, $\\overline{z}_{k} = \\sum_{j=1}^{i-1} x_j + x_{i+1} + x_i + \\sum_{j=i+2}^{n} x_j = \\overline{x}_{k}$, so that $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) = 1$ as desired.\n\\end{IEEEproof}\n\nNotice that we did not specify in Construction~\\ref{cons:T-D codes} the specific codes to be used in the construction. A first attempt for these codes is using a Hamming code as the single-error-correcting code and the Varshamov-Tenengoltz (VT) code as the single-deletion code~\\cite{levenshtein1966binary}. We could also use any coset of these codes and since the cosets of these codes cover the entire space $\\mathbb{F}_2^n$, one can derive that there exists a code with redundancy at most $2\\log (n+1)$. Next, we would like to show how to improve this result by presenting a code which can serve both as the single-deletion-correcting for ${\\boldsymbol x}$ and the single-error-correcting code for $\\overline{{\\boldsymbol x}}$. Using this result we will be able to construct codes with redundancy at most $\\log(n)+3$.\n\n\n\nOur choice of codes is the following. Let $a$ be a non-negative integer $0{\\leqslant} a{\\leqslant} 6n-2$.  For the single-deletion code, we make use of the code\n\n", "itemtype": "equation", "pos": -1, "prevtext": "\nLet $\\overline{{\\boldsymbol x}} = ( \\overline{x}_1, \\ldots, \\overline{x}_n)$. Then, clearly $(\\overline{x}_1, \\ldots, \\overline{x}_{i-1}) = (\\overline{z}_1, \\ldots, \\overline{z}_{i-1})$. Furthermore, \n\n", "index": 7, "text": "$$\\overline{z}_i = \\sum_{j=1}^{i-1} x_j + x_{i+1} = \\sum_{j=1}^{i-1} x_j + (1 + x_{i}) = \\bar{x}_i + 1,$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex5.m1\" class=\"ltx_Math\" alttext=\"\\overline{z}_{i}=\\sum_{j=1}^{i-1}x_{j}+x_{i+1}=\\sum_{j=1}^{i-1}x_{j}+(1+x_{i})%&#10;=\\bar{x}_{i}+1,\" display=\"block\"><mrow><mrow><msub><mover accent=\"true\"><mi>z</mi><mo>\u00af</mo></mover><mi>i</mi></msub><mo>=</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi><mi>j</mi></msub></mrow><mo>+</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mo>=</mo><mrow><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi><mi>j</mi></msub></mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>+</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mover accent=\"true\"><mi>x</mi><mo stretchy=\"false\">\u00af</mo></mover><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\nFor the code ${\\cal C}_H(n,3)$, we make use of the code \n\n", "itemtype": "equation", "pos": 12743, "prevtext": " \nand for any $k {\\geqslant} i+1$, $\\overline{z}_{k} = \\sum_{j=1}^{i-1} x_j + x_{i+1} + x_i + \\sum_{j=i+2}^{n} x_j = \\overline{x}_{k}$, so that $d_H(\\overline{{\\boldsymbol x}}, \\overline{{\\boldsymbol z}}) = 1$ as desired.\n\\end{IEEEproof}\n\nNotice that we did not specify in Construction~\\ref{cons:T-D codes} the specific codes to be used in the construction. A first attempt for these codes is using a Hamming code as the single-error-correcting code and the Varshamov-Tenengoltz (VT) code as the single-deletion code~\\cite{levenshtein1966binary}. We could also use any coset of these codes and since the cosets of these codes cover the entire space $\\mathbb{F}_2^n$, one can derive that there exists a code with redundancy at most $2\\log (n+1)$. Next, we would like to show how to improve this result by presenting a code which can serve both as the single-deletion-correcting for ${\\boldsymbol x}$ and the single-error-correcting code for $\\overline{{\\boldsymbol x}}$. Using this result we will be able to construct codes with redundancy at most $\\log(n)+3$.\n\n\n\nOur choice of codes is the following. Let $a$ be a non-negative integer $0{\\leqslant} a{\\leqslant} 6n-2$.  For the single-deletion code, we make use of the code\n\n", "index": 9, "text": "\\begin{align*}\n\\textbf{Y}_D(n,a) =& \\{ {\\boldsymbol y} \\in \\mathbb{F}_2^n:  \\sum_{i=1}^{n-1} i \\, y_i + \\\\\n&\\ \\ (2n-1) \\, y_n \\equiv \\,a\\, \\bmod (6n-3) \\}.\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{Y}_{D}(n,a)=\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc18</mtext><mi>D</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex6.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{{\\boldsymbol{y}}\\in\\mathbb{F}_{2}^{n}:\\sum_{i=1}^{n-1}i\\,y_{i}+\" display=\"inline\"><mrow><mrow><mrow><mi mathvariant=\"normal\">{</mi><mo>\u2062</mo><mi>\ud835\udc9a</mi></mrow><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup></mrow><mo>:</mo><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><mpadded width=\"+1.7pt\"><mi>i</mi></mpadded><mo>\u2062</mo><msub><mi>y</mi><mi>i</mi></msub></mrow></mrow><mo>+</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex7.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\ \\ (2n-1)\\,y_{n}\\equiv\\,a\\,\\bmod(6n-3)\\}.\" display=\"inline\"><mrow><mpadded width=\"+5pt\"><mi mathvariant=\"normal\">\u00a0</mi></mpadded><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo>-</mo><mn>1</mn><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><msub><mi>y</mi><mi>n</mi></msub><mo rspace=\"4.2pt\">\u2261</mo><mpadded width=\"+1.7pt\"><mi>a</mi></mpadded><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mi>n</mi><mo>-</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\n\\begin{claim}\\label{cl:eq}\nFor any vector ${\\boldsymbol x}\\in\\mathbb{F}_2^n$, if ${\\boldsymbol x}' \\in \\textbf{Y}_D(n,a)$ then ${\\boldsymbol x} \\in \\textbf{Y}_H(n,a)$ and thus if ${\\boldsymbol x}\\in \\textbf{Y}_D(n,a)$ then $\\overline{{\\boldsymbol x}} \\in \\textbf{Y}_H(n,a)$.\n\\end{claim}\n\n\\vspace{-1.5ex}According to Claim~\\ref{cl:eq} and Lemma~\\ref{lem:t1}, the code ${\\cal C}_{T \\lor D}(n)= \\textbf{Y}_D(n,a)$ is a single transposition or deletion correcting code. We are left to show that the codes $\\textbf{Y}_D(n,a)$ and $\\textbf{Y}_H(n,a)$ have the desired properties. \n\n\\vspace{-0.5ex}\\begin{lemma} \nThe code $\\textbf{Y}_{H}(n,a)$ is a single-error-correcting code. \\vspace{-2.5ex}\n\\end{lemma}\n\\begin{lemma} \n\\vspace{-0.5ex}The code $\\textbf{Y}_D(n,a)$ can correct a single deletion.\n\\end{lemma}\n\nThe following corollary summarizes the result in this section.\\vspace{-0.5ex}\n\\begin{corollary} \nThere exists a single transposition or deletion correcting code whose redundancy is at most $\\log(6n-3)$ bits. \n\\end{corollary}\n\\vspace{-1.5ex}\\begin{IEEEproof}\nWhen applying the codes $\\textbf{Y}_D(n,a)$ and $\\textbf{Y}_H(n,a)$ in Construction~\\ref{cons:T-D codes}, we got that ${\\cal C}_{T \\lor D}(n)= \\textbf{Y}_D(n,a)$. Since the codes ${\\cal C}_{T \\lor D}(a,n)$ for $0{\\leqslant} a {\\leqslant} 6n-2$ partition the space $\\mathbb{F}_2^n$, we get that there exists such a code with redundancy at most $\\log(6n-3)$.\n\n\n\\end{IEEEproof}\n\nNote that every single transposition or deletion correcting code is in particular a single-deletion code. Since the lower bound on the latter codes is $\\log(n)$~\\cite{6497614}, the difference between the redundancy of our codes and the optimal redundancy is at most $\\log 6$ bits.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Codes Correcting Deletions and Adjacent Transpositions} \\label{sec:main}\n\nWe now turn our attention to the significantly more challenging task of constructing codes that can correct both deletions and adjacent transpositions simultaneously. Our main result is a construction of a code capable of correcting a single deletion along with multiple adjacent transpositions. At the end of this section, we derive an improved construction for the case of a single deletion and a single transposition. \n\n\nWe first introduce some useful notation. Let ${\\cal B}_{(T,\\ell)}({\\boldsymbol x})$ denote the set of vectors that may be obtained by applying at most $\\ell$ adjacent transpositions to ${\\boldsymbol x}$.  We define ${\\cal B}_{(T,\\ell)}({\\boldsymbol x}) \\triangleq \\underbrace{{\\cal B}_{(T,1)}( \\cdots( {\\cal B}_{(T,1)}(}_{\\text{$\\ell$ times}} {\\boldsymbol x} ) \\cdots ))$, so that a vector $(0,0,1)$ can be converted to $(1,0,0)$ with two adjacent transpositions. That is, we allow bits to change their positions by more a single location. Let ${\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ denote the set of vectors that may be obtained from ${\\boldsymbol x}$ by at most $\\ell$ adjacent transpositions followed by a single deletion. Let ${\\cal B}_D({\\boldsymbol x})$ be the set of words that may be obtained by applying a single deletion to ${\\boldsymbol x}$. With a slight abuse of notation, we use the same symbols for the sets ${\\cal B}$ when their arguments are collections of words, rather than just one word. In this case, the sets ${\\cal B}$ equal the union of the sets corresponding to each individual word in the collection. The next example illustrates the previously described notation.\n\n\\vspace{-0.5ex}\\begin{example} Suppose that ${\\boldsymbol x}=(0,0,1,1,0)$. Then, ${\\cal B}_{(T,1)}({\\boldsymbol x}) = \\{ (0,0,1,1,0),$ $(0,1,0,1,0),$ $(0,0,1,0,1) \\}$, ${\\cal B}_{D}({\\boldsymbol x})= \\{ (0,1,1,0),$ $(0,0,1,0),$ $(0,0,1,1) \\}$, ${\\cal B}_{(T,1),D}({\\boldsymbol x}) = \\{ (0,1,1,0),$ $(0,0,1,0),$ $(0,0,1,1)$, $(1,0,1,0), (0,1,0,1),$ $(0,1,0,0),$ $(0,0,0,1)  \\}$.\n\\end{example}\n\n\\vspace{-1.5ex}\\begin{lemma}\\label{lem:order} For any ${\\boldsymbol x} \\in \\mathbb{F}_2^n$, \n\n", "itemtype": "equation", "pos": 12969, "prevtext": "\nFor the code ${\\cal C}_H(n,3)$, we make use of the code \n\n", "index": 11, "text": "\\begin{align*}\n\\textbf{Y}_H(n,a) &= \\{ {\\boldsymbol y} \\in \\mathbb{F}_2^n:  \\sum_{i=1}^{n-2} (2i+1) \\, y_i + (2(n-1)+1) \\, y_{n}  \\notag \\\\\n&+(3(n-1) + 1) \\, y_{n-1}  \\equiv a \\bmod (6n-3) \\bigg\\}. \\notag\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{Y}_{H}(n,a)\" display=\"inline\"><mrow><msub><mtext>\ud835\udc18</mtext><mi>H</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo stretchy=\"false\">)</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex8.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle=\\{{\\boldsymbol{y}}\\in\\mathbb{F}_{2}^{n}:\\sum_{i=1}^{n-2}(2i+1)\\,%&#10;y_{i}+(2(n-1)+1)\\,y_{n}\" display=\"inline\"><mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>\ud835\udc9a</mi><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup><mo>:</mo><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></munderover></mstyle><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><msub><mi>y</mi><mi>i</mi></msub><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><mn>1</mn><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><msub><mi>y</mi><mi>n</mi></msub></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex9.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle+(3(n-1)+1)\\,y_{n-1}\\equiv a\\bmod(6n-3)\\bigg{\\}}.\" display=\"inline\"><mrow><mo>+</mo><mrow><mo stretchy=\"false\">(</mo><mn>3</mn><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo>+</mo><mn>1</mn><mo rspace=\"4.2pt\" stretchy=\"false\">)</mo></mrow><msub><mi>y</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>\u2261</mo><mi>a</mi><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mi>n</mi><mo>-</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><mo maxsize=\"210%\" minsize=\"210%\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": " \n\\end{lemma}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs a consequence of the previous lemma, we may hence assume that the deletion always occurs after the adjacent transposition. We say that a code ${\\cal C}$ can correct $\\ell$ adjacent transpositions and a single deletion, and denote it by a \\emph{$\\ell$-TD code} if for any two different codewords ${\\boldsymbol x},{\\boldsymbol y}\\in {\\cal C}$, ${\\cal B}_{(T,\\ell),D}({\\boldsymbol x})\\cap{\\cal B}_{(T,\\ell),D}({\\boldsymbol y}) =\\emptyset$. \nOur code construction and the ideas behind our approach are best explained by describing the decoding procedure. \n\nSuppose that the code ${\\cal C}_{T \\land D}(n,\\ell)$ is an $\\ell$-TD code, which is a subcode of a single-deletion-correcting code. Assume also that  ${\\boldsymbol x} \\in {\\cal C}_{T \\land D}(n,\\ell)$ was transmitted and the vector ${\\boldsymbol y}$ was received, where ${\\boldsymbol y}$ is the result of at most $\\ell$ transpositions followed by a single deletion occurring to ${\\boldsymbol x}$. The simplest idea to pursue is to try to correct the single deletion by naively applying the decoder for the chosen constituent single-deletion code. Clearly, such a decoder will produce an erroneous result due to the presence of the  adjacent transposition errors. It is therefore important to construct the code ${\\cal C}_{T \\land D}(n,\\ell)$ in such a way that the result of the ``mismatched'' deletion correction $\\widehat{{\\boldsymbol x}}$, obtained from ${\\boldsymbol y}$, is easy to characterize and contains only a limited number of errors that may be corrected to recover ${\\boldsymbol x} \\in {\\cal C}(n,\\ell)$ from $\\widehat{{\\boldsymbol x}}$.\n\nTo this end, define the following VT code ${\\cal C}_{VT}(n,a,\\ell)$ to be\n\\vspace{-0.5ex}\n", "itemtype": "equation", "pos": -1, "prevtext": "\n\\begin{claim}\\label{cl:eq}\nFor any vector ${\\boldsymbol x}\\in\\mathbb{F}_2^n$, if ${\\boldsymbol x}' \\in \\textbf{Y}_D(n,a)$ then ${\\boldsymbol x} \\in \\textbf{Y}_H(n,a)$ and thus if ${\\boldsymbol x}\\in \\textbf{Y}_D(n,a)$ then $\\overline{{\\boldsymbol x}} \\in \\textbf{Y}_H(n,a)$.\n\\end{claim}\n\n\\vspace{-1.5ex}According to Claim~\\ref{cl:eq} and Lemma~\\ref{lem:t1}, the code ${\\cal C}_{T \\lor D}(n)= \\textbf{Y}_D(n,a)$ is a single transposition or deletion correcting code. We are left to show that the codes $\\textbf{Y}_D(n,a)$ and $\\textbf{Y}_H(n,a)$ have the desired properties. \n\n\\vspace{-0.5ex}\\begin{lemma} \nThe code $\\textbf{Y}_{H}(n,a)$ is a single-error-correcting code. \\vspace{-2.5ex}\n\\end{lemma}\n\\begin{lemma} \n\\vspace{-0.5ex}The code $\\textbf{Y}_D(n,a)$ can correct a single deletion.\n\\end{lemma}\n\nThe following corollary summarizes the result in this section.\\vspace{-0.5ex}\n\\begin{corollary} \nThere exists a single transposition or deletion correcting code whose redundancy is at most $\\log(6n-3)$ bits. \n\\end{corollary}\n\\vspace{-1.5ex}\\begin{IEEEproof}\nWhen applying the codes $\\textbf{Y}_D(n,a)$ and $\\textbf{Y}_H(n,a)$ in Construction~\\ref{cons:T-D codes}, we got that ${\\cal C}_{T \\lor D}(n)= \\textbf{Y}_D(n,a)$. Since the codes ${\\cal C}_{T \\lor D}(a,n)$ for $0{\\leqslant} a {\\leqslant} 6n-2$ partition the space $\\mathbb{F}_2^n$, we get that there exists such a code with redundancy at most $\\log(6n-3)$.\n\n\n\\end{IEEEproof}\n\nNote that every single transposition or deletion correcting code is in particular a single-deletion code. Since the lower bound on the latter codes is $\\log(n)$~\\cite{6497614}, the difference between the redundancy of our codes and the optimal redundancy is at most $\\log 6$ bits.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\section{Codes Correcting Deletions and Adjacent Transpositions} \\label{sec:main}\n\nWe now turn our attention to the significantly more challenging task of constructing codes that can correct both deletions and adjacent transpositions simultaneously. Our main result is a construction of a code capable of correcting a single deletion along with multiple adjacent transpositions. At the end of this section, we derive an improved construction for the case of a single deletion and a single transposition. \n\n\nWe first introduce some useful notation. Let ${\\cal B}_{(T,\\ell)}({\\boldsymbol x})$ denote the set of vectors that may be obtained by applying at most $\\ell$ adjacent transpositions to ${\\boldsymbol x}$.  We define ${\\cal B}_{(T,\\ell)}({\\boldsymbol x}) \\triangleq \\underbrace{{\\cal B}_{(T,1)}( \\cdots( {\\cal B}_{(T,1)}(}_{\\text{$\\ell$ times}} {\\boldsymbol x} ) \\cdots ))$, so that a vector $(0,0,1)$ can be converted to $(1,0,0)$ with two adjacent transpositions. That is, we allow bits to change their positions by more a single location. Let ${\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ denote the set of vectors that may be obtained from ${\\boldsymbol x}$ by at most $\\ell$ adjacent transpositions followed by a single deletion. Let ${\\cal B}_D({\\boldsymbol x})$ be the set of words that may be obtained by applying a single deletion to ${\\boldsymbol x}$. With a slight abuse of notation, we use the same symbols for the sets ${\\cal B}$ when their arguments are collections of words, rather than just one word. In this case, the sets ${\\cal B}$ equal the union of the sets corresponding to each individual word in the collection. The next example illustrates the previously described notation.\n\n\\vspace{-0.5ex}\\begin{example} Suppose that ${\\boldsymbol x}=(0,0,1,1,0)$. Then, ${\\cal B}_{(T,1)}({\\boldsymbol x}) = \\{ (0,0,1,1,0),$ $(0,1,0,1,0),$ $(0,0,1,0,1) \\}$, ${\\cal B}_{D}({\\boldsymbol x})= \\{ (0,1,1,0),$ $(0,0,1,0),$ $(0,0,1,1) \\}$, ${\\cal B}_{(T,1),D}({\\boldsymbol x}) = \\{ (0,1,1,0),$ $(0,0,1,0),$ $(0,0,1,1)$, $(1,0,1,0), (0,1,0,1),$ $(0,1,0,0),$ $(0,0,0,1)  \\}$.\n\\end{example}\n\n\\vspace{-1.5ex}\\begin{lemma}\\label{lem:order} For any ${\\boldsymbol x} \\in \\mathbb{F}_2^n$, \n\n", "index": 13, "text": "$${\\cal B}_{(T,\\ell),D}({\\boldsymbol x}) = {\\cal B}_D({\\cal B}_{(T,\\ell)}({\\boldsymbol x})) = {\\cal B}_{(T,\\ell)}({\\cal B}_D({\\boldsymbol x})).$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex10.m1\" class=\"ltx_Math\" alttext=\"{\\cal B}_{(T,\\ell),D}({\\boldsymbol{x}})={\\cal B}_{D}({\\cal B}_{(T,\\ell)}({%&#10;\\boldsymbol{x}}))={\\cal B}_{(T,\\ell)}({\\cal B}_{D}({\\boldsymbol{x}})).\" display=\"block\"><mrow><mrow><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow><mo>,</mo><mi>D</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc99</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mi>D</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc99</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\u212c</mi><mi>D</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>\ud835\udc99</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\n\nAs a VT code, the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ can correct a single deletion occurring in a codeword ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$~\\cite{sloane2002single}.\n\nAs before, and for the special case of VT codes, assume that $\\widehat{{\\boldsymbol x}}$ is the result of VT decoding the vector ${\\boldsymbol y}$ where ${\\boldsymbol y}\\in{\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$. Our first aim is to characterize the difference between $\\widehat{{\\boldsymbol x}}$ and ${\\boldsymbol x}$, and for this purpose we use an intermediary word ${\\boldsymbol y}^{(\\ell)}$ that is generated from at most $\\ell$ adjacent transpositions in ${\\boldsymbol x}$, that is ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol y}^{(\\ell)})$. \n\nMore precisely, we demonstrate that if both ${\\boldsymbol x}, {\\boldsymbol y}^{(\\ell)} \\in {\\cal C}_{VT}(n,a,\\ell)$, then ${\\cal D}_{VT,n,\\ell}(a,{\\boldsymbol x})$ and ${\\cal D}_{VT,n,\\ell}(a,{\\boldsymbol y}^{(\\ell)})$ differ only in the transpositions which converted ${\\boldsymbol x}$ to ${\\boldsymbol y}^{(\\ell)}$. On the other hand, if ${\\boldsymbol x}, {\\boldsymbol y}^{(\\ell)}$ belong to two different VT codes (i.e. they have different values of the parameter $a$ when VT-transformed), then  ${\\boldsymbol x}$ and $\\widehat{{\\boldsymbol x}}$ differ by at most $2\\ell$ adjacent transpositions. The following simple claim is a consequence of the fact that an adjacent transposition changes the VT syndrome by at most one.\n\n\\vspace{-0.5ex}\\begin{claim}\\label{cl:trans} Suppose that ${\\boldsymbol y}^{(\\ell)}=(y^{(\\ell)}_1, \\ldots, y^{(\\ell)}_n) \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x})$ where ${\\boldsymbol x} \\in \\mathbb{F}_2^n$. Then, one has\n$| \\sum_{i=1}^n i \\cdot x_i - \\sum_{i=1}^n i \\cdot y^{(\\ell)}_i | {\\leqslant} \\ell.$\n\\end{claim}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\vspace{-0.5ex}As a consequence of the previous claim, if ${\\boldsymbol x} \\in{\\cal C}_{VT}(n,a,\\ell)$ and ${\\boldsymbol y}^{(\\ell)} \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x})$, then ${\\boldsymbol y}^{(\\ell)} \\in {\\cal C}_{VT}(n,\\hat{a},\\ell)$ for some $\\hat{a}$, where \n$ | a - \\hat{a} | {\\leqslant} \\ell. $ The next lemma summarizes the previous discussion.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:equiv} Suppose that ${\\boldsymbol y}^{(\\ell)} \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$, and let ${\\boldsymbol y}\\in{\\cal B}_{D}({\\boldsymbol y}^{(\\ell)})$. Then, ${\\cal D}_{VT,n,\\ell}(\\hat{a},{\\boldsymbol y})={\\boldsymbol y}^{(\\ell)}$ for some $\\hat{a}$ such that $|a - \\hat{a}| {\\leqslant} \\ell$. \\vspace{-0.5ex}\n\\end{lemma}\n\n\\begin{example} Suppose that ${\\boldsymbol x}=(0,1,1,0,0,1,0,\\textcolor{red}{0},0,0,1,0) \\in {\\cal C}(12, \\textcolor{blue}{3}, 3)$ was transmitted and that the vector \n${\\boldsymbol y} = (0,1,1,0,$ $0,1,0,0,$ $\\textcolor{red}{1},\\textcolor{red}{0},0) $ was received after at most three adjacent transpositions and a single deletion.\nFor ${\\boldsymbol y}^{(3)} =  (0,1,1,0,$ $0,1,0,\\textcolor{red}{0},$ $0, \\textcolor{red}{1},\\textcolor{red}{0},0)$ (where ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol y}^{(3)})$, we have $\\sum_{i=1}^{n-1} y_i \\equiv 2 \\bmod 19$. Thus, since $a=3$ and $\\hat{a}=2$, we get that $|a - \\hat{a}| {\\leqslant} 1 {\\leqslant} \\ell = 3$ as desired.\n\n\nNotice that if we apply the decoder ${\\cal D}_{VT,12,3}$ we get $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,12,3}(\\textcolor{blue}{3},{\\boldsymbol y}) = (0,1,1,0,0,\\textcolor{blue}{0},1,0,0,\\textcolor{red}{1},\\textcolor{red}{0},0)$. Here, we have\n$\\widehat{{\\boldsymbol x}}=(0,1,1,0,0,\\textcolor{blue}{0},1,0,0,\\textcolor{red}{1},\\textcolor{red}{0},0),$ and\n${\\boldsymbol x}=(0,1,1,0,0,1,0,\\textcolor{red}{0},0,0,1,0).$\n\\end{example}\n\n\\vspace{-0.5ex}We want next to characterize the difference between ${\\cal D}_{VT,n,\\ell}(a, {\\boldsymbol y})$ and ${\\cal D}_{VT,n,\\ell}(\\hat{a}, {\\boldsymbol y})$ for the case that $|a - \\hat{a}| {\\leqslant} \\ell$, as the value $\\hat{a}$ is unknown beforehand. \n\nOur main result may be intuitively described as follows: suppose that ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$ and ${\\boldsymbol y}$ is obtained by deleting the $k$th bit, $x_k$, from ${\\boldsymbol x}$ and the value of $x_k$ is known to the decoder. Assume that $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,n,\\ell}(a+v,{\\boldsymbol y})$, for some offset $v$, is obtained by inserting the bit $x_k $ in ${\\boldsymbol y}$. \nThen, if $x_k=0$, we may obtain ${\\boldsymbol x}$ from $\\widehat{{\\boldsymbol x}}$ by sliding the inserted bit to the left/right using a series adjacent transposition operations past at most $v$ ones. Otherwise, if $x_k=1$, then we can obtain ${\\boldsymbol x}$ from $\\widehat{{\\boldsymbol x}}$ by sliding the inserted bit to the left/right past at most $v$ zeros. The next lemma rigorously summarizes this observation.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:similar2} Suppose that ${\\boldsymbol y}$ is the result of a single deletion occurring in ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$ at position $k$. Given $k$, let $v_L=|\\{ j \\in [n] : j < k, x_j=1 \\}|$ and $v_R=|\\{ j \\in [n] : j > k, x_j=1 \\}|$. Then, \n\\begin{enumerate}\n\\item If $x_k=0$, then for all $v \\in \\{-v_R, -v_R+1, \\ldots, v_L\\}$, one may obtain ${\\cal D}_{VT,n,\\ell}(a+v,{\\boldsymbol y})$ by inserting the symbol $0$ in ${\\boldsymbol y}$ immediately after the $(v_L-v)$-th one. \n\\item If $x_k=1$, then for all $v \\in \\{-(k-1)+v_L, -k+v_L+2,$ $\\ldots, (n-k)-v_R \\}$, one may obtain ${\\cal D}_{VT,n,\\ell}( a + v,{\\boldsymbol y})$ by inserting the symbol $1$ in ${\\boldsymbol y}$ immediately after the $(v+k-v_L-1)$-th zero.\n\\end{enumerate}\n\\end{lemma}\n\n\\vspace{-0.5ex}\\begin{example} Suppose that ${\\boldsymbol x}=(0,1,1,0, \\textcolor{red}{0},1,0,\\textcolor{black}{0},0,0,1,0) \\in {\\cal C}(12, 3, 3)$, and that $ {\\boldsymbol x} = {\\cal D}_{VT,n,\\ell}(3,{\\boldsymbol y}),$\nwas obtained by VT decoding ${\\boldsymbol y} = (0,1,1,0,1,0,\\textcolor{black}{0},0,0,1,0)$. For $v=2$, one has \n${\\cal D}_{VT,n,\\ell}(5,{\\boldsymbol y})=(\\textcolor{red}{0},0,1,1,0,1,0,0,0,0,1,0),$\nwhereas for $v=-1$, one has \n${\\cal D}_{VT,n,\\ell}(2,{\\boldsymbol y})=({0},1,1,0,1,\\textcolor{red}{0},0,0,0,0,1,0).$\n\nNext, suppose that ${\\boldsymbol y} = (0,1,1,0,0,0,0,0,0,1,0)$ -- i.e., ${\\boldsymbol y}$ is the result of deleting the third $1$ at position $k=6$ from ${\\boldsymbol x}=(0,1,1,0, \\textcolor{black}{0},$ $\\textcolor{red}{1},0,\\textcolor{black}{0},$ $0,0,1,0)$. In this case, choosing $v=3$ gives $ {\\cal D}_{VT,n,\\ell}(6,{\\boldsymbol y})=(0,1,1,0,0,0,0,0,\\textcolor{red}{1},0,1,0)$, while $v=-2$ gives \n$ {\\cal D}_{VT,n,\\ell}(1,{\\boldsymbol y})=(0,\\textcolor{red}{1},1,1,0,0,0,0,0,0,1,0).$\n\\end{example}\n\n\\vspace{-0.5ex}{ {\\textit{Proof of Lemma~8:}} Suppose first that ${\\boldsymbol y}$ is the result of deleting a zero from ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$. Let $a' = a - \\sum_{i=1}^{n-1} i \\cdot y_i \\bmod (n+ 2\\ell+1)$. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ produces the vector $\\widehat{{\\boldsymbol x}} \\in {\\cal C}_{VT}(n,a,\\ell)$ by inserting a zero into the first position $k'$ that has $a'$ ones to the right of it. If $x_k=0$, then clearly $a' = v_R$, $k'=k$, and the decoder correctly outputs ${\\boldsymbol x}$ so that $\\widehat{{\\boldsymbol x}} = {\\boldsymbol x}$. If the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ were applied to ${\\boldsymbol y}$ instead, one would have\n\n", "itemtype": "equation", "pos": 19045, "prevtext": " \n\\end{lemma}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs a consequence of the previous lemma, we may hence assume that the deletion always occurs after the adjacent transposition. We say that a code ${\\cal C}$ can correct $\\ell$ adjacent transpositions and a single deletion, and denote it by a \\emph{$\\ell$-TD code} if for any two different codewords ${\\boldsymbol x},{\\boldsymbol y}\\in {\\cal C}$, ${\\cal B}_{(T,\\ell),D}({\\boldsymbol x})\\cap{\\cal B}_{(T,\\ell),D}({\\boldsymbol y}) =\\emptyset$. \nOur code construction and the ideas behind our approach are best explained by describing the decoding procedure. \n\nSuppose that the code ${\\cal C}_{T \\land D}(n,\\ell)$ is an $\\ell$-TD code, which is a subcode of a single-deletion-correcting code. Assume also that  ${\\boldsymbol x} \\in {\\cal C}_{T \\land D}(n,\\ell)$ was transmitted and the vector ${\\boldsymbol y}$ was received, where ${\\boldsymbol y}$ is the result of at most $\\ell$ transpositions followed by a single deletion occurring to ${\\boldsymbol x}$. The simplest idea to pursue is to try to correct the single deletion by naively applying the decoder for the chosen constituent single-deletion code. Clearly, such a decoder will produce an erroneous result due to the presence of the  adjacent transposition errors. It is therefore important to construct the code ${\\cal C}_{T \\land D}(n,\\ell)$ in such a way that the result of the ``mismatched'' deletion correction $\\widehat{{\\boldsymbol x}}$, obtained from ${\\boldsymbol y}$, is easy to characterize and contains only a limited number of errors that may be corrected to recover ${\\boldsymbol x} \\in {\\cal C}(n,\\ell)$ from $\\widehat{{\\boldsymbol x}}$.\n\nTo this end, define the following VT code ${\\cal C}_{VT}(n,a,\\ell)$ to be\n\\vspace{-0.5ex}\n", "index": 15, "text": "\\begin{align*}\n{\\cal C}_{VT}(n,a,\\ell) = \\{ &{\\boldsymbol x} \\in \\mathbb{F}_2^n : \\sum_{i=1}^n i \\cdot x_i \\equiv a \\bmod (n+2\\ell+1) \\}. \\nonumber\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\cal C}_{VT}(n,a,\\ell)=\\{\" display=\"inline\"><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mi>V</mi><mo>\u2062</mo><mi>T</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mo stretchy=\"false\">{</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex11.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{x}}\\in\\mathbb{F}_{2}^{n}:\\sum_{i=1}^{n}i\\cdot x_{i}%&#10;\\equiv a\\bmod(n+2\\ell+1)\\}.\" display=\"inline\"><mrow><mi>\ud835\udc99</mi><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup><mo>:</mo><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mstyle><mi>i</mi><mo>\u22c5</mo><msub><mi>x</mi><mi>i</mi></msub><mo>\u2261</mo><mi>a</mi><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mi mathvariant=\"normal\">\u2113</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\nHence, the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ would insert a zero in the vector ${\\boldsymbol y}$ at the first position $k''$ that has $a' + v$ ones to the right of it. The claim follows by observing that the position that has $a'+v$ ones after it is in the same run as the position in ${\\boldsymbol y}$ with $(v_L-v)$ ones preceding it.\n\n\nSuppose now that ${\\boldsymbol y}$ is the result deleting a one from ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$. Let $a' = a - \\sum_{i=1}^{n-1} i \\cdot y_i \\bmod (n+2\\ell+1)$. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ produces the vector $\\widehat{{\\boldsymbol x}} \\in {\\cal C}_{VT}(n,a,\\ell)$ by inserting a one into the first position $k'$ that has $a'-k'$ ones to the right of it. If $x_k=1$, then clearly $k' = k$ and the decoder correctly outputs ${\\boldsymbol x}$, and hence $\\widehat{{\\boldsymbol x}} = {\\boldsymbol x}$. \n\nIf the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ were applied to ${\\boldsymbol y}$ instead, then $a''  \\equiv a' + v \\bmod (n+2\\ell+1)$ as before. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ would insert a one in the vector ${\\boldsymbol y}$ into the first position $k''$ that has $a' + v - k''$ ones to the right of it. This produces a vector $\\widehat{{\\boldsymbol x}}$. Since the first position $k''$ in ${\\boldsymbol y}$ with $a' + v - k''$ ones to the right is the same as the first position in ${\\boldsymbol y}$ following $(v+k-v_L-1)$ zeros, the claimed result also follows for $x_k=1$. \n$\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\blacksquare$} \\vspace{-0.5ex}\\\\\n\nThe previous lemma allows us to propose a modification of a VT code capable of correcting a deletion and multiple adjacent transpositions. Furthermore, it leads to a straightforward decoding architecture for the proposed code. Formally,\n\\vspace{-0.5ex}\n", "itemtype": "equation", "pos": 26656, "prevtext": "\n\nAs a VT code, the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ can correct a single deletion occurring in a codeword ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$~\\cite{sloane2002single}.\n\nAs before, and for the special case of VT codes, assume that $\\widehat{{\\boldsymbol x}}$ is the result of VT decoding the vector ${\\boldsymbol y}$ where ${\\boldsymbol y}\\in{\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$. Our first aim is to characterize the difference between $\\widehat{{\\boldsymbol x}}$ and ${\\boldsymbol x}$, and for this purpose we use an intermediary word ${\\boldsymbol y}^{(\\ell)}$ that is generated from at most $\\ell$ adjacent transpositions in ${\\boldsymbol x}$, that is ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol y}^{(\\ell)})$. \n\nMore precisely, we demonstrate that if both ${\\boldsymbol x}, {\\boldsymbol y}^{(\\ell)} \\in {\\cal C}_{VT}(n,a,\\ell)$, then ${\\cal D}_{VT,n,\\ell}(a,{\\boldsymbol x})$ and ${\\cal D}_{VT,n,\\ell}(a,{\\boldsymbol y}^{(\\ell)})$ differ only in the transpositions which converted ${\\boldsymbol x}$ to ${\\boldsymbol y}^{(\\ell)}$. On the other hand, if ${\\boldsymbol x}, {\\boldsymbol y}^{(\\ell)}$ belong to two different VT codes (i.e. they have different values of the parameter $a$ when VT-transformed), then  ${\\boldsymbol x}$ and $\\widehat{{\\boldsymbol x}}$ differ by at most $2\\ell$ adjacent transpositions. The following simple claim is a consequence of the fact that an adjacent transposition changes the VT syndrome by at most one.\n\n\\vspace{-0.5ex}\\begin{claim}\\label{cl:trans} Suppose that ${\\boldsymbol y}^{(\\ell)}=(y^{(\\ell)}_1, \\ldots, y^{(\\ell)}_n) \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x})$ where ${\\boldsymbol x} \\in \\mathbb{F}_2^n$. Then, one has\n$| \\sum_{i=1}^n i \\cdot x_i - \\sum_{i=1}^n i \\cdot y^{(\\ell)}_i | {\\leqslant} \\ell.$\n\\end{claim}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\vspace{-0.5ex}As a consequence of the previous claim, if ${\\boldsymbol x} \\in{\\cal C}_{VT}(n,a,\\ell)$ and ${\\boldsymbol y}^{(\\ell)} \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x})$, then ${\\boldsymbol y}^{(\\ell)} \\in {\\cal C}_{VT}(n,\\hat{a},\\ell)$ for some $\\hat{a}$, where \n$ | a - \\hat{a} | {\\leqslant} \\ell. $ The next lemma summarizes the previous discussion.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:equiv} Suppose that ${\\boldsymbol y}^{(\\ell)} \\in {\\cal B}_{(T,\\ell)}({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$, and let ${\\boldsymbol y}\\in{\\cal B}_{D}({\\boldsymbol y}^{(\\ell)})$. Then, ${\\cal D}_{VT,n,\\ell}(\\hat{a},{\\boldsymbol y})={\\boldsymbol y}^{(\\ell)}$ for some $\\hat{a}$ such that $|a - \\hat{a}| {\\leqslant} \\ell$. \\vspace{-0.5ex}\n\\end{lemma}\n\n\\begin{example} Suppose that ${\\boldsymbol x}=(0,1,1,0,0,1,0,\\textcolor{red}{0},0,0,1,0) \\in {\\cal C}(12, \\textcolor{blue}{3}, 3)$ was transmitted and that the vector \n${\\boldsymbol y} = (0,1,1,0,$ $0,1,0,0,$ $\\textcolor{red}{1},\\textcolor{red}{0},0) $ was received after at most three adjacent transpositions and a single deletion.\nFor ${\\boldsymbol y}^{(3)} =  (0,1,1,0,$ $0,1,0,\\textcolor{red}{0},$ $0, \\textcolor{red}{1},\\textcolor{red}{0},0)$ (where ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol y}^{(3)})$, we have $\\sum_{i=1}^{n-1} y_i \\equiv 2 \\bmod 19$. Thus, since $a=3$ and $\\hat{a}=2$, we get that $|a - \\hat{a}| {\\leqslant} 1 {\\leqslant} \\ell = 3$ as desired.\n\n\nNotice that if we apply the decoder ${\\cal D}_{VT,12,3}$ we get $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,12,3}(\\textcolor{blue}{3},{\\boldsymbol y}) = (0,1,1,0,0,\\textcolor{blue}{0},1,0,0,\\textcolor{red}{1},\\textcolor{red}{0},0)$. Here, we have\n$\\widehat{{\\boldsymbol x}}=(0,1,1,0,0,\\textcolor{blue}{0},1,0,0,\\textcolor{red}{1},\\textcolor{red}{0},0),$ and\n${\\boldsymbol x}=(0,1,1,0,0,1,0,\\textcolor{red}{0},0,0,1,0).$\n\\end{example}\n\n\\vspace{-0.5ex}We want next to characterize the difference between ${\\cal D}_{VT,n,\\ell}(a, {\\boldsymbol y})$ and ${\\cal D}_{VT,n,\\ell}(\\hat{a}, {\\boldsymbol y})$ for the case that $|a - \\hat{a}| {\\leqslant} \\ell$, as the value $\\hat{a}$ is unknown beforehand. \n\nOur main result may be intuitively described as follows: suppose that ${\\boldsymbol y} \\in {\\cal B}_D({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$ and ${\\boldsymbol y}$ is obtained by deleting the $k$th bit, $x_k$, from ${\\boldsymbol x}$ and the value of $x_k$ is known to the decoder. Assume that $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,n,\\ell}(a+v,{\\boldsymbol y})$, for some offset $v$, is obtained by inserting the bit $x_k $ in ${\\boldsymbol y}$. \nThen, if $x_k=0$, we may obtain ${\\boldsymbol x}$ from $\\widehat{{\\boldsymbol x}}$ by sliding the inserted bit to the left/right using a series adjacent transposition operations past at most $v$ ones. Otherwise, if $x_k=1$, then we can obtain ${\\boldsymbol x}$ from $\\widehat{{\\boldsymbol x}}$ by sliding the inserted bit to the left/right past at most $v$ zeros. The next lemma rigorously summarizes this observation.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:similar2} Suppose that ${\\boldsymbol y}$ is the result of a single deletion occurring in ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$ at position $k$. Given $k$, let $v_L=|\\{ j \\in [n] : j < k, x_j=1 \\}|$ and $v_R=|\\{ j \\in [n] : j > k, x_j=1 \\}|$. Then, \n\\begin{enumerate}\n\\item If $x_k=0$, then for all $v \\in \\{-v_R, -v_R+1, \\ldots, v_L\\}$, one may obtain ${\\cal D}_{VT,n,\\ell}(a+v,{\\boldsymbol y})$ by inserting the symbol $0$ in ${\\boldsymbol y}$ immediately after the $(v_L-v)$-th one. \n\\item If $x_k=1$, then for all $v \\in \\{-(k-1)+v_L, -k+v_L+2,$ $\\ldots, (n-k)-v_R \\}$, one may obtain ${\\cal D}_{VT,n,\\ell}( a + v,{\\boldsymbol y})$ by inserting the symbol $1$ in ${\\boldsymbol y}$ immediately after the $(v+k-v_L-1)$-th zero.\n\\end{enumerate}\n\\end{lemma}\n\n\\vspace{-0.5ex}\\begin{example} Suppose that ${\\boldsymbol x}=(0,1,1,0, \\textcolor{red}{0},1,0,\\textcolor{black}{0},0,0,1,0) \\in {\\cal C}(12, 3, 3)$, and that $ {\\boldsymbol x} = {\\cal D}_{VT,n,\\ell}(3,{\\boldsymbol y}),$\nwas obtained by VT decoding ${\\boldsymbol y} = (0,1,1,0,1,0,\\textcolor{black}{0},0,0,1,0)$. For $v=2$, one has \n${\\cal D}_{VT,n,\\ell}(5,{\\boldsymbol y})=(\\textcolor{red}{0},0,1,1,0,1,0,0,0,0,1,0),$\nwhereas for $v=-1$, one has \n${\\cal D}_{VT,n,\\ell}(2,{\\boldsymbol y})=({0},1,1,0,1,\\textcolor{red}{0},0,0,0,0,1,0).$\n\nNext, suppose that ${\\boldsymbol y} = (0,1,1,0,0,0,0,0,0,1,0)$ -- i.e., ${\\boldsymbol y}$ is the result of deleting the third $1$ at position $k=6$ from ${\\boldsymbol x}=(0,1,1,0, \\textcolor{black}{0},$ $\\textcolor{red}{1},0,\\textcolor{black}{0},$ $0,0,1,0)$. In this case, choosing $v=3$ gives $ {\\cal D}_{VT,n,\\ell}(6,{\\boldsymbol y})=(0,1,1,0,0,0,0,0,\\textcolor{red}{1},0,1,0)$, while $v=-2$ gives \n$ {\\cal D}_{VT,n,\\ell}(1,{\\boldsymbol y})=(0,\\textcolor{red}{1},1,1,0,0,0,0,0,0,1,0).$\n\\end{example}\n\n\\vspace{-0.5ex}{ {\\textit{Proof of Lemma~8:}} Suppose first that ${\\boldsymbol y}$ is the result of deleting a zero from ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$. Let $a' = a - \\sum_{i=1}^{n-1} i \\cdot y_i \\bmod (n+ 2\\ell+1)$. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ produces the vector $\\widehat{{\\boldsymbol x}} \\in {\\cal C}_{VT}(n,a,\\ell)$ by inserting a zero into the first position $k'$ that has $a'$ ones to the right of it. If $x_k=0$, then clearly $a' = v_R$, $k'=k$, and the decoder correctly outputs ${\\boldsymbol x}$ so that $\\widehat{{\\boldsymbol x}} = {\\boldsymbol x}$. If the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ were applied to ${\\boldsymbol y}$ instead, one would have\n\n", "index": 17, "text": "$$\\vspace{-0.5ex}a'' = a+v - \\sum_{i=1}^{n-1} i \\cdot y_i \\bmod (n+2\\ell+1) \\equiv a' + v \\bmod (n+2\\ell+1). \\vspace{-0.5ex}$$\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex12.m1\" class=\"ltx_Math\" alttext=\"\\vspace{-0.5ex}a^{\\prime\\prime}=a+v-\\sum_{i=1}^{n-1}i\\cdot y_{i}\\bmod(n+2\\ell+%&#10;1)\\equiv a^{\\prime}+v\\bmod(n+2\\ell+1).\\vspace{-0.5ex}\" display=\"block\"><mrow><mrow><msup><mi>a</mi><mi>\u2032\u2032</mi></msup><mo>=</mo><mrow><mrow><mrow><mi>a</mi><mo>+</mo><mi>v</mi></mrow><mo>-</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover><mrow><mi>i</mi><mo>\u22c5</mo><msub><mi>y</mi><mi>i</mi></msub></mrow></mrow></mrow><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2113</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow><mo>\u2261</mo><mrow><mrow><msup><mi>a</mi><mo>\u2032</mo></msup><mo>+</mo><mi>v</mi></mrow><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2113</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\n\n\n\\vspace{-0.5ex}The decoder for  ${\\cal C}_{VT}(n,a,b,\\ell)$, denoted by ${\\cal D}_{VT,n,b,\\ell}$, operates as follows. Suppose that ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,b,\\ell)$ is transmitted and that ${\\boldsymbol y} \\in {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ is received. Suppose that $n_1$ denotes the number of ones in ${\\boldsymbol y}$. Then, for $a \\in \\mathbb{Z}_{n+2\\ell+1}$ and $b \\in \\mathbb{F}_2$,  ${\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$ executes the next steps:\n\n\\begin{enumerate}\n\\item Set $x=\\sum_{i=1}^{n-1} x_i + b \\bmod 2$.\n\\item Compute $a' =a- \\sum_{i=1}^{n-1} i \\, y_i \\bmod (n+2\\ell+1).$\n\\item If $x=0$ and $a' \\in \\{0,1,\\ldots, n_1 \\}$, insert a zero into the first position in ${\\boldsymbol y}$ that has $a'$ ones on its right. If $a' \\in \\{n_1+1,n_1+2,\\ldots,n_1+\\ell \\}$, insert a zero in the first position in ${\\boldsymbol y}$. If $a' \\in \\{ n_1+\\ell+1, n_1+\\ell+2, \\ldots, n_1+2\\ell\\}$, insert a zero in the last position of ${\\boldsymbol y}$.\n\\item If $x=1$ and $a' \\in \\{n_1+1,n_1+2,\\ldots,n\\}$, insert a one in the first position $k$ of ${\\boldsymbol y}$ that has $a'-k$ ones to its right. Otherwise, if $a' \\in \\{n+1,n+2,\\ldots,n+\\ell\\}$, insert a one in the last position of ${\\boldsymbol y}$. If \\\\$a' \\in \\{ n-\\ell+1,n_1-\\ell+2,\\ldots,n_1\\}$, insert a one in the first position of ${\\boldsymbol y}$.\n\\end{enumerate}\n\nNote that the VT decoder discussed so far aims to correct a single deletion only, but potentially in a mismatched fashion as additional adjacent transposition errors may exist. The output of this decoder has to be fed into the input of a transposition error-correcting code, and we will describe how this is accomplished after providing an illustration of the VT decoding process.\n\n\\vspace{-0.5ex}\\begin{example}  Suppose that ${\\boldsymbol x}=(0,1,1,0, \\textcolor{red}{0},1,0,\\textcolor{black}{0},0,0,1,0) \\in {\\cal C}_{VT}(12, 3,0,3)$, and that\n${\\boldsymbol y} = (0,1,1,0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0)$\nis the received word, which is the result of a deletion and a single transposition. We first apply the decoder ${\\cal D}_{VT,12,0,3}$ to ${\\boldsymbol y}$. From the first step of the procedure, we conclude that the deleted bit has value $x=0$. In the second step of decoding, we compute $a' = 3$. Since $0 {\\leqslant} a' {\\leqslant} 4$, we have $\\widehat{{\\boldsymbol x}}= (0,1,\\textcolor{red}{0},1,0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0)$. Note that\n$\\widehat{{\\boldsymbol x}}= (0,1,\\textcolor{red}{0},\\textcolor{red}{1},0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0),$ and\n${\\boldsymbol x}= (0,1,1,0, \\textcolor{black}{0},1,0,\\textcolor{black}{0},0,0,1,0),$\ndiffer in two adjacent transpositions.\n\\end{example}\n\n\\vspace{-0.5ex}The previous example illustrates that ${\\boldsymbol x}$ and $\\widehat{{\\boldsymbol x}}$ differ in a limited number of transpositions which depends on the original number of transposition errors. In particular, for the given example, the two vectors differed in two adjacent transpositions as $\\widehat{{\\boldsymbol x}}$ is the result of a single deletion and a single transposition in ${\\boldsymbol y}$. The next lemma gives a more precise characterization of the ``distance'' between ${\\boldsymbol x}$ and  $\\widehat{{\\boldsymbol x}}$.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:miserror}  Suppose that ${\\boldsymbol y}^{(\\ell)} = {\\cal B}_{(T,\\ell)}({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in  {\\cal C}_{VT}(n,a,b,\\ell)$ and where ${\\boldsymbol y}\\in{\\cal B}_D({\\boldsymbol y}^{(\\ell)})$. Let $\\widehat{{\\boldsymbol x}} = {\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. Then the following statements are true:\n\\begin{enumerate}\n\\item If $\\widehat{{\\boldsymbol x}}$ is the result of inserting a zero in ${\\boldsymbol y}$ in a position with $v_R$ ones to the right of the inserted bit, then ${\\boldsymbol y}^{(\\ell)}$ can be obtained from ${\\boldsymbol y}$ by inserting a zero in ${\\boldsymbol y}$ in the first position with $j$ ones to the right of it where $j \\in \\{ v_R-\\ell, v_R - \\ell+1, \\ldots, v_R + \\ell \\}$.\n\\item If $\\widehat{{\\boldsymbol x}}$ is the result of inserting a one in ${\\boldsymbol y}$ in position $k$ with $v_R$ ones to the right of the inserted bit, then ${\\boldsymbol y}^{(\\ell)}$ can be obtained from ${\\boldsymbol y}$ by inserting a one in ${\\boldsymbol y}$ in the first position $j$ with $j_1$ ones to the right of it where $j+j_1 \\in \\{ k+v_R-\\ell, k+v_R - \\ell+1, \\ldots, k+v_R + \\ell \\}$.\n\\end{enumerate}\n\\end{lemma}\n\\vspace{-0.5ex}The following corollary summarizes one of the main results of this section.\n\n\\vspace{-0.5ex}\\begin{corollary}\\label{cor:deltrans11} Suppose that ${\\boldsymbol y} = {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,b,\\ell)$ and let $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. Then ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$.\n\\end{corollary}\nConsequently, the mismatched VT decoder increases the number of adjacent transposition errors by at most a factor of two.\n\nBased on the results on mismatched VT decoding and Corollary~\\ref{cor:deltrans11}, we are now ready to define a family of codes capable of correcting a single deletion and multiple adjacent transposition errors. In this setting, recall that given a binary word $\\textbf{x}$, its derivative $\\partial({\\boldsymbol x})={\\boldsymbol x}'$ is defined as ${\\boldsymbol x}' = (x_1,x_2+x_1,x_3+x_2,\\ldots, x_n+x_{n-1})$ and its inverse $\\partial^{-1}({\\boldsymbol x})=\\overline{{\\boldsymbol x}} = (x_1, x_1 + x_2, \\ldots, \\sum_{i=1}^n x_i)$.\nWe claim that the code ${\\cal C}_{(T,\\ell) \\land D} \\subseteq \\mathbb{F}_2^n$, defined as\n\\vspace{-0.5ex}\n", "itemtype": "equation", "pos": 28699, "prevtext": "\nHence, the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ would insert a zero in the vector ${\\boldsymbol y}$ at the first position $k''$ that has $a' + v$ ones to the right of it. The claim follows by observing that the position that has $a'+v$ ones after it is in the same run as the position in ${\\boldsymbol y}$ with $(v_L-v)$ ones preceding it.\n\n\nSuppose now that ${\\boldsymbol y}$ is the result deleting a one from ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,\\ell)$. Let $a' = a - \\sum_{i=1}^{n-1} i \\cdot y_i \\bmod (n+2\\ell+1)$. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a,\\ell)$ produces the vector $\\widehat{{\\boldsymbol x}} \\in {\\cal C}_{VT}(n,a,\\ell)$ by inserting a one into the first position $k'$ that has $a'-k'$ ones to the right of it. If $x_k=1$, then clearly $k' = k$ and the decoder correctly outputs ${\\boldsymbol x}$, and hence $\\widehat{{\\boldsymbol x}} = {\\boldsymbol x}$. \n\nIf the decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ were applied to ${\\boldsymbol y}$ instead, then $a''  \\equiv a' + v \\bmod (n+2\\ell+1)$ as before. The decoder ${\\cal D}_{VT,n,\\ell}$ for ${\\cal C}_{VT}(n,a+v,\\ell)$ would insert a one in the vector ${\\boldsymbol y}$ into the first position $k''$ that has $a' + v - k''$ ones to the right of it. This produces a vector $\\widehat{{\\boldsymbol x}}$. Since the first position $k''$ in ${\\boldsymbol y}$ with $a' + v - k''$ ones to the right is the same as the first position in ${\\boldsymbol y}$ following $(v+k-v_L-1)$ zeros, the claimed result also follows for $x_k=1$. \n$\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\blacksquare$} \\vspace{-0.5ex}\\\\\n\nThe previous lemma allows us to propose a modification of a VT code capable of correcting a deletion and multiple adjacent transpositions. Furthermore, it leads to a straightforward decoding architecture for the proposed code. Formally,\n\\vspace{-0.5ex}\n", "index": 19, "text": "\\begin{align}\\label{eq:vtphi}\n{\\cal C}_{VT}(n,a,b,\\ell) = \\{ &{\\boldsymbol x} \\in \\mathbb{F}_2^n : \\\\\n&\\sum_{i=1}^n i \\cdot x_i \\equiv a \\bmod (n+2\\ell+1), \\nonumber \\\\\n&\\sum_{i=1}^{n} x_i \\equiv b \\bmod 2 \\}. \\nonumber\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\cal C}_{VT}(n,a,b,\\ell)=\\{\" display=\"inline\"><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mi>V</mi><mo>\u2062</mo><mi>T</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mo stretchy=\"false\">{</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{x}}\\in\\mathbb{F}_{2}^{n}:\" display=\"inline\"><mrow><mrow><mi>\ud835\udc99</mi><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup></mrow><mo>:</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex13.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{n}i\\cdot x_{i}\\equiv a\\bmod(n+2\\ell+1),\" display=\"inline\"><mrow><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mstyle><mrow><mi>i</mi><mo>\u22c5</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mrow><mo>\u2261</mo><mrow><mi>a</mi><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2113</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex14.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{n}x_{i}\\equiv b\\bmod 2\\}.\" display=\"inline\"><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mstyle><msub><mi>x</mi><mi>i</mi></msub><mo>\u2261</mo><mi>b</mi><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mn>2</mn><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\nis an $\\ell$-TD code. This claim is proved in the next theorem.\n\\vspace{-0.5ex}\\begin{theorem}\\label{th:general} \nThe code ${\\cal C}_{(T,\\ell) \\land D}(n,a,b)$ is an $\\ell$-TD code.\n\\end{theorem}\n\\vspace{-0.5ex}\\begin{IEEEproof} Suppose that ${\\boldsymbol y} \\in  {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$. We show how to recover ${\\boldsymbol x}$ from ${\\boldsymbol y}$. First, we determine $\\widehat{{\\boldsymbol x}} = {\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. From Corollary~\\ref{cor:deltrans11}, we have that ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$. \nSince ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$, we have $d_H(\\partial^{-1}(\\widehat{{\\boldsymbol x}}), \\overline{{\\boldsymbol x}}) {\\leqslant} 2\\ell$. Because the minimum distance of the code $\\overline{{\\cal C}}_{(T,\\ell) \\land D}(n,a,b)$ is $4\\ell + 1$, we can uniquely recover ${\\boldsymbol x}$ from $\\partial^{-1}(\\widehat{{\\boldsymbol x}})$.\n\\end{IEEEproof}\n\n\n\\vspace{-0.5ex}\\begin{corollary} \nThere exists an $\\ell$-TD code which redundancy at most $(2\\ell + 1)\\log(n)$ bits.\n\n\\end{corollary}\n\nLastly in this section, we improve upon this result for the case when $\\ell=1$. The case of $\\ell>1$ is reserved for an extended version of the paper.\n\n\n\n\n\n\n\n\n\n\n\nLet $a_1, a_2 \\in \\mathbb{Z}_{n+2L+1}$ and $b \\in \\mathbb{F}_2$. Define $\\textbf{Y}_{T \\land D}(n,a_1,a_2,b) \\subseteq \\mathbb{F}_2^n$ according to\n\\vspace{-0.5ex}\n", "itemtype": "equation", "pos": 34670, "prevtext": "\n\n\n\\vspace{-0.5ex}The decoder for  ${\\cal C}_{VT}(n,a,b,\\ell)$, denoted by ${\\cal D}_{VT,n,b,\\ell}$, operates as follows. Suppose that ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,b,\\ell)$ is transmitted and that ${\\boldsymbol y} \\in {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ is received. Suppose that $n_1$ denotes the number of ones in ${\\boldsymbol y}$. Then, for $a \\in \\mathbb{Z}_{n+2\\ell+1}$ and $b \\in \\mathbb{F}_2$,  ${\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$ executes the next steps:\n\n\\begin{enumerate}\n\\item Set $x=\\sum_{i=1}^{n-1} x_i + b \\bmod 2$.\n\\item Compute $a' =a- \\sum_{i=1}^{n-1} i \\, y_i \\bmod (n+2\\ell+1).$\n\\item If $x=0$ and $a' \\in \\{0,1,\\ldots, n_1 \\}$, insert a zero into the first position in ${\\boldsymbol y}$ that has $a'$ ones on its right. If $a' \\in \\{n_1+1,n_1+2,\\ldots,n_1+\\ell \\}$, insert a zero in the first position in ${\\boldsymbol y}$. If $a' \\in \\{ n_1+\\ell+1, n_1+\\ell+2, \\ldots, n_1+2\\ell\\}$, insert a zero in the last position of ${\\boldsymbol y}$.\n\\item If $x=1$ and $a' \\in \\{n_1+1,n_1+2,\\ldots,n\\}$, insert a one in the first position $k$ of ${\\boldsymbol y}$ that has $a'-k$ ones to its right. Otherwise, if $a' \\in \\{n+1,n+2,\\ldots,n+\\ell\\}$, insert a one in the last position of ${\\boldsymbol y}$. If \\\\$a' \\in \\{ n-\\ell+1,n_1-\\ell+2,\\ldots,n_1\\}$, insert a one in the first position of ${\\boldsymbol y}$.\n\\end{enumerate}\n\nNote that the VT decoder discussed so far aims to correct a single deletion only, but potentially in a mismatched fashion as additional adjacent transposition errors may exist. The output of this decoder has to be fed into the input of a transposition error-correcting code, and we will describe how this is accomplished after providing an illustration of the VT decoding process.\n\n\\vspace{-0.5ex}\\begin{example}  Suppose that ${\\boldsymbol x}=(0,1,1,0, \\textcolor{red}{0},1,0,\\textcolor{black}{0},0,0,1,0) \\in {\\cal C}_{VT}(12, 3,0,3)$, and that\n${\\boldsymbol y} = (0,1,1,0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0)$\nis the received word, which is the result of a deletion and a single transposition. We first apply the decoder ${\\cal D}_{VT,12,0,3}$ to ${\\boldsymbol y}$. From the first step of the procedure, we conclude that the deleted bit has value $x=0$. In the second step of decoding, we compute $a' = 3$. Since $0 {\\leqslant} a' {\\leqslant} 4$, we have $\\widehat{{\\boldsymbol x}}= (0,1,\\textcolor{red}{0},1,0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0)$. Note that\n$\\widehat{{\\boldsymbol x}}= (0,1,\\textcolor{red}{0},\\textcolor{red}{1},0,1,0,\\textcolor{black}{0},0,\\textcolor{red}{1},\\textcolor{red}{0},0),$ and\n${\\boldsymbol x}= (0,1,1,0, \\textcolor{black}{0},1,0,\\textcolor{black}{0},0,0,1,0),$\ndiffer in two adjacent transpositions.\n\\end{example}\n\n\\vspace{-0.5ex}The previous example illustrates that ${\\boldsymbol x}$ and $\\widehat{{\\boldsymbol x}}$ differ in a limited number of transpositions which depends on the original number of transposition errors. In particular, for the given example, the two vectors differed in two adjacent transpositions as $\\widehat{{\\boldsymbol x}}$ is the result of a single deletion and a single transposition in ${\\boldsymbol y}$. The next lemma gives a more precise characterization of the ``distance'' between ${\\boldsymbol x}$ and  $\\widehat{{\\boldsymbol x}}$.\n\n\\vspace{-0.5ex}\\begin{lemma}\\label{lem:miserror}  Suppose that ${\\boldsymbol y}^{(\\ell)} = {\\cal B}_{(T,\\ell)}({\\boldsymbol x}),$ where ${\\boldsymbol x} \\in  {\\cal C}_{VT}(n,a,b,\\ell)$ and where ${\\boldsymbol y}\\in{\\cal B}_D({\\boldsymbol y}^{(\\ell)})$. Let $\\widehat{{\\boldsymbol x}} = {\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. Then the following statements are true:\n\\begin{enumerate}\n\\item If $\\widehat{{\\boldsymbol x}}$ is the result of inserting a zero in ${\\boldsymbol y}$ in a position with $v_R$ ones to the right of the inserted bit, then ${\\boldsymbol y}^{(\\ell)}$ can be obtained from ${\\boldsymbol y}$ by inserting a zero in ${\\boldsymbol y}$ in the first position with $j$ ones to the right of it where $j \\in \\{ v_R-\\ell, v_R - \\ell+1, \\ldots, v_R + \\ell \\}$.\n\\item If $\\widehat{{\\boldsymbol x}}$ is the result of inserting a one in ${\\boldsymbol y}$ in position $k$ with $v_R$ ones to the right of the inserted bit, then ${\\boldsymbol y}^{(\\ell)}$ can be obtained from ${\\boldsymbol y}$ by inserting a one in ${\\boldsymbol y}$ in the first position $j$ with $j_1$ ones to the right of it where $j+j_1 \\in \\{ k+v_R-\\ell, k+v_R - \\ell+1, \\ldots, k+v_R + \\ell \\}$.\n\\end{enumerate}\n\\end{lemma}\n\\vspace{-0.5ex}The following corollary summarizes one of the main results of this section.\n\n\\vspace{-0.5ex}\\begin{corollary}\\label{cor:deltrans11} Suppose that ${\\boldsymbol y} = {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$ where ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,b,\\ell)$ and let $\\widehat{{\\boldsymbol x}}={\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. Then ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$.\n\\end{corollary}\nConsequently, the mismatched VT decoder increases the number of adjacent transposition errors by at most a factor of two.\n\nBased on the results on mismatched VT decoding and Corollary~\\ref{cor:deltrans11}, we are now ready to define a family of codes capable of correcting a single deletion and multiple adjacent transposition errors. In this setting, recall that given a binary word $\\textbf{x}$, its derivative $\\partial({\\boldsymbol x})={\\boldsymbol x}'$ is defined as ${\\boldsymbol x}' = (x_1,x_2+x_1,x_3+x_2,\\ldots, x_n+x_{n-1})$ and its inverse $\\partial^{-1}({\\boldsymbol x})=\\overline{{\\boldsymbol x}} = (x_1, x_1 + x_2, \\ldots, \\sum_{i=1}^n x_i)$.\nWe claim that the code ${\\cal C}_{(T,\\ell) \\land D} \\subseteq \\mathbb{F}_2^n$, defined as\n\\vspace{-0.5ex}\n", "index": 21, "text": "\\begin{align}\\label{eq:generaltrans}\n{\\cal C}_{(T,\\ell) \\land D}(n,a,b)= \\{ {\\boldsymbol x} \\in \\mathbb{F}_2^n  :\\ & \\overline{{\\boldsymbol x}} \\in {\\cal C}_H(n,4\\ell+1), \\notag \\\\\n&{\\boldsymbol x} \\in {\\cal C}_{VT}(n,a,b,\\ell) \\}.\\vspace{-0.5ex}\n\\end{align}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\cal C}_{(T,\\ell)\\land D}(n,a,b)=\\{{\\boldsymbol{x}}\\in\\mathbb{F}%&#10;_{2}^{n}:\" display=\"inline\"><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mrow><mo stretchy=\"false\">(</mo><mi>T</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow><mo>\u2227</mo><mi>D</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><mo>=</mo><mrow><mo stretchy=\"false\">{</mo><mi>\ud835\udc99</mi><mo>\u2208</mo><msubsup><mi>\ud835\udd3d</mi><mn>2</mn><mi>n</mi></msubsup><mo>:</mo></mrow></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex15.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\overline{{\\boldsymbol{x}}}\\in{\\cal C}_{H}(n,4\\ell+1),\" display=\"inline\"><mrow><mrow><mover accent=\"true\"><mi>\ud835\udc99</mi><mo>\u00af</mo></mover><mo>\u2208</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mi>H</mi></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mrow><mrow><mn>4</mn><mo>\u2062</mo><mi mathvariant=\"normal\">\u2113</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle{\\boldsymbol{x}}\\in{\\cal C}_{VT}(n,a,b,\\ell)\\}.\" display=\"inline\"><mrow><mi>\ud835\udc99</mi><mo>\u2208</mo><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mi>V</mi><mo>\u2062</mo><mi>T</mi></mrow></msub><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi mathvariant=\"normal\">\u2113</mi><mo stretchy=\"false\">)</mo></mrow><mo stretchy=\"false\">}</mo><mo>.</mo></mrow></math>", "type": "latex"}, {"file": "1601.06885.tex", "nexttext": "\nwhere $L {\\geqslant} 1$ is chosen so that $n + 2L + 1$ is a prime number greater than $4n-1$. Let ${\\cal C}_{T \\land D}(n,a_1, a_2, b) = \\textbf{Y}'_{T \\land D}(n,a_1, a_2, b)$. We have the following lemma.\n\n\n\\vspace{-0.5ex}\\begin{lemma} \nFor all $a_1, a_2 \\in \\mathbb{Z}_{n+2L+1}$ and $b \\in \\mathbb{F}_2$, the code ${\\cal C}_{T \\land D}(n,a_1, a_2, b)$ is a 1-TD code.\n\n\\end{lemma}\n\\vspace{-0.5ex}\\begin{IEEEproof} Since ${\\boldsymbol x} \\in {\\cal C}_{VT}(n,a_1,b,L)$ by design, we only need to show $\\overline{{\\cal C}}_{T \\land D}(n,a_1,a_2,b)=\\textbf{Y}_{T \\land D}(n,a_1, a_2, b)$ has Hamming distance $5$. Notice that if ${\\boldsymbol x}' \\in {\\cal C}_{VT}(n,a_1,0,L)$ and $x_n=0$, then this implies\n$ \\sum_{i=1}^{n-1} (2i+1) x_i \\equiv a_1 \\bmod n + 2L + 1.$\nThus, the vectors in the code ${\\cal C}_{T \\land D}(n,a_1,a_2,b)$ are a subset of the codewords in a Berlekamp code over $\\mathbb{F}_{n+2L+1}$ which has minimum Lee distance $5$~\\cite{Roth}. \n\nTherefore, since the code ${\\cal C}_{T \\land D}(n,a_1,a_2,b)$ is comprised of only binary vectors, the minimum Hamming distance of ${\\cal C}_{T \\land D}(n,a_1,a_2,b)$ is $5$.\n\\end{IEEEproof}\n\n\\vspace{-0.5ex}\\begin{corollary} \nThere exists a $1$-TD code which redundancy at most $2\\log(n)+c$ bits, for some constant $c$.\\vspace{-0.5ex}\n\\end{corollary}\n\nHence, the above construction improves upon the general construction in (\\ref{eq:generaltrans}) in terms of a saving of $\\log(n)$ redundant bits.\n\n\n\\vspace{-0.5ex}\\section{Conclusion and Future Work}\\vspace{-0.5ex}\n\nIn this work, we considered the problem of coding for the Damerau distance. We focused on the problem of constructing codes capable of correcting a single deletion and a number of adjacent transpositions. Our extended work includes upper bounds on the cardinalities of such codes as well as the construction of codes capable of correcting substitutions and deletions.\n\n\\vspace{-0.5ex}\n\\scriptsize\n\n\\bibliographystyle{IEEEtranS}\n\\bibliography{damerau-ref}\n\n", "itemtype": "equation", "pos": 36368, "prevtext": "\nis an $\\ell$-TD code. This claim is proved in the next theorem.\n\\vspace{-0.5ex}\\begin{theorem}\\label{th:general} \nThe code ${\\cal C}_{(T,\\ell) \\land D}(n,a,b)$ is an $\\ell$-TD code.\n\\end{theorem}\n\\vspace{-0.5ex}\\begin{IEEEproof} Suppose that ${\\boldsymbol y} \\in  {\\cal B}_{(T,\\ell),D}({\\boldsymbol x})$. We show how to recover ${\\boldsymbol x}$ from ${\\boldsymbol y}$. First, we determine $\\widehat{{\\boldsymbol x}} = {\\cal D}_{VT,n,b,\\ell}(a,{\\boldsymbol y})$. From Corollary~\\ref{cor:deltrans11}, we have that ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$. \nSince ${\\boldsymbol x} \\in {\\cal B}_{(T,2\\ell)}(\\widehat{{\\boldsymbol x}})$, we have $d_H(\\partial^{-1}(\\widehat{{\\boldsymbol x}}), \\overline{{\\boldsymbol x}}) {\\leqslant} 2\\ell$. Because the minimum distance of the code $\\overline{{\\cal C}}_{(T,\\ell) \\land D}(n,a,b)$ is $4\\ell + 1$, we can uniquely recover ${\\boldsymbol x}$ from $\\partial^{-1}(\\widehat{{\\boldsymbol x}})$.\n\\end{IEEEproof}\n\n\n\\vspace{-0.5ex}\\begin{corollary} \nThere exists an $\\ell$-TD code which redundancy at most $(2\\ell + 1)\\log(n)$ bits.\n\n\\end{corollary}\n\nLastly in this section, we improve upon this result for the case when $\\ell=1$. The case of $\\ell>1$ is reserved for an extended version of the paper.\n\n\n\n\n\n\n\n\n\n\n\nLet $a_1, a_2 \\in \\mathbb{Z}_{n+2L+1}$ and $b \\in \\mathbb{F}_2$. Define $\\textbf{Y}_{T \\land D}(n,a_1,a_2,b) \\subseteq \\mathbb{F}_2^n$ according to\n\\vspace{-0.5ex}\n", "index": 23, "text": "\\begin{align*}\n\\textbf{Y}_{T \\land D}(n,a_1, a_2, b) = &\\{{\\boldsymbol x} \\ : {\\boldsymbol x}' \\in {\\cal C}_{VT}(n,a_1,b,L) , \\\\\n&\\sum_{i=1}^{n-1} (2i+1)^2 \\, x_i   \\equiv a_2 \\bmod (n+2L+1), \\\\\n& x_n = 0 \\},\\vspace{-0.5ex}\n\\end{align*}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m1\" class=\"ltx_Math\" alttext=\"\\displaystyle\\textbf{Y}_{T\\land D}(n,a_{1},a_{2},b)=\" display=\"inline\"><mrow><mrow><msub><mtext>\ud835\udc18</mtext><mrow><mi>T</mi><mo>\u2227</mo><mi>D</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mi/></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex16.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\{{\\boldsymbol{x}}\\ :{\\boldsymbol{x}}^{\\prime}\\in{\\cal C}_{VT}(n,%&#10;a_{1},b,L),\" display=\"inline\"><mrow><mrow><mrow><mi mathvariant=\"normal\">{</mi><mo>\u2062</mo><mpadded width=\"+5pt\"><mi>\ud835\udc99</mi></mpadded></mrow><mo>:</mo><mrow><msup><mi>\ud835\udc99</mi><mo>\u2032</mo></msup><mo>\u2208</mo><mrow><msub><mi class=\"ltx_font_mathcaligraphic\">\ud835\udc9e</mi><mrow><mi>V</mi><mo>\u2062</mo><mi>T</mi></mrow></msub><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>b</mi><mo>,</mo><mi>L</mi><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex17.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle\\sum_{i=1}^{n-1}(2i+1)^{2}\\,x_{i}\\equiv a_{2}\\bmod(n+2L+1),\" display=\"inline\"><mrow><mrow><mrow><mstyle displaystyle=\"true\"><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover></mstyle><mrow><mpadded width=\"+1.7pt\"><msup><mrow><mo stretchy=\"false\">(</mo><mrow><mrow><mn>2</mn><mo>\u2062</mo><mi>i</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow><mn>2</mn></msup></mpadded><mo>\u2062</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mrow><mo>\u2261</mo><mrow><msub><mi>a</mi><mn>2</mn></msub><mo lspace=\"2.5pt\" rspace=\"2.5pt\">mod</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mi>n</mi><mo>+</mo><mrow><mn>2</mn><mo>\u2062</mo><mi>L</mi></mrow><mo>+</mo><mn>1</mn></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math>\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.Ex18.m2\" class=\"ltx_Math\" alttext=\"\\displaystyle x_{n}=0\\},\" display=\"inline\"><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo>,</mo></mrow></math>", "type": "latex"}]