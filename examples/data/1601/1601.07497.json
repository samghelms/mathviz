[{"file": "1601.07497.tex", "nexttext": "\nwhich appears $\\sim 18 L^4$ times throughout the algorithm \\cite{NB4}\nwhen using the minimally required number of qubits to factor a semiprime $N$\nwhose bit-length is $L$, we tested the sensitivity of the quantum computer\nrunning Shor's algorithm with respect to effective errors introduced\nin $\\theta_j^{(\\pm)}$. \nSpecifically, we used a statistical error model of the rotation gate\n\\cite{NB6} of the form\n\n", "itemtype": "equation", "pos": 6325, "prevtext": "\n \n\\title{Symmetry boosts quantum computer performance}\n\n\n\\author{Y. S. Nam and R. Bl\\\"umel}  \n\\affiliation{Department of Physics, Wesleyan University, \nMiddletown, Connecticut 06459-0155, USA}\n  \n\\date{\\today}\n\n\\begin{abstract} \n\nFrequently, subroutines in quantum computers have the structure\n$\\mathcal{F}\\mathcal{U}\\mathcal{F}^{-1}$, where $\\mathcal{F}$ is\nsome unitary transform and $\\mathcal{U}$ is performing a quantum computation.\nIn this paper we suggest that if, in analogy to spin echoes,\n$\\mathcal{F}$ and $\\mathcal{F}^{-1}$ can be implemented symmetrically\nsuch that $\\mathcal{F}$ and $\\mathcal{F}^{-1}$ have the same hardware errors\non the logical qubit level, a symmetry boost in the fidelity of the combined\n$\\mathcal{F}\\mathcal{U}\\mathcal{F}^{-1}$ quantum operation results that\nin our simulations reaches up to a factor 10.\nWhile we find and document this symmetry boost here in the case of Shor's algorithm,\nwe suggest that other quantum algorithms might profit from similar\nsymmetry performance boosts whenever $\\mathcal{F}\\mathcal{U}\\mathcal{F}^{-1}$\nsub-units of the corresponding quantum algorithm can be identified.\n\n\\end{abstract}\n\n\\pacs{03.67.Lx} \n                       \n\n\n\n\n                              \n\n\\maketitle\n\n\nThe second half of the 20th century saw the advent\nof the information technology revolution.\nThere is no doubt about its profound impact\non just about every aspect of modern society.\nThe technological innovation in computers\nand networks enabled us to achieve tasks\npreviously thought to be impossible,\nsuch as weather forecast, telecommunication,\nthe Global Positioning System, and online banking.\n\nWhile the current classical technology is already impressive,\nyet another revolution is about to emerge: Quantum information technology \\cite{NC}.\nTaking advantage of quantum superposition and entanglement,\na quantum information device is expected to be faster\nand more secure than its classical counterpart.\nEpitomizing this is Shor's algorithm \\cite{Shor,NC}, which enables us\nto factor a semiprime $N = pq$, where $p$ and $q$ are\nprime numbers, exponentially faster than any classical\nalgorithm known to date.\nShor's algorithm is often associated with code-breaking\nsince semiprime factorization is at the heart\nof the widely-employed Rivest-Shamir-Adleman (RSA) \nencryption algorithm \\cite{RSA,NC}.\n\nDespite all the theoretically predicted stupendous powers of quantum information devices,\nwe do encounter major challenges when it comes to a physical\nrealization of these devices: Errors and defects.\nThis is so, because a quantum system is known to be susceptible\nto inexact manipulation and decoherence,\nespecially for a quantum computer whose workings are based on\nexquisite control of quantum superposition and interference.\nAn early list of the potentially dangerous physical mechanisms\nthat may destroy the proper functioning of a quantum computer was compiled\nby Landauer \\cite{Landauer}, and much progress has been made to fight \nthese detrimental mechanisms over the past couple of decades.\nFor instance, overcoming the stochastic type of errors,\ni.e., errors that occur on a single qubit probabilistically,\nwas the invention of quantum error correction \\cite{Shor9,CSS1,CSS2,QECC5} \nand its fault-tolerant implementation \\cite{Fault1,Fault2,Fault3},\nculminating in the standard de facto approaches of\ntopological and surface codes (see \\cite{Surface} and references therein).\n\nStill, if we are to truly realize a working, physical quantum computer\nthat is practically useful, the limits of engineering must be taken into consideration.\nOtherwise, a quantum computer will remain\nan academically interesting device of no practical relevance.\nOne way to approach this problem is to investigate\nthe accuracy gain in logical operations on a logical qubit,\ngiven the technology-dependent physical qubit error rate.\nPioneering work in \\cite{Autotune}, for instance, \nis already making headway in this direction.\nYet, another way to help realize the full potential of quantum computing\nis to investigate the algorithmic performance behavior\nat the logical qubit level, providing quantum experimentalists\nand engineers with a logical error-rate target,\npotentially easing the accuracy and precision requirements.\nAdding to recent experimental breakthroughs, \nsuch as reported in \\cite{FM} and \\cite{Morello},\nthis paper provides an additional \nstrategy for \nrealizing a working, physical quantum computer.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs a testbed algorithm\nwe chose Shor's algorithm, implemented \naccording to Beauregard's architecture \\cite{Beau}.\nWe selected this particular architecture based on the facts that\n(i) Shor's algorithm is arguably the most interesting\nand most important quantum algorithm to date,\n(ii) the algorithm is complex enough to realistically \ncapture the effects of faulty gates, and, most importantly,\nand exploited in this paper,\n(iii) Beauregard's architecture allows us to take\nadvantage of symmetry.\nWhether some other Shor algorithm architectures,\nsuch as those presented in \\cite{ShorArch} (and references therein),\nmay be exploited in a similar fashion is currently under investigation\nand the results will be reported elsewhere.\n\n\n\n\n\nStudies addressing the effects of errors and defects\non a quantum computer running Shor's algorithm \ncontinue to be of central interest to many scientists.\nA list of early, notable contributions includes the investigations by\nCirac and Zoller \\cite{CZ} studying the effect of errors \nin interaction time and laser detuning,\nMiquel {\\it et al.} studying the effects of interactions with\na dissipative environment \\cite{Mq1} and phase drift errors \\cite{Mq2},\nWei {\\it et al.} exploring the effects of coherence errors occurring\nwhile the quantum computer is idling \\cite{Wei}, and\nGarc\\'ia-Mata {\\it et al.} simulating static imperfections in Shor's algorithm \\cite{Shep}.\nRecent developments in quantum simulation software \\cite{Liquid, Quipu} \nreflect the fact that quantum computers remain\nat the forefront of research.\nOur work extends this line of research\nin that we simulate the entire Shor algorithm gate--by--gate.\nIn particular, we investigate the effects of phase-rotation gate errors.\n\nSince the most frequently used quantum gate in Beauregard's architecture\nof Shor's algorithm is a phase rotation gate\n\n", "index": 1, "text": "\\begin{equation}\n\\label{theta-ideal}\n\\theta_j^{(\\pm)} = \\left( \\begin{matrix} \n\t\t\t\t1 & 0 \\\\\n\t\t\t\t0 & e^{\\pm i\\frac{\\pi}{2^j}}\n\t\t\t    \\end{matrix} \\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"\\theta_{j}^{(\\pm)}=\\left(\\matrix{1}&amp;0\\\\&#10;0&amp;e^{\\pm i\\frac{\\pi}{2^{j}}}\\right),\" display=\"block\"><mrow><mrow><msubsup><mi>\u03b8</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mo>\u00b1</mo><mo stretchy=\"false\">)</mo></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mrow><mtable displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>\u00b1</mo><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><msup><mn>2</mn><mi>j</mi></msup></mfrac></mrow></mrow></msup></mrow><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07497.tex", "nexttext": "\nin the case where the errors scale \naccording to the size of the gate operation and\n\n", "itemtype": "equation", "pos": 6901, "prevtext": "\nwhich appears $\\sim 18 L^4$ times throughout the algorithm \\cite{NB4}\nwhen using the minimally required number of qubits to factor a semiprime $N$\nwhose bit-length is $L$, we tested the sensitivity of the quantum computer\nrunning Shor's algorithm with respect to effective errors introduced\nin $\\theta_j^{(\\pm)}$. \nSpecifically, we used a statistical error model of the rotation gate\n\\cite{NB6} of the form\n\n", "index": 3, "text": "\\begin{equation}\n\\label{theta-defect-R}\n{}^{R} \\theta_j^{(\\pm)} = \\left( \\begin{matrix} \n\t\t\t\t1 & 0 \\\\\n\t\t\t\t0 & e^{\\pm i\\frac{\\pi}{2^j} (1+\\alpha^{(\\pm)})}\n\t\t\t    \\end{matrix} \\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"{}^{R}\\theta_{j}^{(\\pm)}=\\left(\\matrix{1}&amp;0\\\\&#10;0&amp;e^{\\pm i\\frac{\\pi}{2^{j}}(1+\\alpha^{(\\pm)})}\\right),\" display=\"block\"><mrow><mrow><mmultiscripts><mi>\u03b8</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mo>\u00b1</mo><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mi>R</mi></mmultiscripts><mo>=</mo><mrow><mo>(</mo><mrow><mtable displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>\u00b1</mo><mrow><mi>i</mi><mo>\u2062</mo><mfrac><mi>\u03c0</mi><msup><mn>2</mn><mi>j</mi></msup></mfrac><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><mrow><mn>1</mn><mo>+</mo><msup><mi>\u03b1</mi><mrow><mo stretchy=\"false\">(</mo><mo>\u00b1</mo><mo stretchy=\"false\">)</mo></mrow></msup></mrow><mo stretchy=\"false\">)</mo></mrow></mrow></mrow></msup></mrow><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}, {"file": "1601.07497.tex", "nexttext": "\nin the case where the errors do not scale\naccording to the size of the operation. \nIn both cases \n$\\alpha^{(\\pm)}$ is the defect parameter \nthat may or may not be (strongly) correlated with \nthe gate type indexed with $j$. In case a \none-to-one correlation \nexists, we call the error ``typed'' and replace \n$\\alpha^{(\\pm)}$ with $\\alpha_j^{(\\pm)}$. \nThe $\\pm$ sign corresponds to forward and backward operation.\n\nThe reason why we investigate these two error models is as follows.\nFirst, any device has a finite accuracy, and\nthis is usually given in terms of percentage error \nwith respect to the size of the gate operation.\nSince a rotation gate $\\theta_j$ is built\naccording to a gate decomposition sequence (see references in \\cite{NB-qic}),\ntogether with the faulty logical gates, the approximated \nrotation gate will contain errors that scale in the size of the operation,\nespecially regarding the construction method of $\\theta_j$\nby applying $\\theta_{j+1}$ twice, for instance.\nThis iteration method may be realistic and desirable\nfrom the technological or economical perspective.\nThus, characterizing a device in terms of relative errors is captured\nby the ${}^{R}\\theta_j^{(\\pm)}$ model.\nHowever, suppose we characterize our quantum computer device\nin terms of its technological limit, say $\\delta$.\nIn this case, most likely, all gates are to be made with\ndifferent sequences resulting in an error level $\\lesssim \\delta$, \nand this is captured by our model ${}^{A}\\theta_j^{(\\pm)}$.\n\nWe now subdivide both models into 3 categories:\n(i) typed errors ($\\alpha^{\\pm} = \\alpha^{\\pm}_j$), \nasymmetric ($\\alpha^{+} \\neq \\alpha^{-}$),\n(ii) typed errors ($\\alpha^{\\pm} = \\alpha^{\\pm}_j$), \nsymmetric ($\\alpha^{+} = \\alpha^{-}$), and \n(iii) non-typed errors, i.e., completely random $\\alpha^{\\pm}$.\nThe three categories are explained as follows.\nTyping arises from using the same sequence, or the same physical device, \nfor the same $\\theta_j$ that occur multiple times throughout the entire Shor algorithm.\nThen, depending on the way that the physical device is set up,\nsince the backward gate is nothing but a unitary inverse of the forward gate,\nwe may assume that the errors of the forward and backward\ngates are symmetric. Therefore, \nwhile (i) and (ii) capture systematic errors,\n(iii) deals with random errors.\n\n\n\n\\begin{figure}\n\\includegraphics[scale=1,angle=0]{fig1.eps}\n{\\vspace{+10mm}}\n\\caption {\\label{fig1}\nFidelity $F$ of a quantum computer factoring $N=15$ with seed $2$ \nas a function of standard deviation $\\sigma$ of the logical-gate errors. \nIn the order of a, b, and c, the quantum computer is equipped with \nadders that are capable of being used in Shor-algorithm-factoring \nof 4, 5, and 6-bit semiprimes.\nShown are the cases of\ntyped, asymmetric errors (triangles),\ntyped, symmetric errors (squares), and\nnon-typed, random errors (circles).\nFilled plot symbols (Red, Blue, and Black) \ndenote relative errors [see Eq.(\\ref{theta-defect-R})]\nand the open plot symbols (Orange, Cyan, and Grey) \ndenote absolute errors [see Eq.(\\ref{theta-defect-A})].\nDashed lines connecting plot symbols are drawn to guide the eye.\nThe solid, horizontal lines correspond to $F = 0$. \n\n\n\n\n}\n\\end{figure}\n\n\nTo start with, we simulate the case of factoring $N=15$.\nThis is the case used in \\cite{Mq2}, which allows us to compare the results.\nDefining fidelity $F = |\\langle \\Psi_{{\\rm actual}} | \\Psi_{{\\rm ideal}} \\rangle|^2$\nas in \\cite{Mq2}, in Fig.~\\ref{fig1} we plot $F$ as a function of $\\sigma$,\nwhere the errors $\\alpha^{(\\pm)}$ are Gaussian distributed\nrandom variables with mean 0 and standard deviation $\\sigma$.\nAt first glance, we observe that the quantum computer performs better\nin the order of the asymmetric, random, and symmetric errors.\nIn particular, symmetric errors give rise to a fidelity boost in $\\sigma$\nby an astonishing factor of $\\sim 10$ in both the ${}^{R}\\theta_j^{\\pm}$\nand the ${}^{A}\\theta_j^{\\pm}$ models.\n\nTo better feature the symmetry-driven fidelity boost, this time\nwe plot, in Fig.~\\ref{fig2}a,\nthe fidelity $F$ of Shor's algorithm\nas a function of the number of qubits $n$,\nwhile fixing the error strength\n$\\sigma = 10^{-8/3}$, $10^{-6/3}$, and $10^{-4/3}$\nfor asymmetric, random, and symmetric errors, respectively.\nThe error strengths were chosen so that\nthe corresponding resulting fidelities are \nroughly of the same magnitude,\npointing to the fact that there exists\na fidelity boost due to symmetry.\nA surprising result: Not only does \nthe fidelity boost persist,\nbut the boost is in fact enhanced\nas a function of increasing $n$.\nWhile one may expect that the fidelity\nshould decrease for increasing $n$ \n(after all, \nthe quantum computer is exposed\nto a larger number of erroneous gates),\nfor the symmetric case, apparently,\nthere is an anomalous initial {\\it increase} in $F$.\n\n\n\n\n\\begin{figure}\n\\includegraphics[scale=1,angle=0]{fig2.eps}\n{\\vspace{+10mm}}\n\\caption {\\label{fig2}\n\\small{Fidelity $F$ of Shor's algorithm running in various modes.\nFrame~a: Factoring $15$ with seed $2$ with\n$n=19, 23, 27$ and $31$ qubits, where\n$\\sigma = 10^{-8/3}, 10^{-6/3}, \\,\\text{and}\\, 10^{-4/3}$\nfor asymmetric (triangles), random (squares), \nand symmetric (circles) errors, respectively.\nFrames~b and c: Fidelity $F$ of a $U$-gate (see \\cite{Beau})\ncomputing the controlled modulo-multiplication $2 \\times 1 \\bmod 15$\nwith the control qubit turned on (qubit state $|1\\rangle$),\nas a function of adder size $L$, defined as\nthe maximal bit-length of a semiprime that may be factored\nwhen the adder is used in Shor's algorithm. The \n$U$-gates are equipped with adders that \ncontain random errors \n(b: relative and c: absolute).\nShown are the cases with $\\sigma = 0.01$ (pluses/red),\n$\\sigma = 0.02$ (squares/green), $\\sigma = 0.03$ (crosses/blue),\n$\\sigma = 0.04$ (circles/purple), and $\\sigma = 0.05$ (asterisks/cyan).\nBlack lines are fit-lines of the form \n$\\exp \\left[-10 (L+5)^2 \\sigma^2/3 \\right]$ and\n$\\exp \\left[-10 (L-1.2)^2 \\sigma^2 \\right]$ for\nFrames~b and c, respectively.\nInsets in Frames~b and c show $\\gamma$, defined according to \n$F = \\exp[-\\gamma(L) \\sigma^2]$, for $\\sigma = 0.01$\nas a function of $L$.\nFrame~d: An equivalent plot to the insets in Frames~b and c\nfor symmetric errors. Pluses (red) and crosses (green) are\nabsolute and relative errors, respectively.\nDashed lines guide the eye.\nThe fit functions (orange solid lines) for the tail regions\nare $\\exp[(L+9)/4]$ and $\\exp[(L+24)/10]$ for\nabsolute and relative errors, respectively.}\n}\n\\end{figure}\n\n\nIn an attempt to find the scaling relation\nof $F$ for Shor's algorithm as a function of $\\sigma$ and $n$,\nwe now probe a smaller computational unit of Shor's algorithm.\nIn Figs.~\\ref{fig2}b and c,\nwe plot the fidelity $F$ of a $U$-gate\nas a function of the bit-length $L$ of the adder,\nequipped with uncorrelated relative\nand absolute errors, respectively\n(as shown in \\cite{Beau}, a $U$-gate is a multiplier gate, \ni.e., \na computational unit one level smaller than\na full modulo-exponentiation gate).\nNumerically we find that the $U$-gate fidelities \nfor both cases are Gaussian in both $\\sigma$ and $L$\n(see caption of Fig.~\\ref{fig2} for details).\nThe results are in excellent agreement\nwith the corresponding data \nin Fig.~\\ref{fig1} and Fig.~\\ref{fig2}a,\nobtained by multiplying a factor $2L$\nto the exponent of the $U$-gate scaling relations (not shown),\nreflecting the fact that there are $2L$ $U$-gates\nin a complete modulo-exponentiation circuit in Shor's algorithm.\nFor reference we note that,\naccording to \\cite{Beau}, $n = 4L + 3$.\n\nWhile similar behavior is observed for\nthe interesting symmetric cases at the $U$-gate level,\ncurrently no explicit formula is available.\nAt present, it is sufficient to note that,\nfor a given $L$, the $U$-gate fidelity is\n(i) Gaussian in $\\sigma$ for small $\\sigma$ and\n(ii) exponential in $\\sigma$ for large $\\sigma$.\nExplicit numerical computations show that\nthe scaling parameters are sensitive to both\nthe multiplier of a $U$-gate and the semiprime $N$.\nAn additional difficulty arises in predicting \nthe fidelity scaling of the entire Shor algorithm:\nThe technique of multiplying a factor $2L$\nto the exponent of the $U$-gate fidelity scaling fails.\nA pleasant surprise, on the other hand, is the following:\nThe true Shor fidelity outperforms expectations.\n\nRemaining in the small-$\\sigma$ regime [case (i)],\nimportant for practical applications, and\nassuming the functional form $\\exp(-\\gamma \\sigma^2)$\nof the fidelity of the $U$-gate equipped with correlated,\nsymmetric noise, we extract the coefficient $\\gamma$\nand plot it against $L$ in Fig.~\\ref{fig2}d.\nConsistent with earlier observations,\nthe $U$-gate initially performs better as a function of increasing $L$,\nreverting to the expected behavior of deteriorating fidelity for $L > L_c$.\nWhile the exact scaling relation of $L_c$ is currently unknown\nand forms a topic for future investigations,\nin the remaining part of the paper,\nwe turn to a more important question:\nIs the symmetry-driven fidelity boost \npersistent in $n$ (and/or $L$)?\n\n\n\\begin{figure}\n\\includegraphics[scale=0.7,angle=0]{fig3.eps}\n{\\vspace{+10mm}}\n\\caption {\\label{fig3}\n\\small{Fidelity $F$ of a modulo-addition gate performing $0+2\\bmod N$,\nwhere $N$ is a semiprime.\nFrames~a and b show $F$ as a function of the bit-length $L$\nof the maximal semiprime that may be factored using\nthe employed modulo-addition gate, equipped with\nrelative and absolute symmetric errors, respectively.\nAll cases were performed with $N=15$.\nIn decreasing order of $F$,\ndifferent plot symbols refer to\n$\\sigma = 0.1 ,0.2, \\ldots, 0.9$.\nThe solid black lines in \nFrame a are the large-$L$ regime fit-lines\n$(2\\sigma+0.3)^{-2/3}$ for $\\sigma \\geq 0.6$.\nFrames~c and d show $F$ as a function of\nall odd semiprimes $N < 2^{13}$ for\nrelative and absolute symmetric errors, respectively.\nThe error strength used is $\\sigma = 0.2$.\nIn the order of pluses (red), crosses (green), asterisks (blue),\nand squares (purple), the adders are equipped with\n0, 1, 2, and 3 additional qubits than minimally required.\nFrames~e and f show logarithmically averaged $F$,\ni.e., each plot point at $x$-coordinate of $2^{j+1/2}$ \nis the result of averaging over $N$\nfrom $2^{j}$ to $2^{j+1}$, where $3 \\leq j \\leq 12$.\nNotice that for $j=3$ and $j=4$, there is only\none semiprime each, namely, 15 and 21, respectively,\nresulting in larger fluctuations due to insufficient statistics.\nSolid lines in Frame~e, with corresponding color symbols,\nare the tail-region fit lines $F = 0.807, 0.9, 0.89, \\,\\text{and}\\, 0.87$.\nSolid lines in Frame~f, with corresponding color symbols,\nare the tail-region fit lines (to first order) $F=-0.01 \\log_2 (N)+k$,\nwhere $k=0.827, 0.918, 0.885,$ and $0.841$ for\nthe four cases shown.}\n}\n\\end{figure}\n\n\nTracking down the origin of the anomalous behavior,\nwe first tested various computational sub-units of Shor's algorithm.\nWe find that a modulo-addition gate is the smallest unit\nthat exhibits the symmetry-driven fidelity boost.\nIn Fig.~\\ref{fig3}a and b, we plot \nthe fidelity $F$ of the modulo-addition gate,\nequipped with the typed, symmetric,\nrelative and absolute errors, respectively,\nexecuting $0 + 2 \\bmod 15$\nas a function of the bit-length $L$ of the adder\nfor various error levels $\\sigma$.\nWe observe that both types of errors result in an\ninitial boost in fidelity, followed by deterioration.\nWe note that while the relative kind of errors shows sustained\ndeterioration of $F$ in $L$, as would be expected from\nfurther introducing relatively more noisy gates,\nthe absolute kind of errors nearly plateaus out.\nThis may be explained as follows. \nWhile the absolute kind of noise may \ndrown out the rotation gates\nwith rotation angles smaller than the noise amplitude,\nit leaves those with angles larger than the noise amplitude relatively unaltered,\neffectively keeping the hierarchy of rotation \nangles (i.e. $\\theta_{j+1} < \\theta_j$) intact.\nThis observation agrees with the findings in \\cite{NB-qip},\ni.e., banding and hierarchy in certain quantum circuits,\nsuch as in the quantum Fourier transform\n(a backbone subroutine of Shor's algorithm \\cite{Beau}),\nare the determining factors of the performance of a quantum computer.\n\nWe now turn to the question of persistence of\nthe symmetry-induced performance boost for different semiprimes.\nSo far, we have used $N=15$ as our test case.\nThe question now is whether for all other $N$'s\nthe performance boost continues to be observed.\nIn particular, we are interested in how the fidelity changes\nwhen additional qubits are introduced into the modulo-addition gate.\nTo this end, we numerically simulated $0 + 2 \\bmod N$\nfor all odd semiprimes $N < 2^{13}$ with 0, 1, 2, and 3 additional\nqubits in the modulo-addition gate and plot the resulting $F$\nas a function of $N$ in Fig.~\\ref{fig3} c and d\nfor the relative and absolute \ncases with $\\sigma = 0.2$, respectively.\nClearly, we see that for all semiprimes we tested,\nthere is an apparent fidelity boost for both relative and absolute errors.\nAnother interesting phenomenon is that\nsemiprimes $N$ between $2^j$ and $2^{j+1}$\nare sectioned into different $F$-bands,\nprobably arising from the bit-spectra of different $N$ values,\ni.e., the binary digit 1 in the digit spectrum of $N$ turns on\nthe corresponding noisy rotation gate operation.\nThis, however, forms a subject of research in itself\nand is beyond the scope of this paper.\n\nTo highlight the result shown in Fig.~\\ref{fig3} c and d,\nwe averaged $F$ over $N$ in logarithmic scale, i.e., $2^j < N < 2^{j+1}$\nfor $j = 3, 4, \\ldots, 12$, and plot the results in \nFig.~\\ref{fig3} e and f, respectively.\nWe immediately confirm that the performance boost persists.\nIn addition, we see that\n(A) the fidelity does not scale in $N$ for the relative type of noise and\n(B) the fidelity does scale in $N$, like $\\sim \\log_2 (N)$, \nfor the absolute type of noise.\nWhile the exact reasoning behind these two observations is \ncurrently unknown,\non the basis of the following two arguments we \nspeculate that (A) and (B) are direct consequences of\nthe hierarchical structure competing with the fixed-strength errors.\nFirst, additional qubits used in the modulo-addition gates\ncorrespond to increasing the depth of the hierarchy of the quantum gates,\nwhich helps increase $F$ in the absence of errors.\nThen, for a fixed-strength error $\\sigma >0$,\nthe relative kind affects the entire hierarchy of the modulo-addition gates evenly,\ni.e., all constituent rotation gates of the modulo-addition gates \nare subjected to the same relative strength of errors.\nThis results in the plateau behavior of $F$ as shown in Fig.~\\ref{fig3} e.\nIn contrast, the absolute kind of errors drowns out all rotation gates with\nrotation angles less than the noise level, which necessarily\ncomes about as $N$ increases.\nThis is consistent with the scaling of $F$ in $\\log_2 (N) \\sim L$\n(see Fig.~\\ref{fig3} f) in that the number of drowned-out gates scales in $L$ as well.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhile we conjecture that the symmetry boost\npresented in this paper persists in the regime of\na large number of qubits,\nwe were able to check this explicitly only for $n \\leq 31$.\nGoing beyond, however, becomes prohibitively expensive,\ntaking into account that a large number of runs are needed to gather statistics.\nFor instance, let us take a look at memory requirements.\nWith double-precision complex numbers,\na single run of the $n$-qubit case requires\nat least $2^{n-26}$ GB of RAM, which already for $n=300$  \n(a relatively small number of qubits in view of \npractical applications),\namounts to more than $10^{80}$ GB, which exceeds the\nclassical resources of the entire known universe.\nTogether with a runtime that is exponential in $n$,\nany classical computer, present or future, \nquickly reaches its limits.\nNonetheless, on the basis of the simple \nanalytical scaling formula found in Fig.~\\ref{fig2},\nwe arrive at the prediction that factoring a 1000-bit semiprime \nwith $\\sim 40 \\%$ fidelity\nwould require error levels of the order of\n$\\sim 10^{-3}\\,\\%$ for uncorrelated noise,\nperfectly within practical engineering limits. \n\nThe error-level requirement is relaxed further\nwhen the noise becomes symmetric.\nIn fact, as shown in Fig.~\\ref{fig1} and\nFig.~\\ref{fig2} a, for factoring $N=15$,\nmore than a factor of 10 in $\\sigma$ \nof symmetric noise is\nallowed for a fidelity comparable to\nwhat would be observed in the uncorrelated cases.\nIn fact, we numerically confirm that the fidelity of \nmodulo-addition gates exposed to relative, uncorrelated noise\nscales like $\\exp(-1.73 L)$, consistent with the fidelity scaling we obtained\nfrom Fig.~\\ref{fig2} since there are $2L$ modulo-addition gates\nin a single $U$-gate.\nTogether with the findings in Fig.~\\ref{fig3}, i.e., that\nthe fidelity of modulo-addition gates subjected to symmetric noise\nis approximately constant in $L$\nwhen compared to its uncorrelated counterparts,\nwe arrive at the conclusion that symmetric noise\neffectively lowers the power of $L$ in the exponent of \nthe fidelity scaling relations of Shor's algorithm\nthat are subjected to the uncorrelated noise.\nFidelity may be further enhanced by employing\nextra qubits in the adder.\nAccording to Fig.~\\ref{fig3},\nthis ``trick'' will result in a constant boost in $F$ for the modulo-addition gates,\nultimately decreasing the coefficients in the exponent.\nAssuming (i) that for small $\\sigma$ the modulo-addition gates\nare operating with near perfect fidelity and\n(ii) that the Shor fidelity, to a good approximation, may be obtained\nby multiplying the modulo-addition gate fidelity by the number of its occurrences,\ndenoting by $\\delta$ and $\\Delta$ the \ndifferences of fidelity from 1\nof the modulo-addition gates with and without additional qubits, respectively, \nwe obtain for $\\delta < \\Delta$ a reduction in the coefficient of the exponent\nby approximately $\\delta / \\Delta$.\nAt this point, we recall that Shor's algorithm with symmetric noise\nperforms better than expected on the basis of \nnaive multiplication of the fidelities of its corresponding \nsmaller computational sub-units.\nTherefore we conclude that our findings are\na lower bound of the ultimately achievable improvement in fidelity,\nsince other parts of the algorithm may be identified\nwhich may also be implemented symmetrically with\nan accompanying additional boost in fidelity.\n\nWe are certain that our results are a welcome boon for \nquantum experimentalists and engineers.\nNot only is the quantum computer already resilient against irremovable\nhardware errors, but, as we showed in this paper,\nexhibits significant performance enhancement \njust by controlling the symmetry of the errors. \nWe also showed that using symmetry as a method \nto boost performance \nis well within engineering capabilities. \nThis is supported by the fact that spin-echoes \\cite{Spin-echo},\ne.g., already proved useful for practical applications \nin suppressing the naturally occurring errors in a given physical system.\nWhile it is still true that the symmetry needs to be implemented to a high precision,\nfrom the engineering perspective, the task of \nkeeping the symmetry should be\neasier than keeping the error level itself small.\nOur results are also of interest to theorists.\nGiven that the symmetry was the key \nfor the dramatic fidelity boost\nat the architectural, surface level, \nas opposed to the individual, microscopic,\ninner-workings of a single-qubit state,\nwe gain the insight that \na topologically and structurally robust \nquantum algorithm may be developed.\nGiven the fact that quantum algorithms, in general,\ntend to contain a large number of symmetric structures,\nwe expect that designing hardware that \nresults in symmetric errors, as exploited \nin this paper, may be beneficial for boosting \nperformance in other quantum\nalgorithms as well. \n\nIt would have been lamentable if the irremovable \nhardware errors in the logical qubits proliferated too quickly\nfor a quantum computer to be of practical use.\nFortunately, as we showed in this paper, this is not so.\nTogether with the pioneering works in quantum error correction\nand its fault-tolerant implementation,\nthe surprising robustness of quantum computers\nwith respect to errors and noise suggests\nthat quantum computing and quantum information\nis not just of academic interest but is \npractically useful and important. \n\n\\section*{ADDITIONAL INFORMATION}\n{\\bf Competing financial interests:} The authors declare no competing financial interests.\n\n\n\n\n\\begin{thebibliography}{99}\n \n\\bibitem{NC} Nielsen, M. A. \\& Chuang, I. L.\n{\\it Quantum Computation and Quantum Information} \n(Cambridge Univ. Press, 2000).  \n \n\\bibitem{Shor}  Shor, P. W.\n{\\it Proc. 35th Annual Symp. Foundations of Computer Science}\n124-134 (IEEE, 1994).\n\n\\bibitem{RSA} Rivest, R., Shamir, A., \\& Adleman, A.\nA method for obtaining digital signatures and public-Key cryptosystems.\n{\\it Comm. ACM} {\\bf 21} (2), 120-126\n\n(1978). \n\n\n\n\\bibitem{Landauer} Landauer, R. {\\it Quantum Computing and Communications},\n  edited by M. Brooks (Springer, 1999), 61.\n  \n\\bibitem{Shor9} Shor, P. W. \nScheme for reducing decoherence in quantum computer memory.\n{\\it Phys. Rev. A} {\\bf 52} R2493-R2496 (1995).\n\n\\bibitem{CSS1} Steane, A. M. \nError correcting codes in quantum theory.\n{\\it Phys. Rev. Lett.} {\\bf 77}, 793-797 (1996).\n\n\\bibitem{CSS2} Calderbank, A. R. \\& Shor, P. W.\nGood quantum error-correcting codes exist.\n{\\it Phys. Rev. A} {\\bf 54}, 1098-1105 (1996).\n\n\\bibitem{QECC5} Laflamme, R., Miquel, C., Paz, J. P. \\& Zurek, W. H. \nPerfect quantum error correcting code.\n{\\it Phys. Rev. Lett.} {\\bf 77} 198 (1996).\n\n\\bibitem{Fault1}  Shor, P. W.\n{\\it Proc. 37th Annual Symp. Foundations of Computer Science}\n56-65 (IEEE,1996).\n\n\\bibitem{Fault2} Steane, A. M.\nFault-tolerant quantum computing.\n{\\it Nature} {\\bf 399}, 124-126 (1999).\n\n\\bibitem{Fault3} Gottesman, D.\nTheory of fault-tolerant quantum computation.\n{\\it Phys. Rev. A} {\\bf 57}, 127-137 (1998).\n\t\t\t\n\\bibitem{Surface} Fowler, A. G., Mariantoni, M., Martinis, J. M. \\& Cleland, A. N.\nSurface codes: Towards practical large-scale quantum computation.\n{\\it Phys. Rev. A} {\\bf 86}, 032324 (2012).\n\n\\bibitem{Autotune} Fowler, A. G., Whiteside, A. C., McInnes, A. L. \\& Rabbani, A.\nTopological code Autotune.\n{\\it Phys. Rev. X} {\\bf 2}, 041003 (2012).\n\n\\bibitem{FM} Barends, R. {\\it et al.}\nSuperconducting quantum circuits at the surface code threshold for fault tolerance.\n{\\it Nature} {\\bf 508}, 500-503 (2014).\n\n\\bibitem{Morello} Muhonen, J. T. {\\it et al.}\nStoring quantum information for 30 seconds \nin a nanoelectronic device.\n{\\it Nat. Nanotech.} {\\bf 9}, 986-991 (2014).\n\n\n\n\n\n\n\n\n\n\\bibitem{Beau} Beauregard, S.\nCircuit for Shor's algorithm using 2n+3 qubits.\n{\\it Quantum Inf. and Comput.} {\\bf 3}, 175-185 (2003). \n\n\n\\bibitem{ShorArch} Markov, I. L. \\& Saeedi, M.\nConstant-optimized quantum circuits for modular multiplication and exponentiation.\n{\\it Quantum Inf. Comput.} {\\bf 12}, 361-394 (2012).\n\t\t\t\n\\bibitem{CZ} Cirac, J. I. \\& Zoller, P.\nQuantum computations with cold trapped ions.\n{\\it Phys. Rev. Lett.} {\\bf 74}, 4091-4094 (1995). \n\n\\bibitem{Mq1} Miquel, C., Paz, J. P. \\& Perazzo, R.\nFactoring in a dissipative quantum computer.\n{\\it Phys. Rev. A} {\\bf 54}, 2605-2613 (1996).\n\n\\bibitem{Mq2} Miquel, C., Paz, J. P. \\& Zurek, W. H.\nQuantum computation with phase drift errors.\n{\\it Phys. Rev. Lett.} {\\bf 78}, 3971-3974 (1997).\n\n\\bibitem{Wei} Wei, L. F., Li, X., Hu, X. \\& Nori, F.\nEffects of dynamical phases in Shor's factoring algorithm\nwith operational delays.\n{\\it Phys. Rev. A} {\\bf 71}, 022317 (2005).\n\n\n\n\n\\bibitem{Shep} Garc\\'ia-Mata, I., Frahm, K. M. \\& Shepelyansky, D. L.\nShor's factorization algorithm with a single control qubit and imperfections.\n{\\it Phys. Rev. A} {\\bf 78}, 062323 (2008).\n\t\t\t    \n\\bibitem{Liquid} Wecker, D. \\& Svore, K. M.\nLIQUi$|$$>$: A software design architecture and domain-specific language for quantum computing.\nPreprint at http://arxiv.org/abs/1402.4467 (2014).\n\n\\bibitem{Quipu} Garc\\'ia, H. J. \\& Markov, I. L.\nSimulation of quantum circuits via stabilizer frames.\n{\\it IEEE Trans. on Comput.} {\\bf 64}, 2323-2336 (2014).\n\n\\bibitem{NB-qic} Nam, Y. S. \\& Bl\\\"umel, R.\nPerformance scaling of the quantum Fourier transform\nwith defective rotation gates.\n{\\it Quantum Inf. Comput.} {\\bf 15}, 721-736 (2015). \n\n\\bibitem{NB6} Nam, Y. S. \\& Bl\\\"umel, R.\nRobustness of the quantum Fourier transform with respect to\nstatic gate defects.\n{\\it Phys. Rev. A} {\\bf 89}, 042337 (2014).\n\n\\bibitem{NB4} Nam, Y. S. \\& Bl\\\"umel, R.\nRobustness and performance scaling of a quantum computer\nwith respect to a class of static defects.\n{\\it Phys. Rev. A} {\\bf 88}, 062310 (2014).\n\n\\bibitem{NB-qip} Nam, Y. S. \\& Bl\\\"umel, R.\nStructural stability of the quantum Fourier transform.\n{\\it Quantum Inf. Process.} {\\bf 14}, 1179-1192 (2015).\n\n\n\n\n\n\n\\bibitem{Spin-echo} Hahn, E. L.\nSpin echoes.\n{\\it Phys. Rev.} {\\bf 80}, 580-594 (1950).\n\n\n\n  \n\\end{thebibliography} \n\n\\section*{AUTHOR CONTRIBUTIONS}\nY. S. Nam and R. Bl\\\"{u}mel devised the idea and\nwrote the main manuscript.\nY. S. Nam analyzed the results.\n\n\n", "itemtype": "equation", "pos": 7183, "prevtext": "\nin the case where the errors scale \naccording to the size of the gate operation and\n\n", "index": 5, "text": "\\begin{equation}\n\\label{theta-defect-A}\n{}^{A} \\theta_j^{(\\pm)} = \\left( \\begin{matrix} \n\t\t\t\t1 & 0 \\\\\n\t\t\t\t0 & e^{\\pm i\\left(\\frac{\\pi}{2^j} + \\alpha^{(\\pm)}\\right)}\n\t\t\t    \\end{matrix} \\right),\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"{}^{A}\\theta_{j}^{(\\pm)}=\\left(\\matrix{1}&amp;0\\\\&#10;0&amp;e^{\\pm i\\left(\\frac{\\pi}{2^{j}}+\\alpha^{(\\pm)}\\right)}\\right),\" display=\"block\"><mrow><mrow><mmultiscripts><mi>\u03b8</mi><mi>j</mi><mrow><mo stretchy=\"false\">(</mo><mo>\u00b1</mo><mo stretchy=\"false\">)</mo></mrow><mprescripts/><none/><mi>A</mi></mmultiscripts><mo>=</mo><mrow><mo>(</mo><mrow><mtable displaystyle=\"true\"><mtr><mtd columnalign=\"center\"><mn>1</mn></mtd></mtr></mtable><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mn>0</mn><mo>\u2062</mo><mi mathvariant=\"normal\">&amp;</mi><mo>\u2062</mo><msup><mi>e</mi><mrow><mo>\u00b1</mo><mrow><mi>i</mi><mo>\u2062</mo><mrow><mo>(</mo><mrow><mfrac><mi>\u03c0</mi><msup><mn>2</mn><mi>j</mi></msup></mfrac><mo>+</mo><msup><mi>\u03b1</mi><mrow><mo stretchy=\"false\">(</mo><mo>\u00b1</mo><mo stretchy=\"false\">)</mo></mrow></msup></mrow><mo>)</mo></mrow></mrow></mrow></msup></mrow><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math>", "type": "latex"}]