[{"file": "1601.07101.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 32034, "prevtext": "\n\n\n\n\n\n\n\n\\title{Empirical Evaluation of Ambient Sensors as Proximity Detection Mechanism for Mobile Payments}\n\n\\author{Raja Naeem Akram\\thanks{r.n.akram@rhul.ac.uk}\\qquad \nIakovous Gurulian \\thanks{Iakovos.Gurulian.2014@live.rhul.ac.uk} \\qquad\nCarlton Shepherd  \\thanks{Carlton.Shepherd.2014@live.rhul.ac.uk} \\\\\nKonstantinos Markantonakis \\thanks{k.markantonakis@rhul.ac.uk} \\qquad\nKeith Mayes \\thanks{keith.mayes@rhul.ac.uk}\\\\\nInformation Security Group, Royal Holloway, University of London.\\\\ \nEgham, United Kingdom. \n}\n\n\n\\maketitle\n\\begin{abstract}\nAccording to the UK Cards Association, 74.5 million contactless cards were issued and a total of 103.2 million contactless transactions were carried out in September 2015.  Beside financial applications, contactless cards are used increasingly in transport and access control-related applications.  Technologies such as Near Field Communications (NFC) have enabled mobile phones to emulate contactless smart cards, making them a potentially feature rich substitute -- highlighted by the recent deployment of Apple Pay and Android Pay.  Contactless smart cards, however, are susceptible to relay attack, and to avoid them, techniques such as distance bounding protocols have been proposed.  To avoid such attacks on mobile-based contactless transactions, a number of methods have been proposed that rely primarily on ambient sensors as a proximity detection mechanism (also known as an anti-relay mechanism).  In this paper, we, for the first time in academic literature, empirically evaluate a comprehensive set of ambient sensors for their effectiveness as a proximity detection mechanism -- translating into their application as an anti-relay mechanism for mobile contactless transactions.  We select a total of 17 sensors available through the Google Android platform and evaluate 15 of these. The remaining sensors were either unavailable or failed to measure any data within an acceptable timeframe for real-world deployment. In existing academic literature, only 5 sensors have been investigated as a potential anti-relay mechanism.  Each sensor, where feasible, was used to record the measurements of 1000 transactions -- each transaction comprising a terminal and mobile phone measurement pair, 2000 measurements in total per sensor -- at four different physical locations. A total of 252 random users were involved during the collection of measurements.  The analysis of these transactions in this paper provides an empirical foundation to answer the question: ``Which ambient sensors can be used an anti-relay countermeasure and what are their associated risks?\".  After collecting measurement data from the implemented sensors and carefully evaluating them, we find that no single mobile ambient sensor is suitable as a proximity detection mechanism for critical applications like banking, transport and (sensitive sites) access control. Providing an evidence for their ineffectiveness as an anti-relay mechanism in their current state as claimed in existing literature.  Lastly, we identify a number of potential avenues that may lead their application as an anti-relay mechanism.\n   \n\\end{abstract}\n\n\n\n\\section{Introduction}\n\nContactless smart cards are deployed in a multitude of applications, ranging from banking, transport and access control \\cite{markantonakis2013secure}.  Moreover, the awareness and acceptance of them is increasing, particularly in the banking sector \\cite{UKCardsAnnualRep2015a}.  While the acceptance of the contactless cards is growing, mobile (contactless) payments are also gaining acceptance, especially ``among early adopters and young age groups\" \\cite{UKCardsPayment2015a}.  In mobile (contactless) payments, Near Field Communication (NFC) provides the platform to emulate a contactless smart card.  It is expected that five percent of 600-650 million NFC enabled mobile phones will be used at least once a month in 2015 to make a contactless payment \\cite{Deloitte2015}.  We can reasonably assume, therefore, that mobile payments will be a significant payment medium in the future, potentially overtaking contactless smart cards. Although the above discussion is limited to the financial industry, similar trends are being observed in other domains where contactless smart cards are deployed \\cite{VeriFone2010}.\n\nContactless smart cards are susceptible to relay attacks \\cite{Hancke2009615,Hancke06,kfir2005picking}, as well as NFC-enabled mobile phones \\cite{FrancisHMM11,FrancisHMM10,madlmayr2008nfc,6482441}. A relay attack is a passive man-in-the-middle attack in which an attacker extends the distance between the genuine terminal (point-of-service) and genuine contactless smart card (or NFC-enabled mobile device).  This attack can enable a malicious user to access services for which the genuine user is eligible, such as paying for goods or accessing a building with physical access controls. \n\nQuantifying the number of fraudulent activities where relay attacks were employed (on both smart card and NFC mobile phones) is a challenging task.   Evidence exists, however, that academic work dealing with attacks on smart cards have been adopted by real-world criminals \\cite{Ferradi2015}.  In the domain of contactless smart cards, a potentially effective countermeasure has been distance bounding protocols \\cite{Hancke:2005:RDB:1128018.1128472,trujillo2010poulidor}.  For NFC-enabled phones, anti-relay mechanisms -- at least in academic literature -- have comprised largely of ambient sensing (section \\ref{sec:AmbientSensorDeploymetinMobilePayment}).  In this paper, we investigate the ambient sensors available through the Google Android platform and construct a test-bed environment (section \\ref{sec:FrameworkforEvaluationofAmbientSensorsEffectiveness}) to evaluate their effectiveness as a anti-relay mechanism for NFC-based transactions (section \\ref{sec:AmbientSensorEvaluation}). Additionally, we evaluate each individual sensor in relation to their technical feasibility, report any challenges that were encountered during implementation (section \\ref{sec:ExperimentationandChallenges}) and investigate their usability and reliability.  The aim of this work is to provide empirical evidence of each ambient sensor's suitability as an anti-relay mechanism (section \\ref{AntiRelayMechanismandAmbientSensorsTheVerdict}). \n\nWe continue to refer to contactless mobile payments due to the associated financial repercussions, and the attention this may attract from malicious actors.  However, the discussion in this paper is equally relevant towards the deployment of contactless mobile-based solutions in other domains, such as transport and access control.\n\n\\subsection{Contributions}\nThere are three primary contributions of this paper:\n\\begin{enumerate}\n\\item A test-bed architecture and implementation, which can be used to evaluate various sensors on Google Android devices.\n\\item A data analysis framework and methodology for evaluating ambient sensor measurements.\n\\item An empirical evaluation of the effectiveness of ambient sensors as an anti-relay mechanism.  This evaluation provides a foundation towards deciding which sensors to deploy in a target environment.\n\\end{enumerate}\n\nThe implementation of the test-bed, data analysis and collected data sets are being made available online at \\url{http://anonymised}\n\n\\section{Ambient Sensing in Mobile Payments}\n\\label{sec:AmbientSensorDeploymetinMobilePayment}\nIn this section, we briefly describe mobile phone-based contactless payments, relay attacks and a generic architecture for deploying ambient sensing as an anti-relay mechanism. \n\n\\subsection{Contactless Mobile Devices and Relay Attacks}\n\\label{sub:ContactlessMobileHandsetsAndRelayAttacks}\nDistance bounding protocols in smart cards are closely integrated with the physical layer \\cite{Hancke:2005:RDB:1128018.1128472}.  Usually, the overall architecture and process is the same with minor differences, whether the intended purpose of the smart cards is financial payments, transportation, access control or another domain.  The major differences reside in the higher-level protocols and algorithms that implement the semantics of each application.  In this section we examine contactless transactions in relation to NFC-based mobile payments; however, the overall architecture is common across all deployment domains.  \n\nWhen a user brings their NFC-enabled mobile phone close to a contactless payment terminal, the NFC in the mobile handset enters the radio frequency range around a payment terminal through which it can initiate a dialogue.  During a contactless transaction, physical contact is not necessary and in many cases a second factor of authentication, e.g. biometrics or Personal Identification Number (PIN), is not required.  As a result, it is difficult to ascertain whether an authorised user brought the mobile device near the terminal, or whether the device itself is legitimate.\n\n\\begin{figure}[ht]\n\t\\centering\n\t\t\\includegraphics[width=0.75\\columnwidth]{images/Relay_Attacks.png}\n\t\\caption{Overview of a Relay Attack}\n\t\\label{fig:relay_attack}\n\\end{figure}\n\nIn a relay attack, shown in figure \\ref{fig:relay_attack}, an attacker must emulate a malicious terminal to a genuine user and a masquerading payment instrument (mobile phone) to a genuine terminal.  The goal of the malicious actor is to extend the physical distance of the communication channel between the victim's mobile phone and the payment terminal -- relaying each messages across this extended distance.  The attacker has the potential to pay for services using the victim's account if the attacker is able to relay these messages successfully, without detection.\n\nWith contactless smart cards, relay attacks are countered using distance bounding protocols \\cite{rasmussen2010realization} or variants of such \\cite{Hancke2009615}.  Relay attacks on contactless smart cards and their countermeasures is still an active research domain, with new attacks and countermeasures emerging \\cite{Hancke:2008:ATD:1352533.1352566, Cremers2012, boureanu2014towards}.  The aim of distance bounding protocols is to enable a terminal (verifier) to enforce an upper bound on its physical distance to a smart card (prover).  The enforcement of physical distance is achieved through periodic challenge-response exchange and timing the process.  If the response is received within a predefined time (threshold), the verifier establishes that the prover is within a specified physical distance.  In a relay attack, provers may be either malicious or genuine; verifiers, however, are considered honest.  If verifiers are malicious and try to participate in a relay attack, then, logically, they are attacking themselves, which defeats the purpose of the attack. There might be a possibility that they might play a unwitting victim; however, so long as we do not consider them to be physically modifying the (certified) payment terminals, then an anti-relay mechanism will succeed. \n\nIn the domain of NFC-based contactless mobile transactions, several methods have been proposed to provide some notion of proximity detection, most of which utilise environmental (ambient) sensors present on modern mobile handsets (for related work see section \\ref{sec:RelatedWork}).  In the following section, we discuss how ambient sensors have been proposed to counter relay attacks in NFC-based mobile (contactless) transactions. \n\n\\subsection{Ambient Sensors for Proximity Detection}\nAn ambient sensor measures a particular physical property of its immediate surroundings, such as temperature, light and sound.  Most modern mobile devices, namely smartphones and tablets, are equipped with one or more of these sensors.  The physical environment surrounding a smartphone (or a terminal) can potentially provide a rich set of attributes that might be unique to that location: the sound and lighting of a quiet, brightly-lit room, for example.  Such information might be useful to implement proximity detection between two interacting devices.  \n\n\\begin{figure}[ht]\n\t\\centering\n\t\t\\includegraphics[width=0.75\\columnwidth]{images/AmbientSensorAntiRelay.png}\n\t\\caption{Generic Deployments of Ambient Sensors as Proximity Detection Mechanism}\n\t\\label{fig:AmbientSensorDeploymentOverview}\n\\end{figure}\n\nIn this section, we discuss a generic approach for deploying ambient sensing as a proximity detection mechanism using in the context of mobile payments. Figure \\ref{fig:AmbientSensorDeploymentOverview} illustrates the entities involved in this process. Variations of this approach are discussed below.\n\n\\begin{enumerate}\n\\item Independent Reporting: In this deployment scenario, depicted as solid lines in Figure \\ref{fig:AmbientSensorDeploymentOverview}, both the smartphone and terminal collect sensor measurements independent of each other and transmit these to a trusted authority.  This authority compares the sensor measurements, based on some predefined comparison algorithm with set margins of error (threshold), and decides whether the two devices were within proximity of each other.\n\\item Terminal Dependent Reporting: This scenario, depicted as double-dot-dash line in figure \\ref{fig:AmbientSensorDeploymentOverview}, involves the smartphone encrypting the sensor measurements with a shared key (between smart phone and trusted authority) and transmitting the encrypted message to the terminal.  The terminal sends its own measurements and the smartphone's to the trusted authority for comparison.\n\\item Terminal (Localised) Evaluation: The mobile phones provides its own measurement to the terminal that then locally compares it with its own measurements. The terminal then decides whether the smartphone is in its proximity. \n\\end{enumerate}\n\nRegardless of how the user interacts with the terminal, e.g. touching or tapping it with their device, the overall deployment architecture falls under one of the above scenarios.  It can be observed that there is a potential for a fourth scenario to have a mobile phone perform the proximity analysis.  However, as we consider the terminal to be the (potentially) trusted device, as per the discussion in section \\ref{sub:ContactlessMobileHandsetsAndRelayAttacks} and mobile phones might be with malicious entity, this scenario is not discussed.\n\n\\subsection{Related Work}\n\\label{sec:RelatedWork}\nA substantial section of work surrounding anti-relay countermeasures for contactless smart cards is on distance bounding protocols \\cite{DrimerM07,Francillon11} discussed previously.  However, these may not be feasible for NFC-enabled phones -- at the current state-of-the-art -- due to their requirement of high time-delay sensitivity and specialised hardware \\cite{Coskun2013,Halevi2012}.\n\nDrimer et al.\\ \\cite{DrimerM07} and Ma et al.\\ \\cite{6378376} showed how location-related data, namely using GPS (Global Positioning System), can be used to determine the proximity of two NFC mobile phones.  Ma et al. use a ten second window with location information collected every second, which was subsequently compared across various devices.  The authors report a high success rate in identifying the devices in close proximity to one another.\n\nHalevi et al.\\ \\cite{Halevi2012} demonstrated the suitability of using ambient sound and light for proximity detection.  Here, the authors analysed the sensor measurements -- collected at 2 seconds and 30 seconds for light and audio respectively -- using a range of similarity comparison algorithms.  Extensive experiments were performed different physical locations, with a high success rate of detecting co-located devices.\n\nVarshavsky et al.\\ \\cite{Varshavsky2007} based their proximity detection mechanism on the shared radio environment of devices -- the presence of WiFi access points and associated signal strengths -- using the application scenario of secure device pairing.  In this work, they considered this approach to produce low error rates, recommending it as a proximity detection mechanism.  While their paper did not focus on NFC mobile transactions, their techniques and methodology may still be applicable.\n\nUrien et al.\\ \\cite{Urien201428} use ambient temperature with an elliptic curve-based RFID/NFC authentication protocol to determine whether two devices are co-located.  Using this method, they were successful in establishing a secure channel; the proposal combines the timing channels in RFID -- traditionally used in distance bounding protocols -- in conjunction with ambient temperature.  Their proposal, however, was not implemented and there is no experimental data provided to evaluate its efficacy.\n\nMehrnezhad et al.\\ \\cite{mehrnezhad2014tap} proposed the use of an accelerometer to provide assurance that the mobile phone is within the vicinity of the terminal.  Their proposal requires the user to tap the payment terminal twice in succession, after which the sensor streams of the device and terminal are compared for similarity.  It is difficult to deduce the total time it took to complete one transaction, but the authors have provided a recording time range of 0.6--1.5 seconds.\n\n  \\begin{table}[ht]\n\t\\centering\n\t\\caption{Related Work in Sensors as Anti-Relay Mechanism}\n\t\\label{tab:RelatedWork}\n    \\resizebox{0.65\\columnwidth}{!}{\n\t\t\t\\begin{tabular}{@{}lccc@{}}\n\t\t\t\t\\toprule\n\t\t\t\t\\multirow{2}{*}{\\textbf{Paper}} & \\multirow{2}{*}{\\textbf{Sensor}} \n                & \\textbf{Sample} & \\textbf{Contactless}\\\\\n                && \\textbf{Duration} & \\textbf{Suitability}\\\\\n                \\midrule\n    \t Ma et al.\\ \\cite{6378376} & GPS & 10 seconds & Possibly Not \\\\ [0.6ex]\n         \\hdashline \n        \\multirow{2}{*}{Halevi et al.\\ \\cite{Halevi2012}} & Audio  & 30 seconds &  Possibly Not\\\\ \n        \t\t\t\t\t\t\t\t\t\t\t\t & Light  & 2 seconds &  Potentially \\\\ [0.8ex]\n                                                         \\hdashline\n      \t\\multirow{2}{*}{Varshavsky et al.\\ \\cite{Varshavsky2007}} & WiFi & \\multirow{2}{*}{1 second} & \\multirow{2}{*}{Potentially} \\\\ \n        \t\t\t\t\t\t\t\t\t\t\t\t\t     & (Radio Waves) &  &  \\\\ [0.6ex]\n                                                                 \\hdashline\n    \tUrien et al.\\ \\cite{Urien201428} & Temperature & N/A & - \\\\ [0.6ex]\n        \\hdashline\n        Mehrnezhad et al.\\ \\cite{mehrnezhad2014tap} & Accelerometer & 0.6 to 1.5 Seconds & Potentially\\\\\n    \n\t\t\\bottomrule\n\t\t\t\\end{tabular}\n    }\n\\end{table}\n\nWe have summarised the related work in Table \\ref{tab:RelatedWork}, using sensor sampling durations to determine whether a given approach is suitable for contactless NFC mobile phone services, namely in banking and transportation.  The goal of contactless transactions in these sectors is to serve people served as efficiently as possible, so time is critical in determining whether a transaction is successful and, indeed, permitted. An optimum transaction duration would be in milliseconds, rather then seconds.  We will return to the discussion about transaction duration limits later in section \\ref{sec:Test-Bed_Architecture}. \n\nAmbient sensing is also used in user-device authentication, key generation and establishment of secure channels.  These application typically measure the environment for longer periods of time (>1 second) and, generally speaking, their primary goal is not proximity detection.  As such, we do not discuss them in this section.  \n\nThe field of ambient sensors for proximity detection for NFC mobile services is expanding, as illustrated by the number of proposals currently exist.  In this paper, we extend the discussion to a large set of ambient sensors.  We evaluate the suitability of sensors proposed currently and investigated a range of sensors not yet explored as an anti-relay mechanism in related work.  Table \\ref{tab:availability} shows that we have undertaken a comprehensive evaluation of ambient sensors for proximity detection (fifteen in total). In the existing literature, only five of these sensors are proposed and evaluated as proximity detection mechanism in related literature -- illustrated in Table \\ref{tab:RelatedWork}.  Effectively, we have not only empirically re-evalauted the already proposed sensors for their effectiveness, but we have expanded the work on proximity detection mechanism based on ambient sensors by an additional ten sensors -- to counter relay attacks on mobile contactless transactions.  \n\n\\section{Framework for Evaluating Ambient Sensors}\n\\label{sec:FrameworkforEvaluationofAmbientSensorsEffectiveness}\n\nIn this section, we describe the test-bed that was developed to test, analyse and evaluate the effectiveness of using various ambient sensors as an anti-relay mechanism.\nThe results of the evaluation are presented in Section~\\ref{sec:AmbientSensorEvaluation}.\n\n\\subsection{Test-bed Architecture}\n\\label{sec:Test-Bed_Architecture}\nTwo applications were implemented and installed on pairs of Android devices, one as a terminal (reader) and the other as the mobile device (card).\nWhen the devices touch, an NFC connection is established and both begin recording data using a pre-specified sensor.  Upon successful completion of the measurements, each device stores the recorded data in a local database, shown in Figure~\\ref{fig:Architecture}.\n\n\\begin{figure}[ht]\n\t\\centering\n\t\\includegraphics[width=0.70\\columnwidth]{images/Diagram.png}\n\t\\caption{Test-bed Architecture}\n\t\\label{fig:Architecture}\n\\end{figure}\n\n\nA more detailed view of this process is depicted in Figure~\\ref{fig:diagram}.  Bringing the two devices together causes the terminal application to send a message to the mobile device, stating which sensor it uses in the transaction, along with a unique transaction ID\\@.\nAfter this message is received by the mobile device, both applications initiate the process to record a measurement, by storing values returned by a sensor.  The recording process lasts 500ms -- the maximum permitted time in which a contactless payment transaction should complete in accordance with the ``\\textit{EMV Contactless Specifications for Payment Systems: Book A}\" \\cite{EVM2015-ContactlessArchitectureReq} and additional industrial specifications like \\cite{VISAMobileTicketing2013,MasterCard2014,VISA-TADG}.  According to \\cite{MasterCard2014} the same document, this time limit will be reduced gradually to 400ms from 2016 onwards.  For transport-related transactions, the performance requirements are stricter, where transaction times should not exceed 300ms \\cite{transport300,emms2014harvesting}.\n\nAfter completing the measurements, the mobile device validates the data it received from the terminal (in message one), returning a completion or rejection message accordingly.  This is along with which sensor was used on the mobile device and the transaction ID received from the terminal in message one.  This validation process ensures that the two devices were recording data from the same sensor.\n\nFinally, the terminal verifies the data received from the mobile device, ensuring that the mobile device was measuring the same transaction, using the transaction ID and whether the two devices were recording from the same sensor. Upon validation, the devices save the measurements in their local databases.  In the event of any inconsistencies during the exchange, i.e. the devices recorded data for differing transaction IDs, then the measurement is rejected.  The database is designed to hold measurements for each transaction, which are used to analyse and evaluate the effectiveness of each sensor.\n\n\\begin{figure}[ht]\n\t\\centering\n\t\\resizebox{0.75\\columnwidth}{!}{\n\t\t\\begin{sequencediagram}\n\n\t\t\t\\tikzstyle{inststyle}+=[rounded corners=3mm]\n\t\t\t\\newthread{reader}{Terminal}\n\t\t\t\\newinst[4]{card}{Mobile device}\n\t\t\t\\begin{call}{reader}{1) sensor|transaction ID}{card}{2) sensor|transaction ID}\n\t\t\t\t\\begin{callself}{reader}{recordSensor()}{}\n\t\t\t\t\t\\postlevel\n\t\t\t\t\\end{callself}\n\t\t\t\t\\prelevel\\prelevel\\prelevel\n\t\t\t\t\\begin{callself}{card}{recordSensor()}{}\n\t\t\t\t\t\\postlevel\n\t\t\t\t\\end{callself}\n\t\t\t\t\\begin{callself}{card}{validateReceivedData()}{}\n\t\t\t\t\\end{callself}\n\t\t\t\\end{call}\n\n\t\t\t\\begin{callself}{card}{saveMeasurement()}{}\n\t\t\t\\end{callself}\n\t\t\t\\prelevel\\prelevel\n\t\t\t\\begin{callself}{reader}{validateReceivedData()}{}\n\t\t\t\\end{callself}\n\t\t\t\\begin{callself}{reader}{saveMeasurement()}{}\n\t\t\t\\end{callself}\n\n\t\t\\end{sequencediagram}\n\t}\n\t\\caption{Measurement Recording Overview}\n\t\\label{fig:diagram}\n\\end{figure} \n\n\\subsection{Data Collection Framework}\n\\label{datacollectionsection}\nTo gauge the sensor variance in physical locations and how this influences proximity detection, we test each sensor in four different locations around the university: the lab, cafeteria, dining hall and library.  Furthermore, a user study was conducted in each location to incorporate data from differing user behavioural profiles: 252 participants supplied a varying number of transactions, with each providing a minimum of one transaction per sensor.\n\nFour devices were used in the experiments, forming two \\textit{mobile-terminal device} pairs.\nThe first consisted of two Nexus 9 tablets, while the second pair comprised two Android smartphones: a Nexus 5, assuming the role of the terminal and a Samsung Galaxy S5 mini (SGS5 mini), acting as the mobile device.  Not all sensors were present on all devices; the ones present on the tablets formed one data set, with the remaining sensors forming a second set.  The availability of the sensors on each device can be found in Table~\\ref{tab:availability}, along with which sensors comprised each set.\nSensors with technical limitations -- Bluetooth, GPS, Rotation Vector and WiFi -- although present on the devices, returned no or very few data points (>99\\% transaction failure) within the 500ms timeframe.  The specific limitations for each of these sensors are described in more detail in Appendix~\\ref{sec:appendixB}.\nTwo sensors, the humidity and the temperature sensors, are relatively uncommon among Android devices and none of our tested devices contained them, thus we excluded them from this study.\n\n\\begin{table}[t]\n\t\\centering\n\t\\caption{Sensor Availability}\n\t\\label{tab:availability}\n\t\\resizebox{0.75\\columnwidth}{!}{\n\t\t\\begin{threeparttable}\n\t\t\t\\begin{tabular}{@{}lcccc@{}}\n\t\t\t\t\\toprule\n\t\t\t\t\\multicolumn{1}{c}{\\textbf{Sensors}} & \\textbf{Nexus 9 (1)} & \\textbf{Nexus 9 (2)} & \\textbf{Nexus 5} & \\textbf{SGS5 mini} \\\\ \\midrule\n\t\t\t\t\\rowcolor[HTML]{EFEFEF}\n\t\t\t\t\\multicolumn{5}{c}{\\cellcolor[HTML]{EFEFEF}Nexus 9 (1) $\\rightarrow$ Nexus 9 (2)} \\\\\n\t\t\t\t\\textbf{Accelerometer} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Bluetooth} & $\\ast$ & $\\ast$ & $\\ast$ & $\\ast$ \\\\\n\t\t\t\t\\textbf{GRV$^\\dag$} & {\\ding{51}} & {\\ding{51}} & $\\ast$ & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{GPS} & $\\ast$ & $\\ast$ & $\\ast$ & $\\ast$ \\\\\n\t\t\t\t\\textbf{Gyroscope} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Magnetic Field} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Network Location} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Pressure} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & {\\ding{55}} \\\\\n\t\t\t\t\\textbf{Rotation Vector} & $\\ast$ & $\\ast$ & $\\ast$ & $\\ast$ \\\\\n\t\t\t\t\\textbf{Sound} & {\\ding{51}} & {\\ding{51}} & {\\ding{51}} & $\\ast$ \\\\\n\t\t\t\t\\textbf{WiFi} & $\\ast$ & $\\ast$ & $\\ast$ & $\\ast$ \\\\\n\t\t\t\t\\multicolumn{5}{c}{\\cellcolor[HTML]{EFEFEF}SGS5 mini $\\rightarrow$ Nexus 5} \\\\\n\t\t\t\t\\textbf{Gravity} & $\\circ$ & $\\circ$ & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Light} & $\\ast$ & $\\ast$ & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Linear Acceleration} & $\\circ$ & $\\circ$ & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\textbf{Proximity} & {\\ding{55}} & {\\ding{55}} & {\\ding{51}} & {\\ding{51}} \\\\\n\t\t\t\t\\multicolumn{5}{c}{\\cellcolor[HTML]{EFEFEF}Unsupported} \\\\\n\t\t\t\t\\textbf{Humidity} & {\\ding{55}} & {\\ding{55}} & {\\ding{55}} & {\\ding{55}} \\\\\n\t\t\t\t\\textbf{Temperature} & {\\ding{55}} & {\\ding{55}} & {\\ding{55}} & {\\ding{55}} \\\\ \\bottomrule\n\t\t\t\\end{tabular}\n\n\t\t\t\\begin{tablenotes}\n\t\t\t\\item{\\ding{51}}: Working properly.\n\t\t\t\t{\\ding{55}}: Not present on device.\n\t\t\t\t$\\ast$: Technical limitations.\\\\\n\t\t\t\t$\\circ$: Only returning \\textit{0s}.\n\t\t\t\\item[\\dag] Geomagnetic Rotation Vector\n\t\t\t\\end{tablenotes}\n\t\t\\end{threeparttable}\n\n\t}\n\\end{table}\n\nA minimum of 1000 transactions -- measurement pairs for which both mobile and terminal have corresponding sensor data -- were recorded for each sensor.  700 measurements for each sensor were recorded in the Lab, with 100 in each of the remaining locations.\n\nThe Android operating system returns data captured by a sensor in time intervals set by the application.  To prevent unnecessary power consumption, the sensor values are returned by the operating system only when the values have altered.  The sound sensor (microphone), however, captures data in a continuous, uninterrupted stream.  In this instance, the applications convert the recorded amplitudes into sound pressure levels (in decibels) before storing the values in their respective databases.\nWith Bluetooth, data is sent from the operating system to the application every time a new Bluetooth device is discovered; with WiFi, this is once the device has completed scanning the presence of nearby access points.\n\nOn each device (terminal and mobile), each transaction generated a single database record containing the sensor values measured over 500ms.\nThe recorded sensor measurements were subsequently stored in the database in XML form. Every time sensor values were returned, a new child element was created containing the sequence ID of the measurement, the timestamp (initialised to zero at the start of the transaction), along with the recorded sensor measurements.  A sample XML record can be found in Listing~\\ref{lst:xml}.\nThe data measurements -- whether a sensor returned one or multiple values per sample -- were saved in a generic format \\textit{(e.g.\\ data0, data1, etc.)} for convenience, and later assigned to their actual units during the analysis phase, in accordance with the Android documentation~\\cite{sensorUnits}.\nDetails for each sensor can be found in Appendix~\\ref{sec:AmbientSensors}.\n\nThe sequence ID of each measurement, the date and time the transaction occurred, the location in which it was captured, and the transaction ID were also stored in the database.\n\n\\begin{lstlisting}[style=listXML, caption={Sample XML Record}, label={lst:xml}, float, floatplacement=H]\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<measurements>\n\t....\n\t<measurement>\n\t\t<id>6</id>\n\t\t<timestamp>60</timestamp>\n\t\t<data0>-0.32935655</data0>\n\t\t<data1>6.2396774</data1>\n\t\t<data2>-7.558329</data2>\n\t</measurement>\n\t....\n</measurements>\n\\end{lstlisting}\n\nThe transaction ID is a random 7-byte string generated by the terminal, used to assist in linking the measurements of each device to represent a single transaction.\n\nOccasionally, the connection is disrupted when the mobile device has already replied to the terminal (message 2 in figure~\\ref{fig:diagram}) while the terminal has not yet finished processing it.  As a result, the measurement is stored only on the mobile device; this occurs typically when the two devices are moved apart before the end of the transaction.  To counter this, the transaction ID is used in conjunction with the sequence ID to detect and exclude these measurements during the analysis phase.\n\n\n\n\n\n\n\n\nAfter completing the experiments, the databases were extracted from the devices via USB and transferred to the PC running the analysis software.\n\n\\subsection{Data Analysis and Evaluation Criteria}\n\\label{sec:DataAnalysisandEvaluationCriteria}\n\nAfter retrieving the databases from the terminal and mobile, the set of all transactions, $T$, was produced using the shared IDs generated during data collection.  Each transaction may be thought of as the set of reader and mobile values, $R_{i}$ and $M_{i}$, with the same shared ID, i.e.\\ $T_{i} = (R_{i}, M_{i})$.  A Python application was developed for analysing the transaction measurements from the application databases, employing the SciPy library \\cite{scipy} for numerical computation.\n\n\n\n\n", "index": 1, "text": "\\begin{equation}\n2r\\footnote{$r$ represents the radius of Earth: 6371km} \\arcsin  \\left(\\sqrt{\\sin^2\\frac{\\phi_2 - \\phi_1}{2}\n+ \\cos{\\phi_1} \\cos{\\phi_2}\\sin^2\\frac{\\lambda_2 - \\lambda_1}{2}}\\right)\n\\label{haversineeq}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E1.m1\" class=\"ltx_Math\" alttext=\"2r\\footnote{$r$ represents the radius of Earth: 6371km}\\arcsin\\left(\\sqrt{\\sin%&#10;^{2}\\frac{\\phi_{2}-\\phi_{1}}{2}+\\cos{\\phi_{1}}\\cos{\\phi_{2}}\\sin^{2}\\frac{%&#10;\\lambda_{2}-\\lambda_{1}}{2}}\\right)\" display=\"block\"><mrow><mn>2</mn><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mtext><span xmlns=\"http://www.w3.org/1999/xhtml\" class=\"ltx_note ltx_role_footnote\"><sup class=\"ltx_note_mark\">1</sup><span class=\"ltx_note_outer\"><span class=\"ltx_note_content\"><sup class=\"ltx_note_mark\">1</sup><XMath xmlns=\"http://dlmf.nist.gov/LaTeXML\">\n                    <XMTok font=\"italic\" role=\"UNKNOWN\">r</XMTok>\n                  </XMath> represents the radius of Earth: 6371km</span></span></span></mtext><mo>\u2062</mo><mrow><mi>arcsin</mi><mo>\u2061</mo><mrow><mo>(</mo><msqrt><mrow><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mfrac><mrow><msub><mi>\u03d5</mi><mn>2</mn></msub><mo>-</mo><msub><mi>\u03d5</mi><mn>1</mn></msub></mrow><mn>2</mn></mfrac></mrow><mo>+</mo><mrow><mrow><mi>cos</mi><mo>\u2061</mo><msub><mi>\u03d5</mi><mn>1</mn></msub></mrow><mo>\u2062</mo><mrow><mi>cos</mi><mo>\u2061</mo><msub><mi>\u03d5</mi><mn>2</mn></msub></mrow><mo>\u2062</mo><mrow><msup><mi>sin</mi><mn>2</mn></msup><mo>\u2061</mo><mfrac><mrow><msub><mi>\u03bb</mi><mn>2</mn></msub><mo>-</mo><msub><mi>\u03bb</mi><mn>1</mn></msub></mrow><mn>2</mn></mfrac></mrow></mrow></mrow></msqrt><mo>)</mo></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07101.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 32269, "prevtext": "\n\n\n", "index": 3, "text": "\\begin{equation}\nM = \\sqrt{x^{2} + y^{2} + z^{2}}\n\\label{mageq}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E2.m1\" class=\"ltx_Math\" alttext=\"M=\\sqrt{x^{2}+y^{2}+z^{2}}\" display=\"block\"><mrow><mi>M</mi><mo>=</mo><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup></mrow></msqrt></mrow></math>", "type": "latex"}, {"file": "1601.07101.tex", "nexttext": "\n\n\n", "itemtype": "equation", "pos": 32349, "prevtext": "\n\n\n", "index": 5, "text": "\\begin{equation}\nMAE(R_{i}, M_{i}) = \\frac{1}{N}\\sum_{j=0}^{N} | R_{i,j} - M_{i,j} |\n\\label{aadeq}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E3.m1\" class=\"ltx_Math\" alttext=\"MAE(R_{i},M_{i})=\\frac{1}{N}\\sum_{j=0}^{N}|R_{i,j}-M_{i,j}|\" display=\"block\"><mrow><mrow><mi>M</mi><mo>\u2062</mo><mi>A</mi><mo>\u2062</mo><mi>E</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><mi>i</mi></msub><mo>,</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mi>N</mi></mfrac><mo>\u2062</mo><mrow><munderover><mo largeop=\"true\" movablelimits=\"false\" symmetric=\"true\">\u2211</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></munderover><mrow><mo stretchy=\"false\">|</mo><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>-</mo><msub><mi>M</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mo stretchy=\"false\">|</mo></mrow></mrow></mrow></mrow></math>", "type": "latex"}, {"file": "1601.07101.tex", "nexttext": "\n\n\nTo compare $(R_{i}, M_{i})$, we measure the similarity distance between the two, which was measured differently according to sensor type. \nFor network location, this was calculated using the Haversine formula (Eq.\\ \\ref{haversineeq}), which measures the geographic distance between two latitude and longitude pairs, $\\{(\\phi_1, \\lambda_1), (\\phi_2, \\lambda_2)\\}$.\nFor the remaining sensors, similarity was measured using the \\emph{mean absolute error} (MAE, Eq.\\ \\ref{aadeq}) and \\emph{correlation coefficient} (Eq.\\ \\ref{correq}), as used in \\cite{mehrnezhad2014tap}, between the signals of $R_{i}$ and $M_{i}$, with each containing $N$ measurements.  Certain sensors -- the accelerometer, gyroscope, magnetic field, rotation vector and GRV sensors -- produce a vector of values comprising $x$, $y$ and $z$ components.  In these instances, the vector magnitude (Eq.\\ \\ref{mageq}) was used as a general-purpose method for producing a single, combined value prior to computing the MAE and correlation coefficient.\n\n\\section{Experimentation and Challenges}\n\\label{sec:ExperimentationandChallenges}\n\nIn this section, we discuss the challenges encountered in implementing the test-bed, during data collection and in analysing and evaluating the collected data. \n\n\n\\subsection{Implementation Challenges}\n\\label{sec:ImplementationChallenges}\nA number of challenges were encountered during the implementation phase, particularly in relation to recording sufficient sensor values in a relatively short time period.\n\n\n The clocks of the two devices involved in a transaction cannot be expected to be completely synchronised, particularly in a real-world deployment.\n\t\tIn order for the measurements on the devices to initiate as close to each other as possible, we perform the validity and integrity checks after the recordings have finished.  Consequently, the recorded measurement is rejected at the end of the transaction in the event of any inconsistencies.\n\nTo capture the maximum possible amount of data, the applications were designed such that no threads, or other process-intense components, were used prior to the initialisation of the measurement recording (other than those started by the Android API automatically).\n\t\tThe threads initiated by the Android API were responsible to listen for sensor changes.\n\nThe sound sensor's development was relatively challenging.\n    \tTypically, to avoid any problems, the microphone should be accessed from within a separate thread, otherwise the NFC communication stops for as long as the microphone is being used.\n        Initiating a thread prior to accessing the microphone had an impact in the performance of the application, leading to no data being recorded in 500ms.\n        To overcome this issue, no threads were used.  Instead, the code responsible for checking whether the NFC connection was lost had to be removed, so solely for this sensor data in the devices was being saved even in the occasion of NFC connection loss.\n\nEnsuring that the recording of each sensor will not exceed 500ms since the initiation of the transaction was a high priority requirement that faced number of challenges.\n\t\tA common way to run a task for a specific duration of time in Java is by using a timer inside a thread.\n\t\tSince the timer is initiated after the creation of a thread, which is a processor intense procedure, there is no guarantee that the measurement will last for no more than 500ms since the initiation of the transaction. \n\t\tTo overcome this issue, we track the system time on the terminal side when it sends the first message to the device and on the mobile device side, when it receives the first message from the terminal.\n\t\tA loop ensures that measurements after the 500ms timeframe will not be stored and the recording will terminate.\n\nThe \\texttt{HostApduService} class was used for the implementation of the mobile device application, which is capable of emulating an NFC card on an Android handset, and is the basis of implementing a Host Card Emulation (HCE) service~\\cite{hce}.\n\t\tHCE was introduced on Android 4.4 (API level 19), therefore the handset that acts as the mobile device in the experiment should be running Android 4.4 or later.\n\nThe data from the sensors was retrieved in time intervals of 10ms.\n\t\tAlthough the SGS5 mini device was capable of collecting data at a higher frequency (less than 1ms), the fastest common value across all our devices was 10ms.\n\n\n\\begin{figure}\n    \\centering\n    \\begin{subfigure}[b]{0.31\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/flow_1.eps}\n        \\caption{Step One}\n        \\label{fig:Step_One}\n    \\end{subfigure}\n    ~ \n      \n    \\begin{subfigure}[b]{0.31\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/flow_2.eps}\n        \\caption{Step Two}\n        \\label{fig:Step_Two}\n    \\end{subfigure}\n    ~ \n    \n    \\begin{subfigure}[b]{0.31\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/flow_3.eps}\n        \\caption{Step Three}\n        \\label{fig:Step_Three}\n    \\end{subfigure}\n    \\caption{Data Analysis Workflow for Accelerometer-based Transactions}\\label{fig:workflow}\n\\end{figure}\n\n\\subsection{Data Collection Challenges}\nHere, we discuss a selection of challenges faced during the data collection process. \n\n\nAlthough the sampling rate for retrieving sensor values was set to 10ms, we encountered variance in the intervals that sensors returned data, as well as in the granularity of values provided across different devices.\n\t\tAs mentioned previously, only when there is a significant change in the values recorded by a sensor are they returned to the application~\\cite{AndroidAPIRef}.\tAs we are using a relatively small sampling rate (10ms), it is possible that there was no change in the values observed by the sensor, so no data was returned.\n\t\tAnother reason relates to other processes, services and daemons running in the background that may also be causing slight delays to the frequency that an application is notified about sensor changes.\n\t\tDuring our experiments we ensured these delays were limited by uninstalling CPU-heavy applications and disabling any background services.  However, such precautions cannot be enforced in a real-world, wide-scale deployment by a general mobile application. However, a well embedded application into the Android platform with process priority and isolation might avoid it. \n\nVarious sensors -- WiFi, GPS and Bluetooth -- were excluded from the study, since they were not capable of returning any useful data in the 500ms timeframe.\n\t\tWe performed an initial limited experiment in which we only took 100 transactions per sensors prior to the data collection phase, and found that 100\\% of these transactions from WiFi and GPS sensors contained little to no measurement data (i.e. at least one nearby WiFi access point or Bluetooth device). For bluetooth, 99\\% of the transactions contained little to no data points. As a result, they were excluded from the rest of our analysis.\n\t\t\n        A separate application was built to measure the average time required for the WiFi and Bluetooth sensors to capture sufficient data.\n\t\tThe GPS sensor's speed and accuracy are very dependent on the environment in which it is being tested.\n\t\tThe results for 50 sensor measurements for the WiFi and the Bluetooth are presented in Table~\\ref{tab:wifibt}.\n\n\n\\begin{table}[b]\n\t\\centering\n\t\\caption{Time Required for Receiving Results from Sensors}\n\t\\label{tab:wifibt}\n\t\\resizebox{0.75\\columnwidth}{!}{\n\t\t\\begin{tabular}{@{}llll@{}}\n\t\t\t\\toprule\n\t\t\t\\multicolumn{1}{c}{\\textbf{Sensor}} & \\multicolumn{1}{c}{\\textbf{Average time}} & \\multicolumn{1}{c}{\\textbf{Minimum time}} & \\multicolumn{1}{c}{\\textbf{Maximum time}} \\\\ \\midrule\n\t\t\t\\textbf{Bluetooth} & 962.7ms & 354ms & 1960ms \\\\\n\t\t\t\\textbf{WiFi} & 3873.5ms & 3795ms & 3954ms \\\\ \\bottomrule\n\t\t\\end{tabular}\n\t}\n\\end{table}\n\n\\subsection{Data Analysis Challenges}\n\nDuring the data analysis, we faced a number of challenges.  Below is a list of some selected challenges that we had to overcome. \n\n\\begin{itemize}\n\\item After acquiring the data from the card and reader, we used linear interpolation to mitigate the effect of missing and inconsistent samples due to the unwanted variation in sampling rates (steps \\textbf{1} and \\textbf{2} of figure \\ref{fig:workflow}).\n\n\n\n\n\n\n\n\n\\item Data sampling rarely finished at 500ms precisely: Figure \\ref{fig:magfield} illustrates that the reader's final sample occurs at $\\approx$490ms, while the card finished at $\\approx$460ms.  To counter this, interpolation was performed up to the maximum time period shared by both devices (460ms) and any samples beyond this point were discarded.  \n\t\\begin{itemize}\n    \t\\item Correlation, however, is sensitive to this type of truncation.  If relatively extreme values are discarded, such as the reader's measurements between 0-100ms in figure \\ref{fig:magfield}, then correlation may differ significantly.  \n    \\end{itemize}\n\\item Only one measurement was collected at maximum -- if any were collected at all -- when analysing network location for all transactions.  Since correlation is undefined for a single point, we calculated only the MAE for this particular modality.\n\n\\item For 43\\% of gyroscope-based transactions (430 of 1000), a value of zero was measured for the entire transaction on the card or reader, indicating that the device was not perturbed sufficiently to alter the sensor's resting value.  Correlation is undefined for a single point, so these transactions were discarded for the correlation analysis.\n\n\\item On one device (SGS5 mini), the light sensor returned values far more frequently than the other.  With the Nexus 5, only one light measurement was captured on average during the 500ms timeframe, while the SGS5 mini collected 48--50 measurements.  Rather than truncating a significant number of measurements, we assumed that all of the Nexus 5 values lay on a straight line, with a gradient of zero, and calculated the MAE using this.  (Note that correlation is undefined in this case).\n\n\\item The proximity sensor on both tested devices (Nexus 5 and SGS5 mini -- see table returned only a binary value, representing \\emph{near} and \\emph{far}, rather than the precise proximity of the device to an object in centimetres.  The Android documentation states that `some' devices provide a binary value rather than a real value \\cite{androidposition}.  In our dataset, both devices registered as `far' for all transactions, as the proximity sensor -- located on the front of the device -- was not covered on either end.\n\\end{itemize}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.70\\columnwidth]{images/MagneticField.eps}\n\\caption{Example Magnetic Field transaction illustrating differing finishing times for the card and reader}\n\\label{fig:magfield}\n\\end{figure}\n\n\\section{Ambient Sensor Evaluation}\n\\label{sec:AmbientSensorEvaluation}\n\n\n\nIn this section, we describe the methodology to calculate False Positive Rate (FPR), False Negative Rate (FNR) and Equal Error Rate (EER). Furthermore, we present the results of our analysis for each individual sensor.  \n\n\\subsection{Calculating the FPR, FNR and EER}\nAs discussed in Section \\ref{sec:DataAnalysisandEvaluationCriteria}, each transaction, $T_i$, comprises a set of $R_i$ and $M_i$ measurements.  From this data, we compute the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ for each successful transaction.   We calculate the FPR, FNR and EER of a each sensor by testing the $MAE$ and $corr$ of the set of authorised transaction pairs, $(R_i, M_i)$, against the $MAE$ and $corr$ of unauthorised pairs $(R_i, M_j)$ using some threshold, $t$.  Ideally, $(R_i, M_i) < t$ and $(R_i, M_j) > t$ for all possible pairs.  To calculate the FPR, we implemented the algorithm in Listing \\ref{CalculatingFAR}:\n\n\\begin{lstlisting}[style=customc, caption={Calculating False Positive Rate},label=CalculatingFAR]\n/* Pseudocode to calculate FPR data points */\nint t = Tested_Threshold;\nint maxint = Number_of_Transactions;\nint FPS = 0; // False positives\nint TNS = 0; // True negatives\nfor (int i = 1; i <= maxint; i++) {\n  for (int j = 1; j <= maxint; j++) {\n    if (i != j) {\n      calculateMAE(Ri, Mj);\n      if (MAE(Ri, Mj) < t)\n         FPS++;\n      else\n         TNS++;\n    }        \n  }\n}\ndouble FPR = FPS / (FPS + TNS);\nwrite(FPR);\n\\end{lstlisting}\n\nThe calculation of FPR based on $corr$ follows the same algorithm, only substituting $MAE$ with the $corr$ function.  To calculate the False Negative Rate (FNR), we implemented the algorithm described in Listing \\ref{CalculatingFNR}.  As with FPR, substituting $MAE$ for $corr$ in Listing \\ref{CalculatingFNR} allows us to generate an FNR curve based on correlation. \n\n\\begin{lstlisting}[style=customc, caption={Calculating False Negative Rate},label=CalculatingFNR]\n/* Pseudocode to calculate FNR data points */\nint t = Test_Threshold;\nint maxint = Number_of_Transactions;\nint FNS = 0;  // False negatives\nint TPS = 0;  // True positives\nfor (int i = 1; i <= maxint; i++) {\n  calculateMAE(Ri, Mi)\n  if (MAE(Ri, Mi) < t)\n    TPS++;\n  else\n    FNS++;\n}\ndouble FNR = FNS / (FNS + TPS);\nwrite(FNR);\n\\end{lstlisting}\n\n\\subsection{Individual Sensor Results}\n\nThe aim of our evaluation is to investigate to what extent legitimate and illegitimate transactions can be identified using these similarity metrics.  For a transaction between two co-located devices, the $MAE(R_{i}, M_{i}) \\approx 0$ and $corr(R_{i}, M_{i}) \\approx 1$, while for a terminal and mobile device in differing locations, i.e.\\ $(R_{i}, M_{j})$, the distance and correlation should be sufficiently large.  What is considered `sufficient' is determined through finding a suitable threshold, $t$, which permits all legitimate transactions while denying those which are illegitimate, i.e.\\ $similarity(R_{i}, M_{i}) < t$ and $similarity(R_{i}, M_{j}) > t$, as mentioned previously.  For each individual sensor, we aim to find an optimal value of $t$, along with its reliability.\n\n\\begin{figure}[ht]\n\t\\centering\n\t\t\\includegraphics[width=0.70\\columnwidth]{images/EER_Accelerometer.eps}\n\t\\caption{FPR and FNR Graph for an Accelerometer-based Transactions using $MAE(R_i,M_i)$}\n\t\\label{fig:EERAmbientSensor}\n\\end{figure}\n\nWe generate FPR and FNR curves for $MAE$ and $corr$ for every sensor we were able to collect data.  The point of intersection for these curves provides an optimal threshold for $MAE$ and $corr$ based on its associated EER, i.e. the rate at which the acceptance and rejection errors are equal. Figure \\ref{fig:EERAmbientSensor} shows the FPR and FNR curves for the accelerometer (based on $MAE$ calculations), along with the optimum threshold and EER\\@. Appendix \\ref{sec:AmbientSensors} includes the EER graphs for all of the tested sensors (except Accelerometer), based on both $MAE$ and $corr$. \n\nFigure \\ref{fig:EERAmbientSensor} illustrates that the optimum threshold (based on the $MAE$) is 0.651, with an associated EER of 0.506.  A threshold of 0.651ms$^{-2}$, therefore, one can expect the proportion of false positives and false negatives to be 50.6\\%.\n\n\\begin{figure}[ht]\n\t\\centering\n\t\t\\includegraphics[width=0.70\\columnwidth]{images/EER_Accelerometer_corr.eps}\n\t\\caption{FPR and FNR Graph for Accelerometer-based Transactions using $corr(R_i, M_i)$}\n\t\\label{fig:EERAmbientSensorcorr}\n\\end{figure}\n\nSimilarly, for correlation, Figure \\ref{fig:EERAmbientSensorcorr} shows that the EER (0.523) produces an optimal threshold of 0.007.  If we use the $corr$ as the comparison criterion, the rate of false positives and negatives is approximately 52\\%.  Table \\ref{tab:OptimumThresholds} lists the optimum thresholds and associated EERs for each tested sensor. \n\nIn a wide-scale deployment of an ambient sensing proximity detection mechanism, a single threshold ought to be defined.  The terminal itself would store this threshold, and if the similarity of the terminal's and device's sensor readings was within this, then the transaction would be assumed to be legitimate, i.e. both devices in close proximity.   However, setting a threshold of this nature invariably incurs some rate of false positives and false negatives.  The intersection of FPR and FNR provides us with the proportion of potentially malicious transactions might passing as genuine (false positives) and the proportion of genuine transactions being rejected (false negatives). The goal of a malicious entity would be to carry out relay attacks such that the sensor measurements at the terminal and mobile phone remained within the predefined threshold.  A threshold with a higher FPR provides a large working space to the attacker, whereas a higher FNR will reduce the usability of the scheme, potentially frustrating consumers by rejecting legitimate transactions. \n\n\\begin{table}[ht]\n\t\\centering\n\t\\caption{Optimum Thresholds and Associated Risk for Each Sensors}\n\t\\label{tab:OptimumThresholds}\n\t\\resizebox{0.75\\columnwidth}{!}{\n    \\begin{threeparttable}\n\t\t\t\\begin{tabular}{@{}lcccc@{}}\n\t\t\t\t\\toprule\n\t\t\t\t\\multirow{2}{*}{\\textbf{Sensors}} & \\textbf{Optimum} & \\multirow{2}{*}{\\textbf{$EER_{MAE}$}} & \\textbf{Optimum} & \\multirow{2}{*}{\\textbf{$EER_{corr}$}} \\\\ \n                \t\t\t\t\t\t\t\t  & \\textbf{Threshold$_{MAE}$} & & \\textbf{Threshold$_{corr}$}& \\\\\n                                                  \\midrule\n\t\t\t\t\\textbf{Accelerometer} & 0.651 & 0.506 & 0.007 & 0.523 \\\\\n\t\t\t\t\\textbf{Bluetooth} & -- & -- & -- & -- \\\\\n\t\t\t\t\\textbf{GRV} & 0.499 & 0.615 & 0.006 & 0.518 \\\\\n\t\t\t\t\\textbf{GPS} & -- & -- & -- & -- \\\\\n\t\t\t\t\\textbf{Gyroscope} & 0.520 & 0.504 & 0.007 & 0.752 \\\\\n\t\t\t\t\\textbf{Magnetic Field} & 77.33 & 0.334 & 0.235 & 0.582 \\\\\n\t\t\t\t\\textbf{Network Location} & 8.532 & 0.369 & N/A$^\\ast$ & N/A \\\\\n\t\t\t\t\\textbf{Pressure} & 2.787 & 0.270 & 0.329 & 0.645 \\\\\n\t\t\t\t\\textbf{Rotation Vector} & -- & -- & -- & -- \\\\\n\t\t\t\t\\textbf{Sound} & 10.19 & 0.395 & -0.087 & 0.524 \\\\\n\t\t\t\t\\textbf{WiFi} & -- & -- & -- & -- \\\\\n\t\t\t\t\\textbf{Gravity} & 9.5e-05 & 0.506 & 0.020 & 0.534 \\\\\n\t\t\t\t\\textbf{Light} & 178.5 & 0.518 & 0.020 & 0.515 \\\\\n\t\t\t\t\\textbf{Linear Acceleration} & 1.348 & 0.514 & 0.087 & 0.491 \\\\\n\t\t\t\t\\textbf{Proximity} & N/A$^\\dag$ & N/A & N/A & N/A \\\\\n\t\t\t\t\\bottomrule\n\t\t\t\\end{tabular}\n            \n            \\begin{tablenotes}\n            \t\\item $^\\ast$Insufficient data to calculate correlation\n                \\item $^\\dag$All transactions contained the same value for both devices.  Consequently, EER is undefined.\n            \\end{tablenotes}\n            \\end{threeparttable}\n            }\n\\end{table}\n\nBesides investigating the EERs of sensors and the effect this has on their suitability for NFC mobile services, we evaluate the reliability and potential usability of the selected sensors.   This analysis, shown in Table \\ref{tab:UsabilityandReliability}, presents our findings regarding the proportion of failed transactions and sensor failures.\n\n\\begin{table}[ht]\n\t\\centering\n\t\\caption{Usability and Reliability Analysis of Each Sensor}\n\t\\label{tab:UsabilityandReliability}\n\t\\resizebox{0.75\\columnwidth}{!}{\n\t\t\t\\begin{tabular}{@{}lccc@{}}\n\t\t\t\t\\toprule\n\t\t\t\t\\multirow{2}{*}{\\textbf{Sensors}} & \\textbf{Total} &\\textbf{Transaction} & \\textbf{Sensor} \\\\ \n                                                  & \\textbf{Transactions}& \\textbf{Failures} &  \\textbf{Failures}\\\\\n                \t\t\t\t\t\t\t\t  \\midrule\n\t\t\t\t\\textbf{Accelerometer} & 1025 & 13 (1.26\\%) & 0 (0\\%) \\\\\n\t\t\t\t\\textbf{Bluetooth} & 101 & 1 (0.99\\%) & 99 (99\\%) \\\\\n\t\t\t\t\\textbf{GRV} & 1019 & 8 (0.78\\%) & 0 (0\\%) \\\\\n\t\t\t\t\\textbf{GPS} & 101 & 1 (0.99\\%) & 100 (100\\%) \\\\\n\t\t\t\t\\textbf{Gyroscope} & 1022 & 11 (1.07\\%) & 0 (0\\%) \\\\\n\t\t\t\t\\textbf{Magnetic Field} & 1027 & 17 (1.65\\%) & 0 (0\\%) \\\\\n\t\t\t\t\\textbf{Network Location} & 1053 & 15 (1.42\\%) & 960 (96\\%) \\\\\n\t\t\t\t\\textbf{Pressure} & 1018 & 10 (0.98\\%) & 0 (0\\%)\\\\\n\t\t\t\t\\textbf{Rotation Vector} & 1023 & 14 (1.36\\%) & 0 (0\\%)\\\\\n\t\t\t\t\\textbf{Sound} & 1047 & 4 (0.38\\%) & 0 (0\\%) \\\\\n\t\t\t\t\\textbf{WiFi} & 100 & 0 (0\\%)&  100 (100\\%)\\\\\n\t\t\t\t\\textbf{Gravity} & 1165 & 143 (12.27\\%) & 0  (0\\%)\\\\\n\t\t\t\t\\textbf{Light} & 1057 & 37 (3.50\\%) & 0  (0\\%)\\\\\n\t\t\t\t\\textbf{Linear Acceleration} & 1175 & 159 (13.53\\%) & 3 (0.3\\%)\\\\\n\t\t\t\t\\textbf{Proximity} & 1071 & 58 (5.41\\%) & 0  (0\\%)\\\\\n\t\t\t\t\\bottomrule\n\t\t\t\\end{tabular}\n            }\n\\end{table}\n\nTo collect 1000 transactions from 252 users (for each sensor), as explained in Section \\ref{datacollectionsection}, we requested each user to present the mobile device to the terminal as many times as they preferred.  At times, transactions were not registered during this process, usually due to the user moving the handset away too quickly, and was the primary cause of transaction failures\\footnote{These failed transactions were not included in the data analysis and results represented in Table 4, which is based on successful 1000 transactions.} (no shared measurements between the terminal and device) represented in Table \\ref{tab:UsabilityandReliability}. The rate of sensor failures, in the same table, represents the situation when the transaction was successfully completed on both the terminal and mobile handset, but where one or both devices failed to record any data in the 500ms timeframe.  The percentage of transaction failures relates to the total transactions, while sensor failures is measured with respect to the number of successful transactions.  The transactions failure represents the difficulty in using the sensors by the user, while the sensor failure rates reflects the reliability of each sensor.\n\n\\section{Outcome and Future Directions}\n\\label{AntiRelayMechanismandAmbientSensorsTheVerdict}\n\nThe results we present provide us with an empirical foundation for evaluating the suitability of various mobile sensors as a proximity detection mechanism for NFC-based mobile transactions.  As discussed in the previous section, the higher the EER, the greater the likelihood that an attack passes undetected and that a genuine transaction is rejected.  Based on our analysis, it is difficult to recommend any of the sensors (individually) for a high security deployment application, like banking.  These sensors, however, might be appropriate for access control, but we recommend that a thorough analysis of the sensors and their performance in the chosen domain is performed prior to deployment.\n\nOne potential reason that related research in this domain has achieved different results is due to the larger sampling durations and limited field tests.  The sample duration limit imposed during our experiments were in line with the performance requirements of an EMV application, i.e.\\ 500 milliseconds.  One of the biggest application areas of contactless smart cards, along with banking, is transport.  In this domain, the recommended duration for a transactions is far lower, in the range of 300--400 milliseconds.  Imposing a limit of 500 millisecond in our experiments, therefore, was based on the upper bound of the recommendations of two significant application areas where contactless mobile phones might be utilised. \n\nDuring our experiments, we realised that sensors and their associated platforms may not have the maturity and standardisation required for a wide-scale deployment as a proximity detection mechanism for NFC-enabled phones.  The variations in sensor readings across devices, how the platform's sensor architecture is affected by other applications running simultaneously, and differences in minimum sampling rates may vary between mobile device manufacturers.  We consider that mobile sensors have a considerable way to go before achieving the necessary interoperability, standardised specifications, and performance requirements to prevent relay attacks.\n\nFrom the work carried out and the results presented in this paper, we can claim with a high degree of confidence that mobile sensors, at least in their current state on Google Android devices, are not suitable for use as an anti-relay mechanism.  Especially in the case of applications with high security requirements, such as banking, transport and access-control at highly sensitive sites. \n\n\n\n\n\n\n\n\n\n\n\\section{Conclusion}\n\n \n \nThe aim of the paper was to evaluate and analyse a range of sensors present in modern day mobile devices, and determining which sensors, if any, would be suitable as a proximity detection mechanism in the domain of NFC mobile phone transactions.  We shortlisted 17 sensors accessible through the Google Android platform, before limiting it to those which are widely-available.  In existing literature, only five sensors have been proposed as an effective proximity detection mechanism by authors listed in Table 1. In this paper, we extend this with ten additional sensors by evaluating their suitability and effectiveness as a proximity detection mechanism on NFC-enabled mobile devices.  In total, we implemented and evaluated 15 sensors; three sensors WiFi, Bluetooth and GPS were dropped after initial tests as they were showing high sensor failure rates.  The scope of our analysis focuses on NFC-enabled mobile devices that emulate traditional smart card services, such as transportation and banking.  Any analysis or recommendation regarding these sensors is restricted to this particular domain, and we have neither evaluated nor claimed that similar results will be produced in other deployment scenarios of mobile sensors. \n\nThe experimentation and analysis carried out as part of this paper showed that none of the sensors individually would be sufficiently secure and usable to be deployed as an proximity detection mechanism for NFC-based mobile transactions.  It may be argued that these sensors might be suitable for low-risk application environments.  Before doing so, however, the developer ought to consider the risks highlighted in this paper, i.e.\\ EER rates at optimum thresholds.  For each sensor, we provide an EER graph that indicates the effectiveness of the respective sensor and their associated risk if it was deployed.  From the data we have analysed we can safely claim that mobile sensors, in their current state in most of the Google Android devices, may not be suitable for deployment as a anti-relay mechanism.\n\nFinally, we will make the source code of our test-bed publicly available, along with our collected data sets, for open scrutiny and further analysis.\n\n\n\n\n\n\n\n\n\n\n\n\\bibliographystyle{abbrv}\n\\bibliography{paper}  \n\n\n\n\n\n\n\n\n\n\n\\appendix\n\n\\section{Ambient Sensors}\n\\label{sec:AmbientSensors}\nThis appendix provides a short description of each sensor. \n\n\\subsection{Accelerometer}\nThe accelerometer sensor -- deployed in most modern smartphones -- measures the acceleration applied to the device on the $x$, $y$ and $z$ axes; its units are metres per second per second ($ms^{-2}$). The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure~\\ref{fig:EERAmbientSensor} and \\ref{fig:EERAmbientSensorcorr} respectively.\n\n\\subsection{Bluetooth}\nBluetooth is a technology that facilitates wireless communication and operates in the ISM band centred at 2.4 gigahertz.  As a proximity sensor, we measure the Bluetooth devices in the vicinity (their names and MAC addresses).\n\n\n\n\\subsection{Geomagnetic Rotation Vector (GRV)}\nThe GRV sensor measures the rotation of the device using the device's magnetometer and accelerometer; it returns a vector containing the angles that the device is rotated in the $x$, $y$ and $z$ axes. The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EERGRV} and \\ref{fig:EERGRVcorr} respectively.\n\n\\subsection{Global Positioning System (GPS)}\nThe GPS sensor based a satellite-based global positioning and velocity measurement. A latitude and longitude pair is returned, representing a geographical location on Earth.\n\n\n\\subsection{Gravity}\nThe gravity sensor on mobile handsets measures the effect of Earth's gravity on the device, measured in metres per second per second ($ms^{-2}$). The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EERGravity} and \\ref{fig:EERGravitycoor} respectively.\n\n\\subsection{Gyroscope}\nThe gyroscope measures the rate of rotation of the device about the $x$, $y$ and $z$ axes; its units are radians per second ($rads^{-1}$).  The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EERGyroscope} and \\ref{fig:EERGyroscopecoor} respectively.\n\n\\subsection{Light}\nThe light sensor measures the lighting conditions surrounding the mobile handset.  Android measures this quantity in $lux$.  The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EER_Light} and \\ref{fig:EER_Light_corr} respectively.\n\n\\subsection{Linear Acceleration}\nThe linear acceleration sensor measures the affect of a device's movement on itself; its units are metres per second per second ($ms^{-2}$). The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EER_LinearAcceleration} and \\ref{fig:EER_LinearAcceleration_corr} respectively.\n\n\\subsection{Magnetic Field}\nThe magnetic field sensor detects the Earth's magnetic field along three perpendicular axes $x$, $y$ and $z$.  Android measures these values in microteslas ($\\mu T$).  The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EER_MagneticField} and \\ref{fig:EER-Corr_MagneticField_corr} respectively.  \n\n\\subsection{Network Location}\nA latitude and longitude pair is returned, representing a geographical location on Earth.  The EER graphs based on the $MAE(R_i, M_i)$ is represented in Figure \\ref{fig:EER_NetworkLocation}.\n\n\\subsection{Pressure}\nThe pressure sensor measures the atmospheric pressure surrounding the mobile handset. It is measured in hectopascals ($hPa$).\nThe EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EER_Pressure} and \\ref{fig:EER-Corr_Pressure_corr} respectively.\n\n\\subsection{Proximity}\nThe proximity sensors detects distance, measured in centimetres.\nIn many devices the sensor returns only a boolean value, declaring whether something is in close proximity to the device or not.\n\n\n\n\\subsection{Rotation Vector}\nRotation vector is a software sensor, similar to the GRV, but also incorporates the gyroscope. The returned values represent the angles which the device has rotated through the $x$, $y$ and $z$ axes.\n\n\n\\subsection{Sound}\nFor the sound sensor's measurement, we use the device's microphone to record the noise in the vicinity of the mobile handsets and retrieve the maximum amplitude that was sampled, every time it becomes available by the Android operating system. The EER graphs based on the $MAE(R_i, M_i)$ and $corr(R_i, M_i)$ are represented in Figure \\ref{fig:EER_Sound} and \\ref{fig:EER_Sound_corr} respectively.\n\n\\subsection{WiFi}\nThis sensor uses traditional WiFi to detect the networks in the vicinity of the mobile device.  The MAC addresses and ESSIDs of the nearby networks are returned.\n\n\n\\begin{figure*}[h]\n\\caption{FPR and FNR Graphs}\\label{fig:GRV_Results}\n    \\centering\n\\begin{xtabular*}{\\textwidth}{cl}\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_GeomagneticRotationVector.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EERGRV}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_GeomagneticRotationVector_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EERGRVcorr}\n    \\end{subfigure}\n \\\\\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Gravity.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EERGravity}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Gravity_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EERGravitycoor}\n    \\end{subfigure}  \n \\\\\n     \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Gyroscope.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EERGyroscope}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Gyroscope_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EERGyroscopecoor}\n    \\end{subfigure}\n\\end{xtabular*}\n\\end{figure*}\n\n\\addtocounter{figure}{-1}\n\\begin{figure*}[h]\n    \\centering\n\\begin{xtabular*}{\\textwidth}{cl}\n    \\begin{subfigure}[b]{0.45\\textwidth}\n\t\t\\addtocounter{subfigure}{6}\n        \\includegraphics[width=\\textwidth]{images/EER_Light.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_Light}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Light_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EER_Light_corr}\n    \\end{subfigure}\n\\\\\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_LinearAcceleration.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_LinearAcceleration}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_LinearAcceleration_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EER_LinearAcceleration_corr}\n    \\end{subfigure}  \n    \\\\\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_MagneticField.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_MagneticField}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_MagneticField_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EER-Corr_MagneticField_corr}\n    \\end{subfigure}\n\\end{xtabular*}\n\\end{figure*}\n\n\\addtocounter{figure}{-1}\n\\begin{figure*}[h]\n    \\centering\n\\begin{xtabular*}{\\textwidth}{cl}\n    \\multicolumn{2}{c}{\n    \\begin{subfigure}[b]{0.45\\textwidth}\n\t\t\\addtocounter{subfigure}{12}\n        \\includegraphics[width=\\textwidth]{images/EER_NetworkLocation.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_NetworkLocation}\n    \\end{subfigure}\n    }\n \\\\\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Pressure.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_Pressure}\n        \\end{subfigure}\n &\n     \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Pressure_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EER-Corr_Pressure_corr}\n    \\end{subfigure}\n \\\\\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Sound.eps}\n        \\caption{Based on $MAE(R_i,M_i)$}\n        \\label{fig:EER_Sound}\n    \\end{subfigure}\n    &\n    \\begin{subfigure}[b]{0.45\\textwidth}\n        \\includegraphics[width=\\textwidth]{images/EER_Sound_corr.eps}\n        \\caption{Based on $corr(R_i,M_i)$}\n        \\label{fig:EER_Sound_corr}\n    \\end{subfigure}\n    \\end{xtabular*}\n  \n    \\end{figure*}\n\n\\section{Technical limitations in sensors}\n\\label{sec:appendixB}\n\n\\begin{itemize}\n\t\\item \\textbf{Bluetooth:} Very few times (<5\\% of all measurements) data was returned in the 500ms timeframe on all devices.\n    \\item \\textbf{Geomagnetic Rotation Vector:} Although the sensor is present on Nexus 5, no data was returned from it.\n    \\item \\textbf{GPS:} No data is returned in the 500ms timeframe on any of the devices used in our experiments.\n    \\item \\textbf{Light:} The Nexus 9 tablets return a limited amount of values, in large intervals.\n    Although the sensor was functioning, the mobile devices were chosen for the experiments, as they produce a much wider range of values and higher accuracy.\n    \\item \\textbf{Rotation Vector:} There were inconsistencies in the readings recorded on any of the possible pairs, therefore the sensor could not be evaluated properly.  This includes the two Nexus 9 tablets, although they were the same model and were running the same version of the operating system.  Finally, the Nexus 5 did not return any results, although the sensor is present on the device.\n    \\item \\textbf{Sound:} No data is returned in the 500ms timeframe on the SGS5 mini.\n    \\item \\textbf{WiFi:} No data is returned in the 500ms timeframe on any of the devices used in our experiments.\n\\end{itemize}\n\n\n\n\n", "itemtype": "equation", "pos": 32464, "prevtext": "\n\n\n", "index": 7, "text": "\\begin{equation}\ncorr(R_{i}, M_{i}) = \\frac{covariance(R_{i}, M_{i})}{\\sigma_{R_{i}} \\cdot \\sigma_{M_{i}}}\n\\label{correq}\n\\end{equation}\n", "mathml": "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" id=\"S0.E4.m1\" class=\"ltx_Math\" alttext=\"corr(R_{i},M_{i})=\\frac{covariance(R_{i},M_{i})}{\\sigma_{R_{i}}\\cdot\\sigma_{M_%&#10;{i}}}\" display=\"block\"><mrow><mrow><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><mi>i</mi></msub><mo>,</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mo>=</mo><mfrac><mrow><mi>c</mi><mo>\u2062</mo><mi>o</mi><mo>\u2062</mo><mi>v</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>r</mi><mo>\u2062</mo><mi>i</mi><mo>\u2062</mo><mi>a</mi><mo>\u2062</mo><mi>n</mi><mo>\u2062</mo><mi>c</mi><mo>\u2062</mo><mi>e</mi><mo>\u2062</mo><mrow><mo stretchy=\"false\">(</mo><msub><mi>R</mi><mi>i</mi></msub><mo>,</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow></mrow><mrow><msub><mi>\u03c3</mi><msub><mi>R</mi><mi>i</mi></msub></msub><mo>\u22c5</mo><msub><mi>\u03c3</mi><msub><mi>M</mi><mi>i</mi></msub></msub></mrow></mfrac></mrow></math>", "type": "latex"}]